<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting started in STM32CubeMX. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 3 

 Last time, we learned how to create a new project in STM32CubeMX, set up a clock generator, a timer and an I / O port, and a little...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting started in STM32CubeMX. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/310742/">Part 1</a> <br>  <a href="https://habrahabr.ru/post/323674/">Part 3</a> <br><br>  <a href="https://habrahabr.ru/post/310742/">Last time,</a> we learned how to create a new project in STM32CubeMX, set up a clock generator, a timer and an I / O port, and a little bit flashed the LED.  Today we will master the digital-to-analog converter and learn how to work with it through DMA.  As a result, we should have a simple direct synthesis (Direct digital synthesizer, DDS) generator. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e86/af6/2f1/e86af62f124947e38c0c827cb45c0e6e.jpg"></div><br><a name="habracut"></a><br><h3>  Work with DAC </h3><br>  Most of the STM32 microcontrollers are equipped with 12-bit DAC in the amount of one or two pieces.  The DAC architecture is the same in all crystals, no matter which core ARM Cortex M is used there.  Thus, today's experiment can be performed on any STM32 microcontroller with at least one DAC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the frequency of DAC conversion?  The answer to this question is not quite simple.  If you want more details, I recommend these two documents: <a href="https://habr.com/ru/post/312810/">[1]</a> <a href="https://habr.com/ru/post/312810/">[2]</a> <br><br>  To summarize, it is as follows: the DAC itself can update the output with a frequency of up to 5 MSPS (mega-samples per second), but the buffer operational amplifier (OU) at the output will not provide this speed, limiting it to 1 MSPS.  If we want more, we need an external op-amp, to which some requirements are imposed on the frequency characteristics, which will be discussed below.  It is impossible to use the buffer DU DAC, since it has a rather large output impedance (&gt; 10 kŒ©). <br><br><h3>  Some circuitry </h3><br>  At a frequency higher than a hundred kilohertz, the built-in buffer amplifier begins to introduce significant distortions into the signal, so I immediately put an external buffer amplifier at the output that satisfies ST recommendations. <br><br>  To achieve a 5MSPS conversion rate, ST recommends using an OU with a unit amplification frequency of at least 10 MHz, a gain with open-loop feedback of at least 60 dB, and an slew rate of output of at least 16.5 V / Œºs.  ST recommends as an example the Shelter LMH6645 / 6646/6647 manufactured by Texas Instruments. <br><br>  I used the AD845JN opamp, which has a single gain frequency of 16 MHz, a typical gain value of 500 V / mV (about 114 dB) and a slew rate of 100 V / Œºs.  Power is supplied from the DC / DC converter 5 V / ¬± 9 B. You can power the buffer amplifier with unipolar power, for example, by taking 5 V directly from the board, but then you will need a rail-to-rail amplifier.  Connection diagram is shown in Fig.  one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8d5/00e/20e/8d500e20e85a4b0aaa7c94fa3ca6d118.jpg"></div><br>  <em>Fig.</em>  <em>1. Diagram of the output buffer amplifier</em> <br><br>  I didn‚Äôt do a special board, I mounted it with a wire on a breadboard board, which is inserted into an arduino-compatible footprint for debugging. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/709/594/76f/70959476ff8444a68dded53bf92dbae9.jpg"></div><br>  <em>Fig.</em>  <em>2. View of the buffer amplifier board</em> <br><br>  The internal buffer amplifier of the microcontroller begins to introduce noticeable non-linear distortions already starting at a frequency of 100-150 kHz.  If you are not going to use the DAC to generate signals above these frequencies, you can do without a buffer. <br>  Now go to the software part. <br><br><h3>  DAC configuration </h3><br>  We will assume that we are already able to create a project in CubeMX, choose a microcontroller and adjust the clock generator, as in the first part.  You can simply take the project from the first part and continue it. <br><br>  On the board I use, the DAC outputs are not very conveniently output, unfortunately, DAC_OUT1 (pin N4) is connected to the DCMI connector, DAC_OUT2 (pin P4) is connected to the USB interface and can hardly be used as a DAC output.  Therefore, only DAC_OUT1 remains.  Enable it in the Pinout tab: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4ed/481/8fa/4ed4818fa1834f18a133709d228f35a9.jpg"></div><br>  In the Configuration tab, the DAC has only one interesting setting for us: Output Buffer.  If you do not use an external amplifier, it must be turned on; if you use it, it is turned off. <br><br>  You can control the output of the DAC "manually" from the program, you can use DMA.  The second method is well suited for generating a periodic signal of an arbitrary shape, and we will look at it below, and now we are using the first method.  Just set the output voltage uninteresting, try to generate a signal.  For this we need a timer.  We do everything as in the first part, only the frequency of the timer is set more, for example, 500 kHz.  To do this, set Prescaler = 215, then we get 216 MHz / (215 + 1) = 1 MHz, and Counter Period = 1, which will give 1 MHz / (1 + 1) = 500 kHz.  I remind you that 216 MHz is the peripheral clocking frequency in our clocking system configuration. <br><br><h3>  Signal generation from interrupt handler </h3><br>  We generate the code, open the project and enter the following: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_TIM_PeriodElapsedCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (htim-&gt;Instance==TIM1) <span class="hljs-comment"><span class="hljs-comment">//check if the interrupt comes from TIM1 { HAL_DAC_SetValue(&amp;hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, val); val = val? 0: 4095; } } /* USER CODE END 0 */ ... /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(&amp;htim1); __HAL_DAC_ENABLE(&amp;hdac, DAC_CHANNEL_1); /* USER CODE END 2 */</span></span></code> </pre> <br>  Once again I remind you that all user code is written between lines of the form / * USER CODE BEGIN ... * / ... / * USER CODE END ... * / <br><br>  The first piece of code is the timer interrupt handler, in which 0 and 4095 are written alternately in the DAC register, that is, the minimum and maximum DAC values.  The second section of the code includes a timer and DAC.  We obtain rectangular oscillations with a frequency of 250 kHz, but due to the distortions introduced by the buffer amplifier, they look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/985/c72/e4b/985c72e4baf4484fb7009c314e36456e.png"></div><br>  It's time to use the external buffer, disabling the internal one.  To do this, go to the Configuration tab in STM32CubeMX, click the DAC button, and on the Parameter Settings tab, set Output Buffer = Disable.  Re-generate the code and flash into the board.  Now the pulses look like a meander passed through the low-pass filter (due to the fact that the system bandwidth is still limited): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6b8/160/dd4/6b8160dd43c948be92fa818b40eeb6d0.png"></div><br>  You can even approximately estimate the cutoff frequency of the low pass filter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/401/95f/9be/40195f9bed7a4fefa263cb0238849077.jpg"></div><br>  The method is clear from the figure: draw a tangent to the exponent until the intersection with the upper signal level.  The distance on the time scale from the beginning of the pulse to the intersection will be the filter time constant œÑ = 400 ns, the cutoff frequency is fc = 1 / 2œÄœÑ ‚âà 0.4 MHz. <br><br>  Let's try to double the frequency, reducing the Prescaler to 107, but disappointment awaits us: the frequency does not rise above 333 kHz.  Probably need some code optimization. <br><br>  In fact, the greatest delay is introduced by the huge timer interrupt handler in the depths of the HAL (HAL_TIM_IRQHandler function).  You can replace it with your own.  To do this, find the file stm32f7xx_it, and in it we change the function TIM1_UP_TIM10_IRQHandler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIM1_UP_TIM10_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* TIM Update event */</span></span> __HAL_TIM_CLEAR_IT(&amp;htim1, TIM_IT_UPDATE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (htim1.Instance==TIM1) { *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(DAC_BASE + <span class="hljs-number"><span class="hljs-number">0x00000008</span></span>U) = val; val = val? <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">4095</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END TIM1_UP_TIM10_IRQn 0 */</span></span> HAL_TIM_IRQHandler(&amp;htim1); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN TIM1_UP_TIM10_IRQn 1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END TIM1_UP_TIM10_IRQn 1 */</span></span> }</code> </pre><br>  HAL_TIM_IRQHandler is no longer called.  Now the timer frequency can be raised to 2 MHz, and the frequency of the meander, respectively, to 1 MHz.  To do this, in the timer settings, set the value to Prescaler = 53, and then we get the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/006/557/ad2/006557ad2bc94abe994123d1405e5487.jpg"></div><br>  This is probably the maximum frequency achievable on this microcontroller. <br><br>  The HAL library is, of course, a handy thing, but inside it there are many different actions that can be avoided.  It should just be remembered that premature optimization is evil, and resorting to it only when we have reached the limit, like this time. <br><br>  Another nuance.  We can notice that sometimes strange jumps with a period of 1ms occur in the signal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d4/5d8/237/4d45d823704746b98d5496c36589b01f.jpg"></div><br>  They are obtained as a result of the fact that we have another interrupt in the system, which has a higher priority than our timer.  It is hidden inside the HAL, and this is the SysTick system timer, which has the highest (zero) interrupt priority.  To correct the situation, go to STM32CubeMX-&gt; Configuration-&gt; NVIC-&gt; Time base: System Tick Timer-&gt; Preeption Priority = 1. Re-generate the code, the signal distortions have disappeared. <br><br>  Let's try to generate a sinusoidal signal.  For this, we need an array of N values, filled with the values ‚Äã‚Äãof the round (A * cos ((pi / 2) * (n / N))) function, where A is the signal amplitude, N is the number of points in the array, n is the point number.  During the output, we shift the points by shift = 2048, let the amplitude be A = 2047, then the DAC values ‚Äã‚Äãwill be from 1 to 4095. The array can be filled only for a quarter of the period, from 0 to pi / 2, and the missing values ‚Äã‚Äãwill be obtained from it by obvious arithmetic action.  Why use the cosine function, not the sine, I will write further. <br><br>  How to choose N?  On the one hand, the more N, the better, the values ‚Äã‚Äãwill be closer to the exact values, on the other hand, the limited DAC capacity makes such an increase useless after the value [A * pi / 2] = 3215. In fact, with N = 3215 the increment of the angle will be pi / (2 * 3215) = 4.89e-4, and the increment of the amplitude near the middle of the scale, where the growth rate is maximum, will be 4.89e-4 * 2047 = 1 discrete DAC. <br><br>  We can generate an array in advance and place it in flash-memory, we can generate it at run-time during initialization.  The first method is preferable for practical use, but we will use the second for greater clarity: <br><br>  I want the array and signal conditioning to occur in main, so we change the interrupt handler code in the stm32f7xx_it file to the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIM1_UP_TIM10_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* TIM Update event */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(__HAL_TIM_GET_FLAG(&amp;htim1, TIM_FLAG_UPDATE) != RESET) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(__HAL_TIM_GET_IT_SOURCE(&amp;htim1, TIM_IT_UPDATE) !=RESET) { __HAL_TIM_CLEAR_IT(&amp;htim1, TIM_IT_UPDATE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (htim1.Instance==TIM1) { HAL_TIM_PeriodElapsedCallback(&amp;htim1); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END TIM1_UP_TIM10_IRQn 0 */</span></span> HAL_TIM_IRQHandler(&amp;htim1); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN TIM1_UP_TIM10_IRQn 1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END TIM1_UP_TIM10_IRQn 1 */</span></span> }</code> </pre><br>  Now the ‚Äúslow‚Äù function HAL_TIM_IRQHandler () is not called, but HAL_TIM_PeriodElapsedCallback is called in main.  In the main write the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"math.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span></span><span class="hljs-meta"> volatile uint32_t * dac; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N 3216 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DAC_SHIFT 2047 static uint16_t cosine[N]; const int delta = 1; void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { static int val = 0; static int phase = 0; *(uint32_t*)(DAC_BASE + 0x00000008U) = val; phase += delta; phase = phase &gt; N * 4 - 1 ? phase - N * 4 : phase; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(phase &lt; N) { val = DAC_SHIFT + cosine[phase]; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(phase &lt; 2 * N) { val = DAC_SHIFT - cosine[2 * N - 1 - phase]; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(phase &lt; 3 * N) { val = DAC_SHIFT - cosine[phase - 2 * N]; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { val = DAC_SHIFT + cosine[4 * N - 1 - phase]; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 0 */</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span></span></span><span class="hljs-meta"> const float A = 2047; const float PI = 3.1415927; for(int i = 0; i &lt; N; i++) { cosine[i] = (uint16_t)(round(A * cos((i * PI) / (N * 2.0)))); } HAL_TIM_Base_Start_IT(&amp;htim1); __HAL_DAC_ENABLE(&amp;hdac, DAC_CHANNEL_1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 2 */</span></span></span></span></code> </pre><br>  This code also contains the delta value, the phase increment.  By changing the delta, you can change the frequency of the signal over a wide range.  delta = 1 corresponds to the lowest frequency (and the best approximation of the sinusoidal function), the maximum value of delta, which makes sense in this case is 2 * N.  In this case, the output should be a meander, because  the phase alternately becomes 0, then pi, and the cosine values ‚Äã‚Äãare 1 and -1, respectively.  Therefore, we wrote down the cosine instead of sine into the array; with a sine, the function values ‚Äã‚Äãat these points would be 0, and we would not see any signal. <br><br>  In STM32CubeMX, we set the frequency of the 500 kHz timer operation, like this: Prescaler = 107, Counter Period = 3. We get a beautiful sinusoid with a frequency of 500e3 / (4 * 3216) = 38.868 Hz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/918/194/e7b/918194e7b4c34cd78adc17c3ee3cccde.jpg"></div><br>  The maximum frequency at these settings will be 250 kHz.  In this case, the signal will turn into a meander, we have already seen them.  Let's try to get 10 kHz.  To do this, we need to set delta - (1e4 / 2e5) * 4 * 3216 = 257.28.  Rounded to an integer value of 257, we obtain the calculated value of the frequency (5e3 * 257) / (4 * 3216) = 9989 Hz.  We get this picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/26e/9e3/baf/26e9e3baf97d442888327bced9ef618c.jpg"></div><br>  The difference with a frequency of 10 kHz is about 0.1%.  Is it possible to set the frequency more accurately?  It is possible, but for this you need to consider the phase as a float, but at this sampling rate (500 kHz) the microcontroller does not have time to count the phase as a float.  It is possible to reduce the clock frequency of the timer or try to manually optimize the code, but this is another story.  So far, the achieved accuracy suits us. <br><br><h3>  Work with DMA </h3><br>  The digital-to-analog converter (DAC) built into the STM32 microcontrollers can operate on timer signals and receive data directly from the memory array via DMA.  Thus, it is possible to configure the controller so that the DAC will work without the participation of the program, without wasting CPU resources, with the exception of system initialization. <br><br>  The disadvantage of the DMA method is that tricks with writing to a quarter-period array and calculating phase accumulation are impossible here.  We have to write the entire array into memory and specify the desired period.  The advantage, as already mentioned, is that when generating a signal through a DMA processor is free for other work. <br><br>  So, we will open a new project in STM32CubeMX, and we will do the procedure of configuration of a clock generator already familiar to us.  Now we set up the rest. <br><br>  DMA can call two timers: TIM6 and TIM7.  Enable TIM6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f6e/cb6/aae/f6ecb6aaea7f480fa2273566f32ecd02.jpg"></div><br>  Next, set the following settings: <br><br><img src="https://habrastorage.org/files/fd3/193/4db/fd31934db6614b149517df863dd98756.jpg"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b42/2fb/09d/b422fb09da034551a9956c1aabd3045a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cc3/d27/751/cc3d27751d8b49d48848b77fe5322a37.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3a2/142/887/3a214288712f4cf4b1de830ba570ea56.jpg"></div><br><img src="https://habrastorage.org/files/347/eca/c3c/347ecac3cb374d2380930d2ed1cf28f9.jpg"><br><br>  We generate the code, and paste the following into main: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"math.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//... /* USER CODE BEGIN 0 */ #define N 3216 static uint16_t sine[N * 4]; /* USER CODE END 0 */ int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration----------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* Configure the system clock */ SystemClock_Config(); /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_DMA_Init(); MX_TIM6_Init(); MX_DAC_Init(); /* USER CODE BEGIN 2 */ const float A = 2047; const float PI = 3.1415927; for(int i = 0; i &lt; N * 4; i++) { sine[i] = 2048 + (int16_t)(round(A * sin((i * PI) / (N * 2.0)))); } HAL_TIM_Base_Start(&amp;htim6); HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1); HAL_DAC_Start_DMA(&amp;hdac, DAC_CHANNEL_1, (uint32_t*)sine, N * 4, DAC_ALIGN_12B_R); /* USER CODE END 2 */</span></span></span></span></code> </pre><br>  Of course, we can make an array of a different size.  The size of the array should be passed to the HAL_DAC_Start_DMA function by the fourth parameter, after the array address. <br><br>  After launching the program, we should get a sine wave at the output, exactly the same as mentioned above, so I will not give a screenshot. <br><br>  That's all I wanted to write about working with the DAC. <br><br><h3>  What's next? </h3><br>  Next time we will briefly discuss the operation of the ADC and the USB interface. <br><br><a name="1"></a>  1. <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/05/fb/41/91/39/02/4d/1e/CD00259245.pdf/files/CD00259245.pdf/jcr:content/translations/en.CD00259245.pdf">AN3126</a> <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/05/fb/41/91/39/02/4d/1e/CD00259245.pdf/files/CD00259245.pdf/jcr:content/translations/en.CD00259245.pdf"><br></a>  <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/05/fb/41/91/39/02/4d/1e/CD00259245.pdf/files/CD00259245.pdf/jcr:content/translations/en.CD00259245.pdf">Application note "Audio and waveform generation using the DAC in STM32 microcontrollers"</a> <br><a name="2"></a>  2. <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/6f/35/61/e9/8a/28/48/8c/DM00129215.pdf/files/DM00129215.pdf/jcr:content/translations/en.DM00129215.pdf">AN4566</a> <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/6f/35/61/e9/8a/28/48/8c/DM00129215.pdf/files/DM00129215.pdf/jcr:content/translations/en.DM00129215.pdf"><br></a>  <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/6f/35/61/e9/8a/28/48/8c/DM00129215.pdf/files/DM00129215.pdf/jcr:content/translations/en.DM00129215.pdf">Application note "Extending the DAC performance of STM32 microcontrollers"</a> <br><br><h3>  PS </h3><br>  The examples given in the article were also implemented on the Nucleo F767ZI (microcontroller STM32F767ZI) board, in IDE Atollic TrueStudio.  They can be downloaded here: <a href="https://github.com/arktur04/stm32-habr">https://github.com/arktur04/stm32-habr</a> </div><p>Source: <a href="https://habr.com/ru/post/312810/">https://habr.com/ru/post/312810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312794/index.html">The digest of interesting materials for the Mobile Developer # 175 (October 10-16)</a></li>
<li><a href="../312796/index.html">Donald Knut: How the ‚ÄúArt of Programming‚Äù was created (33,38,39 / 97)</a></li>
<li><a href="../312800/index.html">Introducing 3CX V15 SP2 with Debian Linux 8 support</a></li>
<li><a href="../312806/index.html">How neural networks are now used: from research projects to entertainment services</a></li>
<li><a href="../312808/index.html">Project AirGig: Broadband Power Line Access</a></li>
<li><a href="../312814/index.html">Silicon Valley Etiquette</a></li>
<li><a href="../312816/index.html">Scrolling endlessly scrolling page</a></li>
<li><a href="../312818/index.html">A few thoughts on the job search algorithm</a></li>
<li><a href="../312820/index.html">Site to Zone Assignment list and Internet Explorer with Enhanced Security Configuration enabled</a></li>
<li><a href="../312822/index.html">Create and estimate the number of sudoku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>