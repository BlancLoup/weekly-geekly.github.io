<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>String Features in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The string data type is one of the most important in any programming language. It is hardly possible to write a useful program without using this data...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>String Features in .NET</h1><div class="post__text post__text-html js-mediator-article">  The string data type is one of the most important in any programming language.  It is hardly possible to write a useful program without using this data type.  However, many developers do not know some of the nuances associated with this type.  So let's look at some of the features of this type in .NET. <br><br><h4>  So, let's start by presenting strings in memory. </h4><br>  B.NET strings are arranged according to the BSTR rule (Basic string or binary string).  This way of representing string data is used in COM (the word basic from the programming language VisualBasic, in which it was originally used).  As it is known in C / C ++, PWSZ is used to represent strings, which stands for <b>Pointer to Wide-character String, Zero-terminated</b> .  With this location in memory at the end of the line is a null-terminated symbol, by which we can determine the end of the line.  The string length in PWSZ is limited only by the amount of free memory. <a name="habracut"></a><br><img src="https://habrastorage.org/storage2/5e4/425/6b9/5e44256b98b33c3596674b7f85820581.jpg"><br>  With BSTR, things are a little different. <br><img src="https://habrastorage.org/storage2/2a4/a7b/1a9/2a4a7b1a9e9a39dcd8f447cb1ab1dbf7.jpg"><br>  The main features of the BSTR inline memory string representation are: <br><br><ol><li>  The line length is limited to a certain number, unlike PWSZ, where the line length is limited by the availability of free memory. </li><li>  The BSTR line always points to the first character in the buffer.  PWSZ can point to any character in the buffer. </li><li>  In BSTR, the null character is always at the end, just like in PWSZ, but unlike the latter, it is a valid character and can appear anywhere in the string. </li><li>  Due to the presence of a null character at the end, BSTR is compatible with PWSZ, but not vice versa. </li></ol><br>  So, strings in .NET are represented in memory according to the BSTR rule.  The buffer contains a four-byte string length, followed by two-byte string characters in UTF-16 format, followed by two zero bytes (\ u0000). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using such an implementation has several advantages: the length of the string does not need to be recalculated; it is stored in the header, the string can contain null characters anywhere, and the most important address of the string (pinned) can be transferred to the unmanaged code without problems where WCHAR * is expected. <br><br>  Go ahead ... <br><br><h4>  How much memory does a string type object occupy? </h4><br>  I have met articles where it was written that the size of a string object is size = 20 + (length / 2) * 4, but this formula is not entirely correct. <br>  To begin with, the string is a reference type, so the first 4 bytes contain SyncBlockIndex, and the second 4 bytes contain a pointer to the type. <br><br>  <b>Line size = 4 + 4 + ...</b> <br><br>  As mentioned above, the length of the string is stored in the buffer - this is an int field, which means another 4 bytes. <br><br>  <b>Line size = 4 + 4 + 4 + ...</b> <br><br>  In order to quickly transfer a string to unmanaged code (without copying) at the end of each line there is a null-terminated character that takes 2 bytes, which means <br><br>  <b>Line size = 4 + 4 + 4 + 2 + ...</b> <br><br>  It remains to recall that each character in the string is in UTF -16 encoding means it also takes 2 bytes, therefore <br><br>  <b>String size = 4 + 4 + 4 + 2 + 2 * length = 14 + 2 * length</b> <br><br>  We take into account another nuance, and we have a goal.  Namely, the memory manager in the CLR allocates memory multiple of 4 bytes (4, 8, 12, 16, 20, 24, ...), that is, if the string length will take 34 bytes, then 36 bytes will be allocated.  We need to round our value to the nearest greater multiple of four, for this we need: <br><br>  <b>String size = 4 * ((14 + 2 * length + 3) / 4)</b> (division is naturally integer) <br><br>  <b>Version Question:</b> In .NET up to version 4, the String class stores an additional field m_arrayLength of type int, which takes 4 bytes.  This field is the actual length of the buffer allocated for the line, including null, the terminated character, that is, length + 1. In .NET 4.0, this field is removed from the class, with the result that the string type object is 4 bytes less. <br><br>  The size of the empty string without the m_arrayLength field (that is, in .NET 4.0 and above) is = 4 + 4 + 4 + 2 = 14 bytes, and with this field (that is, below .NET 4.0) it is = 4 + 4 + 4 + 4 + 2 = 18 bytes.  If rounded to 4 bytes, then 16 and 20 bytes, respectively. <br><br><h4>  String Features </h4><br>  So, we looked at how the lines are represented, and how much they actually take up space in the memory.  Now let's break down about their features. <br><br>  Main features of strings in .NET: <br><ol><li>  They are reference types. </li><li>  They are immutable.  Once, having created a string, we can no longer change it (honestly).  Each method call of this class returns a new line, and the previous line becomes a prey for the garbage collector. </li><li>  They override the Object.Equals method, with the result that it compares not the values ‚Äã‚Äãof the links, but the values ‚Äã‚Äãof the characters in the strings. </li></ol><br>  Consider each item in more detail. <br><br><h4>  Strings - Reference Types </h4><br>  Strings are real reference types, that is, they are always located in a heap.  Many people confuse them with meaningful types, because they behave as well, for example, they are immutable and their comparison occurs by value, not by reference, but it must be remembered that this is a reference type. <br><br><h4>  Strings are immutable </h4><br>  Strings are immutable.  This is done for a reason.  There are a lot of advantages in immutability of lines: <br><ul><li>  The string type is thread safe, since no thread can change the contents of a string. </li><li>  The use of unchanged lines leads to a reduction in memory load, since there is no need to store 2 instances of one line.  In this case, and less memory is spent, and the comparison is faster, as it requires a comparison only links.  The mechanism that this implements in .NET is called string interning (a pool of strings), let's talk about it a bit later. </li><li>  When passing an immutable parameter to a method, we need not worry that it will be changed (unless, of course, it was passed as a ref or out). </li></ul><br>  Data structures can be divided into two types - ephemeral and persistent.  Data structures that store only their latest version are called ephemeral.  Persistent structures are structures that retain all their previous versions when they change.  The latter are virtually immutable, since their operations do not change the structure in place; instead, they return a new one based on the previous structure. <br><br>  Given that strings are unchanged, they could be persistent, but they are not.  In .NET, strings are ephemeral.  Read more about why this is exactly the way you can read at Eric Lippert <a href="">link</a> <br><br>  For comparison, take the string Java.  They are immutable, as in .NET, but in addition and persistent.  The implementation of the String class in Java looks like this: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> value[]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash; ..... }</code> </pre> <br>  In addition to the same 8 bytes in the object header, including the link to the type and the link to the synchronization object, the lines contain the following fields: <br><ol><li>  A reference to an array of char characters; </li><li>  The index of the first character of the string in the char array (the offset of the beginning); </li><li>  The number of characters per line; </li><li>  The calculated hash code after the first call to the hashCode () method; </li></ol><br>  As you can see, strings in Java occupy more memory than in .NET, because they contain additional fields, which allow them to be persistent.  Due to persistence, the <b>String.substring ()</b> method in Java is executed in O (1), since it does not require copying the string as in .NET, where this method is executed in O (n). <br><br>  Implementing the String.substring () method in Java: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">substring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beginIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endIndex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (beginIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringIndexOutOfBoundsException(beginIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endIndex &gt; count) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringIndexOutOfBoundsException(endIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (beginIndex &gt; endIndex) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringIndexOutOfBoundsException(endIndex - beginIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((beginIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (endIndex == count)) ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(offset + beginIndex, endIndex - beginIndex, value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset = offset; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = count; }</code> </pre><br>  However, according to the principle of LDNB (there is no free lunch), which Eric Lippert so often says is not so good.  If the source string is large enough, and the substring to be cut is a couple of characters, the entire character array of the original string will hang in memory as long as there is a link to the substring or, if you serialize the received substring by standard means and transmit it over the network, the entire original array will be serialized and the number of bytes transmitted over the network will be large.  Therefore, in this case, instead of the code <br><br>  <b>s = ss.substring (3)</b> <br><br>  can use code <br><br>  <b>s = new String (ss.substring (3)),</b> <br><br>  which will not store a link to the array of characters of the source string, but will copy only the actually used part of the array.  By the way, if this constructor is called on a string of length equal to the length of the array of characters, then copying in this case will not occur, and the link to the original array will be used. <br><br>  As it turned out in the latest version of Java, the implementation of the string type has changed.  <a href="http://habrahabr.ru/users/xonix/" class="user_link">xonix</a> suggested this.  Now the class has no fields of offset and length, and a new hash32 (with a different hashing algorithm) has appeared.  This means that strings are no longer persistent.  Now the String.substring method will create a new string each time. <br><br><h4>  Strings override Object.Equals </h4><br>  The String class overrides the Object.Equals method, as a result of which the comparison occurs not by reference, but by value.  I think the developers are grateful to the creators of the String class for redefining the == operator, because the code that uses == to compare strings looks more elegant than a method call. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == s2)</code> </pre><br>  compared <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Equals(s2))</code> </pre><br>  By the way, in Java, the operator == compares by reference, but in order to compare strings, it is necessary to use the string.equals () method character-by-character. <br><br><h4>  String interning </h4><br>  Well, lastly let's talk about interning strings. <br>  Consider a simple example, code that reverses a string. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Strings are immutuble"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length / <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = s[i]; s[i] = s[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; s[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = c; }</code> </pre><br>  Obviously, this code is not compiled.  The compiler will swear at these lines, because we are trying to change the contents of the line.  Indeed, any method of the String class returns a new instance of the string, instead of changing its contents. <br><br>  In fact, the string can be changed, but for this it is necessary to resort to unsafe code.  Consider an example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Strings are immutable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* c = s) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length / <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = c[i]; c[i] = c[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; c[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = temp; } } }</code> </pre><br>  After executing this code, as expected, the line will <b>contain elbatummi era sgnirtS</b> . <br>  The fact that the lines are still changeable leads to one very interesting incident.  It is connected with the internment of strings. <br><br>  <i>String interning</i> is a mechanism by which identical literals represent one object in memory. <br><br>  If you do not delve deeply into the details, then the meaning of string interning is this: within the process (the process, not the application domain), there is one internal hash table, the keys of which are strings, and the values ‚Äã‚Äãare references to them.  During JIT compilation, literal strings are sequentially entered into a table (each row in the table occurs only once).  At the execution stage, references to literal strings are assigned from this table.  You can place a string in an internal table at runtime using the String.Intern method.  You can also check whether the string is contained in an internal table using the String.IsInterned method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = <span class="hljs-string"><span class="hljs-string">"habrahabr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 = <span class="hljs-string"><span class="hljs-string">"habrahabr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s3 = <span class="hljs-string"><span class="hljs-string">"habra"</span></span> + <span class="hljs-string"><span class="hljs-string">"habr"</span></span>; Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(s1, s2));<span class="hljs-comment"><span class="hljs-comment">//true Console.WriteLine(object.ReferenceEquals(s1, s3));//true</span></span></code> </pre><br>  It is important to note that only string literals are interned by default.  Since an internal hash table is used to implement internment, a search is performed on it during the JIT compilation, which takes time, so if all the lines were interned, this would nullify all the optimization.  During compilation into IL code, the compiler concatenates all literal strings, since there is no need to contain them in parts, therefore the 2nd equality returns true.  So, what is the incident.  Consider the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Strings are immutable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* c = s) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length / <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = c[i]; c[i] = c[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; c[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = temp; } } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Strings are immutable"</span></span>);</code> </pre><br>  It seems that everything is obvious here and that such code should print the <b>Strings are immutable</b> .  However, no!  The code prints <b>elbatummi era sgnirtS</b> .  The point is interning, changing the string s, we change its contents, and since it is a literal, it is interned and represented by a single instance of the string. <br><br>  String interning can be waived by applying the <b>CompilationRelaxationsAttribute</b> special attribute to an assembly.  The <b>CompilationRelaxationsAttribute</b> attribute controls the accuracy of the code generated by the CLR JIT compiler.  The constructor of this attribute accepts the <b>CompilationRelaxations</b> enumeration in the composition, which currently includes only <b>CompilationRelaxations.NoStringInterning</b> - which marks the assembly as not requiring internment. <br><br>  By the way, this attribute is not processed in the .NET Framework version 1.0., Therefore it was not possible to disable the default internment.  The mscorlib build, starting with the second version, is marked with this attribute. <br><br>  It turns out that the lines in .NET can still be changed if you really want to, using unsafe code. <br><br><h4>  And what if without unsafe? </h4><br>  It turns out that it was possible to change the contents of the line, without resorting to unsafe code, using the reflection mechanism.  This trick could roll in .NET to version 2.0 inclusive, then the developers of the String class deprived us of this opportunity. <br>  In the .NET 2.0 version, the String class has two internal methods: <b>SetChar</b> , which checks for <b>outbound</b> boundaries, and <b>InternalSetCharNoBoundsCheck</b> , which does not check for <b>outbound</b> boundaries that set the specified character at a specific index.  Here is their implementation: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetChar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)index &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-string"><span class="hljs-string">"index"</span></span>, Environment.GetResourceString(<span class="hljs-string"><span class="hljs-string">"ArgumentOutOfRange_Index"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr = &amp;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_firstChar) chPtr[index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalSetCharNoBoundsCheck</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr = &amp;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_firstChar) chPtr[index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre><br>  Thus, using the following code, you can change the contents of the line, even without using unsafe code. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Strings are immutable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>).GetMethod(<span class="hljs-string"><span class="hljs-string">"InternalSetCharNoBoundsCheck"</span></span>, BindingFlags.Instance | BindingFlags.NonPublic); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length / <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = s[i]; method.Invoke(s, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { i, s[length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>] }); method.Invoke(s, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>, temp }); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Strings are immutable"</span></span>);</code> </pre><br>  This code as expected, prints <b>elbatummi era sgnirtS</b> . <br><br>  <b>Version Question:</b> In different versions of the .NET Framework, string.Empty may or may not be interned. <br>  Consider the code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str1 = String.Empty; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().Append(String.Empty); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str2 = String.Intern(sb.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(str1, str2)) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Equal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Not Equal"</span></span>);</code> </pre><br>  In the .NET Framework 1.0, the .NET Framework 1.1 and the .NET Framework 3.5 Service Pack 1 (SP1), str1 and str2 are equal.  In the .NET Framework 2.0 Service Pack 1 (SP1) and the .NET Framework 3.0, str1 and str2 are not equal.  Currently string.Empty is interned. <br><br><h4>  Performance features </h4><br>  Internment has a negative side effect.  The fact is that the reference to the interned String object that the CLR stores can be maintained even after the application and even the application domain have terminated.  Therefore, large literal strings should not be used, or if it is necessary to disable internment by applying the CompilationRelaxations attribute to the assembly. <br><br>  <i>I hope this article was helpful ...</i> </div><p>Source: <a href="https://habr.com/ru/post/172627/">https://habr.com/ru/post/172627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172615/index.html">AMA with Alan Mendelevich - AdDuplex CEO</a></li>
<li><a href="../172617/index.html">How to become master of your time: Jedi tricks</a></li>
<li><a href="../172619/index.html">Hours-long crash of Microsoft cloud services</a></li>
<li><a href="../172621/index.html">At 10:00, the online broadcast of the HTML5 Camp conference will begin. Get connected!</a></li>
<li><a href="../172625/index.html">Mobile application that allows you to get more from the car</a></li>
<li><a href="../172629/index.html">OpenSUSE 12.3 released</a></li>
<li><a href="../172631/index.html">How, in your opinion, should antiviruses be perceived by Guard@Mail.Ru and other similar software?</a></li>
<li><a href="../172633/index.html">First look at the HTC One</a></li>
<li><a href="../172637/index.html">Android and Chrome OS on the road to unification: Sundar Pichai becomes the new head of Android</a></li>
<li><a href="../172641/index.html">Why modern interfaces are bad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>