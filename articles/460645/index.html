<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Doing well, doing badly: writing ‚Äúevil‚Äù code with Go, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bad tips for the go programmer 


 After decades of Java programming, for the past few years I have mainly worked on Go. Working with Go is great, fir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Doing well, doing badly: writing ‚Äúevil‚Äù code with Go, part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  <i>Bad tips for the go programmer</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="image"><br><br>  After decades of Java programming, for the past few years I have mainly worked on Go.  Working with Go is great, first of all because the code is very easy to follow.  Java simplified the C ++ programming model by removing multiple inheritance, manual memory management, and operator overloading.  Go does the same thing, continuing to move to a simple and understandable programming style, completely removing inheritance and function overloading.  Simple code is readable code, and readable code is supported code.  And it's great for the company and my staff. <br><br>  As in all cultures, software development has its own legends, stories, which are retold by a water cooler.  We all heard about developers who, instead of focusing on creating a quality product, are fixated on protecting their own work from outsiders.  They do not need supported code, because it means that other people will be able to understand and modify it.  Is it possible on Go?  Is it possible to make Go code so complicated?  I will say right away - this is not an easy task.  Let's consider the possible options. <br><a name="habracut"></a><br>  You think: ‚Äú <i>How much can you fuck up code in a programming language?</i>  <i>Is it possible to write such a terrible code on Go, so that its author becomes indispensable in the company?</i>  " Do not worry.  When I was a student, I had a project in which I supported someone else's Lisp-e code written by a graduate student.  In fact, he managed to write Fortran-e code using Lisp.  The code looked like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  There were dozens of files of this code.  He was absolutely terrible and absolutely brilliant at the same time.  I spent months trying to figure it out.  Compared to this, write bad code on Go - just spit. <br><br>  There are many different ways to make code unsupported, but we‚Äôll look at a few.  To properly do evil, you must first learn to do good.  Therefore, we first look at how the ‚Äúgood‚Äù programmers of Go write, and then analyze how the opposite can be done. <br><br><h3>  Bad packaging </h3><br>  Packages are a convenient topic to start with.  How can code organization degrade readability? <br><br>  In Go, the package name is used to refer to the entity being exported (for example, ` <i>fmt.Println`</i> <i>or` http.RegisterFunc</i> `).  Since we can see the name of the package, ‚Äúgood‚Äù Go programmers ensure that this name describes what the exported entities are.  We should not have util packages, because names like ` <i>util.JSONMarshal`</i> will not suit us, we need ` <i>json.Marshal`</i> . <br><br>  The "good" Go developers also do not create a separate package for the DAO or model.  For those unfamiliar with this term, DAO is a ‚Äú <i>data access object</i> ‚Äù <i>‚Äîa</i> layer of code that interacts with your database.  I used to work at a company where 6 Java services imported the same DAO library to access the same database that they used together because ‚Äú <i>... well, you know, microservices are the same ...</i> ‚Äù. <br><br>  If you have a separate package with all your DAOs, then the likelihood that you will get a cyclic dependency between packages, which is forbidden in Go, increases.  And if you have several services that connect this DAO package as a library, you may also encounter a situation where a change in one service requires updating all of your services, otherwise something will break.  This is called a distributed monolith, and it is incredibly difficult to update. <br><br>  When you know how packaging should work, and what makes it worse, ‚Äústarting to serve evil‚Äù becomes easy.  Poorly organize your code and give your packages bad names.  Break your code into packages such as <i>model</i> , <i>util,</i> and <i>dao</i> .  If you really want to start ‚Äúcreate chaos‚Äù, try creating packages in honor of your cat or your favorite color.  When people encounter cyclic dependencies or distributed monoliths because they try to use your code, you have to sigh, roll your eyes and tell them that they are just doing wrong ... <br><br><h3>  Unsuitable interfaces </h3><br>  Now that all of our packages have been corrupted, we can go to the interfaces.  The interfaces in Go are not similar to interfaces in other languages.  The fact that you do not explicitly declare that this type implements the interface seems insignificant at first, but in fact it completely reverses the concept of interfaces. <br><br>  In most languages ‚Äã‚Äãwith abstract types, the interface is defined before or simultaneously with the implementation.  You will have to do this at least for testing.  If you do not create the interface in advance, you will not be able to insert it later without breaking all the code that this class uses.  Because you have to rewrite it with reference to the interface instead of a specific type. <br><br>  For this reason, Java code often has giant service interfaces with a variety of methods.  Classes that implement these interfaces then use the methods they need and ignore the rest.  Writing tests is possible, but you add an extra layer of abstraction, and when writing tests, you often use tools to generate implementations of those methods that you don‚Äôt need. <br><br>  In Go, implicit interfaces determine which methods you need to use.  The code owns the interface, not the other way around.  Even if you use a type with a variety of methods defined in it, you can specify the interface that includes only the methods you need.  Other code using separate fields of the same type will define other interfaces that cover only the functionality that is needed.  Typically, these interfaces have only a couple of methods. <br><br>  This makes it easy to understand your code, because the method declaration not only determines what data it needs, but also indicates exactly what functionality it is going to use.  This is one of the reasons why good Go developers follow the advice: ‚Äú <i>Accept interfaces, return structures</i> ‚Äù. <br><br>  But just because it is a good practice does not mean that you should do that ... <br>  The best way to make your interfaces "evil" is to return to the principles of using interfaces from other languages, i.e.  define interfaces in advance as part of the code being called.  Define huge interfaces with a variety of methods that are used by all clients of the service.  It becomes unclear what methods are really needed.  This complicates the code, and complication, as you know, is the best friend of the ‚Äúevil‚Äù programmer. <br><br><h3>  Pass-to-Heap Pointers </h3><br>  Before explaining what this means, you need to philosophize a little.  If you digress and think, each written program does the same thing.  It takes data, processes it, and then sends the processed data to another location.  This is so regardless of whether you are writing a payroll system, accepting HTTP requests and returning web pages, or even checking a joystick to track a button click ‚Äî the programs process the data. <br><br>  If we look at the programs in this way, the most important thing to do is to make sure that it is easy for us to understand how the data is transformed.  And because of this, it will be good practice to keep the data unchanged for as long as possible during the program.  Because data that does not change is data that is easy to track. <br><br>  In Go, we have reference types and value types.  The difference between them is whether the variable refers to a copy of the data or to the place of the data in memory.  Pointers, slices, maps, channels, interfaces, and functions are reference types, and everything else is a value type.  If you assign a value type variable to another variable, it creates a copy of the value;  changing one variable does not change the value of another. <br><br>  Assigning one variable of reference type to another variable of reference type means that they both share the same memory area, so if you change the data pointed to by the first, you change the data pointed to by the second.  This is true for both local variables and function parameters. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  ‚ÄúGood‚Äù Go developers want to simplify their understanding of how data is collected.  They try to use the type of values ‚Äã‚Äãas parameters of functions as often as possible.  In Go, there is no way to mark fields in structures or function parameters as final.  If the function uses value parameters, changing parameters will not change the variables in the calling function.  All the called function can do is return the value to the calling function.  Thus, if you fill a structure by calling a function with value parameters, you can not be afraid to transfer data to the structure, because you understand where each field in the structure came from. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  So how do we become "evil"?  Very simple - turning this model over. <br><br>  Instead of calling functions that return the desired values, you pass a pointer to the structure in the function and allow them to make changes to the structure.  Because each function owns the entire structure, the only way to find out which fields change is to view the entire code.  You may also have implicit dependencies between functions - the 1st function transfers data required by the 2nd function.  But in the code itself, nothing indicates that you must first call the 1st function.  If you build your data structures in this way, you can be sure that nobody will understand what your code does. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Panic ascent </h3><br>  Now we proceed to error handling.  Probably, you think that it is bad to write programs that handle errors by about 75%, and I will not say that you are wrong.  The Go code is often filled with error handling from head to toe.  And of course, it would be convenient to handle them not so straightforward.  Mistakes happen, and processing them is what distinguishes professionals from beginners.  Mild error handling leads to unstable programs that are difficult to debug and difficult to maintain.  Sometimes to be a ‚Äúgood‚Äù programmer is to ‚Äústrain‚Äù. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Many languages, such as C ++, Python, Ruby and Java, use exceptions to handle errors.  If something goes wrong, the developers in these languages ‚Äã‚Äãthrow or throw an exception, expecting some code to handle it.  Of course, the program calculates that the client is aware of a possible error in the given place, so that it is possible to generate an exception.  Because, with the exception of (without a pun), checked Java exceptions, there is nothing in the languages ‚Äã‚Äãor functions in the method signature to indicate that an exception may be thrown.  So how do developers know which exceptions to worry about?  They have two options: <br><br><ul><li>  First, they can read all the source code of all libraries that call their code, and all libraries that call called libraries, etc. </li><li>  Secondly, they can trust the documentation.  Perhaps I am biased, but personal experience does not allow me to completely trust the documentation. </li></ul><br>  So, how do we bring this evil into Go?  Abusing panic ( <i>panic</i> ) and recovering ( <i>recover</i> ), of course!  Panic is designed for situations such as "the disk fell off" or "network card exploded."  But not for such - "someone passed the string instead of int." <br><br>  Unfortunately, other, ‚Äúless enlightened developers‚Äù will return errors from their code.  Therefore, here is a small helper function PanicIfErr.  Use it to turn other developers' mistakes into a panic. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  You can use PanicIfErr to wrap other people's errors, compress the code.  No more ugly error handling!  Any mistake is now panic.  It is so productive! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  You can place the reserver somewhere closer to the beginning of the program, maybe in your own <i>middleware</i> .  And then to say that you not only handle errors, but also make someone else's code cleaner.  To do evil by doing good is the best kind of evil. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Side effects setup </h3><br>  Next we will create a side effect.  Remember, the ‚Äúgood‚Äù developer Go wants to understand how the data passes through the program.  The best way to know what the data goes through is to set up explicit dependencies in the application.  Even entities that match the same interface can vary greatly in behavior.  For example, a code that stores data in memory, and a code that accesses a database for the same work.  However, there are ways to establish dependencies in Go without explicit calls. <br><br>  As in many other languages, Go has a way to magically execute code without invoking it directly.  If you create a function called init with no parameters, it will automatically start when the package is loaded.  And, to make things even more confusing, if there are several functions in the same file with the name init or several files in the same package, they all start. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  The init functions are often associated with an empty import.  There is a special way to declare import in Go, which looks like `import _‚Äú github.com / lib / pq`.  When you set an empty name identifier for an imported package, it invokes the init method, but it does not show any of the package identifiers.  For some Go libraries ‚Äî such as database drivers or image formats ‚Äî you must load them by including an empty package import, just to call the init function so that the package can register its code. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  And this is clearly the "evil" option.  When you use initialization, the code that works in a magical way is completely outside the control of the developer.  Best-practices do not recommend using initialization functions - these are not obvious features, they confuse code, and they are easy to hide in the library. <br><br>  In other words, init functions are perfect for our evil purposes.  Instead of explicitly configuring or registering entities in packages, you can use initialization functions and empty import to adjust the state of your application.  In this example, we make the account accessible to the rest of the application through the registry, and the package itself is placed on the registry using the init function. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  If you want to use an account, then put an empty import in your program.  It should not be the main or related code - it just has to be ‚Äúsomewhere‚Äù.  It `s Magic! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  If you use inits in your libraries to configure dependencies, you will immediately see that other developers are puzzled, how these dependencies were installed, and how to change them.  And no one will be wiser than you. <br><br><h3>  Advanced Configuration </h3><br>  There is still a lot of everything that we can create with the configuration.  If you are a ‚Äúgood‚Äù Go developer, you will want to isolate the configuration from the rest of the program.  In the main () function, you get variables from the environment and convert them to the values ‚Äã‚Äãnecessary for components that are clearly related to each other.  Your components do not know anything about the settings files, or what their properties are called.  For simple components, you set public properties, and for more complex ones, you can create a factory function that receives configuration information and returns a correctly configured component. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  But "evil" developers know that it is better to scatter information about the configuration throughout the program.  Instead of having one function in the package that defines the names and types of values ‚Äã‚Äãfor your package, use a function that accepts the config as is and converts it on its own. <br><br>  If this seems too ‚Äúevil,‚Äù use the init function to load the properties file from within your package and set the values ‚Äã‚Äãyourself.  It may seem that you have made the lives of other developers easier, but we all know ... <br><br>  Using the init function, you can define new properties in the depth of the code, and no one will ever find them until they get into production, and everything will not fall off, because they will not get something in one of the dozens of properties files needed to run.  If you want even more ‚Äúevil power‚Äù, you can suggest creating a wiki to keep track of all the properties in all libraries and ‚Äúforget‚Äù to add new ones periodically.  As a Property Keeper, you become the only person who can run the software. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Frameworks for functionality </h3><br>  Finally, we come to the topic of framework vs libraries.  The difference is very subtle.  It's not just about the size;  You can have large libraries and small frameworks.  The framework calls your code while you call the library code.  The frameworks require that you write your code in a specific way, be it naming your methods according to specific rules, or that they match certain interfaces, or force you to register your code with the framework.  The frameworks make their demands on all your code.  That is, in general, the frameworks command you. <br><br>  Go encourages the use of libraries because libraries are linked.  Although, of course, each library is waiting for data to be sent in a specific format, you can write some glue code to convert the output of one library to an input for another. <br>  It is difficult to force frameworks to work smoothly together because each framework wants complete control over the life cycle of the code.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often the only way to get frameworks to work cohesively is to get the framework authors to come together and explicitly organize mutual support. </font><font style="vertical-align: inherit;">And the best way to use the ‚Äúevil frameworks‚Äù for long-term power is to write your own framework, which is used only within the company.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Current and future evil </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having mastered these techniques, you will forever take the path of evil. </font><font style="vertical-align: inherit;">In the second part, I will show how to deploy all this ‚Äúevil‚Äù, and how to properly turn the ‚Äúgood‚Äù code into ‚Äúevil‚Äù.</font></font></div><p>Source: <a href="https://habr.com/ru/post/460645/">https://habr.com/ru/post/460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460633/index.html">Details of the implementation of RSTP and proprietary Extended Ring Redundancy</a></li>
<li><a href="../460635/index.html">CLRium # 6: Concurrency</a></li>
<li><a href="../460637/index.html">Light control on ZigBee</a></li>
<li><a href="../46064/index.html">The British encroached on the "Classmates"</a></li>
<li><a href="../460641/index.html">YouTokenToMe: tool for quick tokenization of text from the VKontakte Team</a></li>
<li><a href="../460647/index.html">The solution to the task with pwnable.kr 05 - passcode. Rewriting the procedure link table via format string vulnerability</a></li>
<li><a href="../460651/index.html">Meeting of the Society of Anonymous Testers: TMS, monitoring monitoring, search quality assessment and native iOS tests</a></li>
<li><a href="../460655/index.html">How I broke Telegram</a></li>
<li><a href="../460659/index.html">We use pipe for pivoting</a></li>
<li><a href="../46066/index.html">Sequential - free photo viewer for Mac OS X</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>