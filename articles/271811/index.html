<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of fast mobile applications on Android. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Edison, we often encounter optimization of mobile applications and want to share material that we consider extremely useful if you solve one of two...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of fast mobile applications on Android. Part two</h1><div class="post__text post__text-html js-mediator-article">  In <a href="http://www.edsd.ru/">Edison,</a> we often encounter optimization of mobile applications and want to share material that we consider extremely useful if you solve one of two tasks: a) you want the application to slow down less;  b) want to make a beautiful, soft and smooth interface for the mass user. <br><br>  We bring to your attention the first part of the translation of the article Udi Cohen, which we used as a tool for teaching young colleagues to optimize for Android. <br><br>  (Read the <a href="http://habrahabr.ru/company/edison/blog/271761/">first part</a> ) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/499/b8f/85f/499b8f85f84f44eb84918af27e4a13dd.jpg"><br><a name="habracut"></a><br><h4>  <b>General tips for working with memory</b> </h4><br>  Here are some simple guidelines that I use when writing code. <br><br><ul><li>  <b>Enumerations</b> are already the subject of heated debate about performance.  Here is a <a href="https://youtu.be/Hzs6OBcvNQE">video</a> that discusses the amount of memory that the enumeration spends, and a <a href="https://plus.google.com/%2BJakeWharton/posts/bTtjuFia5wm">discussion of</a> this video and some potentially misleading information.  Do enums use more memory than regular constants?  Definitely.  Is it bad?  Not necessary.  If you are writing a library and need strong type safety, it could justify their use compared to other solutions, such as <a href="https://developer.android.com/reference/android/support/annotation/IntDef.html">@IntDef</a> .  If you just have a bunch of constants that can be grouped together, using enums will not be a very wise decision.  As usual, there is a trade-off that needs to be considered when making a decision. <br><br></li><li>  <b>A wrapper</b> is an automatic conversion of primitive types to their object representation (for example, int -&gt; Integer).  Each primitive type "turns around" into an object representation, a new object is created (shocking, I know).  If we have many such objects, the call to the garbage collector will be executed more often.  It is easy to miss the number of wraps, because this is done automatically for us when assigned to a primitive type of object.  As a solution, try to use the appropriate types.  If you use primitive types in your application, try to avoid wrapping them without real need.  You can use the memory profiling tools to find objects that represent primitive types.  You can also use Traceview and search for Integer.valueOf (), Long.valueOf (), etc. <br><br></li><li>  <b>HashMap vs ArrayMap / Sparse * Array</b> - as well as in the case of wrappers, using HashMap requires using objects as keys.  If we use the primitive type int in our application, it is automatically wrapped in an Integer when interacting with a HashMap, in this case we could use SparseIntArray.  In the case where we still use objects as keys, we can use ArrayMap.  Both options require less memory than HashMap, but they <a href="https://www.youtube.com/watch%3Fv%3DORgucLTtTDI">work differently</a> , which makes them more efficient in memory consumption at the cost of decreasing speed.  Both alternatives have a smaller memory footprint than HashMap, but the time required to retrieve an item or allocate memory is slightly longer than that of a HashMap.  If you do not have more than 1000 items, the differences in runtime are not significant, which makes these two options viable. <br><br></li><li>  <b>Awareness of context</b> - as you saw earlier, it is relatively easy to create memory leaks.  You may not be surprised to learn that activations are the most common cause of Android memory leaks (!).  Their leaks are also very expensive, as they contain all representations of the hierarchy of their UI, which themselves can take up a lot of space.  Make sure you understand what is happening in the activation.  If a link to an object in the cache and this object lives longer than your activation, without clearing this link you will get a memory leak. <br><br></li><li>  <b>Avoid using non-static inner classes</b> .  When creating a non-static inner class and its instance, you create an implicit reference to your outer class.  If an instance of the inner class is needed for a longer period of time than the outer class, the outer class will continue to be in memory, even if it is no longer needed.  For example, a non-static class is created that inherits AsyncTask inside the Activity class, then a transition to a new asynchronous task takes place and, while it lasts, the activation is completed.  As long as this asynchronous task lasts, it will keep the activity alive.  The solution is simple - do not do this, declare an internal static class, if necessary. <br><br></li></ul><h4>  <b>GPU profiling</b> </h4><br>  A new addition to Android Studio 1.4 is GPU profiling rendering. <br>  Under the Android window, go to the GPU tab, and you will see a graph showing the time it took to make each frame on the screen: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/eed/aaf/ec3/eedaafec3e549d1d967c001abeb07596.png" alt="image"></a> <br><br>  Each panel on the chart represents one frame drawn, and the color represents the various stages of the process. <br><br><ul><li>  <b>Draw</b> (blue) represents the View # onDraw () method.  This part builds / updates DisplayList objects, which will then be converted to OpenGL commands that are understandable to the GPU.  High performance may be due to the complex used representations, which require more time to build their display list, or many representations become invalid in a short period of time. <br><br></li><li>  <b>Prepare</b> (purple) - another thread was added to Lollipop to help draw the UI faster.  It is called RenderThread.  He is responsible for converting the display lists to OpenGL commands and sending them to the graphics processor.  Once this happens, the UI thread can proceed to processing the next frame.  The time spent by the UI thread to transfer all the necessary RenderThread resources is reflected at this stage.  If we have long / heavy mapping lists, this step may take longer. <br><br></li><li>  <b>Process</b> (red) - execute display lists to create OpenGL commands.  This step may take longer if the lists are long or complex, because many elements need to be redrawn.  The view may be redrawn, since it has become invalid or has been opened after the movement of the concealing view. <br><br></li><li>  <b>Execute</b> (yellow) - send OpenGL commands to the GPU.  This stage can take a long time, as the CPU sends a buffer with commands to the GPU, expecting to get back a clean buffer for the next frame.  The number of buffers is limited, and if the GPU is too busy, the processor will wait until the first one is available.  Therefore, if we see high values ‚Äã‚Äãat this step, this may mean that the GPU was busy with drawing our interface, which may be too complicated to be drawn in a shorter time. <br></li></ul><br>  More colors have been added to Marshmallow to display more steps, such as Measure / Layout, Input Handing, and others: <br><img src="https://habrastorage.org/getpro/habr/post_images/836/125/4f2/8361254f2b193f02da0b1984998f938b.png" alt="image"><br><br>  EDIT 09/29/2015: John Reck, a framework engineer from Google, <a href="https://plus.google.com/%2BAlexLockwood/posts/Yj23fFY7Eon">added the</a> following information about some of these colors: <br><blockquote>  ‚ÄúThe exact definition of the word‚Äú animation ‚Äùis all that is registered with Choreographer as CALLBACK_ANIMATION.  This includes the Choreographer # postFrameCallback and View # postOnAnimation, which are used by view.animate (), ObjectAnimator, Transitions, and others ... And yes, this is the same thing that is labeled ‚Äúanimation‚Äù in systrace. <br><br>  ‚ÄúMisc‚Äù is the delay between the vsync timestamp and the current timestamp when it was received.  If you have already seen the logs from Choreographer "Missed vsync by blabla ms skipping blabla frames", now it will be represented as "misc".  There is a difference between INTENDED_VSYNC and VSYNC in framestats dump (https://developer.android.com/preview/testing/performance.html#timing-info). ‚Äù </blockquote><br><br>  But before starting to use this feature, we need to enable the GPU rendering mode in the developer menu: <br><img src="https://habrastorage.org/getpro/habr/post_images/1da/c89/1e0/1dac891e0a9cb51a35b7ca37bca8b515.png" alt="image"><br><br>  It can be (!), Using: <br><br><pre><code class="java hljs">adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt;</code> </pre> <br><br>  we can get the information and build the schedule yourself.  The command will display useful information, such as the number of elements in the hierarchy, the size of all display lists, and so on.  In Marshmallow we get more information. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22b/c06/dad/22bc06daddcf168037bf2d9e44b55ec3.png" alt="image"><br><br>  If we have automated UI testing of our application, we can build an assembly that runs this command after certain actions (list scrolling, heavy animation, etc.) and see if there are changes in values, such as ‚ÄúJanky Frames‚Äù, over time .  This can help determine the decline in performance after several code changes, allowing us to fix the problem before the application has entered the market.  We can get even more accurate information when we use the ‚Äúframestats‚Äù keyword, as shown <a href="https://developer.android.com/preview/testing/performance.html">here</a> . <br><br>  But this is not the only way to see such a schedule! <br><br>  As you can see in the developer menu of the Profile GPU Rendering, there is also the option ‚ÄúOn screen as bars‚Äù.  His choice will show a graph for each window on your screen along with a green line indicating a 16 ms threshold. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/665/46f/8ef/66546f8ef1549720f6fbaa169dfe8d3f.png" alt="image"></a> <br><br>  In the example to the right, we can see that some frames cross the green line, which means that they require more than 16ms to draw.  Since the blue color seems to dominate, we understand that there were many representations to draw, or they were complex.  In this case, I scroll the tape, which supports different types of presentation.  Some items become invalid, and some become more complex than others.  Perhaps the reason why some frames crossed this line is because an element is difficult to display. <br><br><h4>  <b>Hierarchy viewer</b> </h4><br>  I love this tool, and I am very sorry that many do not use it! <br>  Using the Hierarchy Viewer, we can get performance statistics, see the complete view hierarchy on the screen, and access all the properties of an item.  You can also dump all topic data, see all parameters used for each style attribute, but this is possible only if the Hierarchy Viewer is running standalone, not from Android Monitor.  I use this tool when I create application layouts and I want to optimize them. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0b2/4bf/caf/0b24bfcaf1d3ca92b047ac00f6a82aaa.png" alt="image"></a> <br><br>  In the center we can see a tree reflecting the hierarchy of the view.  The presentation hierarchy may be broad, but if it is too deep (~ 10 levels), it can cost us a lot.  Each time a view dimension occurs in View # onMeasure (), or when its descendants are placed in View # onLayout (), these commands apply to the descendants of these views, doing the same.  Some layouts will do each step twice, for example, RelativeLayout and some LinearLayout configurations, and if they are nested, the number of passes increases exponentially. <br><br>  In the lower right corner we can see the ‚Äúplan‚Äù of our layout, noting where each presentation is located.  We can choose a view here, or in a tree and see all the properties on the left.  When designing a layout, I'm sometimes not sure why a particular view ends where it ends.  Using this tool, I can track the tree, select it and see where it is in the preview window.  I can make interesting animations by looking at the final dimensions of the views on the screen, and use this information to precisely place elements around.  I can find lost views that were overlaid by other ideas unintentionally. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/35f/630/c3a/35f630c3af834ace323cf28b87459fe5.png" alt="image"></a> <br><br>  For each view, we have the time it took to measure / create a layout / render it and all its descendants.  The colors reflect how these representations are performed in comparison with other representations in the tree; this is a great way to find the weak link.  Since we also see a preview of the view, we can go through the tree and follow the instructions that create them, finding extra steps that we could remove.  One of the things that affects performance is called Overdraw. <br><br><h4>  <b>Overdraw</b> </h4><br>  As can be seen in the GPU profiling section, the Execute phase represented in yellow on the graph may take longer to complete if the GPU has to draw a lot of elements, increasing the time required to draw each frame.  Overdraw occurs when we draw something on top of something else, such as a yellow button on a red background.  The GPU needs to draw, first, a red background and then a yellow button on top of it, which makes inevitable overdraw.  If we have too many overdraw layers, this may be the reason why the GPU works more intensively and does not have time to 16 ms. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ec4/829/96d/ec482996dca6f9697e79d55e085663de.gif" alt="image"></a> <br><br>  Using the ‚ÄúDebug GPU Overdraw‚Äù setting in the developer menu, all overdraw will be tinted to demonstrate the degree of overdraw in a given area.  If overdraw has a 1x / 2x degree, this is normal, even small red areas are not bad either, but if we have too many red elements on the screen, we probably have a problem.  Let's look at a few examples: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/130/550/1e5/1305501e5cc7be899e43da3550042975.png" alt="image"></a> <br><br>  In the example on the left there is a list colored green, which is usually normal, but there is an overdraw at the top, which makes the screen red, and this is becoming a problem.  In the example to the right, the entire list is light red.  In both examples there is an opaque list with a 2x / 3x overdraw layer.  These can happen if there is a background color on the whole screen in a window that overlaps your activit or fragment, as well as on the list view and the presentation of each of its elements. <br><br>  Note: the default theme sets the background color for your entire window.  If you have an activation with an opaque layout that covers the entire screen, you can remove the background for this window to remove one overdraw layer.  This can be done in a thread or in code by calling getWindow (). SetBackgroundDrawable (null) in onCreate (). <br><br>  Using the Hierarchy Viewer, you can export all your hierarchy layers to a PSD file to open it in Photoshop.  As a result of researching different layers, all overdraw in the layout will be revealed.  Use this information to remove redundant overdraws, and do not settle for green, aim for the blue! <br><br><h4>  <b>Alpha</b> </h4><br>  Using transparency can affect performance, and in order to understand why, let's see what happens when setting the alpha parameter in a view.  Consider the following structure: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5c6/6b8/807/5c66b8807ef509f1289c80823227a9f7.png" alt="image"></a> <br><br>  We see a layout that contains 3 ImageViews that overlap each other.  In a direct implementation, setting alpha with setAlpha () will cause the command to be propagated to all representations of the children, ImageView in this case.  These ImageViews will then be drawn with the alpha parameter in the frame buffer.  Result: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c67/957/d0f/c67957d0fe61dafcd6ebeb8d530ddd54.png" alt="image"></a> <br><br>  This is not what we want to see. <br><br>  Since each ImageView was rendered with an alpha value, all overlapping images will merge.  Fortunately, the OS has a solution to this problem.  The layout will be copied to a separate off-screen buffer, alpha will be used in this buffer as a whole and the result will be copied to the frame buffer.  Result: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/0bf/c64/afd0bfc6437b1a02afb4f9299901b392.png" alt="image"></a> <br><br>  But ... we will pay our price for it. <br><br>  Additional drawing of the presentation in the off-screen buffer before it is done in the frame buffer adds another invisible overdraw layer.  The OS does not know exactly when to use this or a direct approach before, so by default it always uses one integrated one.  But there are still ways to set alpha and avoid difficulties with the addition of off-screen buffer: <br><ul><li>  <b>TextViews</b> - use setTextColor () instead of setAlpha ().  Using the alpha channel for text will cause the text to be redrawn. <br></li><li>  <b>ImageView</b> - use setImageAlpha () instead of setAlpha ().  Same reasons as TextView. <br></li><li>  <b>Custom views</b> - if our custom view does not support overlapping, this comprehensive solution does not matter to us.  There is no way that our descendant views will be connected together, as shown in the example above.  By redefining the hasOverlappingRendering () method so that it returns false, we signal the OS to take the direct path to our view.  There is also an option to manually handle what happens when setting an alpha by overriding the onSetAlpha () method so that it returns true. <br></li></ul><br><h4>  <b>Hardware acceleration</b> </h4><br>  When hardware acceleration was enabled in Honeycomb, we got a new rendering model to display our application on the screen.  This includes a DisplayList structure that records view rendering commands for faster image acquisition.  But there is another interesting feature that developers usually forget about - presentation levels. <br><br>  Using them, we can draw the presentation in the off-screen buffer (as we saw earlier when using the alpha channel) and manipulate it as we wish.  This is great for animation because we can animate complex views faster.  Without levels, the animation of the representations would become inaccessible after changing the properties of the animation (such as x-coordinate, scale, alpha value, etc.).  For complex representations, this inability extends to descendants, and they in turn will redraw themselves, which is an expensive operation.  Using the presentation levels, relying on hardware, the texture for our presentation is created in the graphics processor.  There are several operations that we can apply to the texture without having to replace it, such as changing the position along the x / y axes, rotation, alpha, and others.  All this means that we can animate complex presentations on our screen without replacing them in the process of animation!  This makes the animation more smooth.  Here is a sample code showing how this can be done: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Using the Object animator view.setLayerType(View.LAYER_TYPE_HARDWARE, null); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 20f); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { view.setLayerType(View.LAYER_TYPE_NONE, null); } }); objectAnimator.start(); // Using the Property animator view.animate().translationX(20f).withLayer().start();</span></span></code> </pre><br><br>  Just right? <br><br>  Yes, but there are a few points to keep in mind when using the hardware level. <br><br><ul><li>  <b>Do the cleanup</b> after running your view ‚Äî the hardware level uses space on the limited memory space on your GPU.  Try to use it only in cases when it is needed, for example, in animation, and do the cleaning after.  In the example above with ObjectAnimator, I used the withLayers () method, which automatically creates a layer at the beginning and deletes it when the animation ends. </li><li>  If you <b>change your presentation</b> after using the hardware level, it will lead to its unsuitability and you will have to re-play the presentation on the off-screen buffer.  This will happen when the property is not optimized for the hardware level (currently optimized: rotation, scaling, movement along the x / y axes, alpha).  For example, if you are animating a presentation using a hardware level and moving the presentation across the screen while the background color is being updated, this will result in constant updates on the hardware level.  This requires additional costs that may make its use unjustified. </li></ul><br>  For the second case, there is a way to visualize this update.  Using developer settings, we can activate ‚ÄúShow hardware layers updates‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96f/1f3/f41/96f1f3f41a110ca67c7072dbc2bf5b4a.png" alt="image"><br><br>  After that, the view will be highlighted in green when upgrading at the hardware level.  I used it some time ago when I had a ViewPager that did not flip through the pages with the smoothing that I was expecting.  After I turned on this option, I went back and flipped through the ViewPager, and this is what I saw: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/054/16c/cd5/05416ccd594f1600dc7e9f7c41345d2e.gif" alt="image"></a> <br><br>  Both pages were green throughout the entire scroll! <br><br>  This means that the hardware level was used to optimize the pages, and the pages became unusable when we looked through the ViewPager.  I updated the pages and flipped through them using the parallax effect in the background and gradually revived the elements on the page.  What I didn't do was not create a hardware layer for the ViewPager pages.  After examining the ViewPager code, I discovered that when the user starts scrolling, both pages are created at the hardware level and deleted after the scrolling ends. <br><br>  While it makes sense to use hardware levels for scrolling through pages, in my case this did not work.  Usually the pages do not change when we flip through the ViewPager, and since they can be quite complex, the hardware level helps to render the drawing much faster.  In the application I was working on, this was not the case, and I removed this hardware layer using a small <a href="http://blog.udinic.com/2013/09/16/viewpager-and-hardware-acceleration">hack, which I wrote myself.</a> <br><br>  The hardware layer is not a silver bullet.  It is important to understand how it works, and to use it properly, otherwise you may face a big problem. <br><br><h4>  <b>Do it yourself</b> </h4><br>  In preparing for all these examples shown here, I wrote a lot of code to simulate these situations.  You can find them on <a href="https://github.com/Udinic/PerformanceDemo">the Github repository</a> , as well as on <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.udinic.perfdemo">Google Play</a> .  I shared the scenarios for various activations, and tried to document them as much as possible, to help understand what kind of problems you might encounter using activations.  Read the activation documentation, open the tools and play with the app. <br><br><h4>  <b>More information</b> </h4><br>  As the Android OS evolves, the ways in which you can optimize your applications are evolving.  New tools are introduced in the Android SDK, and new functions are added to the OS (for example, hardware levels).  It is very important to learn new things and study compromises before you decide to change something. <br><br>  There is a great YouTube playlist called <a href="https://www.youtube.com/playlist%3Flist%3DPLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Android Performance Patterns</a> , with a lot of short videos from Google explaining various performance related things.  You can find comparisons between different data structures (HashMap vs ArrayMap), Bitmap optimization, and even optimization of network requests.  I highly recommend watching all of them. <br><br>  Join the <a href="https://plus.google.com/communities/116342551728637785407">Android Performance Patterns Google+ community</a> and discuss performance with other contributors, including Google employees, to share ideas, articles, and questions. <br><br><h4>  <b>Other interesting links</b> </h4><br><ul><li>  Learn how <a href="http://source.android.com/devices/graphics/architecture.html">Graphics Architecture in Android</a> works.  It has everything you need to know about drawing your UI on Android, explains the various system components, such as SurfaceFlinger, and how they all interact with each other. <br><br></li><li>  <a href="https://www.youtube.com/watch%3Fv%3DQ8m9sHdyXnE">Talk from Google IO 2012</a> shows how the drawing model works and how / why we get garbage when our UI is drawn. <br><br></li><li>  Android Performance Workshop talk from Devoxx 2013 demonstrates some of the optimizations that were made in Android 4.4 in the drawing model and presents various tools for optimizing performance (Systrace, Overdraw, etc.). <br><br></li><li>  A wonderful post about <a href="https://medium.com/google-developers/the-truth-about-preventative-optimizations-ccebadfd3eb5">Preventive Optimization</a> , and how it differs from Premature Optimization.  Many developers do not optimize their code, because they think that this change is insignificant.  One thought you need to remember is that all this adds up to a <a href="https://plus.google.com/105051985738280261832/posts/YDykw2hstUu">big problem</a> .  If you have the opportunity to optimize only a small part of the code, this may seem insignificant, I do not exclude. <br><br></li><li>  <a href="https://www.youtube.com/watch%3Fv%3D_CruQY55HOk">Android memory management</a> is an old video from Google IO 2011, which is still relevant.  It demonstrates how Android manages the memory of our applications, and how to use tools like Eclipse MAT to identify problems. <br><br></li><li>  <a href="http://www.curious-creature.com/docs/android-performance-case-study-1.html">A case study</a> done by Google Romain Guy, an engineer, to optimize a popular twitter client.  In this study, Romain shows how he found performance problems in the application and what he recommends doing to fix them.  <a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/">Here is the next post</a> showing other problems after it has been recycled. <br></li></ul><br>  I hope you now have enough information and more confidence to start optimizing your applications today! <br><br>  Start tracing, or turn on some of the other available developer options, and just start with them.  I propose to share your thoughts in the comments. </div><p>Source: <a href="https://habr.com/ru/post/271811/">https://habr.com/ru/post/271811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271797/index.html">COUNT (*)</a></li>
<li><a href="../271799/index.html">An example of express analysis of the performance of storage using the free service Mitrend</a></li>
<li><a href="../271803/index.html">Google spam confession</a></li>
<li><a href="../271805/index.html">Jira Automation on Groovy</a></li>
<li><a href="../271809/index.html">Investigation of the installation error Visual Studio 2015</a></li>
<li><a href="../271813/index.html">New Acquisition Options and Free Visual Studio 2015 Offers</a></li>
<li><a href="../271815/index.html">Today‚Äôs world is amd64, armv7 and aarch64. Everything else is dead, Jim</a></li>
<li><a href="../271817/index.html">"Black Friday" or "Buy Nothing Day"? Your choice? Do not buy dedicated servers in the Netherlands at a 30% discount in addition?</a></li>
<li><a href="../271819/index.html">State management and efficient rendering in React applications</a></li>
<li><a href="../271823/index.html">Network monitoring: how we make sure that large companies have all the nodes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>