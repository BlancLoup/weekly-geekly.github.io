<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular Expression Crossword Algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably, anyone who is interested in regular expressions and reads Habr, saw this crossword from regular expressions: 





 It takes from 30 minutes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular Expression Crossword Algorithm</h1><div class="post__text post__text-html js-mediator-article"><p>  Probably, anyone who is interested in regular expressions and reads Habr, saw this crossword from regular expressions: </p><br><p><img src="https://habrastorage.org/storage2/dea/28a/b96/dea28ab964aca8a9c98e96bcd9f42328.png" alt="image"></p><br><p>  It takes from 30 minutes to several hours to solve it, but your computer can solve it in just a few minutes.  And not only this crossword puzzle, but any crossword from regular expressions can be done by the algorithm under the cut. </p><a name="habracut"></a><br><p>  I will try to give as little code as possible - you will find all the code written in Python3 on <a href="https://github.com/ReinRaus/RegexCrossTool">GitHub</a> . </p><br><h1 id="shag-0-uslovnye-oboznacheniya-i-aksiomy">  Step 0. Notation and axioms </h1><br><p> <strong>Axiom.</strong>  If a regular expression crossword has a unique finite solution, then all the characters that will be encountered in the solution are not specified by negative character classes and not by the metacharacter <code>.</code> </p><br><p>  That is, suppose there are only character classes in a certain crossword: <code>[ABC]</code> , <code>[^ABC]</code>  , then the solution of the crossword will consist solely of the characters <code>A</code> , <code>B</code> and <code>C</code> </p><br><p>  <strong>Atom.</strong>  An ‚Äúatom‚Äù is a character class, a single literal, or a metacharacter of a character class that is part of the regular expression being parsed. </p><br><p>  One "atom" - one character in the text.  The concept of "atom" will be used not to confuse them with character classes inside a regular expression. </p><br><p>  For example, the regular expression <code>[ABC]*ABC[^ABC].\w</code> consists of seven "atoms" <code>[ABC], A, B, C, [^ABC], . , \w</code> <code>[ABC], A, B, C, [^ABC], . , \w</code> </p><br><p>  <strong>Crossword map, map.</strong>  An array of dependencies between different regular expressions for a single crossword puzzle cell.  The card contains information that in this field cell there is (for example) the 1st character of the 3rd regular expression, as well as the 5th character of the 8th regular expression, as well as the 3rd character of the 12th regular expression.  Simply put - in which positions regular expressions intersect. </p><br><h1 id="shag-1-perebiraem-vse-varianty-dlya-atomov">  Step 1. Enumerate all the options for "atoms" </h1><br><p>  If you try to solve a crossword puzzle "head on" by a complete enumeration of all the characters, then immediately there will be a problem that you will not be able to wait a few million years, too many options.  And yet, the algorithm is a complete search, but not individual characters, but "atoms". </p><br><p>  For example, take a regular expression <code>.*(IN|SE|HI)</code> .  In this crossword, it should be a string of 13 characters in length. </p><br><p>  First we find in the regular expression all the unique "atoms" by the regular expression: </p><br><pre> <code class="python hljs">reChars = <span class="hljs-string"><span class="hljs-string">r"\[\^?[az]+\]|[az]|\."</span></span> reCharsC = re.compile( reChars, re.I )</code> </pre> <br><p>  It searches for character classes, single characters, and the dot metacharacter.  Currently there is no support for metacharacters like <code>\w</code> , <code>\d</code> , etc., only the most necessary. </p><br><p>  In the expression under consideration, we find such "atoms": </p><br><pre> <code class="python hljs">[ <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'N'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-string"><span class="hljs-string">'H'</span></span> ]</code> </pre> <br><p>  "Atoms" must be "atomized" in order to treat their string notation as an inseparable whole, rather than individual characters: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( m )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"(?:"</span></span>+re.escape( m.group(<span class="hljs-number"><span class="hljs-number">0</span></span>) )+<span class="hljs-string"><span class="hljs-string">")"</span></span> self.regex2 = reCharsC.sub( repl, self.regex )</code> </pre> <br><p>  At the input <code>.*(IN|SE|HI)</code> , at the output <code>(?:\.)*((?:I)(?:N)|(?:S)(?:E)|(?:H)(?:I))</code> .  What will it give?  Now you can iterate over all "atoms" for a length of 13 "atoms", apply <code>self.regex2</code> to the resulting string and check for consistency.  For example: </p><br><table><thead><tr><th>  Reg.  expression </th><th>  Atomic Reg Expression </th><th>  Length </th><th>  Line </th><th>  Result </th></tr></thead><tbody><tr><td> <code>.*(IN|SE|HI)</code> </td> <td> <code>(?:\.)*((?:I)(?:N)|(?:S)(?:E)|(?:H)(?:I))</code> </td> <td>  13 </td><td> <code>SE...........</code> </td> <td>  does not match </td></tr><tr><td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>..SHI.....</code> </td> <td>  does not match </td></tr><tr><td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>...........IN</code> </td> <td>  corresponds to </td></tr><tr><td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>...........SE</code> </td> <td>  corresponds to </td></tr><tr><td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>-*-</code> </td> <td> <code>...........HI</code> </td> <td>  corresponds to </td></tr><tr><td> <code>[^X]*</code> </td> <td> <code>(?:\[\^X\])*</code> </td> <td>  3 </td><td> <code>[^X][^X][^X]</code> </td> <td>  corresponds to </td></tr></tbody></table><br><p>  The result of a complete iteration to the regular expression under consideration will be an array of three elements: </p><br><pre> <code class="python hljs">[ <span class="hljs-string"><span class="hljs-string">'...........IN'</span></span>, <span class="hljs-string"><span class="hljs-string">'...........SE'</span></span>, <span class="hljs-string"><span class="hljs-string">'...........HI'</span></span> ]</code> </pre> <br><p>  Agree that a very obvious result? </p><br><p>  You can experiment with different regular expressions like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> regexCrossTool <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tool print( tool.singleRegex( regex, length ).variants )</code> </pre> <br><h1 id="shag-2-optimizaciya">  Step 2. Optimization </h1><br><p>  In the previous step, it was so easy to say that a regular expression <code>.*(IN|SE|HI)</code> will give only 3 possible variants of the string, but in fact in the expression 6 "atoms" and the length 13 "atoms", which means 6 to 13 degrees of options for enumeration. </p><br><p>  A few days of iteration is not the most promising prospect, so the first optimization is essentially only for this expression, but in fact all the optimizations are written in an honest way - they parse the regular expression at the input and optimize the calculations if they meet a suitable template. </p><br><p>  Expression <code>.*(IN|SE|HI)</code> very easy to optimize: </p><br><pre> <code class="python hljs">reCh = <span class="hljs-string"><span class="hljs-string">r"(?:"</span></span>+reChars+<span class="hljs-string"><span class="hljs-string">")+"</span></span> re1 = <span class="hljs-string"><span class="hljs-string">r"(?!^)\((?:"</span></span>+reCh+<span class="hljs-string"><span class="hljs-string">r"\|)+"</span></span>+reCh+<span class="hljs-string"><span class="hljs-string">r"\)$"</span></span></code> </pre> <br><p>  We look for an alternative at the end of the line, check that all parts of the alternative are the same length, select everything to the left of this alternative and process them separately, taking into account that the length of the expected result is reduced by the length of the part of the alternative. </p><br><p>  <code>singleRegex( ".*", 11 )</code> will return only one possible option <code>...........</code> <br>  In the cycle we go through all returned options and all parts of the alternative.  The concatenations are returned as the result for the original regular expression. </p><br><p>  Opening hours have been reduced from a few days to 20 minutes.  Good result, but you need better. </p><br><p>  The following optimization is very similar to the first.  We optimize the regular expression, which is represented by just one alternative and quantifier to the alternative.  There are several such expressions in this crossword: <code>(DI|NS|TH|OM)*</code> , <code>(O|RHH|MM)*</code> , <code>(E|CR|MN)*</code> , <code>(S|MM|HHH)*</code> </p><br><p>  Instead of a complete search, we will write a simple recursive function: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( arr, string, length )</span></span></span><span class="hljs-function">:</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr: newstr = string + i lenChars = len( reCharsC.findall( newstr ) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lenChars == length: res.append( newstr ) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> lenChars &gt; length: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: recres = recur( arr, newstr, length ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> recres: res.append( j ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res recur( <span class="hljs-string"><span class="hljs-string">r"(DI|NS|TH|OM)*"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span> )</code> </pre> <br><p>  The result will be obtained in a fraction of a second, and not in a minute and a half, as before optimization. </p><br><p>  Another optimization applies to most regular expressions. <br>  We are looking for two or more single literals, not inside a character class <code>[...]</code> and if there was no bracket <code>(</code> . </p><br><p>  Brackets are avoided because it can mean anything: group, condition, recursion.  Parsing regular expressions with regular expressions is not the best idea, so it‚Äôs better not to bother with complex optimizations.  Let them optimize what they can and what they cannot wait. </p><br><p>  I forgot to add that all optimizations are recursive, so several optimizations can be applied to one regular expression.  Consider the expression <code>[AO]*abc[AO]*def</code> - it will be optimized in 2 passes. </p><br><p>  First, replace <code>abc</code> with <code>[a]</code> , get <code>[AO]*[a][AO]*def</code> , replace <code>def</code> with <code>[aa]</code> on the second pass, get <code>[AO]*[a][AO]*[aa]</code> </p><br><p>  As a result, instead of seven unique character classes <code>[ '[AO]', 'a', 'b', 'c', 'd', 'e', 'f' ]</code> there are three <code>[ '[AO]', '[a]', '[aa]' ]</code> - so full brute force will go much faster, but before returning the result, you need to make the inverse replacements of <code>[a]</code> with <code>abc</code> and <code>[aa]</code> with <code>def</code> . </p><br><p>  The result of optimizations: all options for all regular expressions are considered approximately 40 seconds. </p><br><h1 id="shag-3-sozdaem-kartu-krossvorda">  Step 3. Create a crossword map </h1><br><p>  The algorithm is in the <code>hexaMap.py</code> module and it makes no sense to consider it. <br>  You give him the length of the minimum face of the hexagonal field, and in return the map of this field is returned. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hexaMap maps = hexaMap.getMap( <span class="hljs-number"><span class="hljs-number">7</span></span> ) printer = hexaMap.getPrinter( <span class="hljs-number"><span class="hljs-number">7</span></span> )</code> </pre> <br><p>  <code>printer</code> - the function that receives the result of the calculations will print the solution in accordance with the card. </p><br><h1 id="shag-4-obedinenie">  Step 4. Merge </h1><br><p>  The regular expression <code>.*(IN|SE|HI)</code> will return three options <code>[ '...........IN', '...........SE', '...........HI' ]</code> , we will place them under each other, to make it clearer what is next in question: </p><br><pre> <code class="hljs css">..........<span class="hljs-selector-class"><span class="hljs-selector-class">.IN</span></span> ..........<span class="hljs-selector-class"><span class="hljs-selector-class">.SE</span></span> ..........<span class="hljs-selector-class"><span class="hljs-selector-class">.HI</span></span></code> </pre> <br><p>  Only the metacharacter can be found in the zero position <code>.</code>  and so on up to the 10th position. <br>  In the 11th position there can be three characters <code>I</code> , <code>S</code> , <code>H</code> <br>  In the 12th position there may be three characters <code>N</code> , <code>E</code> , <code>I</code> </p><br><p>  Create sets ( <code>set()</code> ) for each position separately - this is the union. <br>  The union occurs for each regular expression separately and shows as a result what characters can be in certain positions in the given regular expression. </p><br><p>  Metacharacters and character classes will also be converted to sets.  Remember the axiom?  Create a complete list of characters that make up the crossword puzzle solution: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullABC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( self )</span></span></span><span class="hljs-function">:</span></span> result = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.cross.regexs: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reCharsC.findall( i ): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> re.match( <span class="hljs-string"><span class="hljs-string">r"\[\^"</span></span>, j ) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> j == <span class="hljs-string"><span class="hljs-string">"."</span></span>: result = result.union( self.char2set( j ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result self.fullABC = self.getFullABC()</code> </pre> <br><p>  This complete list matches the metacharacter <code>.</code>  , and negative classes are obtained by subtracting from the full list of characters in the negative class.  To convert "atoms" into sets, use the function: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char2set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( self, char )</span></span></span><span class="hljs-function">:</span></span> char=char.lower() result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convDiap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( diap )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re.sub( <span class="hljs-string"><span class="hljs-string">r"([az])\-([az])"</span></span>, repl, diap, flags=re.I ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( m )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># dh -&gt; defgh res = "" for i in range( ord( m.group(1) ), ord( m.group(2) )+1 ): res+= chr( i ) return res char = char.replace( ".", "[az]" ) char = convDiap( char ) if re.fullmatch( "[az]", char, re.I ): result = set( [char] ) elif re.fullmatch( r"\[[az]+\]", char, re.I ): result = set( char.replace( "[", "" ).replace( "]", "" ) ) elif re.fullmatch( r"\[\^[az]+\]", char, re.I ): result = set( char.replace( "[", "" ).replace( "]", "" ).replace( "^", "" ) ) result = self.fullABC - result return result</span></span></code> </pre> <br><p>  The line <code>char = char.lower()</code> makes a crossword puzzle case-insensitive, if you need to solve a case-sensitive crossword puzzle, you will need to remove it and all <code>re.I</code> flags in the code, but this is pure hardcore, not a crossword puzzle. </p><br><h1 id="shag-5-peresechenie">  Step 5. Crossing </h1><br><p>  The results of the merger are reviewed in accordance with the map.  For example, the 1st character of the 3rd regular expression after the merge may contain <code>{'a', 'b', 'c', 'd'}</code> <br>  The 5th character of the 8th regular expression after the union can contain <code>{'a', 'c', 'd', 'x'}</code> <br>  The 3rd character of the 12th regular expression after the union may contain <code>{'c', 'f', 's'}</code> <br>  This means that in this cell of the crossword puzzle field there can only be the character <code>c</code> </p><br><p>  Having obtained the result of the intersection, it must be placed back into the result of the union in all three dimensions.  Sets <code>{'a', 'b', 'c', 'd'}</code> , <code>{'a', 'c', 'd', 'x'}</code> , <code>{'c', 'f', 's'}</code> replace with set <code>{'c'}</code> . </p><br><h1 id="shag-6-filtraciya-variantov">  Step 6. Filtering options </h1><br><p>  In the previous step, we changed the intersection results. <br>  For example, in the 1st character of the 3rd regular expression instead of <code>{'a', 'b', 'c', 'd'}</code> returned <code>{'c'}</code> , respectively, the options that were given to this position <code>{'a', 'b', 'd'}</code> . </p><br><p>  If at this step at least one option was removed in any regular expression, then we return to step 4, that is, we merge again and again, intersect and filter until these actions bear fruit. </p><br><p>  Here is what we get as a result: </p><br><pre> <code class="hljs markdown"> nhpehasdiomomthf <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> nx <span class="hljs-bullet"><span class="hljs-bullet">* xphmm *</span></span> mmm <span class="hljs-bullet"><span class="hljs-bullet">* rhhmcxnmmcrxemcmccccm mmmmm *</span></span> rxrcmiiihxls <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> e <span class="hljs-bullet"><span class="hljs-bullet">* r *</span></span> <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> <span class="hljs-bullet"><span class="hljs-bullet">* orevcxcc *</span></span> h <span class="hljs-bullet"><span class="hljs-bullet">* xccrrrrhhhrruncxdx *</span></span> xlerrdd <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> gcchh <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span></code> </pre> <br><p>  Asterisks are where the sets continue to contain several values, which means praise to the creators of the crossword, they created it so competently that without analyzing the backlinks it can not be solved. </p><br><h1 id="shag-7-analiz-obratnyh-ssylok">  Step 7. Backlink Analysis </h1><br><p>  Backlinks are the only thing that was not properly processed in the variants, because, for example, the regular expression <code>(...?)\1*</code> for length 6 will return the only option <code>......</code> , that there is a backward in it The link was not used in any way. </p><br><p>  Analysis is a big word.  The game again comes full bust.  After a complete search, try again steps 4-6 and so on until the result is obtained: </p><br><pre> <code class="hljs swift"> nhpehasdiomomthfoxnxa xphmmommmmrhhmcxnmmcr xemcmccccmmmmmmhrxrcm iiihxlsoreoreoreorevc xcchhmxccrrrrhhhrrunc xdxexlerrddmmmmgcchhc <span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><h1 id="a-chto-dalshe">  What's next? </h1><br><p>  Then you can solve crossword puzzles from any regular expressions, no matter what intricate constructions they contain, because the algorithm honestly applies this "atomized" regular expression to "atoms", which means it can contain all possible syntactic constructions of any complexity. </p><br><p>  If there are character classes in the crossword that are not currently supported, welcome to GitHub, because to add new character classes you need to change only <code>char2set</code> and <code>reChars</code> . </p><br><p>  If you would like to have characters like <code>(</code> , <code>[</code> , then again, the GitHub is open. It‚Äôs enough to build a full-fledged regular expression syntax tree and analyze it instead of regular expression parsing. </p><br><p>  Thank you for your attention, I hope that you did not get bored from reading this small article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302662/">https://habr.com/ru/post/302662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302650/index.html">Inertial sensors: cooking recipes for positioning systems</a></li>
<li><a href="../302652/index.html">Adventure Jam 2016</a></li>
<li><a href="../302654/index.html">How Jack Ma managed to overcome his 7 biggest failures</a></li>
<li><a href="../302656/index.html">1000 and 1 repost: a guide on the "share" button in Russian social networks</a></li>
<li><a href="../302660/index.html">Asus automatically updates BIOS / UEFI over HTTP without verification</a></li>
<li><a href="../302664/index.html">Angler EK exploit kit specializes in circumventing EMET security mechanisms</a></li>
<li><a href="../302666/index.html">Google Developers Agency Pro: certification for the best developers of Android applications</a></li>
<li><a href="../302668/index.html">Interview with Baruch Sadogursky: the perfect stack of technologies for enterprise development</a></li>
<li><a href="../302670/index.html">Data Warehouse Testing</a></li>
<li><a href="../302672/index.html">Analysis of the tasks of the third qualifying round of the RCC 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>