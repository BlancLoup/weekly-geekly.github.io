<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Five ways to optimize code for Android 5.0 Lollipop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to make programs faster? One of the effective ways is code optimization. Knowing the features of the platform for which the application is created...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Five ways to optimize code for Android 5.0 Lollipop</h1><div class="post__text post__text-html js-mediator-article">  How to make programs faster?  One of the effective ways is code optimization.  Knowing the features of the platform for which the application is created, you can find effective ways to accelerate it. <br><br> <a href="http://habrahabr.ru/company/intel/blog/263873/"><img src="https://habrastorage.org/files/313/2f2/a12/3132f2a12a074953a955ac7803c27a79.jpg"></a> <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Preliminary Information</font> </h2><br>  <b>ART</b> (Android Runtime) is a new Android application execution environment.  In Android 5.0, Lollipop ART is first used by default.  It includes many enhancements aimed at improving performance.  In this material, we will talk about some of the new features of ART, compare it with the previously used Android Dalvik runtime and share five tips that will make your applications faster. <br><br><h2>  <font color="#0071c5">What's new in ART?</font> </h2><br>  In the course of profiling many Android applications that ran in the Dalvik environment, two key features were discovered that users pay special attention to.  The first feature is the time required to launch the application.  The second is the number of various ‚Äúslowdowns‚Äù (jank).  At its worst, this is a staggering sound, a jerky animation, if not an unexpected stop of the application.  This usually happens because the application takes too much time to prepare the next frame.  As a result, it simply does not keep up with the device screen refresh rate.  Frame formation speed can be a problem if the next frame is formed much faster or slower than the previous one.  If something like this happens, the user sees jerks in the work of the interface elements.  This makes interaction with the program much less convenient than it would be desirable for both users and developers.  In ART, there are several new features designed to solve the problems described above. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Compile before execution.</b>  ART compiles applications during installation using the dex2oat tool installed on the device.  The result is an executable file compiled for the target architecture.  For comparison, Dalvik uses an interpreter and compiles applications on the fly.  During installation, Dalvik converts APK-files into optimized DEX-code, and already during the launch of the application compiles it into machine instructions.  As a result, applications run in the ART environment faster, although the time needed for installation increases.  In addition, with this approach, applications use more flash memory of the device, since additional space is required to store the code compiled during installation. <br><br></li><li>  <b>Improved memory allocation mechanisms.</b>  Applications that use memory intensively may experience performance problems with Dalvik.  Mitigate this problem with a separate storage space for large objects and an improved memory allocation mechanism in ART. <br><br></li><li>  <b>Improved garbage collection</b> .  ART is equipped with a faster garbage collector that supports parallel data processing, which leads to less memory fragmentation and more efficient use of it. <br><br></li><li>  <b>Improved JNI performance.</b>  Optimization of the JNI-code call and return from it, which reduces the number of instructions necessary to make JNI-calls. <br><br></li><li>  <b>Support for 64-bit architectures.</b>  ART feels great on 64-bit architectures.  This improves the performance of many applications when running them on the appropriate hardware. <br></li></ul><br>  The combined effect of these enhancements improves the perception by users of both applications that are written only using the Android SDK and programs that heavily use JNI calls.  The additional benefits, from the point of view of users, include a longer device operation time from a single charge.  The point here is that applications are compiled only once, they run faster, and as a result, they consume less battery power for everyday use. <br><br><h2>  <font color="#0071c5">Performance comparison of ART and Dalvik</font> </h2><br>  When ART was just released, in the form of a preliminary version on Android KitKat 4.4, there were criticisms of its performance in comparison with Dalvik.  I must say that such a comparison can not be called honest.  After all, we compared the early preliminary version of ART with a mature product that has been subjected to many improvements over the years of work on it.  As a result of these early tests, some applications worked in the ART environment more slowly than in Dalvik. <br><br>  Now we have the opportunity to compare the matured ART environment, which is used in mass-produced devices, with Dalvik.  Since Android 5.0 only uses ART, a direct comparison of ART and Dalvik is possible only if you first run tests on a device with Android KitKat 4.4 installed, retrieving data for the Dalvik environment, then update it to Android Lollipop 5.0 and run The same series of tests for the ART-environment. <br><br>  In preparing this material, we did similar tests with the SurfTab xintron i7.0 tablet, which is based on the Intel Atom processor.  At first, Android 4.4.4 was installed on it, and, accordingly, Dalvik was used in tests, then the device was updated to Android 5.0.  and tested the performance of ART. <br><br>  Since the tests were performed on different versions of Android, there is the possibility that some of the improvements found come not from ART, but from other improvements to Android.  However, based on our internal performance analysis, we can say that it is the use of ART that is the main reason for the increase in system performance. <br><br>  We used performance tests in which Dalvik, by aggressively optimizing code that runs many times, is able to gain an advantage.  In addition, we tested the system using a gaming simulator developed by Intel. <br><br>  Based on the data obtained, we can conclude that ART is superior to Dalvik in all of our tests.  In some cases, this superiority is quite significant. <br><br><img src="https://habrastorage.org/files/135/b3d/d94/135b3dd948a04fa89d3cebacef61113b.png"><br>  <i><font color="#999999">Relative test rates ART (Android Lollipop) and Dalvik (Android KitKat)</font></i> <br><br>  Details of the test applications that we used, you can find by clicking on the following links: <br><br><ul><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.aurorasoftworks.quadrant.ui.standard%26hl%3Den">Quadrant 2.1.1</a> <br></li><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.android.cm3%26hl%3Den">CaffeineMark 3.0</a> <br></li><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.smartbench.twelve%26hl%3Den">Smartbench 2012 productivity</a> <br></li><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.antutu.ABenchMark%26hl%3Den">Antutu 4.4 Overall</a> (the version used for testing is no longer available for download) <br></li><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Deu.chainfire.cfbench%26hl%3Den">CF-Bench 1.3 Overall</a> </li></ul><br>  IcyRocks version 1.0 is a device performance testing application created by Intel.  It simulates real computer games.  For most of the calculations, it uses the open source library Cocos2D and the library JBox2D (physics engine, Java Physics Engine).  The application measures the average number of frames that it manages to display per second (FPS, Frame Per Second) at various levels of load.  It then calculates the final indicator, taking the geometric average of the FPS values ‚Äã‚Äãobtained in different modes of operation.  In addition, the program calculates the level of "incorrect" frames per second (jank per second), as the average between such frames at different load levels.  IcyRocks shows the superiority of ART over Dalvik. <br><br><img src="https://habrastorage.org/files/286/742/cb2/286742cb233a4be8bcbc44e12288bc01.png"><br>  <i><font color="#999999">Relative Frames Per Second Performance Testing in ART and Dalvik Environments</font></i> <br><br>  As a result of testing, we managed to find out that in ART the characteristics of frames are more constant than in Dalvik, with fewer ‚Äúwrong‚Äù frames.  As a result, in ART, the application interface runs more smoothly. <br><br><img src="https://habrastorage.org/files/43a/af8/5cd/43aaf85cdec842eaa00073bdfd6ca657.png"><br>  <i><font color="#999999">The relative rates of "wrong" frames per second when tested in ART and Dalvik environments</font></i> <br><br>  The results obtained allow us to say with confidence that today ART allows for better perception of applications by users and greater performance than Dalvik. <br><br><h2>  <font color="#0071c5">Transferring software code from Dalvik to ART</font> </h2><br>  The transition from Dalvik to ART is transparent, most applications that run in the Dalvik environment will work in the ART environment without the need to modify their code.  As a result, when users update the system, applications start to work faster without any additional effort.  However, especially if your applications use Java Native Interface, they will not interfere with testing in the ART environment.  The fact is that ART uses a more rigorous JNI error handling mechanism than Dalvik.  <a href="https://developer.android.com/guide/practices/verifying-apps-art.html">Here</a> you can find out more about it. <br><br><h2>  <font color="#0071c5">Five tips for code optimization</font> </h2><br>  The performance of most of the applications that will be launched in the ART environment will increase only because of the platform improvements we talked about above.  However, there is a set of recommendations, following which you can optimize applications for even greater performance.  Each of the code optimization techniques described below is provided with a simple code example illustrating the features of its work. <br><br>  It is impossible to predict in advance what kind of performance increase can be expected using one or another approach to optimization.  The point here is that all applications are different, their final performance depends very much on the rest of the code and on the features of their use.  However, we will explain why the proposed optimization methods can improve application performance.  In order to assess their impact on your application, test them by applying to your code. <br><br>  Recommendations that we offer are applicable quite widely, but we focus on the fact that when working with ART, improvements will be perceived by the dex2oat compiler, which generates binary executable code from dex files and optimizes it. <br><br><h2>  <font color="#0071c5">Council number 1.</font>  <font color="#0071c5">Whenever possible, use local variables instead of public class fields</font> </h2><br>  By limiting the scope of variables, you will not only improve the readability of the code and reduce the number of potential errors, but also make it better suited for optimization. <br><br>  In a block of non-optimized code, which is shown below, the value of the variable <i>v is</i> calculated during the execution of the application.  This is due to the fact that this variable is available outside the <i>m ()</i> method and can be changed in any part of the code.  Therefore, the value of the variable is unknown at compile time.  The compiler does not know whether the call to the <i>some_global_call ()</i> method will change the value of this variable or not, since the <i>v</i> variable, again, can change any code outside of the method. <br><br>  In the optimized version of this example, <i>v</i> is a local variable.  So, its value can be calculated at the compilation stage.  As a result, the compiler can put the value of a variable in the code it generates, which will help to avoid calculating the value of the variable at run time. <br><table><tbody><tr><td>  <b>Non-optimized code</b> </td><td>  <b>Optimized code</b> </td></tr><tr><td><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{    v = <span class="hljs-number"><span class="hljs-number">42</span></span>;    some_global_call();    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v*<span class="hljs-number"><span class="hljs-number">3</span></span>;  } }</code> </pre> </td><td><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">42</span></span>;   some_global_call();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v*<span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre></td></tr></tbody></table><br><h2>  <font color="#0071c5">Council number 2.</font>  <font color="#0071c5">Use the final keyword to tell the compiler that the field value is a constant.</font> </h2><br>  The <i>final</i> keyword can be used to protect the code from accidentally changing variables that should be constants.  However, it allows you to improve performance, as it tells the compiler that it is a constant before it. <br><br>  In a fragment of a non-optimized code, the value of <i>v * v * v</i> must be calculated during the execution of the program, since the value of <i>v</i> may change.  In the optimized version, using the <i>final</i> keyword when declaring a variable and assigning it a value tells the compiler that the value of the variable will not change.  Thus, the calculation of the value can be made at the compilation stage and a value will be added to the output code, and not commands for its calculation during the execution of the program. <br><table><tbody><tr><td>  <b>Non-optimized code</b> </td><td>  <b>Optimized code</b> </td></tr><tr><td><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v*v*v; } }</code> </pre></td><td><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v*v*v;  } }</code> </pre> </td></tr></tbody></table><br><h2>  <font color="#0071c5">Council number 3.</font>  <font color="#0071c5">Use the final keyword when declaring classes and methods.</font> </h2><br>  Since any method in Java can be polymorphic, declaring a method or class with the <i>final</i> keyword indicates to the compiler that the method is not overridden in any of the subclasses. <br><br>  In a non-optimized version of the code, before calling the <i>m ()</i> function, its permission must be made. <br>  In optimized code, because the <i>m ()</i> method is used to declare the keyword <i>final</i> , the compiler knows which version of the method will be called.  Therefore, it can avoid searching for a method and replace the method call <i>m () with</i> its contents by embedding it in the necessary place of the program.  The result is an increase in performance. <br><table><tbody><tr><td>  <b>Non-optimized code</b> </td><td>  <b>Optimized code</b> </td></tr><tr><td><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>;  } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++)     sum += m(); <span class="hljs-comment"><span class="hljs-comment">// m       return sum; } }</span></span></code> </pre> </td><td><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m(){   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>;  } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f(){   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++)     <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> += m();    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>; } }</code> </pre> </td></tr></tbody></table><br><h2>  <font color="#0071c5">Council number 4.</font>  <font color="#0071c5">Avoid calling small methods via JNI</font> </h2><br>  There are good reasons for using JNI calls.  For example, if you have code or libraries in C / C ++ that you want to reuse in Java applications.  Perhaps you are creating a cross-platform application, or your goal is to increase productivity through the use of low-level mechanisms.  However, it is important to keep the number of JNI calls to a minimum, since each of them creates a significant load on the system.  When JNI is used to optimize performance, this additional burden can negate the expected benefit.  In particular, frequent calls to short, non-significant computational JNI methods can degrade performance.  And if such calls are placed in a loop, then the unnecessary load on the system will only increase. <br><br>  <b>Code example</b> <br><br><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factorial(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x){   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= x; i++)     f *= i;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f;  } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compute (){   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++)     <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> += factorial(i % <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    JNI-  factorial(), //     , //        //          JNI-   return sum; } }</span></span></code> </pre> <br><h2>  <font color="#0071c5">Council number 5.</font>  <font color="#0071c5">Use standard libraries instead of implementing the same functionality in native code.</font> </h2><br>  Standard Java libraries are seriously optimized.  If you use, wherever possible, the internal mechanisms of Java, this will achieve the best performance.  Standard solutions can work much faster than self-written implementations.  Attempting to avoid additional load on the system by refusing to call a standard library function can, in fact, degrade performance. <br>  In a non-optimized version of the code, an attempt is made to avoid calling the standard function <i>Math.abs ()</i> by using our own implementation of the algorithm for obtaining the absolute value of a number.  However, the code in which the library function is called is faster due to the fact that the call is replaced with an optimized internal implementation in ART at compile time. <br><table><tbody><tr><td>  <b>Non-optimized code</b> </td><td>  <b>Optimized code</b> </td></tr><tr><td><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b;   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)     b = a;   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>     b = -a;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } }</code> </pre> </td><td><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.abs(a); } }</code> </pre></td></tr></tbody></table><br><h2>  <font color="#0071c5">Testing optimization techniques</font> </h2><br>  Find out what the performance difference is in the optimized and non-optimized code from tip # 2 when running it in ART.  For the experiment, we will use the Asus Fonepad 8 tablet, built on the basis of the Intel Atom Z3530 CPU.  The device has been updated to Android 5.0. <br><br>  Here is the code we are testing: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ops</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">42</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">42</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnoptimized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v*v*v;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testOptimized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w*w*w;   } }</code> </pre> <br>  The difference between the <i>testUnoptimized</i> and <i>testOptimized methods</i> is that the second is optimized, the variable <i>w</i> , which is used in it, is declared with the keyword <i>final</i> . <br><br>  During the tests, each method will be called a specified number of times.  The cycles in which these calls are made are executed in the background thread.  After the tests are completed, the results are displayed in the user interface of the application. <br><br><img src="https://lh6.googleusercontent.com/2Ih_yGf4onzc3IngADt1GXSR46XWNVntNi_Jg9vUMs8thrAKSut8z8AyDmJUlD4pBP0QXknfoTUS928Gzqbg12L-BSwc3UJSAtcI4wF_erVN-lw_GhdYiXgpEr4YBkEldU5438h5dUfnNh2u"><br>  <i><font color="#999999">Application interface for testing optimization results</font></i> <br><br>  The table shows the results of ten consecutive test launches in the release version of the application.  Each of the individual indicators is obtained by performing a cyclic call to the corresponding method 10 million times. <br><br>  <b>Comparison of execution speed of optimized and non-optimized code</b> <br><table><tbody><tr><td>  No </td><td>  Optimized, ms. </td><td>  Not optimized, ms. </td></tr><tr><td>  one </td><td>  25 </td><td>  193 </td></tr><tr><td>  2 </td><td>  21 </td><td>  203 </td></tr><tr><td>  3 </td><td>  thirty </td><td>  220 </td></tr><tr><td>  four </td><td>  25 </td><td>  175 </td></tr><tr><td>  five </td><td>  23 </td><td>  184 </td></tr><tr><td>  6 </td><td>  28 </td><td>  177 </td></tr><tr><td>  7 </td><td>  thirty </td><td>  186 </td></tr><tr><td>  eight </td><td>  27 </td><td>  191 </td></tr><tr><td>  9 </td><td>  34 </td><td>  212 </td></tr><tr><td>  ten </td><td>  27 </td><td>  174 </td></tr><tr><td>  The average </td><td>  27 </td><td>  191.5 </td></tr></tbody></table>  As a result, it turned out that the optimized method is executed, on average, 7 times faster than the non-optimized one. <br><br>  The source code of the project, suitable for import into Android Studio, can be found <a href="http://rghost.ru/7bLtkxPKS">here</a> . <br><br><h2>  <font color="#0071c5">Intel Optimizations in ART</font> </h2><br>  Intel worked with OEMs of devices, providing them with an optimized version of Dalvik based on Intel processors.  The same thing happens in the case of ART, as a result, the performance of the new runtime environment will increase over time.  Optimized versions of the code will be available either in the Android Open Source Project (AOSP), or directly from device manufacturers.  As before, the optimizations are transparent to both users and developers, that is, in order to take advantage of their benefits, neither one nor the other will have to make additional efforts. <br><br>  To learn more about optimizing Android applications for devices based on Intel processors, see the compilers, visit the <a href="https://software.intel.com/ru-ru/">Intel Developer Zone</a> . <br><br><h2>  <font color="#0071c5">Results</font> </h2><br>  In this material, we reviewed the main features of the new runtime environment for Android applications, ART.  Other things being equal, it achieves better performance than Dalvik.  But the speed of each specific application is very much dependent not only on the execution environment, but also on the developer.  We hope our tips on code optimization will help you in writing fast and convenient applications. </div><p>Source: <a href="https://habr.com/ru/post/263873/">https://habr.com/ru/post/263873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263861/index.html">Alarm, ahtung, attention, whistle all the server</a></li>
<li><a href="../263863/index.html">How to find a place on earth and not get to the Yandex counter</a></li>
<li><a href="../263865/index.html">5G radio interface</a></li>
<li><a href="../263869/index.html">Twisted architecture</a></li>
<li><a href="../263871/index.html">When the program falls only on Wednesdays</a></li>
<li><a href="../263875/index.html">How I gathered the skeleton of the bot to order a taxi in Telegram</a></li>
<li><a href="../263877/index.html">Zip-quest about space admin Vasily Romanov</a></li>
<li><a href="../263879/index.html">HP ProLiant Gen9 Server Line</a></li>
<li><a href="../263881/index.html">github attracted $ 250M investment</a></li>
<li><a href="../263883/index.html">Create a universal Install Server for an automatic network installation of Linux and Windows based on Cobbler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>