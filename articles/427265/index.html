<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protobuffers are wrong</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much of my professional life, I oppose the use of Protocol Buffers. They are clearly written by amateurs, incredibly narrowly specialized, suffer from...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protobuffers are wrong</h1><div class="post__text post__text-html js-mediator-article">  Much of my professional life, I oppose the use of Protocol Buffers.  They are clearly written by amateurs, incredibly narrowly specialized, suffer from a variety of pitfalls, are difficult to compile and solve a problem that in fact no one else has but Google.  If these problems of protobuffers remained in the quarantine of serialization abstractions, then my complaints would have ended.  But unfortunately, the bad design of Protobuffers is so intrusive that these problems can leak into your code. <br><br>  <b>Narrow specialization and development by amateurs</b> <br><br>  Stop it.  Close your email client, where they have already sent me a half letter saying that ‚Äúthe best engineers in the world are working at Google,‚Äù that ‚Äúby definition, their development cannot be created by amateurs‚Äù.  I don't want to hear that. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's just not discuss this topic.  Full disclosure: I've worked at Google.  It was the first (but, unfortunately, not the last) place where I have ever used Protobuffers.  All the problems I want to talk about exist in the Google code base;  it is not just "the misuse of protobuffers" and similar nonsense. <br><a name="habracut"></a><br>  Of course, the biggest problem with Protobuffers is a terrible type system.  Java fans should feel at home here, but, unfortunately, literally no one considers Java as a well-designed type system.  The guys from the dynamic typing camp complain about excessive restrictions, while representatives of the static typing camp, like me, complain about excessive restrictions and the lack of everything that you really want from the type system.  Losing in both cases. <br><br>  Narrow specialization and development by amateurs go hand in hand.  Much of the specifications seem to be screwed at the last moment - and it was clearly screwed at the last moment.  Some restrictions will make you stop, scratch your head and ask: ‚ÄúWhat the hell?‚Äù But these are just symptoms of a deeper problem: <br><br>  Obviously, the protobuffers were created by amateurs, because they offer poor solutions to well-known and already solved problems. <br><br><h1>  Lack of composition </h1><br>  Protobuffers offer several features that do not work with each other.  For example, look at the list of orthogonal, but at the same time limited, typing functions that I found in the documentation. <br><br><ul><li> <code>oneof</code> fields cannot be <code>repeated</code> . </li><li>  There is a special syntax for keys and values ‚Äã‚Äãin <code>map&lt;k,v&gt;</code> fields, but it is not used in any other types. </li><li>  Although <code>map</code> fields can be parameterized, no more user-defined type is possible.  This means that you are stuck with manually specifying your own specializations of common data structures. </li><li>  <code>map</code> fields cannot be <code>repeated</code> . </li><li>  <code>map</code> keys <i>can</i> be <code>string</code> , but <i>not</i> <code>bytes</code> .  Enum is also prohibited, although the latter are considered equivalent to integers in all other parts of the Protobuffers specification. </li><li>  <code>map</code> values ‚Äã‚Äãcan not be other <code>map</code> . </li></ul><br>  This insane list of restrictions is the result of an unprincipled choice of design and screwing functions at the last moment.  For example, one of the fields can not be <code>repeated</code> , because instead of a side type the code generator will produce mutually exclusive optional fields.  Such a transformation is valid only for a singular field (and, as we will see later, does not work even for it). <br><br>  The restriction of <code>map</code> fields, which cannot be <code>repeated</code> , is approximately from the same opera, but shows another type system restriction.  Behind the scenes, the <code>map&lt;k,v&gt;</code> transformed into something like a <code>repeated Pair&lt;k,v&gt;</code> .  And since <code>repeated</code> is a magic keyword of a language, and not a normal type, it is not combined with itself. <br><br>  Your guesses about the problem with <code>enum</code> are as true as mine. <br><br>  What is so frustrating about all this is the poor understanding of how modern type systems work.  This understanding would <i>dramatically simplify</i> the Protobuffers specification and, at the same time, <i>remove any arbitrary restrictions</i> . <br><br>  The solution is as follows: <br><br><ul><li>  Make all the fields in the <code>required</code> message.  This makes each message <i>a</i> product type. </li><li>  Raise the value of <code>oneof</code> field to autonomous data types.  This will be the coproduct type. </li><li>  Allow other types to parameterize product types and products. </li></ul><br>  That's all!  These three changes are all you need to determine any possible data.  With this simple system, you can redo all the other specifications of Protobuffers. <br><br>  For example, you can remake the <code>optional</code> fields: <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Creating fields <code>repeated</code> also easy: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Of course, the actual serialization logic allows you to do something smarter than push related lists across the network - after all, <a href="http://reasonablypolymorphic.com/blog/follow-the-denotation/">implementation and semantics do not have to match each other</a> . <br><br><h1>  Doubtful choice </h1><br>  Java-based Protobuffers distinguishes <i>scalar</i> types and <i>message</i> types.  The scalars more or less correspond to the machine primitives ‚Äî things like <code>int32</code> , <code>bool</code> and <code>string</code> .  On the other hand, message types are everything else.  All library and user types are messages. <br><br>  Of course, the two types of types have completely different semantics. <br><br>  Fields with scalar types are always present.  Even if you have not installed them.  I have already said that (at least in proto3 <a href="https://habr.com/ru/post/427265/"><sup>1</sup></a> <a name="1_1"></a>  ) are all protobuffers initialized with zeros, even if they have absolutely no data?  Scalar fields get fake values: for example, <code>uint32</code> initialized to <code>0</code> , and <code>string</code> initialized to <code>""</code> . <br><br>  It is impossible to distinguish a field that was missing in the protobuffer from a field to which a default value is assigned.  Presumably, this decision is made to optimize, so as not to send scalar defaults.  This is only an assumption, because this optimization is not mentioned in the documentation, so your assumption will be no worse than mine. <br><br>  When we discuss Protobuffers claims of an ideal solution for backward and future API compatibility, we will see that this inability to distinguish between unspecified values ‚Äã‚Äãand default values ‚Äã‚Äãis a real nightmare.  Especially if it is a truly conscious decision to save one bit (set or not) for the field. <br><br>  Compare this behavior with message types.  While scalar fields are stupid, the behavior of message fields is completely <i>insane</i> .  Internally, the message fields are either there or they are not, but the behavior is crazy.  A small pseudocode for their accessor is worth a thousand words.  Imagine this in Java or somewhere else: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  In theory, if the <code>foo</code> field is not set, you will see a default initialized copy, ask you or not, but you cannot change the container.  But if you change <code>foo</code> , it will also change its parent!  All this is just to avoid using the <code>Maybe Foo</code> type and its associated ‚Äúheadache‚Äù to figure out what an unspecified value should mean. <br><br>  This behavior is especially flagrant because it violates the law!  We expect the job <code>msg.foo = msg.foo;</code>  will not work.  Instead, the implementation actually quietly changes <code>msg</code> to a copy of <code>foo</code> with zero initialization if it was not there before. <br><br>  Unlike scalar fields, at least here you can determine that the message field is not set.  Language bindings for protobuffers offer something like the generated <code>bool has_foo()</code> method.  If it is present, then in case of frequent copying of the message field from one protobuffer to another, the following code should be written: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Note that, at least in statically typed languages, this template <i>cannot be abstracted</i> due to the nominal relationship between the <code>foo()</code> , <code>set_foo()</code> and <code>has_foo()</code> .  Since all these functions are own <i>identifiers</i> , we have no means for their program generation, with the exception of the preprocessor macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (but preprocessor macros are not allowed by Google style guides). <br><br>  If instead all of the additional fields were implemented as <code>Maybe</code> , you could easily put abstracted call points. <br><br>  To change the subject, let's talk about another dubious decision.  Although you can define oneof fields in <code>oneof</code> , their semantics <i>does not match the</i> type of coproduct!  Newbie bug, guys!  Instead, you get an optional field for each one of the cases and a magic code in the setters that will simply cancel any other field, if it is set. <br><br>  At first glance it seems that this should be semantically equivalent to the correct type of union.  But instead we get a disgusting, indescribable source of errors!  When this behavior is combined with the illegal implementation, <code>msg.foo = msg.foo;</code>  , this seemingly normal assignment silently deletes arbitrary amounts of data! <br><br>  As a result, this means that <code>oneof</code> fields <code>oneof</code> not form law-abiding <code>Prism</code> , and messages do not form law-abiding <code>Lens</code> .  So good luck with trying to write non-trivial manipulations with protobuffers without bugs.  <i>It is literally impossible to write a universal, error-free, polymorphic code on protobuffers</i> . <br><br>  This is not very pleasant to hear, especially among us who love parametric polymorphism, which <i>promises exactly the opposite</i> . <br><br><h1>  Lies backward and future compatibility </h1><br>  One of the commonly referred to as ‚Äúkiller features‚Äù Protobuffers is their ‚Äúhassle-free ability to write back and forward-compatible APIs‚Äù.  This statement was hung in front of your eyes to obscure the truth. <br><br>  What Protobuffers are <i>permissive</i> .  They manage to cope with messages from the past or the future, because they make absolutely no promises what your data will look like.  Everything is optional!  But if you need it, Protobuffers will gladly cook and serve you something with a type check, regardless of whether it makes sense. <br><br>  This means that the Protobuffers perform the promised ‚Äútime travel‚Äù by <i>quietly doing the wrong things by default</i> .  Of course, a cautious programmer can (and should) write code that checks the correctness of the received protobuffers.  But if you write defensive validation checks on each site, maybe it just means that the deserialization step was too permissive.  All you managed to do was to decentralize the validation logic from a clearly defined boundary and spread it across the entire codebase. <br><br>  One of the possible arguments is that the protobuffers will keep in the message any information that they do not understand.  In principle, this means non-destructive transmission of a message through an intermediary who does not understand this version of the scheme.  This is a clear victory, isn't it? <br><br>  Of course, on paper this is a cool feature.  But I have never seen an application where this property is really stored.  With the exception of routing software, no program wants to check only certain bits of a message, and then forward it unchanged.  The vast majority of programs on the protobuffers will decode the message, transform it into another one and send it to another place.  Alas, these transformations are made to order and encoded manually.  And manual transformations from one protobuffer to another do not save unknown fields, because it is literally meaningless. <br><br>  This ubiquitous attitude to protobuffers as universally compatible is also manifested in other ugly ways.  Protobuffers style guides actively oppose DRY and suggest that they embed definitions in code as much as possible.  They argue that this will allow the use of individual messages in the future if the definitions diverge.  I emphasize that they propose to abandon the 60-year practice of good programming <i>, just in case</i> , all of a sudden you will need to change something in the future. <br><br>  The root of the problem is that Google combines the value of data with its physical representation.  When you are on the Google scale, this makes sense.  In the end, they have an internal tool that compares the programmer's hourly pay using the network, the cost of storing X bytes, and other things.  Unlike most technology companies, the salary of programmers is one of the smallest items of expenditure of Google.  Financially, it makes sense for them to spend the time of programmers to save a couple of bytes. <br><br>  In addition to the five leading technology companies, no one else is within five orders of magnitude of Google.  Your startup <i>cannot afford to</i> spend engineering hours on saving bytes.  But saving bytes and wasting programmers in the process is exactly what Protobuffers are optimized for. <br><br>  Let's face it.  You do not fit the scale of Google, and never will.  Stop using technology only because "Google uses it," and because "these are industry best practices." <br><br><h1>  Protobuffers pollutes code bases </h1><br>  If it were possible to limit the use of Protobuffers only to the network, I would not speak so harshly about this technology.  Unfortunately, although in principle there are several solutions, none of them are good enough to actually be used in real software. <br><br>  Protobuffers correspond to the data you want to send over the communication channel.  They often <i>correspond</i> , but are not <i>identical, to the</i> actual data with which the application would like to work.  This puts us in an awkward position; you must choose between one of three bad choices: <br><br><ol><li>  Maintain a separate type that describes the data that you really need, and guarantee simultaneous support for both types. </li><li>  Pack complete data in a format for transmission and use by the application. </li><li>  Extract complete data each time it is needed, from a short format for transmission. </li></ol><br>  Option 1 is definitely a ‚Äúright‚Äù solution, but it is not suitable for Protobuffers.  The language is not powerful enough to encode types that can do double work in two formats.  This means that you have to write a completely separate data type, develop it synchronously with Protobuffers and <i>specifically write serialization code for them</i> .  But since most people seem to use Protobuffers to not write serialization code, this option is obviously never implemented. <br><br>  Instead, code using protobuffers allows them to be distributed throughout the codebase.  This is reality.  My main project at Google was the compiler, which took a ‚Äúprogram‚Äù written on one type of Protobuffers, and gave an equivalent ‚Äúprogram‚Äù to another.  The input and output formats were different enough that their correct parallel versions of C ++ never worked.  As a result, my code could not use any of the rich compiler writing techniques, because the data from Protobuffers (and the generated code) was too hard to do anything interesting with them. <br><br>  As a result, instead of 50 lines of <a href="https://github.com/passy/awesome-recursion-schemes">recursion schemes</a> , 10,000 lines of special buffer shuffling were used.  The code I wanted to write was literally impossible with protobuffers. <br><br>  Although this is one case, it is not unique.  Due to the harsh nature of code generation, the manifestations of protobuffers in languages ‚Äã‚Äãwill never be idiomatic, and they cannot be made so - except to rewrite the code generator. <br><br>  But even then, you still have the problem of embedding the crap type system into the target language.  Since most of the features of Protobuffers are poorly thought out, these questionable properties leak into our code bases.  This means that we have to not only implement, but also use these bad ideas in any project that hopes to interact with Protobuffers. <br><br>  On a solid basis, it is easy to realize meaningless things, but if you go in a different direction, at best you will encounter difficulties, and at worst - with real ancient horror. <br><br>  In general, give up hope to everyone who incorporates Protobuffers into their projects. <br><br><hr><br><a name="1"></a>  1. To this day, Google has a stormy discussion about proto2 and whether to ever mark fields as <code>required</code> .  At the same time, the manifesto ‚Äú <code>optional</code> is considered harmful‚Äù <i>and</i> ‚Äú <code>required</code> is considered harmful.‚Äù  Good luck with this guys.  <a href="https://habr.com/ru/post/427265/">‚Üë</a> </div><p>Source: <a href="https://habr.com/ru/post/427265/">https://habr.com/ru/post/427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427253/index.html">typeof Everything and duck misunderstandings</a></li>
<li><a href="../427255/index.html">Cowon D2: musical long-liver</a></li>
<li><a href="../427257/index.html">Cameron Craig: Seven Lessons Learned in 10 Years of Managing Apple's PR Department</a></li>
<li><a href="../427259/index.html">What the Turing Test actually tests</a></li>
<li><a href="../427263/index.html">Be a security ninja: webinar recording and bonus level</a></li>
<li><a href="../427267/index.html">SNMP + Java is a personal experience. Writing MIB files parser</a></li>
<li><a href="../427269/index.html">Google OKR Video Five Years Later - Review of Google Ventures OKR Implementation Experience (2012-2017)</a></li>
<li><a href="../427271/index.html">History and experience of using machine translation. Yandex lecture</a></li>
<li><a href="../427273/index.html">Can artificial intelligence leave bookmakers out of work?</a></li>
<li><a href="../427275/index.html">Information architecture on the Internet, part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>