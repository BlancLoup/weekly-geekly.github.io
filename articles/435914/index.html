<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pack ASP.NET Core Applications with Docker</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ASP.NET Core applications are truly cross-platform and can be run in Nix, and, accordingly, in Docker. Let's see how they can be packaged to be deploy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pack ASP.NET Core Applications with Docker</h1><div class="post__text post__text-html js-mediator-article"><p>  ASP.NET Core applications are truly cross-platform and can be run in Nix, and, accordingly, in Docker.  Let's see how they can be packaged to be deployed on Linux and used in conjunction with Nginx.  Details under the cut! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Note: we continue the series of publications of the full versions of articles from the magazine Hacker.</em>  <em>Spelling and punctuation of the author saved.</em> </p><br><h2>  About docker </h2><br><p>  About microservice architecture heard almost everything.  The very concept of breaking the application into parts is not to say that a new one.  But the new is well forgotten and reworked old. </p><br><p>  If you try to talk about architecture in a few words, the web application is divided into separate unitary parts - services.  Services do not interact with each other directly and do not have common databases.  This is done to be able to change each service without consequences for others.  Services are packaged in containers.  Among the containers rules Docker Ball. </p><br><p>  In order to describe what Docker is, it is very often simplistic to use the term ‚Äúvirtual machine‚Äù.  There is definitely a similarity, but to say so is wrong.  The easiest way to understand this difference is to look at the following images from the official documentation of the docker: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Containers use the core of the current operating system and divide it among themselves.  While virtual machines using hypervisor use hardware resources. <br>  The image / image of the docker is a read-only object, which, in essence, stores the template for building the container.  The container is the environment in which the code is executed.  Images are stored in repositories.  For example, the official <a href="https://hub.docker.com/">Docker Hub</a> repository allows you to store only one image in private.  However, it's free, so even for that you need to thank them. </p><br><h1>  INFO </h1><br><p>  Docker is not the only representative of containerization.  In addition to it, there are other technologies.  For example: </p><br><p>  <a href="https://coreos.com/rkt/">rkt</a> (pronounced 'rocket') from CoreOS </p><br><p>  <a href="https://www.ubuntu.com/containers/lxd">LXD</a> (pronounced 'leksdi') from Ubuntu </p><br><p>  Windows Containers - never guess from anyone. </p><br><p>  Now that we are familiar with the theory, let's move on to practice. </p><br><p>  Installing the docker does not make much sense to disassemble, because it can be installed on many operating systems.  I will only indicate that you can download it for your platform from the <a href="https://store.docker.com/search%3Ftype%3Dedition%26amp%3Boffering%3Dcommunity">Docker Store</a> .  If you install Docker under Windows, it is necessary that virtualization is enabled in the BIOS and in the OS.  You can read about how to enable it in 10-ke in the following article: <a href="https://docs.microsoft.com/ru-ru/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">Installing Hyper-V in Windows10</a> </p><br><h2>  Creating a project with docker support </h2><br><p>  Docker is, of course, a Linux-based product, but if necessary you can use it when developing for Mac or for Windows.  When creating a project in Visual Studio, to add docker support, simply tick the Enable Docker Support checkbox. </p><br><p>  Docker support can be added to an existing project.  It is added to the project in the same way as various new components are added.  Context Menu Add - Docker Support. </p><br><p>  If a docker is installed and running on your machine, the console will be automatically opened and the command </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  which starts the process of downloading the image.  This image is actually a blank on the basis of which your image will be created.  ASP.NET Core 2.1 uses a different image - <a href="https://hub.docker.com/r/microsoft/dotnet/">microsoft / dotnet: sdk</a> </p><br><p>  The following files will be automatically created for you in the solution directory: <br>  .dockerignore (excluding files and directories from the docker image), docker-compose.yml (with this file you can configure the execution of several services), docker-compose.override.yml (docker-compose helper configuration), docker-compose.dcproj ( project file for Visual Studio). </p><br><p>  A Dockerfile file will be created in the project directory.  Actually, with the help of this file we create our own image.  By default (in case the project is called DockerServiceDemo) it may look something like this: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  The initial configuration for .NET Core 2.0 will not allow you to immediately build an image using the docker build command.  It is configured to run the docker-compose file from a higher directory.  In order to build successfully, Dockerfile can be brought to a similar form: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  All I did was remove the extra DockerServiceDemo directory. </p><br><p>  If you are using Visual Studio Code, then you have to generate the files manually.  Although VS Code has auxiliary functionality in the form of the <a href="https://marketplace.visualstudio.com/items%3FitemName%3DPeterJausovec.vscode-docker">Docker</a> extension. I will add a link to the manual on how to work with the VS Code - <a href="https://code.visualstudio.com/docs/azure/docker">Working with Docker</a> .  Yes, the article is in English, but it‚Äôs with pictures. </p><br><h2>  "Three chords" docker </h2><br><p>  For daily work with the docker, just remember a few commands. </p><br><p>  The most important team is, of course, building an image.  In order to do this, you need to use bash / CMD / PowerShell to go to the directory where the Dockerfile is located and execute the command: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Here, after the -t parameter, the name of your image is specified.  Attention - at the end of the command after the space point.  This dot means that the current directory is used.  You can mark an image with any tag (number or name).  To do this, after the name put a colon and specify the tag.  If the tag is not specified, then by default it will be set with the name latest.  To send an image to the repository, it is necessary that the name of the image includes the name of the repository.  Like that: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Here your_docker_account_name is the name of your docker hub account. </p><br><p>  If you have created an image with a local name that does not include a repository, then you can mark the image with another name after building using the following command: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  In order to send changes to the hub, you must now run the following command: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Before this, you must log into your docker account.  On Windows, this is done from the UI of the application, but on * nix, this is done by the command: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  In fact, three teams are not enough.  You must also be able to check the operation of the container  The command to start the container looks like this: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  The -it option will create a pseudo-TTY and your container will respond to requests.  After running the command, the service will be available at <a href="http://localhost:5000/">http: // localhost: 5000 /</a> </p><br><p>  -p 5000: 80 connects port 5000 of the container with port 80 of the host. </p><br><p>  In addition, there are such commands: </p><br><pre> <code class="python hljs">docker ps ‚Äìa</code> </pre> <br><p>  Show you a list of containers.  Since the -a option has been added, all containers will be displayed, not just those that are currently running. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  This command will remove the container named container_name.  rm - short for remove </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Display container logs </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  Delete image named image_name </p><br><h2>  Running a container through a reverse proxy server </h2><br><p>  The fact is that the .NET Core applications themselves use their Kestrel web server.  This server is not recommended for production.  Why?  There are several explanations. <br>  If there are several applications that share the IP and the port, then Kestrel will not be able to distribute traffic.  In addition, the reverse proxy server provides an extra layer of security, simplifies load balancing and SSL configuration, and also integrates better into existing infrastructure.  For most developers, the most important reason for the need for reverse proxy is additional security. </p><br><p>  To begin, restore the initial Dockerfile configuration.  And then we will deal with the docker-compose.yml file and try to run our service alone.  The format of the yml file is read like ‚Äújumble‚Äù and is an abbreviation either from ‚ÄúYet Another Markup Language‚Äù, or from ‚ÄúYAML Ain't Markup Language‚Äù.  Either another markup language, or not a markup language at all.  Somehow all is not certain. </p><br><p>  My default docker-compose file looks like this: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  The docker-compose.override.yml file adds several settings to the configuration: <br>  version: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  We can build the created solution using the docker-compose build, by invoking the docker-compose up command we will launch our container.  Everything is working?  Then go to the next step.  We create the nginx.info file.  The configuration will be approximately as follows: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Here we specify that nginx will listen on port 80 (listen 80;).  And the received requests will be redirected to the 80th port of the host in the container dockerservicedemo.  In addition, we indicate to nginx what headers need to be passed on. </p><br><p>  We can use http in nginx, and access the website via https.  When an https request goes through an http proxy, then a lot of information from https is not transmitted to http.  In addition, when using a proxy, the external IP address is lost.  To transfer this information in the headers, you need to change the code of our ASP.NET project and add the following code to the beginning of the Configure method of the Startup.cs file: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  Most proxy servers use X-Forwarded-For and X-Forwarded-Proto headers.  It is these headers that are specified now in the nginx configuration. </p><br><p>  Now we include the nginx image and the nginx.conf file in the doker-compose configuration.  Caution in YAML spaces matter: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Here we add to our proxy configuration in the form of a nginx image.  To this image we ‚Äúcling‚Äù to the external settings file.  We somehow mount it to the file system of the container using a mechanism called volume.  If you add to the end: ro then the object will be mounted only for reading. </p><br><p>  The proxy listens to the external 80th port of the machine on which the container is running and sends a request to the internal 80th port of the container. </p><br><p>  Having executed the doker-compose up command, we launch it, that is, extract the nginx image from the repository and launch our container together with the proxy container.  Now at <a href="http://localhost/">http: // localhost: 80 /</a> it will be accessible through nginx.  At the 5000th port, the application is ‚Äúspinning‚Äù under Kestrel. </p><br><p>  We can verify that the request to the web application passes through the reverse proxy.  Open in Chrome developer tools browser and go to the Network tab.  Here click on localhost and select the Headers tab. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  We start the container through a proxy and HTTPS </h2><br><p>  The ASP.NET Core 2.1 version brought with it improvements in HTTPS support. <br>  Let's say the following middleware allows you to redirect from an unprotected connection to a secure: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  And the next one allows you to use HTTP Strict Transport Security Protocol - HSTS. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS is a feature from the HTTP / 2 protocol, the specification of which was released in 2015.  This functionality is supported by modern browsers and informs that the website uses only https.  Thus, a protection against downgrade attacks occurs, during which the attacker can take advantage of the situation by switching to the unprotected http protocol.  For example, lower the version of TLS or even replace the certificate. </p><br><p>  As a rule, this type of attack is used in conjunction with man-in-the-middle attacks.  It should be known and remembered that HSTS does not save from the situation when the user enters the site using the http protocol and then redirects to https.  There is a so-called <a href="https://hstspreload.org/">Chrome preload list</a> , which contains links to websites that support https.  Other browsers (Firefox, Opera, Safari, Edge) also support https lists of sites created based on the Chrome list.  But in all these lists far from all sites are contained. </p><br><p>  When you first run a Core application on Windows, you will receive a message that a developer certificate has been created and installed.  Clicking the button and installing the certificate will thus make it trusted.  From the command line on macOS you can add trust to the certificate using the command: <br>  dotnet dev-certs https ‚Äìtrust </p><br><p>  If the dev-certs utility is not installed, you can install it with the command: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  How to add a certificate to trusted on Linux depends on the distribution. <br>  For test purposes, we use the certificate of the developer.  Actions with a certificate signed by a CA are similar.  If you wish, you can use free <a href="https://letsencrypt.org/">LetsEncrypt</a> certificates <a href="https://letsencrypt.org/">.</a> </p><br><p>  You can export the developer certificate to a file using the command </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  The file must be copied to the% APPDATA% / ASP.NET / Https / directory under Windows or into /root/.aspnet/https/ under macOS / Linux. </p><br><p>  In order for the container to pick up the path to the certificate and its password, you need to create User secrets with the following contents: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  This file stores unencrypted data and is therefore only used during development.  The file is created in Visual Studio by calling the context menu on the project icon or using the user-secrets utility on Linux. </p><br><p>  On Windows, the file will be saved in the% APPDATA% \ Microsoft \ UserSecrets \ &lt;user_secrets_id&gt; \ secrets.json directory, and on macOS and Linux it will be saved in ~ / .microsoft / usersecrets / &lt;user_secrets_id&gt; /secrets.json </p><br><p>  To save the settings for production, some Linux distributions may use <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/using_systemd_with_containers">systemd. The</a> settings are saved under the Service attribute.  For example: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  Next, I will give and sort out immediately the working version of the configuration of the docker for the proxy and the container via https. </p><br><p>  Docker-compose file: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Now I will describe incomprehensible moments.  ASPNETCORE_URLS allows us not to indicate in the application code using app.UseUrl the port listened by the application. </p><br><p>  ASPNETCORE_HTTPS_PORT makes a redirect similar to what the following code would do: <br>  services.AddHttpsRedirection (options =&gt; options.HttpsPort = 44392) </p><br><p>  That is, traffic from http requests will be redirected to a specific port https requests. <br>  With the help of ports it is indicated that the request from the external 59404th port will be redirected to the 80th container, and from the 44392th external port to the 44392nd.  Theoretically, once we have a reverse proxy server configured, we can remove ports with these redirections. <br>  Using volumes, you can mount the directory with the pfx certificate and the UserSecrets application with password and a link to the certificate. </p><br><p>  The proxy section indicates that requests from the 5001th external port will be redirected to the 44392nd nginx port.  In addition, the file with the nginx configuration is mounted, as well as the certificate and key to the certificate. </p><br><p>  In order for their single pfx format certificate (which we already have) to create crt and rsa files, you can use OpenSSL.  First you need to extract the certificate: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  And then the private key: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  The nginx configuration is as follows: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  The proxy server listens on port 44392.  This port receives requests from the 5001st port of the host.  Next, the proxy forwards requests to port 44392 of the dockerdemoservice container. </p><br><p>  Having dealt with these examples, you will get a good background for working with docker, microservices and nginx. </p><br><p>  We remind you that this is the full version of an <a href="https://xakep.ru/2018/08/20/aspnet-docker-nginx/">article from Hacker magazine</a> .  Its author is <a href="https://habrahabr.ru/users/asommer/">Alexey Sommer</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435914/">https://habr.com/ru/post/435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435904/index.html">AI translated brain activity to speech</a></li>
<li><a href="../435906/index.html">Pacemaker + DRBD (Dual primary) + ctdb cluster storage</a></li>
<li><a href="../435908/index.html">Ascetic web: prototype flea market on go and js</a></li>
<li><a href="../435910/index.html">Why did BSD lose in the battle with GNU / Linux?</a></li>
<li><a href="../435912/index.html">The main problems of the development of modern interfaces</a></li>
<li><a href="../435916/index.html">Hacking VC, two-factor authentication will not save</a></li>
<li><a href="../435920/index.html">Developer Cookbook: DDD Recipes (Part 4, Structures)</a></li>
<li><a href="../435922/index.html">Java, Spring, Kurento and media services. Part 2</a></li>
<li><a href="../435924/index.html">The neural network generates images of dishes according to their recipes.</a></li>
<li><a href="../435926/index.html">The neural network brings together pieces of archaeological finds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>