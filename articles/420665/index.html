<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating an application on .NET Core and Kubernetes: our experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Today we will tell about the experience of one of our DevOps projects. We decided to implement a new Linux application using .Net Core on th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating an application on .NET Core and Kubernetes: our experience</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Today we will tell about the experience of one of our DevOps projects.  We decided to implement a new Linux application using .Net Core on the microservice architecture. <br><br>  We expect that the project will be actively developed, and there will be more and more users.  Therefore, it should be easily scaled both in functionality and in performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We need a fault-tolerant system - if one of the blocks of functionality does not work, then the rest should work.  We also want to ensure continuous integration, including the deployment of the solution on the customer‚Äôs servers. <br><br>  Therefore, we used the following technologies: <br><br><ul><li>  .Net Core for the implementation of microservices.  In our project version 2.0 was used, </li><li>  Kubernetes for microservice orchestration, </li><li>  Docker for creating microservice images, </li><li>  Rabbit MQ and Mass Transit integration bus, </li><li>  Elasticsearch and Kibana for logging, </li><li>  TFS to implement the CI / CD pipeline. </li></ul><br>  In this article we will share the details of our decision. <br><br><img src="https://habrastorage.org/webt/bp/r9/oo/bpr9ootyfj2tqvrmfpp6uhdnjfu.jpeg"><br><br>  This is a transcript of our performance on .NET-mitap, here is a <a href="https://vk.com/eastbanctech%3Fw%3Dwall-157954708_487">link to the video of the</a> speech <br><a name="habracut"></a><br><h2>  Our business challenge </h2><br>  Our customer is a federal company, where there are merchandisers - these are people who are responsible for the way goods are presented in stores.  And then there are supervisors - these are the heads of merchandisers. <br><br>  The company has a process of learning and evaluating the work of merchandisers by supervisors, which needed to be automated. <br><br><img src="https://habrastorage.org/webt/of/w5/bh/ofw5bhdvkm9ml03ofsazm3e5mzg.png"><br><br>  Here is how our solution works: <br><br>  1. The supervisor prepares the questionnaire - this is a checklist of what needs to be checked in the work of the merchandiser. <br>  2. Next, the supervisor selects the employee whose work will be checked.  The date of the survey is assigned. <br>  3. Next, the activity is sent to the mobile device of the supervisor. <br>  4. Then the questionnaire is filled out and sent to the portal. <br>  5. The portal generates results and various reports. <br><br><h3>  Microservices will help us solve three problems: </h3><br>  1. In the future, we want to easily extend the functionality, since there are many similar business processes in the company. <br>  2. We want the solution to be fault tolerant.  If some part ceases to function, the solution will be able to restore its work on its own, and the failure of one part will not greatly affect the operation of the solution as a whole. <br>  3. The company for which we are implementing a solution has many branches.  Accordingly, the number of users of the solution is constantly growing.  Therefore, I wanted this to not affect performance. <br><br>  As a result, we decided to use microservices on this project, which required taking a number of non-trivial decisions. <br><br><h3>  What technologies helped to implement this solution: </h3><br>  ‚Ä¢ Docker makes it easy to distribute solution distribution.  In our case, the distribution kit is a set of microservice images. <br>  ‚Ä¢ Since there are a lot of microservices in our solution, we need to manage them.  For this we use Kubernetes. <br>  ‚Ä¢ We implement microservices ourselves using .Net Core. <br>  ‚Ä¢ To quickly update a solution with a customer, we must implement convenient continuous integration and delivery. <br><br>  Here is our set of technologies in general: <br><br>  ‚Ä¢ .Net Core we use to create microservices <br>  ‚Ä¢ Microservice is packaged in a Docker image, <br>  ‚Ä¢ Continuous integration and continuous delivery is implemented using TFS, <br>  ‚Ä¢ Front end part is implemented on Angular, <br>  ‚Ä¢ For monitoring and logging, we use Elasticsearch and Kibana, <br>  ‚Ä¢ RabbitMQ and MassTransit are used as an integration bus. <br><br><h3>  .NET Core for Linux solutions </h3><br>  We all know what the classic .Net Framework is.  The main disadvantage of the platform is that it is not cross-platform.  Accordingly, we cannot launch solutions on the .Net Framework platform under Linux in Docker. <br><br>  To enable Docker to use C #, Microsoft rethought the .Net Framework and created .Net Core.  And in order to use the same libraries, Microsoft created the .Net Standard Library specification.  .Net Standart Library assemblies can be used in the .Net Framework and .Net Core. <br><br><img src="https://habrastorage.org/webt/2z/qy/s9/2zqys9n9-watdykykh0uxpbhgl8.png"><br><br><h3>  Kubernetes - for microservice orchestration </h3><br>  Kubernetes is used to manage and cluster Docker containers.  Here are the main advantages of Kubernetes that we used: <br><br>  - provides the ability to easily configure the environment of microservices, <br>  - simplifies the management of the environment (Dev, QA, Stage), <br>  - out of the box provides the ability to replicate microservices and load balancing replicas. <br><br><img src="https://habrastorage.org/webt/jw/fu/11/jwfu11e5m-xv4rrqmy--goxcghs.png"><br><br><h2>  Solution Architecture </h2><br>  At the beginning of the work, we wondered how to divide the functionality into microservices.  The split was done on the principle of common responsibility, only at the level of more.  Its main task is to make changes in one service as little as possible affect other microservices.  As a result, in our case, microservices began to perform a separate functional area. <br><br>  As a result, we have services that are engaged in planning questionnaires, microservice for displaying results, microservice for working with a mobile application and other microservices. <br><br><img src="https://habrastorage.org/webt/f8/by/-6/f8by-6unz3mtb-f8edbczrmvhtg.png"><br><br><h3>  Options for interaction with external consumers </h3><br>  Microsoft in his book about microservices ‚Äú <a href="https://aka.ms/microservicesebook">.NET Microservices.</a>  <a href="https://aka.ms/microservicesebook">The architecture of .NET container applications</a> offers three possible implementations of interaction with microservices.  We reviewed all three and selected the most appropriate. <br><br>  ‚Ä¢ API Gateway service <br>  API Gateway service is a facade implementation for user requests to other services.  The problem of the solution is that if the facade does not work, then the whole solution will cease to function.  We decided to abandon this approach for the sake of resiliency. <br><br>  ‚Ä¢ API Gateway with Azure API Management <br>  Microsoft provides the ability to use the cloud facade in Azure.  But this solution did not come up, since we were going to deploy the solution not in the cloud, but on the customer‚Äôs servers. <br><br>  ‚Ä¢ Direct Client-To-Microservice communication <br>  As a result, we still have the last option - direct user interaction with microservices.  We chose it. <br><br><img src="https://habrastorage.org/webt/sc/uc/x6/scucx6-8y4bj629y967_urhsy2q.png"><br><br>  Its plus in fault tolerance.  The downsides are that some of the functionality will have to be reproduced on each service separately.  For example, it was necessary to configure authorization separately on each microservice to which users have access. <br><br>  Of course, the question arises how we will balance the load and how fault tolerance is implemented.  Everything is simple - this is what the Ingress Controller Kubernetes does. <br><br><img src="https://habrastorage.org/webt/87/3p/zq/873pzqb0ffu9ugon6pa5b8bx6ao.png"><br><br>  Node 1, node 2 and node 3 are replicas of one microservice.  If one of the replicas fails, the load balancer will automatically redirect the load to the other microservices. <br><br><h3>  Physical architecture </h3><br>  Here is how we organized the infrastructure of our solution: <br><br>  ‚Ä¢ Each microservice has its own database (if it is, of course, needed), other services do not apply to the database of another microservice. <br>  ‚Ä¢ Microservices communicate with each other only via RabbitMQ + Mass Transit bus, as well as using HTTP requests. <br>  ‚Ä¢ Each service has its own clearly defined responsibility. <br>  ‚Ä¢ For logging, we use Elasticsearch and Kibana and the Serilog library for working with it. <br><br><img src="https://habrastorage.org/webt/lu/8p/z3/lu8pz3zhxiggf1syj1btyqm9q54.png"><br><br>  The database service was deployed on a separate virtual machine, and not in Kubernetes, because Microsoft DBMS does not recommend using Docker on product environments. <br><br>  The logging service was also deployed on a separate virtual machine for reasons of fault tolerance - if we have problems with Kubernetes, then we can figure out what the problem is. <br><br><h2>  Deployment: how we organized the development and product environments </h2><br>  Our infrastructure has created 3 Neimespeys in Kubernetes.  All three environments refer to one database service and one logging service.  And, of course, each environment looks at its database. <br><br><img src="https://habrastorage.org/webt/rh/el/mz/rhelmza1dleycp5kdiylccr1aig.png"><br><br>  On the infrastructure of the customer, we also have two environments - this is pre-production and production.  In production, we have separate database servers for pre-production and product environments.  For logging, we have allocated one ELK server on our infrastructure and on the customer's infrastructure. <br><br><h3>  How to deploy 5 environments with 10 microservices in each? </h3><br>  On average, we have 10 services per project and three environments: QA, DEV, Stage, on which about 30 microservices are deployed.  And it is only on the development infrastructure!  Let's add 2 more environments on the customer's infrastructure, and we get 50 microservices. <br><br><img src="https://habrastorage.org/webt/sq/1m/kf/sq1mkfrwc4nfuu6whyq-cja9g-m.png"><br><br>  It is clear that such a number of services must somehow be managed.  Kubernetes helps us in this. <br><br>  In order to deploy microservice, you need <br>  ‚Ä¢ Expand secret, <br>  ‚Ä¢ Deploy deployement, <br>  ‚Ä¢ Expand service. <br><br>  We'll write about secret below. <br>  Deployment is the instruction for Kubernetes, on the basis of which it will launch the Docker container of our microservice.  Here is the deployment deployment team: <br><br> <code>kubectl apply -f .\(yaml  deployment-) --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  This file describes what is called deployment (imtob-etr-it-dictionary-api), which image it needs to use for execution, plus other settings.  In the secret section we will customize our environment. <br><br>  After deployment, we need to deploy a service, if necessary. <br><br>  Services are needed when access to microservice is required from outside.  For example, when it is necessary for a user or another microservice to be able to make a Get request to another microservice. <br><br> <code>kubectl apply -f .\imtob-etr-it-dictionary-api.yml --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: imtob-etr-it-dictionary-api-services spec: ports: - name: http port: 80 targetPort: 80 protocol: TCP selector: name: imtob-etr-it-dictionary-api</code> </pre> <br><br>  Usually the description of the service is small.  In it we see the name of the service, how it can be accessed and the port number. <br><br>  As a result, we need to deploy the environment. <br><br>  ‚Ä¢ a set of files with secret for all microservices, <br>  ‚Ä¢ a set of files with deployment of all microservices, <br>  ‚Ä¢ a set of files with the service of all microservices. <br><br>  All these scripts are stored in the git repository. <br><br>  To deploy the solution, we have a set of three types of scripts: <br><br>  ‚Ä¢ the secret folder is the configuration for each environment <br>  ‚Ä¢ folder with deployments for all microservices, <br>  ‚Ä¢ a folder with service for some microservices, <br><br>  in each - about ten teams, one for each microservice.  For convenience, we brought a page with scripts in Confluence, which helps us quickly deploy a new environment. <br><br>  Here is the deployment deployment script (there are similar sets for the secret and for service): <br><br><div class="spoiler">  <b class="spoiler_title">Deployment script deployment</b> <div class="spoiler_text">  kubectl apply -f. \ imtob-etr-it-image-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-mobile-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-planning-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-result-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-web.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-report-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-template-constructor-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-dictionary-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-integration-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-identity-api.yml --namespace = DEV <br></div></div><br><br><h3>  CI / CD implementation </h3><br><br>  Each service is in its own folder, plus we have one folder with shared components. <br><br><img src="https://habrastorage.org/webt/kj/xk/zf/kjxkzf7k-qzppe0ncduxvb_dzmc.jpeg"><br><br>  Also for each microservice there is Build Definition and Release Definition.  We set up the launch of Build Definion when committing to the appropriate service or commiting to the appropriate folder.  If the contents of the folder with shared components are updated, then all microservices are deployed. <br><br>  What are the advantages of such an organization Build-we see: <br><br>  1. The solution is in the same git repository, <br>  2. When changing in several microservices, the assembly is launched in parallel if there are free agents of the assembly, <br>  3. Each Build Definition represents a simple script from the image build and its push in the Nexus Registry. <br><br><h3>  Build definition and Release Definition </h3><br>  How to deploy a VSTS agent, we previously described <a href="https://habr.com/company/eastbanctech/blog/349510/">in this article</a> . <br><br><img src="https://habrastorage.org/webt/df/3i/k6/df3ik6q87wmw9qwjsjituwvmat8.png"><br><br>  First comes Build Definition.  At the command of TFS, the VSTS agent launches the Dockerfile build.  As a result, we get the image of microservice.  This image is saved locally on the environment where the VSTS agent is running. <br><br>  After the build, Push is launched, which sends the image we received in the previous step to the Nexus Registry.  Now it can be used from the outside.  Nexus Registry is a kind of Nuget, not only for libraries, but for Docker images and not only. <br><br>  After the image is ready and accessible from the outside, it needs to be deployed.  For this we have Release Definition.  Everything is simple here - we execute the set image command: <br><br> <code>kubectl set image deployment/imtob-etr-it-dictionary-api imtob-etr-it-dictionary-api=nexus3.company.ru:18085/etr-it-dictionary-api:$(Build.BuildId)</code> <br> <br>  After that, it will update the image for the desired microservice and launch a new container.  As a result, our service has been updated. <br><br>  Let's now compare the build with and without Dockerfile. <br><br><img src="https://habrastorage.org/webt/dn/wq/j6/dnwqj6og3rbyvdojybcrvs88yq0.png"><br><br>  Without Dockerfile, we have many steps, in which there is a lot of specificity of .Net.  On the right, we see a Docker image build.  Everything has become much easier. <br><br>  The entire image building process is described in the Dockerfile.  This assembly can be debugged locally. <br><br><img src="https://habrastorage.org/webt/hk/pd/g0/hkpdg0lafe00sbh1_afyquwwjsm.png"><br><br><h3>  Total: we got a simple and transparent CI / CD </h3><br><br>  1. Separation of development and deployment.  The assembly is described in the Dockerfile and lies on the shoulders of the developer. <br>  2. When configuring CI / CD, you do not need to know about the details and features of the assembly - work is carried out only with Dockerfile. <br>  3. We update only changed microservices. <br><br>  Further it is required to nastrit RabbitMQ in K8S: about it we wrote <a href="https://habr.com/company/eastbanctech/blog/419817/">separate article</a> . <br><br><h3>  Setting up the environment </h3><br>  Anyway, we need to configure microservices.  The main part of the environment is configured in the root configuration file Appsettings.json.  This file stores settings that are independent of the environment. <br><br>  Those settings that depend on the environment, we store in the secrets folder in the appsettings.secret.json file.  We took the approach described in the article <a href="https://anthonychu.ca/post/aspnet-core-appsettings-secrets-kubernetes/">Managing ASP.NET Core App Settings on Kubernetes</a> . <br><br><pre> <code class="plaintext hljs">var configuration = new ConfigurationBuilder() .AddJsonFile($"appsettings.json", true) .AddJsonFile("secrets/appsettings.secrets.json", optional: true) .Build();</code> </pre> <br><br>  The appsettings.secrets.json file stores settings for Elastic Search indexes and a database connection string. <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Serilog"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"WriteTo"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elasticsearch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nodeUris"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://192.168.150.114:9200"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"indexFormat"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary-{0:yyyy.MM.dd}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"templateName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"typeName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary.event"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DictionaryDbContext"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=192.168.154.162;Database=DEV.ETR.IT.iField.Dictionary;User Id=it_user;Password=PASSWORD;"</span></span> } }</code> </pre><br><br><h4>  Add a configuration file to Kubernetes </h4><br>  In order to add this file, you need to deploy it in the Docker-container.  This is done in the deployment file of a cubnet.  In deployment, it describes in which folder you need to create a file with secret and with which secret you need to associate the file. <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Create a secret in Kubernetes using the utility kubectl.  We see here the name of the secret and the path to the file.  We also indicate the name of the environment for which we are creating a secret. <br><br> <code>kubectl create secret generic secret-appsettings-dictionary <br> --from-file=./Dictionary/appsettings.secrets.json --namespace=DEMO</code> <br> <br><h2>  findings </h2><br><h3>  Cons of the chosen approach </h3><br>  1. High entry threshold.  If you are doing a similar project for the first time, there will be a lot of new information. <br>  2. Microservices ‚Üí more complex design.  It is necessary to apply a lot of non-obvious solutions due to the fact that we have not a monolithic solution, but a microservice one. <br>  3. Not everything is implemented for Docker.  Not everything can be run in microservice architecture.  For example, while SSRS is not in docker. <br><br><h3>  Pros of the approach, proven on yourself </h3><br>  1. Infrastructure as a code <br>  The infrastructure description is stored in the source control.  At the time of deployment does not need to adapt the environment. <br>  2. Scaling both at the functional level and at the level of performance out of the box. <br>  3. Microservices are well isolated <br>  Virtually no critical parts, the failure of which leads to the inoperability of the system as a whole. <br>  4. Fast delivery of changes <br>  Only those microservices are updated in which there were changes.  If we do not take into account the time for coordination and other things related to the human factor, then we update one microservice in 2 minutes or less. <br><br><h3>  Conclusions for us </h3><br>  1. On .NET Core it is possible and necessary to implement industrial solutions. <br>  2. K8S really made life easier, simplified updating of environments, and facilitated the configuration of services. <br>  3. TFS can be used to implement CI / CD for Linux. </div><p>Source: <a href="https://habr.com/ru/post/420665/">https://habr.com/ru/post/420665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420655/index.html">Robots rent apartments through Airbnbs to learn to better grab items</a></li>
<li><a href="../420657/index.html">Analysis: on whose money Ilon Mask will be able to withdraw Tesla from the stock exchange</a></li>
<li><a href="../420659/index.html">HRF (Human Rights Foundation) USB Campaign ‚ÄúFlash Drives for Freedom‚Äù</a></li>
<li><a href="../420661/index.html">Continuous Cloud Infrastructure</a></li>
<li><a href="../420663/index.html">Simple metrics and a way to save time when searching for problems in the infrastructure</a></li>
<li><a href="../420667/index.html">How does the EIGRP protocol work?</a></li>
<li><a href="../420669/index.html">Overview of the enterprise automation market: solutions for construction and management companies in the housing and utilities sector</a></li>
<li><a href="../420671/index.html">[Yekaterinburg, Announcement] UralJS # 9 - three reports on microservices, testing and logging errors on the front</a></li>
<li><a href="../420673/index.html">Docker for symfony 4 - from lokalki to production</a></li>
<li><a href="../420675/index.html">SOC is people. ‚ÄúHello, we are looking for talents‚Äù or where do analysts from the center for monitoring and responding to cyber attacks come from</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>