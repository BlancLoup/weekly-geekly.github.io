<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three JavaScript performance principles that make Bluebird fast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The company Reaktor shared in its blog the principles and examples of optimizing JavaScript-code, applied in the library of Bluebird promises, created...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three JavaScript performance principles that make Bluebird fast</h1><div class="post__text post__text-html js-mediator-article"><p>  The company Reaktor shared in its blog the principles and examples of optimizing JavaScript-code, applied in the library of Bluebird promises, created by their employee Petka Antonov (Petka Antonov). </p><a name="habracut"></a><br><p>  <a href="http://bluebirdjs.com/">Bluebird</a> is the popular JavaScript library of promises.  It was first noticed in 2013, when it turned out that it can surpass other implementations of promises with similar sets of properties up to 100 times.  Bluebird is so fast thanks to the consistent application of some basic optimization principles in JavaScript.  This article details the 3 most important principles used to optimize Bluebird. </p><br><h2>  1. Minimize feature creation </h2><br><p>  Creating objects and, in particular, creating function objects ( <em>translator's note:</em> <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions">any function is an object</a> ) can be very costly in terms of performance, since it requires the use of a large amount of internal data.  Practical implementations of JavaScript contain garbage collectors, which means that the created objects are not just sitting in memory - the garbage collector constantly searches for unused objects in order to free the memory they occupy.  The more memory you use in javascript, the more cpu the garbage collection takes and less is left to run the code itself.  In JavaScript, functions are <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25B0">first class objects</a> .  This means that they have the same features and properties as any other objects.  If you have a function that contains a declaration of another function (or functions), then each time you call the original function, new unique functions will be created that do the same thing.  Consider a simple example: </p><br><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trimStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.replace(/^\s+/g, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trimEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.replace(/\s+$/g, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trimEnd(trimStart(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) }</code> </pre> <br><p>  Whenever <code>trim</code> is called, two function objects are created, representing <code>trimStart</code> and <code>trimEnd</code> .  But they are not needed, since neither the unique behavior of objects, such as assigning properties, or closure over variables, is used in them.  The only reason they are used is for the functionality of the code they contain. </p><br><p>  This example is easy to optimize - you just need to remove functions from <code>trim</code> .  Since the example is contained in the module, and the module is loaded in the program once, there is only one representation for the functions: </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trimStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.replace(/^\s+/g, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trimEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.replace(/\s+$/g, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trimEnd(trimStart(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) }</code> </pre> <br><p>  However, most often the functions look like a necessary evil, from which you just can not get rid of.  For example, almost every time you pass a callback function for a deferred call, the callback needs a unique context to work.  As a rule, the context is implemented in a simple and intuitive, but inefficient manner - through the use of closures.  A simple example is reading a file from JSON to a node using a standard asynchronous callback interface. </p><br><pre> <code class="hljs lua">var fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFileAsJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, callback)</span></span></span></span> { fs.readFile(fileName, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error, result)</span></span></span></span> { //        readFileAsJson. //   ,    Context //   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>); } //  try-catch    //    -  JSON try { var json = JSON.parse(result); callback(null, json); } catch (e) { callback(e); } }) }</code> </pre> <br><p>  In this example, the callback passed to <code>fs.readFile</code> cannot be removed from <code>readFileAsJson</code> , because it creates a closure around a unique <code>callback</code> variable.  It should be noted that an attempt to render an anonymous callback to a named function does not lead to anything. </p><br><p>  Optimization constantly used inside Bluebird ‚Äî using an explicit simple object to hold context data.  In order to pass the callback through multiple levels, you only need to allocate memory for one such object.  Instead of creating a new closure at each level, when the callback is passed to the next level, we will pass an explicit simple object with an additional argument.  For example, if there are 5 levels in the original function, it means that using closures, 5 functions and Context-objects will be created along with them.  In the case of this optimization, only one object will be created for this purpose. </p><br><p>  If you could change <code>fs.readFile</code> to pass a context object there, you could apply the optimization like this: </p><br><pre> <code class="hljs coffeescript">var fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs-modified'</span></span>); function internalReadFileCallback(error, result) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  readFile  callback    , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   `<span class="javascript"><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span>`, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(error); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -  JSON <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { var json = JSON.parse(result); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, json); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(e); } } function readFileAsJson(fileName, callback) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  fs.readFile     . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,    callback, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          fs.readFile(fileName, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, internalReadFileCallback, callback); }</code> </pre> <br><p>  Of course, you need to control both parts of the API ‚Äî without the support of the context parameter, such optimization is not applicable.  However, where it is used (for example, when you control multiple internal levels), the performance benefit is significant.  A little-known fact: some of the built-in JavaScript Array APIs, such as <code>Array.prototype.forEach</code> , accept a context object as a second parameter. </p><br><h2>  2. Minimize object size. </h2><br><p>  It is critical to minimize the size of frequently created objects and objects created in large quantities, such as promises.  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C)">The heap</a> in which objects are created in most JavaScript implementations is divided into occupied and free sites.  Objects of smaller sizes fill the free space longer than large ones, as a result, leaving the garbage collector less work.  Also, small objects usually contain fewer fields, so it is easier for the garbage collector to bypass them, marking live and dead objects. </p><br><p>  Boolean and / or limited numeric fields are compressed much more by <a href="https://learn.javascript.ru/bitwise-operators">bitwise operations</a> .  Bitwise JavaScript operations work with 32-bit numbers.  In one field, you can place 32 boolean fields, or 8 4-bit numbers, or 16 boolean and 2 8-bit numbers, etc. For the code to remain readable, each logical field must have a <a href="https://learn.javascript.ru/getters-setters">getter and a setter</a> that performs the necessary bitwise operations on physical meaning.  Here is an example of how to compress one Boolean field into a number (which can later be extended to other logical fields): </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">//  1 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">   , </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"></span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">READONLY</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">constructor</span></span></span></span><span class="xml"><span class="hljs-tag">() { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">isReadOnly</span></span></span></span><span class="xml"><span class="hljs-tag">() { //  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">READONLY</span></span></span></span><span class="xml"><span class="hljs-tag">) !== </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">setReadOnly</span></span></span></span><span class="xml"><span class="hljs-tag">() { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">READONLY</span></span></span></span><span class="xml"><span class="hljs-tag">; } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">unsetReadOnly</span></span></span></span><span class="xml"><span class="hljs-tag">() { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this._bitField</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp; (~</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">READONLY</span></span></span></span><span class="xml"><span class="hljs-tag">); } }</span></span></span></span></code> </pre> <br><p>  Access methods are so short that, most likely, they will be built into runtime without additional function calls. </p><br><p>  <em>Translator's note:</em> Basic information about the work of the JavaScript compiler, the concept of inline caching and embedding functions - in the article The <a href="https://habrahabr.ru/post/182802/">Past and Future of Compiling JavaScript</a> .  On the work of the optimizer - <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers">Optimization killers</a> (from time to time the original is updated) Petki Antonova and the translation of the <a href="http://frontender.info/optimization-killers/">Killer Optimization</a> (published in 2014). </p><br><p>  Two or more fields that are not used at the same time can be compressed into one field using a flag that tracks the type of value placed in the field.  However, this method will only save space when the flag is implemented as a compressed number, as shown above. </p><br><p>  In Bluebird, this trick is used to preserve the value of the promise performed or the cause of the failure.  There is no separate field for this: if the promise is done, the result of the execution is stored in the field for the failure callback, if the promise is rejected, then the cause of the failure can be stored in the callback field of successful execution.  Again, accessing values ‚Äã‚Äãshould be done through access functions that hide implementation details. </p><br><p>  If an object needs to store a list of entities, you can avoid creating a separate array by storing the values ‚Äã‚Äãdirectly into the indexed properties of the object.  Instead of writing: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = []; } addListener(fn) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.push(fn); } }</code> </pre> <br><p>  You can avoid the array: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length = <span class="hljs-number"><span class="hljs-number">0</span></span>; } addListener(fn) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[index] = fn; } }</code> </pre> <br><p>  If the <code>.length</code> field can be limited to a small number (for example, 10-bit, that is, the <code>event emitter</code> can have a maximum of 1024 listeners), it can be made part of a bitwise field containing other limited numbers and Boolean values. </p><br><h2>  3. Use <a href="https://ru.wikipedia.org/wiki/NOP">no-op</a> functions.  Overwrite them lazily for costly optional features </h2><br><p>  Bluebird contains several optional functions that cause a uniform loss of performance of the entire library when used.  These are versions, stack traces, cancellation, Promise.prototype.bind, monitoring of states of promises, etc.  These functions require interceptor calls throughout the library.  For example, the function of monitoring promises requires an interceptor to be called each time a promise is created. </p><br><p>  It is much easier to check before the call whether the monitoring function is enabled than to run it every time, regardless of the actual state.  However, thanks to the inline caches ( <em>translator's note:</em> <a href="https://gist.github.com/twokul/9501770">here is another note</a> on the topic) and the embedding of functions, this operation can be completely simplified for users who have monitoring disabled.  To do this, assign the empty function to the original interceptor method: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Promise</span></span></span><span class="hljs-class"> { // ... constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">executor</span></span></span><span class="hljs-class">) { // ... this._promiseCreatedHook(); } //   no-op . _promiseCreatedHook() {} }</span></span></code> </pre> <br><p>  Now, if the user has not turned on the monitoring function, the optimizer sees that the interceptor does nothing and simplifies it.  It turns out that the interceptor method in the constructor simply does not exist. </p><br><p>  In order for the monitoring function to work, its inclusion must overwrite all the related no-op functions to their actual implementation: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableMonitoringFeature</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.prototype._promiseCreatedHook = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }; // ... }</span></span></code> </pre> <br><p>  Such a rewrite of the method invalidates the inline caches created for objects of the Promise class.  This should be done when the application starts, before any promises are created.  Thus, inline caches made after this will not know that no-op functions existed. </p><br><hr><br><p>  <em>Original: <a href="https://reaktor.com/blog/javascript-performance-fundamentals-make-bluebird-fast/">Three JavaScript performance fundamentals that make Bluebird fast</a> , by Petka Antonov.</em> </p><br><p>  <em>Translation: <a href="https://habrahabr.ru/users/aalexeev/" class="user_link">aalexeev</a> , edited: <a href="https://habrahabr.ru/users/jabher/" class="user_link">jabher</a> .</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/309848/">https://habr.com/ru/post/309848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309836/index.html">Setting and using speed limit for Open vSwitch with DPDK</a></li>
<li><a href="../309840/index.html">Android Dev: continued podcasts about professional development for Android</a></li>
<li><a href="../309842/index.html">Exit "in the field": How we made a mobile application to increase the efficiency of field workers</a></li>
<li><a href="../309844/index.html">How to render the frame of the new Doom</a></li>
<li><a href="../309846/index.html">Using blocks in iOS. Part 2</a></li>
<li><a href="../309850/index.html">1C, .Net Core. Dynamic compilation of a wrapper class for receiving events of a .Net object in 1C</a></li>
<li><a href="../309852/index.html">DevFest season 2016 in 10 cities of Russia</a></li>
<li><a href="../309854/index.html">Five kinds of game crafting systems</a></li>
<li><a href="../309856/index.html">We are recruiting a technical support team: instructions for use</a></li>
<li><a href="../309858/index.html">PHP 7.1: Overview of New Features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>