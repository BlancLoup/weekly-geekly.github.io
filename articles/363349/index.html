<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with ESP8266: Compiling the compiler and writing the first firmware</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we looked at the initial setup and operation of the ESP-01 module with the base AT firmware. The capabilities of this firmware ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with ESP8266: Compiling the compiler and writing the first firmware</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://geektimes.ru/post/241054/">last article,</a> we looked at the initial setup and operation of the ESP-01 module with the base AT firmware.  The capabilities of this firmware are quite limited and it is quite difficult to use it for some everyday tasks.  As I wrote in the first article, for ESP8266 you can write your own firmware with the necessary functionality and thus make the ESP-01 board a self-sufficient device.  Anyone who cares, I ask under habrakat. <br><a name="habracut"></a><br>  As you know, the SoC ESP8266 is built on the basis of the Tensilica Xtensa LX106 processor, if anyone is interested, then there is <a href="http://www.kit-e.ru/articles/elcomp/2009_10_66.php">an article</a> in the network <a href="http://www.kit-e.ru/articles/elcomp/2009_10_66.php">about configurable processors from this company</a> .  Espressif company provides full documentation, as well as a compiler and development environment for SoC ESP8266 only after signing a partnership agreement and not with everyone, they didn‚Äôt respond to my letter.  With a little googling you can find the official compiler leaked to the network, a development environment based on Eclipse, a lot of documentation and licenses, but this is not our way.  We will use an unofficial compiler based on <a href="https://github.com/jcmvbkbc/crosstool-NG">Crosstool-NG</a> <br><br>  In this article I will explain how to build a compiler for Ubuntu Linux, as well as we will try to write the simplest firmware.  I will focus on working with the Windows compiler, as well as setting up the Eclipse environment for writing firmware for ESP8266. <br><br>  <b>Part 1: Build a compiler for Ubuntu Linux, configure the SDK, build standard examples and firmware.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u>Install the build environment</u> <br><br>  For 32-bit Debian (Linux) we execute: <br><pre><code class="bash hljs">apt-get install git autoconf build-essential gperf bison flex texinfo libtool libncurses5-dev wget gawk libc6-dev-amd64 python-serial libexpat-dev</code> </pre>  For 64-bit Debian (Linux) we execute: <br><pre> <code class="bash hljs">apt-get install git autoconf build-essential gperf bison flex texinfo libtool libncurses5-dev wget gawk libc6-dev-i386 python-serial libexpat-dev</code> </pre>  Further: <br>  USER change to the current user login. <br><pre> <code class="bash hljs">sudo mkdir /opt/Espressif sudo chown USER:root /opt/Espressif <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> -b lx106 git://github.com/jcmvbkbc/crosstool-NG.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> crosstool-NG ./bootstrap &amp;&amp; ./configure --prefix=`<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>` &amp;&amp; make &amp;&amp; make install ./ct-ng xtensa-lx106-elf ./ct-ng build PATH=<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>/builds/xtensa-lx106-elf/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span></code> </pre> <br>  After that, you can sit back in the chair for 40-50 minutes and drink coffee.  If everything is completed without errors, then we can move on. <br><br>  <u>Install SDK</u> <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif mkdir ESP8266_SDK <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ESP8266_SDK wget http://bbs.espressif.com/download/file.php?id=72 -O esp_iot_sdk_v0.9.3_14_11_21.zip wget http://bbs.espressif.com/download/file.php?id=73 -O esp_iot_sdk_v0.9.3_14_11_21_patch1.zip unzip esp_iot_sdk_v0.9.3_14_11_21.zip &amp;&amp; rm esp_iot_sdk_v0.9.3_14_11_21.zip rm esp_iot_sdk_v0.9.3/lib/libpp.a unzip esp_iot_sdk_v0.9.3_14_11_21_patch1.zip &amp;&amp; rm esp_iot_sdk_v0.9.3_14_11_21.zip mv esp_iot_sdk_v0.9.3/* . &amp;&amp; rm -r esp_iot_sdk_v0.9.3/</code> </pre> <br>  <u>Add libc libraries, libhal and header files to the SDK</u> <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif/ESP8266_SDK wget -O lib/libc.a https://github.com/esp8266/esp8266-wiki/raw/master/libs/libc.a wget -O lib/libhal.a https://github.com/esp8266/esp8266-wiki/raw/master/libs/libhal.a wget -O include.tgz https://github.com/esp8266/esp8266-wiki/raw/master/include.tgz tar -xvzf include.tgz &amp;&amp; rm include.tgz</code> </pre> <br>  <u>Installing the ESP image tool</u> <br><br>  The ESP tool can be compiled from sources, <br>  for Linux can be downloaded <a href="">here</a> <br>  for debian / ubuntu <a href="">here</a> <br>  Ready package for Ubuntu download <a href="">from here</a> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif/ wget https://github.com/esp8266/esp8266-wiki/raw/master/deb/esptool_0.0.2-1_i386.deb sudo dpkg -i esptool_0.0.2-1_i386.deb &amp;&amp; rm esptool_0.0.2-1_i386.deb</code> </pre> <br>  <u>Install ESP upload tool</u> <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/themadinventor/esptool esptool-py sudo ln -s <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>/esptool-py/esptool.py crosstool-NG/builds/xtensa-lx106-elf/bin/ sudo ln -s <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>/esptool-py/esptool.py /usr/sbin/</code> </pre> <br>  <u>Build examples of firmware</u> <br><br>  First, open the file /opt/Espressif/ESP8266_SDK/include/osapi.h and comment out the line #include "user_config.h" <br><br>  Download and compile the blinky and basic_example examples: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif/ESP8266_SDK/examples/ wget https://github.com/esp8266/<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>-code-examples/archive/master.zip &amp;&amp; unzip master.zip &amp;&amp; rm -r master.zip mv <span class="hljs-built_in"><span class="hljs-built_in">source</span></span>-code-examples-master/* . &amp;&amp; rm -r <span class="hljs-built_in"><span class="hljs-built_in">source</span></span>-code-examples-master <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> blinky make</code> </pre>  If all steps were done correctly, then the assembly will pass without errors and 2 firmware files 0x00000.bin and 0x40000.bin will appear in the firmware directory <br><br>  Download and collect an example of the basic AT firmware: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif/ESP8266_SDK/examples/ wget -O at_v0.19_14_10_30.zip http://bbs.espressif.com/download/file.php?id=13 unzip at_v0.19_14_10_30.zip &amp;&amp; rm at_v0.19_14_10_30.zip <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> at_v0.19_on_SDKv0.9.2/ rm Makefile &amp;&amp; cp ../example.Makefile . &amp;&amp; mv example.Makefile Makefile</code> </pre> <br>  To properly build the AT firmware, you need to edit the base Makefile in the line <br>  LIBS = c gcc hal pp phy net80211 lwip wpa main <br>  add the upgrade library link, the final line will look like this <br>  LIBS = c gcc hal pp phy net80211 lwip wpa upgrade main <br>  After that, the firmware can be assembled with the make command. <br><br>  We are compiling an example of IoT firmware: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt/Espressif/ESP8266_SDK/examples/IoT_Demo/ rm Makefile &amp;&amp; cp ../example.Makefile . &amp;&amp; mv example.Makefile Makefile</code> </pre> <br>  As well as for AT firmware, for correct assembly of IoT firmware, it is necessary to edit the base Makefile into a string <br>  MODULES = driver user <br>  you need to add additional modules, the final line will look like this <br>  MODULES = driver user json ssl upgrade lwip <br>  and in line <br>  LIBS = c gcc hal pp phy net80211 lwip wpa main <br>  add json library link, the final line will look like this <br>  LIBS = c gcc hal pp phy net80211 lwip wpa main json <br>  After that, the firmware can be assembled with the make command. <br><br>  To flash the ESP-01 board, use the make flash command. <br>  Do not forget that to switch to the firmware update mode, you need to apply a low level to GPIO0 and a high level to CH_PD. <br>  To understand what makes flash do, open any Makefile and find the flash line: <br>  after the substitution of all arguments, we get the SoC firmware command: <br><pre> <code class="bash hljs">esptool.py --port /dev/ttyUSB0 write_flash 0x00000 firmware/0x00000.bin 0x40000 firmware/0x40000.bin</code> </pre> <br>  The format of the firmware file, in fact, and how the exchange protocol can be read <a href="http://esp8266.ru/esp8266-image-firmware-protocol/">here in Russian</a> or <a href="https://github.com/themadinventor/esptool">here in English</a> . <br>  That's where the compiler build and SDK for Linux are finished. <br><br><a name="Espressif-ESP8266-DevKit"></a>  <b>Part 2: Installing the compiler for Windows, setting up the SDK, building standard examples and firmware.</b> <br><br>  Since  My main OS under which I work 90% of the time is Windows, then I was not interested in Linux development. <br>  Below I will explain how to install and configure the compiler and SDK in Windows, as well as how to set up an Eclipse development environment for comfortable development of firmware in it. <br>  I will not consider the process of building a compiler for Windows, because  This is a rather complicated procedure, it is much more complicated than a build in Linux. <br>  In order to save you from all the subtleties and nuances, I prepared the Espressif DevKit work package, which includes the compiler, the latest SDK version, standard firmware examples, as well as my own firmware samples. <br><br>  So let's start: <br>  1. <a href="http://dl.programs74.ru/get.php%3Ffile%3DEspressifESP8266DevKit">Download</a> (148Mb) and install my Espressif-ESP8266-DevKit-v2.2.1-x86.exe kit (as of November 15, 2016) <br>  2. <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Download</a> and install Java Runtime x86 or x64 (For example: jre-8u111-windows-x64.exe for Windows x64) <br>  3. Download and install <a href="https://www.eclipse.org/downloads/download.php%3Ffile%3D/technology/epp/downloads/release/neon/R/eclipse-cpp-neon-R-win32.zip">Eclipse Neon x86</a> or <a href="https://www.eclipse.org/downloads/download.php%3Ffile%3D/technology/epp/downloads/release/neon/R/eclipse-cpp-neon-R-win32-x86_64.zip">Eclipse Neon x64</a> for C ++ development.  Unpack the archive in the root of drive C. <br>  4. <a href="http://sourceforge.net/projects/mingw/files/Installer/">Download</a> and install MinGW.  Run mingw-get-setup.exe, during the installation process, select the mode without GUI, that is, remove the check mark "... also install support for the graphical user interface". <br>  5. <a href="http://dl.programs74.ru/get.php%3Ffile%3DEspressifESP8266DevKitAddon">Download a</a> set of my scripts to automate the installation of additional modules for MinGW.  (current on 10/15/2016) <br>  6. Run install-mingw-package.bat from my set.  It will download the cached archives of packages for mingw from my site, approximately 90 Mb and install the basic modules for MinGW.  Downloading a pre-made set of package files for MinGW ensures that all of them are installed, sometimes the servers where the MinGW packages are located become inaccessible and the necessary packages are not installed and therefore the firmware build can take place with all sorts of tricks. <br>  7. Run Eclipse from the directory c: \ eclipse \ eclipse.exe <br>  8. In Eclipse, select File -&gt; Import -&gt; General -&gt; Existing Project into Workspace, in the Select root directory line, select the C: \ Espressif \ examples \ ESP8266 directory and import the working projects. <br>  Next to the right in Make Target, select the desired project, for example hello-world, and run the all target on the assembly, <br>  at the same time the assembly progress should be displayed in the Console window; if everything is done correctly, there will be something like this: <br><br><pre> <code class="bash hljs">17:00:00 **** Build of configuration Default <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> project hello-world **** mingw32-make.exe -f C:/Espressif/examples/ESP8266/hello-world/Makefile all CC driver/uart.c CC user/user_main.c AR build/app_app.a LD build/app.out FW firmware/0x00000.bin FW firmware/0x40000.bin 17:00:04 Build Finished (took 3s.740ms)</code> </pre> <br>  This means that the firmware for ESP8266 is compiled and located in the directory C: \ Espressif \ examples \ hello-world \ firmware <br>  To flash ESP8266, use the flash target, after having edited the Makefile project build file, line <br>  ESPPORT? = COM2 <br>  where after COM the number 2 indicates the number of the COM port to which the board with the ESP8266 is connected. <br><br><div class="spoiler">  <b class="spoiler_title">Video with a demonstration of connecting projects in Eclipse, assembly and firmware ESP8266.</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/eWGjADdjH98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><div class="spoiler">  <b class="spoiler_title">Video demonstrating the creation of a new project in Eclipse.</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/y9uk-3A1acM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br>  As mentioned above, to switch to the firmware update mode, you need to apply a low level to GPIO0 and a high level on CH_PD, after that either distort the board power or perform a Reset, feeding a low level to EXT_RSTB (also known as RESET).  Perform these actions constantly very uncomfortable.  A little thought, I changed the connection scheme of the ESP-01 board to the USB-to-RS232 converter, the meaning of the changes comes down to connecting the RTS output of the USB-to-RS232 converter to the EXT_RSTB output (also known as RESET) of the ESP-01 board and the DTR output of the USB-converter to-RS232 to output GPIO0 of the ESP-01 board. <br><br>  <b>ATTENTION!</b>  In my current build of the Unofficial Development Kit for Espressif ESP8266, the esptool utility already contains these improvements, so no additional patching is needed. <br><br><div class="spoiler">  <b class="spoiler_title">I also corrected the esptool.py utility in the connect procedure.</b> <div class="spoiler_text">  I also corrected the esptool.py utility in the connect procedure in order to reset the board by the RTS signal at startup and enter the bootloader mode by the DTR signal. <br><div class="spoiler">  <b class="spoiler_title">Changes to esptool.py</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> def <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(self): print <span class="hljs-string"><span class="hljs-string">'Entering bootloader...'</span></span> self._port.setRTS(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) #RTS self._port.setDTR(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) #GPIO0 <span class="hljs-type"><span class="hljs-type">time</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) self._port.setRTS(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) self._port.setDTR(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-type"><span class="hljs-type">time</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) self._port.setRTS(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) self._port.setDTR(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print <span class="hljs-string"><span class="hljs-string">'Connecting...'</span></span></code> </pre> </div></div><br>  With such light ears, I solved the problem of manually switching to the firmware update mode. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">The final wiring diagram:</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/geektimes/post_images/46a/553/bf4/46a553bf4f142256d81d55a9ae390998.png"></div></div><br><br>  Now, fulfilling the goal of flash in Eclipse, we are making a new firmware with one click of the mouse.  No need to poke on the breadboard and connect anything. <br><br>  But in connection with this tricks my ears had to look for the normal Terminal program, since  Putty no longer fit, it cannot control the RTS and DTR lines and moreover, immediately after connecting to the COM port via Putty, he set the DTR line to a low level, which led to a permanent entry into the bootloader mode.  The <a href="https://sites.google.com/site/terminalbpp/">Terminal</a> program, convenient and at the same time rich in functionaries, was easily found; it is located in the C: \ Espressif \ utils \ directory. <br><br>  <b>Part 3: Writing the simplest firmware.</b> <br><br>  In order to start writing firmware, you need to study the documentation for the ESP8266 chip itself and the SDK, I did not include the documentation in my Espressif-ESP8266-DevKit assembly, so as not to violate all sorts of licensing agreements, all the same, all the documentation comes with the label confidential.  However, there are plenty of sources on the Internet where you can get it, for example: <br>  <a href="http://esp8266.ru/download/esp8266-doc/ESP8266_Specifications_v4.1.pdf">ESP8266 chip specification</a> <br>  <a href="http://esp8266.ru/download/esp8266-doc/ESP8266_IoT_SDK_Programming%2520Guide_v0.9.1.pdf">Description The ESP8266 SDK</a> is the main document we need. <br><br>  In the <a href="http://geektimes.ru/post/241054/">last article,</a> using the example of AT firmware, we connected to a Wi-Fi access point and ran a TCP server (TCP client) on the ESP8266, and also sent test data to a PC.  As I wrote earlier, this method is not very convenient, because  To execute AT commands to start a TCP server (TCP client), a separate controller is required.  Below we consider an example of writing the simplest firmware for ESP8266, which implements all this without an external controller. <br>  So the task: <br>  1. The ESP-01 card should switch to the STA (Wi-Fi client) mode, establish a connection with our AP. <br>  2. After establishing the connection with the AP, you must establish a TCP connection with the PC and send a test string. <br>  3. We connect a button to GPIO0, when closing we send a text string. <br>  3. The procedure for sending is repeated every 5 seconds. <br><br>  Open the wifi-sta-tcp-client example from C: \ Espressif \ examples \ in Eclipse <br>  A typical folder structure in any project for ESP8266 is something like this: <br><pre> <code class="hljs ruby">wifi-sta-tcp-client <span class="hljs-params"><span class="hljs-params">|-Makefile |</span></span>-driver <span class="hljs-params"><span class="hljs-params">|-uart.c |</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-params"><span class="hljs-params">|-user |</span></span>-user_main.c <span class="hljs-params"><span class="hljs-params">|-user_config.h</span></span></code> </pre> <br>  where <br>  - The Makefile is a set of instructions for the make program that helps build our project. <br>  - driver directory - contains drivers for various devices, as long as we have only the uart.c file there, for working with the rs232 port of the ESP8266 chip, in principle there may be drivers for working with gpio, i2c, spi, pwm, etc., see the example IoT_Demo, there is more clearly what can be. <br>  - directory include - contains auxiliary header files, while there are only files to work with port rs232 <br>  - user directory - the main directory, it contains the main firmware files, the file user_main.c and user_config.h <br><br>  There may be other directories, it all depends on the model and principles of development, but the Makefile is configured exactly on such a structure, and if you start changing something, you will have to rewrite the instructions of the Makefile. <br>  In the current form in order to add extra.  the source directory in the assembly is enough in the Makefile in the string <br>  MODULES = driver user <br>  add our new directory, for example ssl and it will participate in the firmware build. <br>  To add extra.  libraries in the Makefile, you need to add a line <br>  LIBS = c gcc hal phy pp net80211 lwip wpa main <br>  we need libraries, for example, if we need a library for working with json in a project, then we write <br>  LIBS = c gcc hal phy pp net80211 lwip wpa main json <br><br>  Open the user \ user_main.c file <br><br>  The main procedure that is performed when starting the firmware is <br><pre> <code class="hljs lua">//Init <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ICACHE_FLASH_ATTR</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  We add header files to the beginning of the user \ user_main.c file: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ets_sys.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"osapi.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"os_type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"user_interface.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"driver/uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"espconn.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mem.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gpio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"user_config.h"</span></span></span></span></code> </pre><br>  These files, with the exception of user_config.h and driver / uart.h are located C: \ Espressif \ ESP8266_SDK \ include \ <br>  ets_sys.h - specific structures and definitions for working with events and timers <br>  osapi.h - timers and some system functions, such as os_strcat, os_memcpy, os_delay_us, etc. <br>  os_type.h - mapping structures from ets_sys.h <br>  user_interface.h - a lot of supporting structures and API procedures, in particular for working with wi-fi, system_restart, system_deep_sleep procedures, etc. <br>  espconn.h - main API file with structures and procedures for working with TCP and UDP connections <br>  mem.h - work with memory, os_malloc, os_free, etc. <br>  gpio.h - supporting structures and API procedures for working with GPIO <br><br><div class="spoiler">  <b class="spoiler_title">So we write in user_init () the following:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> //  uart0  uart1   <span class="hljs-number"><span class="hljs-number">115200</span></span> uart_init(BIT_RATE_115200, BIT_RATE_115200); //  <span class="hljs-number"><span class="hljs-number">100</span></span> . os_delay_us(<span class="hljs-number"><span class="hljs-number">100</span></span>); #ifdef PLATFORM_DEBUG //    uart   , .  PLATFORM_DEBUG  user_config.h uart0_sendStr("ESP8266 platform starting...\r\n"); #endif //      STA (   AP) struct station_config stationConfig; <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>[<span class="hljs-number"><span class="hljs-number">150</span></span>]; //         AP,       //   SDK  <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  wifi_set_opmode    system_restart <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_get_opmode() != STATION_MODE) { #ifdef PLATFORM_DEBUG uart0_sendStr("ESP8266 not in STATION mode, restarting in STATION mode...\r\n"); #endif wifi_set_opmode(STATION_MODE); } //     STA,   ,  AP, , . user_config.h //   MAC      AP, . wifi_get_macaddr(SOFTAP_IF, <span class="hljs-type"><span class="hljs-type">macaddr</span></span>); //   STA     MAC ,   ,                  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_get_opmode() == STATION_MODE) { wifi_station_get_config(&amp;stationConfig); os_memset(stationConfig.ssid, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(stationConfig.ssid)); os_memset(stationConfig.<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(stationConfig.<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>)); os_sprintf(stationConfig.ssid, "%s", WIFI_CLIENTSSID); os_sprintf(stationConfig.<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, "%s", WIFI_CLIENTPASSWORD); wifi_station_set_config(&amp;stationConfig); wifi_get_macaddr(SOFTAP_IF, <span class="hljs-type"><span class="hljs-type">macaddr</span></span>); } //     uart     STA #ifdef PLATFORM_DEBUG <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_get_opmode() == STATION_MODE) { wifi_station_get_config(&amp;stationConfig); os_sprintf(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>,"OPMODE: %u, SSID: %s, PASSWORD: %s\r\n", wifi_get_opmode(), stationConfig.ssid, stationConfig.<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>); uart0_sendStr(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>); } #endif //      Wi-Fi,     <span class="hljs-number"><span class="hljs-number">1</span></span> .,   ,   TCP-    . os_timer_disarm(&amp;WiFiLinker); os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); //  GPIO, BtnInit(); //      #ifdef PLATFORM_DEBUG uart0_sendStr("ESP8266 platform started!\r\n"); #endif</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIO Initialization Procedure</b> <div class="spoiler_text"><pre> <code class="hljs ruby">void BtnInit() { PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     - (pull down) PIN_PULLDWN_DIS(PERIPHS_IO_MUX_GPIO0_U); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     + (pull up) PIN_PULLUP_EN(PERIPHS_IO_MUX_GPIO0_U); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  GPIO<span class="hljs-number"><span class="hljs-number">0</span></span>   gpio_output_set(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BIT<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    GPIO os_timer_disarm(&amp;BtnTimer); os_timer_setfn(&amp;BtnTimer, BtnTimerCb, NULL); os_timer_arm(&amp;BtnTimer, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> </div></div><br>  The verification procedure is done in the forehead, without any elimination of contact bounce, according to the mind, you need to do it differently, it will also be seen below that in the senddata there is no check for raising the wi-fi interface, which should also be taken into account. <br><div class="spoiler">  <b class="spoiler_title">GPIO verification procedure</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ICACHE_FLASH_ATTR </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BtnTimerCb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GPIO_INPUT_GET(BTNGPIO)) { GPIO_Time_Active++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GPIO_Time_Active != <span class="hljs-number"><span class="hljs-number">0</span></span>) { #ifdef PLATFORM_DEBUG uart0_sendStr(<span class="hljs-string"><span class="hljs-string">"Start sending data...\r\n"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   senddata(); } GPIO_Time_Active = 0; } }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">The procedure for checking Wi-Fi connection (called on a timer)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> ICACHE_FLASH_ATTR wifi_check_ip(<span class="hljs-type"><span class="hljs-type">void</span></span> *arg) { //     , ip   STA,  , . struct ip_info ipConfig; //    wi-fi os_timer_disarm(&amp;WiFiLinker); //      wifi_get_ip_info(STATION_IF, &amp;ipConfig); //   wi-fi     ip  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wifi_station_get_connect_status() == STATION_GOT_IP &amp;&amp; ipConfig.ip.addr != <span class="hljs-number"><span class="hljs-number">0</span></span>) { //   wi-fi  connState = WIFI_CONNECTED; #ifdef PLATFORM_DEBUG uart0_sendStr("WiFi connected\r\n"); #endif #ifdef PLATFORM_DEBUG uart0_sendStr("Start TCP connecting...\r\n"); #endif connState = TCP_CONNECTING; //     senddata(); //           <span class="hljs-number"><span class="hljs-number">5</span></span> , . . os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_station_get_connect_status() == STATION_WRONG_PASSWORD) { connState = WIFI_CONNECTING_ERROR; #ifdef PLATFORM_DEBUG uart0_sendStr("WiFi connecting error, wrong password\r\n"); #endif os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } // AP   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_station_get_connect_status() == STATION_NO_AP_FOUND) { connState = WIFI_CONNECTING_ERROR; #ifdef PLATFORM_DEBUG uart0_sendStr("WiFi connecting error, ap not found\r\n"); #endif os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } //    AP <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wifi_station_get_connect_status() == STATION_CONNECT_FAIL) { connState = WIFI_CONNECTING_ERROR; #ifdef PLATFORM_DEBUG uart0_sendStr("WiFi connecting fail\r\n"); #endif os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } //   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { os_timer_setfn(&amp;WiFiLinker, (os_timer_func_t *)wifi_check_ip, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); os_timer_arm(&amp;WiFiLinker, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); connState = WIFI_CONNECTING; #ifdef PLATFORM_DEBUG uart0_sendStr("WiFi connecting...\r\n"); #endif } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">The procedure for sending data to a PC</b> <div class="spoiler_text"><pre> <code class="hljs erlang-repl">static void ICACHE_FLASH_ATTR senddata() { char info[<span class="hljs-number"><span class="hljs-number">150</span></span>]; char tcpserverip[<span class="hljs-number"><span class="hljs-number">15</span></span>]; struct espconn *pCon = (struct espconn *)os_zalloc(sizeof(struct espconn)); if (pCon == NULL) { #ifdef PLATFORM_DEBUG uart0_sendStr(<span class="hljs-string"><span class="hljs-string">"TCP connect failed\r\n"</span></span>); #endif return; } pCon-&gt;type = ESPCONN_TCP; pCon-&gt;state = ESPCONN_NONE; //   TCP-,     os_sprintf(tcpserverip, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, TCPSERVERIP); uint32_t ip = ipaddr_addr(tcpserverip); pCon-&gt;proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp)); pCon-&gt;proto.tcp-&gt;local_port = espconn_port(); //   TCP-,     pCon-&gt;proto.tcp-&gt;remote_port = TCPSERVERPORT; os_memcpy(pCon-&gt;proto.tcp-&gt;remote_ip, &amp;ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); //  callback ,     espconn_regist_connectcb(pCon, at_tcpclient_connect_cb); //   callback ,   ,       //espconn_regist_reconcb(pCon, at_tcpclient_recon_cb); //    #ifdef PLATFORM_DEBUG os_sprintf(info,<span class="hljs-string"><span class="hljs-string">"Start espconn_connect to "</span></span> IPSTR <span class="hljs-string"><span class="hljs-string">":%d\r\n"</span></span>, IP2STR(pCon-&gt;proto.tcp-&gt;remote_ip), pCon-&gt;proto.tcp-&gt;remote_port); uart0_sendStr(info); #endif //    TCP- espconn_connect(pCon); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">callback function called after establishing a connection</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ICACHE_FLASH_ATTR </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at_tcpclient_connect_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">espconn</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pespconn</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">espconn</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PLATFORM_DEBUG uart0_sendStr(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TCP client connect\r\n"</span></span></span><span class="hljs-meta">); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// callback ,     espconn_regist_sentcb(pespconn, at_tcpclient_sent_cb); // callback ,    espconn_regist_disconcb(pespconn, at_tcpclient_discon_cb); char payload[128]; //   ,   MAC  ESP8266   AP      ESP8266 os_sprintf(payload, MACSTR ",%s\r\n", MAC2STR(macaddr), "ESP8266"); #ifdef PLATFORM_DEBUG uart0_sendStr(payload); #endif //   espconn_sent(pespconn, payload, strlen(payload)); }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">callback functions called after sending data and after disconnecting</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ICACHE_FLASH_ATTR </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at_tcpclient_sent_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PLATFORM_DEBUG uart0_sendStr(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send callback\r\n"</span></span></span><span class="hljs-meta">); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ,   TCP- struct espconn *pespconn = (struct espconn *)arg; espconn_disconnect(pespconn); } static void ICACHE_FLASH_ATTR at_tcpclient_discon_cb(void *arg) { struct espconn *pespconn = (struct espconn *)arg; // ,   os_free(pespconn-&gt;proto.tcp); os_free(pespconn); #ifdef PLATFORM_DEBUG uart0_sendStr("Disconnect callback\r\n"); #endif }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">And in the conclusion of the video, with a demonstration of the operation of this firmware.</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/HqVKPganlOI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br>  As you have already noticed, the motherboard on the Espressif ESP8266 chip has quite an impressive potential for writing your own firmware. <br>  In the next article I will give an example of how the ESP8266 works in conjunction with the transmitter module of the <a href="http://www.noo.com.by/modul_mt1132.html">nooLite MT1132</a> and we will try to control the lighting in a real apartment.  Perhaps in the same article we will analyze the work of the simplest Web-server for ESP8266. <br><br>  PS If you have any questions and suggestions, then I will be glad to hear them, but due to low karma, I will not be able to respond promptly in the comments, so write to the PM or email. </div><p>Source: <a href="https://habr.com/ru/post/363349/">https://habr.com/ru/post/363349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../363339/index.html">State of system administrators, programmers and pirates</a></li>
<li><a href="../363341/index.html">Satellite - it's very simple - 2</a></li>
<li><a href="../363343/index.html">New clue to the mystery of the Cryptos</a></li>
<li><a href="../363345/index.html">Detective story "Cosmos-2499"</a></li>
<li><a href="../363347/index.html">Signing instead of a PIN in the TCS Bank is considered safer</a></li>
<li><a href="../363351/index.html">Go - unity in diversity</a></li>
<li><a href="../363353/index.html">Laptops on ISS</a></li>
<li><a href="../363355/index.html">Inventions - to inventors. Or why you don't need a huge printer.</a></li>
<li><a href="../363359/index.html">Lunar Mission One: flight to the moon at the expense of Kickstarter users</a></li>
<li><a href="../363361/index.html">If the touchpad (or joystick) already got</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>