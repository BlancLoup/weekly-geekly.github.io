<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming language J. Amateur look. Part 2. Tacit Programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Previous article in the Cycle Programming Language J. Amateur Look. Part 1. Introduction 

 Question: If functions change data, and operators change f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming language J. Amateur look. Part 2. Tacit Programming</h1><div class="post__text post__text-html js-mediator-article">  <i>Previous article in the Cycle <a href="http://habrahabr.ru/post/198052/">Programming Language J. Amateur Look.</a></i>  <i><a href="http://habrahabr.ru/post/198052/">Part 1. Introduction</a></i> <br><br><blockquote>  <em>Question: If functions change data, and operators change functions, then who changes the operators?</em> <br>  <em>Answer: Ken Iverson</em> <br>  <em>Chirag pathak</em> <br></blockquote><br><br>  J uses the idea of ‚Äã‚Äãtacit (from the word "tacit", implicit) programming, which does not require explicit mention of the arguments of the function (program) being defined.  Work in the tacit approach occurs, as a rule, with arrays of data, and not with their individual elements. <br>  It is interesting to note that tacit programming was discovered by Backus before APL and implemented in the FP language.  Among the modern languages ‚Äã‚Äãthat support this approach (except, of course, J), we can name the Fort and other concatenative languages, as well as Haskell (due to the point-free approach). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  1. Verbs </h2><br>  Define our first verb.  For convenience, we can assume that the verb is a function with default arguments.  Open the interpreter J, enter <br><br><pre><code class="matlab hljs">neg =: -</code> </pre> <a name="habracut"></a><br><br>  where ‚Äúneg‚Äù is the name of our verb, ‚Äú=:‚Äù is the assignment operator, ‚Äú-‚Äù is the actual body of the verb, which consists of calling the embedded verb ‚Äú-‚Äù.  Now let's try to apply our verb to the value (i.e. call it).  For example, to the unit: <br><br><pre> <code class="matlab hljs"> neg <span class="hljs-number"><span class="hljs-number">1</span></span> _1</code> </pre><br><br>  As you can see from the example, the result is the number ‚Äú-1‚Äù (in J, an underscore is used to write a negative number, since the minus is occupied by the embedded verb). <br><br>  Now we define a variable (in J this is called a ‚Äúnoun‚Äù) ‚Äúx‚Äù and assign the value -1 to it: <br><br><pre> <code class="matlab hljs"> x =: _1</code> </pre><br><br>  We expect the ‚Äúneg x‚Äù construction to return the unit to us.  It really is: <br><br><pre> <code class="matlab hljs"> neg x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  This call is similar to the simple <br><br><pre> <code class="matlab hljs"> - x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Another example: <br><br><pre> <code class="matlab hljs"> x _1 neg -</code> </pre><br><br>  Those.  the value of the variable "x" is "-1", and the value of the verb is its body.  You can change the way the values ‚Äã‚Äãare displayed on the screen using the verb "9!: 3". <br>  We define another verb, which will also be a simple synonym for the embedded verb: <br><br><pre> <code class="matlab hljs"> twice =: +:</code> </pre><br><br>  This verb doubles the value of its argument.  Here you can trace the pattern in the naming of verbs - for example, if the verb ‚Äú+:‚Äù doubles its argument, then the verb ‚Äú-:‚Äù halves its argument. <br><br><pre> <code class="matlab hljs"> NB.    x =: _1 NB. ,  ¬´NB.¬ª   . NB.     ¬´Nota Bene¬ª,    ¬´ ¬ª. twice x _2 twice (neg x) <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  And even so: <br><br><pre> <code class="matlab hljs"> twice (-: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  So <br><br><pre> <code class="matlab hljs"> +: (+: (- <span class="hljs-number"><span class="hljs-number">2</span></span>)) _8</code> </pre><br><br><h2>  2. Monads and dyads </h2><br><blockquote>  <em>This section is not related to Haskell</em> </blockquote><br><br>  Verbs can be called with one or two arguments.  A verb with one argument (operand) in terms of J is called a monad, and with two arguments it is called a dyad.  In the latter case, the arguments are written left and right (the first and second arguments, respectively) from the verb being called.  Recall our first monad: <br><br><pre> <code class="matlab hljs"> minus =: - minus <span class="hljs-number"><span class="hljs-number">1</span></span> _1 minus <span class="hljs-number"><span class="hljs-number">7</span></span> _7</code> </pre><br><br>  But the verb we have defined can be invoked with two arguments: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">4</span></span> minus <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> minus <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  In this case, the verb minus is used as a dyad and, as a result of the substitution, the expression "4-2" and "12-5" is calculated, respectively. <br><br>  Two arguments are a maximum that can be used when defining and invoking a verb. <br>  One can imagine that if the language J supported a two-dimensional syntax (such as the esoteric language Befunge), then the arguments could be written not only on the left and on the right, but on the top-bottom.  Fortunately, J only supports linear syntax. <br><br>  Let us give one more example - we define the verb ‚Äúdiv‚Äù as a synonym for the embedded verb ‚Äú%‚Äù.  Moreover, "%" is a division operator, the more familiar to us symbol "/" is used for other tasks (later we will show why). <br><br><pre> <code class="matlab hljs"> div =: <span class="hljs-comment"><span class="hljs-comment">% 1 div 2 0.5 4 div 3 1.3333</span></span></code> </pre><br><br>  In this example, the verb is called as a dyad and divides 1 into 2 and 4 into 3, respectively.  And note that although the operands are integers, the result of the division is a floating point number. <br><br>  When called with one operand, the verb ‚Äú%‚Äù by default divides the unit by this operand. <br><br><pre> <code class="matlab hljs"> div <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> div <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0.25</span></span></code> </pre><br><br>  The above expression could also be written as "1% 2" and "1% 4", respectively. <br><br>  In the example above, a rather important feature of the language is used - the monadic and dyadic calls of the same verb can perform actions that are quite different in meaning.  For example, the verb "*:" in the monad case calculates the square of its argument, and in the dyadic it performs the logical operation "Not-And": <br><br><pre> <code class="matlab hljs"> *: <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> *: <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> *: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> *: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> *: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> *: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Verbs "[" and "]" are intended for the verb to explicitly use its left or right argument.  The first one returns its left argument, the second one - the right one.  For example: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">11</span></span> [ <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> ] <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span> ] <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span> [ <span class="hljs-number"><span class="hljs-number">44</span></span> NB.  ,   ,  [   . <span class="hljs-number"><span class="hljs-number">44</span></span></code> </pre><br><br>  Let's add our luggage with the constant verbs "0:", "1:", "2:", ..., "9:".  They are called constant because, with whatever arguments we would not call them, they always return the same value.  "0:" returns zero, "1:" - one, etc.  For example: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br><h2>  3. Unions </h2><br>  Suppose further that for the same verb it is necessary to define different behavior for monadic (with one argument) and dyadic (with two arguments) calls.  This is a well-grounded desire, since  J is a dynamic language, and our code is not immune from incorrect use.  In order to separate the monadic and dyadic behavior of the verb, there is a special union ":". <br><br>  If we say that a verb is a function with one or two arguments by default, and the value of the arguments can be both a variable and an immediate value, then, in this case, ‚Äúunion‚Äù is a function that as two (and only two) arguments accept verbs.  Unions, as well as verbs, the user can define on their own. <br><br>  Here one could draw an analogy with parts of speech (in J, as we shall see later, there are also adverbs), but it seems to the author that this will lead to unnecessary confusion. <br><br>  Let's return to our monads.  On the left side of the union ":" the monadic call of the verb is recorded, on the right side - dyadic.  Example: <br><br><pre> <code class="matlab hljs"> v =: <span class="hljs-number"><span class="hljs-number">1</span></span>: : <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> v <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> v <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  If you call the verb "v" as a dyad (in the example with the arguments "11" and "22"), then the expression "2:" will be called.  If as a monad (in the example with the argument "11"), then to "1:".  And these are constant verbs that always return their meaning: ‚Äú2‚Äù in the first case and ‚Äú1‚Äù in the second. <br><br>  So far, we have operated only with numerical values.  This time, we use strings that are written in single quotes (double quotes in J is a union).  Redefine the previously described verb "v": <br><br><pre> <code class="matlab hljs"> v =: <span class="hljs-string"><span class="hljs-string">'monadic call'</span></span> : <span class="hljs-string"><span class="hljs-string">'dyadic call'</span></span> v <span class="hljs-number"><span class="hljs-number">11</span></span> |domain error <span class="hljs-number"><span class="hljs-number">11</span></span> v <span class="hljs-number"><span class="hljs-number">22</span></span> |domain error</code> </pre><br><br>  As we can see, there is an error in our definition.  A string is a value, not a verb, and it therefore does not produce any action.  And with the tacit definition of a verb, you only need to specify the order in which the verbs and their combinations are used. <br><br>  You can work with strings in J as well as with arrays (which we will get to know a little later).  For example, the verb ‚Äú#‚Äù in a monadic call returns the length of the array: <br><br><pre> <code class="matlab hljs"> # <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> # <span class="hljs-string"><span class="hljs-string">'12ab'</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> # <span class="hljs-string"><span class="hljs-string">'012345'</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> # <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  Earlier we defined the verb neg, which changes the sign of its argument.  However, if you call this verb in the dyadic version, the following will happen: <br><br><pre> <code class="matlab hljs"> neg =: - <span class="hljs-number"><span class="hljs-number">1</span></span> neg <span class="hljs-number"><span class="hljs-number">2</span></span> _1</code> </pre><br><br>  Those.  after substitution, our verb worked as a subtraction "1 - 2".  It would be advisable to limit the scope of the verb to only monadic call.  As mentioned earlier, the dynamic nature of J forces us to conduct similar checks during program execution.  As, perhaps, everything else in J, such a test is recorded as short as possible: <br><br><pre> <code class="matlab hljs"> neg =: - : [:</code> </pre><br><br>  We used the new verb "[:".  In the book ‚ÄúJ for C programmers‚Äù, this verb is called ‚Äúsuicidal verb‚Äù for being called, results in the program crash: <br><br><pre> <code class="matlab hljs"> neg <span class="hljs-number"><span class="hljs-number">1</span></span> _1 <span class="hljs-number"><span class="hljs-number">1</span></span> neg <span class="hljs-number"><span class="hljs-number">2</span></span> NB.      - - |domain error</code> </pre><br><br>  In order to catch such situations, you can use the so-called.  "Traps".  In J, there are no exceptions in the conventional sense of the word, instead the ‚Äú::‚Äù union is used. <br><br>  The union "::" executes the expression to the left of itself, and if it ended with an error, it executes the expression to the right.  Example: <br><br><pre> <code class="matlab hljs"> v =: [: :: <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> v <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> v <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br>  This verb will always return 3, because, as we said, the expression on the left will be executed first.  And on the left we put a suicidal verb.  Consequently, the union "::" with each call of the verb "v" catches the suicide "[:" and passes all the arguments to the verb, which we wrote down on the right, i.e.  the verb-constant "3:". <br><br><h3>  3.1.  Unions for sequential computing </h3><br><br>  So far, we have used only single verbs.  In order to carry out sequential calculations, the conjunction ‚Äú@‚Äù or the special verb ‚Äú[:‚Äù ‚Äùis used, which, being the first element in the composition of verbs, is skipped and allows you to perform a sequential calculation: <br><br><pre> <code class="matlab hljs"> ([: +: +:) <span class="hljs-number"><span class="hljs-number">10</span></span> NB.  (+: (+: <span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-number"><span class="hljs-number">40</span></span> (+: @ +:) <span class="hljs-number"><span class="hljs-number">10</span></span> NB.  (+: (+: <span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-number"><span class="hljs-number">40</span></span></code> </pre><br><br>  The next union in our collection is ‚Äú&amp;.‚Äù, The principle of which is the following. <br><br><pre> <code class="matlab hljs"> u&amp;.vy NB.  v_ uvy x u&amp;.vy NB.  v_ (vx) u (vy). +:&amp;.*: <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">14.1421</span></span> <span class="hljs-comment"><span class="hljs-comment">%: @: +: (*: 10) NB.    14.1421 %: (+: (*: 10)) NB.   14.1421</span></span></code> </pre><br>  where ‚Äúv_inversion‚Äù means a verb, reverse ‚Äúv‚Äù.  In the expression ‚Äú+: &amp;. *:‚Äù The verb from which the inversion is taken is ‚Äú*:‚Äù (because it stands to the right of the conjunction ‚Äú&amp;.‚Äù).  And the verb, the reverse "*:" is "%:".  Those.  the operation inverse to squaring is taking a square root. <br><br>  Another useful for us is the conjunction "&amp;", which makes a monadic from a dyadic call, attaching a noun (operand-value) to the verb.  With a certain assumption, it can be said that this union performs currying.  For example: <br><pre> <code class="matlab hljs"> inc =: <span class="hljs-number"><span class="hljs-number">1</span></span>&amp;+ NB.  inc <span class="hljs-number"><span class="hljs-number">41</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> inc _3 _2 div3 =: <span class="hljs-comment"><span class="hljs-comment">%&amp;3 div3 9 3 div3 12 4</span></span></code> </pre><br><br>  Define the increment only for the monad case: <br><br><pre> <code class="matlab hljs"> inc =: <span class="hljs-number"><span class="hljs-number">1</span></span>&amp;+ : [: inc <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> inc <span class="hljs-number"><span class="hljs-number">2</span></span> |domain error: inc | <span class="hljs-number"><span class="hljs-number">1</span></span> inc <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br><h2>  4. Adverbs </h2><br><br>  We have already mentioned adverbs.  In terms of the J language, an adverb is an expression that takes a verb as an argument and forms a new verb with a different behavior. <br><br>  We give the adverb "~", which swaps the arguments in its dyadic call ("xu ~ y" is substituted for "yux") and replaces the monadic call of the verb - with the dyadic, copying the operand ("u ~ y" is substituted for "yuy"). <br><br><pre> <code class="matlab hljs"> <span class="hljs-comment"><span class="hljs-comment">% 2 NB.   ,    ¬´1 % 2¬ª 0.5 %~ 2 NB.  ¬´2 % 2¬ª 1 2 % 3 0.666667 2 %~ 3 NB.  ¬´3 % 2¬ª 1.5</span></span></code> </pre><br><br>  One of the most commonly used adverbs is the adverb / (‚Äúbetween‚Äù), the consideration of which we will defer to the section on arrays. <br><br><h2>  5. Hooks and forks </h2><br><br>  In J, there is a very peculiar way of composition of functions - if 2 consecutive verbs are indicated, this does not mean that they will be applied sequentially.  They will have their own special calling procedure for dyadic and monadic calls.  Such a composition for 2 verbs is called a hook (hook).  Define the verb v, which is the hook calling of the verbs f and g: <br><br><pre> <code class="matlab hljs"> v =: fg</code> </pre><br><br>  If you call v as a monad on some noun y: <br><br><pre> <code class="matlab hljs"> vy</code> </pre><br><br>  then this call will be equivalent to: <br><br><pre> <code class="matlab hljs"> yf (gy)</code> </pre><br><br>  It should be noted that, despite the monadic call of the verb v, one of the elements of the hook (namely, f) is called as a dyad with duplication on the left of a single operand. <br><br>  If you call v as a dyad on some nouns x and y: <br><br><pre> <code class="matlab hljs"> xvy</code> </pre><br><br>  then this call will be equivalent to: <br><br><pre> <code class="matlab hljs"> xf (gy)</code> </pre><br><br>  Let us recall the verb <code>¬´#¬ª</code> , which in the monadic call returns the length of a string / array, and in the dyadic it copies the right operand as many times as indicated in the left operand.  Define the dyad: <br><br><pre> <code class="matlab hljs"> v =: # #</code> </pre><br><br>  Let's decompose the dyadic call of the verb v according to the above scheme: <br><br><pre> <code class="matlab hljs">  # (# y)</code> </pre><br><br>  As you can see, v copies a number equal to the length of the operand y, x times.  For example: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">2</span></span> v <span class="hljs-string"><span class="hljs-string">'1234'</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><br>  One would assume that 3 consecutive verbs are a hook from a hook.  However, this is not the case - instead, a fork composition (the so-called fork) is implemented.  So, monad call fork <br><br><pre> <code class="matlab hljs"> (fgh) y</code> </pre><br><br>  equivalent to the following call: <br><br><pre> <code class="matlab hljs"> (fy) g (hy)</code> </pre><br><br>  An example of such an expression is the already known verb, which calculates the average of an array of numbers: <br><br><pre> <code class="matlab hljs"> <span class="hljs-built_in"><span class="hljs-built_in">mean</span></span> =: +/<span class="hljs-comment"><span class="hljs-comment">%# mean 0 1 2 3 4 5 2.5</span></span></code> </pre><br><br>  This expression is equivalent to the following: <br><br><pre> <code class="matlab hljs"> ((+/ @ [ )<span class="hljs-comment"><span class="hljs-comment">%(# @ ])) 0 1 2 3 4 5 2.5</span></span></code> </pre><br><br>  Consider another example of a fork: <br><br><pre> <code class="matlab hljs"> v =: # # # v <span class="hljs-string"><span class="hljs-string">'12345'</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><br>  As you can see, this expression copies the number equal to the length of the operand, as many times as the length of the operand. <br><br>  The previous verb could be rewritten without using forks: <br><br><pre> <code class="matlab hljs"> ((#@]) # (#@])) <span class="hljs-string"><span class="hljs-string">'12345'</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><br>  Define on the dyadic call forks on nouns x and y: <br><br><pre> <code class="matlab hljs"> x (fgh) y</code> </pre><br><br>  which will be equivalent to the following expression: <br><br><pre> <code class="matlab hljs"> (xfy) g (xhy)</code> </pre><br><br>  We illustrate the dyadic fork with the help of our old friend - the verb mean: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mean</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1.66667</span></span> <span class="hljs-number"><span class="hljs-number">1.66667</span></span></code> </pre><br><br>  Expand this expression: <br><br><pre> <code class="matlab hljs"> (<span class="hljs-number"><span class="hljs-number">2</span></span> +/ <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">% (2 # 3)</span></span></code> </pre><br><br>  We get that the right side of the expression copies 2 times the top three.  And the left one calculates the sum of the left and right operands.  So  we will receive: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">% 3 3 1.66667 1.66667</span></span></code> </pre><br><br>  It is especially important to understand that in J if 4 verbs are indicated, then this expression will be a hook from a fork, if 5 - then a fork from a fork, 6 - a hook from a fork from a fork, etc.  Those.  the expressions "(# # # # # #)" and "(# (# # (# # #)))" are equivalent. <br><br>  We show how to use the round brackets to change the order of calculations.  For example: <br><br><pre> <code class="matlab hljs"> (# # #) <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  But <br><br><pre> <code class="matlab hljs"> (# (# #)) <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  The last expression is equivalent to the following: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">3</span></span> # (<span class="hljs-number"><span class="hljs-number">3</span></span> # (# <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> # <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> NB.  <span class="hljs-number"><span class="hljs-number">3</span></span>   .</code> </pre><br><br>  Let us show a more complex example with the composition of functions. <br><br><pre> <code class="matlab hljs"> (* + - <span class="hljs-comment"><span class="hljs-comment">%) 3 8</span></span></code> </pre><br><br>  This expression is equivalent to: <br><br><pre> <code class="matlab hljs"> <span class="hljs-number"><span class="hljs-number">3</span></span> * ((+ <span class="hljs-number"><span class="hljs-number">3</span></span>) - (<span class="hljs-comment"><span class="hljs-comment">% 3))</span></span></code> </pre><br><br>  A combination of 5 verbs might look like this: <br><br><pre> <code class="matlab hljs"> (&gt;: * + - <span class="hljs-comment"><span class="hljs-comment">%) 3 10.6667</span></span></code> </pre><br><br>  The last expression is equivalent to the following: <br><br><pre> <code class="matlab hljs"> (&gt;: <span class="hljs-number"><span class="hljs-number">3</span></span>) * ((+ <span class="hljs-number"><span class="hljs-number">3</span></span>) - (<span class="hljs-comment"><span class="hljs-comment">% 3)) 4 * (3 ‚Äì 0.333)</span></span></code> </pre><br><br>  <i>Next article in the Cycle of <a href="http://habrahabr.ru/post/198228/">Programming Language J. Amateur Look.</a></i>  <i><a href="http://habrahabr.ru/post/198228/">Part 3. Arrays</a></i> </div><p>Source: <a href="https://habr.com/ru/post/198066/">https://habr.com/ru/post/198066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198052/index.html">Programming language J. Amateur look. Part 1. Introduction</a></li>
<li><a href="../198054/index.html">About how we made the game for google play</a></li>
<li><a href="../198056/index.html">The isoHunt BitTorrent tracker closes after being defeated against MPAA</a></li>
<li><a href="../198060/index.html">VirtualDub Check</a></li>
<li><a href="../198062/index.html">Listen to music from Google Play Music</a></li>
<li><a href="../198068/index.html">Method for generating test tasks based on AND / OR trees and its software implementation</a></li>
<li><a href="../198072/index.html">Seek advice from experts and colleagues (mobile solutions)</a></li>
<li><a href="../198076/index.html">Business tablet HP ElitePad 900, or What should be a tablet for business?</a></li>
<li><a href="../198082/index.html">3 ways to develop</a></li>
<li><a href="../198084/index.html">Coursmos. The first platform for learning in micro-course format</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>