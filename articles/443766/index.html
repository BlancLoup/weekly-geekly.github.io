<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We try contract programming With ++ 20 already now</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20 contract programming appeared. At the moment, no compiler has yet implemented support for this feature. 


 But there is a way to try to us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We try contract programming With ++ 20 already now</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ow/o1/yv/owo1yvuvpymi1w4uoa1olkjoo0g.png"></p><br><p>  In C ++ 20 contract programming appeared.  At the moment, no compiler has yet implemented support for this feature. </p><br><p>  But there is a way to try to use contracts from C ++ 20 right now, as it is described in the standard. </p><a name="habracut"></a><br><h3 id="tldr">  TL; DR </h3><br><p>  <em>There is fork clang supporting contracts.</em>  <em>On his example, I tell you how to use contracts so that as soon as the feature appears in your favorite compiler, you can immediately start using it.</em> </p><br><p>  A lot has already been written about contract programming, but in a nutshell I‚Äôll tell you what it is and why you need it. </p><br><h2 id="logika-hoara">  Logic hoare </h2><br><p>  The contract paradigm is based on the logic of Hoare ( <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25A5%25D0%25BE%25D0%25B0%25D1%2580%25D0%25B0">1</a> , <a href="https://habr.com/ru/post/268013/">2</a> ). </p><br><p>  Hoar's logic is a way to formally prove the correctness of an algorithm. <br>  It operates with such concepts as precondition, postcondition and invariant. <br>  From a practical point of view, the use of Hoar‚Äôs logic is, firstly, a way to formally prove the correctness of a program in cases where errors can lead to a catastrophe or death.  Secondly, a way to increase the reliability of the program, along with static analysis and testing. </p><br><h2 id="kontraktnoe-programmirovanie">  Contract Programming </h2><br><p>  ( <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">1</a> , <a href="https://habr.com/ru/post/38612/">2</a> ) </p><br><p>  The basic idea of ‚Äã‚Äãcontracts is that by analogy with contracts in business, agreements are described for each function or method.  These arrangements must be respected by both the caller and the callee. <br>  An integral part of the contract is at least two modes of assembly - debugging and grocery.  Depending on the build mode, contracts must behave differently.  The most common practice is to check contracts in the debug build and ignore them in the grocery. </p><br><p>  Sometimes in a product assembly contracts are also checked and their non-fulfillment may, for example, lead to an exception being thrown. </p><br><p>  The main difference between the use of contracts from the "classic" approach is that the caller must comply with the caller's preconditions, which are described in the contract, and the callee must abide by his post-conditions and invariants. <br>  Accordingly, the called party is not obliged to check the correctness of its transmitted parameters.  This obligation is imposed by the contract to the caller. </p><br><p>  Noncompliance with contracts must be detected at the testing stage and complements all types of tests: modular integration, etc. </p><br><p>  At first glance, the use of contracts leads to more complicated development and degrades the readability of the code.  In fact, everything is just the opposite.  Adherents of static typing will be the easiest to evaluate the benefits of contracts, because the simplest option is to describe types in the signature of methods and functions. </p><br><p>  So, what benefits give contracts: </p><br><ul><li>  Improve readability of the code due to explicit documentation. </li><li>  Improve the reliability of the code, complementing the testing. </li><li>  Allow compilers to use low-level optimizations and generate faster code based on contract compliance.  In the latter case, failure to comply with the contract in a release assembly may lead to UB. </li></ul><br><h2 id="kontraktnoe-programmirovanie-v-c">  Contract programming in C ++ </h2><br><p>  Contract programming is implemented in many languages.  The most prominent examples are <a href="https://www.eiffel.org/doc/eiffel/ET-_Design_by_Contract_%2528tm%2529%252C_Assertions_and_Exceptions">Eiffel</a> , where the paradigm was first implemented, and <a href="https://dlang.org/spec/contracts.html">D</a> , in D, contracts are part of the language. </p><br><p>  In C ++, up to the standard C ++ 20, contracts could be used as separate libraries. </p><br><p>  This approach has several disadvantages: </p><br><ul><li>  Very awkward syntax with macros. </li><li>  The lack of a uniform style. </li><li>  The inability to use contracts compiler to optimize the code. </li></ul><br><p>  Library implementations are usually based on the use of the good old assert and preprocessor directives that check for the presence of a compilation flag. </p><br><p>  Using contracts in this form really makes the code ugly and unreadable.  This is one of the reasons why contracting is little practiced in C ++. </p><br><p>  Looking ahead, I'll show you how in C ++ 20 the use of contracts will look. <br>  And then, let's look at all this in more detail: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; 0 ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition [[ expects: y &gt; 0 ]] // precondition [[ ensures r: r &lt; x + y ]] // postcondition { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z + y; }</span></span></span></span></code> </pre> <br><h2 id="probuem">  We try </h2><br><p>  Unfortunately, at the moment none of the widely used compilers have yet implemented contract support. <br>  But there is a way out. </p><br><p>  <em>The ARCOS research group</em> from the <em>Universidad Carlos III de Madrid</em> implemented experimental support for contracts in the fork of clang ++. </p><br><p>  In order not to ‚Äúwrite code on a piece of paper,‚Äù but to have the opportunity to immediately try new possibilities in business, we can assemble this fork and use it to try the examples given below. </p><br><p>  Assembly instructions are described in the Github repository readme. <br>  <a href="https://github.com/arcosuc3m/clang-contracts">https://github.com/arcosuc3m/clang-contracts</a> </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/arcosuc3m/clang-contracts/ mkdir -p clang-contracts/build/ &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> clang-contracts/build/ cmake -G <span class="hljs-string"><span class="hljs-string">"Unix Makefiles"</span></span> -DLLVM_USE_LINKER=gold -DBUILD_SHARED_LIBS=ON -DLLVM_USE_SPLIT_DWARF=ON -DLLVM_OPTIMIZED_TABLEGEN=ON ../ make -j8</code> </pre> <br><p>  I did not have any problems with the build, but compiling the source takes a lot of time. </p><br><p>  To compile the examples, you will need to explicitly specify the path to the clang ++ binary. <br>  For example, I have it looks like this </p><br><pre> <code class="bash hljs">/home/valmat/work/git/clang-contracts/build/bin/clang++ -std=c++2a -build-level=audit -g test.cpp -o test.bin</code> </pre> <br><p>  I prepared examples for you to conveniently explore contracts with real code examples.  I suggest, before starting the next section, to clone and compile the examples. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/valmat/cpp20-contracts-examples/ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> cpp20-contracts-examples make CPP=/path/to/clang++</code> </pre> <br><p>  Here <code>/path/to/clang++</code> path to the <code>clang++</code> binary of your experimental compiler build. </p><br><p>  In addition to the compiler itself, the ARCOS research group prepared their own version of the <a href="http://fragata.arcos.inf.uc3m.es/">Compiler Explorer</a> for their fork. </p><br><h2 id="kontraktnoe-programmirovanie-v-c20">  Contract programming in C ++ 20 </h2><br><p>  Now nothing prevents us from starting to explore the possibilities offered by contract programming, and immediately try these possibilities in action. </p><br><p>  As mentioned above, contracts are built from preconditions, postconditions and invariants (statements). </p><br><p>  In C ++ 20, attributes with the following syntax are used for this. </p><br><pre> <code class="cpp hljs">[[contract-attribute modifier identifier: conditional-expression]]</code> </pre> <br><p>  Where <code>contract-attribute</code> can be one of the following values: <br>  <strong>expects</strong> , <strong>ensures</strong> or <strong>assert</strong> . </p><br><p>  <code>expects</code> used for preconditions, <code>ensures</code> for postconditions and <code>assert</code> for statements. </p><br><p>  <code>conditional-expression</code> is a boolean expression that is checked in a predicate contract. <br>  <code>modifier</code> and <code>identifier</code> may be omitted. </p><br><p>  Why do I need a <code>modifier</code> I will write below. </p><br><p>  <code>identifier</code> used only with <code>ensures</code> and serves to represent the return value. </p><br><p>  Preconditions have access to arguments. </p><br><p>  Postconditions have access to the value returned by the function.  To do this, use the syntax </p><br><pre> <code class="cpp hljs">[[ensures return_variable: expr(return_variable)]]</code> </pre> <br><p>  Where <code>return_variable</code> any valid expression for a variable. </p><br><p>  In other words, the preconditions are intended to declare the constraints imposed on the arguments taken by the function, and the postconditions to declare the constraints imposed on the return value of the function. </p><br><p>  <em>Preconditions</em> and <em>postconditions</em> are considered to be part of the function interface, while <em>statements</em> are part of its implementation. </p><br><p>  Predicates preconditions are always calculated immediately before the execution of the function.  Postconditions are executed immediately after being passed by the control function to the calling code. </p><br><p>  If an exception is thrown in the function, the postconditions will not be checked. <br>  Postconditions are checked only in case of normal completion of the function. </p><br><p>  If an exception is raised while checking the expression in the contract, then <code>std::terminate()</code> will be called. </p><br><p>  Preconditions and postconditions are always described outside the function body and cannot access local variables. </p><br><p>  If preconditions and postconditions describe a contract for a public class method, they cannot have access to private and protected class fields.  If the class method is protected, then there is access to the protected and public data of the class, but there is no private one. <br>  The last restriction is completely logical, given that the contract is part of the method interface. </p><br><p>  Statements (invariants) are always described in the body of a function or method.  By design, they are part of the implementation.  And, accordingly, can have access to all available data.  This includes local function variables and private and protected class fields. </p><br><p>  <a href="">example 1</a> </p><br><p>  We define two preconditions, one post-condition and one invariant: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; y ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition #1 [[ expects: y &gt; 0 ]] // precondition #2 [[ ensures r: r &lt; x ]] // postcondition #3 { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z; } int main() { std::cout &lt;&lt; foo(117, 20) &lt;&lt; std::endl; std::cout &lt;&lt; foo(10, 20) &lt;&lt; std::endl; // &lt;-- contract violation #1 std::cout &lt;&lt; foo(100, -5) &lt;&lt; std::endl; // &lt;-- contract violation #2 return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="">example 2</a> </p><br><p>  The public method precondition cannot refer to a protected or private field: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//protected: int m = 5; public: int foo(int n) [[expects: n &lt; m]] { return n*n; } };</span></span></code> </pre> <br><p>  Modification of variables inside expressions described by contract attributes is not allowed.  If this is broken, it will be UB. </p><br><p>  The expressions described in the contracts should not have side effects.  Although compilers can verify this, this is not their responsibility.  Violation of this requirement is considered unspecified behavior. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; m++ ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// UB: Modifies variable m { int k = n*n; [[ assert: ++k &lt; 100 ]] // UB: Modifies variable k return n*n; } };</span></span></span></span></code> </pre> <br><p>  The requirement not to change the state of the program in contract expressions will become obvious a little lower when I talk about contract modifier levels and assembly modes. </p><br><p>  Now I‚Äôll just note that the correct program should work just as if there were no contracts at all. </p><br><p>  As I noted above, in the contract you can specify any number of preconditions and postconditions. <br>  All of them will be checked in order.  But preconditions are always checked before executing the function, and postconditions immediately after exiting it. </p><br><p>  This means that the preconditions are always checked first, as illustrated in the following example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// # 1 [[ ensures r: expr(r) ]] // # 4 [[ expects: expr(n) ]] // # 2 [[ expects: expr(n) ]] // # 3 [[ ensures r: expr(r) ]] // # 5 {...}</span></span></span></span></code> </pre> <br><p>  Expressions in postconditions can refer not only to the return value of the function, but also to the arguments of the function. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ ensures: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]]</span></span>;</code> </pre> <br><p>  In this case, you can omit the return value ID. </p><br><p>  If a postcondition refers to a function argument, then this argument is considered <em>at the exit point of the function</em> , and not at the entry point, as is the case with preconditions. </p><br><p>  There is no way to refer to the original (at the function entry point) value in a postcondition. </p><br><p>  <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ expects: 3 </span></span>== n ]] [[ ensures: <span class="hljs-number"><span class="hljs-number">4</span></span> == n ]] {++n;}</code> </pre> <br><p>  Predicates in contracts can refer to local variables only if the lifetime of these variables corresponds to the predicate's computation time. </p><br><p>  For example, for <code>constexpr</code> functions, you cannot refer to local variables unless they are known at compile time. </p><br><p>  <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: a &lt;</span></span>= n ]] <span class="hljs-comment"><span class="hljs-comment">// error: `a` is not constexpr [[ expects: n &lt; b ]] // OK { [[assert: n &gt; 2*a]]; // error: `a` is not constexpr [[assert: n &lt; 2*b]]; // OK return 2*n; }</span></span></code> </pre> <br><h3 id="kontrakty-dlya-ukazateley-na-funkciyu">  Function pointers contracts </h3><br><p>  You cannot define contracts for a function pointer, but you can assign a function pointer to the address of the function for which the contract is defined. </p><br><p>  <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*pfoo)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) = &amp;foo;</code> </pre> <br><p>  Calling <code>pfoo(100)</code> will violate the contract. </p><br><h3 id="kontrakty-pri-nasledovanii">  Inheritance contracts </h3><br><p>  The classic implementation of the concept of contracts suggests that preconditions can be relaxed in subclasses, postconditions and invariants can be strengthened in subclasses. </p><br><p>  In a C ++ implementation, this is not the case. </p><br><p>  First, invariants in C ++ 20 are part of the implementation, not the interface.  For this reason, they can be both strengthened and weakened.  If there is no <code>assert</code> in the implementation of the virtual function, it will not be inherited. </p><br><p>  Secondly, it is required that when inheriting a function, the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">ODRs are</a> identical. <br>  And, since the preconditions and postconditions are part of the interface, then in the heir they must be exactly the same. </p><br><p>  At the same time, the description of preconditions and postconditions for inheritance can be omitted.  But if they are declared, they must exactly match the definition in the base class. </p><br><p>  <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n*<span class="hljs-number"><span class="hljs-number">2</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-comment"><span class="hljs-comment">// Inherits contracts from Base virtual int foo(int n) override { return n*3; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text"><p>  Unfortunately, the example above <a href="https://github.com/arcosuc3m/clang-contracts/issues/18">does not work</a> in the experimental compiler as expected. </p><br><p>  If the <code>foo</code> from <code>Derived2</code> contract, it will not be inherited from the base class.  In addition, the compiler allows you to determine for a subclass a contract that does not match the base contract. </p><br><p>  Another experimental compiler <a href="https://github.com/arcosuc3m/clang-contracts/issues/20">error</a> : </p><br><p>  the syntax should be correct </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[expects: n &lt; 10]] </span></span>{...}</code> </pre> <br><p>  However, in this form, I received a compilation error </p><br><pre> <code class="bash hljs">inheritance1.cpp:20:36: error: expected <span class="hljs-string"><span class="hljs-string">';'</span></span> at end of declaration list virtual int foo(int n) override ^ ;</code> </pre> <br><p>  and had to be replaced by </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] override </span></span>{...}</code> </pre> <br><p>  I think this is due to the peculiarity of the experimental compiler, and syntax correct code will work in the release versions of compilers. </p></div></div><br><h3 id="modifikatory-kontraktov">  Contract Modifiers </h3><br><p>  Verification of contract predicates may incur additional computational costs. <br>  Therefore, it is common practice to check contracts in the developer and test builds and ignore them in the release build. </p><br><p>  For these purposes, the standard offers three levels of contract modifiers.  With the help of modifiers and compiler keys, the programmer can control which contacts will be checked in the assembly, and which ones will be ignored. </p><br><ul><li>  <code>default</code> - this modifier is used by default.  It is assumed that the computational cost of checking the execution of an expression with this modifier is <em>small</em> compared with the cost of calculating the function itself. </li><li>  <code>audit</code> - this modifier assumes that the computational cost of checking the execution of an expression is <em>significant</em> compared to the cost of calculating the function itself. </li><li>  <code>axiom</code> - this modifier is used if the expression is declarative.  Not checked at runtime.  It is used to document the interface of a function, to be used by static analyzers and the compiler optimizer.  Expressions with the <code>axiom</code> modifier <code>axiom</code> never evaluated at run time. </li></ul><br><p>  Example </p><br><pre> <code class="cpp hljs">[[expects: expr]] <span class="hljs-comment"><span class="hljs-comment">//  default [[expects default: expr]] //  default [[expects axiom : expr]] // Run-time    [[expects audit : expr]] //   </span></span></code> </pre> <br><p>  Using modifiers, you can determine which checks in which versions of your builds will be used and which ones will be disabled. </p><br><p>  It should be noted that even if the check is not performed, the compiler has the right to use the contract for low-level optimizations.  And although contract verification can be disabled with a compilation flag, contract violation leads to undefined program behavior. </p><br><p>  At the discretion of the compiler, means may be provided to include checking expressions marked as <code>axiom</code> . </p><br><p>  In our case, this is a compiler option. </p><br><pre> <code class="plaintext hljs">-axiom-mode=&lt;mode&gt;</code> </pre> <br><p>  <code>-axiom-mode=on</code> <em>enables</em> the axioms mode and, accordingly, <em>turns off the</em> verification of assertions with the identifier <code>axiom</code> , </p><br><p>  <code>-axiom-mode=off</code> <em>turns off</em> the axiom mode and, accordingly, <em>turns on</em> verification of assertions with the identifier <code>axiom</code> . </p><br><p>  <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects axiom: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; }</code> </pre><br><p>  The program can be compiled with three different levels of verification: </p><br><ul><li>  <code>off</code> turns off all expression tests in contracts. </li><li>  <code>default</code> only expressions with the <code>default</code> modifier are checked. </li><li>  <code>audit</code> extended mode when all checks are performed with the <code>default</code> and <code>audit</code> modifiers </li></ul><br><p>  How exactly to implement the installation of the verification level is left to the discretion of the compiler developers. </p><br><p>  In our case, the compiler option is used for this. </p><br><pre> <code class="bash hljs">-build-level=&lt;off|default|audit&gt;</code> </pre> <br><p>  The default is <code>-build-level=default</code> </p><br><p>  As already mentioned, the compiler can use contracts for low-level optimizations.  For this reason, despite the fact that at the time of execution, some predicates in contracts (depending on the level of verification) may not be computed, their failure leads to undefined behavior. </p><br><p>  I will postpone the examples of application of assembly levels until the next section, where they can be made visible. </p><br><h3 id="perehvat-narusheniya-kontrakta">  Interception breach of contract </h3><br><p>  Depending on the options with which the program is going, in case of breach of contract there may be different scenarios of behavior. </p><br><p>  By default, breaching a contract causes the program to crash, calling <code>std::terminate()</code> .  But the programmer can override this behavior by giving his handler and telling the compiler to continue the program after a breach of contract. </p><br><p>  When compiling, you can install a <em>violation handler</em> called when a contract is violated. </p><br><p>  The way to implement the installation handler is given to the discretion of the creators of the compiler. </p><br><p>  In our case it is </p><br><pre> <code class="bash hljs">-contract-violation-handler=&lt;violation_handler&gt;</code> </pre> <br><p>  The handler signature must be </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info)</code> </pre> <br><p>  or </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span></code> </pre> <br><p>  <code>std::contract_violation</code> equivalent to the following definition: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contract_violation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint_least32_t</span></span> line_number() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertion_level</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; };</code> </pre> <br><p>  Thus, the processor allows you to get enough comprehensive information about exactly where and under what conditions a breach of contract occurred. </p><br><p>  If the <em>violation handler is</em> set, then in case of a contract violation, by default, immediately after its execution, <code>std::abort()</code> will be called <code>std::abort()</code> <code>std::terminate()</code> is called without specifying the handler). </p><br><p>  The standard assumes that compilers provide tools that allow programmers to continue executing a program after a breach of contract. </p><br><p>  The method of implementing these tools is left to the discretion of the compiler developers. <br>  In our case, this is a compiler option. </p><br><pre> <code class="bash hljs">-fcontinue-after-violation</code> </pre> <br><p>  The options <code>-fcontinue-after-violation</code> and <code>-contract-violation-handler</code> can be set independently of each other.  For example, you can set <code>-fcontinue-after-violation</code> , but not set <code>-contract-violation-handler</code> .  In the latter case, after the breach of contract, the program will simply continue to work. </p><br><p>  The possibility of continuing the work of the program after the breach of contract is specified by the standard, but care should be taken with this opportunity. </p><br><p>  Technically, the behavior of the program after the breach of contract is not defined, even if the programmer explicitly indicated that the program should continue to work. </p><br><p>  This is due to the ability of the compiler to perform low-level optimizations per contract execution. </p><br><p>  Ideally, if a breach of contract occurred, you need to record diagnostic information as soon as possible and shut down the program.  You need to understand exactly what you are doing allowing the program to work after a violation. </p><br><p>  Define <a href="">your handler</a> and with its help intercept the breach of contract </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp; info)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"line_number : "</span></span> &lt;&lt; info.line_number() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"file_name : "</span></span> &lt;&lt; info.file_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"function_name : "</span></span> &lt;&lt; info.function_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"comment : "</span></span> &lt;&lt; info.comment() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assertion_level : "</span></span> &lt;&lt; info.assertion_level() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  And consider <a href="">an example of</a> breach of contract: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[expects: n &lt; 10]] { return n*n; } int main() { foo(100); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;-- contract violation return 0; }</span></span></span></span></code> </pre> <br><p>  Compile the program with the options <code>-contract-violation-handler=violation_handler</code> and <code>-fcontinue-after-violation</code> and run </p><br><pre> <code class="bash hljs">$ bin/example8-handling.bin line_number : 4 file_name : example8-handling.cpp function_name : foo comment : n &lt; 10 assertion_level : default</code> </pre> <br><p>  Now you can give examples that demonstrate the behavior of the program when a contract is violated at different levels of assembly and contract modes. </p><br><p>  Consider the following <a href="">example</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[ expects axiom : n &lt; 100 ]] [[ expects default : n &lt; 200 ]] [[ expects audit : n &lt; 300 ]] { return 2 * n; } int main() { foo(350); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// audit foo(250); // default return 0; }</span></span></span></span></code> </pre> <br><p>  If you build it with the option <code>-build-level=off</code> then, as expected, the contracts will not be checked. </p><br><p>  Gathering with the <code>default</code> level (with the option <code>-build-level=default</code> ), we get the following output: </p><br><pre> <code class="bash hljs">$ bin/example9-default.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><p>  And the assembly with the level of <code>audit</code> will give: </p><br><pre> <code class="bash hljs"> $ bin/example9-audit.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 6 file_name : example9.cpp function_name : foo comment : n &lt; 300 assertion_level : audit line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><h4 id="zamechaniya">  Remarks </h4><br><p>  <code>violation_handler</code> may throw exceptions.  In this case, you can configure the program so that the breach of contract leads to the release of an exception. </p><br><p>  If the function with which contracts are described is marked as <code>noexcept</code> and when checking the contract, a <code>violation_handler</code> called that throws an exception, then <code>std::terminate()</code> will be called. </p><br><p>  <a href="">Example</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> [[ expects: n &gt; 0 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- std::terminate() when violation handler throws an exception return 0; }</span></span></code> </pre> <br><p>  If the flag is passed to the compiler: do not continue program execution after contract violation ( <code>continuation mode=off</code> ), but the violation handler handler throws an exception, <code>std::terminate()</code> will be forcibly called. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Contracts are non-intrusive runtime checks.  They play a very important role in ensuring the quality of the released software. </p><br><p>  C ++ is used very widely.  And for sure there will be a sufficient number of claims to the specification of contracts.  In my subjective opinion, the implementation turned out quite comfortable and intuitive. </p><br><p>  C ++ 20 contracts will make our programs even more reliable, fast, and understandable.  I look forward to their implementation in compilers. </p><br><hr><br><p>  PS <br>  In PM, they tell me that it is <a href="https://github.com/jensmaurer/papers/issues/162">likely</a> that in the final edition of the standard, the <code>expects</code> and <code>ensures</code> will <code>ensures</code> replaced with <code>pre</code> and <code>post</code> , respectively. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443766/">https://habr.com/ru/post/443766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443752/index.html">Kotlin as the future of Android application development</a></li>
<li><a href="../443754/index.html">About the feasibility of Selenium WebDriverWait</a></li>
<li><a href="../443756/index.html">Design classes: what is good?</a></li>
<li><a href="../443762/index.html">Using inheritance when generating web pages in pure javascript</a></li>
<li><a href="../443764/index.html">What the designer smoked: an unusual firearm</a></li>
<li><a href="../443768/index.html">Monolith for hundreds of client versions: how we write and support tests</a></li>
<li><a href="../443770/index.html">Domain Driven Design: Value Objects and Entity Framework Core in practice</a></li>
<li><a href="../443772/index.html">Antiquities: IBM ThinkPad T40, the first wireless</a></li>
<li><a href="../443776/index.html">China introduces experimental face recognition system when paying for subway fares</a></li>
<li><a href="../443782/index.html">Developers can now use Valve's Network API for their games on Steam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>