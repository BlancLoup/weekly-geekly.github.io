<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing in Yandex. Himself a web-service over SSH, or how to make a stub for the whole service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You are a practicing magician manager. Or a combat developer. Or a professional tester. Or maybe just a person who is not indifferent to the developme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing in Yandex. Himself a web-service over SSH, or how to make a stub for the whole service</h1><div class="post__text post__text-html js-mediator-article">  You are a practicing <s>magician</s> manager.  Or a combat developer.  Or a professional tester.  Or maybe just a person who is not indifferent to the development and use of systems that include client-server components.  I am sure you even know that the port is not only the place where the ships come, and ‚Äússh‚Äù is not only the sound made by the snake.  And you know that services located on one or several machines actively communicate with each other.  Most often via HTTP.  And from version to version the format of this communication needs to be controlled. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/228691/"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/7db/027/b2d7db0271edc0df494a991644e4f898.jpg"></a> <br><br>  I think each of you asked the following release with the next release: ‚ÄúDo we send the correct request exactly?‚Äù Or ‚ÄúDid we exactly pass all the necessary parameters to this service?‚Äù.  Everyone should be aware of the existence of negative scenarios for the development of events along with positive ones.  This knowledge should actively generate questions from the ‚ÄúWhat if ..?‚Äù Series.  What if the service starts to process connections with a delay of 2 hours?  What if the service responds to abracadabra instead of data in json format? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Such things are often forgotten during the development process.  Due to the complexity of testing problems of this kind, the low probability of such situations, and a thousand other reasons.  But a strange error or application crash at a crucial moment may scare the user away forever, and he will no longer return to your product.  We at Yandex constantly keep such questions in mind and strive to optimize the testing process as much as possible using useful ideas.  How we have made such checks easy, visual, <i>automatic</i> will be discussed in this article. <br><a name="habracut"></a><br><h4>  Salt </h4><br>  There are a number of long-known ways to find out how and what is transmitted from service to service - from a mobile application to the server, from one part to another. <br>  The first of the most popular and not requiring serious training - to connect a special program to one of the sources of data transmission or reception.  Such programs are called <a href="http://en.wikipedia.org/wiki/Packet_analyzer">traffic analyzers</a> or, more often, sniffers. <br>  The second is to replace with artificial implementation entirely one of the parties.  In this approach, it is possible to define a clear scenario of behavior in certain cases and save all the information that comes to this service.  This approach is called using stubs ( <a href="http://en.wikipedia.org/wiki/Mock_object">mock objects</a> ).  We will consider both. <br><br><h5>  Using sniffers </h5><br>  A new release or debugging of changes affecting inter-service communication comes.  We are armed with the necessary interceptor programs - <a href="http://www.wireshark.org/">WireShark</a> or <a href="http://en.wikipedia.org/wiki/Tcpdump">Tcpdump</a> .  We launch traffic interception to the necessary node, imposing filters of a host, port and interface.  We do ‚Äúdark deeds‚Äù, initiating the communication we need.  We stop interception.  We begin to disassemble it.  Each service has its own process of parsing, but usually it always resembles convulsive searches in a heap of text of the cherished GET, POST, PUT, etc.  Found?  Then we repeat it from release to release.  This is now a regression test!  Not found?  Repeat this with different combinations of filters to understand the reasons. <br><br><h6>  From release to release? </h6><br>  You can do this manually once.  Or two.  Well, maybe three.  And then just get bored.  And on the fifth release, this communication will take and break.  It is especially difficult to notice this indirectly when communication is a callback call with some kind of notification.  Repetitive from release to release, mechanical actions that take a lot of time and effort should be automated.  How to do it in JAVA?  I am sure that in other languages ‚Äã‚Äãthis can be done in a similar way, but specifically the JUnit4 + Maven bundle works perfectly and works well for testing automation in Yandex. <br><br>  Suppose that we test the service integrationally, which means that most likely it looks like a battle mode when it is raised on a separate machine, and we are connected to it via SSH.  We take the <a href="https://code.google.com/p/ganymed-ssh-2/">library to work on SSH</a> , <a href="">connect to the server</a> , run tcpdump and catch everything we can in the file (everything is exactly like hands).  After the test, we forcefully end the process and look for what is needed in the file, using grep, awk, sed, etc.  Then the resulting process in the test.  Did you do it?  Not?  And do not need! <br><br><h6>  Why not to do so? </h6><br><blockquote>  I want to note that "not necessary" does not mean "it is not possible." </blockquote><br>  You can do it.  Simply, there are ways easier, because: <br><ul><li>  Parsing large lines is always a lot of specific code that is difficult to maintain. </li><li>  Parsing HTTP messages has long been done in hundreds of libraries.  Why do one hundred and first? </li></ul><br>  We tried this method and we are in Yandex.  At first it seemed convenient - all we had to do was start and stop tcpdump via ssh, and then find the necessary substring in its output.  The first problems with support began almost immediately: the order of the query-parameters was random in the required queries.  I had to break the reference line into several and check the occurrence of each.  The error messages were also disappointing in the event that the request was not found - tons of text did not give an adequate way to structure oneself.  Headache added asynchronous requests that could appear in a few minutes after vigorous action.  It was necessary to build dizzying constructions by waiting for the necessary substring in issuance with a certain delay.  The test code sometimes became more complicated than the code we tested.  Then we began to look for another way to test this part. <br><br><h5>  Using stubs instead of web services </h5><br>  Since we are talking about testing, then, most likely, we have all the opportunities not only to put the mesh in the form of a sniffer, but also to replace one of the services entirely.  With this approach, ‚Äúpure‚Äù requests will reach artificial service, and we will be able to control the behavior of the destination for messages.  For such purposes, there is a wonderful library <a href="http://wiremock.org/">WireMock</a> .  Its code can be viewed on <a href="https://github.com/tomakehurst/wiremock">the</a> project's <a href="https://github.com/tomakehurst/wiremock">GitHub page</a> .  The bottom line is that a web service comes up with a good REST-api, which can be configured in almost any way.  This is a JAVA-library, but it has the ability to run as a standalone application, it would be available jre.  And then simple setup with detailed documentation. <br><br>  Here you can find arbitrary response codes, arbitrary content, and transparent redirection of the request to real services with the ability to save responses and send them then yourself.  Of particular note is the ability to recreate negative behavior: timeouts, communication breaks, invalid responses.  Beauty!  The library can also work as a WAR, which can be loaded into Jetty, Tomcat, etc.  And, most importantly, this library can be used directly in tests like JUnit Rule!  She will take care of parsing the request, dividing the body, address, parameters and headers.  We will only have at the right time to get a list of all the visitors and meeting the criteria. <br><br><h4>  Automate checks using the stub </h4><br>  Before proceeding, you need to decide which steps you need to go through to ensure easy, visual, and automatic testing using the second option considered - the mock-object. <br><blockquote>  It is worth noting that each of the stages is also possible to do by hand without much difficulty. </blockquote><br><br><h5>  Scheme </h5><br>  What are we checking?  <code>{}</code> in the schema: <br> <code>_ -&gt; {} -&gt; _.</code> <br> <br>  More precisely, the scheme will look like this: <br> <code>_ -&gt; _ :( ): {}.</code> <br> <br>  So we need to do a few things: <br><ul><li>  Raise the service stub and make it accept certain messages, responding OK (or neOK - depends on the script).  This will do WireMock. </li><li>  Ensure the delivery of messages to the stub service (in the diagram this <code>-&gt;</code> ).  Let's talk about this stage separately. </li><li>  Validate what has come.  There are two options - using WireMock tools for validation, or by receiving a list of requests from it, applying <a href="http://habrahabr.ru/company/yandex/blog/184634/">matchers</a> to them. </li></ul><br><h4>  Raise an artificial web service </h4><br>  How to raise the service manually is described in detail on the wiremock website in the <a href="http://wiremock.org/getting-started.html">Running standalone</a> section.  How to use in JUnit, too, however described.  But we will need this in the future, so I will give a little bit of code. <br><br>  Create a JUnit rule that will raise the service on the correct port at the start of the test and finish after the end: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WireMockRule wiremock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WireMockRule(LOCAL_MOCKED_PORT);</code> </pre> <br><br>  The beginning of the test will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldSend3Callbacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       stubFor(any(urlMatching(".*")).willReturn(aResponse() .withStatus(HttpStatus.OK_200).withBody("OK"))); ...</span></span></code> </pre> <br><br>  Here we set up a raised web service so that it responds to any requested address with code 200 with the ‚ÄúOK‚Äù body.  After some simple configuration steps, there are several options for the development of events.  First - we have no problems with access to any port from the client to the machine on which the test is performed.  In this case, we simply perform the necessary actions within the framework of the test case, then we proceed to validation.  Second, we only have ssh access.  Yet the ports are covered with a firewall.  This is where ssh port forwarding (or ssh-tunneling) comes to the rescue.  This is discussed below. <br><br><h4>  Reduce the road packages </h4><br>  We need REMOTE (which is with the -R key) and, accordingly, ssh access to the typewriter.  This will allow the test service to access its local port, and for us to listen to ours.  And everything will work. <br><br><blockquote>  In a nutshell, ssh port forwarding (or ssh-tunneling) is a pipe thrown through an ssh connection from a port on a remote machine to a port on a local one.  Good instructions for use can be found at <a href="http://www.debianadmin.com/">www.debianadmin.com</a> </blockquote><br><br>  Since we are engaged in the automation of this process, we will consider in detail how to make the use of this mechanism convenient in tests.  Let's start from the top level - the junit-rule interface.  It will allow to connect the <code>__: -&gt; ssh -&gt; ____:_</code> before the start of the test and close the tunnel after its completion. <br><br><h4>  Making a port forwarding junit rule </h4><br>  Remembering the Ganymed SSH2 library.  We connect it using maven: <br><br><pre> <code class="java hljs">&lt;!--https:<span class="hljs-comment"><span class="hljs-comment">//code.google.com/p/ganymed-ssh-2/--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.ethz.ganymed&lt;/groupId&gt; &lt;artifactId&gt;ganymed-ssh2&lt;/artifactId&gt; &lt;version&gt;${last-ganymed-ssh-ver}&lt;/version&gt; &lt;/dependency&gt;</span></span></code> </pre> <br>  (The release version can always be seen in <a href="http://mvnrepository.com/artifact/ch.ethz.ganymed/ganymed-ssh2">Maven Central</a> .) <br><br>  Open <a href="">an example</a> using this library to raise the tunnel via ssh.  We understand that we need four parameters.  We assume that the test "talks" through his local port, so the <code>__</code> equal to <code>127.0.0.1</code> . <br>  There are three parameters that need to be specified: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SshRemotePortForwardingRule forward = onRemoteHost(props().serviceURI()) .whenRemoteUsesPort(BIND_PORT_ON_REMOTE) .forwardToLocal().withForwardToPort(LOCAL_MOCKED_PORT);</code> </pre><br><br>  Here <code>.forwardToLocal()</code> is: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SshRemotePortForwardingRule </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardToLocal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { hostToForward = InetAddress.getLocalHost().getHostAddress(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UnknownHostException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can't get localhost address"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><br>  It is convenient to do the junit rule as an inheritor of the <code>ExternalResource</code> , overriding <code>before()</code> for <a href="">authorization</a> and raising the tunnel, and <code>after()</code> for closing the tunnel and connection. <br><br>  The connection itself should look something like this: <br><br><pre> <code class="java hljs">logger.info(format(<span class="hljs-string"><span class="hljs-string">"Try to create port forwarding: `ssh %s -l %s -f -N -R %s:%s:%s:%s`"</span></span>, connection.getHostname(), SSH_LOGIN, hostOnRemote, portOnRemote, hostToForward, portToForward )); connection.requestRemotePortForwarding(hostOnRemote, portOnRemote, hostToForward, portToForward);</code> </pre><br><br><h4>  Validating </h4><br>  Successfully catching requests with a muffled service, it remains only to check them.  The easiest way is to use the WireMock built-in tools: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      verify(3, postRequestedFor(urlMatching(".*callback.*")) .withRequestBody(matching("^status=.*")));</span></span></code> </pre> <br><br>  A much more flexible way is to simply get a list of the necessary requests, and then, after reaching certain parameters, apply checks to them: <br><br><pre> <code class="java hljs">List&lt;LoggedRequest&gt; all = findAll(allRequests()); assertThat(<span class="hljs-string"><span class="hljs-string">"    1   "</span></span>, all, hasSize(greaterThan(<span class="hljs-number"><span class="hljs-number">0</span></span>))); assertThat(<span class="hljs-string"><span class="hljs-string">"      "</span></span>, all.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getBodyAsString(), containsString(<span class="hljs-string"><span class="hljs-string">"Wow, it's callback!"</span></span>));</code> </pre> <br><br><h4>  How it worked in Yandex </h4><br>  All of the above is a serious general approach.  It can be used in many places, as a whole, and in parts.  Now the use of plugs at the integration level works fine in a number of large projects to replace various functions of services.  For example, we in Yandex have a file download service that records information about files not independently, but through another service.  Began to download the file - sent the request.  Loaded, counted checksums - another request.  We checked the file for viruses, are ready to work with the file further - one more.  Each next stage continues depending on the response to the previous ones, while the number of connections between the services is limited. <br><br>  How to check that requests really go away and contain all the information about the file in the right format?  How to check what will happen if the request was accepted, but there was no response?  First, we check the positive scenario of the development of events - we replace the service writing to the database with an artificial one, accept and analyze the traffic.  (The code examples above are a copy of what is happening in the tests.) The tunnel via ssh was required so that autotests, without superuser privileges, could be tied to a specific port on the local machine, the address of which is always arbitrary, and in the download service you could specify your local address and port on a permanent basis at the point of request. <br><br>  Having successfully tested the positive scenario, it was not difficult for us to add checks <a href="http://wiremock.org/simulating-faults.html">for negative ones</a> .  Simply increasing the response delay time in WireMock to a value greater than the waiting time in the file download service, it turned out to initiate several attempts to send a request. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,      61  //(     1) stubFor(any(urlMatching(".*")).willReturn(aResponse() .withFixedDelay((int) SECONDS.toMillis(61)) .withStatus(HttpStatus.OK_200).withBody("")));</span></span></code> </pre> <br><br>  Having checked that in 120 seconds while waiting for the answer on the service in 60 seconds two requests came, we made sure that the file download service would not hang at the crucial moment. <br><br><pre> <code class="java hljs">waitFor(<span class="hljs-number"><span class="hljs-number">120</span></span>, SECONDS); verify(<span class="hljs-number"><span class="hljs-number">2</span></span>, postRequestedFor(urlMatching(<span class="hljs-string"><span class="hljs-string">".*service/callback.*"</span></span>)) .withRequestBody(matching(<span class="hljs-string"><span class="hljs-string">"^status_xml.*"</span></span>)));</code> </pre> <br><br>  This means that the developers have foreseen such a development of events, and in this place, in such a situation, information about the download will not be exactly lost.  Similarly, a bug was found on one of the services.  He concluded that if the service was not answered immediately, the connection remained open for several hours, until it was forcibly closed by outside monitoring services.  This could lead to the fact that if there were failures in the network, the connection limit could be completely exhausted in a short time and the rest of the customers would have to wait in the queue for several hours.  Good thing we checked it before! <br><br><h4>  What else to say </h4><br>  There are a number of limitations in this approach: <br><ul><li>  Requires ssh access to the machine. </li><li>  Port forwarding must be enabled on this machine. </li><li>  It will be necessary to stop the services if you need to take their port and replace with a stub.  This means that we need the user rights to stop services without a password.  This also applies to ports with numbers up to 1024. </li><li>  In some organizations, it is not possible to forward a port without administrative sanctions. </li></ul><br><h5>  Local Port Forwarding </h5><br>  In addition to the remote, there is also LOCAL (local), with the <code>-L</code> key.  It allows the mirror described above, referring to a port on your local machine, to get to the internal port of the remote machine, hidden behind the firewall.  Such an approach can be an alternative in tests running on ssh on the server being tested and calling curl, wget. <br><br><h5>  Alternatives </h5><br>  In tests, in addition to WireMock, analogs can be interesting: <a href="https://github.com/jadler-mocking/jadler">github.com/jadler-mocking/jadler</a> or <a href="https://github.com/robfletcher/betamax">github.com/robfletcher/betamax</a> . </div><p>Source: <a href="https://habr.com/ru/post/228691/">https://habr.com/ru/post/228691/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228679/index.html">How I tried to take a bike in a public bicycle rental in St. Petersburg. A look from the IT side</a></li>
<li><a href="../228681/index.html">Viruses. Viruses? Viruses! Part 1</a></li>
<li><a href="../228685/index.html">3D pens: original models and Chinese clones. What does the market offer?</a></li>
<li><a href="../228687/index.html">Passing smart pointers over a constant link. Autopsy</a></li>
<li><a href="../228689/index.html">The prohibition of data storage Russians on foreign servers: what will happen after September 1, 2016?</a></li>
<li><a href="../228693/index.html">Yandex does not index images from sites under https</a></li>
<li><a href="../228695/index.html">Work as a game designer</a></li>
<li><a href="../228697/index.html">How I used a 3d scanner to forge a key, holding a skull, a heart and a gun in my hands</a></li>
<li><a href="../228699/index.html">From Moscow to Silicon Valley: how Alexander Kirov improves Pebble smart watches</a></li>
<li><a href="../228703/index.html">Habrachat quit ARM and now on Heroku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>