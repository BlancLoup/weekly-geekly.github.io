<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visual Studio Online: Continuous Integration and Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual Studio Online , like Team Foundation Server 2015, has the capacity to implement a continuous integration process. 

 In this article, we will l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visual Studio Online: Continuous Integration and Testing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d02/ca6/080/d02ca6080f7348c3b9f9571158b84913.jpg"><br><br>  <a href="https://www.visualstudio.com/products/what-is-visual-studio-online-vs">Visual Studio Online</a> , like Team Foundation Server 2015, has the capacity to implement a continuous integration process. <br><br>  In this article, we will look at an example of using Visual Studio Online (VSO) with a Git repository, as well as ways to customize the processes of continuous integration, testing, and automatic deployment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Setting up a Visual Studio Online service is one of the fastest ways to organize and plan the process of building and deploying applications for various platforms.  The service will be deployed within a few minutes and run on our cloud infrastructure without the need for installation or configuration on a separate server. <br><a name="habracut"></a><br><h4>  Using VSO and Git </h4><br><h5>  Creating a project in VSO and initializing a remote Git repository </h5><br>  Create a new project for the team in VSO.  Go to the VSO website, go to the main page and click New: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/156/e50/d50156e503bbabfbccdbb466a72eb531.png"><br><br>  We specify the name and description of the project.  We select the necessary template for the development process. <br>  Here we select Git as a version control system and click the ‚ÄúCreate Project‚Äù button: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41d/0d5/edf/41d0d5edf0367625d1b3c9a539f00506.png"><br><br>  When the project is created, click on the "Navigate to project" button: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c6/4be/dbe/6c64bedbe517358b2a04271e2e5f37d5.png"><br><br>  The main project page for the work of our team will be displayed.  Now you need to initialize the Git repository.  Go to the CODE page and click "Create a ReadMe file".  The repository is initialized and the master branch is created.  For example, I will configure continuous integration on this thread: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56a/757/a81/56a757a81a6d2cfdccb104ada1bc7138.png"><br><br>  In the screenshot we can see the master branch with the README.md file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ff/e44/09c/2ffe4409c1c9f900ded1843c0def852d.png"><br><br><h5>  Opening a project in Visual Studio, cloning a Git repository and creating a solution. </h5><br>  Now open the project for the team in Visual Studio and clone the repository to create a local copy. <br><br>  Go to the main page of the project in VSO and click "Open in Visual Studio": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7e/732/5f1/b7e7325f1542d2039d0e3c2a2a258cdd.png"><br><br>  Visual Studio opens a connection to a VSO project. <br><br>  In the Team Explorer window, enter the address of the local repository and click the ‚ÄúClone‚Äù button: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b69/aa1/c0c/b69aa1c0c2dbf4f9f5a7d18dec038ac3.png"><br><br>  Now click ‚ÄúNew‚Äù to create a new solution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/58c/fbe/91958cfbe5114ad46e9e84699f0f6874.png"><br><br>  Select the ASP.NET Web Application project template, specify the project name and click ‚ÄúOK‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/579/7be/fea/5797befeaa02f561c12bedd9aa2820b9.png"><br><br>  Select the ASP.NET 5 Preview Web Application template and click on ‚ÄúOK‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/1d9/107/1071d9107f55133677e7f4276ad3e6a9.png"><br><br>  Now add a project containing unit tests.  Right-click on the solution in Solution Explorer, select ‚ÄúAdd New Project‚Äù and select the Unit Test Project template.  My project is called CITest.Tests. <br><br>  The solution is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c5/07c/e95/7c507ce953c0981e981b0be4821ba76a.png"><br><br>  The UnitTest1 class was created with the only method TestMethod1.  TestMethod1 will be passed, because it has no implementation. <br><br>  Add the second method TestMethod2, with the expression Assert.Fail.  The second method will not be passed and will just show that the test performer has successfully identified and launched the necessary tests. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.VisualStudio.TestTools.UnitTesting; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">CITest.Tests</span></span> { [TestClass] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UnitTest1</span></span> { [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Assert.Fail(<span class="hljs-string"><span class="hljs-string">"failing a test"</span></span>); } } }</code> </pre> <br>  Save the changes and run the build. <br><br>  Now we need to commit (commit) the solutions to the local repository and send from local to remote.  In order to do this, go to the Changed tab in the Team Explorer window, add a comment to the commit and select the option ‚ÄúCommit and Push‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/027/502/b1a027502495cae3d5eaffc6eba83d0b.png"><br><br>  The master branch of the remote Git repository now contains a solution that includes a web application and a project with tests. <br><br><h5>  Creating a build process definition </h5><br>  Now we will create the build process definition in the VSO. <br><br>  Go to the project ‚ÄúBUILD‚Äù page for the team to work and press the "+" button. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6b/8f2/c16/a6b8f2c167fcbd4c25b6c11f352dd555.png"><br><br>  Select the Visual Studio template and click OK. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41b/5ec/437/41b5ec437e47c1131f13e559e233ef4a.png"><br><br>  The Visual Studio template for defining an assembly contains 4 assembly steps: <br><br><ol><li>  Visual Studio Build - build solutions </li><li>  Visual Studio Test - run tests </li><li>  Index Sources &amp; Publish Symbols - indexing source code and publishing symbols in .pdb files </li><li>  Publish Build Artifacts - publish build artifacts (dlls, pdb, and xml documentation files) </li></ol><br>  Now let's leave everything as it is, by default, click ‚ÄúSave‚Äù and specify the name for the definition being created. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c1/c9c/a50/8c1c9ca50662e90915f607b7b0d98e81.png"><br><br>  To test, click ‚ÄúQueue build‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dca/dc9/e15/dcadc9e15e5d55c9c021ead4390e123e.png"><br><br>  We accept the default settings and click "OK". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db4/043/848/db40438481eb9a98331c25f8cec048c0.png"><br><br>  We fall into the browser assembly process (BUILD-&gt; Explorer).  The assembly enters the queue and, as soon as the process is launched, we will see information about it in the output window: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c53/c85/811/c53c858116c231f537419aaf43e3da03.png"><br><br>  The build failed at the Build Solution step with the following error - The Dnx Runtime package needs to be installed. <br><br>  The reason for this error is that we start the build process on a remote server and we need to set the appropriate DNX environment that our solution will choose to build. <br><br>  Let's go back to Visual Studio and add a new file to our solution.  Let's call Prebuild.ps1 and add the following Powershell script to it: <br><br><pre> <code class="bash hljs">DownloadString(<span class="hljs-string"><span class="hljs-string">'https://raw.githubusercontent.com/aspnet/Home/dev/dnvminstall.ps1'</span></span>))} <span class="hljs-comment"><span class="hljs-comment"># load up the global.json so we can find the DNX version $globalJson = Get-Content -Path $PSScriptRoot\global.json -Raw -ErrorAction Ignore | ConvertFrom-Json -ErrorAction Ignore if($globalJson) { $dnxVersion = $globalJson.sdk.version } else { Write-Warning "Unable to locate global.json to determine using 'latest'" $dnxVersion = "latest" } # install DNX # only installs the default (x86, clr) runtime of the framework. # If you need additional architectures or runtimes you should add additional calls # ex: &amp; $env:USERPROFILE\.dnx\bin\dnvm install $dnxVersion -r coreclr &amp; $env:USERPROFILE\.dnx\bin\dnvm install $dnxVersion -Persistent # run DNU restore on all project.json files in the src folder including 2&gt;1 to redirect stderr to stdout for badly behaved tools Get-ChildItem -Path $PSScriptRoot\src -Filter project.json -Recurse | ForEach-Object { &amp; dnu restore $_.FullName 2&gt;1 }</span></span></code> </pre><br>  The script runs DNVM, determines the version of DNX from the <b>global</b> file <b>.</b>  <b>json</b> our solution, installs DNX and then restores the dependencies of the project contained in the project.json file. <br><br>  After adding the Prebuild.ps1 file, the solution will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/8f9/517/d2c8f9517b9682a8c0bf192f797a5cfc.png"><br><br>  Make commit changes to the local repository and send to the remote. <br><br>  Now you need to add a step with the Powershell script to the assembly definition. <br>  Let's go back to the VSO and edit the build steps.  Click "+" and add a Powershell step. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76e/e45/bfe/76ee45bfedabc5f7b8924fd3c1aa4a13.png"><br><br>  Move the task with the Powershell script to the top of the list of build steps so that it runs first.  Click "Script" and select the file Prebuild.ps1.  Click ‚ÄúSave‚Äù and then ‚ÄúQueue build‚Äù to test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/903/662/ea4/903662ea470471ce3efe5d3177355b72.png"><br><br>  Now all assembly steps are completed successfully: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/0ae/955/b3d0ae955f0db56b9261a4aaf2147006.png"><br><br>  However, if we decide to see the results of the Test step in more detail, we will see a warning - No results found to publish.  But we added 2 methods to the solution. <br><br>  The answer is contained in the following "Executing" expression, which indicates that vstest.console was executed for 2 test files - CITest.Tests.dll, which is good.  And Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll, which is bad. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/9e2/621/c919e2621343fc18dade719e69d34f11.png"><br><br>  You need to change the Test build step to exclude the UnitTestFramework.dll file <br><br>  Edit the build definition, select the Test step and change the Test Assembly path from the current ** \ $ (BuildConfiguration) \ * test * .dll; -: ** \ obj \ ** to the next ** \ $ (BuildConfiguration) \ * tests. dll; -: ** \ obj \ **. <br><br>  Click ‚ÄúSave‚Äù and ‚ÄúQueue Build‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/006/686/42a/00668642af6c6f3e3c20e43c8086c800.png"><br><br>  The build failed.  But this is exactly what we wanted.  TestMethod2 contains the expression Assert.Fail () and therefore we provoked the failure of the Test step, as seen in the screenshot.  We caused this failure to prove that tests run correctly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/28a/cf9/d2028acf95653927b4d06a3fa614164a.png"><br><br><h5>  Configure continuous integration, trigger to build and deploy artifacts </h5><br>  Now in the assembly definition, we have a preliminary step that downloads DNX, then a step that provides a solution build and a Test step that fails, thanks to the TestMethod2 method. <br><br>  Now it's time to configure continuous integration and make changes to the UnitTest1 class.  Then we will commit and send the changes to the repository, which should serve as a trigger to start the build. <br><br>  Edit the assembly definition and go to the Triggers tab.  Select Continuous Integration (CI) and click "Save": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/349/8e2/151/3498e21512ac13412120ec36f191dc12.png"><br><br>  Edit the UnitTest1.cs file in Visual Studio and remove the TestMethod2 method.  Then we commit and send the changes. <br><br>  Let's go back to the VSO and go to the BUILD page.  In the Queued list, we should see the assembly awaiting launch: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd0/73c/d6c/dd073cd6c03b3d72cd4ba949685298c7.png"><br><br>  All steps are successful. <br><br>  DNX was successfully installed on the remote host where the assembly is being made.  The decision has gathered.  All tests are run and passed.  Character files are generated.  Finally, the build artifacts are published. <br><br>  That is, we have a new, tested application build. <br><br><h5>  Deploying build artifacts to a web application server </h5><br>  If we host our web application in Azure, we need to add an Azure Web Application Deployment step to the build process definition and in this case, the build artifacts will be automatically deployed to Azure when the application is successfully built and tested. <br><br>  Alternatively, we can manually download the build artifacts and then copy them to the correct server.  In order to do this, go to the list of completed assemblies and open the necessary one.  Then select the Artifacts tab and click "Download".  The resulting .zip file will contain the necessary files. <br><br><h5>  Tests </h5><br>  So, we have a website.  Let's see how you can test it. <br><br>  In preparation for the launch of assembly definitions, we mean the preparation of an assembly agent.  The <a href="http://aka.ms/vsopreview">link</a> presents the steps to configure the build agent. <br><br>  Create a build process definition and select the Visual Studio template: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce3/eca/e0e/ce3ecae0e5744a1e86050387c503dd3e.jpg"><br><br>  Selecting a Visual Studio template automatically adds the Build Task and Unit Tesk Task.  Now fill in the parameters required for each of the tasks.  Task Build task takes a solution that needs to be built and configuration options.  As mentioned earlier, this solution contains the application code, the code for the unit tests, as well as the automatic Selenium tests that we want to run, as one of the steps to build validation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f52/f72/78d/f52f7278d399e3e25be71fab1d6883fd.jpg"><br><br>  At the end, add the required parameters required for the Unit Test - Test Assembly task and the Test Filter criterion.  Note that in this task we take the dll of unit tests, number all the tests and run them automatically.  You can enable the Test Filter criterion and use the filter by test case type if you need to run specific tests.  Another important point is that the unit tests in Visual Studio Test Task are always run on the server where the build takes place and do not require additional settings for deployment: <br><br><img src="https://habrastorage.org/files/490/997/ad4/490997ad41bf4413b063e81f59a15a7b.jpg"><br><br><h4>  Using Visual Studio Online to manage tests </h4><br><h5>  Configuring virtual machines for application deployment and running tests </h5><br>  Once the build is complete and the unit tests are completed, the next step is to deploy the application (website) and run the functional tests. <br><br>  The following components are necessary for this: <br><br><ol><li>  Ready and configured Windows Server 2012 R2 with IIS installed for web site deployment or Microsoft Azure Website. </li><li>  A set of virtual machines with installed browsers (Chrome, Firefox and IE) to automatically run Selenium tests on these machines. </li></ol><br>  You must ensure that these virtual machines are <a href="https://technet.microsoft.com/en-us/magazine/ff700227.aspx">configured for remote access via Powershell</a> . <br><br>  Once the virtual machines are ready, go to the Test Hub-&gt; Machine page to create the necessary configuration as shown in the screenshot.  Specify the name for the group of virtual machines and the FQDN / IP address of the IIS / Web server of the virtual machine.  It is also necessary to enter the administrator's login and password for future settings: <br><br><img src="https://habrastorage.org/files/fc1/3a4/11f/fc13a411fa1f40828a291bbeb5edb5c7.jpg"><br><br>  For the test environment, specify the name and add all the IP addresses of the machines that have already been configured with the necessary browsers.  As mentioned earlier, the automated test system is able to perform all tests on a distributed basis and can scale to a different number of virtual machines. <br><br>  As a result, in the virtual machine hub there will be one application in the test environment and the test environment itself, for example, in this example it is ‚ÄúApplication Under Test‚Äù and ‚ÄúTest Machines‚Äù, respectively. <br><br><h5>  Application Deployment and Testing Settings </h5><br>  Now we will add a task for deploying the application to a web server and a task for remotely running integration tests on virtual machines. <br><br>  We will use the same build definition, simply adding new steps to implement continuous deployment. <br><br><h5>  Deploy a web site using Powershell </h5><br>  To begin, copy all the files of the website in the right place.  Click ‚ÄúAdd build step‚Äù, add the task ‚ÄúWindows Machine File Copy‚Äù and fill in the parameters for copying files.  Now add ‚ÄúRun Powershell on Target Machine Tasks‚Äù to the definition for deploying / configuring the application environment.  To deploy a web application on a web server, select ‚ÄúApplication under Test‚Äù as a group of virtual machines, we configured them earlier.  Select the Powershell task to deploy the website.  Make sure that this script is included in the solution / project.  This task will execute a Powershell script on a remote machine to configure the website and other additional steps: <br><br><img src="https://habrastorage.org/files/134/575/3c8/1345753c876f4856b74571bd79d5f741.jpg"><br><br><img src="https://habrastorage.org/files/ad9/6bc/98d/ad96bc98d47c4915b9be7a31c9bb0765.jpg"><br><br><h5>  Copying tests to the test environment </h5><br><br>  Add the ‚ÄúCopy Files‚Äù task to the assembly definition for copying all test files to the ‚ÄúTest Machines‚Äù group. <br><br>  You can choose any location, the example uses ‚ÄúC: \ Tests‚Äù <br><img src="https://habrastorage.org/files/68f/5d4/8a3/68f5d48a340a40f69b2ad6732ff2a9c1.jpg"><br><br><h5>  Configuring Visual Studio Test Agent </h5><br>  To perform actions on remote machines, first you need to create and configure a test agent.  To do this, create a task in which we will write information about the remote machines. <br><br>  Unlike previous versions of Visual Studio, there is no need to manually copy and configure the controller and test agents on the test environment machines: <br><img src="https://habrastorage.org/files/ae1/015/852/ae101585296e4c1ab2f864bb39484ae7.jpg"><br><br><h5>  Running tests on remote virtual machines </h5><br>  When the setup is complete, the last task will need to add ‚ÄúRun Visual Studio Tests using Test Agent‚Äù to run the tests.  In this task, we specify the information of the Test Assembly and a filter for running the tests.  As part of the build verification, we want to run P0 Selenium tests, so you need to filter the builds using SeleniumTests * .dll as a test build. <br><br>  We can include the runsettings file with tests and any test run parameters as input.  Below we specify for tests data on where the application was deployed using the variable $ (addurl): <br><br><img src="https://habrastorage.org/files/a49/feb/537/a49feb53706f48e48fbdc2aa4850fb9f.jpg"><br><br>  Once the tasks are added and configured, you must save the build process definition. <br><br><h5>  Placing the assembly in a queue, running tests and analyzing test results. </h5><br><br>  Now that the set of all tasks is ready in the build process definition, you can run it by placing the assembly in a queue.  Before doing this, you need to make sure that the build server and the pool of test machines are configured correctly. <br><br>  Once the build is complete, VSO provides an overview of the build results with all the necessary information for later decision making. <br><br>  The build results contain the following information: <br><br><ul><li>  The results of the steps and the selection of their color in the left side of the panel, as well as details in the right. </li><li>  By clicking on each step, detailed log entries are available. </li><li>  From the test results, you can see that all the unit tests have been passed, but there are problems with integration tests. </li></ul><br><img src="https://habrastorage.org/files/44a/b4b/15e/44ab4b15ee1d4bb3824e0fec960a8641.jpg"><br><br>  Clicking on "Test Results" allows you to go to the results of running tests. <br><br>  The Test Run page contains a set of graphs and mechanisms for more in-depth study of the results: <br><br><img src="https://habrastorage.org/files/af4/8e6/01f/af48e601f26a4930adb2290a19791902.jpg"><br><br>  When you go to Test Results, you can also see the information for each test - the name of the test, the test parameters, the author, the virtual machine where it was run, etc. <br><br>  For each test not passed, the option ‚ÄúUpdate Analysis‚Äù is available for its analysis.  The following screenshot shows that IE Selenium tests failed.  If you click "Create Bug", then all the information on the test will automatically be added to the created element: <br><br><img src="https://habrastorage.org/files/9aa/0e2/12e/9aa0e212ec7c4d7684a363209e4e55a6.jpg"><br><br><h5>  Settings for continuous integration </h5><br>  Now that all tests have been studied and defects are registered, you can configure the build process definition to automatically start the continuous integration process, unit tests and integration tests for each check-in. <br><br>  There are two ways to configure: <br><br><ul><li>  Select ‚ÄúContinuous Integration‚Äù to run the process for each check. </li><li>  Select a special launch on a schedule to check after making all changes. </li></ul><br>  You can choose both options, as shown in the screenshot: <br><br><img src="https://habrastorage.org/files/539/3b8/b16/5393b8b16dac41dabe4a4aa7a3c87fee.jpg"><br><br>  Thus, using a similar definition of the build process, we were able to configure the continuous integration process to automatically start the build, then run the unit tests and validate the build. <br><br><h4>  Conclusion </h4><br>  Finally, using Visual Studio Online we managed to solve several problems: <br><br><ol><li>  Creating a simple build process definition that includes unit testing and automated tests </li><li>  Set up a test environment and test agents </li><li>  Received a report on the results of the assembly and run tests </li><li>  Customized build process using continuous integration approach </li></ol><br><h4>  useful links </h4><br><ul><li>  Video materials: <a href="http://channel9.msdn.com/Series/ConnectOn-Demand/234">continuous integration</a> and <a href="">DevOps using Visual Studio</a> </li><li>  Visual Studio Online: <a href="https://www.visualstudio.com/products/what-is-visual-studio-online-vs">official website and documentation</a> </li><li>  Visual Studio 2015: <a href="https://www.visualstudio.com/ru-ru/products/free-developer-offers-vs.aspx">free offers for developers</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/270229/">https://habr.com/ru/post/270229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270217/index.html">Google Play Services Research: Place Picker & Autocomplete</a></li>
<li><a href="../270219/index.html">Unity Cloud Build or how to build an iOS build on Windows</a></li>
<li><a href="../270223/index.html">Download and convert video to Rutube: from crutches to meta-programming</a></li>
<li><a href="../270225/index.html">Double cycle KCS. Just about knowledge management.</a></li>
<li><a href="../270227/index.html">Translation: how gitLab uses unicorn and unicorn-worker-killer</a></li>
<li><a href="../270231/index.html">How the second chip allows hackers to bypass the verification process of a bank card</a></li>
<li><a href="../270233/index.html">About Parboiled</a></li>
<li><a href="../270235/index.html">Programmer's resume: how to make it convenient?</a></li>
<li><a href="../270237/index.html">CONVERT web analytics and internet marketing conference: preliminary program</a></li>
<li><a href="../270241/index.html">Index-based programming or why do we need all these if, switch, ternary operator?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>