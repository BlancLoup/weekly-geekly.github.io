<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unreal Engine Tutorial: Cel Shading</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Thanks to the physically accurate rendering in Unreal Engine 4, it is convenient to develop realistic games. The rendering model imitates the interact...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unreal Engine Tutorial: Cel Shading</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a87/7ab/a0ea877ab7924d731ea278ef313205ff.png" alt="image"></div><br>  Thanks to the physically accurate rendering in Unreal Engine 4, it is convenient to develop realistic games.  The rendering model imitates the interaction of light with materials, which leads to the creation of a realistic image.  However, if you want to develop a game with a stylized look, then you will have to explore other techniques. <br><br>  One way to create styling is to use <em>cel shading</em> (also known as toon shading).  This technique emulates the shading commonly used in cartoons and anime.  Examples of its use can be seen in games such as <i>Jet Set Radio</i> , <i>The Legend of Zelda: The Wind Waker</i> and <i>Gravity Rush</i> . <br><br>  In this tutorial you will learn the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Create and use post processing material </li><li>  Create cel shader </li><li>  Isolate cel shader for individual meshes </li><li>  Manage color bars with lookup tables. </li></ul><a name="habracut"></a><br><blockquote>  <em>Note:</em> This tutorial assumes that you are already familiar with the basics of the Unreal Engine.  If you are new to the Unreal Engine, then you should study first the tutorial of ten parts of the <a href="https://habrahabr.ru/post/344394/">Unreal Engine for beginners</a> . </blockquote><br><h2>  Getting Started </h2><br>  Download the <a href="">project blank</a> and unpack it.  Navigate to the project folder and open <em>CelShader.uproject</em> .  You will see the following scene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/d17/d35/29bd17d359b6eccf2f1a4622247cb12f.jpg"></div><br>  This is a character to which we will apply cel shading.  Before you begin, you need to figure out what is cel shading. <br><br><h2>  What is Cel Shading? </h2><br>  Cel shading is a rendering process using multiple bands of color, rather than a continuous gradient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01a/00e/219/01a00e219b6931b86f39e280e3c0a310.jpg"></div><br>  Below is an example of using cel shading in <i>The Legend of Zelda: Breath of the Wild</i> .  Note that cel shading is implemented only for the character, and the background remains normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/af6/f06/c0daf6f06fcb371c8790178f6828bbc9.jpg"></div><br>  There are three bands in this image: one for the shadows, one for the mid-tones, and one for the light areas. <br><br>  It is often mistakenly thought that cel shading is applied if objects have <em>contours</em> .  An example of this is the <i>Borderlands</i> .  Although this game has a stylized look, in fact there is <em>no</em> cel shading.  This can be seen in the image below.  Note that the color of the character does not use color bars. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/c21/33f/9aac2133f13ceebe2c63a5957c46bc3d.jpg"></div><br>  Contours are not cel shading, but they are often shared.  Thanks to this, the picture becomes similar to painted with ink or ink.  This technique is often used in anime styling games such as <i>Guilty Gear Xrd</i> and <i>Dragon Ball FighterZ</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef0/717/f5f/ef0717f5fb2625ac59b591048ddaaef6.jpg"></div><br>  In the next section, we will learn how to implement cel shading. <br><br><h2>  Method of implementing Cel Shading </h2><br>  The most common method of implementation is to compare the direction of the surface (known as ‚Äúnormal‚Äù) and the direction of light.  By calculating the <em>scalar product</em> between the normal and the direction of light, we obtain a value from -1 to 1. <br><br>  A value of -1 means that the surface and light have opposite directions.  0 means they are perpendicular.  1 means they are directed in the same way. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/416/001/38c416001c9f7596785e6d86b4a677b8.jpg"></div><br>  By setting threshold values ‚Äã‚Äãfor scalar products, you can create multiple bands.  For example, if the dot product is greater than -0.8, then the surface can be assigned a dark color, and if the dot product is less than -0.8, then the light color.  So we will create a two-way cel-shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b47/0a7/dc0/b470a7dc09d87890addf2a40639d37ba.jpg"></div><br>  The limitation of this method is that objects with cel-shading cannot be affected by other sources of illumination.  In addition, objects cannot cast shadows on objects with cel-shading. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc1/768/993/cc17689933d595c0146fa673d9f91654.gif"></div></div></div><br>  To solve this problem, we must use another method.  Instead of calculating the dot product, we will calculate the surface illumination.  Then, when setting the threshold values, you can use this value instead of the dot product. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/c0e/0f5/987c0e0f51bcbc52f600489b878af2da.gif"></div></div></div><br>  Now that you know what a cel shader is and how it works, it's time to create it. <br><br><h2>  Create Cel Shader </h2><br>  In this tutorial, cel shading will be a post-processing effect.  Post processing allows you to change the image after the engine has finished rendering it.  Post-processing is commonly used for effects such as depth of field, motion blur and bloom. <br><br>  To create our own post-processing effect, we need to use the <em>post process material</em> .  Go to the <em>Materials</em> folder and create a new <em>Material</em> .  Rename it to <em>PP_CelShader</em> and open it. <br><br>  To convert a material into a post-processing material, you need to change its <em>domain</em> .  Go to the Details panel and change the <em>Material Domain</em> to <em>Post Process</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/725/ed4/b5a725ed48bec48afaea990bfd9f6b1d.jpg"></div><br>  The first step in creating a cel shader is to calculate the illumination of each pixel.  We will call this the <em>lighting buffer</em> . <br><br><h3>  Light Buffer Calculation </h3><br>  When Unreal renders an image to the screen, it saves passes to the buffers.  To calculate the lighting buffer, we will need to access two such buffers: <br><br><ol><li>  <em>Post Process Input:</em> After Unreal has done the lighting and post-processing, it saves the image to this buffer.  It is his Unreal will be displayed to the player, if you do not perform further post-processing. </li><li>  <em>Diffuse Color:</em> This is a scene without any lighting and post-processing.  It will contain the diffuse color of everything on the screen. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afc/ec7/9dc/afcec79dc9a895d6a44e3b3d9d4e7cd8.jpg"></div><br>  To access these buffers you need to use the <em>SceneTexture</em> node.  Create it, select it and go to the Details panel.  To access the Post Process Input buffer, change the <em>Scene Texture Id</em> to <em>PostProcessInput0</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/b52/6bd/baab526bd9ea0fe4b09735819d1bdfe2.jpg"></div><br>  To access Diffuse Color, create another <em>SceneTexture</em> node.  Change its <em>Scene Texture Id</em> to <em>DiffuseColor</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/746/4d8/cff/7464d8cff556bea1a2c8b42d647d4b52.jpg"></div><br>  The illumination buffer should contain only values ‚Äã‚Äãin grayscale (describing the degree of illumination of pixels).  This means that we do not need color information from both buffers.  To discard the colors, connect the <em>Color</em> output of both <em>SceneTexture</em> nodes to the <em>Desaturation</em> .  This will completely discolor both buffers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/597/61f/ba2/59761fba2f9ef713939ea2b42d452a0a.jpg"></div><br>  To calculate the light buffer, simply divide <em>SceneTexture: PostProcessInput0</em> into <em>SceneTexture: DiffuseColor</em> .  Order is important here! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d63/6ab/bf2d636abf066110b521601ada9d5ff1.jpg"></div><br>  Then use <em>Clamp</em> to keep the values ‚Äã‚Äãin the range from 0 to 1. This will simplify the creation of thresholds, because we will know the possible values. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ae/e62/7ca/3aee627caee8056d8a4ee6b6cc362eaa.jpg"></div><br>  Here is the visualization of the lighting buffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/039/1c9/4440391c9ac1dd85307d8bdf8a044a96.jpg"></div><br>  As you can see, the illuminated areas are closer to white, and the unlit areas are closer to black. <br><br>  Then we use the light buffer to create the threshold. <br><br><h3>  Create threshold </h3><br>  In our cel shader, any pixel with a value greater than 0.5 will use a normal diffuse color.  Pixels with values ‚Äã‚Äãless than 0.5 will use a half-brightness diffuse color. <br><br>  First, create an <em>If</em> node.  He will allow us to compare two values.  Depending on the results of the comparison, we will be able to specify different outputs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/026/31d/b1e/02631db1e629c852e4826f881e6b637e.jpg"></div><br>  Next, connect the <em>Clamp</em> to the input <em>A.</em>  Then create a <em>Constant</em> with a value of <em>0.5</em> and connect it to the input <em>B.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/a6f/cd5/bfba6fcd5e3d77afa80cb79ffce1cdad.jpg"></div><br><blockquote>  <em>Note:</em> to change the threshold, you can change the value of input B. </blockquote><br>  To get the colors, create a <em>SceneTexture</em> and set its <em>Scene Texture Id</em> to <em>Diffuse Color</em> .  Then multiply the <em>Color</em> by <em>0.5</em> to get a diffuse color of half brightness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ea/c0d/9dd/1eac0d9dd79faaa1a2cc205ebf49d3d6.jpg"></div><br>  And finally, let's connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e24/89f/679/e2489f6791edb99cb5e1d95d2d861a7d.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Desaturation</em> converts <em>Post Process Input</em> and <em>Diffuse Color</em> to grayscale images. </li><li>  <em>Divide</em> divides <em>Post Process Input</em> to <em>Diffuse Color</em> .  So we create a lighting buffer. </li><li>  <em>Clamp</em> limits the values ‚Äã‚Äãfrom 0 to 1 </li><li>  <em>If</em> displays the normal diffuse color if the light value is greater than <em>0.5</em> .  If it is less than <em>0.5</em> , then it displays a diffuse color of half brightness. </li></ol><br>  Now that we have a cel shader, we need to apply it to the scene. <br><br><h2>  Use of post processing materials </h2><br>  To use post-processing materials, we need to create a <em>Post Process Volume</em> .  It is commonly used to control post-processing effects such as white balance, saturation, and contrast. <br><br>  Click on <em>Apply</em> and return to the main editor.  To create a Post Process Volume, go to the Modes panel and select the category <em>Volumes</em> .  Then drag <em>Post Process Volume</em> to Viewport to create it. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3db/873/6c9/3db8736c9315d45047f99ce801f9cca2.gif"></div></div></div><br>  Now we need to tell Post Process Volume to use the cel shader.  After selecting Post Process Volume, go to the Details panel.  Then find the <em>Rendering Features \ Post Process Materials</em> and click on the <em>+</em> icon.  This will add a new element to the array. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5bd/5a5/46f/5bd5a546f2a32a39746d286b887cacb6.jpg"></div><br>  Then click on the <em>Choose</em> drop-down list and select <em>Asset Reference</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/35a/3c3/14635a3c3eb6cf284e7407e490001826.jpg"></div><br>  This will allow you to choose a material.  Click on the <em>None</em> drop-down list and select <em>PP_CelShader</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/bc3/1f8/05abc31f8d6be01ad4ca6be1f8595609.jpg"></div><br>  By default, the Post Process Volume only affects when we are inside.  However, in our case, it is necessary that it affect the whole world.  To do this, scroll to <em>Post Process Volume Settings</em> and turn on <em>Infinite Extent (Unbound)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03a/10f/f76/03a10ff76bba5e16745746770d9dcdf5.jpg"></div><br>  Now that the cel shader is applied to the whole game, we will see the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32b/fbd/a96/32bfbda96555f91012543ce9e9925f90.jpg"></div><br>  "Wait a minute, it doesn't look like the cel shader that you showed before!" <br><br>  The main reason for this difference is that the engine uses a cel-shader <em>after</em> tone mapping.  To fix this, we need to ask the engine to use a cel-shader <em>before</em> tone mapping. <br><br><h2>  Cel Shading before tone mapping </h2><br>  Before showing the image to the player, Unreal performs a process known as ‚Äútonemapping‚Äù.  One of the goals of tonal compression is to make the image more natural.  It takes the input color and then uses the curve to shift it to a new value. <br><br>  Here are two images, before and after tone mapping: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a90/9e2/8a7/a909e28a7150c161d060eca64ce94571.jpg"></div><br>  As you can see, the light areas before tone mapping are too bright.  However, after tonal compression, bright areas become softer. <br><br>  Although tone mapping is useful for images that need to be displayed, we <em>do not have</em> to perform tone mapping for images that we want to use in calculations.  Because of the offset values, we will not use the values ‚Äã‚Äãthat we expect. <br><br>  Open <em>PP_CelShader</em> and make sure nothing is selected.  Then go to the panel and find the <em>Post Process Material</em> section.  Set the <em>Blendable Location</em> to <em>Before Tonemapping</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dc/f47/9d0/9dcf479d04004477714ec0bc47dcdcfe.jpg"></div><br>  Click on <em>Apply</em> , and then return to the main editor.  The colors now look much better! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/d51/e24/53dd51e2411e2c6ca9562a18c03ceec5.jpg"></div><br>  In the next section, we will learn how to apply cel shading only to individual objects. <br><br><h2>  Isolating the Cel Shader </h2><br>  To isolate the effects of post-processing, we need to use a function called <em>Custom Depth</em> .  Like Post Process Input with Diffuse Color, this is also a buffer that can be used in post-processing materials. <br><br>  Before you understand what Custom Depth is, you need to deal with the <em>Scene Depth</em> buffer.  Scene Depth keeps the distance of each pixel from the camera.  Here's what the Scene Depth visualization looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03e/448/865/03e448865dfd4d4429d9ae7f95123e79.jpg"></div><br>  Custom Depth stores the same information, but only for the meshes you select.  Here is his visualization with a Viking rendered to Custom Depth: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8a/f51/04c/e8af5104c32fa60144c7affbe7ad57c3.jpg"></div><br>  By comparing Scene Depth with Custom Depth, we can isolate objects.  If Scene Depth is smaller than Custom Depth, then we use a regular image.  If Scene Depth is larger than Custom Depth, then an image with cel shading is used. <br><br>  The first step is to render the viking to Custom Depth. <br><br><h3>  Using Custom Depth </h3><br>  Go to World Outliner and select <em>SK_Viking</em> .  Then go to the Details panel and find the <em>Rendering</em> section.  Then turn on the <em>Render CustomDepth Pass</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/f70/9c3/d33f709c38bb55047d1083b61c509786.jpg"></div><br>  Next we need to perform a depth comparison.  Open <em>PP_CelShader</em> and create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/769/1be/0c17691beef9261b04d721490bdbe2ef.jpg"></div><br><blockquote>  <em>Note:</em> <em>Mask (R)</em> nodes are Component Masks.  They allow you to convert multi-channel data to scalar values.  We need to put a mask on Scene Depth and Custom Depth because the <em>If</em> node for inputs <em>A</em> and <em>B</em> takes only scalar values. </blockquote><br>  Then connect the output of the cel shading network to <em>A&gt; B.</em>  Finally, connect the output of the newly created <em>If</em> to the <em>Emissive Color</em> . <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/71b/9ca/4e2/71b9ca4e2d7b512e5b71b7f2bad39165.jpg"></a> </div><br>  Now cel shading will only be applied to meshes rendered in Custom Depth. <br><br>  Click on <em>Apply</em> , and then return to the main editor.  You will see that cel shading is now performed only for the viking. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/154/470/6fa15447027273e99deda3f178629bd7.jpg"></div><br>  The Cel Shader works great, but it‚Äôs pretty simple.  What if we need more lanes?  What if we want to create smoother transitions between lanes?  All this can be done using <em>lookup tables</em> (LUT). <br><br><h2>  What is a ‚Äúlookup table‚Äù? </h2><br>  In childhood we learned what multiplication is.  However, the young brain could not always perform such calculations.  Therefore, instead of calculations, you could use the multiplication table to ‚Äúsearch‚Äù for answers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d0/abf/79c/2d0abf79cf91f616596c8939d14acff9.jpg"></div><br>  In essence, this is LUT.  This is an array of values ‚Äã‚Äã(usually precomputed) that can be accessed using input data.  In the case of a multiplication table, the input data was a multiplier and a multiplicand. <br><br>  In the context of our cel-shader, LUT is a texture with some kind of gradient.  Here are four examples of what LUT might look like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/654/95f/365/65495f3659bb091f72a5c27c5dd720df.jpg"></div><br>  For now, we calculate the color of the shadow by multiplying the diffuse color by 0.5.  Instead of multiplying by the constant 0.5, we will use the value from the LUT.  Due to this we can manage the number of lanes and their transitions.  To understand how shading will look, you can by the appearance of the LUT. <br><br>  Before using LUT, you need to change some of its texture parameters. <br><br><h3>  Change LUT Parameters </h3><br>  Go to the <em>Textures</em> folder and open <em>T_Lut_01</em> .  This is what LUT looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8d/bd9/f04/f8dbd9f046e55a6959fba0273a5b327c.jpg"></div><br>  The first parameter we need to change is <em>sRGB</em> .  When rendering, Unreal converts all textures with sRGB on to a linear color.  This makes it easier for the engine to perform rendering calculations. <br><br>  The sRGB parameter is useful for textures that describe appearance.  However, textures like normal maps and LUTs contain data for mathematical calculations.  Therefore, Unreal should consider their values ‚Äã‚Äãalready true.  If you disable sRGB, Unreal <em>will not</em> convert to a linear color. <br><br>  To do this, <em>uncheck</em> <em>sRGB</em> .  This parameter is located in the <em>Texture</em> section. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/b49/840/77cb49840019989c4349f19109b4aace.jpg"></div><br>  The next parameter we need to change is the texture <em>tiling</em> method.  Since we will not display this texture, she does not need tiling.  Moreover, if you leave the tiling enabled, it will add problems when sampling at the edges of the texture.  For example, if we sample a pixel from the left edge, then because of the tiling, it will try to blend with the right edge. <br><br>  To disable tiling, change the value of the <em>X-axis Tiling Method</em> to <em>Clamp</em> .  Do the same for the <em>Y-axis Tiling Method</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/540/52c/85354052cadca3bc9930ed6761081c3b.jpg"></div><br>  And on this we are done with the parameters.  Now we need to use LUT in the postprocessing material. <br><br><h3>  Using LUT </h3><br>  Close <em>T_Lut_01</em> and open <em>PP_CelShader</em> .  First, delete the selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/015/69d/27d/01569d27dccb0843ca47a272f05d9981.jpg"></div><br>  Then create a <em>Texture Sample</em> and change its <em>Texture</em> to <em>T_Lut_01</em> .  This LUT table will create three bands with a smooth transition. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b97/198/291/b971982912865ab7d0975add21e269b3.jpg"></div><br>  As we remember, LUTs use input data to determine the values ‚Äã‚Äãto be output.  In our case, the light buffer will be used as input. <br><br>  To do this, connect the <em>Clamp</em> to the <em>UVs</em> in the <em>Texture Sample</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/cf1/7f9/181cf17f983512c304a8d73fd20e1128.jpg"></div><br>  This works because the lighting buffer values ‚Äã‚Äãand texture coordinates are between 0 and 1. For example, if a pixel from the lighting buffer is 0.5, then the LUT will output the pixel value from the middle of the texture. <br><br>  Next we need to multiply the diffuse color by LUT.  To do this, recreate the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/810/e44/03b/810e4403bc9ebe19faf6c2425af6b813.jpg"></div><br>  We use <em>Append</em> to convert <em>Texture Sample‚Äôs</em> output to a four-channel vector.  We need this because we cannot multiply a three-channel vector by a four-channel ( <em>SceneTexture</em> ). <br><br>  Finally, connect everything as follows: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/069/da2/87b/069da287b3916e85d91bb005445abd94.jpg"></a> </div><br>  Now, instead of multiplying the diffuse color by a constant, we multiply it by the value from the LUT.  So we control the number of color bars and their transitions (depending on LUT).  The output value of the LUT is determined by the light buffer. <br><br>  Click <em>Apply</em> , and then close <em>PP_CelShader</em> .  Now shading will have three lanes with smoother transitions between lanes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/098/04c/5e609804c97fb23fdee43fc47ba065c2.jpg"></div><br>  Below is a comparison of how different LUTs may look.  These LUTs are also added to the project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca0/656/76f/ca065676f44d9105b818a2b3792fa6c9.jpg"></div><br><h2>  Where to go next? </h2><br>  The finished project can be downloaded <a href="">from here</a> . <br><br>  As you can see, post-processing materials are a very powerful tool.  They allow you to create many realistic and stylized effects.  If you want to learn more about the post-processing, then study the <a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/index.html">documentation for the post-processing UE</a> . </div><p>Source: <a href="https://habr.com/ru/post/350172/">https://habr.com/ru/post/350172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350162/index.html">Event digest for HR-specialists in IT for March 2018</a></li>
<li><a href="../350164/index.html">TOP-10: analysis of the best reports of HolyJS 2017 Moscow</a></li>
<li><a href="../350166/index.html">Using CSS Grid to Design User Interfaces</a></li>
<li><a href="../350168/index.html">Communication in space: how it works</a></li>
<li><a href="../350170/index.html">System Architect: First After God</a></li>
<li><a href="../350174/index.html">Collaboration Visual Studio Code and Anaconda</a></li>
<li><a href="../350176/index.html">Who needs an architect?</a></li>
<li><a href="../350178/index.html">The obvious benefit: how and why to use the service approach beyond IT (Part 3)</a></li>
<li><a href="../350180/index.html">The Internet of Things: From Designing a Backend to Energy Absorption</a></li>
<li><a href="../350182/index.html">Experience of using the Puniverse Quasar library for actors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>