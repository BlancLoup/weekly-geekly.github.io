<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Puns typing functions in C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C has a reputation for inflexible language. But you know that you can change the order of the function arguments in C if you don‚Äôt like it? 


#includ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Puns typing functions in C</h1><div class="post__text post__text-html js-mediator-article"><p>  C has a reputation for inflexible language.  But you know that you can change the order of the function arguments in C if you don‚Äôt like it? </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; #include &lt;stdio.h&gt; double DoubleToTheInt(double base, int power) { return pow(base, power); } int main() { //          double (*IntPowerOfDouble)(int, double) = (double (*)(int, double))&amp;DoubleToTheInt; printf("(0.99)^100: %lf \n", DoubleToTheInt(0.99, 100)); printf("(0.99)^100: %lf \n", IntPowerOfDouble(100, 0.99)); }</span></span></span></span></code> </pre> <br><p>  This code never actually defines the <code>IntPowerOfDouble</code> function - because the <code>IntPowerOfDouble</code> function <code>IntPowerOfDouble</code> not exist.  This is a variable that points to <code>DoubleToTheInt</code> , but with a type that says he wants an <code>int</code> argument to go in front of a <code>double</code> argument. </p><br><p>  You might expect <code>IntPowerOfDouble</code> take the arguments in the same order as <code>DoubleToTheInt</code> , but lead the arguments to other types, or something like that.  But this is not what is happening. </p><br><p>  Try it - you will see the same result in both lines. </p><br><pre> <code class="hljs kotlin"><span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; clang something.c <span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> (<span class="hljs-number"><span class="hljs-number">0.99</span></span>)^<span class="hljs-number"><span class="hljs-number">100</span></span>: <span class="hljs-number"><span class="hljs-number">0.366032</span></span> (<span class="hljs-number"><span class="hljs-number">0.99</span></span>)^<span class="hljs-number"><span class="hljs-number">100</span></span>: <span class="hljs-number"><span class="hljs-number">0.366032</span></span></code> </pre> <a name="habracut"></a><br><p>  Now try changing all <code>int</code> to <code>float</code> - you will see that <code>FloatPowerOfDouble</code> does something even <code>FloatPowerOfDouble</code> .  Yes, </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoubleToTheFloat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> power)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(base, power); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> (*FloatPowerOfDouble)(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>))&amp;DoubleToTheFloat; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"(0.99)^100: %lf \n"</span></span>, DoubleToTheFloat(<span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// OK printf("(0.99)^100: %lf \n", FloatPowerOfDouble(100, 0.99)); // ... }</span></span></code> </pre> <br><p>  gives: </p><br><pre> <code class="hljs css">(0<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>)^100: 0<span class="hljs-selector-class"><span class="hljs-selector-class">.366032</span></span> (0<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>)^100: 0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span></code> </pre> <br><p>  The value in the second line is ‚Äúnot even erroneous‚Äù - if the problem were in the rearrangement of the arguments, we would expect the answer to be 100 ^ 0.99 = 95.5 and not 0. What happens? </p><br><p>  The code examples above represent type punning of functions ‚Äî a dangerous form of "assembler without assembler" that should never be used at work, alongside heavy machinery, or in combination with prescription drugs.  These examples are absolutely logical for those who understand the code at the assembly level - but, most likely, it will confuse everyone else. </p><br><p>  I was a little cheating - suggested that you run the code on a 64-bit x86 computer.  On another architecture, this focus may not work.  Although it is believed that C has an infinite number of dark corners, the behavior with int and double arguments is not exactly part of the C standard. This is the result of how functions are called on modern x86 machines, and can be used for elegant programmer tricks. </p><br><h1>  This is not my signature </h1><br><p>  If you studied C at university, you may remember that the arguments are passed to functions on the stack.  The caller puts the arguments on the stack in reverse order, and the function reads the arguments from the stack. </p><br><p>  At least, they explained it to me like this, but most computers today pass the first few arguments directly to the CPU registers.  Thus, functions will not need to be read from the stack, which is much slower than registers. </p><br><p>  The number and location of registers used for function arguments depends on the calling convention.  Windows has one <a href="https://msdn.microsoft.com/en-us/library/ms235286.aspx">convention</a> ‚Äî four registers for floating point values ‚Äã‚Äãand four registers for pointers and integers.  Unix has another convention called <a href="http://www.x86-64.org/documentation/abi.pdf">System V</a> convention.  It uses eight registers for floating-point arguments and six more for pointers and integers.  (If the arguments are not registered in the registers, then they are sent to the stack according to the old one.) </p><br><p>  In C, header files exist only to tell the compiler where to put the function arguments, often combining registers and stack.  Each calling convention has its own algorithm for placing these arguments in registers and on the stack.  Unix, for example, is very aggressive about breaking structures and attempting to fit all fields in registers, while Windows is a bit lazier and simply passes a pointer to a large parameter structure. </p><br><p>  But in both Windows and Unix, the basic algorithm works like this: </p><br><ul><li>  The floating-point arguments are arranged, in order, in the SSE registers, denoted XMM0, XMM1, etc. </li><li>  Integers and pointers are arranged, in order, in general-purpose registers, labeled RDX, RCX, etc. </li></ul><br><p>  Let's see how the arguments to the <code>DoubleToTheInt</code> function are <code>DoubleToTheInt</code> . </p><br><p>  The signature of the function is as follows: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoubleToTheInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> power)</span></span></span></span>;</code> </pre> <br><p>  When the compiler encounters <code>DoubleToTheInt(0.99, 100)</code> , it registers as follows: </p><br><table><thead><tr><th>  Rdx </th><th>  RCX </th><th>  R8 </th><th>  R9 </th></tr></thead><tbody><tr><td>  100 </td><td>  ??? </td><td>  ??? </td><td>  ??? </td></tr><tr><td>  <strong>XMM0</strong> </td><td>  <strong>Xmm1</strong> </td><td>  <strong>Xmm2</strong> </td><td>  <strong>Xmm3</strong> </td></tr><tr><td>  0.99 </td><td>  ??? </td><td>  ??? </td><td>  ??? </td></tr></tbody></table><br><p>  (For simplicity, I use the Windows calling convention.) If in return there was such a function: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoubleToTheDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> power)</span></span></span></span>;</code> </pre> <br><p>  Arguments would be arranged like this: </p><br><table><thead><tr><th>  Rdx </th><th>  RCX </th><th>  R8 </th><th>  R9 </th></tr></thead><tbody><tr><td>  ??? </td><td>  ??? </td><td>  ??? </td><td>  ??? </td></tr><tr><td>  <strong>XMM0</strong> </td><td>  <strong>Xmm1</strong> </td><td>  <strong>Xmm2</strong> </td><td>  <strong>Xmm3</strong> </td></tr><tr><td>  0.99 </td><td>  100 </td><td>  ??? </td><td>  ??? </td></tr></tbody></table><br><p>  Now you may have guessed why the little trick from the beginning of the article works.  Consider the following function signature: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPowerOfDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span></span>;</code> </pre> <br><p>  Calling <code>IntPowerOfDouble(100, 0.99)</code> , the compiler will arrange the registers like this: </p><br><table><thead><tr><th>  Rdx </th><th>  RCX </th><th>  R8 </th><th>  R9 </th></tr></thead><tbody><tr><td>  100 </td><td>  ??? </td><td>  ??? </td><td>  ??? </td></tr><tr><td>  <strong>XMM0</strong> </td><td>  <strong>Xmm1</strong> </td><td>  <strong>Xmm2</strong> </td><td>  <strong>Xmm3</strong> </td></tr><tr><td>  0.99 </td><td>  ??? </td><td>  ??? </td><td>  ??? </td></tr></tbody></table><br><p>  In other words, just like in <code>DoubleToTheInt(0.99, 100)</code> ! <br>  Due to the fact that the compiled function has no idea how it was called - only where in registers and on the stack <em>we can</em> expect our arguments - <em>we can call a function with a different order of arguments by casting a pointer to the function to the wrong (but ABI-compatible) function signature</em> . </p><br><p>  In fact, as long as the integer and floating point arguments preserve order, we can mix them as you please, and the location of the registers will be the same.  That is, </p><br><p> <code>double functionA(double a, double b, float c, int x, int y, int z);</code> </p> <br><p>  there will be the same register arrangement as in: </p><br><p> <code>double functionB(int x, double a, int y, double b, int z, float c);</code> </p> <br><p>  and the same as u: </p><br><p> <code>double functionC(int x, int y, int z, double a, double b, float c);</code> </p> <br><p>  In all three cases in the registers will be: </p><br><table><thead><tr><th>  Rdx </th><th>  RCX </th><th>  R8 </th><th>  R9 </th></tr></thead><tbody><tr><td> <code>int x</code> </td> <td> <code>int y</code> </td> <td> <code>int z</code> </td> <td>  ??? </td></tr><tr><td>  <strong>XMM0</strong> </td><td>  <strong>Xmm1</strong> </td><td>  <strong>Xmm2</strong> </td><td>  <strong>Xmm3</strong> </td></tr><tr><td> <code>double a</code> </td> <td> <code>double b</code> </td> <td> <code>double c</code> </td> <td>  ??? </td></tr></tbody></table><br><p>  Note that both double and single precision arguments occupy XMM registers - but they are <em>not</em> ABI-compatible with each other.  Therefore, if you remember the second code example at the very beginning, the reason <code>FloatPowerOfDouble</code> returned zero (not 95.5) is because the compiler arranged the single-precision value (32-bit) 100.0 in XMM0, and the double-precision value (64-bit) 0.99 in XMM1 - but the called function expected <em>double-</em> precision number in XMM0 and <em>single</em> in XMM1.  Because of this, the exhibitor pretended to be a mantissa, the bits of the mantissa were cut off or taken as an exponent, and the <code>FloatPowerOfDouble</code> function raised a Very Small Number to the <code>FloatPowerOfDouble</code> a Very Large Number, getting a zero.  The riddle is solved. </p><br><p>  Pay attention to ???  in the tables above.  The values ‚Äã‚Äãof these registers are not defined - there can be any value from previous calculations.  The called function does not matter what is in them, and it can overwrite them during execution. </p><br><p>  This creates an interesting possibility - in addition to calling a function with a different order of arguments, you can also call a function with a <em>different number of arguments</em> .  There are several reasons why you might want to do something so crazy. </p><br><h1>  Dial 1-800-I-Really-Enjoy-Type-Punning </h1><br><p>  Try it: </p><br><pre> <code class="hljs mel">#include &lt;math.h&gt; #include &lt;stdio.h&gt; double DoubleToTheInt(double x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>(x, y); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { double (*DoubleToTheIntVerbose)( double, double, double, double, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) = (double (*)(double, double, double, double, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>))&amp;DoubleToTheInt; printf(<span class="hljs-string"><span class="hljs-string">"(0.99)^100: %lf \n"</span></span>, DoubleToTheIntVerbose( <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); printf(<span class="hljs-string"><span class="hljs-string">"(0.99)^100: %lf \n"</span></span>, DoubleToTheInt(<span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)); }</code> </pre> <br><p>  It is not surprising that in both lines the same result - all arguments are placed in registers, and the location of registers is the same. </p><br><p>  Now the fun begins.  We can define a new "verbose" type of function that can call many different types of functions, provided that the arguments get into the registers and the function returns the same type. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; #include &lt;stdio.h&gt; typedef double (*verbose_func_t)(double, double, double, double, int, int, int, int); int main() { verbose_func_t verboseSin = (verbose_func_t)&amp;sin; verbose_func_t verboseCos = (verbose_func_t)&amp;cos; verbose_func_t verbosePow = (verbose_func_t)&amp;pow; verbose_func_t verboseLDExp = (verbose_func_t)&amp;ldexp; printf("Sin(0.5) = %lf\n", verboseSin(0.5, 0.0, 0.0, 0.0, 0, 0, 0, 0)); printf("Cos(0.5) = %lf\n", verboseCos(0.5, 0.0, 0.0, 0.0, 0, 0, 0, 0)); printf("Pow(0.99, 100) = %lf\n", verbosePow(0.99, 100.0, 0.0, 0.0, 0, 0, 0, 0)); printf("0.99 * 2^12 = %lf\n", verboseLDExp(0.99, 0.0, 0.0, 0.0, 12, 0, 0, 0)); }</span></span></span></span></code> </pre> <br><p>  This type compatibility is convenient because we can, for example, create a simple calculator that refers to any function that accepts and returns double-precision numbers: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef double (*four_arg_func_t)(double, double, double, double); int main(int argc, char **argv) { four_arg_func_t verboseFunction = NULL; if (strcmp(argv[1], "sin") == 0) { verboseFunction = (four_arg_func_t)&amp;sin; } else if (strcmp(argv[1], "cos") == 0) { verboseFunction = (four_arg_func_t)&amp;cos; } else if (strcmp(argv[1], "pow") == 0) { verboseFunction = (four_arg_func_t)&amp;pow; } else { return 1; } double xmm[4]; int i; for (i=2; i&lt;argc; i++) { xmm[i-2] = strtod(argv[i], NULL); } printf("%lf\n", verboseFunction(xmm[0], xmm[1], xmm[2], xmm[3])); return 0; }</span></span></span></span></code> </pre> <br><p>  Checking: </p><br><pre> <code class="hljs kotlin"><span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; clang calc.c <span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> pow <span class="hljs-number"><span class="hljs-number">0.99</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">0.366032</span></span> <span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sin <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.479426</span></span> <span class="hljs-symbol"><span class="hljs-symbol">emiller@</span></span>gibbon ~&gt; ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> cos <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.877583</span></span></code> </pre> <br><p>  Not quite a competitor to <em>Mathematica</em> , but you can present a more complex version with a table of function names and corresponding function pointers ‚Äî to add a new function, you just need to update the table and not explicitly call a new function in code. </p><br><p>  Other uses include JIT compilers.  If you have ever practiced on an LLVM tutorial, you might suddenly come across a message: </p><br><blockquote>  "Full-featured argument passing not supported yet!" </blockquote><br><p>  LLVM skillfully turns code into machine codes and loads machine codes into memory, but is not very flexible if you need to call a function loaded into memory.  With <code>LLVMRunFunction</code> , you can call <code>main()</code> -like functions (integer argument, pointer argument, pointer argument, returns integer), but not much else.  Most tutorials recommend wrapping your compiler function with a function similar to <code>main()</code> , hiding all your arguments for the pointer argument, and using a wrapper to pull the arguments from the pointer and call the real function. </p><br><p>  But with our new knowledge of X86 registers, we can simplify the ceremony by getting rid of the wrapper function in many cases.  Instead of checking that the function belongs to the restricted list of C-callable function signatures ( <code>int main()</code> , <code>int main(int)</code> , <code>int main(int, void *)</code> , etc.), we can create a pointer, signature It fills all the registers of parameters and, consequently, is compatible with all functions that pass arguments only through registers, and call them, passing zero (or whatever) for unused arguments.  We just need to define a separate type for each return type, rather than for each possible function signature, and call the functions more flexibly using a method that otherwise would require the use of an assembler. </p><br><p>  I'll show you the last trick before closing the shop.  Try to figure out how this code works: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NoOp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> (*ReturnLastReturnValue)() = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> (*)())&amp;NoOp; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-number"><span class="hljs-number">100.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> other_value = ReturnLastReturnValue(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Value: %lf Other value: %lf\n"</span></span> value, other_value); }</code> </pre> <br><p>  (You should first read your calling agreement ...) </p><br><div class="spoiler">  <b class="spoiler_title">Translator theory</b> <div class="spoiler_text"><p>  The function returns the result via XMM0.  Nothing happens between the two functions, and in XMM0 the result of the last function remains, which <code>NoOp</code> picks up as an argument and returns. </p></div></div><br><h1>  Some assembly language required </h1><br><p>  If you ever ask on a programmer‚Äôs forum about an assembler, the usual answer is: <em>You don‚Äôt need an assembler - leave it for the brilliant doctors of science who write compilers.</em>  <em>Yes, please hold your hands in sight.</em> </p><br><p>  Compiler writers are smart people, but I think it is a mistake to assume that everyone else should carefully avoid assembler.  In the short run on puns of typing, we saw how register locations and calling convention ‚Äî supposedly the exclusive care of assembler compiler writers ‚Äî pops into C from time to time and how to use this knowledge to do things that ordinary C programmers would consider impossible. </p><br><p>  But this is only the very tip of the programming language in assembly language ‚Äî specially presented without a single line of assembly language code ‚Äî and I advise anyone who has time to take a deeper dive into this topic.  The assembler is the key to understanding how the CPU handles instructions ‚Äî what the instruction counter is, what the frame pointer is, what the stack pointer is, what registers do ‚Äî and allows you to look at programs in a different (brighter) light.  Even basic knowledge can help you come up with solutions that otherwise would not even occur to you and understand what is happening when you slip past the prison guards of your favorite high-level language and squint into the harsh, beautiful sun. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/307706/">https://habr.com/ru/post/307706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307696/index.html">Juniper Hardware Architecture</a></li>
<li><a href="../307698/index.html">In the wake of "spammer" or Oracle DB + UTL_SMTP + SSL / TLS</a></li>
<li><a href="../307700/index.html">The digest of interesting materials for the mobile # 166 developer (on August 8-14)</a></li>
<li><a href="../307702/index.html">How a variable may not equal its own value.</a></li>
<li><a href="../307704/index.html">New 3CX Client clients for Mac and iOS, and a tip for setting up a Gmail server for 3CX Phone System</a></li>
<li><a href="../307708/index.html">A little introduction to parallel programming on R</a></li>
<li><a href="../307710/index.html">The story ‚ÄúNIICHOSHI. Saday</a></li>
<li><a href="../307712/index.html">Passing infinity: do-it-yourself t-test</a></li>
<li><a href="../307714/index.html">Basics of computer networks. Subject number 2. Top level protocols</a></li>
<li><a href="../307718/index.html">PHP Digest number 90 - interesting news, materials and tools (August 1 - 14, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>