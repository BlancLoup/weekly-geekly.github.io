<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prism Developer Guide - Part 8.1, View-Based Navigation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


1. Introduction 
2. Initializing Prism Applications 
3. Manage dependencies between components 
4. Modular Application Developmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prism Developer Guide - Part 8.1, View-Based Navigation</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>Table of contents</b> <br><ol><li>  <a href="http://habrahabr.ru/post/176851/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/176853/">Initializing Prism Applications</a> </li><li>  <a href="http://habrahabr.ru/post/176861/">Manage dependencies between components</a> </li><li>  <a href="http://habrahabr.ru/post/176863/">Modular Application Development</a> </li><li>  <a href="http://habrahabr.ru/post/176867/">Implementation of the MVVM pattern</a> </li><li>  <a href="http://habrahabr.ru/post/176869/">Advanced MVVM scripts</a> </li><li>  <a href="http://habrahabr.ru/post/176895/">Creating user interface</a> <br><ol><li>  <a href="http://habrahabr.ru/post/177925/">User Interface Design Recommendations</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/178009/">Navigation</a> <ol><li>  <a href="http://habrahabr.ru/post/182052/">View-Based Navigation (View-Based Navigation)</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/182580/">The interaction between loosely coupled components</a> </li></ol></blockquote><br><h3>  <i>View-Based Navigation</i> ( <i>View-Based Navigation</i> ) </h3><br>  Although state-based navigation may be useful in the scenarios described earlier, however, navigation in an application often requires replacing one view with another.  In Prism, this type of navigation is called " <i>view-based navigation</i> ". <br><br>  Depending on the application requirements, the navigation process can be quite complex and requires careful coordination.  The following are some of the difficulties you may encounter when implementing navigation based on views: <br><br><ul><li> The purpose of navigation ‚Äî a container for adding or deleting views ‚Äî can process navigation in different ways when adding and removing views, or it can visualize the navigation process in different ways.  In many cases, the purpose of the navigation is the usual <code>Frame</code> , or <code>ContentControl</code> , and the views are simply displayed inside these controls.  However, there are many scenarios where the purpose of navigation is another kind of control, such as <code>TabControl</code> , or <code>ListBox</code> .  In such cases, navigation may require activating or highlighting an existing view, or adding a new view. </li><li>  The application will often be required to somehow identify the view to which navigation should be performed.  For example, in web applications, the page you are navigating to is directly identified by a URI.  In client applications, a view can be identified by its type name, resource file location, or many other ways.  In composite applications consisting of loosely coupled modules, views are often defined in separate modules.  Separate views, in such cases, should be able to be identified without creating additional dependencies between modules. </li><li>  After identifying the presentation, the process of its creation and initialization should be carefully coordinated.  This is especially important when using the MVVM pattern.  In such a case, the views and the corresponding view model must be created and associated with each other while navigating.  If you use a dependency injection container, such as Unity, or MEF, you may need to use a special design mechanism when creating a view and / or view model. </li><li>  MVVM pattern allows you to separate the UI of the application from its user interaction logic and business logic.  However, the navigation process can encompass both the UI and the application logic.  The user can start navigating within the view, with the result that the view will be updated.  But it will often require the ability to initiate and coordinate navigation from the view model.  An important aspect to consider is the ability to clearly separate the navigation behavior between the view and the view model. </li><li>  An application may often need to pass parameters, or a context, to the view to correctly initialize it.  For example, if a user navigates to a view to edit information about a selected client, the ID of this client, or its data, must be transferred to the view in order to display the correct information in it. </li><li>  Many applications need to carefully coordinate navigation to ensure that certain business requirements are met.  For example, a user may be shown a pop-up message about the incorrectness of the data entered by him, while trying to navigate to another view.  This process requires coordination between the previous and the new ideas. </li><li>  Finally, most modern applications allow the user to navigate to the previous, or to the next view.  Similarly, some applications implement their workflow using a sequence of views or forms and allow the user to navigate forward or backward through them, adding or editing data, before completing the task and sending all the changes made in one batch.  Such scripts require some kind of journaling mechanism in order for the navigation sequence to be saved, repeated, or predefined. </li></ul><br>  Prism provides guidance on how to solve these problems, expanding the mechanism of regions to support navigation.  The following sections provide a brief summary of the Prism regions and how they were extended to support view-based navigation. <br><a name="habracut"></a><br><h4>  <i>Region</i> overview Prism </h4><br>  Prism regions were designed to support the development of composite applications (applications consisting of several modules), allowing the user interface to be designed in a loosely coupled fashion.  Regions allow you to display the views defined in the modules in the application UI, and the modules do not need to know about the full structure of the user interface.  This makes it easy to change the UI markup of the application, without having to make changes to the modules themselves. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Regions of Prism, for the most part, are named placeholders that display views.  Any control can be declared as a region, by simply adding the attached <code>RegionName</code> property, as shown below. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">prism:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MainRegion"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  For each control defined as a region, Prism creates a <code>Region</code> object, representing the region itself, and a <code>RegionAdapter</code> object (region adapter), whose task is to control the location and activation of views in a given control element.  The Prism Library provides a <code>RegionAdapter</code> implementation for most Silverlight and WPF controls.  You can create your own <code>RegionAdapter</code> to support additional controls, or to implement special behavior.  The <code>RegionManager</code> class (region manager) provides access to the <code>Region</code> application objects. <br><br>  In many cases, a region can be a simple control, such as <code>ContentControl</code> , which can display only one view at a time.  In other cases, it can be a control that allows you to display multiple views at once, such as <code>TabControl</code> , or <code>ListBox</code> . <br><br>  The region adapter manages the list of views associated with that region.  One or more of these views can be displayed in the region's control, in accordance with its content display strategy.  Views can be assigned names that can be used to search for them in the future.  The region adapter also controls which presentation is active in the region.  Active, is the view that is highlighted at the moment, or is the top one.  For example, in <code>TabControl</code> , the view that is displayed on the highlighted tab is active, in <code>ContentControl</code> , the one that is currently displayed on the screen. <br><br><blockquote>  <b>The note.</b> <br>  Determining which presentation is active is especially important in the navigation process.  Often, it may be necessary for an active view to take part in navigation, for example, to save data before the user leaves it, or to request cancellation, or to confirm the operation. <br></blockquote><br>  Previous versions of Prism made it possible to display views in regions in two different ways.  The first method, called <i>view injection</i> , allowed programmatically display views in a region.  This approach is useful when displaying dynamic content, when the view that needs to be displayed in a region often changes to reflect the logic of the application. <br><br>  The implementation of views is supported by providing the <code>Add</code> method in the <code>Region</code> class.  The following code shows how you can get a reference to a <code>Region</code> object through the <code>RegionManager</code> class, and programmatically add a view to it.  In the example, the view is created using the DI container. <br><br><pre> <code class="cs hljs">IRegionManager regionManager = ...; IRegion mainRegion = regionManager.Regions[<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>]; InboxView view = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.Resolve&lt;InboxView&gt;(); mainRegion.Add(view);</code> </pre><br>  The following method, called <i>view discovery</i> , allows modules to register a mapping between view types and region names.  At the moment when the region with the specified name is displayed on the screen, an instance of the corresponding view will be automatically created and displayed in this region.  This trip is useful for displaying relatively static content when the view displayed in the region does not change. <br><br>  View detection is supported through the <code>RegisterViewWithRegion</code> method in the <code>RegionManager</code> class.  This method allows you to specify a callback method that will be called when displaying a region with the specified name.  The following example shows how you can create a view (using a dependency injection container) when displaying a region named <i>‚ÄúMainRegion‚Äù</i> . <br><br><pre> <code class="cs hljs">IRegionManager regionManager = ...; regionManager.RegisterViewWithRegion(<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>, () =&gt; container.Resolve&lt;InboxView&gt;());</code> </pre><br>  For a more detailed overview of the regions of Prism, see the chapter " <a href="http://habrahabr.ru/post/176895/">Creating a User Interface</a> ".  The rest of the article will look at how the regions were expanded to support navigation, and how to overcome the problems described earlier. <br><br><h4>  Basic navigation in the regions </h4><br>  Both of the above-described methods for displaying views in regions can be regarded as some limited form of navigation ‚Äî the introduction of a view is an explicit, programmatic navigation, and the detection of a view is implicit or deferred navigation.  However, in Prism 4.0, regions were expanded to support more general concepts of navigation, based on URIs and an extensible navigation mechanism. <br><br>  Navigating within a region means displaying a new view in it.  The displayed view is identified by a URI, which, by default, refers to the name of the view being navigated to.  You can initiate navigation programmatically using the <code>RequestNavigate</code> method defined in the <code>INavigateAsync</code> interface. <br><br><blockquote>  <b>The note.</b> <br>  Despite the name, the <code>INavigateAsync</code> interface <code>INavigateAsync</code> not imply asynchronous navigation performed in a separate thread.  On the contrary, <code>INavigateAsync</code> implies pseudo-asynchronous navigation.  The <code>RequestNavigate</code> method may end synchronously after the end of navigation, or it may end before the end of navigation, for example, when the user needs to confirm the navigation.  By allowing you to set a callback method during navigation, Prism enables support for such scenarios without the difficulty of handling background threads. <br></blockquote><br>  The <code>INavigateAsync</code> interface implements the <code>Region</code> class, allowing you to initiate navigation in that region. <br><br><pre> <code class="cs hljs">IRegion mainRegion = ...; mainRegion.RequestNavigate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>, UriKind.Relative));</code> </pre><br>  You can also call the <code>RequestNavigate</code> method on the <code>RegionManager</code> object, specifying the name of the region on which you are navigating.  This method finds a link to the corresponding region and calls the <code>RequestNavigate</code> method on it.  This is shown in the example below. <br><br><pre> <code class="cs hljs">IRegionManager regionManager = ...; regionManager.RequestNavigate(<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>, UriKind.Relative));</code> </pre><br>  By default, the navigation URI specifies the name of the view by which it is registered in the container.  The code below illustrates the relationship between the view registration name in a Unity container and the use of that name during navigation. <br><br><pre> <code class="cs hljs">container.RegisterType&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, InboxView&gt;(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>); regionManager.Regions[Constants.MainRegion].RequestNavigate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>, UriKind.Relative));</code> </pre><br><blockquote>  <b>The note.</b> <br>  When creating a view by a navigation service, it requests an object of type <code>Object</code> from a container, with the name provided in the navigation URI.  Different containers use different registration mechanisms to support this.  For example, in Unity, you need to register the views by associating the <code>Object</code> type with this view, and providing the registration name that matches the name in the navigation URI.  In MEF, you only need to specify the name of the contract in the <code>ExportAttribute</code> attribute. <br></blockquote><br>  Example.  When using Unity to register a view: <br><br>  <b>Do not use:</b> <br><pre> <code class="cs hljs">container.RegisterType&lt;InboxView&gt;(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>);</code> </pre><br>  <b>Use instead:</b> <br><pre> <code class="cs hljs">container.RegisterType&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>,InboxView&gt;(<span class="hljs-string"><span class="hljs-string">"InboxView"</span></span>);</code> </pre><br><blockquote>  <b>The note.</b> <br>  The name used for registration and navigation does not have to be associated with the name of the view type, any string will do.  For example, instead of a string, you can explicitly use the full name of the type: <code>typeof(InboxView).FullName</code> ; <br></blockquote><br>  In MEF, you can simply export the view with the desired name. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InboxView"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InboxView</span></span> : <span class="hljs-title"><span class="hljs-title">UserControl</span></span> { ... }</code> </pre><br>  During navigation, the specified view is requested from the container along with the corresponding view model and other dependencies.  After that, it is added to the specified region and activated (details about activation will be later in the article). <br><br><blockquote>  <b>The note.</b> <br>  The preceding description illustrates <i>view-first</i> navigation when a URI refers to the name of the view with which it was exported or registered in a container.  With <i>view-first</i> navigation, the dependent view model is created as a view dependency.  An alternative approach is to use the <i>view model ‚Äì first</i> navigation when the navigation URI refers to the name of the view model with which it was registered in the container.  This approach can be useful when views are defined as data patterns, or when you want the navigation pattern to be defined independently of the views. <br></blockquote><br>  The <code>RequestNavigate</code> method also allows you to specify a callback method that will be called when the navigation is completed. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectedEmployeeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { ... regionManager.RequestNavigate(RegionNames.TabRegion, <span class="hljs-string"><span class="hljs-string">"EmployeeDetails"</span></span>, NavigationCompleted); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NavigationCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationResult result</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  The <code>NavigationResult</code> class has properties through which you can get information about the navigation operation.  The <code>Result</code> property indicates whether navigation has completed.  If the navigation ended with an error, then the <code>Error</code> property will contain a reference to any exceptions thrown during the navigation.  Through the <code>Context</code> property, you can access the navigation URI and any parameters it contains, as well as a link to the service that coordinates navigation operations. <br><br><h4>  View participation and view models in navigation </h4><br>  It often happens that both the view and the view model in your application will want to participate in the navigation.  This allows the interface <code>INavigationAware</code> .  You can implement this interface in a view, or (more often) in a view model.  By implementing it, your view, or view model, can be directly involved in the navigation process. <br><br><blockquote>  <b>The note.</b> <br>  In the following description, it is assumed that navigation occurs between views.  But it should be noted that the <code>INavigationAware</code> interface during navigation will be called regardless of whether it is implemented in the view, or in the view model.  During navigation, Prism checks whether the <code>INavigationAware</code> view <code>INavigationAware</code> , if so, the necessary methods are called on it.  Also, Prism makes a check on the implementation of this interface on the object in which the View <code>DataContext</code> property is set, and, if successful, calls the necessary methods. <br></blockquote><br>  This interface allows the view, or view model, to participate in a navigation operation.  Three methods are defined in the <code>INavigationAware</code> interface: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INavigationAware</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNavigationTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNavigatedTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNavigatedFrom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  The <code>IsNavigationTarget</code> method allows an existing representation in the region, or a representation model, to show whether it can process a navigation request.  This can be useful in cases where you want to reuse an already existing view for navigation processing, or you want to navigate to an already existing view.  For example, a view that displays customer information can be updated by selecting different customers.  For more information, see the ‚ÄúNavigating to Existing Views‚Äù section later in this article. <br><br>  The <code>OnNavigatedFrom</code> and <code>OnNavigatedTo</code> are called during a navigation operation.  If the current active view in a region (or its view model) implements this interface, the <code>OnNavigatedFrom</code> method <code>OnNavigatedFrom</code> called before navigation begins.  The <code>OnNavigatedFrom</code> method allows the previous view to save its state, or prepare for deactivation or deletion from the user interface.  For example, a view can save changes made by a user to a database, or send them to a web service. <br><br>  If the newly created view (or view model) implements this interface, its <code>OnNavigatedTo</code> method <code>OnNavigatedTo</code> called after the navigation is completed.  The <code>OnNavigatedTo</code> method allows the view that was just displayed to be initialized, possibly using parameters passed along with the navigation URI.  For more information, see the next section, ‚ÄúPassing Parameters During Navigation.‚Äù <br><br>  After creating, initializing and adding a new view to the target region, it becomes active, and the previous view is deactivated.  Sometimes, it may be necessary to remove a deactivated view from a region.  In Prism, there is an <code>IRegionMemberLifetime</code> interface that allows you to control the lifetime of views in regions, asking whether you should immediately remove deactivated views from a region, or simply mark them as deactivated. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EmployeeDetailsViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">IRegionMemberLifetime</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> KeepAlive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }</code> </pre><br>  The <code>IRegionMemberLifetime</code> interface defines the only <code>KeepAlive</code> property that is read-only.  If it is set to <code>false</code> , the view will be removed from the region when it is deactivated.  Since the region then stops storing the link to the view, it will be accessible to the garbage collector (unless, of course, other parts of your application reference it).  You can implement this interface in both the view and the view model.  Although the <code>IRegionMemberLifetime</code> interface <code>IRegionMemberLifetime</code> intended, for the most part, to control the lifetime of views in regions during activation and deactivation, the <code>KeepAlive</code> property is also used during navigation after creating and activating a view in the target region. <br><br><blockquote>  <b>The note.</b> <br> ,    ,   <code>ItemsControl</code> ,  <code>TabControl</code> ,    ,    .     ,    ,       . <br></blockquote><br><h4>      </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement the necessary behavior during navigation, you may often need to specify additional data that is transmitted during the navigation request, in addition to the name of the target view. The object </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides access to the navigation URI and to all parameters that were passed along with it. You can get access to </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the way </font></font><code>IsNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>OnNavigatedFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>OnNavigatedTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To help set and get navigation options, there is a class in Prism </font></font><code>UriQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can use it if necessary to add navigation parameters to the URI before starting navigation and to access these parameters during navigation. </font></font><code>UriQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates a list with name-value pairs for each parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code example shows how to add parameters to</font></font><code>UriQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and attach them to the navigation URI. </font></font><br><br><pre> <code class="cs hljs">Employee employee = Employees.CurrentItem <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Employee; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (employee != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { UriQuery query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriQuery(); query.Add(<span class="hljs-string"><span class="hljs-string">"ID"</span></span>, employee.Id); _regionManager.RequestNavigate(RegionNames.TabRegion, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"EmployeeDetailsView"</span></span> + query.ToString(), UriKind.Relative)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can get navigation parameters using the </font></font><code>Parameters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object </font><font style="vertical-align: inherit;">property </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This property returns an instance of a class </font></font><code>UriQuery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has an indexing property to simplify access to individual parameters.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNavigatedTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> id = navigationContext.Parameters[<span class="hljs-string"><span class="hljs-string">"ID"</span></span>]; }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Navigation to existing views </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quite often, reusing a view, updating it, or activating during navigation, is a preferred behavior than replacing it with a new view. This is a typical case when you are navigating to a view of the same type, but in which you want to display other data, or when the required view is already available, but requires activation (to highlight or move up). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of the first scenario is when the application allows the user to change information about the client using the view </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the user already uses this view to edit the client with ID 123. If the user decides to edit the client record with ID 456, he can simply navigate to submission</font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and enter a new ID. After that, the view </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will request information about the new client and update its UI accordingly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an example of using the second scenario, let's say that the application allows you to edit information about several clients simultaneously. In this case, the application displays several views </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>TabControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example, clients with ID 123 and ID 456. When you navigate to </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and enter ID 456, the corresponding view will be activated (that is, the corresponding tab will be highlighted). If the user navigates to the view </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and enters ID 789, then a new instance will be created and displayed in the UI.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to navigate to already existing views is useful for a variety of reasons. It is often more efficient to update an existing view, rather than replace it with a new one of the same type. Similarly, activating an existing view instead of creating a new one makes the interface more consistent. In addition, the ability to handle such scripts without the need to write additional code simplifies the development and support of the application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prism supports both scripts described above through a method </font></font><code>INavigationAware.IsNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This method is called during navigation on views in the region that have the same type as the target view. In the previous example, the target representation was of type </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so the method </font></font><code>IsNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be called on all existing representations of type</font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">located in the region. </font><font style="vertical-align: inherit;">Prism determines the target presentation type using a navigation URI, assuming that it is the short name of the target representation type.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The note. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for Prism to determine the type of the target view, the name of the view in the navigation URI must match the short name of its type. </font><font style="vertical-align: inherit;">For example, if a view has a class </font></font><code>MyApp.Views.EmployeeDetailsView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the name of the view specified in the navigation URI should be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EmployeeDetailsView</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is the standard behavior of Prism. </font><font style="vertical-align: inherit;">You can change it by creating your content loader class. </font><font style="vertical-align: inherit;">You can do this by implementing an interface </font></font><code>IRegionNavigationContentLoader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or by inheriting your class from </font></font><code>RegionNavigationContentLoader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method implementation </font></font><code>IsNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can use a parameter </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to determine if the view can process the navigation request. </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gives access to the navigation URI and navigation parameters. </font><font style="vertical-align: inherit;">In the previous example, the implementation of this method in the view model </font></font><code>EditCustomer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compared the current client ID with the ID specified in the navigation query, returning </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it matches.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNavigationTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> id = navigationContext.Parameters[<span class="hljs-string"><span class="hljs-string">"ID"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _currentCustomer.Id.Equals(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the method </font></font><code>IsNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always returns </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, regardless of the navigation parameters, this view will always be reused. </font><font style="vertical-align: inherit;">Such an approach can guarantee that in a certain region there will be only one representation of a certain type.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confirmation or cancellation of navigation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It may often be necessary to interact with the user during navigation, allowing the user to confirm or cancel it. In many applications, the user, for example, can start navigation while entering or editing data. In such situations, you may need to ask the user if he wants to save, or to cancel the changes, before leaving the page, or if he does not want to cancel the navigation at all. Prism supports such scripts through the interface </font></font><code>IConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The interface </font></font><code>IConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inherits from the interface </font></font><code>INavigationAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and adds a method</font></font><code>ConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">By implementing this interface in your view, or view model, you allow them to participate in the navigation process, allowing you to interact with the user so that he can cancel or confirm the navigation. </font><font style="vertical-align: inherit;">You may also need to use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interaction Request</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">, which was discussed in Part 6, </font></font><a href="http://habrahabr.ru/post/176869/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVVM Advanced Scenarios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , to display a confirmation popup window.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The note. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>ConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called on the active view (or view model), similar to the method </font></font><code>OnNavigatedFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">described earlier.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>ConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes two parameters, a reference to the current navigation context described above, and a delegate that must be called to continue navigation. </font><font style="vertical-align: inherit;">For this reason, this delegate is often called the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuation callback</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can save a reference to the delegate-continuation, to call it after the end of user interaction. </font><font style="vertical-align: inherit;">If an application interacts with the user through </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interaction Request</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects </font><font style="vertical-align: inherit;">, you can use this delegate as the callback method of the interaction request. </font><font style="vertical-align: inherit;">The following diagram illustrates the complete process. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/448/4dc/55d/4484dc55d9fca99f22dae2829dff16e1.png" alt="Confirmation of navigation using the interaction request object"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following steps describe the process of confirming navigation when using an object </font></font><code>InteractionRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation is initiated through a method call </font></font><code>RequestNavigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li>  ,      <code>IConfirmNavigation</code> ,   <code>ConfirmNavigationRequest</code> . </li><li>       ( <i>interaction request event</i> ). </li><li>           . </li><li>        ,     . </li><li> -   ,     . </li><li>   ,  . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To see an illustration of this, see </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View-Switching Navigation Quick Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This application allows the user to create emails using classes </font></font><code>ComposeEmailView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>ComposeEmailViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The view model class implements the interface </font></font><code>IConfirmNavigation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the user navigates, for example, by pressing the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calendar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">, at the time of creating the message, a method will be invoked </font></font><code>ConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that the view model can request confirmation from the user. </font><font style="vertical-align: inherit;">To support this, the view model sets the interaction request object, as shown in the example below.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ComposeEmailViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">NotificationObject</span></span>, <span class="hljs-title"><span class="hljs-title">IConfirmNavigationRequest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> InteractionRequest&lt;Confirmation&gt; confirmExitInteractionRequest; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComposeEmailViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEmailService emailService</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.confirmExitInteractionRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InteractionRequest&lt;Confirmation&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInteractionRequest ConfirmExitInteractionRequest { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.confirmExitInteractionRequest; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The class has a </font></font><code>ComposeEmailVew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trigger </font></font><code>InteractionRequestTrigger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attached to </font></font><code>ConfirmExitInteractionRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the view model </font><font style="vertical-align: inherit;">property </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When an interaction is requested, a simple popup window is shown to the user.</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl.Resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DataTemplate</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ConfirmExitDialogTemplate"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">VerticalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DataTemplate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl.Resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LayoutRoot"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Background</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"White"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ei:Interaction.Triggers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">prism:InteractionRequestTrigger</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SourceObject</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding ConfirmExitInteractionRequest}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">prism:PopupChildWindowAction</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ContentTemplate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{StaticResource ConfirmExitDialogTemplate}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">prism:InteractionRequestTrigger</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ei:Interaction.Triggers</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><code>ConfirmNavigationRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">method </font></font><code>ComposeEmailVewMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is invoked when a user attempts to navigate while writing a message. </font><font style="vertical-align: inherit;">The implementation of this method triggers the interaction request defined earlier, so that the user can confirm or change the navigation operation.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; continuationCallback) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.confirmExitInteractionRequest.Raise( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Confirmation {Content = <span class="hljs-string"><span class="hljs-string">"..."</span></span>, Title = <span class="hljs-string"><span class="hljs-string">"..."</span></span>}, c =&gt; {continuationCallback(c.Confirmed);}); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The callback method for requesting interaction is invoked when the user clicks a button on the confirmation popup. </font><font style="vertical-align: inherit;">It simply invokes the delegate continuation, passing in the flag's value </font></font><code>Confirmed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which forces it to confirm or cancel the navigation.</font></font><br><br><blockquote> <b>.</b> <br>  ,     <code>Rise</code>   ,  <code>ConfirmNavigationRequest</code>   ,       UI .    <i>OK</i> ,  <i>Cancel</i>   ,        , ,   ,  -   .      UI.         . <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using this mechanism, you can control whether the navigation request is executed immediately, or with a delay, waiting for a user response, or other asynchronous operation, such as a request to a web server. To continue and confirm the navigation, you just need to call the delegate-continuation, passing in it </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to cancel the navigation, you must pass </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; continuationCallback) { continuationCallback(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to postpone navigation, you can save a link to the delegate continuation, which can be called after the end of user interaction, or an asynchronous request (for example, to a web server). </font><font style="vertical-align: inherit;">The navigation operation will be in a pending state until the delegate continues. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the user starts another navigation at this time, the navigation request will be canceled. </font><font style="vertical-align: inherit;">In this case, calling the delegate-continuation will not cause any effect. </font><font style="vertical-align: inherit;">Similarly, if you decide not to call the delegate continuation, the navigation operation will be in a pending state until it is replaced with a new navigation operation.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the navigation history ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Navigation Journal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The class </font></font><code>NavigationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides access to the region‚Äôs navigation service, which is responsible for coordinating the sequence of operations during navigation in the region. It provides access to the region in which you are navigating, and to the navigation log associated with that region. The navigation service implements the interface </font></font><code>IRegionNavigationService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown below.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRegionNavigationService</span></span> : <span class="hljs-title"><span class="hljs-title">INavigateAsync</span></span> { IRegion Region { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IRegionNavigationJournal Journal { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;RegionNavigationEventArgs&gt; Navigating; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;RegionNavigationEventArgs&gt; Navigated; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;RegionNavigationFailedEventArgs&gt; NavigationFailed; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this interface is inherited from the interface </font></font><code>INavigateAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can initiate navigation in the parent region by calling the method </font></font><code>RequestNavigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The event </font></font><code>Navigating</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is triggered when a navigation operation is initiated. The event </font></font><code>Navigated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is triggered when navigation is completed in the region. </font></font><code>NavigationFailed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">called when an error occurs during navigation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The property </font></font><code>Journal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gives access to the navigation log associated with the region. The navigation log implements the interface </font></font><code>IRegionNavigationJournal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown below.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRegionNavigationJournal</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CanGoBack { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CanGoForward { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IRegionNavigationJournalEntry CurrentEntry { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } INavigateAsync NavigationTarget { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoForward</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecordNavigation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IRegionNavigationJournalEntry entry</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can get and save a link to the region‚Äôs navigation service in a view while navigating through a method call </font></font><code>OnNavigatedTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. By default, Prism provides a simple stack log that allows you to navigate back and forth within a region. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use the navigation log to allow the user to navigate within the view itself. In the following example, the view model implements a command </font></font><code>GoBack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that uses the navigation log of the parent region. Consequently, the view can display the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">, which allows the user to move to the previous view in the region. Similarly, you can implement a command </font></font><code>GoForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to create a wizard-style workflow (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wizard style workflow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EmployeeDetailsViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INavigationAware</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IRegionNavigationService navigationService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNavigatedTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NavigationContext navigationContext</span></span></span><span class="hljs-function">)</span></span> { navigationService = navigationContext.NavigationService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DelegateCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; GoBackCommand { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandArg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigationService.Journal.CanGoBack) { navigationService.Journal.GoBack(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanGoBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandArg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> navigationService.Journal.CanGoBack; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can create your own journal for a region to implement a specific workflow for that region. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The note. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The navigation log can be used only in navigation operations in the region, which are coordinated by the navigation service of the region. </font><font style="vertical-align: inherit;">If you use a detection or deployment technique to implement navigation in a region, the navigation log will not be updated during navigation and cannot be used to navigate backward or forward in a region.</font></font><br></blockquote><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight Navigation Frameworks</font></font></i> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Region-based navigation in Prism has been designed to support a wide range of scenarios and problems that you may encounter when implementing navigation in loosely coupled modular applications that use the MVVM pattern and dependency injection container, such as Unity, or MEF. It was also designed to support the confirmation and cancellation of navigation, navigation to existing views, transfer of parameters during navigation, and navigation logging.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By supporting navigation for regions, Prism provides the ability to perform navigation within a variety of controls, and allows you to change the layout of the user interface of the application without disturbing the navigation structure. Pseudo-synchronous navigation is also supported, which allows for enhanced user interaction during navigation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, Prism navigation was not designed to replace the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (introduced in Silverlight 3.0), or the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF's navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Instead, navigation in the regions of Prism was designed to work with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight and the WPF navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides deep link support, browser integration, and navigation projection URIs. Navigation is possible inside the control </font></font><code>Frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may, if necessary, display an address bar that allows the user to navigate backward or forward between the views displayed in </font></font><code>Frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The usual approach is to use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to implement high-level navigation in the application shell and use the Prism navigation for all other parts of the application. In this case, your application will support deep links and will be integrated with the browser‚Äôs browser and its address bar, and will also enjoy all the benefits of navigation in the Prism regions. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not as extensible as in Silverlight. </font><font style="vertical-align: inherit;">Accordingly, support for dependency injection and the MVVM pattern is significantly hampered. </font><font style="vertical-align: inherit;">It is also based on a control </font></font><code>Frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has similar functionality in terms of logging and navigation UI. </font><font style="vertical-align: inherit;">You can use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF navigation framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with Prism navigation, although implementing navigation using only Prism regions may be a simpler and more flexible solution.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The sequence of navigation in the region </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following illustration gives an overview of the sequence of operations during navigation. </font><font style="vertical-align: inherit;">It is provided as a reference so you can see how the various elements of the Prism navigation interact with each other during the navigation request.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e9/8a2/0f4/5e98a20f484a86cf8d8396a2ab007c87.png" alt="The sequence of navigation in the region"><br><br><h3>  Additional Information </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information about the Visual State Manager, see the "VisualStateManager Class" on MSDN: </font></font><a href="http://msdn.microsoft.com/en-us/library/cc626338(v%3DVS.95).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/en-us/library/cc626338 (</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> v = VS.95 ).aspx </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information about using Microsoft Expression Blend behaviors, see "Working with built-in behaviors" on MSDN: </font></font><a href="http://msdn.microsoft.com/en-us/library/ff724013(v%3DExpression.40).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/en-us/library/ff724013(v=Expression.40).aspx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information about creating Microsoft Expression Blend behaviors, see "Creating Custom Behaviors" on MSDN: </font></font><a href="http://msdn.microsoft.com/en-us/library/ff724708(v%3DExpression.40).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/en-us/library/ff724708(v=Expression.40).aspx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information on the Silverlight </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation Framework</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, see ‚ÄúNavigation Overview‚Äù on MSDN: </font></font><a href="http://msdn.microsoft.com/en-us/library/cc838245(VS.95).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/en-us/library/cc838245(VS.95).aspx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information on integrating Silverlight's Navigation Framework with Prism, see ‚ÄúIntegrating Prism v4 Region Navigation with Silverlight Frame Navigation‚Äù on Karl Schifflett's blog: </font></font><a href="http://blogs.msdn.com/b/kashiffl/archive/2010/10/05/integrating-prism-v4-region-navigation-with-silverlight-frame-navigation.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://blogs.msdn.com/b/kashiffl/archive/2010/10/05 /integrating-prism-v4-region-navigation-with-silverlight-frame-navigation.aspx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/182052/">https://habr.com/ru/post/182052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182040/index.html">Windows client release for Nekka</a></li>
<li><a href="../182042/index.html">Testing code before committing using Jenkins and Jetbrains IDE (IDEA, PhpStorm ...)</a></li>
<li><a href="../182046/index.html">Intensity is more important than thoroughness</a></li>
<li><a href="../182048/index.html">In the looking glass: how to hire sales managers</a></li>
<li><a href="../182050/index.html">Feedly opened API for third-party RSS applications</a></li>
<li><a href="../182054/index.html">Burden of new</a></li>
<li><a href="../182056/index.html">From 4 mayors of cities in Denmark, Universal Music requires a payment of 42 thousand dollars for a musical parody of Gangnam Style</a></li>
<li><a href="../182058/index.html">Analysis of the tasks of the competition to analyze the security of the network infrastructure NetHack</a></li>
<li><a href="../182060/index.html">Eidos Montreal showed teaser Deus Ex: The Fall</a></li>
<li><a href="../182062/index.html">IBM uses Roomba robots to control temperature in data centers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>