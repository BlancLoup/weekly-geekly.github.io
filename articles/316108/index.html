<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trello Clone on Phoenix and React. Parts 10-12. Long Term Finish</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (current material is highlighted) 

1. Introduction and selection of technology stack 
2. Initial setup of the Phoenix Framework pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trello Clone on Phoenix and React. Parts 10-12. Long Term Finish</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/86e/e8d/293/86ee8d2930024c60a834695276f5de15.jpg"><br><p><br></p><br><div class="spoiler">  <b class="spoiler_title">Table of Contents (current material is highlighted)</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/308056/">Introduction and selection of technology stack</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">Initial setup of the Phoenix Framework project</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">User Model and JWT Authentication</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Front-end for registration on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Initial database population and controller to enter the application</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">Front-end authentication on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">We configure sockets and channels</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">We display the list and create new boards</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">Add new board users</a> </li><li>  <strong>We trace the connected users of boards</strong> </li><li>  <strong>Add lists and cards</strong> </li><li>  <strong>We spread the project on Heroku</strong> </li></ol></div></div><br><p>  <em>This part is the final one, and it will be especially long, but I want to finish the cycle and go further.</em>  <em>I also apologize for such a huge pause in its preparation and publication.</em>  <em>However, this time was not wasted and gave material for new, this time original, articles - approx.</em>  <em>translator</em> </p><a name="habracut"></a><br><a name="10"></a><br><h2 id="otslezhivaem-podklyuchenie-uchastnikov-dosok">  We trace connection of participants of boards </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-10">Original</a> </p><br><p>  <strong>Warning from the author: this part was written before the appearance of the Presence functionality and is a small introduction to the basics of GenServer behavior.</strong> </p><br><p>  Recall the <a href="https://habrahabr.ru/post/308382/">previous part</a> , in which we gave our users the opportunity to invite new participants to their boards.  When adding an e-mail to an existing user, a new relationship was created between users and boards, and the new user data was transmitted through the channel (channel), with the result that his avatar was displayed to all board members who were online.  At first glance, this is cool, but we can do much better and more useful if we can simply select the users who are currently online and browsing the board.  Let's start! </p><cut><br><h3 id="problema">  Problem </h3><br><p>  Before we continue, let's think about what we want to achieve.  So, in fact, we have a board and several participants who can unexpectedly visit its url, automatically connecting to the board channel.  When this happens, the participant‚Äôs avatar must be shown without transparency, as opposed to offline members whose avatars must be translucent. </p><br><img src="https://habrastorage.org/files/3e4/f09/096/3e4f090964204d388fdd00f5a2310da2.jpg"><br><p><br>  When a connected participant leaves the url of the board, exits the application or even closes the browser window, we need to notify all users connected to the board of the channel so that his avatar becomes translucent again, notifying that the user is no longer viewing the board.  Let's look at several ways in which we can achieve this and their shortcomings: </p><br><ol><li>  Managing the list of connected participants on the front-end in the Redux repository.  At first glance, this may seem like a suitable solution, but it will only work for participants who have already connected to the board channel.  Recently logged in users will not have this data. </li><li>  Use the database to store the list of connected participants.  This may also be an appropriate way, but it will force us to constantly twitch the database with requests from the list of participants and its updates for any connection or exit of the participant, not to mention mixing data with very specific user behavior. </li></ol><br><p>  So where can we store this information so that we can access it for all users quickly and efficiently?  Easy.  In ... have patience ... a permanent state-saving process. </p><br><h3 id="principy-genserver">  GenServer Principles </h3><br><p>  Although the phrase <em>permanent state-saving process</em> may sound daunting at first, this is much easier to implement than you would expect, thanks to <strong>Elixir</strong> and his <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html">GenServer</a> . </p><br><blockquote>  GenServer is a process similar to any other Elixir process, and can be used to store state, asynchronous code execution, and the like. <br></blockquote><p>  Imagine this as a small process running on our server and having an associative array (map) containing a list of connected users for each board.  Something like this: </p><br><pre><code class="hljs php">%{ <span class="hljs-string"><span class="hljs-string">"1"</span></span> =&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-string"><span class="hljs-string">"2"</span></span> =&gt; [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] }</code> </pre> <br><p>  Now imagine that this process has an available interface for self-initialization and updating the associative state array, for adding and removing boards and connected users.  Well, this is, in general, a <strong>GenServer</strong> process, and I say ‚Äúoverall‚Äù as <strong>long</strong> as it will also have corresponding benefits such as tracing, error reporting, and tracking capabilities (supervision). </p><br><h3 id="monitor-boardchannel">  BoardChannel Monitor </h3><br><p>  So, let's create the most initial version of this process, which will store the tracking data of the list of connected board members: </p><br><pre> <code class="hljs pgsql"># /lib/phoenix_trello/board_channel/monitor.ex defmodule PhoenixTrello.BoardChannel.Monitor <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use GenServer ##### # Client API def start_link(initial_state) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GenServer.start_link(__MODULE__, initial_state, <span class="hljs-type"><span class="hljs-type">name</span></span>: __MODULE__) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Working with <strong>GenServer,</strong> you need to consider both the API functions for external clients and their server implementation.  The first step is to implement the <code>start_link</code> function, which will actually launch GenServer, passing the initial state to it, - in our case, an empty associative array - between the module name and the server name.  We want to start this process during the launch of the application, so add it to the list of descendants in our supervision tree: </p><br><pre> <code class="hljs swift"># /lib/phoenix_trello.ex defmodule <span class="hljs-type"><span class="hljs-type">PhoenixTrello</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use <span class="hljs-type"><span class="hljs-type">Application</span></span> def start(_type, _args) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Supervisor.Spec, warn: fals e children = [ # ... worker(PhoenixTrello.BoardChannel.Monitor, [%{}]), # ... ] # ... end end</code> </pre> <br><p>  Now, each time the application starts, it will automatically call the <code>start_link</code> function, which we have just created, passing as an initial state the empty associative array <code>%{}</code> .  If the execution of the <code>Monitor</code> interrupted for any reason, the application will re-launch it with a new empty associative array.  Wow, isn't it?  Now, having configured all this, let's start adding participants to the array of <code>Monitor</code> states. </p><br><h3 id="obrabotka-podklyucheniy-uchastnikov">  Handling Member Connections </h3><br><p>  To do this, we need to add both the client function and the corresponding server handler of the feedback function (hereinafter simply callback functions): </p><br><div class="spoiler">  <b class="spoiler_title">/lib/phoenix_trello/board_channel/monitor.ex</b> <div class="spoiler_text"><pre> <code class="hljs vbscript"># /lib/phoenix_trello/board_channel/monitor.ex defmodule PhoenixTrello.BoardChannel.Monitor <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use GenServer ##### # Client API # ... def member_joined(board, member) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GenServer.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(__MODULE__, {:member_joined, board, member}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ##### # <span class="hljs-built_in"><span class="hljs-built_in">Server</span></span> callbacks def handle_call({:member_joined, board, member}, _from, state) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Map.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(state, board) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nil -&gt; state = state |&gt; Map.put(board, [member]) {:reply, [member], state} members -&gt; state = state |&gt; Map.put(board, Enum.uniq([member | members])) {:reply, Map.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(state, board), state} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  When the <code>member_joined/2</code> function is <code>member_joined/2</code> , passing it the board and the user, we will make an appeal to the <strong>GenServer</strong> process with the message <code>{:member_joined, board, member}</code> .  For this reason, we need a server handler for the callback function.  The <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html"><code>handle_call/3</code></a> function from <code>GenServer</code> receives the request message, the sender and the current state.  So in our case we will try to get the board from the state and add the user to its list of users.  In case the board is not there yet, we will add it with a new list containing the logged in user.  In response, we will return the list of users belonging to this board. </p><br><p>  Where should I call the <code>member_joined</code> method?  From <strong>BoardChannel</strong> at the time of user connection: </p><br><div class="spoiler">  <b class="spoiler_title">/web/channels/board_channel.ex</b> <div class="spoiler_text"><pre> <code class="hljs vbscript"># /web/channels/board_channel.ex defmodule PhoenixTrello.BoardChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :channel alias PhoenixTrello.{User, Board, UserBoard, List, Card, Comment, CardMember} alias PhoenixTrello.BoardChannel.Monitor def <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(<span class="hljs-string"><span class="hljs-string">"boards:"</span></span> &lt;&gt; board_id, _params, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> current_user = socket.assigns.current_user board = get_current_board(socket, board_id) connected_users = Monitor.user_joined(board_id, current_user.id) send(self, {:after_join, connected_users}) {:ok, %{board: board}, assign(socket, :board, board)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def handle_info({:after_join, connected_users}, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast! socket, <span class="hljs-string"><span class="hljs-string">"user:joined"</span></span>, %{users: connected_users} {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Thus, when it connects, we use <code>Monitor</code> to track it, and send via the socket an updated list of current users of the board.  Now we can process this newsletter on the front-end to update the status of the application with a new list of connected users: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/web/static/js/actions/current_board.js import Constants from '../constants'; const Actions = { /</span></span>/ ... connectToChannel: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket, boardId)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { const channel = socket.channel(`<span class="javascript"><span class="javascript">boards:${boardId}</span></span>`); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... channel.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'user:joined'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.CURRENT_BOARD_CONNECTED_USERS, users: msg.users, }); }); }; } }</code> </pre> <br><p>  The only thing left to do is to change the transparency of the avatar, depending on whether the board member is on this list or not: </p><br><pre> <code class="hljs xml">// /web/static/js/components/boards/users.js export default class BoardUsers extends React.Component { _renderUsers() { return this.props.users.map((user) =&gt; { const index = this.props.connectedUsers.findIndex((cu) =&gt; { return cu.id === user.id; }); const classes = classnames({ connected: index != -1 }); return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{classes}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{user.id}</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReactGravatar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"react-gravatar"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{user.email}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">https</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> ); }); } // ... }</code> </pre> <br><h3 id="obrabotka-otklyucheniy-polzovateley">  Handle user trips </h3><br><p>  The process of disconnecting the user from the board is almost the same  First, let's update the <code>Monitor</code> by adding the necessary client function and the corresponding server callback function to it: </p><br><div class="spoiler">  <b class="spoiler_title">/lib/phoenix_trello/board_channel/monitor.ex</b> <div class="spoiler_text"><pre> <code class="hljs vbscript"># /lib/phoenix_trello/board_channel/monitor.ex defmodule PhoenixTrello.BoardChannel.Monitor <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use GenServer ##### # Client API # ... def member_left(board, member) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GenServer.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(__MODULE__, {:member_left, board, member}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ##### # <span class="hljs-built_in"><span class="hljs-built_in">Server</span></span> callbacks # ... def handle_call({:member_left, board, member}, _from, state) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> new_members = state |&gt; Map.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(board) |&gt; List.delete(member) state = state |&gt; Map.update!(board, fn(_) -&gt; new_members <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) {:reply, new_members, state} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  As you can see, this is almost the same functionality as <code>member_join</code> , but deployed in reverse order.  The function searches the board for the condition and deletes the participant, and then replaces the current list of board members with a new one and returns it in the reply.  Just as in the case of the connection, we will call this function from the <strong>BoardChannel</strong> , so let's update it: </p><br><pre> <code class="hljs vbscript"># /web/channels/board_channel.ex defmodule PhoenixTrello.BoardChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :channel # ... def terminate(_reason, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board_id = Board.slug_id(socket.assigns.board) user_id = socket.assigns.current_user.id broadcast! socket, <span class="hljs-string"><span class="hljs-string">"user:left"</span></span>, %{users: Monitor.user_left(board_id, user_id)} :ok <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  When the connection to the channel is interrupted, the handler will send the updated list of participants via the socket, as we did before.  To interrupt the connection to the channel, we will create an action creator, which we will use when unmounting the current board view;  we also need to add a handler for mailing <code>user:left</code> : </p><br><div class="spoiler">  <b class="spoiler_title">/web/static/js/actions/current_board.js</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/web/static/js/actions/current_board.js import Constants from '../constants'; const Actions = { /</span></span>/ ... connectToChannel: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket, boardId)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { const channel = socket.channel(`<span class="javascript"><span class="javascript">boards:${boardId}</span></span>`); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... channel.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'user:left'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.CURRENT_BOARD_CONNECTED_USERS, users: msg.users, }); }); }; }, leaveChannel: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { channel.leave(); }; }, }</code> </pre> </div></div><br><p>  Do not forget to update the <code>BoardShowView</code> component in order to process the <code>leaveChannel</code> action constructor <code>leaveChannel</code> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /web</span></span><span class="hljs-regexp"><span class="hljs-regexp">/static/js</span></span><span class="hljs-regexp"><span class="hljs-regexp">/views/boards</span></span><span class="hljs-regexp"><span class="hljs-regexp">/show.js import Actions from '../</span></span>../actions/current_board<span class="hljs-string"><span class="hljs-string">'; // ... class BoardsShowView extends React.Component { // ... componentWillUnmount() { const { dispatch, currentBoard} = this.props; dispatch(Actions.leaveChannel(currentBoard.channel)); } } // ...</span></span></code> </pre> <br><p>  And that is all!  To test the result, simply open two different browsers and log in to the application with different users.  Then go to the same board in both and play, logging in and out of the board by one of the users.  You'll see how the transparency of his avatar will change back and forth, which is pretty cool. </p><br><p>  I hope you enjoyed working with <strong>GenServer</strong> just as I did the first time.  But we have affected only a small part.  <strong>GenServer</strong> and <strong>Supervisor</strong> are very rich tools from the proposed <strong>Elixir</strong> , and fully integrated and bulletproof <em>(in the original, the author uses the term bullet proof, implying, apparently, Erlang / Elixir functionality for tracking the life cycle of processes and restarting them if necessary - interpreter )</em> that do not require third-party dependencies to work with ‚Äî in contrast, for example, <strong>Redis</strong> .  In the following part, we will continue to create lists and cards in real time using sockets and pipes. </p><br><a name="11"></a><br><h2 id="dobavlyaem-spiski-i-kartochki">  Add lists and cards </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-11">Original</a> </p><br><p>  In the previous section, we created a simple but already useful mechanism for tracking connected users to the channel using <strong>OTP</strong> and <strong>GenServer</strong> functionality.  We also learned to send this list through the channel, so that each participant will be able to see who else is viewing the board at the same time.  Now it's time to allow participants to add a few cards and lists, while changes will appear on their screens immediately ... Let's do it! </p><br><h3 id="migracii-i-modeli">  Migrations and models </h3><br><p>  A board can have several lists ( <strong>lists</strong> ), which, in turn, can also have several cards, so let's keep this in mind and start by generating the <code>List</code> model using the following <code>mix</code> task in the console: </p><br><pre> <code class="hljs ruby">$ mix phoenix.gen.model List lists <span class="hljs-symbol"><span class="hljs-symbol">board_id:</span></span><span class="hljs-symbol"><span class="hljs-symbol">references:</span></span>board <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span>string ... ... $ mix ecto.migrate</code> </pre> <br><p>  By this we will create in the database table <code>lists</code> and the corresponding model: </p><br><pre> <code class="hljs pgsql"># web/models/list.ex defmodule PhoenixTrello.List <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Board, List} @derive {Poison.Encoder, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>: [:id, :board_id, :<span class="hljs-type"><span class="hljs-type">name</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "lists" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> field :<span class="hljs-type"><span class="hljs-type">name</span></span>, :string belongs_to :board, Board timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @required_fields ~w(<span class="hljs-type"><span class="hljs-type">name</span></span>) @optional_fields ~w() def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The generation of the <code>Card</code> model is very similar: </p><br><pre> <code class="hljs ruby">$ mix phoenix.gen.model Card cards <span class="hljs-symbol"><span class="hljs-symbol">list_id:</span></span><span class="hljs-symbol"><span class="hljs-symbol">references:</span></span>lists <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span>string ... ... $ mix ecto.migrate</code> </pre> <br><p>  The resulting model will look something like this: </p><br><pre> <code class="hljs pgsql"># web/models/card.ex defmodule PhoenixTrello.Card <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Repo, List, Card} @derive {Poison.Encoder, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>: [:id, :list_id, :<span class="hljs-type"><span class="hljs-type">name</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "cards" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> field :<span class="hljs-type"><span class="hljs-type">name</span></span>, :string belongs_to :list, List timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @required_fields ~w(<span class="hljs-type"><span class="hljs-type">name</span></span> list_id) @optional_fields ~w() def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Do not forget to add a set of cards to the scheme <code>lists</code> : </p><br><pre> <code class="hljs vbscript"># web/models/list.ex defmodule PhoenixTrello.List <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... @derive {Poison.Encoder, only: [:id, :board_id, :name, :cards]} # ... schema <span class="hljs-string"><span class="hljs-string">"lists"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # .. has_many :cards, Card <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Now we can move forward to the frontend and create the necessary components. </p><br><h3 id="komponent-formy-spiska">  List form component </h3><br><p>  Before continuing, let's recall the <code>render</code> function of the <code>BoardsShowView</code> component: </p><br><div class="spoiler">  <b class="spoiler_title">web / static / js / views / boards / show.js</b> <div class="spoiler_text"><pre> <code class="hljs xml">// web/static/js/views/boards/show.js //... //... _renderLists() { const { lists, channel, id, addingNewCardInListId } = this.props.currentBoard; return lists.map((list) =&gt; { return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ListCard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{list.id}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">boardId</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{id}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dispatch</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.props.dispatch}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">channel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{channel}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">isAddingNewCard</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{addingNewCardInListId</span></span></span><span class="hljs-tag"> === </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">list.id}</span></span></span><span class="hljs-tag"> {</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...list</span></span></span><span class="hljs-tag">} /&gt;</span></span> ); }); } render() { const { fetching, name } = this.props.currentBoard; if (fetching) return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"view-container boards show"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">i</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fa fa-spinner fa-spin"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ); return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"view-container boards show"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"view-header"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>{name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> {::this._renderMembers()} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvas-wrapper"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvas"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lists-wrapper"</span></span></span><span class="hljs-tag">&gt;</span></span> {::this._renderLists()} {::this._renderAddNewList()} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {this.props.children} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ); }</code> </pre> </div></div><br><p>  In contrast to the <code>BoardMembers</code> component that we created last, we also need to draw all the lists related to the current board.  At the moment we have no lists, so let's move on to the <code>_renderAddNewList</code> function: </p><br><div class="spoiler">  <b class="spoiler_title">web / static / js / views / boards / show.js</b> <div class="spoiler_text"><pre> <code class="hljs xml">// web/static/js/views/boards/show.js // ... _renderAddNewList() { const { dispatch, formErrors, currentBoard } = this.props; if (!currentBoard.showForm) return this._renderAddButton(); return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ListForm</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dispatch</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{dispatch}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">errors</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{formErrors}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">channel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{currentBoard.channel}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onCancelClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{::this._handleCancelClick}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ); } _renderAddButton() { return ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"list add-new"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{::this._handleAddNewClick}</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inner"</span></span></span><span class="hljs-tag">&gt;</span></span> Add new list... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ); } _handleAddNewClick() { const { dispatch } = this.props; dispatch(Actions.showForm(true)); } _handleCancelClick() { this.props.dispatch(Actions.showForm(false)); } // ...</code> </pre> </div></div><br><p>  The <code>_renderAddNewList</code> function first checks whether the <code>currentBoard.showForm</code> property is set to <code>true</code> , so that it <code>currentBoard.showForm</code> <em>Add New List ...</em> button instead of the <code>ListForm</code> component. </p><br><p>  When the user clicks a button, the corresponding action (action) will be sent to the repository and set the <code>showForm</code> property to <code>true</code> , which will cause the form to display.  Now create a form component: </p><br><div class="spoiler">  <b class="spoiler_title">web / static / js / components / lists / form.js</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// web/static/js/components/lists/form.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { PropTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/lists'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ListForm extends React.Component { componentDidMount() { this.refs.name.focus(); } _handleSubmit(e) { e.preventDefault(); const { dispatch, channel } = this.props; const { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.refs; const data = { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, }; dispatch(Actions.save(channel, data)); } _handleCancelClick(e) { e.preventDefault(); this.props.onCancelClick(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="list form"&gt; &lt;div className="inner"&gt; &lt;form id="new_list_form" onSubmit={::this._handleSubmit}&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="name" id="list_name" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" placeholder="Add a new list..." required="true"/&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;Save list&lt;/button&gt; <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> &lt;a href="#" onClick={::this._handleCancelClick}&gt;cancel&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; ); } }</code> </pre> </div></div><br><img src="https://habrastorage.org/files/84b/6dd/5b4/84b6dd5b4c9b4da18d0a31dd033ce6f1.jpg"><br><p><br>  This is a very simple component with a form containing a text field for the list name, a submit button, and a cancel link that will direct the same action that we described, but setting the <code>showForm</code> to <code>false</code> to hide the form.  When the form is submitted, the component, along with the username, will send the action constructor <code>save</code> , which will send the name to the <code>BoardChannel</code> channel <code>lists:create</code> <code>BoardChannel</code> : </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web/static/js/actions/lists.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const Actions = { save: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { channel.push(<span class="hljs-string"><span class="hljs-string">'lists:create'</span></span>, { list: data }); }; }, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> <br><h3 id="boardchannel">  Board channel </h3><br><p>  The next step is to teach <code>BoardChannel</code> handle <code>lists:create</code> message, so let's do this: </p><br><div class="spoiler">  <b class="spoiler_title">web / channels / board_channel.ex</b> <div class="spoiler_text"><pre> <code class="hljs lua"># web/channels/board_channel.ex defmodule PhoenixTrello.BoardChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... def handle_in(<span class="hljs-string"><span class="hljs-string">"lists:create"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"list"</span></span> =&gt; list_params}, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board = socket.assigns.board changeset = board |&gt; build_assoc(:lists) |&gt; List.changeset(list_params) case Repo.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, list} -&gt; list = Repo.<span class="hljs-built_in"><span class="hljs-built_in">preload</span></span>(list, [:cards]) broadcast! socket, <span class="hljs-string"><span class="hljs-string">"list:created"</span></span>, %{list: list} {:noreply, socket} {:<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>, _changeset} -&gt; {:reply, {:<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>, %{<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: <span class="hljs-string"><span class="hljs-string">"Error creating list"</span></span>}}, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Using the board attached to the channel, the function will build a changeset for the <code>List</code> model based on the received parameters ( <code>list_params</code> ) and add it to the database.  If everything is <code>:ok</code> , the created list will be sent via the channel to <strong>all connected users</strong> , including the creator, so we do not need to answer something, and we simply return <code>:noreply</code> .  If by some miracle an error occurs while adding a new list, an error message will be returned <strong>only to the creator</strong> , so that he will know that something has gone wrong. </p><br><h3 id="preobrazovatel">  Converter </h3><br><p>  We are almost done with the lists.  The channel sends the created sheet, so we add a handler to the frontend in the action constructor of the current board where the connection to the channel occurred: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/actions/current_board.js import Constants from '../constants'; const Actions = { /</span></span>/ ... connectToChannel: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket, boardId)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { const channel = socket.channel(`<span class="javascript"><span class="javascript">boards:${boardId}</span></span>`); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... channel.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'list:created'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.CURRENT_BOARD_LIST_CREATED, list: msg.list, }); }); }; }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... }</code> </pre> <br><p>  Finally, we need to update the converter (reducer) of the board to add the list to the new version of the state, which it returns: </p><br><pre> <code class="hljs lua">// web/static/js/reducers/current_board.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = initialState, action = {})</span></span></span></span> { switch (action.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { //... case Constants.CURRENT_BOARD_LIST_CREATED: const lists = [...state.lists]; lists.push(action.list); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, lists: lists, showForm: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; // ... } }</code> </pre> <br><p>  We also need to set the <code>showForm</code> attribute to <code>false</code> to automatically hide the form and show the <em>Add New List</em> button again <em>...</em> along with the list we just created: </p><br><img src="https://habrastorage.org/files/947/041/bbf/947041bbf48b466c98c2329e3111ac03.jpg"><br><p><br></p><br><h3 id="komponent-list">  Component <code>List</code> </h3><br><p>  Now there is at least one list on the board, and we can create the <code>List</code> component, which we will use for drawing: </p><br><div class="spoiler">  <b class="spoiler_title">/web/static/js/components/lists/card.js</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/web/static/js/components/lists/card.js import React, {PropTypes} from 'react'; import Actions from '../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/actions/current_board'; import CardForm from '../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/components/cards/form'; import Card from '../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/components/cards/card'; export default class ListCard extends React.Component { /</span></span>/ ... _renderForm() { const { isAddingNewCard } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isAddingNewCard) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; let { id, dispatch, formErrors, channel } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;CardForm listId={id} dispatch={dispatch} errors={formErrors} channel={channel} onCancelClick={::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._hideCardForm} onSubmit={::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._hideCardForm}/&gt; ); } _renderAddNewCard() { const { isAddingNewCard } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAddingNewCard) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;a className=<span class="hljs-string"><span class="hljs-string">"add-new"</span></span> href=<span class="hljs-string"><span class="hljs-string">"#"</span></span> onClick={::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._handleAddClick}&gt;Add a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> card...&lt;/a&gt; ); } _handleAddClick(e) { e.preventDefault(); const { dispatch, id } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; dispatch(Actions.showCardForm(id)); } _hideCardForm() { const { dispatch } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; dispatch(Actions.showCardForm(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)); } render() { const { id, connectDragSource, connectDropTarget, connectCardDropTarget, isDragging } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; const styles = { display: isDragging ? <span class="hljs-string"><span class="hljs-string">'none'</span></span> : <span class="hljs-string"><span class="hljs-string">'block'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div id={`<span class="javascript"><span class="javascript">list_${id}</span></span>`} className=<span class="hljs-string"><span class="hljs-string">"list"</span></span> style={styles}&gt; &lt;div className=<span class="hljs-string"><span class="hljs-string">"inner"</span></span>&gt; &lt;header&gt; &lt;h4&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.name}&lt;/h4&gt; &lt;/header&gt; &lt;div className=<span class="hljs-string"><span class="hljs-string">"cards-wrapper"</span></span>&gt; {::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderCards()} &lt;/div&gt; &lt;footer&gt; {::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderForm()} {::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderAddNewCard()} &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; ); } }</code> </pre> </div></div><br><p>  In the same way as in the case of lists, first focus on drawing the form of cards.  In general, we will use the same approach to drawing or hiding a form, using the property ( <code>prop</code> ), transmitted by the main component of the board, and directing the action to change this property of the state. </p><br><img src="https://habrastorage.org/files/88a/f14/b5b/88af14b5bcdc476c8412ff424541c24c.jpg"><br><p><br></p><br><h3 id="komponent-formy-kartochki">  Card Form Component </h3><br><p>  This component will be very similar to the <code>ListForm</code> component: </p><br><div class="spoiler">  <b class="spoiler_title">/web/static/js/components/cards/form.js</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// /web/static/js/components/cards/form.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { PropTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/lists'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PageClick <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-page-click'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CardForm extends React.Component { _handleSubmit(e) { e.preventDefault(); let { dispatch, channel } = this.props; let { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.refs; let data = { list_id: this.props.listId, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, }; dispatch(Actions.createCard(channel, data)); this.props.onSubmit(); } componentDidMount() { this.refs.name.focus(); } _handleCancelClick(e) { e.preventDefault(); this.props.onCancelClick(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;PageClick onClick={::this._handleCancelClick}&gt; &lt;div className="card form"&gt; &lt;form id="new_card_form" onSubmit={::this._handleSubmit}&gt; &lt;textarea <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="name" id="card_name" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" required="true" <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>={<span class="hljs-number"><span class="hljs-number">5</span></span>}/&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>&lt;/button&gt; <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> &lt;a href="#" onClick={::this._handleCancelClick}&gt;cancel&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/PageClick&gt; ); } }</code> </pre> </div></div><br><p>  As before, when sending a form, we send an action to create a card with the name provided by the user.  For this, the action constructor will send a new message to the channel: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /web</span></span><span class="hljs-regexp"><span class="hljs-regexp">/static/js</span></span><span class="hljs-regexp"><span class="hljs-regexp">/actions/lists</span></span>.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const Actions = { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-symbol"><span class="hljs-symbol">createCard:</span></span> (channel, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { channel.push(<span class="hljs-string"><span class="hljs-string">'cards:create'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">card:</span></span> data }); }; }, }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br><p>  Let's add a handler to <code>BoardChannel</code> : </p><br><pre> <code class="hljs vbscript"> # web/channels/board_channel.ex def handle_in(<span class="hljs-string"><span class="hljs-string">"cards:create"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"card"</span></span> =&gt; card_params}, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board = socket.assigns.board changeset = board |&gt; assoc(:lists) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(card_params[<span class="hljs-string"><span class="hljs-string">"list_id"</span></span>]) |&gt; build_assoc(:cards) |&gt; Card.changeset(card_params) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Repo.insert(changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, card} -&gt; broadcast! socket, <span class="hljs-string"><span class="hljs-string">"card:created"</span></span>, %{card: card} {:noreply, socket} {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, _changeset} -&gt; {:reply, {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: <span class="hljs-string"><span class="hljs-string">"Error creating card"</span></span>}}, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In the same way that creating a list, a new <code>Card</code> entry will be created by associating with the board attached to the channel, and with the list passed as a parameter.  If the creation was successful, the recording will be forwarded to all participants connected to the channel.  Finally, add a callback function to the <strong>js</strong> channel: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ web/static</span></span><span class="hljs-regexp"><span class="hljs-regexp">/js/actions</span></span><span class="hljs-regexp"><span class="hljs-regexp">/current_board.js /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/... channel.on('card:created', (msg) =&gt; { dispatch({ type: Constants.CURRENT_BOARD_CARD_CREATED, card: msg.card, }); }); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ...</span></span></code> </pre> <br><p>  And add a new card to the state through the converter: </p><br><pre> <code class="hljs coffeescript"> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/reducers/current_board.js /</span></span>/ ... case Constants.CURRENT_BOARD_CARD_CREATED: lists = [...state.lists]; const { card } = action; const listIndex = lists.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.id == card.list_id; }); lists[listIndex].cards.push(card); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, lists: lists }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br><p>  And it's all!  The card will appear on the screen of each connected participant. </p><br><img src="https://habrastorage.org/files/4b3/195/7cb/4b31957cb2bd4396b6d139a8c76e01ed.jpg"><br><p><br></p><br><h3 id="chto-teper">  Now what? </h3><br><p>  In this section, we completed the creation of the basic functionality required for user registration, logging in, creating boards, inviting other people to them, and working in real time by adding lists and cards.  The final version in the repository has significantly more features, such as editing lists, sorting lists and cards by moving them, displaying more detailed information about the cards, where you can also assign participants to them and even add comments and color labels, but we will not detail talk about none of them, otherwise it would be a perpetual training.  :-D </p><br><p>  But do not worry, there is one more part left, where we will talk about how to share the result with the whole world, putting it on <strong>Heroku</strong> . </p><br><a name="12"></a><br><h2 id="vykladyvaem-proekt-na-heroku">  We spread the project on Heroku </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-12">Original</a> </p><br><p>  We finally did it <em>(and I, too, approx. Translator)</em> .  After 5 <em>(in the original - 11 - approx. Translator)</em> publications, we learned how to set up a new <strong>Phoenix</strong> project with <strong>Webpack</strong> , <strong>React</strong> and <strong>Redux</strong> .  We created a secure authentication system based on <strong>JWT</strong> tokens, created <strong>migrations</strong> for our database schemas required, programmed sockets and channels for real-time functionality, and built the <strong>GenServer</strong> process to track connected board members.  It is time to share all this with the world, putting the project on <strong>Heroku</strong> .  Let's do that! </p><br><h3 id="nastraivaem-heroku">  Customize Heroku </h3><br><p>  Before moving on, suppose that we already have a <strong>Heroku</strong> account and the <a href="https://toolbelt.heroku.com/">Heroku Toolbelt installed</a> .  To put the <strong>Phoenix</strong> application on <strong>Heroku</strong> , we need to use two different <em>buildpacks</em> (build sets), so we will create a new application using <a href="https://github.com/ddollar/heroku-buildpack-multi">multi-buildpack</a> : </p><br><pre> <code class="hljs pgsql">$ heroku <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> phoenix-trello <span class="hljs-comment"><span class="hljs-comment">--buildpack https://github.com/ddollar/heroku-buildpack-multi</span></span></code> </pre> <br><p>      <strong>Heroku</strong>    git- <code>heroku</code> ,     .    ,   Phoenix       : </p><br><ol><li> <a href="https://github.com/HashNuke/heroku-buildpack-elixir">heroku-buildpack-elixir</a> :      Elixir. </li><li> <a href="https://github.com/gjaldon/heroku-buildpack-phoenix-static">heroku-buildpack-phoenix-static</a> :    . </li></ol><br><p>   <code>.buildpacks</code>    : </p><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta"># .buildpacks https:</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//github.com/HashNuke/heroku-buildpack-elixir https://github.com/gjaldon/phoenix-static-buildpack</span></span></span></span></code> </pre> <br><p>      ,     Elixir,    ,   <code>elixir_buildpack.config</code> : </p><br><pre> <code class="hljs pgsql"># elixir_buildpack.config # Elixir <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> elixir_version=<span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span> rebuild <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scratch <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> every deploy? always_rebuild=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><p>       Elixir,        ,  ,   .            <code>phoenix_static_buildpack.config</code> : </p><br><pre> <code class="hljs pgsql"># phoenix_static_buildpack.config # We can <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Node <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the app here node_version=<span class="hljs-number"><span class="hljs-number">5.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> # We can <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> NPM <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the app here npm_version=<span class="hljs-number"><span class="hljs-number">3.5</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span></code> </pre> <br><p>        <strong>Webpack</strong>  <code>node</code>  <code>npm</code> .        <code>compile</code> ,    ,       : </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta"># compile info </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Building Phoenix static assets"</span></span></span><span class="hljs-meta"> webpack mix phoenix.digest</span></span></code> </pre> <br><p>  ,    <a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Digest.html">mix-</a> <code>phoenix.digest</code>   <code>webpack</code> ,       . </p><br><h3 id="nastroyka-rabochego-okruzheniya">    </h3><br><p> ,    ,    <code>prod.exs</code> ,    : </p><br><pre> <code class="hljs lua"># <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/prod.exs use Mix.Config # ... <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :phoenix_trello, PhoenixTrello.Endpoint, # .. url: [scheme: <span class="hljs-string"><span class="hljs-string">"https"</span></span>, host: <span class="hljs-string"><span class="hljs-string">"phoenix-trello.herokuapp.com"</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>], # .. secret_key_base: System.get_env(<span class="hljs-string"><span class="hljs-string">"SECRET_KEY_BASE"</span></span>) # .. # Configure your database <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :phoenix_trello, PhoenixTrello.Repo, # .. url: System.get_env(<span class="hljs-string"><span class="hljs-string">"DATABASE_URL"</span></span>), pool_size: <span class="hljs-number"><span class="hljs-number">20</span></span> # Configure guardian <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :guardian, Guardian, secret_key: System.get_env(<span class="hljs-string"><span class="hljs-string">"GUARDIAN_SECRET_KEY"</span></span>)</code> </pre> <br><p> ,    :   URL   Heroku  SSL-.       ,   <code>secret_key_base</code> ,     ( <code>url</code> )  <code>secret_key</code>  guardian.       Heroku    ,           ,   : </p><br><pre> <code class="hljs ruby">$ mix phoenix.gen.secret xxxxxxxxxx $ heroku <span class="hljs-symbol"><span class="hljs-symbol">config:</span></span>set SECRET_KEY_BASE=<span class="hljs-string"><span class="hljs-string">"xxxxxxxxxx"</span></span> ... ... $ mix phoenix.gen.secret yyyyyyyyyyy $ heroku <span class="hljs-symbol"><span class="hljs-symbol">config:</span></span>set GUARDIAN_SECRET_KEY=<span class="hljs-string"><span class="hljs-string">"yyyyyyyyyyy"</span></span> ... ...</code> </pre> <br><p>     ! </p><br><h3 id="publikaciya">  Publication </h3><br><p>             : </p><br><pre> <code class="hljs perl">$ git <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> heroku master ... ... ...</code> </pre> <br><p>      ,  ,        ,  <strong>Erlang</strong>  <strong>Elixir</strong>    ,    <strong>node</strong> , <strong>npm</strong>   . ,         : </p><br><pre> <code class="hljs ruby">$ heroku run mix ecto.migrate</code> </pre> <br><p>    ,       ! </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>   <strong>Phoenix</strong>  <strong>Heroku</strong>    .      ,        . ,         ,   .            ,       .     ,    <a href="https://phoenix-trello.herokuapp.com/"> </a>   <a href="https://github.com/bigardone/phoenix-trello"> </a>  . </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS As always, please report typos in any way. </font><font style="vertical-align: inherit;">If you have the best wording of any phrase - do not be lazy to write to me, at least in a personal, at least in the comment, I will update it. </font><font style="vertical-align: inherit;">Well, the answer to the question of whether to continue such publications, will give a rating of the material.</font></font></strong> </p></cut></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/316108/">https://habr.com/ru/post/316108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316098/index.html">Inside NetBeans. Prologue</a></li>
<li><a href="../316100/index.html">Connecting the character LCD to the board from WD MyBook Live on AppliedMicro APM82181. Ending</a></li>
<li><a href="../316102/index.html">Banana Pi - backup server</a></li>
<li><a href="../316104/index.html">How IT professionals work. Anton Petrochenko, Panasonic Russia</a></li>
<li><a href="../316106/index.html">A boring one-line calculator on sed</a></li>
<li><a href="../316110/index.html">‚ÄúLead me better‚Äù: What will make the work of a novice programmer more effective</a></li>
<li><a href="../316112/index.html">Operating system from scratch (almost)</a></li>
<li><a href="../316116/index.html">Why does a good design start earlier than the first pictures?</a></li>
<li><a href="../316118/index.html">Publisher Peter. Black Friday 2016</a></li>
<li><a href="../316120/index.html">Technologies from the ‚ÄúBlack Mirror‚Äù, which are already with us</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>