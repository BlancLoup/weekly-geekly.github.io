<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Xonix to Javascript with pictures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Xonix is a popular DOS game, a Qix video game clone. 

 Xonix has already been ported to Javascript several times. The best and closest to the origina...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Xonix to Javascript with pictures</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://ru.wikipedia.org/wiki/Xonix">Xonix</a> is a popular DOS game, a <a href="https://ru.wikipedia.org/wiki/Qix">Qix</a> video game clone. <br><br>  Xonix has already been ported to Javascript several times.  The best and closest to the original of the existing implementations to date, perhaps, <a href="http://html5xonix.appspot.com/">this one</a> .  At first I tried to adapt it for my implementation / modification ... But, unfortunately, the code even after deobfuscation did not become clear (at least for me).  In addition, as far as I could understand, the code there is in places not entirely effective, or outdated.  So I had to write everything from scratch. <br><br>  As a result, I got such a "own" Xonix, with pictures and answers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/305/6f3/839/3056f383922a4cb39bbb36ecf431057d.png"></div><a name="habracut"></a><br><br>  <a href="http://demos.savreen.com/picxonix/">Demo</a> |  <a href="https://github.com/hindmost/picxonix">Sources</a> <br><br>  The code turned out to be quite voluminous, so here I will explain not everything, but only the most important (from my point of view) moments. <br><br>  As you know, the playing field Xonix is ‚Äã‚Äãa grid of square cells.  At the beginning of the game (level) most of the field is occupied by a rectangular black area ("sea"), which is surrounded by a light frame ("land") on all sides. <br><br>  The main difference between my implementation and the classic Xonix is ‚Äã‚Äãthat behind the black area there is a picture that is unique for each level.  By this, she is like another modification of Xonix - Sexonix.  But in my picture does not appear just like that.  This is part of the question to be answered.  And the whole game thus turns into a quiz. <br><br>  The size of the image determines the size of the black area, which must be a multiple of the cell size.  In the general case, the pictures for different levels of the game can have different sizes, therefore the dimensions of the black area can vary from level to level, in contrast to the light frame, which at the beginning of the level always has a fixed width of 2 cells. <br><br>  The movement of all objects ( <i>cursor</i> and <i>points</i> ) occurs strictly in the cells, so that at each moment in time each object occupies exactly one cell.  This structure of the playing field greatly simplifies the implementation of the game.  The difficulty is only the definition of "conquered" areas, formed when the cursor crosses the "sea", but more on that later. <br><br><h3>  The movement of objects </h3><br>  The fact that we can take a cell as a ‚Äúpixel‚Äù eliminates most of the computational problems that are commonly found in games with many moving objects: motion calculations, bounces and collisions, etc. <br><br>  In Xonix, any object has only 4 directions of movement: for the cursor - up / down / left / right, for a point (of both types) - the same, only diagonally.  We combine these options into many possible directions, which will be given in degrees.  We get 8 angles of motion: from 0 to 315 degrees in increments of 45. To each angle value, we assign a pair of motion direction vector coordinates.  The result is a structure that we will use when calculating the motion: <br><br><div class="spoiler">  <b class="spoiler_title">Code snippet</b> <div class="spoiler_text"><pre><code class="javascript hljs">dirset = { <span class="hljs-attr"><span class="hljs-attr">vecs</span></span>: { <span class="hljs-number"><span class="hljs-number">0</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">45</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">90</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">135</span></span>: [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">180</span></span>: [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">225</span></span>: [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-number"><span class="hljs-number">270</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-number"><span class="hljs-number">315</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vecs? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vecs[v] : [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; }, <span class="hljs-attr"><span class="hljs-attr">find</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ x = x == <span class="hljs-number"><span class="hljs-number">0</span></span>? <span class="hljs-number"><span class="hljs-number">0</span></span> : (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>); y = y == <span class="hljs-number"><span class="hljs-number">0</span></span>? <span class="hljs-number"><span class="hljs-number">0</span></span> : (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vecs) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vec = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vecs[v]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] == x &amp;&amp; vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] == y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(v); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } };</code> </pre> </div></div><br>  The <code>get</code> method returns the corresponding motion vector for a given angle (in degrees).  The <code>find</code> method does the opposite: for a given motion vector (not necessarily a single), it returns the corresponding angle in degrees, or the closest available angle to it. <br><br>  Collisions of points with each other can be ignored, just let them ‚Äúpass‚Äù through each other.  Since all points (of the same type) look the same, from the outside it will be no different from collision and rebound. <br><br>  To calculate collisions of points with a cursor, rebound of points from the border of "their" area and some other things, we need a <i>matrix of states of</i> all cells - a two-dimensional array <code>(n+4) * (m+4)</code> , <br>  where <code>(n+4)</code> , <code>(m+4)</code> is the width and height of the playing field in the cells, respectively, and the first element of the matrix corresponds to the cell in the upper left corner of the playing field. <br><br>  Each element will store the state of the corresponding cell, which includes 2 signs: the type of area to which it belongs (sea / land), as well as whether there is a ‚Äútrace‚Äù on it at the moment from the cursor movement over the ‚Äúsea‚Äù.  This state will be stored in a two-bit <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25B5">bit field</a> .  To do this, we need to declare two mask constants for each attribute, respectively: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CA_CLEAR = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  , ..    var CA_TRAIL = 1 &lt;&lt; 1; //  -      ""</span></span></code> </pre><br>  In order to optimize, we will make the array of states not two-dimensional, but one-dimensional, so that all elements will be stored line by line, starting with the first (top) line.  To convert cell coordinates into an array index and inverse transform we will use the following formulas: <br><br><pre> <code class="javascript hljs">i = n * (y + <span class="hljs-number"><span class="hljs-number">2</span></span>) + x + <span class="hljs-number"><span class="hljs-number">2</span></span>; x = i % n - <span class="hljs-number"><span class="hljs-number">2</span></span>; y = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(i / n) - <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  To calculate the rebound point ("sea" or "land") from the border of "our" area, we need to know the state of the three cells, not counting the cell of the point itself.  Below, using pseudographics, the position of these cells relative to the current cell of the point is shown at a 45 degree angle of motion. <br><br><pre> OOO
 OX1
 O23
</pre><br>  The cell of a point is marked with a cross, and the desired cells are numbered 1, 2, 3. Zeroes just represent neighboring cells.  The direction of motion of the point in this case is southeast, since the ordinate axis (Y) of the grid is directed downwards. <br><br>  A rebound from the border occurs if at least one of the three cells indicated has the type of area opposite to the type of point.  Those.  if, for example, the "sea" point, then one of these cells must be "land".  At the same time, if this condition is satisfied only in one of the cells 1 or 2 (but not in both), then the angle of motion is added, respectively, <code>+90</code> or <code>-90</code> degrees.  Otherwise, the angle of movement is reversed ( <code>+180</code> degrees). <br><br>  At any other angle of motion, the logic of the rebound will obviously be exactly the same. <br><br>  Collision of a point with a cursor leads to pausing the game, after which the cursor and the ‚Äúland‚Äù points return to their original starting positions for the game: the cursor - to the middle cell in the second row, the ‚Äúland‚Äù points depending on their number - in the bottom and side parts of the frame .  The position of the "sea" points does not change. <br><br>  The definition of a collision of a ‚Äúland‚Äù point with a cursor is trivial.  Just check the contact point with the cursor, comparing the coordinates of the point and cursor cells.  Determining the collision of the ‚Äúsea‚Äù point with the cursor is a bit more difficult: we need to check not only the contact of the point itself with the cursor, but also the touch of the track of the cursor movement.  To do this, use the second bit of the state of the cells: we check it on all the cells adjacent to the point. <br><br><h3>  Definition of "conquered" areas </h3><br>  As already mentioned, the most difficult thing to implement is the definition of areas ‚Äúconquered‚Äù from the ‚Äúsea‚Äù.  These are the closed areas formed as a result of the intersection of the ‚Äúsea‚Äù cursor, within which there are no ‚Äúsea‚Äù points.  In most cases, two closed areas are formed, which are obtained by dividing (following the cursor movement) the available ‚Äúsea‚Äù area into two parts, of which only one or ‚Äúnone‚Äù becomes ‚Äúconquered‚Äù (see screenshot 1).  But in some, especially difficult cases, a multitude of closed (see screenshot 2), including ‚Äúconquered‚Äù areas, can be formed at once.  In addition, it is possible that the trace of the cursor itself forms a closed area (see screenshot 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e52/ecf/8b2/e52ecf8b200f4857a2c9b4fdab3984ef.png"></div>  <i>Screenshot 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b0b/f25/124/b0bf2512491e4bb3b0fb205d47070832.png"></div>  <i>Screenshot 2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aef/d42/e45/aefd42e45a5245a1a7482c286fa86059.png"></div>  <i>Screenshot 3</i> <br><br>  So, we need to find all such closed areas, and then determine the type of each of them ("conquered" / "undefeated"). <br><br>  To find closed areas, you can iterate through all the cells using some general algorithm for comparing neighboring cells.  For example, as implemented <a href="http://habrahabr.ru/post/122029/">here</a> . <br><br>  But there is another way (which I ultimately chose): to use the contours of closed areas formed when the cursor is crossing the "sea".  The <i>contour</i> refers to a closed polyline with a thickness of one cell.  If the contour of the closed area is known, then it remains only to find its contents, i.e.  all the cells inside it.  But how to find these contours? <br><br><h4>  Outlines of closed areas </h4><br>  In the general case, we only know about each desired contour that it has a partial intersection with the trace of the cursor movement, i.e.  contains at least one cell trace cursor.  In most cases, as shown in screenshot 1, exactly two contours are formed, each of which contains the entire trace of the entire cursor (all its cells).  But in some cases, as in screenshot 2, there may be many such contours, and many of them may contain only a portion of the cursor trace cells.  In addition, it is necessary to consider the cases when the entire trace of the cursor itself forms a closed loop (screenshot 3).  Thus, it is necessary, on the basis of the data about the trace of the cursor, to obtain all the information about the contours of the closed regions adjoining it, while checking as few cells as possible. <br><br>  Considering the various options for the distribution of contours, you can find several patterns.  First, the number of contours containing the entire trace of the entire cursor is always no more than 2. Secondly, if all the contours are divided into 2 groups on opposite sides of the cursor trace, the contours of one group will not have common trace cells.  In other words, each cell of the cursor trace belongs to only one contour on each side of the track. <br><br>  Based on the above, it is possible to derive an algorithm for finding contours.  In general terms, it looks like this. <br><br>  We loop through all the cells that belong to the trace of the cursor, starting with the first one (that is, from the beginning of the movement).  For each cell of the track, we check two adjacent cells on both sides of it (to the left and to the right in the direction of motion).  If the cell is ‚Äúmarine‚Äù, then this is part of the contour of one of the areas sought.  Otherwise, we continue searching until we find a ‚Äúmarine‚Äù cell on this side of the track.  From the found cell, you can extend the entire circuit adjacent to it.  To do this, go from this cell first in the direction from the trace cell, and then in such a direction that at least on one side of the current cell there is always a ‚Äúland‚Äù cell (in this case, the current cell must be ‚Äúmarine‚Äù).  And so on until a trace cell is encountered, which means that the contour is closed.  Add to the passed cells a part of the trace cells needed to close the broken line, and we get the desired contour. <br><br>  After this, we continue the external cycle of iterating the cells of the trace, starting with the one on which the procedure for finding the contour from one cell stopped above. <br><br>  It should be noted that the procedures for finding the contours on both sides of the track should be performed independently of each other.  This means that the loop for iterating over the cells of a trace needs to be wrapped into one more cycle of 2 iterations ‚Äî one for each side. <br><br>  It is possible that no circuit will be found from either side.  This means that the trail of movement is adjacent to the border of the "marine" area.  In this case, we will have a unique closed domain consisting only of the trace itself. <br><br>  If there is a situation from screenshot 3, all contours found must be added to the contour formed by the whole trace of the cursor. <br><br><h4>  Content and type of closed area </h4><br>  Now that the outlines of the closed areas have been found, it is necessary to determine the content of the corresponding area (all cells contained in it) and its type (‚Äúconquered‚Äù or not) for each contour.  Since the cursor can only move vertically / horizontally in Xonix, each closed area can be divided into several rectangles of different sizes.  Thus, the task of determining the contents of a closed area is reduced to finding the rectangles that constitute it.  By the way, by this we ‚Äúkill‚Äù at once two ‚Äúbirds with one stone‚Äù: we make it easier to count the points inside the closed areas, as well as to paint over (or rather erase) the ‚Äúconquered‚Äù areas. <br><br>  To find the rectangles, it is enough to know the vertices of the contour of the region, i.e.  vertices of a polygon. <br><br>  The basic idea is to cut off a protruding rectangle with the greatest width or height from each area at each iteration.  A <i>speaker</i> here is a rectangle whose three vertices belong to the original polygon.  Based on this, we can derive an algorithm for partitioning a closed area into rectangles.  It looks like this. <br><br>  At the first iteration we find the side (segment) of the polygon with the greatest length, which is part of the protruding rectangle.  If there are several such segments, choose any of them.  The found segment will be one of the sides of the required rectangle.  Now we need to find the rest of his hand.  To do this, take the segments emanating from both ends of the found side perpendicular to it, and choose the shortest one.  This will be the second side of the rectangle.  To find the third side, you need to find the (orthogonal) projection of the second end of this segment onto the second of the segments that are perpendicular to the first side.  Connect the found point with the corresponding end of the first side and get the third side.  From here we get the entire desired outlined rectangle.  Now we need to cut it off from the original polygon.  To do this, remove the first and second found segments and the corresponding vertices from the polygon, then add the found projection point, connecting it with the vertex that was previously connected to the second found segment.  As a result, we obtain a polygon having two vertices smaller than the original one. <br><br>  At the next iteration, we will work with a trimmed polygon according to the same scheme as in the first iteration ... And so on until we get a polygon from 4 vertices as a result, ie  rectangle. <br><br>  All the rectangles cut off in the considered process will make up the contents of the closed area. <br><br>  Consider the process of splitting into rectangles on a specific example. <br>  Suppose we have a polygon <code>ABCDEFGHIJKL</code> (see Fig. 1), which is the contour of a region.  We apply the stepwise described partitioning algorithm. <br><br>  1. Find the side of the polygon <code>ABCDEFGHIJKL</code> with the greatest length.  This is a piece of <code>CD</code> with a length of 4. But it does not suit us, because  not part of the protruding rectangle.  Therefore, ignore it and look for further.  Find 3 segments with a length of 3: <code>AL</code> , <code>FG</code> , <code>GH</code> .  <code>GH</code> doesn't suit us for the same reason as <code>CD</code> .  So there are segments <code>AL</code> , <code>FG</code> .  Choose any of them.  Let it be <code>AL</code> .  The segments perpendicular to it are <code>AB</code> and <code>KL</code> , of which the shortest is <code>AB</code> .  Find the projection of point <code>B</code> on the segment <code>KL</code> - this is point <code>M</code> (see fig. 2).  Thus we obtain a clip rectangle - <code>ABML</code> .  After it is cut off, the polygon <code>CDEFGHIJKM</code> remains. <br><br>  2. Find the side of the <code>CDEFGHIJKM</code> polygon with the longest length.  This is a <code>FG</code> segment with a length of 3 ... The intersecting rectangle is <code>FGNE</code> (see Fig. 2).  After it is cut off, the polygon <code>CDNHIJKM</code> remains. <br><br>  3. Find the side of the <code>CDNHIJKM</code> polygon with the longest length.  This is already familiar to us segment of <code>CD</code> with a length of 4 ... Cut-off rectangle - <code>CDNO</code> .  After it is cut off, the <code>OHIJKM</code> polygon <code>OHIJKM</code> . <br><br>  4. Find the side of the <code>OHIJKM</code> polygon with the greatest length.  There are two such sides.  These are the <code>OH</code> and <code>HI</code> segments with a length of 2. Choose the first of them, <code>OH</code> ... The cut-off rectangle is <code>OHPM</code> .  After it is cut off, the <code>KPIJ</code> rectangle <code>KPIJ</code> .  Now there is nothing to cut off.  So the algorithm ends here. <br><br>  As a result, we get 5 rectangles that make up the contents of a closed area: <code>ABML</code> , <code>FGNE</code> , <code>CDNO</code> , <code>OHPM</code> and <code>KPIJ</code> (see Fig. 2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/22d/6bc/c49/22d6bcc491ab40b0a7a7831618441bdc.png"></div>  <i>Fig.</i>  <i>one</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ae7/c2f/59c/ae7c2f59cf504d1cbc272513777c7757.png"></div>  <i>Fig.</i>  <i>2</i> <br><br>  After the closed areas are found, it is necessary to determine the type of each of them (whether it is ‚Äúconquered‚Äù or not).  The type of area is determined by counting the "sea" points inside it.  It is not necessary to count all the points inside the region, it is enough just to find out if at least one point is there.  If there is, then this area is not ‚Äúconquered‚Äù (and, accordingly, we do not erase it), because there should not be a single point in the ‚Äúconquered‚Äù area. <br><br>  Determining whether a polygon of arbitrary shape contains a point with a given position (coordinates) is, in general, very difficult.  But we also divided the polygon into rectangles in order to facilitate this task as well.  Unlike an arbitrary polygon, determining whether a point belongs to a rectangle is a trivial task.  You just need to check the belonging of each coordinate of this point to the corresponding range of borders of the rectangle. <br><br>  Thus, the task of determining the type of a closed area is reduced to the search for "sea" points inside each of the rectangles that make up this area. <br><br>  All found "conquered" areas are subject to erasure, which is implemented even more trivially: simply erase (using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect">clearRect</a> method) all the rectangles that make up this area. <br><br><h3>  Animation, game management and more </h3><br>  The title is a bit deceiving).  The article has already come to an end, so, unfortunately, none of the above will be there.  I can only note that I wrote the animation code on the basis of <a href="http://jlongster.com/Making-Sprite-based-Games-with-Canvas">this article</a> ( <a href="http://habrahabr.ru/post/184666/">translation</a> ), as well as <a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/">this</a> ( <a href="http://habrahabr.ru/post/114358/">translation</a> ). <br><br>  For those who are interested, below is the entire code of the game.  However, its value is questionable, because  comments there - the cat cried.  But I hope I explained the main logic. <br><br><div class="spoiler">  <b class="spoiler_title">Game code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// requestAnimationFrame/cancelAnimationFrame polyfill: (function() { var tLast = 0; var vendors = ['webkit', 'moz']; for(var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) { var v = vendors[i]; window.requestAnimationFrame = window[v+'RequestAnimationFrame']; window.cancelAnimationFrame = window[v+'CancelAnimationFrame'] || window[v+'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) { var tNow = Date.now(); var dt = Math.max(0, 17 - tNow + tLast); var id = setTimeout(function() { callback(tNow + dt); }, dt); tLast = tNow + dt; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) { clearTimeout(id); }; }()); (function() { window.picxonix = function(v1, v2) { if (typeof v1 != 'string') { return init(v1, v2); } switch (v1) { case 'level': //    loadLevel(v2); break; case 'end': //   endLevel(v2); break; case 'play': // /  setPlayMode(v2); break; case 'cursorDir': //    typeof v2 == 'string'? setDir(v2) : setDirToward(v2); break; case 'cursorSpeed': //    setCursorSpeed(v2); break; case 'enemySpeed': //    setEnemySpeed(v2); break; case 'enemySpawn': //     spawn(); break; case 'state': //    return buildLevelState(); default: } return 0; } var cfgMain = { width: 600, height: 400, sizeCell: 10, colorFill: '#000000', colorBorder: '#00aaaa', colorBall: '#ffffff', colorBallIn: '#000000', colorWarder: '#000000', colorWarderIn: '#f80000', colorCursor: '#aa00aa', colorCursorIn: '#00aaaa', colorTrail: '#a800a8', timeoutCollision: 1000, callback: null, callbackOnFrame: false }; var cfgLevel = { nBalls: 1, nWarders: 1, speedCursor: 5, speedEnemy: 5 }; // cell attributes: var CA_CLEAR = 1 &lt;&lt; 0; var CA_TRAIL = 1 &lt;&lt; 1; // : var sizeCell; var width, height; // : var elContainer; var ctxPic; var ctxMain; var imgPic; var imgBall; var imgWarder; var imgCursor; //  : var dirset; var cellset; var cursor; var aBalls = [], aWarders = []; var nBalls = 0, nWarders = 0; //   : var idFrame = 0; var tLevel = 0; var tLastFrame = 0; var tLocked = 0; var bCollision = false; var bConquer = false; var dirhash = { 'left': 180, 'right': 0, 'up': 270, 'down': 90, 'stop': false }; function init(el, opts) { if (elContainer || !el || !el.appendChild) return false; elContainer = el; //    : merge(cfgMain, opts); if (!cfgMain.sizeCell) return false; sizeCell = cfgMain.sizeCell; if (typeof cfgMain.callback != 'function') cfgMain.callback = null; //   : if (opts.speedCursor ^ opts.speedEnemy) { opts.speedCursor = opts.speedEnemy = Math.max(opts.speedCursor || 0, opts.speedEnemy || 0); } merge(cfgLevel, opts); setLevelData(cfgMain.width, cfgMain.height); var oWrap = document.createElement('div'); oWrap.style.position = 'relative'; //    (): (function() { var canvas = document.createElement('canvas'); ctxPic = canvas.getContext('2d'); canvas.width = width; canvas.height = height; canvas.style.position = 'absolute'; canvas.style.left = canvas.style.top = (2*sizeCell) + 'px'; ctxPic.fillStyle = cfgMain.colorTrail; ctxPic.fillRect(0, 0, width, height); oWrap.appendChild(canvas); }()); //    : (function() { var canvas = document.createElement('canvas'); ctxMain = canvas.getContext('2d'); canvas.width = width+ 4*sizeCell; canvas.height = height+ 4*sizeCell; canvas.style.position = 'absolute'; canvas.style.left = canvas.style.top = 0; fillCanvas(); ctxMain.fillStyle = cfgMain.colorFill; ctxMain.fillRect(2*sizeCell, 2*sizeCell, width, height); oWrap.appendChild(canvas); }()); elContainer.appendChild(oWrap); //   : var canvas = document.createElement('canvas'); var ctxTmp = canvas.getContext('2d'); canvas.width = sizeCell; canvas.height = sizeCell; //    : var r = sizeCell / 2, q = sizeCell / 4; ctxTmp.clearRect(0, 0, sizeCell, sizeCell); ctxTmp.beginPath(); ctxTmp.arc(r, r, r, 0, Math.PI * 2, false); ctxTmp.fillStyle = cfgMain.colorBall; ctxTmp.fill(); if (cfgMain.colorBallIn) { ctxTmp.beginPath(); ctxTmp.arc(r, r, q, 0, Math.PI * 2, false); ctxTmp.fillStyle = cfgMain.colorBallIn; ctxTmp.fill(); } imgBall = new Image(); imgBall.src = ctxTmp.canvas.toDataURL(); function prepareSquare(colorOut, colorIn) { ctxTmp.clearRect(0, 0, sizeCell, sizeCell); ctxTmp.fillStyle = colorOut; ctxTmp.fillRect(0, 0, sizeCell, sizeCell); if (colorIn) { ctxTmp.fillStyle = colorIn; ctxTmp.fillRect(q, q, sizeCell - r, sizeCell - r); } } //    : prepareSquare(cfgMain.colorWarder, cfgMain.colorWarderIn); imgWarder = new Image(); imgWarder.src = ctxTmp.canvas.toDataURL(); //   : prepareSquare(cfgMain.colorCursor, cfgMain.colorCursorIn); imgCursor = new Image(); imgCursor.src = ctxTmp.canvas.toDataURL(); return {width: width+ 4*sizeCell, height: height+ 4*sizeCell}; } function loadLevel(data) { if (tLevel || tLastFrame || !data || !data.image) return; if (!data.image) return; var img = new Image(); img.onload = function() { applyLevel(img, data); }; img.src = data.image; } function applyLevel(img, data) { imgPic = img; merge(cfgLevel, data, true); setLevelData(img.width, img.height); ctxMain.canvas.width = width+ 4*sizeCell; ctxMain.canvas.height = height+ 4*sizeCell; fillCanvas(); cellset.reset(); ctxPic.canvas.width = width; ctxPic.canvas.height = height; ctxPic.drawImage(imgPic, 0, 0, width, height, 0, 0, width, height); var pos = cellset.placeCursor(); cursor.reset(pos[0], pos[1]); aBalls = []; aWarders = []; var i, aPos; aPos = cellset.placeBalls(nBalls); for (i = 0; i &lt; nBalls; i++) aBalls.push(new Enemy(aPos[i][0], aPos[i][1], false)); aPos = cellset.placeWarders(nWarders); for (i = 0; i &lt; nWarders; i++) aWarders.push(new Enemy(aPos[i][0], aPos[i][1], true, 45)); tLevel = Date.now(); tLastFrame = 0; startLoop(); } function endLevel(bClear) { if (tLastFrame) return; tLevel = 0; if (!bClear) return; fillCanvas(); ctxMain.clearRect(2*sizeCell, 2*sizeCell, width, height); } function setLevelData(w, h) { if (w) width = w - w % (2*sizeCell); if (h) height = h - h % (2*sizeCell); if (cfgLevel.nBalls) nBalls = cfgLevel.nBalls; if (cfgLevel.nWarders) nWarders = cfgLevel.nWarders; } function setPlayMode(bOn) { if (bOn ^ !tLastFrame) return; tLastFrame? endLoop() : startLoop(); } function setDir(key) { if (!tLastFrame) return; if (key in dirhash) cursor.setDir(dirhash[key]); } function setDirToward(pos) { if (!tLastFrame || !pos || pos.length &lt; 2) return; var xc = Math.floor(pos[0] / sizeCell) - 2, yc = Math.floor(pos[1] / sizeCell) - 2; var b = cellset.isPosValid(xc, yc); if (!b) return; var posCr = cursor.pos(), dirCr = cursor.getDir(), dir = false; if (dirCr === false) { var dx = xc - posCr[0], dy = yc - posCr[1], dc = Math.abs(dx) - Math.abs(dy); if (dc == 0) return; dir = dirset.find(dx, dy); if (dir % 90 != 0) { var dir1 = dir-45, dir2 = dir+45; dir = dir1 % 180 == 0 ^ dc &lt; 0? dir1 : dir2; } } else { var delta = dirCr % 180? xc - posCr[0] : yc - posCr[1]; if (!delta) return; dir = (delta &gt; 0? 0 : 180) + (dirCr % 180? 0 : 90); } cursor.setDir(dir); } function setCursorSpeed(v) { if (v &gt; 0) cfgLevel.speedCursor = v; } function setEnemySpeed(v) { if (v &gt; 0) cfgLevel.speedEnemy = v; } function startLoop() { if (!tLevel) return; idFrame = requestAnimationFrame(loop); } function endLoop() { if (idFrame) cancelAnimationFrame(idFrame); tLastFrame = idFrame = 0; } //    function loop(now) { var dt = tLastFrame? (now - tLastFrame) / 1000 : 0; bCollision = bConquer = false; if (!tLastFrame || update(dt)) { render(); tLastFrame = now; } if (bCollision) { lock(); cfgMain.callback &amp;&amp; cfgMain.callback(1); return; } if (bConquer) { bConquer = false; tLastFrame = 0; cellset.conquer(); if (cfgMain.callback &amp;&amp; cfgMain.callback(2)) return; } else cfgMain.callback &amp;&amp; cfgMain.callbackOnFrame &amp;&amp; cfgMain.callback(0); startLoop(); } function update(dt) { var distCursor = Math.round(dt * cfgLevel.speedCursor), distEnemy = Math.round(dt * cfgLevel.speedEnemy); if (!(distCursor &gt;= 1 || distEnemy &gt;= 1)) return false; cursor.update(distCursor); var i; for (i = 0; i &lt; nBalls; i++) aBalls[i].update(distEnemy); for (i = 0; i &lt; nWarders; i++) aWarders[i].update(distEnemy); return true; } function render() { cellset.render(); cursor.render(); var i; for (i = 0; i &lt; nBalls; i++) aBalls[i].render(); for (i = 0; i &lt; nWarders; i++) aWarders[i].render(); } function lock() { tLastFrame = 0; bCollision = false; var posCr = cursor.pos(); cellset.add2Trail(posCr[0], posCr[1], false); setTimeout(unlock, cfgMain.timeoutCollision); } function unlock() { if (!tLevel) return; cellset.clearTrail(); var pos = cellset.placeCursor(); cursor.reset(pos[0], pos[1], true); var aPos = cellset.placeWarders(nWarders); for (var i = 0; i &lt; nWarders; i++) aWarders[i].reset(aPos[i][0], aPos[i][1]); startLoop(); } function spawn() { if (!tLevel) return; var pos = cellset.placeSpawned(); if (!pos) return; aWarders.push(new Enemy(pos[0], pos[1], true)); nWarders++; } function buildLevelState() { return { play: Boolean(tLastFrame), posCursor: cursor.pos(), warders: nWarders, speedCursor: cfgLevel.speedCursor, speedEnemy: cfgLevel.speedEnemy, cleared: cellset.getPercentage() }; } function fillCanvas() { ctxMain.fillStyle = cfgMain.colorBorder; ctxMain.fillRect(0, 0, width+ 4*sizeCell, height+ 4*sizeCell); } function drawCellImg(img, x, y) { ctxMain.drawImage(img, 0, 0, sizeCell, sizeCell, (x+2)*sizeCell, (y+2)*sizeCell, sizeCell, sizeCell ); } function clearCellArea(x, y, w, h) { ctxMain.clearRect( (x+2)*sizeCell, (y+2)*sizeCell, (w || 1)* sizeCell, (h || 1)* sizeCell ); } function fillCellArea(color, x, y, w, h) { ctxMain.fillStyle = color; ctxMain.fillRect( (x+2)*sizeCell, (y+2)*sizeCell, (w || 1)* sizeCell, (h || 1)* sizeCell ); } //   : dirset = { vecs: { 0: [1, 0], 45: [1, 1], 90: [0, 1], 135: [-1, 1], 180: [-1, 0], 225: [-1, -1], 270: [0, -1], 315: [1, -1] }, get: function(v) { return v in this.vecs? this.vecs[v] : [0, 0]; }, find: function(x, y) { x = x == 0? 0 : (x &gt; 0? 1 : -1); y = y == 0? 0 : (y &gt; 0? 1 : -1); for (var v in this.vecs) { var vec = this.vecs[v]; if (vec[0] == x &amp;&amp; vec[1] == y) return parseInt(v); } return false; } }; //    : cellset = { nW: 0, nH: 0, nWx: 0, nCleared: 0, dirTrail: 0, iPreTrail: 0, aCells: [], aTrail: [], aTrailNodes: [], aTrailRects: [], reset: function() { var nW = this.nW = Math.floor(width / sizeCell); var nH = this.nH = Math.floor(height / sizeCell); var n = (this.nWx = nW+4)* (nH+4); this.nCleared = 0; this.aCells = []; var aAll = []; for (var i = 0; i &lt; n; i++) { var pos = this.pos(i), x = pos[0], y = pos[1]; this.aCells.push(x &gt;= 0 &amp;&amp; x &lt; nW &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; nH? 0 : CA_CLEAR); aAll.push(i); } fillCellArea(cfgMain.colorFill, 0, 0, nW, nH); }, render: function() { if (this.aTrailRects.length) { for (var i = this.aTrailRects.length-1; i &gt;= 0; i--) { fillCellArea.apply(null, [cfgMain.colorFill].concat(this.aTrailRects[i])); } this.aTrailRects = []; } }, isPosIn: function(x, y) { return x &gt;= 0 &amp;&amp; x &lt; this.nW &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; this.nH; }, isPosValid: function(x, y) { return x &gt;= -2 &amp;&amp; x &lt; this.nW+2 &amp;&amp; y &gt;= -2 &amp;&amp; y &lt; this.nH+2; }, find: function(x, y) { return this.isPosValid(x, y) ? (this.nWx)*(y+2) + x+2 : -1; }, pos: function(i) { return [i % this.nWx - 2, Math.floor(i / this.nWx)-2]; }, posMap: function(arr) { var _this = this; return arr.map(function(v) { return _this.pos(v) }); }, value: function(x, y) { var i = this.find(x,y); return i &gt;= 0? this.aCells[i] : 0; }, set: function(x, y, v) { var i = this.find(x,y); if (i &gt;= 0) this.aCells[i] = v; return i; }, setOn: function(x, y, v) { var i = this.find(x,y); if (i &gt;= 0) this.aCells[i] |= v; return i; }, setOff: function(x, y, v) { var i = this.find(x,y); if (i &gt;= 0) this.aCells[i] &amp;= ~v; return i; }, placeCursor: function() { return [Math.floor(this.nW/2), -2]; }, placeBalls: function(n) { var a = [], ret = []; for (var i = 0; i &lt; n; i++) { var k; do k = Math.floor(Math.random() * this.nW * this.nH); while (a.indexOf(k) &gt;= 0); a.push(k); var x = k % this.nW, y = Math.floor(k / this.nW); ret.push([x, y]); } return ret; }, placeWarders: function(n) { var z; var aPos = [ [Math.floor(this.nW/2), this.nH+1], [-1, this.nH+1], [this.nW, this.nH+1], [-1, -2], [this.nW, -2], [-1, z = Math.floor(this.nH/2)], [this.nW, z], [z = Math.floor(this.nW/4), this.nH+1], [3*z, this.nH+1] ]; var i0 = (n+ 1)% 2; return aPos.slice(i0, Math.min(n+ i0, 9)); }, placeSpawned: function() { if (nWarders &gt;= 9) return false; function dist(pos1, pos2) { return Math.pow(pos1[0]- pos2[0], 2) + Math.pow(pos1[1]- pos2[1], 2); } function find(pos0) { var n = nWarders; for (var l = 0; l &lt; x0; l++) { for (var dx = -1; dx &lt;= 1; dx+= 2) { var p = [pos0[0]+ l* dx, pos0[1]]; for (var i = 0; i &lt; n &amp;&amp; dist(aWarders[i].pos(), p) &gt;= 4; i++) ; if (i &gt;= n) return p; } } return pos0; } var x0 = Math.floor(this.nW/2); var aPos = [[x0, this.nH+1], [x0, -2]]; var posCr = cursor.pos(); var posSt = dist(aPos[0], posCr) &gt; dist(aPos[1], posCr)? aPos[0] : aPos[1]; var ret = find(posSt); return ret; }, applyRelDirs: function(x, y, dir, aDeltas) { var ret = []; for (var n = aDeltas.length, i = 0; i &lt; n; i++) { var d = (dir + aDeltas[i] + 360) % 360; var vec = dirset.get(d), xt, yt; ret.push([xt = x + vec[0], yt = y + vec[1], d, this.value(xt, yt)]); } return ret; }, add2Trail: function(x, y, dir) { var i = this.setOn(x, y, CA_TRAIL); if (i &lt; 0) return; var n = this.aTrail.length; if (!n || dir !== this.dirTrail) { var iNode = n? this.aTrail[n-1] : i; if (!n || iNode != this.aTrailNodes[this.aTrailNodes.length-1]) this.aTrailNodes.push(iNode); if (!n) { var aPos = this.applyRelDirs(x, y, dir, [180]); this.iPreTrail = this.find(aPos[0][0], aPos[0][1]); } } this.aTrail.push(i); this.dirTrail = dir; }, lastTrailLine: function() { var pos0 = this.pos(this.aTrailNodes[this.aTrailNodes.length-1]), pos = this.pos(this.aTrail[this.aTrail.length-1]); return [ Math.min(pos[0], pos0[0]), Math.min(pos[1], pos0[1]), Math.abs(pos[0] - pos0[0])+1, Math.abs(pos[1] - pos0[1])+1 ]; }, clearTrail: function() { this.aTrailRects = this._buildTrailRects(); for (var n = this.aTrail.length, i = 0; i &lt; n; i++) { this.aCells[this.aTrail[i]] &amp;= ~CA_TRAIL; } this.aTrail = []; this.aTrailNodes = []; }, getPreTrail: function() { return this.iPreTrail; }, conquer: function() { var nTrail = this.aTrail.length; if (!nTrail) return; if (nTrail &gt; 1) this.aTrailNodes.push(this.aTrail[nTrail-1]); var aConqRects = this._conquer() || this._buildTrailRects(); this.aTrail = []; this.aTrailNodes = []; if (!aConqRects || !aConqRects.length) return; for (var n = aConqRects.length, i = 0; i &lt; n; i++) { var rect = aConqRects[i]; var x0 = rect[0], y0 = rect[1], w = rect[2], h = rect[3]; for (var x = 0; x &lt; w; x++) { for (var y = 0; y &lt; h; y++) { if (this.value(x + x0, y + y0, CA_CLEAR) &amp; CA_CLEAR) continue; this.set(x + x0, y + y0, CA_CLEAR); this.nCleared++; } } } for (i = 0; i &lt; n; i++) { clearCellArea.apply(null, aConqRects[i]); } aConqRects = []; }, getPercentage: function() { return this.nCleared / (this.nW * this.nH) * 100; }, _conquer: function() { var nTrail = this.aTrail.length, nNodes = this.aTrailNodes.length; var dz = Math.abs(this.aTrailNodes[0] - this.aTrailNodes[nNodes-1]); var aOutlineset = [], bClosedTrail = false; if (bClosedTrail = nNodes &gt;= 4 &amp;&amp; dz == 1 || dz == this.nWx) { aOutlineset.push([this.aTrailNodes, 1]); } var bAddTrail = false; var posPre = this.pos(this.iPreTrail), posCr = cursor.pos(); var aDeltas = [-90, 90]; for (var d = 0; d &lt; 2; d++) { var dd = aDeltas[d]; var k = 0; var sum = 0, bSum = false, bEndAtNode = false; for (var l = 0; l &lt; nTrail &amp;&amp; sum &lt; nTrail; l++) { var iStart = this.aTrail[l]; var pos = this.pos(iStart); var pos0 = l? this.pos(this.aTrail[l - 1]) : posPre; var x = pos[0], y = pos[1]; var dir = (dirset.find(x - pos0[0], y - pos0[1]) + dd + 360) % 360; var aDirs = bEndAtNode? [] : [dir]; if (this.aTrailNodes.indexOf(iStart) &gt;= 0) { var pos2 = l &lt; nTrail - 1? this.pos(this.aTrail[l + 1]) : posCr; dir = (dirset.find(pos2[0] - x, pos2[1] - y) + dd + 360) % 360; if (dir != aDirs[0]) aDirs.push(dir); } if (this.aTrail[l] == this.aTrailNodes[k+1]) ++k; var ret = 0; for (var nDs = aDirs.length, j = 0; j &lt; nDs &amp;&amp; !ret; j++) { dir = aDirs[j]; var vec = dirset.get(dir); var xt = x + vec[0], yt = y + vec[1]; var v = this.value(xt, yt); if (v &amp; CA_CLEAR || v &amp; CA_TRAIL) continue; ret = this._outline(xt, yt, dir); if (!ret || ret.length &lt; 3) return false; } bEndAtNode = false; if (!ret) continue; var len = ret[0], aNodes = ret[1], bClosed = ret[2], iEnd = aNodes[aNodes.length-1]; if (bClosed) { aOutlineset.push([aNodes, len]); bSum = true; continue; } var aXtra = [iStart]; for (var i = l+1; i &lt; nTrail &amp;&amp; this.aTrail[i] != iEnd; i++) { if (this.aTrail[i] == this.aTrailNodes[k+1]) aXtra.push(this.aTrailNodes[++k]); } if (i &gt;= nTrail) continue; aOutlineset.push([aNodes.concat(aXtra.reverse()), len + i - l]); sum += i - l + 1; l = (bEndAtNode = this.aTrail[i] == this.aTrailNodes[k+1])? i-1 : i; } if (!sum &amp;&amp; !bSum &amp;&amp; !bClosedTrail) return false; if (sum &lt; nTrail &amp;&amp; !bClosedTrail) bAddTrail = true; } if (!aOutlineset.length) return false; aOutlineset.sort(function (el1, el2) { return el1[1] - el2[1]; }); var aRects = [], n = aOutlineset.length, b = false; for (i = 0; i &lt; n; i++) { if (i == n- 1 &amp;&amp; !b) break; ret = this._buildConquerRects(aOutlineset[i][0]); if (ret) aRects = aRects.concat(ret); else b = true; } if (!aRects.length) return false; return bAddTrail? aRects.concat(this._buildTrailRects()) : aRects; }, _outline: function(x0, y0, dir) { var aNodes = [], aUniqNodes = [], aUsedDirs = [], aBackDirs = []; var x = x0, y = y0, lim = 6 * (this.nW + this.nH), n = 0, bClosed = false; function isClear(arr) { return arr[3] &amp; CA_CLEAR; } do { bClosed = n &amp;&amp; x == x0 &amp;&amp; y == y0; var iCurr = this.find(x,y), iUniq = aUniqNodes.indexOf(iCurr); var aCurrUsed = iUniq &gt;= 0? aUsedDirs[iUniq] : []; var aCurrBack = iUniq &gt;= 0? aBackDirs[iUniq] : []; var aPosOpts = this.applyRelDirs(x,y, dir, [-90, 90, 0]); var aTestDirs = [180+45, -45, 45, 180-45, -45, 45]; var aPassIdx = [], aPassWeight = []; for (var i = 0; i &lt; 3; i++) { var d = aPosOpts[i][2]; if (aCurrUsed.indexOf(d) &gt;= 0) continue; if (isClear(aPosOpts[i])) continue; var aTestOpts = this.applyRelDirs(x,y, dir, aTestDirs.slice(i*2,i*2+2)); var b1 = isClear(aTestOpts[0]), b2 = isClear(aTestOpts[1]); var b = b1 || b2 || (i == 2? isClear(aPosOpts[0]) || isClear(aPosOpts[1]) : isClear(aPosOpts[2])); if (!b) continue; aPassIdx.push(i); aPassWeight.push( (b1 &amp;&amp; b2? 0 : b1 || b2? 1 : 2) + (aCurrBack.indexOf(d) &gt;= 0? 3 : 0) ); } var nPass = aPassIdx.length; var min = false, idx = false; for (i = 0; i &lt; nPass; i++) { if (!i || aPassWeight[i] &lt; min) { min = aPassWeight[i]; idx = aPassIdx[i]; } } var pos = nPass? aPosOpts[idx] : this.applyRelDirs(x,y, dir, [180])[0]; var dir0 = dir; x = pos[0]; y = pos[1]; dir = pos[2]; if (pos[2] == dir0) continue; nPass? aNodes.push(iCurr) : aNodes.push(iCurr, iCurr); dir0 = (dir0 + 180) % 360; if (iUniq &lt; 0) { aUniqNodes.push(iCurr); aUsedDirs.push([dir]); aBackDirs.push([dir0]); } else { aUsedDirs[iUniq].push(dir); aBackDirs[iUniq].push(dir0); } } while (n++ &lt; lim &amp;&amp; !(this.value(x, y) &amp; CA_TRAIL)); if (!(n &lt; lim)) return false; if (bClosed) { aNodes.push(iCurr); if (aNodes[0] != (iCurr = this.find(x0,y0))) aNodes.unshift(iCurr); var nNodes = aNodes.length; if (nNodes % 2 &amp;&amp; aNodes[0] == aNodes[nNodes-1]) aNodes.pop(); } else aNodes.push(this.find(x,y)); return [n+1, aNodes, bClosed]; }, _buildTrailRects: function() { if (this.aTrailNodes.length == 1) this.aTrailNodes.push(this.aTrailNodes[0]); var aRects = []; for (var n = this.aTrailNodes.length, i = 0; i &lt; n-1; i++) { var pos1 = this.pos(this.aTrailNodes[i]), pos2 = this.pos(this.aTrailNodes[i+1]); var x0 = Math.min(pos1[0], pos2[0]), y0 = Math.min(pos1[1], pos2[1]); var w = Math.max(pos1[0], pos2[0]) - x0 + 1, h = Math.max(pos1[1], pos2[1]) - y0 + 1; var rect = [x0, y0, w, h]; aRects.push(rect); } return aRects; }, _buildConquerRects: function(aOutline) { if (aOutline.length &lt; 4) return false; var aNodes = this.posMap(aOutline); var n = aNodes.length; if (n &gt; 4 &amp;&amp; n % 2 != 0) { var b1 = aNodes[0][0] == aNodes[n-1][0], b2; if (b1 ^ aNodes[0][1] == aNodes[n-1][1]) { b2 = aNodes[n-2][0] == aNodes[n-1][0]; if (!(b2 ^ b1) &amp;&amp; b2 ^ aNodes[n-2][1] == aNodes[n-1][1]) aNodes.pop(); b2 = aNodes[0][0] == aNodes[1][0]; if (!(b2 ^ b1) &amp;&amp; b2 ^ aNodes[0][1] == aNodes[1][1]) aNodes.shift(); } b1 = aNodes[0][0] == aNodes[1][0]; b2 = aNodes[1][0] == aNodes[2][0]; if (!(b1 ^ b2) &amp;&amp; b1 ^ aNodes[0][1] == aNodes[1][1] &amp;&amp; b2 ^ aNodes[1][1] == aNodes[2][1]) aNodes.shift(); } if (aNodes.length % 2 != 0) return false; var aRects = []; for (var l = 0; l &lt; 10 &amp;&amp; aNodes.length &gt; 4; l++) { n = aNodes.length; var dim1 = 0, dim2 = 0, iBase = 0, iCo = 0; var posB1, posB2, posT1, posT2; for (var i = 0; i &lt; n; i++) { posB1 = aNodes[i]; posB2 = aNodes[(i+1)%n]; posT1 = aNodes[(i-1+n)%n]; posT2 = aNodes[(i+2)%n]; var dir = dirset.find(posT1[0]-posB1[0], posT1[1]-posB1[1]); if (dir != dirset.find(posT2[0]-posB2[0], posT2[1]-posB2[1])) continue; var dirTest = Math.floor((dirset.find(posB2[0]-posB1[0], posB2[1]-posB1[1])+ dir) / 2); var vec = dirset.get(dirTest - dirTest% 45); if (this.value([posB1[0]+ vec[0], posB1[1]+ vec[1]]) &amp; CA_CLEAR) continue; var b = false, t, w, k; if ((t = Math.abs(posB1[0]-posB2[0])) &gt; dim1) { b = true; k = 0; w = t; } if ((t = Math.abs(posB1[1]-posB2[1])) &gt; dim1) { b = true; k = 1; w = t; } if (!b) continue; var k2 = (k+1)%2; vec = dirset.get(dir); var sgn = vec[k2]; var co2 = posB1[k2]; var left = Math.min(posB1[k], posB2[k]), right = Math.max(posB1[k], posB2[k]); var min = Math.min(sgn* (posT1[k2]- co2), sgn* (posT2[k2]- co2)); for (var j = i% 2; j &lt; n; j+= 2) { if (j == i) continue; var pos = aNodes[j], pos2 = aNodes[(j+1)%n], h; if (pos[k2] == pos2[k2] &amp;&amp; (h = sgn*(pos[k2]- co2)) &gt;= 0 &amp;&amp; h &lt; min &amp;&amp; pos[k] &gt; left &amp;&amp; pos[k] &lt; right &amp;&amp; pos2[k] &gt; left &amp;&amp; pos2[k] &lt; right) break; } if (j &lt; n) continue; dim1 = w; dim2 = sgn*min; iBase = i; iCo = k; } var iB2 = (iBase+1)%n, iT1 = (iBase-1+n)%n, iT2 = (iBase+2)%n; posB1 = aNodes[iBase]; posB2 = aNodes[iB2]; posT1 = aNodes[iT1]; posT2 = aNodes[iT2]; var aDim = [0, 0], pos0 = []; var iCo2 = (iCo+1)%2; aDim[iCo] = dim1; aDim[iCo2] = dim2; pos0[iCo] = Math.min(posB1[iCo], posB2[iCo]); pos0[iCo2] = Math.min(posB1[iCo2], posB2[iCo2]) + (aDim[iCo2] &lt; 0? aDim[iCo2]: 0); var rect = [pos0[0], pos0[1], Math.abs(aDim[0])+1, Math.abs(aDim[1])+1]; var bC = Math.abs(posT1[iCo2] - posB1[iCo2]) == Math.abs(dim2); if (this._containBall(rect)) return false; aRects.push(rect); if (bC) { posB2[iCo2] += dim2; aNodes.splice(iBase,1); aNodes.splice(iT1 &lt; iBase? iT1 : iT1-1, 1); } else { posB1[iCo2] += dim2; aNodes.splice(iT2,1); aNodes.splice(iB2 &lt; iT2? iB2 : iB2-1, 1); } } var aX = aNodes.map(function(v) {return v[0]}); var aY = aNodes.map(function(v) {return v[1]}); var x0 = Math.min.apply(null, aX); var y0 = Math.min.apply(null, aY); rect = [x0, y0, Math.max.apply(null, aX)-x0+1, Math.max.apply(null, aY)-y0+1]; if (this._containBall(rect)) return false; aRects.push(rect); return aRects; }, // ,   .   : _containBall: function(rect) { var x1 = rect[0], x2 = x1+ rect[2] - 1; var y1 = rect[1], y2 = y1+ rect[3] - 1; for (var i = 0; i &lt; nBalls; i++) { var o = aBalls[i], x = ox, y = oy; if (x &gt;= x1 &amp;&amp; x &lt;= x2 &amp;&amp; y &gt;= y1 &amp;&amp; y &lt;= y2) return true; } return false; } }; // : cursor = { x: 0, //  x  y: 0, //  y  x0: 0, //  x  y0: 0, //  y  dir: false, //    ( ) state: false, //    (true -  ) state0: false, //    //   : reset: function(x, y, bUnlock) { var bPre = bUnlock &amp;&amp; cellset.value(this.x, this.y) &amp; CA_CLEAR; this.x0 = bPre? this.x : x; this.y0 = bPre? this.y : y; this.x = x; this.y = y; this.dir = this.state = this.state0 = false; }, //   -    : update: function(dist) { if (this.dir === false) return; var x = this.x, y = this.y; var vec = dirset.get(this.dir), vecX = vec[0], vecY = vec[1]; var bEnd = false; for (var n = 0; n &lt; dist; n++) { if (cellset.find(x + vecX, y + vecY) &lt; 0) { this.dir = false; break; } x += vecX; y += vecY; if (cellset.value(x, y) &amp; CA_TRAIL) { bCollision = true; break; } var b = cellset.value(x, y) &amp; CA_CLEAR; if (this.state &amp;&amp; b) { bEnd = true; break; } this.state = !b; if (this.state) cellset.add2Trail(x, y, this.dir); } this.x = x; this.y = y; if (!bEnd) return; if (cellset.getPreTrail() == cellset.find(x,y)) bCollision = true; else { this.dir = this.state = false; bConquer = true; } }, //   : render: function() { if (this.x0 == this.x &amp;&amp; this.y0 == this.y) { if (tLastFrame) return; } else { if (this.state0) { var rect = cellset.lastTrailLine(); fillCellArea.apply(null, [cfgMain.colorTrail].concat(rect)); } else { if (cellset.isPosIn(this.x0, this.y0)) clearCellArea(this.x0, this.y0); else fillCellArea(cfgMain.colorBorder, this.x0, this.y0); } this.x0 = this.x; this.y0 = this.y; } this.state0 = this.state; drawCellImg(imgCursor, this.x, this.y); }, //   : pos: function() { return [this.x, this.y]; }, //    : getDir: function() { return this.dir; }, //   : setDir: function(dir) { if (dir === this.dir) return; if (this.state &amp;&amp; this.dir !== false &amp;&amp; Math.abs(dir - this.dir) == 180) return; this.dir = dir; } }; //    (  ): function Enemy(x, y, type, dir) { this.x = x; this.y = y; this.x0 = x; this.y0 = y; var aDirs = [45, 135, 225, 315]; this.dir = dir === undefined? aDirs[Math.floor(Math.random()*4)] : dir; //    this.type = Boolean(type); // (boolean)   (false - , true - ) } //   : Enemy.prototype = { //  : reset: function(x, y) { this.x = x; this.y = y; }, //   -    : update: function(dist) { var ret = this._calcPath(this.x, this.y, dist, this.dir); this.x = ret.x; this.y = ret.y; this.dir = ret.dir; }, //   : render: function() { if (this.x0 == this.x &amp;&amp; this.y0 == this.y) { if (tLastFrame) return; } else { if (this.type &amp;&amp; cellset.isPosIn(this.x0, this.y0)) clearCellArea(this.x0, this.y0); else fillCellArea(this.type? cfgMain.colorBorder : cfgMain.colorFill, this.x0, this.y0); this.x0 = this.x; this.y0 = this.y; } drawCellImg(this.type? imgWarder : imgBall, this.x, this.y); }, //   : pos: function() { return [this.x, this.y]; }, //    (): _calcPath: function(x, y, dist, dir) { var vec = dirset.get(dir), vecX = vec[0], vecY = vec[1]; var posCr = cursor.pos(); var xC = posCr[0], yC = posCr[1], vC = cellset.value(xC, yC), bC = !this.type ^ vC &amp; CA_CLEAR; if (bC &amp;&amp; Math.abs(x - xC) &lt;= 1 &amp;&amp; Math.abs(y - yC) &lt;= 1 || !this.type &amp;&amp; this._isCollision(x, y, dir)) { bCollision = true; } for (var n = 0; n &lt; dist &amp;&amp; !bCollision; n++) { var xt = x + vecX, yt = y + vecY; var dirB = this._calcBounce(x, y, dir, xt, yt); if (dirB !== false) return this._calcPath(x, y, dist - n, dirB); if (bC &amp;&amp; Math.abs(xt - xC) &lt;= 1 &amp;&amp; Math.abs(yt - yC) &lt;= 1 || !this.type &amp;&amp; this._isCollision(xt, yt, dir)) bCollision = true; if (!this.type &amp;&amp; !cellset.isPosIn(xt, yt)) break; x = xt; y = yt; } return {x: x, y: y, dir: dir}; }, //       ( ): _calcBounce: function(x, y, dir, xt, yt) { var ret = cellset.applyRelDirs(x,y, dir, [-45, 45]); var b1 = this.type ^ ret[0][3] &amp; CA_CLEAR, b2 = this.type ^ ret[1][3] &amp; CA_CLEAR; return b1 ^ b2? (b1? dir + 90 : dir + 270) % 360 : this.type ^ cellset.value(xt, yt) &amp; CA_CLEAR || b1 &amp;&amp; b2? (dir+180) % 360 : false; }, //     : _isCollision: function(x, y, dir) { if (cellset.value(x, y) &amp; CA_TRAIL) return true; var aDirs = [-45, 45, -90, 90]; for (var i = 0; i &lt; 4; i++) { var d = (dir + aDirs[i] + 360) % 360, vec = dirset.get(d); if (cellset.value(x + vec[0], y + vec[1]) &amp; CA_TRAIL) return true; } return false; } }; function merge(dest, src, bFilter) { if (!src) return dest; for(var key in dest) { if (!dest.hasOwnProperty(key) || !src.hasOwnProperty(key)) continue; var v = src[key]; if ((!bFilter || v) &amp;&amp; (typeof v != 'number' || v &gt;= 0)) dest[key] = v; } return dest; } })();</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For this round. </font></font> Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/261853/">https://habr.com/ru/post/261853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261835/index.html">Polymorphic bonds for the smallest</a></li>
<li><a href="../261837/index.html">STM32, C ++ and FreeRTOS. Development from scratch. Part 3 (LCD and Screens)</a></li>
<li><a href="../261847/index.html">Adaptive carousel on AngularJS</a></li>
<li><a href="../261849/index.html">Elm or functional programming for the web, understandable to the teapot</a></li>
<li><a href="../261851/index.html">Windows 10 IoT - a small overview of the new edition of the OS for small devices</a></li>
<li><a href="../261855/index.html">RTCOMM fell</a></li>
<li><a href="../261857/index.html">7 rules for creating beautiful interfaces</a></li>
<li><a href="../261859/index.html">Animation of filtering markers in Yandex Maps API</a></li>
<li><a href="../261861/index.html">Mail server on own site with postfix</a></li>
<li><a href="../261863/index.html">We write maintainable code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>