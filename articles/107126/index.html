<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Objective-C from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anyone who wants to write programs for Apple products comes to a point when he has to learn a new programming language - Objective-C. Once this happy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Objective-C from scratch</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage/f1073050/7aff6749/77739192/fd020592.png">  Anyone who wants to write programs for Apple products comes to a point when he has to learn a new programming language - Objective-C.  Once this happy moment befell me.  And in order to better remember the main features of this language, I decided to inspect my thoughts while thinking about its documentation, which I share with you. <br><a name="habracut"></a><br><h3>  Banal theory of OOP </h3><br>  The problem of reuse of written code and its portability constantly forces programmers to look for new ways to organize, structure and abstract it.  To solve these problems, new programming paradigms, design patterns, new languages, compilers and standard libraries for them, software platforms and frameworks are created.  This formed the paradigm of subroutines (procedures) implemented using the CALL \ RET processor commands and the stack (in fact, transferring the flow of execution to an arbitrary address rather than following the current command, followed by a return).  Then, the module paradigm (each file is a separate translation unit), which gave rise to a two-stage translation: compilation of modules, and then their layout (static or dynamic) into an executable module. <br><br>  As a result of the increase in the amount of code in projects and the complexity of its support, from the 1960s a new, object-oriented programming paradigm began to form, breaking up programs into even smaller components - data types.  Its essence lies in the interaction of entities (objects) by sending messages to each other.  Each object is a variable of a data type defined by the programmer (the so-called class).  The definition of such a special user data type (class) consists of two things: the definition of a data set (invariants, members) and a set of subroutines (methods) that will serve them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/29b3f167/006356ff/88414a4a/cb4d17e5.png"></div><br>  A class is usually designed as a programmer-defined type based on built-in (language) data types and / or other classes.  For a C language that does not support an object-oriented paradigm, this may be a structure (struct).  A set of subroutines is implemented as normal functions, necessarily taking at least one parameter - a pointer to a set of data to be processed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main advantage of the object-oriented approach was the ability to create new classes based on those already written (add invariants and methods, redefine methods, use methods defined in the base class as your own), called inheritance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/53e1c6cb/4d30e3d1/ecfababe/9dcb8d2a.png"></div><br>  A set of methods is an interface for interacting with invariants.  The impossibility of directly modifying class data (without using its interface) reflects the principle of encapsulation.  The figure shows the class and its objects.  There is an x ‚Äã‚Äãinvariant of type float and an interface (method) doubleX to it, which returns the value of the invariant. <br><br>  It happens that it is necessary to send a message to an object that definitely responds to it (that is, to call such an object for the class object that it has implemented), but, in a situation, the specific class of this object is unknown.  For example, each element of the list of pointers to objects of class Auto needs to send a message Move, and it is known that the list contains pointers to objects not only of class Auto, but also pointers to derived (inherited) classes Ford and Subaru.  This can be done only due to the principle of polymorphism, which means that when a certain message is sent to an object from a certain class hierarchy, in which all objects are able to receive such a message, this object responds to it according to its own class rather than the base one. <br><br>  The first language with the support of the object-oriented approach was Simula67.  Then came the Smalltalk.  And in the 80s C ++ began to take shape - the main language of modern system programming.  Its expansion and improvement in the 90s gave rise to a number of paradigms and design patterns, and had an irreversible influence on the modern vision of the object-oriented approach, including the Objective-C language. <br><br><h3>  A little bit of history </h3><br>  Objective-C appeared in the 80s as a modification of C in the direction of Smalltalk.  Moreover, this modification consisted in the addition of new syntactic constructions and a special preprocessor for them (which, passing through the code, converted them into ordinary calls of C functions), as well as a runtime library (these calls are processing).  Thus, initially Objective-C was perceived as an add-on over C. In a sense, this is still true: you can write a program in pure C, and then add to it some constructs from Objective-C (if necessary), or on the contrary, it is free to use C in programs on Objective-C.  In addition, this also applies to C ++ programs.  In 1988, NeXT (and later Apple) licensed Objective-C and wrote the compiler and the standard library for it (essentially the SDK).  In 1992, the developers of the GNU project as part of the OpenStep project joined the improvement of the language and compiler.  Since then, GCC has supported Objective-C.  After buying NeXT, Apple took their SDK (compiler, libraries, IDE) as the basis for their further development.  IDE for code was called Xcode, and for GUI - Interface Builder.  Cocoa development framework for GUI development (and not only) today is the most significant development environment for Objective-C programs. <br><br><h3>  Objective-C Features </h3><br>  Module files in Objective-C have the extension ‚Äú.m‚Äù (if a mixture of C ++ and Objective-C was used, then the extension is ‚Äú.mm‚Äù).  Header files are ‚Äú.h‚Äù.  All objects created in Objective-C should be placed in dynamic memory.  Therefore, the id type, which is a pointer to an object of any class (essentially void *), takes on particular importance.  A null pointer is called a constant nil.  Thus, a pointer to any class can be cast to type id.  The problem arises: how to find out what class the object hiding under id belongs to?  This is due to the isa invariant, which is present in any object of the class that inherited the special base class NSObject (the NS prefix denotes NeXT Step).  The isa invariant is of the reserved type Class.  An object of this type allows you to find out the names of your own and base class, a set of class invariants, as well as prototypes of all the methods that this object has implemented and their addresses (through a local list of selectors).  All Objective-C reserved words that differ from C reserved words begin with an at sign (for example, @protocol, <a href="https://habrahabr.ru/users/selector/" class="user_link">selector</a> , <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> ).  Typically, the names of invariants of classes with limited scope (@private, <a href="https://habrahabr.ru/users/protected/" class="user_link">protected</a> ) begin with an underscore.  Cocoa has very convenient NSString class for strings.  The string constant of this class is written as @ ‚ÄùHello world‚Äù, and not as the usual string ‚ÄúHello world‚Äù for C.  The type BOOL (essentially unsigned char) can take constant values ‚Äã‚ÄãYES and NO.  All special Objective-C reserved words (which are different from C and are found in the objc / objc.h header file) are listed below: <br><ul><li>  <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> Begins a class or category declaration (a category is an extension of a class with additional methods without inheritance) </li><li>  @implementation Begins class definition </li><li>  @protocol Begins a protocol declaration (similar to class C ++, consisting of pure virtual functions) </li><li>  <a href="https://habrahabr.ru/users/end/" class="user_link">end</a> Complete declaration / definition of any class, category, or protocol. </li><li>  @private Restricts the scope of class invariants to class methods (similar to C ++) </li><li>  <a href="https://habrahabr.ru/users/protected/" class="user_link">protected</a> It is by default.  Limits the scope of class invariants to class methods and methods of derived classes (similar to C ++) </li><li>  @public Removes restrictions on visibility (similar to C ++) </li><li>  <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> Defines a block with possible exception generation (similar to C ++) </li><li>  @throw Generates an exception object (similar to C ++) </li><li>  <a href="https://habrahabr.ru/users/catch/" class="user_link">catch</a> () Handles an exception generated in a previous <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> block (similar to C ++) </li><li>  <a href="https://habrahabr.ru/users/finally/" class="user_link">finally</a> Defines a block after a <a href="https://habrahabr.ru/users/try/" class="user_link">try</a> block into which control is committed, regardless of whether or not an exception was thrown. </li><li>  @class Abbreviated form of class declaration (only name (similar to C ++)) </li><li>  <a href="https://habrahabr.ru/users/selector/" class="user_link">selector</a> (method_name) Returns the compiled selector for the method name method_name </li><li>  @protocol (protocol_name) Revolves an instance of the protocol class with the name protocol_name </li><li>  @encode (type_spec) Initializes a string of characters that will be used to encrypt data of type type_spec </li><li>  @synchronized () Defines a block of code that executes with only one thread at any particular time. </li></ul><br><h3>  Message exchange </h3><br>  To force an object to perform some method, it is necessary to send a message to it, which is named the same as the required method.  This message is called a method selector.  The parcel syntax is: <br><br><pre><code class="cpp hljs">[receiver method];</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/d18a0af3/844fdcce/1285d539/5e2f0c3b.png"></div><br>  In the message, you can pass parameters for the called method: <br><br><pre> <code class="cpp hljs">[receiver method: <span class="hljs-number"><span class="hljs-number">20.0</span></span> : <span class="hljs-number"><span class="hljs-number">30.0</span></span>];</code> </pre><br>  Before each parameter it is necessary to put a colon.  How many colons - so many parameters.  The method name can continue after each such parameter colon: <br><br><pre> <code class="cpp hljs">[receiver methodWithFirstArgument: <span class="hljs-number"><span class="hljs-number">10</span></span> andSecondArgument: <span class="hljs-number"><span class="hljs-number">20</span></span>];</code> </pre><br>  Methods with unlimited number of arguments are invoked with the following syntax: <br><br><pre> <code class="cpp hljs">[receiver undefinedNumberParameters: one, two, three, four, five, six, seven];</code> </pre><br>  Sending a message, like any C function, returns a specific (maybe void) value: <br><br><pre> <code class="cpp hljs">BOOL booleanValue; booleanValue = [reveiver method];</code> </pre><br>  When sending a nil message, it just disappears.  When a message is sent to an object that belongs to a class that does not implement the ordered method, an exception is thrown which, if not intercepted, leads the entire program to an unplanned termination.  You can use the following code template to check whether this object responds to any message: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([anObject respondsToSelector: @selector(myMethodWith2Argumets::)]) { <span class="hljs-comment"><span class="hljs-comment">//  [anObject myMethodWith2Argumetns: @‚Äùfirst‚Äù : @‚Äùsecond‚Äù]; } else { //      }</span></span></code> </pre><br><br><h3>  How messaging works </h3><br>  Sending a message is translated to the C-function with a prototype: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">id </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objc_msgSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id receiver, SEL method, ...)</span></span></span></span>;</code> </pre><br>  The SEL type is essentially defined as char const *, but it‚Äôs better to take it as an int, because at run time all selectors are indexed by integer values ‚Äã‚Äãaccording to the global selector table. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/194952d8/4bbdb524/3a81ab57/01842029.png"></div><br>  Using the isa invariant of the receiver object (when using the Foundation framework based on Cocoa, all classes must inherit the NSObject class, therefore the presence of isa is unavoidable), this function searches the local list of class selectors to determine if the object of this class responds to the message method.  If such a selector is found, then control is transferred to the appropriate class method, to which the object id is passed (a pointer to its invariants) and the parameters of the objc_msgSend () function specified after the selector.  The value returned by the method is given as the result of the message being sent.  If the selector object does not have this selector, the objc_msgSend () function scans the list of selectors of its base class. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/8d94a5cd/18d3a791/33c7f9ac/a1811278.png"></div><br>  In this scheme, the call, for example: <br><br><pre> <code class="cpp hljs">[receiver ddObject: otherObject];</code> </pre><br>  Broadcast to: <br><br><pre> <code class="cpp hljs">objc_msgSend(receiver, <span class="hljs-number"><span class="hljs-number">12</span></span>, otherObject);</code> </pre><br>  As in the global selector table 12 corresponds to the line ‚ÄúaddObject:‚Äù.  Next, the objc_msgSend () function searches the selector list of the receiver object and, finding it (even if it is an object of the NSArray class that implemented the method with the selector 12), makes a call like: <br><br><pre> <code class="cpp hljs">addObject(receiver, otherObject);</code> </pre><br><br><h3>  Method declaration </h3><br>  It is interesting to note that the prototype of the addObject method from the previous section in the class declaration looked like this: <br><br><pre> <code class="cpp hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)addObject: (id)otherObject;</code> </pre><br>  That is, took only one parameter.  But, based on the principle of the object-oriented paradigm that methods are subroutines that process certain data sets, the address of the data to be processed must be passed to the method.  Therefore, such a parameter is passed to any class method implicitly.  The compiler makes this additional parameter understand the minus ("-"), which is the first in the prototype of the method.  Such a method (with a minus in front) is called an object (or instance) method, since  can be called only for an object of some class.  In the body of the method, this pointer to the data instance (or the address of the object to which the message was sent) is accessible by means of the reserved word self (the same as this in C ++), and the pointer to the base class instance via the reserved word super.  In addition, the implicit parameter _cmd is also passed to the object method ‚Äî a selector of this method from the global selector table.  From the point of view of the C ++ programmer, all methods of objects in Objective-C are as if declared with the virtual keyword, and always follow dynamic polymorphism. <br><br>  If at the beginning of the prototype method, put a plus sign (‚Äú+‚Äù), then this method will be considered a class method, and, naturally, will not accept the implicit self parameter (this is similar to declaring a static method in C ++).  And without the isa invariant of the object pointed to by self, the super pointer, of course, will not work either. <br>  Thus, the prototype of any method is declared as follows: <br><br><pre> <code class="cpp hljs">-|+ (&lt;  &gt;)  [ : (&lt;  &gt;) [ [] : (&lt;  &gt;)] ‚Ä¶ ]</code> </pre><br>  For example: <br><br><pre> <code class="cpp hljs">+ (Class)<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">;</span></span> + (id)alloc; - (id)init; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)addObject: (id)anObject; + (NSString *)stringWithCString: (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)aCString usingUncoding: (<span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NSStringEncoding)encoding; - (NSString *)initStringWithFormat: (NSString *)format, ‚Ä¶;</code> </pre><br>  If the method returns an object (type id) or a class (type Class), you can use the nested call syntax: <br><br><pre> <code class="cpp hljs">[myLabel setText: [[NSString stringWithString: @‚ÄùHello‚Äù] stringByAppendingString: @‚Äù world‚Äù]];</code> </pre><br>  Here, the UILabel class object from the UIKit framework is set to the text invariant equal to the string @ ‚ÄùHello world‚Äù.  This string, in turn, is formed by the concatenation of the @ ‚ÄùHello‚Äù and @ ‚Äùworld‚Äù strings.  The first is the result of sending the stringWithString message to the NSString class with the constant parameter @ ‚ÄùHello‚Äù.  Such a call returns an object of class NSString, initialized with a string-parameter.  Then a stringByAppendingString message with the @ ‚Äùworld‚Äù parameter is sent to this object.  The result of sending this message is an object of the NSString class containing the concatenation of the value of the receiver object and a string argument.  This object is passed as a parameter to the setText: message of the myLabel object. <br><br><h3>  Class declaration </h3><br>  Let's declare a simple class of a complex number in the Complex.h file: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt; // NSObject   NSString @interface Complex : NSObject { double _re; //    double _im; //    NSString *_format; //    description } - (id)initWithRe: (double)re andIm: (double)im; //  + (Complex *)complexWithRe: (double)re andIm: (double)im; //      - (Complex *)add: (Complex *)other; //   - (Complex *)sub: (Complex *)other; //   - (NSString *)format; //   _format - (void)setFormat: (NSString *)format; //  _format - (double)re; //        - (void)setRe: (double)re; - (double)im; - (void)setIm: (double)im; @end</span></span></span></span></code> </pre><br>  As you can see, the entire declaration is enclosed in the <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> and <a href="https://habrahabr.ru/users/end/" class="user_link">end keywords</a> .  First, invariants are declared (in curly braces).  Outside braces are declared methods.  The description method is missing in the class declaration is not accidental.  The fact is that it, like the dealloc and init methods, is present in the class definition.  When sending a description message to the Complex object of the Complex class, its local list of selectors will be considered, where, after compilation, the selectors of all the methods implemented by the class of this object will fall, not even declared in the interface part.  That is, init, description and dealloc will call absolutely correctly. <br><br><h3>  Creating objects </h3><br>  Due to the fact that all objects are distributed in dynamic memory, the creation of an object has to be carried out in two stages: 1) memory allocation (message alloc) and 2) initialization of invariants (class constructors). <br><br><pre> <code class="cpp hljs">MyClass *myObject = [[MyClass alloc] init]; <span class="hljs-comment"><span class="hljs-comment">//  MyClass alloc          ,   init    myObject</span></span></code> </pre><br>  After creating an object, you can safely use it: <br><br><pre> <code class="cpp hljs">NSMutableArray *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = [[NSMutableArray alloc] init]; <span class="hljs-comment"><span class="hljs-comment">//   MyClass *myObject = [[MyClass alloc] init]; //  [myObject myMethod]; //   [array addObject: myObject]; //    MyClass *otherObject = [array getLastObject:]; //   ,      [otherObject myOtherMethod: YES]; //       BOOL</span></span></code> </pre><br>  Some classes have a method for quickly (in one step) creating their own instances.  Such methods are class methods, return a pointer to an object of its class, and their name usually begins with the name of the class itself.  For example, the method: <br><br><pre> <code class="cpp hljs">+ (NSString *)stringWithCString: (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> encoding: (NSStringEncoding)encoding;</code> </pre><br>  Returns a ready-made string initialized by the corresponding line with a terminating zero, without calls to alloc and init: <br><br><pre> <code class="cpp hljs">NSString *myString = [NSString stringWithCString: ‚ÄúBla-bla-bla‚Äù encoding: NSASCIIStringEncoding];</code> </pre><br><br><h3>  Object lifetime </h3><br>  As soon as a pointer to an object goes beyond its scope, the memory allocated for it is irretrievably lost (unless, of course, it was the last pointer to that object) and a leak occurs.  In order to avoid such undesirable consequences in Objective-C, the paradigm of resource reference counting is supported.  Thus, each object has an integer counter, which shows the number of pointers referring to it.  When this counter reaches zero, the memory allocated for this object is returned to the system.  After calling the class's alloc method, this counter is one.  To increase its value, you need to send a retain message to the object, and to decrease - release.  All these methods are implemented by NSObject, which any of our classes inherit by all means.  It is interesting to note that the counter value for static objects of the NSString class (for example, @ ‚ÄùI am a string‚Äù) is -1, that is, the maximum possible.  Here is an example of working with a meter: <br><br><pre> <code class="cpp hljs">id anObject = [SomeClass alloc]; <span class="hljs-comment"><span class="hljs-comment">//  == 1 [anObject init]; //    [anObject reatin]; //   (  == 2) [anObject release]; // (  == 1     ) [anObject release]; // ,   1         </span></span></code> </pre><br>  The init implementation is very important.  This is a class constructor.  Constructors differ in that they return id and their names always begin with the word init, and the default constructor is just init.  The scheme of any constructor is approximately as follows: <br><br><pre> <code class="cpp hljs">- (id)init { self = [super init]; <span class="hljs-comment"><span class="hljs-comment">//     //   if (self) //        //    ,      nil { //       } return self; //    }</span></span></code> </pre><br>  Here is a typical specialized (not default) constructor for a class with two members of the type of a certain class and one integer invariant: <br><br><pre> <code class="cpp hljs">- (id)initWithInt: (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)number { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self = [super init]) { _myMember1 = [[SomeClass alloc] init]; <span class="hljs-comment"><span class="hljs-comment">//  :  ,    _myMember2 = [[SomeClass alloc] init]; _myIntMember = number; //     //   } return self; }</span></span></code> </pre><br>  The implementation of release and retain for NSObject is ideologically approximately the following, and it does not need to be redefined in derived classes, due to the lack of access to the reference counter invariant: <br><br><pre> <code class="cpp hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)retain { [_internalLock lock]; <span class="hljs-comment"><span class="hljs-comment">//   _referenceCounter++; //  _referenceCounter ‚Äì    [_internalLock unlock]; } - (void)release { [_internalLock lock]; _referenceCounter--; //  if (!_referenceCounter) //    { [_internalLock unlock]; [self dealloc]; // ,    (  ) } [_internalLock unlock]; }</span></span></code> </pre><br>  That is, the object itself is sent a message dealloc, in the implementation of the method of which it can, if necessary, reduce the counters of its invariants and transmit a similar message to the base class object so that it does the same.  Obviously, the implementation of the dealloc method for NSObject will free up memory allocated to the object.  Usually dealloc for any class looks like this: <br><br><pre> <code class="cpp hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [_myMember1 release]; <span class="hljs-comment"><span class="hljs-comment">//    [_myMember2 release]; //     //[_myIntMember release];   , ..           [super dealloc]; //c   ,     }</span></span></code> </pre><br><br><h3>  Access methods </h3><br>  Proper work with reference counting is very important when returning an object address from a method or invariant initialization with a formal parameter.  Usually, the so-called access methods, which return and set object invariants, deal with such things.  It is customary to call the method that returns the value of the invariant, as well as the invariant, and the name of the method that sets its value to begin with the word set: <br><br><pre> <code class="cpp hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setRe: (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)re { _re = re; }</code> </pre><br>  Since the _re invariant refers to the built-in type, there are no difficulties with changing its value.  But if an invariant is an object of a certain class, then simple assignment is indispensable, since reference counters must be taken into account.  To solve this problem, the following three methods are used: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//,      [label setText: @‚ÄùHello world‚Äù]; //  text // label     NSString * //  setText   UILabel ( ‚Ññ1) - (void)setText: (NSString *)text { [text retain]; //      [_text release]; //       _text _text = text; //    } //  setText   UILabel ( ‚Ññ2) - (void)setText: (NSString *)text { if (_text != text) //c    { [_text release]; //     //  _text _text = [text retain]; //   //       } } //  setText   UILabel ( ‚Ññ3 ‚Äì ) - (void)setText: (NSString *)text { if (_text != text) { [_text autorelease]; // e   // _text    _text = [text retain]; //   //       } }</span></span></code> </pre><br>  Option number 3 is not very good because it clogs the current self-unloading pool, and usually this is not very desirable (see the next section). <br>  The access method for reading the value of an invariant is always very simple: <br><br><pre> <code class="cpp hljs">- (NSString *)text { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _text; }</code> </pre><br><br><h3>  Self-unloading pool in program threads </h3><br>  Now let's try to return from the method an object created inside it: <br><br><pre> <code class="cpp hljs">-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname { NSString *retString = [[NSString alloc] initWithFormat: @‚Äù%@ %@!‚Äù, name, surname]; <span class="hljs-comment"><span class="hljs-comment">//      return retString; }</span></span></code> </pre><br>  The format string conforms to the C standard. But if it is necessary to specify the type id in it, the format specifier% @ is used.  How does the method that parses the format understand which characters to substitute with id?  It will simply substitute what the method of the description of this object will return.  This method is originally declared for the class NSObject.  NSString redefined it to print its string content.  By redefining it, any object can represent its string content.  For example, this is how a class number with two double invariants can make it: <br><br><pre> <code class="cpp hljs">- (NSString *)description { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [NSString stringWithFormat: @‚Äùre: %lf im: %lf‚Äù, _re, _im]; <span class="hljs-comment"><span class="hljs-comment">//  @‚Äúre: 1.0 im: 2.5‚Äù  _re == 1.0  _im == 2.5 }</span></span></code> </pre><br>  After the sayHelloToName: withSurname method is executed, a memory leak will definitely occur, since the calling code most likely does not realize that the returned object needs to be sent a release message after processing.  Even if he guesses to do this, it is possible that the pointer to the object invariant was returned, which means its destruction is fraught with serious consequences.  I would like to have a mechanism for the self-release of objects ever in the future, so that the user code does not even think about their release.  This problem is solved by using an object of the NSAutoreleasePool class - a self-unloading pool of objects. <br><br>  After creating an object of this class, all objects created after it can be sent autorelease messages.  In this case, this object is placed in the current (last created) self-unloading pool.  When a pool receives a release message, it will send the same message to all its objects, reducing their reference count (in effect, destroying).  In this way.  An object placed in a self-unloading pool continues to live and occupy memory during the entire lifetime of the pool.  This is convenient for small temporary objects, but may over time take up a significant amount of memory.  Therefore, it is recommended that cycles capable of generating a large number of temporary objects that are sent to a self-unloading pool be framed with local (nested) pools. <br><br>  Any thread in a program that uses Cocoa should create an object of the NSAutoreleasePool class at the very beginning (before creating other objects), and at the very end destroy it (after destroying all other objects).  The main () function, which is the main thread of any program on Objective-C, when using the Cocoa framework, should always look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    main() { NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // ,     int retVal; //    [pool drain]; //    ,     autorelease return retVal; }</span></span></span></span></code> </pre><br>  And the correct method sayHelloToName: withSurname: will now look like this: <br><br><pre> <code class="cpp hljs">-(NSString *)sayHelloToName: (NSString *)name withSurname: (NSString *)surname { NSString *retString = [[NSString alloc] initWithFormat: @‚Äù%@ %@!‚Äù, name, surname]; <span class="hljs-comment"><span class="hljs-comment">//      [retString autorelease]; //  ,  retString     return retString; }</span></span></code> </pre><br>  By the way, the drain method of the self-unloading pool is similar to release with the only difference that, in addition to freeing itself and all the contained objects, it also gives a hint to the garbage collector to enter the game.  However, this is only relevant for Mac OS 10.4 and higher, since there is no garbage collection on iOS. <br><br><h3>  Class definition </h3><br>  Now consider the Complex.m file with the definition of the methods of the Complex class: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#import ‚ÄúComplex.h‚Äù @implementation Complex - (id)init { return [self initWithRe: 0.0 andIm: 0.0]; } - (id)initWithRe: (double)re andIm: (double)im { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (self = [super init]) { _re = re; _im = im; _format = @‚Äùre: %.1lf im: %.1lf‚Äù; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    } } + (Complex *)complexWithRe: (double)re andIm: (double)im { return [[[Complex alloc] initWithRe: re andIm: im] autorelease]; } - (Complex *)add: (Complex *)other { return [[Complex alloc] initWithRe: _re + other-&gt;_re andIm: _im + other-&gt;_im]; } - (Complex *)sub: (Complex *)other { return [[Complex alloc] initWithRe: _re ‚Äì other-&gt;_re andIm: _im ‚Äì other-&gt;_im]; } - (NSString *)format { return _format; } - (void)setFormat: (NSString *)format {//    - [format retain]; [_format release]; _format = format; } - (double)re { return _re; } - (void)setRe: (double)re { _re = re; } - (double)im { return _im; } - (void)setIm: (double)im { _im = im; } - (NSString *)description {//    return [NSString stringWithFormat: _format, _re, _im]; } - (void)dealloc { [_format release]; //    dealloc [super dealloc]; } @end</span></span></span></span></code> </pre><br>  The default constructor invokes a specialized constructor with certain initial parameters.  The complexWithRe: andIm: method returns an initialized object of the Complex class placed in the current self-unloading pool.  The description method does the same thing, returning an object of class NSString.  Here is an example program where the Complex class is used: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#import ‚ÄúComplex.h‚Äù #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; // printf() int main() { NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; Complex *num1 = [[Complex alloc] init]; //0.0+0.0*i Complex *num2 = [[Complex alloc] initWithRe: 1.5 andIm: -2]; //1.5-2.0*i Complex *num3 = [Complex complexWithRe: 5 andIm: 7]; //5.0+7.0*i printf(‚Äú%s\n‚Äù, [[num2 description] cStringUsingEncoding: NSASCIIStringEncoding]); //&gt; re: 1.5 im: -2.0 printf(‚Äú%s\n‚Äù, [[[num2 add: num3] description] cStringUsingEncoding: NSASCIIStringEncoding]); //&gt; re: 6.5 im: 5.0 [num1 setRe: [num2 re]]; // _re  num1   num2 [num1 setIm: [num3 im]]; // _im  num1   num3 [num1 setFormat: @‚Äù%.2lf+%.2lf*i‚Äù]; //    num1 printf(‚Äú%s\n‚Äù, [[num1 description] cStringUsingEncoding: NSASCIIStringEncoding]); //&gt; 1.50+7.00*i [num1 release]; [num2 release]; //[num3 release];  , ..      [pool drain]; return 0; }</span></span></span></span></code> </pre><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Categories and Extensions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you need to add / redefine some methods without inheritance to an already written (and, possibly, compiled) class, categories allow you to do it with little effort: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ‚ÄúCategorizedComplex.h‚Äù #import ‚ÄúComplex.h‚Äù @interfce Complex (CategorizedComplex) - (Complex *)mul: (Complex *)other; - (Complex *)div: (Complex *)other; @end // ‚ÄúCategorizedComplex.m‚Äù #import ‚ÄúCategorizedComplex.h‚Äù @implementation Complex (CategorizedComplex) - (Complex *)mul: (Complex *)other { return [Complex complexWithRe: _re * other-&gt;_re - _im * other-&gt;_im andIm: _re * other-&gt;_im + _im * other-&gt;_re]; } - (Complex *)div: (Complex *)other { double retRe, retIm, denominator; denominator = other-&gt;_re * other-&gt;_re + other-&gt;_im * other-&gt;_im; if (!denominator) return nil; retRe = (_re * other-&gt;_re + _im * other-&gt;_im) / denominator; retIm = (_im * other-&gt;_re - _re * other-&gt;_im) / denominator; return [Complex complexWithRe: retRe andIm: retIm]; } @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And you can use it like this: </font></font><br><br><pre> <code class="cpp hljs">CategorizdComplex *num1 = [[CategorizedComplex alloc] initWithRe: <span class="hljs-number"><span class="hljs-number">1</span></span> andIm: <span class="hljs-number"><span class="hljs-number">999</span></span>]; Complex *num2 = [Complex complexWithRe: <span class="hljs-number"><span class="hljs-number">0</span></span> andIm: <span class="hljs-number"><span class="hljs-number">0</span></span>]; CategorizedComplex *num3 = [num1 div: num2]; <span class="hljs-comment"><span class="hljs-comment">//num3 == nil</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extensions do good service as unnamed categories: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ‚ÄúCategorizedComplex.m‚Äù #import ‚ÄúCategorizedComplex.h‚Äù @interface Complex () - (void)zeroComplex; //     @end @implementation Complex - (void)zeroComplex //       { _re = 0; _im = 0; } @end</span></span></code> </pre><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocols </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Objective-C protocol is a formalized declaration of a group of methods that, if desired, can be implemented by any class (analogous to a class in C ++, where all methods are declared with the virtual‚Ä¶ = 0 specifier). </font><font style="vertical-align: inherit;">In the 2.0 version of the language, protocol methods can be required (@required specifier, it is considered silent) and selective (@optional specifier). </font><font style="vertical-align: inherit;">If any class has implemented the required protocol methods, then it is called a class that supports this protocol. </font><font style="vertical-align: inherit;">The protocol, and the class that supports it, are declared like this:</font></font><br><br><pre> <code class="cpp hljs">@protocol MyPrinterProtocol @required - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)print; - (BOOL)switchedOn; @optional - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)loadPapaer: (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)numberOfPages; @end @interface MyPrinter : NSObject &lt;MyPrinterProtocol&gt; <span class="hljs-comment"><span class="hljs-comment">// MyPrinter   MyPrinterProtocol { BOOL _state; int _numberOfPages; } - (id)initWithState: (BOOL)state andPagesCount: (int)pages; - (BOOL)state; @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The MyPrinter class object is guaranteed to send print and switchedOn messages, and, after checking the respondsToSelector: message, you can send a loadPaper message, as its implementations must contain definitions of the same methods. </font><font style="vertical-align: inherit;">The declaration of an object of a class that supports any protocol is as follows:</font></font><br><br><pre> <code class="cpp hljs">MyPrinter *printer; id anotherPrinter = [[MyPrinter alloc] init]; [anotherPrinter print]; <span class="hljs-comment"><span class="hljs-comment">//       </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, one class can satisfy several protocols. </font><font style="vertical-align: inherit;">To do this, you can list them separated by commas in angle brackets in the class declaration.</font></font><br><br><pre> <code class="cpp hljs">@interface MyPrinter : NSObject &lt;MyPrinterProtocol, OtherProtocol&gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And in order to declare an object of an unknown class (id) that corresponds to a certain protocol, write this: </font></font><br><br><pre> <code class="cpp hljs">id &lt;MyPrinterProtocol&gt; somePrinter;</code> </pre><br><h3>  Exceptions </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two main approaches to error handling: a global status variable, the value of which indicates the success of the previous operation, and the generation of exceptions. The essence of both is that the code in which the error occurred hopes that the code that caused it will be able to solve it, so it returns control to it, reporting the situation as much as possible. Objective-C supports both of these approaches. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An exception is an object of some class. He (even his type) carries some information about the situation. For convenience, Cocoa has an NSException class, which can be initialized with two NSString objects and one object of an arbitrary class (type id):</font></font><br><br><pre> <code class="cpp hljs">- (id)initWitnName: (NSString *)name reason: (NSString *)reason userInfo: (id)userInfo;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can generate an exception and, thus, launch the call stack promotion mechanism using the @throw operator. To grab the generated exception, the code section where it can be generated must be enclosed in a special block with the name </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (such blocks can be nested). And then, after this block, put a block with the name </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), where in parentheses indicate the type of the proposed exception. There </font><font style="vertical-align: inherit;">can be several </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () blocks after a </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">. After the exception is thrown, the control spins the stack out of the </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">and, checking all the </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">blocks in turn </font><font style="vertical-align: inherit;">, falls into that </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch block</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(), in curly brackets of which there is a type to which the type of the exception is implicitly given (exact match, pointer to base class or id). If the exception type does not coincide with any </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">block </font><font style="vertical-align: inherit;">, management continues to promote the stack. If after the block with the </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> name </font><font style="vertical-align: inherit;">there is a block with the name </font></font><a href="https://habrahabr.ru/users/finally/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finally</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then control will be transferred to it regardless of whether an </font><font style="vertical-align: inherit;">exception </font><font style="vertical-align: inherit;">occurred in the </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">(and some </font></font><a href="https://habrahabr.ru/users/catch/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">block was processed </font><font style="vertical-align: inherit;">), or its last instruction was executed. The following is an example of working with an object of the class Cup in the fill method of which an exception occurs:</font></font><br><br><pre> <code class="cpp hljs">Cup *cup = [[Cup alloc] init]; @<span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { [cup fill]; <span class="hljs-comment"><span class="hljs-comment">// fill    NSException } @catch (NSException *exception) {//     NSLog NSLog(@"main: Caught %@: %@", [exception name], [exception reason]); } @finally //  @try    { [cup release]; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><a href="https://habrahabr.ru/users/finally/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finally</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">it is convenient to free the resources allocated in the </font></font><a href="https://habrahabr.ru/users/try/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block </font><font style="vertical-align: inherit;">, but not freed because of the generated exception.</font></font><br><br><h3>  Properties </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Objective-C 2.0, our implementation of the Complex class is clearly redundant: there are too many access methods and their definition is a complete routine. </font><font style="vertical-align: inherit;">Rewrite it using properties:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ‚ÄúComplex.h‚Äù #import &lt;Foundation/Foundation.h&gt; // NSObject   NSString @interface Complex : NSObject { double _re; //    double _im; //    NSString *_format; //    description } - (id)initWithRe: (double)re andIm: (double)im; + (Complex *)complexWithRe: (double)re andIm: (double)im; - (Complex *)add: (Complex *)other; //   - (Complex *)sub: (Complex *)other; //   @property (nonatomic, retain) NSString *format; //   @property (nonatomic, assign) double re; //   @property (nonatomic, assign) double im; @end // ‚ÄúComplex.m‚Äù #import ‚ÄúComplex.h‚Äù @implementation Complex @synthesize format = _format; //   @synthesize re = _re; //    @synthesize im = _im; //      - (id)init { return [self initWithRe: 0.0 andIm: 0.0]; } - (id)initWithRe: (double)re andIm: (double)im { if (self = [super init]) { _re = re; _im = im; _format = @‚Äùre: %.1lf im: %.1lf‚Äù; //    } } + (Complex *)complexWithRe: (double)re andIm: (double)im { return [[[Complex alloc] initWithRe: re andIm: im] autorelease]; } - (Complex *)add: (Complex *)other { return [[Complex alloc] initWithRe: _re + other.re andIm: _im + other.im]; //  re  im } - (Complex *)sub: (Complex *)other { return [[Complex alloc] initWithRe: _re ‚Äì other.re andIm: _im ‚Äì other.im]; //  re  im } @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A property is a certain name accessible through a pointer to an object by means of the dot operator ‚Äú.‚Äù. </font><font style="vertical-align: inherit;">Properties are used instead of access methods to get or set an object invariant. </font><font style="vertical-align: inherit;">When a property is declared, a number of parameters are specified that describe the features of the access methods generated by the property.</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> getter = getterName, setter = setterName Indicates that the read access method will be called getterName, and setterName to be changed. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> readonly Do not generate access method for change </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> readwrite Generate both access methods </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> assign Implement change access method by simple assignment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retain Send the message a retain to the received value, send a release to the previous value of the invariant and assign the received value to it </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copy Use the usual assignment operator, but assign a copy of the received value (before assigning it sends a copy message) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nonatomic Do not use internal locks to synchronize multiple threads in generated access methods (by default, synchronization is used) </font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in the definition of the class Complex, we do not need to manually write access methods. </font><font style="vertical-align: inherit;">They are generated by the compiler and will be identical to those that were before.</font></font><br><br>  <b>Good luck!</b> </div><p>Source: <a href="https://habr.com/ru/post/107126/">https://habr.com/ru/post/107126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../107118/index.html">Printing a pdf document booklet</a></li>
<li><a href="../107119/index.html">2 years in Germany, impressions after moving from New Zealand</a></li>
<li><a href="../107120/index.html">Oracle: "Google directly copied our Java code"</a></li>
<li><a href="../107123/index.html">Black Friday of William Gates Third</a></li>
<li><a href="../107124/index.html">We use comments for different purposes.</a></li>
<li><a href="../107127/index.html">The nine rules of legal distribution</a></li>
<li><a href="../107130/index.html">Glue it on. Sticking friends, friends and bosses</a></li>
<li><a href="../107134/index.html">Major equipment manufacturers are developing a new standard for SSD-drives</a></li>
<li><a href="../107136/index.html">Acer Liquid Metal: two weeks with an engineering sample</a></li>
<li><a href="../107137/index.html">MySQL: IFNULL is not friendly with different COLLATION ?!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>