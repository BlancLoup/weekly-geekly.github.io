<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>bytes.Buffer in Go: optimizations that don't work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many go programmers are familiar with bytes.Buffer . One of its advantages is that it allows you to avoid heap allocations using the same pattern as "...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>bytes.Buffer in Go: optimizations that don't work</h1><div class="post__text post__text-html js-mediator-article"><p>  Many <a href="https://golang.org/">go</a> programmers are familiar with <a href="https://golang.org/pkg/bytes/">bytes.Buffer</a> .  One of its advantages is that it allows you to avoid heap allocations using the same pattern as " <a href="https://nullprogram.com/blog/2016/10/07/">small buffer / size optimization</a> ": </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  There is only one problem.  This optimization <a href="https://github.com/golang/go/issues/7921">does not work</a> . </p><br><p>  By the end of this article, you will learn why this optimization does not work and what we can do about it. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  As it was planned, "small buffer optimization" </h1><br><p>  We introduce a slightly simplified definition of <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  When we perform actions on the <code>Buffer</code> , for example, we call the <code>Buffer.Write</code> method, the record is always made in <code>buf</code> , but before this record, <code>Buffer.grow(n)</code> run inside each of these methods, which makes sure that there is enough space in this slice next <code>n</code> bytes. </p><br><p>  Grow can look like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Assumptions used in our implementation Buffer.grow</b> <div class="spoiler_text"><hr><br><p>  We assume that <code>len(b.buf)</code> is the actual data length in Buffer, which would require <code>Write</code> methods to use append to add new bytes to the slice.  In the <code>bytes.Buffer</code> from the standard library, this is not the case, but for example this is an inessential implementation detail. </p><br><hr></div></div><br><p>  If <code>b</code> allocated on the stack, then the <code>bootstrap</code> inside it is allocated on the stack, which means that the <code>b.buf</code> slice will reuse memory inside <code>b</code> , without requiring additional allocation. </p><br><p>  When <code>grow</code> reveals that the <code>bootstrap</code> array is no longer enough, a new, ‚Äúreal‚Äù slice will be created, to which elements from the past storage will then be copied (from the ‚Äúsmall buffer‚Äù).  After that <code>Buffer.bootstrap</code> will lose relevance.  If <code>Buffer.Reset</code> is <code>Buffer.Reset</code> , the <code>cap(b.buf)</code> will remain the same, and the <code>bootstrap</code> array will no longer be needed. </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  Memory escaping in heap </h1><br><p>  Further, it is expected that the reader is at least superficially familiar with the fact that such an <a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">analysis</a> in Go. </p><br><p>  Consider the following situation: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Here <code>b</code> will be highlighted on the heap.  The reason for this is a "leaking" pointer to <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminology</b> <div class="spoiler_text"><hr><br><p>  In this article, leaking and escapes are used almost as synonyms. </p><br><p>  In the compiler itself there is some difference, for example, the value ‚Äúruns into a heap‚Äù (x escapes to heap), but the parameters of the function are ‚Äúleaking‚Äù (leaking param x). </p><br><p>  Flowing parameter means that the passed argument for this parameter will be a selection on the heap.  In other words, the leaking parameter causes the arguments to run off into a heap. </p><br><hr></div></div><br><p>  Above was the obvious case, but how about this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Here we need only 1 byte, everything fits into the <code>bootstrap</code> , the buffer itself is local and does not ‚Äúrun away‚Äù from the function.  You might be surprised, but the result will be the same as the allocation <code>b</code> on the heap. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  To be sure, you can check this with the benchmark: </p><br><pre> <code class="hljs">BenchmarkLength-8 20000000 90.1 ns/op 112 B/op 1 allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Benchmark listing</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Explanation 112 b / op</b> <div class="spoiler_text"><hr><br><p>  When runtime asks for an <code>N</code> byte allocator, it is not necessary that exactly <code>N</code> bytes be allocated. </p><br><blockquote>  All results below are shown for a combination of <code>GOOS=linux</code> and <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  If you run <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> with this dough: </p><br><pre> <code class="hljs">BenchmarkAlloc9-8 50000000 33.5 ns/op 16 B/op 1 allocs/op</code> </pre> <br><p>  9 bytes are requested, 16 is allocated. Now let's go back to <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Look at <a href="">$ GOROOT / src / runtime / sizeclasses.go</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  96 bytes does not fit, 112 is selected. </p><br><hr></div></div><br><p>  But why is this happening? </p><br><h1 id="chto-proishodit-i-pochemu">  What happens and why </h1><br><p>  Some analysis of the situation can be found in the <a href="https://github.com/golang/go/issues/7921">issue</a> mentioned at the outset. <br>  There's also a <a href="https://github.com/golang/go/issues/7921">simple reproducer</a> . </p><br><p>  The problem place is in the assignment <code>b.buf = b.bootstrap[:]</code> .  This code causes the escape analysis to assume that <code>b.bootstrap</code> "runs away", and since this is an array, it is stored inside the object itself, which means that the whole <code>b</code> should be allocated on the heap. </p><br><p>  If bootstrap were a slice, and not an array, then this would not have happened, because there is an adhoc optimization for assigning slices from an object to the object itself: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  The answer is why this optimization does not work for arrays has already been formulated above, but here is a squeeze from <a href="">esc.go # L835-L866</a> (the entire optimization code is highlighted by reference): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Here it is worth adding that for the pointer analyzer there are several levels of "leaks", the main ones are: </p><br><ol><li>  The object escapes (b escapes).  In this case, the object itself must be allocated on the heap. </li><li>  Object elements escape (b contents escape).  In this case, the pointers in the object are considered evading. </li></ol><br><p>  The case of an array is special in that if an array leaks, the object itself containing it should leak. </p><br><p>  The escape analysis determines whether the object can be placed on the stack or not, relying only on the information that is available in the body of the analyzed function.  The <code>Buffer.grow</code> method takes <code>b</code> using a pointer, so it is required to calculate a suitable location for placement.  Since in the case of an array we cannot distinguish between <code>"b escape"</code> and <code>"b contents escape"</code> , we have to be more pessimistic and come to the conclusion that <code>b</code> not safe to place on the stack. </p><br><p>  Suppose the opposite, that the <code>self-assignment</code> pattern allows for arrays to be the same as for slices: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  The decision to place <code>b</code> on the stack in this situation will lead to a catastrophe: after exiting the function inside which <code>b</code> was created, the memory to which the <code>sink</code> will refer will be nothing but garbage. </p><br><h1 id="ukazateli-na-massivy">  Pointers to arrays </h1><br><p>  Imagine that our <code>Buffer</code> was announced a little differently: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Unlike a regular array, a pointer to an array will not store all the elements inside the <code>Buffer</code> itself.  This means that if the allocation of <code>bootstrap</code> on the heap does not entail the allocation of <code>Buffer</code> on the heap.  Since escape analysis can allocate pointer fields on the stack, when possible, we can assume that such a definition of <code>Buffer</code> more successful. </p><br><p>  But it is in theory.  In practice, a pointer to an array has no special processing and falls into the same category as a slice from a regular array, which is not entirely correct.  <a href="https://golang.org/cl/133375">The CL133375: cmd / compile / internal / gc: handle array slice self-assign in esc.go</a> aims to remedy this situation. </p><br><p>  Suppose that this change was made to the Go compiler. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  Zero value that we lost </h1><br><p>  Unfortunately, the transition from <code>[64]byte</code> to <code>*[64]byte</code> has a problem: we can no longer use <code>bootstrap</code> without explicitly initializing it, the zero value <code>Buffer</code> no longer useful, we need a constructor. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  We return <code>Buffer</code> , not <code>*Buffer</code> , to avoid problems with the analysis of pointers (it is very conservative in Go), and given that <code>NewBuffer</code> always embedded in the place of the call, unnecessary copying will not occur. </p><br><p>  After embedding the <code>NewBuffer</code> body into the call, escape analysis can try to prove that <code>new(*[smallBufSize]byte)</code> does not exceed the lifetime of the frame of the function in which it is called in its lifetime.  If so, then the allocation will be on the stack. </p><br><h1 id="intel-bytebuf">  Intel bytebuf </h1><br><p>  The optimization described above is applied in the <a href="https://github.com/intel-go/bytebuf">intel-go / bytebuf package</a> . </p><br><p>  This library exports the type <code>bytebuf.Buffer</code> , which duplicates <code>bytes.Buffer</code> by 99.9%.  All changes are reduced to the introduction of the constructor ( <code>bytebuf.New</code> ) and a pointer to the array instead of the usual array: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Here is a performance comparison with <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs vbscript">name old <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>/op <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>/op delta <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-literal"><span class="hljs-literal">empty</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-82.94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">-67.82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-number"><span class="hljs-number">-52.26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">-28.57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">-16.78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alloc/op delta <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-literal"><span class="hljs-literal">empty</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-number"><span class="hljs-number">-100.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-95.73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-63.64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-30.43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-5.19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> allocs/op delta <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-literal"><span class="hljs-literal">empty</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-number"><span class="hljs-number">-100.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-50.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-50.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-33.33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">-33.33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  All other information is available in the <a href="">README</a> . </p><br><p>  Due to the impossibility of using the zero value and binding to the construction function <code>New</code> , it is not possible to apply this optimization to <code>bytes.Buffer</code> . </p><br><p>  Is this the only way to make faster <code>bytes.Buffer</code> ?  The answer is no.  But this is exactly the way to require minimal changes to the implementation. </p><br><h1 id="plany-na-escape-analysis">  Plans for escape analysis </h1><br><p>  In its current form, Go's analysis is pretty weak.  Almost any operations with pointer values ‚Äã‚Äãlead to heap allocations, even if this is not a valid decision. </p><br><p>  Most of the time that I devote to the <a href="https://github.com/golang/go">golang / go</a> project, I will try to <a href="https://github.com/golang/go">focus</a> on solving these particular problems, so that in the next release (1.12) some improvements are possible. </p><br><p>  You can read about the results and details of the internal structure of this part of the compiler in one of my following articles.  I will also try to provide a set of recommendations that will help in some cases to structure the code so that it has less unwanted memory allocations. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422447/">https://habr.com/ru/post/422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422437/index.html">User Perception Games and Website and Application Speed</a></li>
<li><a href="../422439/index.html">Struggle with Yandex: how I spent more than a year to bring the site to the top</a></li>
<li><a href="../422441/index.html">Found a formula for a painless transition to .Net Core</a></li>
<li><a href="../422443/index.html">Corona SDK exact timer</a></li>
<li><a href="../422445/index.html">BottomAppBar implementation. Part 3: Behaviors for Android</a></li>
<li><a href="../422449/index.html">Senators vs. Amazon: what an online store is wrong for</a></li>
<li><a href="../422451/index.html">Listen to the marketing of games and the place of script writer in the gaming industry 26.09 at VSBI</a></li>
<li><a href="../422453/index.html">SmartData 2018: First canceled conference of the JUG.ru Group</a></li>
<li><a href="../422455/index.html">EPAM + universities: how we cooperate with universities of Ukraine</a></li>
<li><a href="../422457/index.html">‚ÄúFor us, it makes no sense to use Retrofit‚Äù: about Android development in Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>