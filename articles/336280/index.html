<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular Basics: HttpClient</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The most common way to get data from web services is through Http. And in this article we will see how this Http request in Angular 4.3 can be made th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular Basics: HttpClient</h1><div class="post__text post__text-html js-mediator-article"><p>  The most common way to get data from web services is through Http.  And in this article we will see how this Http request in Angular 4.3 can be made through the new HttpClient. </p><br><p>  Starting with version Angular 4.3, a new HttpClient has appeared.  This article <strong>only</strong> describes a <strong>new client</strong> . </p><a name="habracut"></a><br><h3 id="angular--43">  Angular&gt; 4.3 </h3><br><p>  HttpClientModule <br>  Httpclient </p><br><h3 id="angular--43-1">  Angular &lt;= 4.3 </h3><br><p>  Httpmodule <br>  Http </p><br><p>  Note: The old http implementation still exists in 4.3, so make sure you are using the right one. </p><br><h3 id="import-modulya">  Import module </h3><br><p>  First of all, we need to import the <strong>HttpClientModule</strong> into the parent module.  If you have a new Angular project, it will most likely be an AppModule.  To import a module, simply add it to the <em>imports</em> section of the parent module. </p><br><p>  <em>src / app / app.module.ts</em> </p><br><pre><code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BrowserModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/platform-browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AppComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./app.component'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      ,      <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; @NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, HttpClientModule <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ], providers: [], bootstrap: [AppComponent] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><h3 id="sozdaem-prostoy-servis">  We create a simple service </h3><br><p>  The correct approach when building an Angular application is to take out all HTTP requests from components to services in order to make them completely independent, and to wrap all requests in separate services.  Then, for example, during testing it will be possible to make a <em>mocke</em> version of the service.  And the code with this approach turns out to be more accurate. </p><br><p>  Usually for services you get a separate folder in the module, where you will have a service, completely your choice. </p><br><p>  Every service has a specific purpose.  For example, if we want to request photos of cats via http, then our service will be called <em>CatPictureService</em> .  The basis of the service will look something like this: </p><br><p>  <em>src / app / services / catPicture.service.ts</em> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatPictureService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { } }</code> </pre> <br><p>  To make an http request from our service, we need Angular <strong>HttpClient</strong> .  We can easily add it through dependency injection (DI). </p><br><p>  <em>src / app / services / catPicture.service.ts</em> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatPictureService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) { } }</code> </pre> <br><h3 id="sozdanie-zaprosa">  Create request </h3><br><p>  To make a request, we will add a new method to our service.  Methods are usually called verbs.  At the moment we will call the method "get".  He will receive a photo of the cat at the URL. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string): Observable&lt;any&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url); }</code> </pre> <br><p>  As you can see, Angular HttpClient is quite simple.  All we need to do is call the get method and pass it the url.  This get method returns an Observable object.  This class is part of the <a href="http://reactivex.io/">rxjs</a> library, which is used in many places in Angular.  One example of use is HttpClient. </p><br><p>  Like a promise (Promise), the observer (Observable) does not immediately contain values.  Instead, it has a subscribe method (subscribe), where we can register a callback.  This callback is called as soon as the result is available.  In addition to the promise, Observable can return more than one value.  You can reclaim the flow of results.  But it does not matter for this lesson.  In our case, Observable returns only one value. </p><br><h3 id="podpiska-na-nablyudateli-subscribing-to-observables">  Subscribing to Observers </h3><br><p>  So, how can we subscribe to an observer who was returned by our new method to get the actual value?  This is pretty easy.  We simply call the subscribe subscription method and register one (or two) methods for the callback.  The first callback is called when the result is available.  It gets the result as a parameter.  The second callback starts when any error occurs with the request.  As a parameter, it receives an error object. </p><br><p>  Here is how it looks in code.  I compiled a picService instance.  You need to secure and request this service yourself. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.picService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'http://anyurl.com'</span></span>).subscibe(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> =&gt;{ <span class="hljs-comment"><span class="hljs-comment">// value -  }, error =&gt; { // error -   });</span></span></code> </pre> <br><p>  NOTE.  You always need to subscribe (call the subscibe method) otherwise the request will not be made! </p><br><h3 id="opcii">  Options </h3><br><p>  Http supports a huge selection of various options, headers and formats.  To make all these different requests from the HttpClient, all its methods take the options object as an optional parameter. </p><br><h3 id="formaty-otvetov">  Response Formats </h3><br><p>  Starting with Angular 4.3, the default response format is JSON.  This makes using HttpClient very easy.  You no longer need to analyze the answer manually.  Angular does this for you. </p><br><p>  Although JSON is the most common response format, there are many examples where you cannot use JSON.  For example, when requesting photos of cats. </p><br><p>  To avoid automatic analysis of the response, we can predefine the <strong>responseType</strong> property through the options object. </p><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">responseType</span></span>: <span class="hljs-string"><span class="hljs-string">'text'</span></span> }</code> </pre> <br><h3 id="zagolovki">  Headlines </h3><br><p>  To add headers to the request, we use the <strong>headers</strong> property of the options object.  For this, we need an <strong>HttpHeaders</strong> object.  It contains all our heading definitions.  Do not use the Headers object, as it is part of the old Http client. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpHeaders({ <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { headers: headers };</code> </pre> <br><h3 id="url-parametry">  URL parameters </h3><br><p>  We can also define url parameters inside the options object.  To do this, we need to create an <strong>HttpParams</strong> object.  Thus, we do not need to add them to the url line. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpParams().<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = {<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>};</code> </pre> <br><h2 id="otslezhivanie-progressa">  Progress tracking </h2><br><p>  One of the new features of the new HttpClient is the ability to track the progress of the request.  For example, if you want to upload a large file, you probably want to report the download progress to the user. </p><br><p>  To do this, we need to break our query in a separate request object.  To get progress, we need to set the <strong>reportProgress</strong> property to <strong>true</strong> . </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpRequest } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Subject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Subject"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpEventType } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpResponse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; public post(url: string, <span class="hljs-attr"><span class="hljs-attr">file</span></span>: File): Observable&lt;number&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, url, file, { <span class="hljs-attr"><span class="hljs-attr">reportProgress</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.request(req).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.type === HttpEventType.UploadProgress) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> percentDone = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(<span class="hljs-number"><span class="hljs-number">100</span></span> * event.loaded / event.total); subject.next(percentDone); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HttpResponse) { subject.complete(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subject.asObservable(); }</code> </pre> <br><p>  The post method returns an Observable object representing the loading progress. </p><br><h2 id="perehvatchiki-interceptors">  Interceptors </h2><br><p>  Another great feature of the new HttpClient are interceptors.  In some cases, you may need to change the request before it reaches the server.  Or you want to change every answer.  You can do this with the Interceptor.  This is a kind of middleware between http-api and the actual request. </p><br><p>  One common use case might be authentication.  To get a response from the server, you often need to add some kind of authentication mechanism to the request.  Of course, you can simply change the authorization header in your service.  But this task is always the same, isn't it?  This is always the same protocol.  It never changes, even between applications.  So why don't we write the logic once and reuse it everywhere? </p><br><h2 id="opredelenie-perehvatchika">  Interceptor Definition </h2><br><p>  Like a service, the interceptor is injectable. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; @Injectable() export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AuthenticationInterceptor implements HttpInterceptor { intercept(req: HttpRequest&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;&gt; { req.headers.append(<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;SOME-TOKEN&gt;'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return next</span></span>.handle(req); } }</code> </pre> <br><p>  Since an application can have multiple interceptors, they are chained.  The first element is called Angular.  Subsequently, we are responsible for transmitting the request to the next interceptor.  To do this, we call the <strong>handle</strong> method of the next element in the chain as soon as we finish. </p><br><p>  Before we do this, we can change the request as we like.  For example, add a token to the authorization header. </p><br><p>  This example is by no means complete or reusable.  But this should give you an idea of ‚Äã‚Äãhow to proceed from here. </p><br><h2 id="predstavlenie-perehvatchikov">  Interceptor view </h2><br><p>  Just like services, we also need to block interceptors.  To do this, your parent module (AppModule) should look something like this: <br>  <em>src / app / app.module.ts</em> </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BrowserModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/platform-browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AppComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./app.component'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      ,      <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HTTP_INTERCEPTORS } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; @NgModule({ declarations: [ AppComponent, ], imports: [ BrowserModule, HttpClientModule <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ], providers: [{ provide: HTTP_INTERCEPTORS, useClass: AuthenticationInterceptor, multi: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }], bootstrap: [AppComponent] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><h2 id="itogo">  Total </h2><br><p>  Now we know how we can send or receive external data via http.  We also learned what options we can use and how to track progress. </p><br><p>  Hope you enjoyed this article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336280/">https://habr.com/ru/post/336280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336268/index.html">ReactiveX 2.0 with examples, or grokay reactive programming 2.0. Part 1: Observable vs Flowable, Backpressure</a></li>
<li><a href="../336270/index.html">Brief reaction to Xored material</a></li>
<li><a href="../336272/index.html">Types of models</a></li>
<li><a href="../336276/index.html">How I created a monitoring system for computers at work and moved the service to Amazon AWS</a></li>
<li><a href="../336278/index.html">Using the system API in Sailfish OS</a></li>
<li><a href="../336282/index.html">Trafaret as a parser. JSON Schema implementation</a></li>
<li><a href="../336284/index.html">Blockchain: The Future of IT Professionals</a></li>
<li><a href="../336286/index.html">Reed-Solomon codes. Part 1 - the theory of simple language</a></li>
<li><a href="../336288/index.html">What is known about the possible IPO Dropbox: rumors, difficulties and numbers</a></li>
<li><a href="../336290/index.html">How to scratch a panda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>