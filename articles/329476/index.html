<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Russian Code Cup - in the wake of the qualifying round</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="May 14th was the qualifying round of the Russian Code Cup 2017 . By tradition, lay out the analysis of tasks and sum up. 


 A. Small numbers 
 B. New...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Russian Code Cup - in the wake of the qualifying round</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/5ac/a23/388/5aca23388fb845fc82c023c0d337428e.jpg"></p><br><p>  May 14th was the qualifying round of the <a href="http://www.russiancodecup.ru/">Russian Code Cup 2017</a> .  By tradition, lay out the analysis of tasks and sum up. </p><br><p>  A. <a href="https://habrahabr.ru/company/mailru/blog/329476/">Small numbers</a> <br>  B. <a href="https://habrahabr.ru/company/mailru/blog/329476/">New keyboard</a> <br>  C. <a href="https://habrahabr.ru/company/mailru/blog/329476/">Folding figure</a> <br>  D. <a href="https://habrahabr.ru/company/mailru/blog/329476/">acute triangles</a> <br>  E. <a href="https://habrahabr.ru/company/mailru/blog/329476/">Combining arrays</a> <br>  F. <a href="https://habrahabr.ru/company/mailru/blog/329476/">Two subtrees</a> </p><br><p>  603 people participated in the round: approximately 200 best programmers from each qualifying round.  According to the results of the qualifying round, we took 55 participants to the final. </p><a name="habracut"></a><br><p>  All six tasks of the qualifying round could not be solved by any participant.  With five tasks handled 15 people.  With four - 55 more participants. </p><br><p>  Top three: </p><br><ol><li>  In the first place with a significant margin from his pursuers (15 minutes) was Ipatov Michael from Kostroma. </li><li>  Second place went to Mikhail Tikhomirov from Moscow. </li><li>  In third place - Igor Pyshkin from St. Petersburg. </li></ol><br><p>  In addition, the top 10 hit: </p><br><ol><li>  Mitrichev Peter, Zurich, Switzerland </li><li>  Gennady Korotkevich, St. Petersburg, Russia </li><li>  Alexander Ostanin, Dolgoprudny, Russia </li><li>  Yershov Stanislav, St. Petersburg, Russia </li><li>  Djokic Nikola </li><li>  Danilyuk Alexey, Odintsovo, Russia </li><li>  Du Yuhao, Beijing, China </li></ol><br><p>  All participants and rating table of the round can be found <a href="http://www.russiancodecup.ru/ru/championship/result/59/">here</a> . </p><br><p>  Congratulations to all who passed to the final, which will be held in September 2017.  And now - analysis of tasks. </p><br><h2 id="a-malenkie-chisla">  A. Small numbers </h2><br><p>  Time limit - 2 seconds <br>  Memory limit - 256 megabytes </p><br><p>  The boy Vlad has two favorite numbers <em>a</em> and <em>b</em> .  Recently he was taught at school to divide and multiply, and he immediately ran to divide and multiply his favorite numbers. </p><br><p>  First, he wrote in the notebook the numbers <em>a</em> and <em>b</em> , after which he decided that he would consistently perform one of the three operations with them: </p><br><ul><li>  Divide both numbers by one of their common divisors; </li><li>  Divide <em>a</em> by one of its divisors <em>g</em> , and <em>b</em> multiplied by <em>g</em> ; </li><li>  Divide <em>b</em> by one of its divisors <em>g</em> , and <em>a</em> multiply by <em>g</em> . </li></ul><br><p>  After each operation, he erases the old numbers, writes the two resulting numbers back into the notebook and can continue operations with them. </p><br><p>  Since Vlad is still small, he likes smaller numbers, so he seeks to minimize the sum of the numbers written in the notebook.  He himself can not cope.  Help Vlad to determine the minimum amount of numbers that can be obtained by such operations, and give an example of a pair of numbers that can be the result. </p><br><p>  <strong>Input Format</strong> </p><br><p>  The input contains several test cases.  The first line contains the number of tests <em>t</em> (1 ‚â§ <em>t</em> ‚â§ 500). </p><br><p>  Each test is described as follows: the single line of the test description contains two numbers <em>a</em> and <em>b</em> (1 ‚â§ <em>a</em> , <em>b</em> ‚â§ 10 <sup>9</sup> ) - Vlad's favorite numbers. </p><br><p>  <strong>Output format</strong> </p><br><p>  For each test in a separate line print the answer to it - a pair with the minimum amount that can be obtained by applying the operations from the condition. </p><br><p>  If there are several answers, then it is allowed to display any of them. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  2 <br>  4 5 <br>  4 6 </p><br><p>  Output <br>  15 <br>  2 3 </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p>  First, decompose the numbers <em>a</em> and <em>b</em> into simple ones. </p><br><p>  Now we note that if some prime number <em>p</em> enters the product <em>ab</em> to degrees higher than the first, then we can either divide both numbers by the number <em>p</em> at once, or if one of the numbers is not divisible by <em>p</em> , then we transfer the factor <em>p</em> from another number, then divide by <em>p</em> . </p><br><p>  Obviously, the parity of the occurrence of primes in the product <em>ab</em> does not change in all operations.  Then let's leave everything simple in the first degree.  The numbers <em>p</em> <sub>1</sub> , <em>p</em> <sub>2</sub> , ..., <em>p <sub>n remain</sub></em> .  Let's call the product of all these primes <em>d</em> , <em>d</em> ‚â§ <em>ab</em> .  It is argued that these primes cannot be greater than 14. If 1 ‚â§ <em>a</em> , <em>b</em> ‚â§ 10 <sup>9</sup> , then the product <em>ab</em> ‚â§ 10 <sup>18</sup> and the product of the first 15 primes exceeds 10 <sup>18</sup> ).  Now note that the final answer is a pair of numbers ( <em>x</em> , <em>y</em> ) such that <em>xy</em> = <em>d</em> .  From this it follows that the second element of the pair is determined uniquely by the first.  Enumerate all possible divisors <em>d</em> of <em>x</em> for <em>O</em> (2 <sup><em>n</em></sup> ), and choose the best pair. </p></div></div><br><h2 id="b-novaya-klaviatura">  B. New keyboard </h2><br><p>  Time limit - 2 seconds <br>  Memory limit - 256 megabytes </p><br><p>  Petya bought a new keyboard.  It supports <em>n</em> layouts.  In each layout, you can type a subset of the lowercase letters of the Latin alphabet.  We number the layouts from 1 to <em>n</em> . </p><br><p>  Peter wants to type some message consisting of <em>m</em> lowercase Latin letters.  Initially, the first layout is active.  Petya can perform the following actions: </p><br><ul><li>  Toggle layout.  Then, if the current layout had the number <em>i</em> , the new layout will have the number <em>i</em> mod <em>n</em> + 1, where mod is the modulo operation of the remainder.  If Petya also switched the layout to the previous action, this action will take <em>b</em> milliseconds, otherwise this action will take <em>a</em> milliseconds. </li><li>  Type a character.  Petya can add to the end of the current message any letter contained in the current layout.  He will spend <em>c for</em> this action <em>c</em> milliseconds. </li></ul><br><p>  Help Petya determine the minimum time required to type a message, or find out that it is impossible to type a message.  The layout, which will remain enabled after typing the message, can be any. </p><br><p>  <strong>Input Format</strong> </p><br><p>  The first line contains four integers <em>n</em> , <em>a</em> , <em>b</em> and <em>c</em> - the number of layouts at the keyboard, and the number of milliseconds required to complete the switch layout and character set (1 ‚â§ <em>n</em> ‚â§ 2 000, 1 ‚â§ <em>b</em> ‚â§ <em>a</em> ‚â§ 10 <sup>9</sup> , 1 ‚â§ <em>c</em> ‚â§ 10 <sup>9</sup> ). </p><br><p>  The following <em>n</em> lines contain a description of the layouts.  Each layout is described by a non-empty string, in which each lowercase letter of the Latin alphabet occurs no more than once - a subset of letters that can be typed in this layout.  The letters in this line are sorted alphabetically. </p><br><p>  The last line contains the string <em>s</em> - the message that Peter wants to type (the length of the string <em>s is</em> from 1 to 2,000).  Line s consists of lowercase Latin letters. </p><br><p>  <strong>Output format</strong> </p><br><p>  Print a single integer - the minimum number of milliseconds required to type the message.  Output - 1 if you cannot type a message. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  5 3 2 1 <br>  abc <br>  d <br>  e <br>  f <br>  def <br>  abcdef </p><br><p>  Output <br>  15 </p><br><p>  Input data <br>  1 1 1 1 <br>  a <br>  z </p><br><p>  Output <br>  -one </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p>  Use to solve the dynamic programming method.  The state is d [i] [j] [k], where <em>i</em> is a flag denoting the type of the previous action (0 if it was a layout switch, and 1 if it was a character set), <em>j</em> is the number of the current layout, and <em>k</em> is number of characters typed.  The value is the minimum time required to reach this state. </p><br><p>  Let's go over <em>k</em> .  For a fixed <em>k,</em> let's go over <em>j</em> from 1 to <em>n</em> twice.  Update d [0] [j% n + 1] [k] = min (d [0] [j% n + 1] [k], min (d [0] [j] [k] + b, d [ 1] [j] [k] + a)).  It is necessary to iterate <em>j</em> from 1 to <em>n</em> twice because after typing the <em>kth</em> character the layout can be included with a number greater than the layout in which the next character will be typed, and it will be necessary to switch layouts along the cycle to the desired one.  After that, let's look at <em>j</em> again and update the values ‚Äã‚Äãfor <em>k</em> + 1. If the <em>j-</em> th layout contains the <em>k-</em> th message symbol, d [1] [j] [k + 1] = min (d [0] [j] [ k], d [1] [j] [k]) + c. </p><br><p>  At the end, the answer is min (d [1] [j] [m]), where <em>m = length (s)</em> , for all <em>j</em> from 1 to <em>n</em> . </p></div></div><br><h2 id="c-skladyvanie-figury">  C. Folding figure </h2><br><p>  Time limit - 2 seconds <br>  Memory limit - 256 megabytes </p><br><p>  Petya, as always, became bored in a mathematics lesson, so he began painting the cells in his notebook.  When he got tired of it, he noticed that he had got a connected checkered figure of <em>k</em> cells - between any two painted cells there is a path through other painted cells, and the neighboring cells in this way have a common side. </p><br><p>  Carefully cutting it out of the notebook, he folded it in half along the line of the checkered grid (horizontally or vertically ‚Äî he did not remember exactly), and also drew a copy of the folded figure in the notebook.  And for good reason!  Petya lost a figure, and all he had left was a copy of the folded figure, drawn in a notebook.  Now he wants to restore the original figure. </p><br><p>  It is not always possible to unequivocally restore the original figure, however, Petya decided that it would be enough for him to draw at least some figure of <em>k</em> cells that can be folded in half so that the folded figure he has is formed.  Help him - find any initial connected figure of <em>k</em> cells that satisfies this condition. </p><br><p>  Consider the second test example from the condition.  In it the folded figure represents the letter ‚ÄúP‚Äù, and the initial figure consists of 12 cells.  One of the possible variants of the original figure is shown in the figure (the fold occurs in a straight line <em>y</em> = 3): </p><br><p><img src="https://habrastorage.org/web/a16/4c2/1e0/a164c21e02ee404f9a70ef9c38caf9a3.png" alt="image"></p><br><p>  <strong>Input Format</strong> </p><br><p>  The input contains several test cases.  The first line contains the number of tests <em>t</em> (1 ‚â§ <em>t</em> ‚â§ 200). </p><br><p>  Each of the following <em>t</em> tests is described as follows: the first line of the test description contains two integers <em>n</em> , <em>k</em> is the number of filled cells that make up the folded Vasya figure and the number of cells in the original figure (1 ‚â§ <em>n</em> &lt; <em>k</em> ‚â§ 10 <sup>5</sup> ). </p><br><p>  Each of the next <em>n</em> lines contains two numbers <em>x <sub>i</sub></em> , <em>y <sub>i</sub></em> - the coordinates of the left lower corner of the <em>i</em> -th filled cell (- 10 <sup>8</sup> ‚â§ <em>x <sub>i</sub></em> , <em>y <sub>i</sub></em> ‚â§ 10 <sup>8</sup> ).  It is guaranteed that all painted cells are different and form a connected figure. </p><br><p>  It is guaranteed that the sum <em>k</em> in all tests of one input data does not exceed 10 <sup>5</sup> . </p><br><p>  <strong>Output format</strong> </p><br><p>  For each test output the answer to it.  It is necessary to display a description of the shape and the way to bend it to get the shape from the input file. </p><br><p>  In the first line print the fold line, and in the next <em>k</em> lines, two integers each ( <em>x ' <sub>i</sub></em> , <em>y' <sub>i</sub></em> ) are the coordinates of the cells of the connected figure, which can be folded in half along the derived fold line to get a figure in the input data. </p><br><p>  The bend line should be displayed in one of 4 ways: </p><br><ul><li>  L <em>num</em> - the fold is made in a straight line <em>x = num</em> , the left side is superimposed over the right; </li><li>  R <em>num</em> - the fold is made in a straight line <em>x = num</em> , the right side overlaps the left; </li><li>  U <em>num</em> - the fold is made in a straight line <em>y = num</em> , the upper part is superimposed over the lower one; </li><li>  D <em>num</em> - the fold is made in a straight line <em>y = num</em> , the lower part is superimposed over the upper one. </li></ul><br><p>  All <em>x ' <sub>i</sub></em> , <em>y' <sub>i</sub></em> , as well as the coordinate of the fold line in the module should not exceed 10 <sup>9</sup> .  It is guaranteed that such a figure exists.  If there are several suitable answers, it is allowed to display any of them. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  2 <br>  7 14 <br>  0 0 <br>  0 1 <br>  0 2 <br>  12 <br>  2 2 <br>  2 1 <br>  20 <br>  7 12 <br>  0 0 <br>  0 1 <br>  0 2 <br>  12 <br>  2 2 <br>  2 1 <br>  20 </p><br><p>  Output <br>  L 0 <br>  0 0 <br>  0 1 <br>  0 2 <br>  12 <br>  20 <br>  2 1 <br>  2 2 <br>  -ten <br>  -eleven <br>  -12 <br>  -2 2 <br>  -3 2 <br>  -3 1 <br>  -thirty <br>  U 3 <br>  0 0 <br>  0 1 <br>  0 2 <br>  12 <br>  2 2 <br>  2 1 <br>  20 <br>  0 3 <br>  13 <br>  2 3 <br>  0 4 <br>  2 4 </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p> Note that there are exactly four possible fold lines: two horizontally and two vertically, since the figure must lie completely on one side of the fold and also touch it. </p><br><p>  Take any of the cells of the folded figure with the minimum coordinate along the axis OX - the cell ( <em>x <sub>i</sub></em> , <em>y <sub>i</sub></em> ).  For the fold line we take the vertical line <em>x</em> = <em>x <sub>i</sub></em> , touching this cell.  Now, on the left, you need to restore the <em>k - n</em> cells of the original shape, so that after laying the left part along the bend line on the right, you get a folded figure from the input.  Since <em>k</em> - <em>n</em> ‚â§ <em>n</em> (otherwise, after folding, there would be more <em>n</em> cells), it suffices to separate out from the folded figure <em>k - n</em> cells that form a connected shape containing the cell ( <em>x <sub>i</sub></em> , <em>y <sub>i</sub></em> ).  This can be done by simply going deeper. </p></div></div><br><h2 id="d-ostrougolnye-treugolniki">  D. acute triangles </h2><br><p>  Time limit - 4 seconds <br>  Memory limit - 256 megabytes </p><br><p>  Quite recently, Moscow‚Äôs tenth-grader Dmitry Zakharov overtook everyone in building a set of points in <em>d-</em> dimensional space, such that all triangles with vertices at these points are acute-angled. </p><br><p>  Tanya decided to challenge themselves with Dmitry.  Of course, she plans to use a computer.  For starters, she wants to solve the following problem.  Given <em>n</em> points on the plane, you need to find the number of acute triangles with vertices at these points.  A triangle is called an acute angle if all its angles are strictly less than 90 degrees. </p><br><p>  <strong>Input Format</strong> </p><br><p>  The input contains several test cases.  The first line contains the number of tests <em>t</em> (1 ‚â§ <em>t</em> ‚â§ 666). </p><br><p>  Each of the tests is described as follows: the first line of the test description contains the number <em>n</em> (3 ‚â§ <em>n</em> ‚â§ 2000) - the number of points. </p><br><p>  The following n lines contain two numbers <em>x <sub>i</sub></em> , <em>y <sub>i</sub></em> (- 10 <sup>9</sup> ‚â§ <em>x</em> , <em>y</em> ‚â§ 10 <sup>9</sup> ) - the coordinates of the points.  It is guaranteed that all points in one test are different. </p><br><p>  The total number of points in all tests of some input data does not exceed 2000. </p><br><p>  <strong>Output format</strong> </p><br><p>  For each test in a separate line print the answer to it - the number of acute triangles with vertices at the given points. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  2 <br>  five <br>  eleven <br>  2 2 <br>  3 3 <br>  4 1 <br>  6 4 <br>  five <br>  0 0 <br>  3 1 <br>  5 1 <br>  5 -1 <br>  13 </p><br><p>  Output <br>  3 <br>  four </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p>  To calculate the acute triangles, it suffices to subtract from the total number of triangles the number of rectangular and obtuse triangles.  We will consider three points on one straight line as a degenerate obtuse triangle. </p><br><p>  The total number of triangles that can be constructed with vertices at given points is <em>C</em> <sub><em>n</em></sub> <sup>3</sup> . </p><br><p>  Note: the number of rectangular and obtuse triangles is equal to the number of right and obtuse angles with vertices at given points. </p><br><p>  It remains to calculate the number of angles not less than 90 degrees with vertices at given points.  Let's iterate over the corner point and sort by the angle relative to this all other points.  We use the method of two pointers.  Let's iterate over the second point that will form an angle.  To count the number of suitable third points, it is sufficient to note that all points that form an angle of at least 90 degrees with two other points lie on the segment in a sorted order and that the segment is shifted only in the direction of increasing angle. </p><br><p>  Solution run time: <em>O (n <sup>2</sup> log (n))</em> . </p></div></div><br><h2 id="e-obedinenie-massivov">  E. Combining arrays </h2><br><p>  Time limit - 4 seconds <br>  Memory limit - 256 megabytes </p><br><p>  Consider two arrays of positive integers <em>A</em> = [ <em>a</em> <sub>1</sub> , <em>a</em> <sub>2</sub> , ..., <em>a <sub>n</sub></em> ] and <em>B</em> = [ <em>b</em> <sub>1</sub> , <em>b</em> <sub>2</sub> , ..., <em>b <sub>m</sub></em> ].  Let us call them <em>k-</em> union a lexicographically minimal array of numbers <em>R of</em> length <em>k</em> , which is split into two non-empty subsequences, the first of which is a subsequence of the array <em>A</em> , and the second is a subsequence of the array <em>B.</em> </p><br><p>  Formally speaking, it is necessary to find a lexicographically minimal array <em>R</em> = [ <em>r</em> <sub>1</sub> , <em>r</em> <sub>2</sub> , ..., <em>r <sub>k</sub></em> ], for which there exist non-empty sets of indices 1 ‚â§ <em>i</em> <sub>1, 1</sub> &lt; <em>i</em> <sub>1, 2</sub> &lt;... &lt; <em>i</em> <sub>1, <em>t</em></sub> ‚â§ <em>n</em> and 1 &lt; <em>j</em> <sub>1, 1</sub> &lt; <em>j</em> <sub>1, 2</sub> &lt;... &lt; <em>j</em> <sub>1, <em>k</em> - <em>t</em></sub> ‚â§ <em>m</em> in the original arrays, as well as sets of indices 1 ‚â§ <em>i</em> <sub>2, 1</sub> &lt; <em>i</em> <sub>2, 2</sub> &lt;.. &lt; <em>i</em> <sub>2, <em>t</em></sub> ‚â§ <em>k</em> and 1 ‚â§ <em>j</em> <sub>2, 1</sub> &lt; <em>j</em> <sub>2, 1</sub> &lt;... &lt; <em>j</em> <sub>2, <em>k</em> - <em>t</em></sub> ‚â§ <em>k</em> , such that: </p><br><ul><li>  For any 1 ‚â§ <em>p</em> ‚â§ <em>t</em> , 1 ‚â§ <em>q</em> ‚â§ <em>k</em> - <em>t</em> , <em>i</em> <sub>2, <em>p</em></sub> ‚â† <em>j</em> <sub>2, <em>q</em></sub> ; </li><li>  For any 1 ‚â§ <em>p</em> ‚â§ <em>t</em> , we have <em>a</em> <sub><em>i</em> <sub>1, <em>p</em></sub></sub> = <em>r</em> <sub>i <sub>1, <em>p</em></sub></sub> ; </li><li>  For any 1 ‚â§ <em>p</em> ‚â§ <em>k</em> - <em>t</em> , <em>b</em> <sub><em>j</em> <sub>1, <em>p</em></sub></sub> = <em>r</em> <sub><em>j</em> <sub>1, <em>p</em></sub></sub> . </li></ul><br><p>  For example, if <em>A</em> = [1, 2, 1, 3, 1, 2, 1], <em>B</em> = [1, 2, 3, 1], and <em>k</em> = 9, then their <em>k</em> -note will be <em>R</em> = [1, 1 , 1, 1, 2, 1, 2, 3, 1] (a subsequence from the first array - [1, 1, 1, 2, 1], a subsequence from the second array - [1, 2, 3, 1]). </p><br><p>  For the two given arrays <em>A</em> and <em>B</em> , as well as the number <em>k,</em> find their <em>k-</em> union <em>R.</em> </p><br><p>  <strong>Input Format</strong> </p><br><p>  The first line of the input contains the number <em>n</em> - the size of the array <em>A</em> (1 ‚â§ <em>n</em> ‚â§ 3000). </p><br><p>  The second line contains <em>n</em> numbers <em>a <sub>i</sub></em> - array <em>A</em> (1 ‚â§ <em>a <sub>i</sub></em> ‚â§ 3000). </p><br><p>  The third line contains the number <em>m</em> - the size of the array <em>B</em> (1 ‚â§ <em>m</em> ‚â§ 3000). </p><br><p>  The fourth line contains <em>m</em> numbers <em>b <sub>i</sub></em> - array <em>B</em> (1 ‚â§ <em>b <sub>i</sub></em> ‚â§ 3000). </p><br><p>  The last line contains the number <em>k</em> (2 ‚â§ <em>k</em> ‚â§ <em>n</em> + <em>m</em> ). </p><br><p>  <strong>Output format</strong> </p><br><p>  Output <em>k-</em> union of the arrays specified in the input file. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  7 <br>  1 2 1 3 1 2 1 <br>  four <br>  1 2 3 1 <br>  9 </p><br><p>  Output <br>  1 1 1 1 2 1 2 3 1 </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p>  We present two solutions to this problem: for <em>O (k <sup>2</sup> ‚Ä¢ log (k))</em> and <em>O (k <sup>2</sup> )</em> . </p><br><p>  Solution in <em>O (k <sup>2</sup> ‚Ä¢ log (k))</em> </p><br><p>  We divide the solution of the problem into three points: </p><br><ol><li>  For each array <em>X</em> ( <em>A</em> or <em>B</em> ) and each length 1 ‚â§ <em>length</em> ‚â§ | X |  find <em>minSubsequenceX [length]</em> - a lexicographically minimal subsequence X of length length. </li><li>  We iterate over the length of the subsequence in the first array - 1 ‚â§ <em>t</em> ‚â§ <em>min</em> ( <em>k</em> - 1, | A |).  If 1 ‚â§ <em>k</em> - <em>t</em> ‚â§ | B |, take <em>minSubsequence <sub>A</sub> [t]</em> and <em>minSubsequence <sub>B</sub> [k - t]</em> , they must be combined. </li><li>  We combine two subsequences into one, thereby obtaining a lexicographically minimal subsequence of length <em>k</em> , updating the answer. </li></ol><br><p>  To find the <em>minSubsequence <sub>X</sub> [length]</em> for each <em>length</em> , do this: </p><br><ul><li>  Calculate <em>next [i] [c]</em> , which will store the next after <em>i</em> occurrence of the character <em>c</em> in <em>X.</em> </li><li>  <em>Calculate firstSymbol [length] [i]</em> - the first character of the lexicographically minimal subsequence of the array <em>X</em> [ <em>i</em> .. |  <em>X</em> |  - 1] <em>length</em> .  To do this, note the following: <br><ul><li>  If <em>j <sub>1</sub> = next [i] [1]</em> exists, then <em>firstSymbol [1] [i]</em> , <em>firstSymbol [2] [i]</em> , ... <em>firstSymbol [| X |</em>  <em>- j <sub>1</sub> ] [i]</em> begin with 1; </li><li>  If <em>j <sub>2</sub> = next [i] [2]</em> exists, then <em>firstSymbol [| X |</em>  <em>- j <sub>1</sub> + 1] [i]</em> , ..., firstSymbol [| X |  - j <sub>2</sub> ] [i] begin with 2; </li><li>  ... </li><li>  If <em>j <sub>| alphabet |</sub></em>  <em>= next [i] [| alphabet |</em>  exists, then <em>firstSymbol [max (| X | - j <sub>1</sub> , | X | - j <sub>2</sub> , ..., | X | - j <sub>| alphabet | - 1</sub> ) + 1] [i], ..., firstSymbol [| X |</em>  <em>- j <sub>| alphabet |</sub></em>  <em>] [i]</em> start with <em>| alphabet |</em>  . <br>  where <em>alphabet</em> is the maximum possible number in the <em>X</em> array. </li></ul></li><li>  <em>By</em> counting <em>firstSymbol [length] [i]</em> , you can restore the lexicographically minimal subsequence <em>X</em> for each length iteratively one letter. </li></ul><br><p>  This item works for <em>O (| X | <sup>2</sup> )</em> . </p><br><p>  Having found two lexicographically minimal subsequences <em>S <sub>A</sub></em> and <em>S <sub>B</sub></em> , they must be combined into one lexicographically minimum length <em>k</em> .  We will move along the subsequences with two pointers <em>p</em> <sub>1</sub> and <em>p</em> <sub>2</sub> .  If <em>S</em> <sub><em>Ap</em> 1</sub> ‚â† <em>S</em> <sub><em>Bp</em> 2</sub> , then move the pointer on a smaller number.  If <em>S</em> <sub><em>Ap</em> 1</sub> = <em>S</em> <sub><em>Bp</em> 2</sub> , use the binary search to find the largest common prefix <em>S <sub>A</sub> [p <sub>1 ..</sub> | S <sub>A</sub> |]</em> and <em>S <sub>B</sub> [p <sub>2 ..</sub> | S <sub>B</sub> |]</em> and compare the following numbers.  For comparison of subracks <em>S <sub>A</sub></em> and <em>S <sub>B</sub></em> you can use hashes. </p><br><p>  This item works for <em>O ((| S <sub>A</sub> | + | S <sub>B</sub> |) ‚Ä¢ log (max (| S <sub>A</sub> |, | S <sub>B</sub> |))) = O (k ‚Ä¢ log (k))</em> . </p><br><p>  Total, summing up all three points, we obtain the asymptotics <em>O (| A | <sup>2</sup> + | B | <sup>2</sup> + k <sup>2</sup> ‚Ä¢ log (k)) = O (k <sup>2</sup> ‚Ä¢ log (k))</em> . </p><br><p>  Solution for <em>O (k <sup>2</sup> )</em> </p><br><p>  Call array <em>A</em> zero, and array <em>B the</em> first.  We will build the answer on one element.  We will also support the auxiliary value <em>dp [i] [j]</em> , where <em>i</em> is the array number (0 or 1), and <em>j</em> is the index in this array.  <em>dp [i] [j]</em> is equal to the minimum index in the array 1 - <em>i</em> , from which you can continue to build the answer, if in the array <em>i</em> we dwell on the index <em>j</em> . </p><br><p>  At the <em>t-</em> th of <em>k</em> iterations of the construction of the answer, we will find the minimal element, such that, adding it to the answer, the sequence can be completed, i.e., the remaining elements are at least <em>k</em> - <em>t</em> - 1. You also need to take into account that both subsequences of both the arrays from which the response is constructed must be non-empty. </p><br><p>  After adding the found element <em>v</em> to the answer for <em>O (| A | + | B |), we</em> update the values ‚Äã‚Äãof <em>dp</em> .  For this, we will use the <em>next</em> array calculated in the previous solution. </p></div></div><br><h2 id="f-dva-poddereva">  F. Two subtrees </h2><br><p>  Time limit - 4 seconds <br>  Memory limit - 256 megabytes </p><br><p>  Consider a hanging tree.  Consider a vertex <em>v</em> having at least one vertex in a subtree at a distance <em>k</em> from <em>v</em> .  We call a <em>k-</em> subtree of a vertex <em>v a</em> tree obtained from a subtree of a vertex <em>v by</em> deleting all the vertices whose distance from <em>v</em> to <em>v is</em> greater than <em>k</em> .  For example, in the illustration below, the 2-subtree of vertex 3 is marked with red. </p><br><p><img src="https://habrastorage.org/web/d4f/249/6ef/d4f2496efb954df9add14e2ec35d738a.png" alt="image"></p><br><p>  We will call two trees the same if we can renumber the vertices of the first so as to get the second, while changing the order of the children at the vertices is not allowed.  For example, the following two trees are not the same: </p><br><p><img src="https://habrastorage.org/web/8fa/ad4/d0b/8faad4d0b29445089683b5657c496b9a.png" alt="image"></p><br><p>  Given a hanging tree.  It is required to determine the greatest <em>k</em> such that it has two identical <em>k-</em> subtrees whose roots are different.  These subtrees may intersect. </p><br><p>  The figure shows the trees from the examples. </p><br><p><img src="https://habrastorage.org/web/503/38d/b27/50338db27ce346629acf093b31967dc9.png" alt="image"></p><br><p>  In the first example, the roots of the same 1-subtrees are vertices 2 and 3. </p><br><p>  In the second example, the roots of the same 3-subtrees are vertices 1 and 4. </p><br><p>  In the third example, the roots of the same 0-subtrees are vertices 1 and 2. </p><br><p>  <strong>Input Format</strong> </p><br><p>  The first line contains the number <em>t</em> - the number of tests (1 ‚â§ <em>t</em> ‚â§ 10 <sup>4</sup> ). </p><br><p>  Each of <em>t</em> tests is described as follows: the first line contains the number <em>n</em> - the number of vertices (2 ‚â§ <em>n</em> ‚â§ 10 <sup>5</sup> ). </p><br><p>  Then follow <em>n</em> lines.  In the <em>i</em> -th of them the number <em>cnt <sub>i</sub></em> is given - the number of children of the vertex <em>i</em> , followed by <em>cnt <sub>i</sub></em> numbers - the numbers of the children of the vertex <em>i</em> .  Vertices are numbered from one.  The root of the tree is vertex 1. It is guaranteed that the given graph is a tree with root at 1. </p><br><p>  The sum <em>n</em> over all tests in the same input data does not exceed 2 ¬∑ 10 <sup>5</sup> . </p><br><p>  <strong>Output format</strong> </p><br><p>  For each test, print on a separate line the maximum <em>k</em> such that there are two identical <em>k-</em> subtrees with different roots. </p><br><p>  <strong>Examples</strong> </p><br><p>  Input data <br>  3 <br>  five <br>  2 2 3 <br>  14 <br>  15 <br>  0 <br>  0 <br>  eight <br>  12 <br>  2 3 4 <br>  0 <br>  15 <br>  2 6 7 <br>  0 <br>  18 <br>  0 <br>  2 <br>  12 <br>  0 </p><br><p>  Output <br>  one <br>  3 <br>  0 </p><br><div class="spoiler">  <b class="spoiler_title">Task analysis</b> <div class="spoiler_text"><p>  By condition, in the <em>k</em> -tree, there are necessarily vertices at the depth <em>k</em> .  Temporarily cancel this requirement. </p><br><p>  Consider all <em>k</em> -trees for some <em>k</em> .  They can be divided into equivalence classes.  To each vertex we associate <em>c <sub>k</sub> [v] with the</em> label of the equivalence class to which its <em>k</em> -tree belongs. </p><br><p>  For <em>k</em> = 0, all <em>c <sub>0</sub> [v]</em> are equal, since the 0-subtree of any vertex is itself. </p><br><p>  When <em>k</em> = 1, <em>c <sub>1</sub> [v]</em> is equal to the number of children of the vertex. </p><br><p>  Let's learn to build an array of <em>c <sub>k + m</sub> [v]</em> using arrays <em>c <sub>k</sub> [v]</em> and <em>c</em> <em><sub>m</sub> [v]</em> .  To begin with, we assign to each vertex <em>v an</em> array of <em>arr <sub>k + m</sub> [v]</em> , which will uniquely define the equivalence class of its <em>k + m</em> - subtree.  Let <em>u</em> <sub>1</sub> , ..., <em>u <sub>s</sub></em> be descendants of a vertex <em>v</em> at a distance <em>k</em> in the traversal order of <em>dfs</em> .  Then we associate with the vertex <em>v the</em> array <em>arr <sub>k + m</sub> [v] = c <sub>k</sub> [v], c <sub>m</sub> [u <sub>1</sub> ], ..., c <sub>m</sub> [u <sub>s</sub> ]</em> .  That is, <em>k + m</em> - a subtree of a vertex is given by a <em>k-</em> subtree of a vertex and <em>m-</em> subtrees of the lower part of a <em>k-</em> subtree.  Below is an illustration for <em>k</em> = 3 and <em>m</em> = 1. </p><br><p><img src="https://habrastorage.org/web/9ea/4ed/e6a/9ea4ede6a01e4c39a32f1605e61daaf8.png" alt="image"></p><br><p>  To get for each vertex a list of its descendants at a distance <em>k</em> , run a search in depth from the root.  We will support the path to the root on the stack and put each vertex in an array for its ancestor at a distance <em>k</em> . </p><br><p>  To convert arrays <em><sub>k + m</sub> [v]</em> arrays to <em>c <sub>k + m</sub> [v]</em> numbers, you can hash them, use boron or unordered_map from an array to a number.  The running time will be <em>O (n)</em> , since each vertex is found in the <em>arr</em> lists only once. </p><br><p>  Having an array <em>c <sub>k</sub> [v]</em> , you can easily verify that there are two identical <em>k-</em> subtrees.  To do this, we find two vertices with the same <em>c <sub>k</sub></em> , and only vertices that have descendants at a distance <em>k</em> from it (this is the requirement that we canceled at the beginning) should be considered. </p><br><p>  To find the maximum <em>k</em> , we calculate <em>c <sub>1</sub> [v], c <sub>2</sub> [v], ..., c <sub>2</sub> <sup>t</sup> [v]</em> (2 <sup>t</sup> is the maximum power of two that does not exceed <em>n</em> ).  After that, we use the analog of binary ascents in <em>k</em> : we start with <em>k</em> = 0 and in turn try to add 2 <sup><em>t</em></sup> , 2 <sup><em>t</em> - 1</sup> , ..., 2 <sup>0 to it</sup> . </p><br><p>  Solution run time: <em>O (nlog (n))</em> . </p></div></div><br><h3 id="plany-na-buduschee">  Future plans </h3><br><p>  Do not forget that in September there will be a final round.  After it we will also lay out the conditions of the tasks and their analysis.  You can feel yourself in the shoes of the finalists and solve hardcore tasks. </p><br><p>  And finally, we are sharing with you one of the ideas: maybe next year we will make special nominations like ‚ÄúBest in Language‚Äù.  Then, for example, the owner of the best solution in C ++ will receive a separate prize.  What do you think? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329476/">https://habr.com/ru/post/329476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329466/index.html">YiiConf 2017 June 16 in Moscow - a program is formed</a></li>
<li><a href="../329468/index.html">BDD - working method or TDD in a fashionable wrapper?</a></li>
<li><a href="../329470/index.html">Do-it-yourself phishing. Experience of the company "Aktiv", part one</a></li>
<li><a href="../329472/index.html">Basic storage protocols: use and prospects</a></li>
<li><a href="../329474/index.html">Intel provides access to clDNN [high-performance library for deep learning]</a></li>
<li><a href="../329478/index.html">Survival Checklist</a></li>
<li><a href="../329480/index.html">The online store's productivity is sketchy or where to start improving it</a></li>
<li><a href="../329482/index.html">A selection of free veeam tools</a></li>
<li><a href="../329484/index.html">Autopilot on your own: sensor fusion from the phone and open training data</a></li>
<li><a href="../329488/index.html">Visual editor of letters on React + Redux. Overview, example of use and expansion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>