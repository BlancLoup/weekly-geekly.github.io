<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exposing rasterization algorithms fonts (2/2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(the second part of the translation of the article Exposing font rasterization algorithms ) 

 Linux 
 Inheriting the worst 
 Windows rasterizes fonts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exposing rasterization algorithms fonts (2/2)</h1><div class="post__text post__text-html js-mediator-article">  (the second part of the translation of the article <a href="http://habrahabr.ru/blogs/google/112401/">Exposing font rasterization algorithms</a> ) <br><br><h3>  Linux </h3><br><h4>  Inheriting the worst </h4><br>  Windows rasterizes fonts badly, Linux is even worse.  All Linux systems I've seen use <a href="http://freetype.org/">FreeType</a> [10] by David Turner, Robert Wilhelm and Werner Lemberg.  This is an excellent library, but unfortunately it‚Äôs not a good way to use it.  A typical screenshot of Linux looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/805/d32/d59/805d32d595eaa5e99fb0cfa74a5202ee.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is the full screenshot: <br>  <a href="">link</a> <br><br>  Immediately noticeable problem - black spots in rounded corners, formed as a result of smoothing.  In general, it can be said that oblique strokes look heavier than vertical ones, which in the end gives the impression of ‚Äúdirt‚Äù.  You can argue that FreeType and Linux could use subtyx pixel rasterization similar to ClearType, but for me it does not give any noticeable advantages. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/740/62e/c78/74062ec786c746a0f733f6626375e618.png"><br><br>  Look at ‚ÄúW‚Äù, ‚Äúv‚Äù and ‚Äúy‚Äù - the problem is essentially the same, the characters look dirty.  You can slightly improve the situation in the corners, using gamma correction in the process of rasterization, but this still does not allow to achieve a perfect display. <br><br><h4>  Gamma Correction </h4><br>  Gamma correction works like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99f/a90/650/99fa90650855458b0895914cd3e90ff8.png"><br><br>  As you can see, rounded corners with anti-aliasing look much better with gamma 2.0.  Gamma correction is a separate non-trivial topic, and, if you are interested, you can find comprehensive information in the Charles Point <a href="http://www.poynton.com/GammaFAQ.html">‚ÄúGamma FAQ‚Äù</a> [6]. <br><br>  In our case, we are not talking about the curves "source signal - result" in electronic circuits, rather, the specifics of human vision.  Visual response is roughly proportional to the square root of the physical luminosity.  In other words, if we have two white pixels on a black background, and one of them emits two times more photons than the second, this does not mean that it will look twice as bright.  In fact, about 1.4 times.  You can easily verify this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a7/f1b/3b2/3a7f1b3b2fe222a2651ccd32374f90e5.png"><br><br>  On the right - two pixels, and we can safely say that they emit twice as many photons per second than the pixel on the left.  However, they do not look twice as bright.  Four pixels will give about twice the brightness, but not two. <br><br>  By omitting unnecessary explanations, we can say that there are two basic RGB color spaces: subjectively uniform, which is called sRGB, and physically uniform.  In the latter, the value is proportional to the physical luminosity, as opposed to sRGB, in which the value is proportional to the subjective luminosity.  Usually, a physically uniform color space is simply called ‚Äúlinear RGB‚Äù.  When using anti-aliasing, color reduction should be performed in a linear space, but before output to the screen it is necessary to bring the colors to sRGB.  In practice, this step is often ignored, and smoothing is performed directly in sRGB.  In many cases, this gives an acceptable result, but not for rasterizing the text, which can be demonstrated directly in Microsoft Word.  The thing is that they use some kind of trick to select text, something like a trivial inversion, instead of redrawing from scratch.  With plain black-and-white anti-aliasing, selected text looks messy.  With ClearType, it acquires a color border: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/031/355/a03031355c6209db19d1238bd4a94e5a.png"><br><br>  So we can conclude that Windows is correct gamma correction (but not for the selected text), in Linux it is usually ignored.  FreeType can easily apply the desired gamma transformation to the black and white smoothing mask that the rasterizer generates.  But it will work the same way as in Windows: inverting the colors will invert the gamma.  In practice, this is useless, since gamma must be applied separately to each color component before mixing (which in practice is equivalent to working in linear RGB).  Therefore, the gamma correction for a black and white mask will help only if you display black text on a white background.  In this case, you can use the value in area 2 for correction. But if you display white text on a black background, you need to invert the gamma value, that is, use something around 0.5.  The problem is that you do not know the exact color of the text and background, the text can also be displayed on top of a gradient or image.  So the ‚Äúblack-and-white‚Äù gamma correction will not work, and the ‚Äúfull-color‚Äù gamma correction can be costly and difficult to implement.  The problem is that for linear RGB you need more than 8 bits per channel, otherwise you will inevitably get a color loss.  For text, this may be valid, but you cannot claim it for the entire desktop!  And working in linear RGB, using 16 bits per channel, is still an impermissible luxury. <br><br><h4>  Gamma does not work </h4><br>  In fact, the situation is even worse.  You can apply gamma correction with a value of 2 to the screenshot from Linux in the same Irfanview (Image-&gt; Enhance colors ...) and look at the text.  Please try not to pay attention to the fact that the icons look overexposed, concentrate on the text. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52c/b42/9d3/52cb429d3f93df3cd95a6b616a60e5d9.png"><br><br>  You like?  I'm still not there.  When I was working on rasterizing text in <a href="http://www.antigrain.com/">AGG</a> , I thought that correct gamma correction could solve all the problems.  Nothing like this!  No matter how well it works, some elements look thicker, and some - thinner than vertical and horizontal strokes.  This is very noticeable on sans serif fonts, and especially when the strokes are strictly pixel aligned.  The problem is that TrueType hinting was specifically designed for a conventional black and white rasterizer without anti-aliasing!  Using any anti-aliasing is formally incorrect, and most Linux systems do just that.  The image below is the result of rasterization with anti-aliasing using both FreeType and GetGlyphOutline (). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/09d/e11/15109de111e8507953f4a3e4e51daa58.png"><br><br>  The text looks lousy and it is very similar to what we see in most cases in Linux.  No gamma correction will help here.  For example, the best result I got with a gamma value of 1.5.  Still looks bad: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/97e/1c8/b2b97e1c8d433872601239afd591a31d.png"><br><br>  Along the way, you should have noticed that, starting from a certain size, the text starts to seem heavy.  This is exactly what is happening in Windows.  If you turn off ClearType, it will be obvious (the text size is not saved exactly). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a18/eb9/8ed/a18eb98ed7d062bd8504ee919f75a888.png"><br><br>  In general, you get the idea.  To make it more obvious, we can enlarge the vector image that the GetGlyphOutline () function returns from the Win32 API, and see what happens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/165/079/03d/16507903ddfe057710ae1a0e3b66f966.png"><br><br>  This is how proprietary aggressive hinting works for a nominal size of 13 pixels.  That is why the strokes in ‚Äúk‚Äù look so thin, almost invisible.  In italics, Times New Roman is still worse: the oblique stroke in ‚Äúz‚Äù disappears completely.  The distortions do not affect the normal rasterizer without smoothing, but the one that uses FreeType is sensitive to these things.  He directly calculates the degree of pixel coverage, so that he honestly gets a zero coverage for the oblique z-dash.  That is, it turns out that there is no point in interpreting TrueType bytecode for hinting (not to mention that you will have to buy a license).  Smoothing is good, but it should not be applied for its own sake.  In any case, I would prefer a non-anti-aliasing text if used in conjunction with inadequate hinting. <br><br><h4>  Autochinter FreeType </h4><br>  In FreeType version 2, David Turner introduced the auto-torque mechanism.  It works quite well, but, nevertheless, its direct application gives a result that is far from ideal.  Look at the result of rasterizing the Verdana headset with a gamut of 1.5: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dbe/e0d/4e8/dbee0d4e8d6f83d093ae50b7f0b6a16b.png"><br><br>  Compare with the example without hinting: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7bb/5d3/9c1/7bb5d39c120ca5cf7dcf8f4e61b51db7.png"><br><br>  The version without hinting definitely looks more accurate, but also more blurred.  There are three main differences: <br><br><ol><li>  Autohinting still produces errors in rounded small elements (the same visual difference in thickness between vertical and oblique strokes). </li><li>  Sometimes auto-quoting leads to incorrect kerning, as in ‚Äúog‚Äù in the word ‚ÄúDog‚Äù (in this example, a kerning table from a font was used). </li><li>  Auto-hinting leads to the same problem of accumulating an error throughout a line of text, with the result that the right edge of the text acquires ‚Äúnotches‚Äù. </li></ol><br>  Autochinter works better with more complex fonts, such as Times New Roman, but the same positioning problems still occur. <br><br><h3>  What to do? </h3><br>  Looking ahead, I'll show you another example. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/490/e0d/02d490e0d87cf7ef77b1bc05b2cbecd6.png"><br><br>  Still, it is possible to find an acceptable solution!  But first you need to agree that there is no way to use hinting of any kind and at the same time maintain the correct position of the text on any scale.  Only text without hinting, with its natural blur.  However, we can improve rasterization, although we will have to sacrifice something not very important.  Namely, we can afford a small inaccuracy in the vertical positioning and height of the text.  Among other things, TrueType hinting works in the same way: lines of text with a height of, say, 12 and 13 pixels will have the same height on the screen, although they will look different. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/715/769/e99715769f509741028668e723b54d64.png"><br><br>  In short, for a nice looking text and at the same time maintaining accurate horizontal positioning, we need the following: <br><br><ol><li>  Use horizontal sub-pixel RGB anti-aliasing on LCD monitors. </li><li>  Use only vertical hinting and completely abandon the horizontal. </li><li>  Use exact glyph offset values ‚Äã‚Äãcalculated at high resolution for non-hinting glyphs. </li><li>  Use exact high resolution values ‚Äã‚Äãfrom the kerning table. </li></ol><br>  A small gamma correction may improve the result, but this is not necessary.  The text looks good even directly in sRGB, which means that there will be no problems with inverted color schemes. <br><br>  You can easily achieve acceptable results with FreeType and its autochinter.  This means that you don‚Äôt need to worry about licensing TrueType proprietary hinting.  The same can be done using the GetGlyphOutline () function from the Win32 API.  It is more difficult, but still possible. <br><br><h4>  Subpixel rasterization in RGB </h4><br>  You can find a comprehensive guide on the use of sub-pixel rasterization in RGB on the pages of Steve Gibson, <a href="http://www.grc.com/cleartype.htm">"Sub-pixel rasterization technology"</a> [2].  I also tried to use this technology with 64-level raster images with anti-aliasing that GetGlyphOutline () can generate: Maxim Shimanarev, <a href="http://www.byte.com/documents/s%3D9553/byt1113241694002/0411_shemanarev.html">"How ClearType</a> works <a href="http://www.byte.com/documents/s%3D9553/byt1113241694002/0411_shemanarev.html">in Windows Longhorn"</a> [3] (UPD: link is rotten, but you can read <a href="http://www.blitzware.com/windows-long-horn.asp">here</a> , <a href="http://permalink.gmane.org/gmane.comp.graphics.agg/2442">here</a> or <a href="http://pastebin.com/ySWZRQfa">here</a> ).  You can download the Windows demo program with all the sources at this link: <br>  <a href="">antigrain.com/stuff/lcd_font.zip</a> <br><br>  In addition, I wrote a simple, ‚Äúon the knee for the evening,‚Äù rasterizer for <a href="http://www.antigrain.com/">AGG</a> .  It can be found in the demo examples that follow.  At the moment, the code is unsafe and rather slow.  This is normal for demonstration programs, but is unacceptable in a real project, primarily due to the fact that it uses a temporary buffer for no more than 2,048 pixels in the stack. <br><br>  In the simplest case, all we need is the transparency values ‚Äã‚Äãfor each color channel.  In this file, agg_pixfmt_rgb24_lcd.h.  I also used the extra blur that Steve Gibson describes.  It runs on the go, although it can be done in advance using some kind of caching mechanism.  In this case, it will work much faster, at least not slower than classical alpha blending. <br><br>  For debugging channel blending, I used Brian <a href="http://www.csc.calpoly.edu/~bfriesen/software/zoomin.shtml">Fraizen‚Äôs ZoomIn</a> [9] program.  I added ‚Äúdecoding‚Äù triples of colors on all scales that are multiples of three.  You can download the executable file here: <a href="">antigrain.com/stuff/ZoomInLcd.zip</a> (in 2005, I lost the modified source code. In any case, these modifications are easy to do on your own).  You can compare the enhanced results of conventional black and white and subpixel RGB rasterization: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/962/931/cb7962931343f3a9c7d1ef645cd3c7c1.png"><br>  Black and white rasterization <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aec/42f/d87/aec42fd87b1a38a50b7b7046fb361208.png"><br>  Subpixel RGB rasterization <br><br><h4>  Other nuances </h4><br>  To keep the vertical hinting, but to get rid of the horizontal, we will simply deceive the hinter: we stretch the characters horizontally so that the hinter is forced to work with high precision.  The problem is that the <a href="http://www.antigrain.com/">AGG</a> font engine for FreeType uses inaccurate offset values, given hinting.  Technically, a hinter should calculate the exact offset values ‚Äã‚Äãfor strongly stretched glyphs, but for some reason it does not.  I had to modify it in order to use the original, ‚Äúnon-screwed‚Äù offsets.  A modified version is also included in the demo programs.  Once the glyph curve is obtained, we use an affine transformation to compress it back.  In the simplest case, that's all we need.  The kerning table contains fairly accurate values. <br><br>  So I want to turn to David Turner: maybe it makes sense to add to his autochinter an option that would allow performing hinting only on the Y axis, ignoring the hinting on the X axis?  Or you can make a separate 1-D hinter, much simpler than the existing one.  As you will see, the text with sub-pixel RGB rasterization looks very similar to the Adobe Acrobat Reader, and, in any case, is much better than in any modern Linux system (the <i>article was written in 2007 - approx. Transl.</i> ).  I believe this will help promote and increase the popularity of Linux based systems. <br><br>  Using the Windows API is much more complicated.  The GetGlyphOutline () function returns the offset value in integer pixels, which is too rough for us.  Stretching does not save.  There are more functions like GetCharABCWidthsFloat (), but they are useless, since they calculate values ‚Äã‚Äãfor hint glyphs and despite the fact that they contain floating-point numbers, it‚Äôs still, in fact, integers.  So I did not find an easy way to get accurate offsets.  As a result, I had to use two fonts at the same time, one 1024 pixels high, and the other the size we need, with hinting and a stretched affine matrix.  I admit that I could miss something, but I have no thoughts about how this can be implemented more correctly.  Perhaps, in Microsoft Word, they use some undocumented functions, which is absolutely unfair from the point of view of competition.  Of course, I cannot be completely sure of this, but the situation makes me think that Microsoft deliberately does not provide a sufficiently good API for developing WYSIWYG document management tools.  This is a typical policy of a monopolist, which as a result leads to inhibition of technical progress. <br><br>  In fact, everything is worse.  Proprietary hinter does not work with a ‚Äústretched‚Äù matrix!  At a minimum, I did not find any scaling factor that would correctly process the glyphs.  Only the 1: 1 scale worked correctly, but as a result I got the same problems that forced me to use a black and white rasterizer without smoothing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/fb6/aec/4e4fb6aecda45d9560e9ac5c50099389.png"><br><br>  It looks terrible, is not it?  Any scaling led to badly damaged glyphs.  Here, for example, italics Times New Roman (16x stretching horizontally): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc0/039/143/dc00391437be67724b5e98fab4f2866b.png"><br><br>  Or even so.  Arial (stretching 100 times horizontally) - funny smudges, right?  But it is impossible to read: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/310/8a5/e5f/3108a5e5f569503a2fbf83fc56673a5a.png"><br><br>  I think it makes no sense to say that the FreeType autochinter works correctly with any stretching. <br><br>  It looks as if the Microsoft API is just a collection of unhealthy, random solutions ‚Äúon the knee‚Äù without any engineering culture and global idea behind all this.  As a rule, you can use Microsoft software only in one strictly predetermined way.  Step to the right, step to the left - and all is lost.  It may be good for their business, but at least unfair.  Such a policy violates the conditions of equal competition and as a result slows down the overall progress in the market.  The antimonopoly committee should pay attention to this situation, instead of ridiculous demands to remove Media Player or Internet Explorer from the system. <br><br>  In the end, I found out that the value "16" is the lesser evil, it is suitable for most cases, but still does not work for the Times New Roman italics. <br><br><h4>  Demonstration program </h4><br>  Here it is, a Windows program using TrueType: <br>  <a href="">www.antigrain.com/research/font_rasterization/truetype_test_02_ft.zip</a> <br><br>  And here is the version that uses the Windows API: <br>  <a href="">www.antigrain.com/research/font_rasterization/truetype_test_02_win.zip</a> <br><br>  The version under FreeType requires the following files in the program directory: arial.ttf, ariali.ttf, georgia.ttf, georgiai.ttf, tahoma.ttf, times.ttf, timesi.ttf, verdana.ttf, verdanai.ttf.  You can find them in the% WINDIR% \ Fonts folder. <br><br>  If you want to compile it, download <a href="http://www.antigrain.com/">AGG</a> version 2.4 or 2.5 and unpack the files somewhere like agg-2.4 \ research \ win32 \ trutype_lcd \ *. *.  For the FreeType version, you will also need to build FreeType yourself, and possibly change the project settings. <br><br>  A program can also be compiled for Linux / X11 or another system if you write an appropriate makefile, similar to those used in the <a href="http://www.antigrain.com/">AGG</a> examples. <br><br>  Text in FreeType and WinAPI versions looks different due to different hinting algorithms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/53e/d91/0f653ed91c613ea77896517a6a0804c5.png"><br><br>  You see here a large number of settings.  First, we can change the fonts, and also enable or disable kerning, hinting and subpixel RGB rasterization.  In addition, you can invert the image to get white text on a black background. <br><br>  Slider "Font Scale" allows you to smoothly change the font size.  As you can see, when hinting is on, lines are attached to pixels, but the width of the text continues to change smoothly.  You can better see this effect by changing the interval.  Without hinting, the layout of the text is perfectly preserved on any scale, but the text looks blurry.  Vertical pegging of lines is the most reasonable compromise between sharpness and accuracy of text layout.  I myself am shocked by how much vertical hinting improves quality while preserving the shape of characters. <br><br>  The interval, width, and ‚Äúimitation italics‚Äù sliders, I think, do not need comments.  For people familiar with computer graphics, it is obvious that these are ordinary <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2584%25D1%2584%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">affine transformations</a> .  I would like to note only one fact: in the ‚Äúblack-and-white‚Äù and ‚Äúsub-pixel RGB rasterization‚Äù modes the ‚Äúitalic imitation‚Äù slider works a little differently.  This is because I was too lazy to process its values ‚Äã‚Äãcorrectly, through arctangents.  In any case, it is irrelevant. <br><br>  The function I'm particularly proud of is ‚Äúimitation of bold.‚Äù  It works like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d5/6f4/b95/0d56f4b950c5d51da4082e6c424a10b1.png"><br><br>  There is one more simple trick.  <a href="http://www.antigrain.com/">AGG</a> has a utility called conv_contour, which allows you to calculate an equidistant for a given polygon.  But using it directly gives a too vague result, and also significantly changes the shape of the characters (although this can be useful for glow and shadow effects): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5af/c2d/0a2/5afc2d0a2982ac75e934166ff3f86773.png"><br><br>  Blur is easy to avoid.  We stretch the glyphs vertically, say, 100 or 1000 times, calculate an equidistant polygon and compress it back.  So as a result, the coordinates along the Y axis almost do not change and the text remains clear.  The demonstration program has a class of "faux_weight".  Again, it's amazing how many features free horizontal scaling gives.  And no less amazing, as far as binding to the pixels vertically improves the visual result. <br><br>  Another example (I love this freedom): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/fca/041/d17fca0419528939e7fc003793797a8e.png"><br><br>  This is still the same Georgia headset, but only programmatically converted.  It is quite readable, clear and smooth at the same time (yes, I agree, hand kerning would not hurt her). <br><br>  Or the same for the Tahoma headset: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a47/7d2/dcc/a477d2dcc14fc9966ae7dd7ca80ca5d8.png"><br><br>  The gamma adjustment slider controls the gamma correction (it is performed separately for each channel).  Theoretically, one should apply an ‚Äúimmediate gamut‚Äù to the original colors, and then, after drawing the scene, apply an ‚Äúinverted gamut‚Äù.  But, since the text in these examples is always white or black, there is no point in the first operation. <br><br>  The primary weight slider controls the distribution of energy as described by Steve Gibson: <a href="http://www.grc.com/freeandclear.htm">www.grc.com/freeandclear.htm</a> .  Enough to manage only the primary weight, and the rest to count accordingly.  By increasing the primary weight, you can make the text clearer, but a colored outline appears around the signs.  It makes sense to use values ‚Äã‚Äãup to 0.5, for large values ‚Äã‚Äãthe color ‚Äúglow‚Äù becomes too noticeable.  As for me, Windows ClearType also gives too noticeable color "glow". <br><br><h4>  Such rasterization can work quickly. </h4><br>  The demo program is pretty slow.  Partly because vector operations are performed on the fly, but primarily because of the WinAPI function GetGlyphOutline (), which itself is terribly slow.  On the other hand, such rasterization can be no less fast than any hardware accelerated rasterization of text.  But for starters, you have to agree that accelerating the rasterization of arbitrarily changing text while preserving hinting, correct markup, and precise sub-pixel quality is not an easy task in principle.  By arbitrary transformations, I mean truly arbitrary ones, including perspective and any non-linear transformations. <br><br>  Most of the time, we have to deal with horizontal text, even when using East Asian languages.  In addition, most of the time glyphs use the same nominal size.  From this it follows that a caching mechanism would be useful here.  A sub-pixel black and white mask for three RGB channels requires three times more memory, but at the same time gives text positioning accuracy up to 1/3 of a pixel.  In most cases, this works quite well.  Unless for theoretical ‚Äúluxurious‚Äù rasterization, you can use two black-and-white masks on the glyph, getting 1/6 pixel accuracy.  Even software alpha blending works fairly quickly - about 2-4 ms per glyph on modern Intel or PPC processors.  Using a GPU this can happen even faster if you load the appropriate textures.  The only problem is that the GPU should allow alpha blending across channels, which, as far as I know, seems possible.  At a minimum, David Brown mentions this <a href="http://download.microsoft.com/download/1/8/f/18f8cee2-0b64-41f2-893d-a6f2295b40c8/TW04007_WINHEC2004.ppt">in his presentation</a> [8].  But I could not find more information on this topic (how to get a 6-channel output from a pixel shader) and I would be grateful if you would offer me any links on this topic. <br><br><h3>  Links </h3><br><ol><li>  Joel Spolsky, Font smoothing, anti-aliasing, and sub-pixel rendering. <br>  <a href="http://www.joelonsoftware.com/items/2007/06/12.html">www.joelonsoftware.com/items/2007/06/12.html</a> </li><li> Steve Gibson, Sub-Pixel Font Rendering Technology. <br> <a href="http://www.grc.com/cleartype.htm">www.grc.com/cleartype.htm</a> </li><li> Maxim Shemanarev, Inside ClearType in Windows Longhorn. <br> <a href="http://www.byte.com/documents/s%3D9553/byt1113241694002/0411_shemanarev.html">www.byte.com/documents/s=9553/byt1113241694002/0411_shemanarev.html</a> <br> (requires online registration.) </li><li> FontFocus white paper, <a href="http://artofcode.com/fontfocus/">artofcode.com/fontfocus</a> </li><li> Jeff Atwood, Font Rendering: Respecting the Pixel Grid. <br> <a href="http://www.codinghorror.com/blog/archives/000885.html">www.codinghorror.com/blog/archives/000885.html</a> </li><li> Charles Poynton, Frequently-Asked Questions about Gamma. <br> <a href="http://www.poynton.com/GammaFAQ.html">www.poynton.com/GammaFAQ.html</a> </li><li> Dave Shea, A Subpixel Safari. <br> <a href="http://mezzoblue.com/archives/2007/06/12/a_subpixel_s">mezzoblue.com/archives/2007/06/12/a_subpixel_s</a> </li><li> David Brown, Avalon Text. A PowerPoint presentation. <br> <a href="http://download.microsoft.com/download/1/8/f/18f8cee2-0b64-41f2-893d-a6f2295b40c8/TW04007_WINHEC2004.ppt">download.microsoft.com/download/1/8/f/18f8cee2-0b64-41f2-893d-a6f2295b40c8/TW04007_WINHEC2004.ppt</a> </li><li> Brian Friesen, ZoomIn Program. <br> <a href="http://www.csc.calpoly.edu/~bfriesen/software/zoomin.shtml">www.csc.calpoly.edu/~bfriesen/software/zoomin.shtml</a> </li><li> David Turner and the others, FreeType font Library. <br> <a href="http://freetype.org/">freetype.org</a> </li><li> Jim Mathies, XP Style DPI Scaling. <br> <a href="http://www.mathies.com/weblog/%3Fp%3D908">www.mathies.com/weblog/?p=908</a> </li><li> Long Zheng, Windows Vista DPI scaling: my Vista is bigger than your Vista <br> <a href="http://www.istartedsomething.com/20061211/vista-dpi-scaling">www.istartedsomething.com/20061211/vista-dpi-scaling</a> </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: </font></font><a href="http://goo.gl/s3vuWV"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first part of the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the web archive (with pictures). </font></font><a href="http://goo.gl/LKxIzF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second part of the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the web archive (with pictures). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPS: Some interesting links for people interested in screen typography: </font></font><br> <a href="http://habrahabr.ru/post/114115"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Font size: not everything is so simple </font></font></a> <br> <a href="http://habrahabr.ru/post/247703"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonts on a budget monitor in Windows 8 </font></font></a> <br> <a href="https://habrahabr.ru/post/248135/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High DPI values ‚Äã‚Äãin Windows OS </font></font></a> <br> <a href="http://si14.livejournal.com/60773.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protection of programmers</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/112400/">https://habr.com/ru/post/112400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112392/index.html">In Russia, more and more mobile phone owners are using mobile Internet access.</a></li>
<li><a href="../112393/index.html">Who will take a pack of tickets, he will receive a water pump!</a></li>
<li><a href="../112394/index.html">Monoids and their applications: monoidal calculations in trees</a></li>
<li><a href="../112396/index.html">The creators of Pirate Bay are planning to launch Music Bay</a></li>
<li><a href="../112399/index.html">‚ÄúWhen ideas are worth something‚Äù or what if the scheme is ‚Äúflipped‚Äù?</a></li>
<li><a href="../112401/index.html">Exposing font rasterization algorithms (1/2)</a></li>
<li><a href="../112402/index.html">The fastest settings for PHP scripts</a></li>
<li><a href="../112404/index.html">Universal solution for printing on network printers under Windows 7 / Vista / 2003/2008</a></li>
<li><a href="../112405/index.html">50 start-up meetings</a></li>
<li><a href="../112407/index.html">A couple of new templates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>