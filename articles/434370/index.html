<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular shadow shadows in the Phaser, or the use of bicycles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Two years ago, I experimented with substances shadows in the Phaser 2D. At the last Ludum Dare, we suddenly decided to make a horror, but what a horro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular shadow shadows in the Phaser, or the use of bicycles</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habr.com/post/319530/">Two years ago,</a> I experimented with <s>substances</s> shadows in the Phaser 2D.  At the last Ludum Dare, we suddenly decided to make a horror, but what a horror without shadows and light!  I crunched my knuckles ... <br><br>  ... And not a damn thing for LD.  The game certainly has a little light and shadows, but this is a pitiful semblance of what it really should have been. <br><br>  After returning home after sending the game to the competition, I decided to ‚Äúclose the gestalt‚Äù and finish these unfortunate shadows.  What happened - you can <a href="https://graal.itch.io/nope-postld%3Fsecret%3D34xxzD7ls3zu4TWHUCIQk829Fs">feel in the game</a> , <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3F">play around in the demo</a> , look at the picture, and read the article. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/if/35/m3if351xwaowt3lxcayun-cuzak.png"></div><br><a name="habracut"></a>  As always in such cases, it makes no sense to try to write a general solution, you need to focus on a specific situation.  The game world can be represented in the form of segments - at least those entities that cast shadows.  The walls are rectangles, people are rectangles, only turned, hellish spoiler is a circle, but it can be simplified in the cut-off model to a length of diameter, which is always perpendicular to the beam of light. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dh/gq/id/dhgqidngehzo_pn9vgr9eirsgna.png"></div><br>  There are several light sources (20-30), and all of them are circular (spotlights) and are conditionally lower than the illuminated objects (so the shadows can be infinite). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I saw in my head the following ways to solve the problem: <br><br><ol><li>  For each light source we build a texture the size of a screen (well, or 2-4 times smaller).  On this texture, we simply draw the trapezium BCC'D ', where A is the light source, BC is the line segment, B'C' is the projection of the line onto the edge of the texture.  After these textures are sent to the shader, where they are mixed into a single picture. <br><br>  Something like this was done by the author of the platformer Celeste, which is well written in his article on medium: <a href="https://medium.com/%40NoelFB/remaking-celestes-lighting-3478d6f10bf">medium.com/@NoelFB/remaking-celestes-lighting-3478d6f10bf</a> <br><br>  Problems: 20-30 screen-sized textures that need to be redrawn almost every frame and loaded into the GPU.  I remember that it was a very, very not a quick process. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z2/ve/ya/z2veyaflrtcpobcfkkdecuqpkpa.png"></div><br></li><li>  The method described in the post on the <a href="https://habr.com/post/272233/">habr</a> is <a href="https://habr.com/post/272233/">habr.com/post/272233</a> .  For each light source we build a ‚Äúdepth map‚Äù, i.e.  a texture where x = the angle of the ‚Äúray‚Äù from the light source, y = the number of the light source, and color == the distance from the source to the nearest obstacle.  If we take, say, a step of 0.7 degrees (360/512), and 32 light sources, then we get one texture 512x32, which is not updated for so long. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aq/ew/_x/aqew_xze8rbkwvhj-68t3d4glz4.png"></div>  <sup>(texture example for a step of 45 degrees)</sup> <br></li><li>  The secret method that I will describe at the very end </li></ol><br>  In the end, I settled on method 2. However, the article described in the article did not fully suit me.  There, the texture was also built in the shader with the help of rakest - the shader in the loop went from the light source in the direction of the beam and looked for an obstacle.  In my past experiments, I also did rake in the shader, and it was very expensive, though universal. <br><br>  ‚ÄúWe have some segments in the model,‚Äù I thought, ‚ÄúAnd 10-20 segments fall into the radius of any light source.  Can't I quickly calculate the distance map based on this? ‚Äù. <br><br>  So I decided to do it. <br><br>  For a start, I just brought up the walls, the conventional ‚Äúmain character‚Äù and light sources on the screen.  Around the light sources cut out in the mist a circle of pure clear light.  To get this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/jh/y4/yljhy4kuzvmkdqscqjuzsbqfjms.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3Fmode%3Dsimple%26lightDecay%3Dfalse%26smoothShadow%3Dfalse%26floatingBulbs%3Dfalse">demo</a> )</sup> <br><br>  I immediately began to do with the shader, so as not to relax.  It was necessary to transfer to it for each light its coordinates and range (beyond which the light does not reach), this is done simply through a uniform array.  And then in the shader (which is fragmentary, which is performed for each pixel on the screen), it remains to be seen whether the current pixel enters the lit circle or not. <br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLightShader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(game) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(game); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lightsArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(MAX_LIGHTS*<span class="hljs-number"><span class="hljs-number">4</span></span>); lightsArray.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, lightsArray.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'1i'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'4fv'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: lightsArray}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragmentSrc = <span class="hljs-string"><span class="hljs-string">` precision highp float; uniform int lightsCount; uniform vec4 lights[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">]; void main() { float lightness = 0.; for (int i = 0; i &lt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; lightness += step(length(light.xy - gl_FragCoord.xy), light.z); } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,0.5), vec4(0,0,0,0), lightness); } `</span></span>; } updateLights(lightSources) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount.value = lightSources.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> light <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> lightSources) { array[i++] = light.x; array[i++] = game.world.height - light.y; array[i++] = light.radius; i++; } } }</code> </pre> <br>  Now we need to understand for each light source which segments will cast a shadow.  Rather, which parts of the segments - in the figure below we are not interested in the ‚Äúred‚Äù parts of the segment, since  the light still does not reach them. <br><br>  <i>Note: intersection definition is a kind of preliminary optimization.</i>  <i>It is necessary in order to reduce the time of further processing, eliminating large pieces of segments outside the radius of action of the light source.</i>  <i>It makes sense when we have a lot of segments, whose length is much larger than the radius of the ‚Äúglow‚Äù.</i>  <i>If this is not the case, and we have many short segments, it may be correct not to waste time on determining the intersection and process the segments as a whole, since</i>  <i>time savings still fail.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cb/93/mb/cb93mbs6zzyyqwvfx633ppxbtzg.png"></div><br>  To do this, I used the well-known formula for finding the intersection of a straight line and a circle, which everyone remembers by heart from a school geometry course ... in someone else's imaginary world.  I never remembered it, so I had to <a href="http://mathworld.wolfram.com/Circle-LineIntersection.html">google it</a> . <br><br>  Encode, look what happened. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_0/up/go/_0upgoezkyggo7sfkntejosckg0.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3FshowSegmentsDebug%3Dtrue%26mode%3Dsimple%26lightDecay%3Dfalse%26smoothShadow%3Dfalse%26floatingBulbs%3Dfalse">demo</a> )</sup> <br>  Like the rules.  Now we know what segments can cast a shadow and can perform raikast. <br><br>  Here we also have options: <br><br><ol><li>  Just go in a loop in a circle, throw rays and look for the intersection.  The distance to the nearest intersection is the value we need. </li><li>  You can go only on those angles that fall into the segments.  After all, we already know the points, it is easy to calculate the angles. </li><li>  Further, if we go along the segment, then we do not need to throw rays and count the intersections - we can move along the segment with the necessary step.  Here's how it works: </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9w/db/yp/9wdbyph5wjrn9dolovyhf_5y6-w.png"></div><br>  Here <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.741ex" height="2.057ex" viewBox="0 -780.1 1180 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-62" x="750" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> Ab </script>  - segment (wall), <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> C </script>  - the center of the light source <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.691ex" height="2.057ex" viewBox="0 -780.1 1589 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-44" x="760" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> CD </script>  - perpendicular to the segment. <br><br>  Let be <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-78" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> x </script>  - the angle to the normal for which you need to know the distance from the source to the segment, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.979ex" height="2.298ex" viewBox="0 -780.1 1282.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-31" x="1171" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> X_1 </script>  - point on the segment <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.741ex" height="2.057ex" viewBox="0 -780.1 1180 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-62" x="750" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> Ab </script>  where the beam falls.  Triangle <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.669ex" height="2.298ex" viewBox="0 -780.1 2871.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-44" x="760" y="0"></use><g transform="translate(1589,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-31" x="1171" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> CDX_1 </script>  - rectangular, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.691ex" height="2.057ex" viewBox="0 -780.1 1589 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-44" x="760" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> CD </script>  - the leg, and its length is known and constant for this segment, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.298ex" viewBox="0 -780.1 2042.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-31" x="1171" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-9"> CX_1 </script>  - the desired length. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="23.042ex" height="2.66ex" viewBox="0 -832 9921 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-31" x="1171" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-3D" x="2320" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-66" x="3626" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-72" x="4177" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-61" x="4628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-63" x="5158" y="0"></use><g transform="translate(5591,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-44" x="760" y="0"></use></g><g transform="translate(7180,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-63" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-6F" x="433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-73" x="919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-28" x="1388" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-78" x="1778" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-29" x="2350" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-10"> CX_1 = \ frac {CD} {cos (x)} </script>  .  If you know the step in advance (and we know it), then you can calculate the reverse cosine table in advance and look for distances very quickly. <br><br>  I will give an example of the code of such a table.  Almost all work with corners is replaced with work with indices, i.e.  integers from 0 to N, where N = the number of steps in the circle (i.e. the step angle = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.923ex" height="2.419ex" viewBox="0 -780.1 4703 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-70" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-69" x="1254" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/434370/&amp;xid=17259,15700002,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgxUCwMFeDodwGjZRA1zN6NqtaD6Q#MJMATHI-4E" x="3814" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> \ frac {2 \ pi} {N} </script>  ) <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HypTable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(steps = 512, stepAngle = 2*Math.PI/steps) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.perAngleStep = [<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; steps/<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   pi/2 let ang = i*stepAngle; this.perAngleStep[i] = 1/Math.cos(ang); } this.stepAngle = stepAngle; } /** * @param distancesMap -  ,    * @param angle1 -           * @param angle2 -           * @param normalFromLight - ,      */ fillDistancesForArc(distancesMap, angle1, angle2, normalFromLight) { const D = Math.hypot(normalFromLight.x, normalFromLight.y); const normalAngle = Phaser.Math.normalizeAngle(Math.atan2(normalFromLight.y, normalFromLight.x)); const normalAngleIndex = (normalAngle / this.stepAngle)|0; const index1 = (angle1 / this.stepAngle)|0; const index2 = (angle2 / this.stepAngle)|0; for (let angleIndex = index1; angleIndex &lt;= index2; angleIndex++) { let distanceForAngle = D * this.perAngleStep[normalize(angleIndex - normalAngleIndex)]; distancesMap.set(angleIndex, distanceForAngle); } } }</span></span></code> </pre><br>  Of course, this method introduces an error for the cases when the initial angle ACD is not a multiple of the step.  But for 512 steps, I visually do not see any difference. <br><br>  So, what we already know how to do: <br><ol><li>  To find segments in the radius of the light source that can cast a shadow <br></li><li>  For step t, make a table of dist (angle), passing through each segment and calculating the distance. </li></ol><br><br>  Here is how this table looks like if you draw it with rays. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/5m/17/kh5m17zbgdyq22dfeoys5borlbe.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3FshowRaycastDebug%3Dtrue%26steps%3D64%26mode%3Dsimple%26lightDecay%3Dfalse%26smoothShadow%3Dfalse%26floatingBulbs%3Dfalse%26showRaycastShaderDebug%3Dtrue">demo</a> )</sup> <br><br>  And this is how it looks for 10 light sources, if written in texture. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/ex/3-/bgex3-jcfuohb9_egfv_4ul-x2e.png"></div><br>  Here, each pixel horizontally corresponds to a corner, and color to a distance in pixels. <br>  All this is written in js like this using <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData">imageData</a> <br><pre> <code class="javascript hljs"> fillBitmap(data, index) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = index + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps*<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d1, d2; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//data[index] = Red //data[index+1] = Green //data[index+2] = Blue //data[index+3] = Alpha for (; index &lt; total; index+=4, i++) { //  512,    R     2. d1 = (this.distances[i]/2)|0; data[index] = d1; d1 = this.distances[i] - d1*2; d2 = (d1*128)|0; //   G -     2. data[index+1] = d2; //  B  A  255,     . data[index+2] = 255; data[index+3] = 255; } }</span></span></code> </pre><br><br>  Now we transfer the texture to our shader, which already has the coordinates and radii of the light sources.  And we process it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      uniform sampler2D iChannel0; #define STRENGTH 0.3 #define MAX_DARK 0.7 #define M_PI 3.141592653589793 #define M_PI2 6.283185307179586 //       float decodeDist(vec4 color) { return color.r*255.*2. + color.g*2.; } float getShadow(int i, float angle, float distance) { //   x   ==  float u = angle/M_PI2; //   y   ==     float v = float(i)/${MAX_LIGHTS}.; float shadowAfterDistance = decodeDist(texture2D(iChannel0, vec2(u, v))); //  1   ,  0  . return step(shadowAfterDistance, distance); } void main() { float lightness = 0.; for (int i = 0; i &lt; ${MAX_LIGHTS}; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; //       vec2 light2point = gl_FragCoord.xy - light.xy; float radius = light.z; float distance = length(light2point); float inLight = step(distance, radius); //      ,       //  . //      , //    ,          //           //     ,    if (inLight == 0.) continue; float angle = mod(-atan(light2point.y, light2point.x), M_PI2); // 1     0   float thisLightness = (1. - getShadow(i, angle, distance)); //,   ‚Äú‚Äù  ,   ,  //    lightness += thisLightness*STRENGTH; } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,MAX_DARK), vec4(0,0,0,0), lightness); }</span></span></code> </pre> <br><br>  Result: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/0l/hj/f90lhj2yepescdli2qndmyx-xkq.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3FlightDecay%3Dfalse%26smoothShadow%3Dfalse%26randomLightsOnStart%3D10%26floatingBulbs%3Dfalse">demo</a> )</sup> <br>  Now you can bring some beauty.  Let the light fade with distance, and the shadows will be blurred. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1s/op/sg/1sopsggdgrpurmn0qsui8rcfhne.png"></div><br>  To blur, I look at the adjacent corners, + - step, like this: <br><br><pre> <code class="cpp hljs">thisLightness = (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle, distance)) * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre><br><br>  If you put everything together and measure FPS, it turns out like this: <br><br><ul><li>  On embedded video cards, everything is bad (&lt;30-40), even for simple examples. <br></li><li>  On the rest - all is well, as long as the light sources are not very strong.  That is, the number of light sources per pixel is important, not the total number. <br></li></ul><br><br>  This result suited me completely.  One could still play around with the color of the lighting, but I did not.  A little more and adding some normal maps, I posted an updated version of NOPE.  She looked like this now: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cq/nw/4o/cqnw4opdblgnm6ebys-lgbtvnt4.gif"></div><br><br>  Then he began to prepare an article.  I looked at this gif and thought. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/de/zr/ctdezrcsaztxtgxx9jyioatirds.gif"></div><br>  ‚ÄúSo it's almost like a pseudo-3d view, like in Wolfenstein,‚Äù I exclaimed (yes, I have a good imagination).  And in fact - if we assume that all the walls are of the same height, then the distance map is enough for us to build the scene.  Why not try? <br><br>  The scene should look something like this. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/5v/-s/lg5v-sk8cmojfurrj_pnrg3xw0k.png"></div><br><br>  Hence, our task: <br><br><ol><li>  At the point on the screen get the world coordinates for the case when there are no walls. <br><br>  We will count as follows: <br><ul><li>  To begin with, we normalize the coordinates of a point on the screen so that in the center of the screen there is a point (0,0), and at the corners (-1, -1) and (1,1) respectively <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/ki/fu/l9kifubvfwn50ust9lhtsik2f_k.png"></div></li><li>  The x coordinate becomes the angle from the direction of gaze, you just need to multiply it by A / 2, where A is the angle <br></li><li>  The y coordinate determines the distance from the observer to the point, in general, d ~ 1 / y.  For a point on the lower edge of the screen, the distance = 1, for a point on the center of the screen, the distance = infinity. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8e/ua/4b/8eua4bycfatkegaiwbyu_eohxky.png"></div></li><li>  Thus, if you do not take into account the walls, then for each visible point of the world there will be 2 points on the screen - one above the middle (on the ‚Äúceiling‚Äù) the other below (on the ‚Äúfloor‚Äù) <br></li></ul></li><li>  Now we can look at the table of distances.  If there is a wall closer than our point, then it is necessary to draw a wall.  If not, then the floor or ceiling <br></li></ol><br>  We get as ordered: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/gj/lu/qpgjluavcmsuba51v0iovqdccc0.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3Fsteps%3D1024%26randomLightsOnStart%3D4%26pseudo3d%3Dtrue%26pseudo3dTexture%3Dfalse%26pseudo3dLights%3Dfalse">demo</a> )</sup> <br>  Add lighting - in the same way, we iterate over the light sources and check the world coordinates.  And - the final touch - add textures.  To do this, in the texture with distances it is also necessary to record the displacement u for the wall texture at this point.  This is where the b channel came in handy. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/ai/ay/knaiayi9epavp3cr8u6wcd4x2ss.png"></div>  <sup>( <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html%3Fsteps%3D1024%26randomLightsOnStart%3D4%26pseudo3d%3Dtrue">demo</a> )</sup> <br>  Perfect. <br><br>  Just kidding <br><br>  Not perfect, of course.  But damn it, I also read how to make my Wolfenstein 15 years ago through racast, and I wanted to do it all, but here such an opportunity! <br><br><h4>  Instead of conclusion </h4><br>  At the beginning of the article I mentioned another secret method.  Here he is: <br><br><blockquote>  <b>Just take the engine that already knows how.</b> </blockquote><br>  In fact, if you need to make a game, then it will be the most correct and fastest way.  Why do you need to fence your bikes and solve long-solved problems? <br><br>  But why? <br><br>  In 10th grade, I moved to another school and faced math problems.  I do not remember the exact example, but this was an equation with degrees, which, by all indications, had to be simplified, but it just could not be done.  Desperate, I consulted with my sister, and she said: ‚Äúadd on both sides so x <sup>2</sup> and everything will go bad.‚Äù  And this was the decision: add something that was not. <br><br>  When I helped my friend build a house much later, I needed to put a bar in the threshold - to fill a niche.  And here I stand and sort out the trimming bars.  One seems to fit, but not quite.  Others are much smaller.  I think I think how to gather the word happiness, and my acquaintance says: ‚Äúthey drank so-called circular grooves where it interferes‚Äù.  And the big bar is already in place. <br><br>  These stories are united by such an effect, which I will call the ‚Äúinventory effect‚Äù.  When you try to make a decision from existing parts, without seeing in these details material that can be processed and refined.  The numbers are tree, money or code. <br><br>  I have seen this effect many times with my programming colleagues.  Without feeling confident in the material, they sometimes succumb when it is necessary to do, say, non-standard control.  Or add unit tests to where they were not.  Or they try to envisage everything, when designing a class, and then we have a dialogue like: <br>  - It is not necessary now <br>  - What if it becomes necessary? <br>  - Then we will add.  Leave the expansion points and that's it.  The code is not granite, it is plasticine. <br><br>  And to learn to see and feel the material with which we work, and we need bicycles. <br><br>  This is not just a workout for the mind or exercise.  This is a way to reach a qualitatively different level of working with code. <br><br>  Thank you all for reading. <br><br>  Reference, in case you forgot to click somewhere: <br><ul><li>  <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html">All demos together</a> </li><li>  <a href="https://alexeygrishin.github.io/ld-prepare/game15/index.html">Demo code</a> </li><li>  <a href="https://graal.itch.io/nope-postld%3Fsecret%3D34xxzD7ls3zu4TWHUCIQk829Fs">Actually LD-game with shadows</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/434370/">https://habr.com/ru/post/434370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434360/index.html">Explanatory conversation about asynchronous programming in Javascript</a></li>
<li><a href="../434362/index.html">Non-forecast for 2019</a></li>
<li><a href="../434364/index.html">Hangfire queue support</a></li>
<li><a href="../434366/index.html">The Big Four are preparing to share 5G frequencies</a></li>
<li><a href="../434368/index.html">Machine learning for finding errors in code: how I trained at JetBrains Research</a></li>
<li><a href="../434372/index.html">The development of the digital economy of Russia will cost the state 1.8 trillion rubles</a></li>
<li><a href="../434374/index.html">Check RBAC at Kubernetes</a></li>
<li><a href="../434376/index.html">"Yandex" will test its robomobil in Israel</a></li>
<li><a href="../434380/index.html">Basics of dependency injection</a></li>
<li><a href="../434382/index.html">Migrate Alpine Linux to RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>