<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extending JavaScript native objects - is it evil? SugarJS Manifesto</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the comments to the post about Underscore / Lo-Dash, I mentioned that among the libraries that extend the standard JavaScript library, I prefer Sug...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extending JavaScript native objects - is it evil? SugarJS Manifesto</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/171/7ab/548/1717ab548cc123ddb67822d9464b9a81.png" alt="SugarJS logo" align="right">  In the comments to the <a href="http://habrahabr.ru/post/217515/">post about Underscore / Lo-Dash,</a> I mentioned that among the libraries that extend the standard JavaScript library, I prefer SugarJS, which, unlike most analogues, works through the extension of native objects. <br><br>  This caused a heated discussion about whether it is permissible to extend native objects.  I was very surprised that almost everyone who spoke out opposed it. <br><br>  This prompted me to translate the SugarJS manifesto on this issue.  Apparently, the author of this library very often had to hear such attacks.  Therefore, he very carefully and rather impartially commented on each of them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This material deals with the pitfalls of JavaScript, known and not so, as well as proposed methods of protection.  Therefore, I think that the article will be interesting and useful to any JS developer, regardless of his attitude to the problem of expanding native objects. <br><br>  I give the word to Andrew Plummer. <br><br><hr><br>  So, Sugar is a library that modifies native JavaScript objects.  Wait, isn't it evil?  - you ask - have you not learned a lesson from the bitter experience of Prototype? <br><br>  There are many misconceptions about this.  Sugar avoids the pitfalls that Prototype stumbled over, and is fundamentally different in nature.  However, this choice is not without consequences.  Below are the potential problems caused by the change of native objects, and Sugar‚Äôs position about each of them is outlined: <br><ol><li>  Modification of environment objects </li><li>  Functions as enumerated properties </li><li>  Property Overriding </li><li>  Conflicts in the global namespace </li><li>  Assumptions about the lack of properties </li><li>  Compliance specification </li></ol><a name="habracut"></a><br><h2>  1. Modification of environment objects </h2><br><h4>  Problem: </h4><br>  The term ‚Äúenvironment objects‚Äù (host objects) means JavaScript objects provided by the environment in which the code is executed.  Examples of host objects: Event, HTMLElement, XMLHttpRequest.  Unlike native JavaScript objects that strictly comply with the specification, environment objects can vary at the discretion of browser developers, and their implementations in different browsers may differ. <br><br>  Without going into details, if you modify environment objects, your code may be prone to errors, slow down and be vulnerable to future environmental changes. <br><br><h4>  Sugar Position: </h4><br>  Sugar works only with native JavaScript objects.  The objects of the environment are not interesting for him (or, more precisely, unknown).  This path was chosen not only to avoid problems with host objects, but also to make the library accessible to a large variety of JavaScript environments, including those running outside the browser. <br><br>  From the translator: here <a href="https://www.npmjs.org/package/sugar">is the Sugar module</a> in the Node repository. <br><br><h2>  2. Functions as enumerable properties </h2><br><h4>  Problem: </h4><br>  In browsers that do not follow modern specifications, defining a new property makes it enumerable.  When traversing the properties of an object, the new property will be affected along with the properties containing the data. <br><br><div class="spoiler">  <b class="spoiler_title">Details</b> <div class="spoiler_text">  By default, when a new property is defined on an object, it becomes enumerable.  Thus, we store data in the objects and cycle through them: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = {}; o.name = <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> o) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(key); } <span class="hljs-comment"><span class="hljs-comment">// =&gt; name</span></span></code> </pre> <br>  If we assign a function as a new property (or, to put it in OOP, add a method to an object), this function will also be enumerated: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {}) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(key); } <span class="hljs-comment"><span class="hljs-comment">// =&gt; getName</span></span></code> </pre><br>  As a result, bypassing the properties of an object with a cycle will lead to an unexpected result, but we do not want that at all.  Fortunately, with the help of a slightly different syntax we can define non-enumerable methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype, <span class="hljs-string"><span class="hljs-string">'getName'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {}) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(key); } <span class="hljs-comment"><span class="hljs-comment">// =&gt; ()</span></span></code> </pre><br>  However, as always, there is a catch.  The ability to define non-enumerable properties is missing in Internet Explorer 8 and below. <br><br>  So, with the enumeration of the properties of ordinary objects sorted out, but what about the arrays?  Usually, to bypass the values ‚Äã‚Äãof arrays use the usual <code>for</code> loop with counters. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.name = <span class="hljs-string"><span class="hljs-string">'Harry'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[i]); } <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'a' // =&gt; 'b' // =&gt; 'c'</span></span></code> </pre><br>  As you can see, problems with the enumeration of properties can be avoided by simply spinning the counter.  If you bypass the object with <code>for..in</code> , the enumerated properties will fall into the loop: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.name = <span class="hljs-string"><span class="hljs-string">'Harry'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[key]); } <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'a' // =&gt; 'b' // =&gt; 'c' // =&gt; 'Harry'</span></span></code> </pre><br>  For this reason, when referring to the properties of objects by property names (and to the values ‚Äã‚Äãof arrays by index numbers) in loops of the form <code>for..in</code> , you should use the <code>hasOwnProperty</code> method.  This will exclude properties that do not belong to the object directly, but are inherited through a chain of prototypes: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.name = <span class="hljs-string"><span class="hljs-string">'Harry'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr.hasOwnProperty(key)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[key]); } } <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'a' // =&gt; 'b' // =&gt; 'c'</span></span></code> </pre><br>  This is one of the most common examples of good javascript practices.  Always use it when referring to object properties by property names. <br><br>  From the translator: <br><br>  The author does not mention that there is another array traversal method: <code>Array.prototype.forEach</code> .  As a result of a quick search, I found a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">polyfill</a> from the Mozilla Developer Network, which, according to them, algorithmically reproduces the specification (and, as you can see from the following link, it has the same performance as the native <code>forEach</code> ).  The polyfill code uses the first (safe) way to traverse the array.  At the same time, it is known that <code>forEach</code> <a href="http://jsperf.com/for-vs-foreach/144">noticeably slower than the</a> simplest <code>for</code> loop with a counter, apparently, due to additional checks. <br><br>  <code>forEach</code> is available in all modern mobile and desktop browsers.  Not available in IE8 and below. </div></div><br><h4>  Sugar Position: </h4><br>  Sugar makes its methods non-enumerable whenever possible, that is, in all modern browsers.  However, until IE8 finally disappears, you should always keep this problem in mind.  Its root lies in traversing the properties of the loop, and we should consider separately the two main types of objects that can be traversed by the loop: ordinary objects and arrays. <br><br>  Because of this problem (and also because of the problem of overriding properties), Sugar does not modify the Object.prototype, as is done in the examples above.  This means that using <code>for..in</code> loops on regular JavaScript objects will never lead to unknown properties in the loop, because there are none. <br><br>  With arrays, the situation is somewhat more complicated.  The standard way of traversing arrays is a simple <code>for</code> loop, which during each iteration increments the counter by one and uses it as the name of the property.  This method is safe and the problem also does not occur.  It is also possible to bypass the array with the <code>for..in</code> loop, but this is not considered good practice.  If you decide to use this approach, always use the <code>hasOwnProperty</code> method to check if the properties belong directly to the object (see the last example in the open box above). <br><br>  It turns out that traversing an array with a <code>for..in</code> and the lack of checking <code>hasOwnProperty</code> is a bad practice inside a bad practice.  If this code is executed in an outdated browser (IE8 and below), all the properties of objects, including Sugar methods, will come out, so <b>it is important to note that the problem exists</b> .  If your project breaks down when Sugar is included in it, the first thing you need to do is check whether you bypass the properties of the objects in the loops.  It is also worth noting that this problem is not a problem of Sugar alone, but is the case for all libraries that provide polyfills for array methods. <br><br>  Conclusion.  If you cannot rewrite the problematic code for traversing arrays, and support for IE8 and below is important to you, then you cannot use the Suray Array package.  <a href="http://sugarjs.com/customize">Build your Sugar assembly by</a> removing this package. <br><br><h2>  3. Redefinition of properties </h2><br><h4>  Problem: </h4><br>  In JavaScript, almost every entity is an object, which means it can have properties in the form of key-value pairs.  In JavaScript, "hashes" (they are also hash tables, dictionaries, associative arrays) are ordinary objects, and "methods" are simply functions assigned to properties of objects instead of data.  Good or bad, but any method declared for an object (directly or further along the chain of prototypes) is also a property, and it is accessed in the same way as for data. <br><br>  The problem becomes apparent.  For example, if the method <code>count</code> defined for all objects, and then some object is written to a property with the same name, the method will be unavailable. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.count = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">18</span></span> }; o.count <span class="hljs-comment"><span class="hljs-comment">// =&gt; 18</span></span></code> </pre><br>  The <code>count</code> property, which is directly defined for an object, seems to obscure the eponymous method, which lies further along the prototype chain (in the original ‚Äúcasts a shadow‚Äù - is ‚Äúshadowing‚Äù).  As a result, it is impossible to call a method for this object. <br><br><h4>  Sugar Position: </h4><br>  Together with the problem of enumerated properties, this is the main reason why Sugar does not modify the <code>Object.prototype</code> .  Even if you know in advance what methods of objects you will use and decide to avoid using properties of the same name, your code will still be vulnerable, and debugging redefined properties is not a pleasant task. <br><br>  Instead, Sugar prefers to present all methods for simple objects as static methods of the <code>Object</code> class.  As long as JavaScript does not make a difference between properties and methods, this approach will not change. <br><br>  From the translator: <br><br>  If desired, you can transfer the Sugar methods for working with ordinary objects to the properties of a specific object.  This is done with <code>Object.extended()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = {<span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>}, bar = {<span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>}; foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.extended(foo); foo.merge(bar); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo); <span class="hljs-comment"><span class="hljs-comment">// =&gt; {foo: 'foo', bar: 'bar'}</span></span></code> </pre><br><h2>  4. Conflicts in the global namespace </h2><br><h4>  Problem: </h4><br>  If you exist in the global namespace, your main source of stress is worrying about what you will be redefined.  When writing code, there is always a risk of how to break other people's methods, and the fact that someone will break yours. <br><br><h4>  Sugar Position: </h4><br>  First of all, it is important to pinpoint the essence of this problem: it is a question of awareness.  If you are the only developer in the project, modifying prototypes carries minimal danger, because you know what you modify and how.  If you work in a team, you may not be aware of everything. <br><br>  For example, if the developers Vasya and Petya define two methods in the same prototype that do the same thing, but have different names, then they only work inconsistently, but nothing criminal.  If they define two methods that perform different tasks but have the same name, they will break the project. <br><br>  The value of Sugar lies in, among other things, that it provides a single, canonical API, the only task of which is to add small helper methods to the prototypes.  Ideally, this task should be trusted only to one library (be it Sugar or some other).  To bring new players to the field of the global namespace, with whom you are not very familiar and whose tasks are less obvious, is to increase the risk.  This, of course, does not mean that you will immediately run into a problem.  The degree of risk needs to be correlated with the degree of your awareness. <br><br>  Libraries, plugins and other <b>middlemware should not use Sugar</b> for the same reason.  Modifying global objects must be a conscious decision of the end user.  If the author of the library nevertheless decides to use Sugar, he must inform his users about it in the most visible place. <br><br>  From the translator: I believe that any library should strive to have as few dependencies as possible, especially such optional ones as Sugar, Underscore and similar libraries.  They do not do anything that could not be rewritten in pure JavaScript.  Abuse of this rule by the authors of the libraries may lead to the fact that your project will have a mess of dependencies with duplicate and completely redundant functionality: Lazy.js, Underscore, Lo-Dash, wu.js, Sugar, Linq.js, JSLINQ, From .js, IxJS, Boiler.js, sloth.js, MooTools ... So the recommendation "do not use Sugar in middleware" is also valid for other libraries. <br><br><h2>  5. Assumptions about the lack of properties </h2><br><h4>  Problem: </h4><br>  As far as conflicts in the global namespace are dangerous, the assumptions about what is (or is not) in the global namespace are just as harmful. <br><br>  Imagine that you have a function that can take an argument of two types: a string and an object.  If the function is passed an object, it must extract a string from a specific property that the object has.  Therefore, you check whether the argument has such a property: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.first) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastName; } }</code> </pre><br>  This deceptively simple code makes an implicit assumption - that the <code>first</code> property will never be defined anywhere in the object's prototype chain (even if it is a string).  Of course, no one will give you guarantees for this, because <code>Object.prototype</code> and <code>String.prototype</code> are global objects, and everyone can change them. <br><br>  Even if you are opposed to changing native objects, you cannot afford to write code that, as in the example above, makes assumptions about the contents of the global namespace.  Such code is vulnerable and can lead to problems. <br><br><h4>  Sugar Position: </h4><br>  Fix the code from the last example is a snap.  You are already familiar with the solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'first'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastName; } }</code> </pre><br>  Now the function will check only the properties declared directly for the transferred object, and not for all the properties in its prototype chain.  One could go further and prohibit the transfer of various types of data, but even such a simple check is enough to avoid problems associated with changes in the global namespace. <br><br>  In his lifetime, Sugar provoked this problem in the code of large libraries two times: <a href="https://github.com/jquery/jquery/pull/1140">jquery # 1140</a> and <a href="https://github.com/LearnBoost/mongoose/issues/482">mongoose # 482</a> .  The culprits in both cases were the unsuccessfully named methods of Sugar.  We willingly renamed them, and this solved the problem.  In addition, one of the libraries (jQuery) worked the problem together with us to eliminate the flaw on its side. <br><br>  Sugar is trying to work very carefully in the global scope, but there is not enough without cooperation between the authors of the libraries.  The root of the problem is the nature of JavaScript itself, which makes no distinction between properties and methods. <br><br><h2>  6. Compliance with the specification </h2><br><h4>  Problem: </h4><br>  The ECMAScript specification is a standard that defines the behavior of native methods.  The developers of JavaScript runtimes strive to ensure that their implementation of native methods is both accurate and up to date.  Therefore, two things are important: that our methods always act in accordance with the specification and that possible specification changes in the future do not cause regressions. <br><br><h4>  Sugar Position: </h4><br>  From the very beginning, we developed Sugar, aiming not only to conform to the specification, but also to evolve with it. <br><br>  In the ES5 package, Sugar offers polyfills of the methods described in the current specification.  Of course, if there is a native implementation of the methods in the execution environment, the native ones are used.  Sugar has an extensive set of tests, thanks to which you can be sure that all polyfills exactly meet the specifications.  In addition, if you wish, you can opt out of the ES5 package and use any other ES5 polyfill. <br><br>  To conform to the specification means to adapt to the changes in it.  Sugar has the responsibility to always be at the forefront of standards.  The sooner you start to comply with the new draft draft specification, the more painless will be the transition to it in the future.  Starting with version 1.4, Sugar equals ECMAScript 6 standard (and looks at 7, which is found at the earliest stages of development).  As the specification changes, Sugar will continue to adapt, avoiding conflicts and striving to strike a balance between practicality and compliance with the native implementation. <br><br>  Of course, adaptation is good for those users who are willing to regularly update dependencies.  But how will the projects sitting on the old version of Sugar behave when the environment switches to the next version of the specification?  Imagine the situation: the browsers of visitors to your site are updated, and the site breaks down in them.  Sugar recently made a difficult decision to redefine methods that are not explicitly described in the specification.  Now, no <code>if (!Object.prototype.foo) Object.prototype.foo = function(){};</code>  , all methods missing in ECMAScript are redefined unconditionally. <br><br>  Although it may seem the opposite, but this solution is aimed at improving the support of sites.  Even if, as a result of updating the specification, native methods change and conflict with Sugar, Sugar will override them.  Consequently, the methods will continue to work as before - until your hands reach the site to update.  But as already mentioned, we strive to go far ahead of the specification, minimizing this need. <br><br><h2>  Tl / dr </h2><br>  Let's go through all the problems and related risks: <ol><li>  Problem: <b>Modifying Environment Objects</b> <br>  Risk: absent. </li><li>  Problem: <b>Functions as enumerable properties</b> <br>  Risk: minimal.  Bypassing normal objects there is no risk, as well as by traversing arrays in a safe way.  When traversing arrays in an unsafe way there will be problems in IE8 and below. </li><li>  Problem: <b>Overriding Properties</b> <br>  Risk: absent. </li><li>  Problem: <b>Conflicts in the global namespace</b> <br>  Risk: minimal, but grows inversely with your awareness of what is happening in the global namespace of your project.  Ideally, the project should not contain more than one library like Sugar, and its use should be documented.  Do not use Sugar if you are writing a library;  as a last resort, report the use of Sugar to your users as loudly as possible. </li><li>  Problem: <b>Assumptions about the lack of properties</b> <br>  Risk: minimal.  The problem arose twice in the history of Sugar, both cases were quickly resolved. </li><li>  Problem: <b>Compliance Specification</b> <br>  Risk: very little.  Sugar tries to be as careful with modifying native objects as possible.  But is that enough?  The answer to this question depends on the user's beliefs and the structure of the project, and also changes with time (for the better). </li></ol><br><br>  These conclusions we made ourselves based on the experience of using Sugar in the real world and user feedback.  If they cause you to doubt, each item we discussed in detail in the article - in the hope that this will help you draw your own conclusions about whether Sugar is suitable for your project. <br><br><h2>  From translator </h2><br><h4>  SugarJS Performance </h4><br>  Being more comfortable to use, Sugar noticeably loses Lo-Dash in performance.  However, the issue of performance, in my opinion, is important only in the processing of any large amounts of data.  If you are working with the front-end, then you will not find any difference in the speed of these libraries. <br><br>  For those for whom performance is critical, I recommend <a href="http://danieltao.com/lazy.js/">LazyJS</a> .  In cases where, after traversing the properties of an object / array, it is not necessary to return a new object with all properties, LazyJS wins Lo-Dash in performance.  In compound operations, the gap becomes significant.  For example, the operation <code>map -&gt; filter</code> LazyJS is five times faster than Lo-Dash, and fifteen times than SugarJS.  If you need not just walk through the property values, but to collect a new object / array, then LazyJS loses the advantage.  <a href="https://habrahabr.ru/users/streetstrider/" class="user_link">StreetStrider</a> <a href="http://habrahabr.ru/post/217515/">suggests</a> that lazy computation on chains is <a href="https://github.com/lodash/lodash/issues/274">planned</a> in LoDash version 3. <br><br>  <a href="http://danieltao.com/lazy.js/comparisons.html">Here</a> you can compare the performance of ten similar libraries on a variety of typical operations directly in your browser. <br><br><h4>  The convenience we lost </h4><br>  You may be wondering how elegantly the problem of extending native objects is solved in Ruby.  They proposed a refinement mechanism (refinements), which in the version of Ruby 2.1 came out of experimental status. <br><br>  Suppose the developer Vasya, who writes the Vasya library, does not hesitate to make decoys-patches: from his library he (re) defines the methods of standard objects using the <code>refine</code> design. <br><br><pre> <code class="ruby hljs">refine String <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">petrovich</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Petrovich</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">says</span></span></span><span class="hljs-function">: " </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Developer Peter sculpts one of the parts of a large project that many programmers work on.  When Petya connects the Vasya library, the Vasiny monkey patches do not apply to the entire project and do not interfere with the rest of the coders.  At library connection redefinition of native objects does not occur at all. <br><br>  In order to use new methods, Petya, in his code, indicates the monkey patches from which libraries he needs: <br><br><pre> <code class="ruby hljs">using Vasya using HollowbodySixString1957</code> </pre><br>  As a result, the redefinition of global objects made from these libraries is applied only for the class, module, or source code file in which Petya asked for it. <br><br><h4>  UPD1: Why is all this necessary? </h4><br>  From the comments it became clear that it was obvious to me alone.  Stand out my answer from the comments. <br><br>  This is probably more obvious to those who started serious programming with Ruby.  As they say, you quickly get used to good: a rich and very functional standard library, a natural way of calling methods for a dynamic language, and the ability to build methods into chains. <br><br>  When you see this code (abstract example): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor( MyArray.last( arr ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (debug) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">"result:"</span></span>, result ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result;</code> </pre><br>  ... instead of this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.last().floor().debug();</code> </pre><br>  ... it becomes somehow, you know, depressingly. </div><p>Source: <a href="https://habr.com/ru/post/217603/">https://habr.com/ru/post/217603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217585/index.html">Networks for the smallest. Part nine. Multicast</a></li>
<li><a href="../217587/index.html">LZ Series Portable Batteries by iconBIT</a></li>
<li><a href="../217593/index.html">Following the publication in Google Play / App Store / Steam Greenlight</a></li>
<li><a href="../217595/index.html">Java Annotations, Part I</a></li>
<li><a href="../217599/index.html">Dismantling IBOX, another ARM mini PC</a></li>
<li><a href="../217605/index.html">99 amazing facts about the business of the future</a></li>
<li><a href="../217607/index.html">80 meetings in 3 days: how we played big in Vegas</a></li>
<li><a href="../217609/index.html">German scientists measured the electron mass 13 times more accurately than before.</a></li>
<li><a href="../217611/index.html">Remote in Russian. New book from 37signals</a></li>
<li><a href="../217615/index.html">Lectorium launches MOOC direction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>