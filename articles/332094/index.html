<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a blog engine with Phoenix and Elixir / Part 9. Channels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: ‚Äú Elixir and Phoenix are a great example of where modern web development is heading. Already, these tools provide high-quality ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a blog engine with Phoenix and Elixir / Part 9. Channels</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/0d3/715/be6/0d3715be6c3f44c3b2db05a36374cec1.png"><br><br><p>  From the translator: ‚Äú <i>Elixir and Phoenix are a great example of where modern web development is heading.</i>  <i>Already, these tools provide high-quality access to real-time technologies for web applications.</i>  <i>Sites with increased interactivity, multiplayer browser games, microservices - those areas in which these technologies will serve a good service.</i>  <i>The following is a translation of a series of 11 articles that describe in detail the aspects of development on the Phoenix framework that would seem such a trivial thing as a blog engine.</i>  <i>But do not hurry to sulk, it will be really interesting, especially if the articles encourage you to pay attention to the Elixir or become its followers.</i> <br><br></p><p>  In this section, we‚Äôll use Phoenix feeds to animate comments. </p><a name="habracut"></a><br><p>  At the moment, our application is based on: </p><br><ul><li>  <b>Elixir</b> : v1.3.1 </li><li>  <b>Phoenix</b> : v1.2.0 </li><li>  <b>Ecto</b> : v2.0.2 </li></ul><br><h2>  Where did we leave off </h2><br><p>  The last time was completely over with the comments!  Now that all the features are ready, let's make the blog really cool, taking advantage of the opportunities that Elixir and Phoenix provide right out of the box.  Let's turn the comment system into a live comment system using feeds from Phoenix.  <strong>Frankly speaking: in this part there are a <i>LOT of</i> heavy <i>javascript</i> .</strong> </p><br><p>  Let's go the same way as before: we will design a new function before its implementation.  The following requirements apply to the live comment system: </p><br><ol><li>  New comments as they appear should be broadcast only to authorized users. </li><li>  When approved, comments should be broadcast to all users. </li><li>  Deleted comments should disappear for all users. </li></ol><br><h2>  Adding channels </h2><br><p> The first step in implementing any channel in Phoenix is ‚Äã‚Äãto work with the file <code>web/channels/user_socket.ex</code> .  Change the commented line under <code>## Channels</code> to the following: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">channel</span></span> <span class="hljs-string"><span class="hljs-string">"comments:*"</span></span>, Pxblog.CommentChannel</code> </pre> <br><p>  And then create the channel itself, which we will work with.  To do this, use the Phoenix generator: </p><br><pre> <code class="bash hljs">$ mix phoenix.gen.channel Comment * creating web/channels/comment_channel.ex * creating <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/channels/comment_channel_test.exs Add the channel to your `web/channels/user_socket.ex` handler, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> example: channel <span class="hljs-string"><span class="hljs-string">"comment:lobby"</span></span>, Pxblog.CommentChannel</code> </pre> <br><p>  Based on the requirements, <i>we will create a separate comment channel for each post_id</i> . </p><br><p>  Let's start with the simplest implementation and go backwards to add security, so first we will have an authorized channel visible to everyone.  We also need to identify the events that will be broadcast. </p><br><p>  <strong>For authorized users:</strong> </p><br><ol><li>  Comment created </li><li>  Comment has been deleted </li><li>  Comment approved </li></ol><br><p>  <strong>For all:</strong> </p><br><ol><li>  Comment approved </li><li>  Comment has been deleted </li></ol><br><p>  First we need to set up some basic things.  Add jQuery to the application to more easily interact with the DOM. </p><br><h2>  Adding jQuery with Brunch </h2><br><p>  Let's start by installing jQuery via NPM. </p><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-comment"><span class="hljs-comment">--save-dev jquery</span></span></code> </pre> <br><p>  And then we reboot the Phoenix server and verify that jQuery has been successfully installed.  Open the <strong>web / static / js / app.js file</strong> and add the following code down: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"jquery"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($(<span class="hljs-string"><span class="hljs-string">"body"</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"jquery works!"</span></span>) }</code> </pre> <br><p>  If you see the jquery works! Message in the Developer Console of your browser, you can delete these lines and proceed to the next step. </p><br><h2>  Javascript channel implementation </h2><br><p>  First let's go back to the <code>web/static/js/app.js</code> and uncomment the socket import statement. </p><br><p>  Then open the <code>web/static/js/socket.js</code> and make some small edits: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// For right now, just hardcode this to whatever post id you're working with const postId = 2; const channel = socket.channel(`comments:${postId}`, {}); channel.join() .receive("ok", resp =&gt; { console.log("Joined successfully", resp) }) .receive("error", resp =&gt; { console.log("Unable to join", resp) });</span></span></code> </pre> <br><p>  Referring to the description of the socket, to understand what messages you need to listen / broadcast.  We will use ‚ÄúCREATED_COMMENT‚Äù for newly created comments, ‚ÄúAPPROVED_COMMENT‚Äù for approved comments and ‚ÄúDELETED_COMMENT‚Äù for deleted ones.  Add them as constants to the file <code>socket.js</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CREATED_COMMENT = <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> APPROVED_COMMENT = <span class="hljs-string"><span class="hljs-string">"APPROVED_COMMENT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DELETED_COMMENT = <span class="hljs-string"><span class="hljs-string">"DELETED_COMMENT"</span></span></code> </pre> <br><p>  Then we proceed to adding channel event handlers for each of these actions. </p><br><pre> <code class="javascript hljs">channel.on(CREATED_COMMENT, (payload) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Created comment"</span></span>, payload) }); channel.on(APPROVED_COMMENT, (payload) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Approved comment"</span></span>, payload) }); channel.on(DELETED_COMMENT, (payload) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Deleted comment"</span></span>, payload) });</code> </pre> <br><p>  Finally, change the Submit button to create a ‚Äúfake‚Äù event instead of sending a comment: </p><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"input[type=submit]"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, (event) =&gt; { event.preventDefault() channel.push(CREATED_COMMENT, { <span class="hljs-attr"><span class="hljs-attr">author</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-string"><span class="hljs-string">"body"</span></span> }) })</code> </pre> <br><h2>  Refinement code to support channels </h2><br><p>  If you try to test in the browser, the application will fall.  You will get an error message like this: </p><br><pre> <code class="hljs pgsql">[error] GenServer #PID&lt;<span class="hljs-number"><span class="hljs-number">0.1250</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt; terminating ** (FunctionClauseError) <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> clause matching <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Pxblog.CommentChannel.handle_in/<span class="hljs-number"><span class="hljs-number">3</span></span> (pxblog) web/channels/comment_channel.ex:<span class="hljs-number"><span class="hljs-number">14</span></span>: Pxblog.CommentChannel.handle_in(‚ÄúCREATED_COMMENT‚Äù, %{‚Äúauthor‚Äù =&gt; ‚Äútest‚Äù, ‚Äúbody‚Äù =&gt; ‚Äúbody‚Äù}, %Phoenix.Socket{assigns: %{}, channel: Pxblog.CommentChannel, channel_pid: #PID&lt;<span class="hljs-number"><span class="hljs-number">0.1250</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;, endpoint: Pxblog.Endpoint, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: Pxblog.UserSocket, id: nil, joined: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, pubsub_server: Pxblog.PubSub, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù, serializer: Phoenix.Transports.WebSocketSerializer, topic: ‚Äúcomments:<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù, transport: Phoenix.Transports.WebSocket, transport_name: :websocket, transport_pid: #PID&lt;<span class="hljs-number"><span class="hljs-number">0.1247</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;}) (phoenix) lib/phoenix/channel/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.ex:<span class="hljs-number"><span class="hljs-number">229</span></span>: Phoenix.Channel.<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>.handle_info/<span class="hljs-number"><span class="hljs-number">2</span></span> (stdlib) gen_server.erl:<span class="hljs-number"><span class="hljs-number">615</span></span>: :gen_server.try_dispatch/<span class="hljs-number"><span class="hljs-number">4</span></span> (stdlib) gen_server.erl:<span class="hljs-number"><span class="hljs-number">681</span></span>: :gen_server.handle_msg/<span class="hljs-number"><span class="hljs-number">5</span></span> (stdlib) proc_lib.erl:<span class="hljs-number"><span class="hljs-number">240</span></span>: :proc_lib.init_p_do_apply/<span class="hljs-number"><span class="hljs-number">3</span></span> Last message: %Phoenix.Socket.Message{event: ‚ÄúCREATED_COMMENT‚Äù, payload: %{‚Äúauthor‚Äù =&gt; ‚Äútest‚Äù, ‚Äúbody‚Äù =&gt; ‚Äúbody‚Äù}, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù, topic: ‚Äúcomments:<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù} State: %Phoenix.Socket{assigns: %{}, channel: Pxblog.CommentChannel, channel_pid: #PID&lt;<span class="hljs-number"><span class="hljs-number">0.1250</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;, endpoint: Pxblog.Endpoint, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: Pxblog.UserSocket, id: nil, joined: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, pubsub_server: Pxblog.PubSub, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: nil, serializer: Phoenix.Transports.WebSocketSerializer, topic: ‚Äúcomments:<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù, transport: Phoenix.Transports.WebSocket, transport_name: :websocket, transport_pid: #PID&lt;<span class="hljs-number"><span class="hljs-number">0.1247</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;}</code> </pre> <br><p>  Right now we have no function to process messages inside the channel.  Open the <code>web/channels/comment_channel.ex</code> file and let's make the <code>handle_in</code> function broadcast messages to subscribers instead of watching in silence.  We also need to change the standard join function at the top: </p><br><pre> <code class="hljs vbscript">def <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(<span class="hljs-string"><span class="hljs-string">"comments:"</span></span> &lt;&gt; _comment_id, payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> authorized?(payload) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, socket} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, %{reason: <span class="hljs-string"><span class="hljs-string">"unauthorized"</span></span>}} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... # It <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> also common <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> receive messages from the client <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> # broadcast <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> everyone <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the current topic (comments:lobby). def handle_in(<span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast socket, <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, payload {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Now we can add similar code for two other messages that we are supposed to ‚Äúlisten to‚Äù. </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"APPROVED_COMMENT"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, payload, socket)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast socket, <span class="hljs-string"><span class="hljs-string">"APPROVED_COMMENT"</span></span>, payload {<span class="hljs-symbol"><span class="hljs-symbol">:noreply</span></span>, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"DELETED_COMMENT"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, payload, socket)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast socket, <span class="hljs-string"><span class="hljs-string">"DELETED_COMMENT"</span></span>, payload {<span class="hljs-symbol"><span class="hljs-symbol">:noreply</span></span>, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We also need to make some changes to the templates.  You need to know what post we work with and who the current user is.  Thus, we add the following code to the top of the <code>web/templates/post/show.html.eex</code> file: </p><br><pre> <code class="hljs pgsql">&lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="hidden" id="post-id" <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>="&lt;%= @post.id %&gt;"&gt;</code> </pre> <br><p>  Then open the <code>web/templates/comment/comment.html.eex</code> and change the opening <code>div</code> : </p><br><pre> <code class="hljs objectivec">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=<span class="hljs-string"><span class="hljs-string">"comment-&lt;%= @comment.id %&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"comment"</span></span> data-comment-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=<span class="hljs-string"><span class="hljs-string">"&lt;%= @comment.id %&gt;"</span></span>&gt;</code> </pre> <br><p>  Now that everything related to comments is processed through Javascript, we need to remove some previously written code for the Approve / Reject buttons.  Change the whole block to make it look like this: </p><br><pre> <code class="hljs pgsql">&lt;%= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @conn.assigns[:author_or_admin] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %&gt; &lt;%= unless @<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>="btn btn-xs btn-primary approve"&gt;Approve&lt;/button&gt; &lt;% <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> %&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>="btn btn-xs btn-danger delete"&gt;<span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span>&lt;/button&gt; &lt;% <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> %&gt;</code> </pre> <br><p>  Also, inside the <code>div</code> tags, where the author and the text of the comment are displayed, change the <code>strong</code> tag so that they have the classes <code>.comment-author</code> and <code>.comment-body</code> , respectively. </p><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"col-xs-4"</span></span>&gt; &lt;strong <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"comment-author"</span></span>&gt;&lt;%= <span class="hljs-meta"><span class="hljs-meta">@comment</span></span>.author %&gt;&lt;/strong&gt; &lt;/div&gt;</code> </pre> <br><p>  ... </p><br><pre> <code class="hljs javascript">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"col-xs-12 comment-body"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> @</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">comment.body</span></span></span></span><span class="xml"><span class="hljs-tag"> %&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Finally, we need to make sure that we can appropriately refer to the author and the text of the comment, so we open the <code>web/templates/comment/form.html.eex</code> and make sure that the comment input field and the submit button look like this: </p><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"form-group"</span></span>&gt; &lt;%= label f, :body, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>: <span class="hljs-string"><span class="hljs-string">"control-label"</span></span> %&gt; &lt;%= textarea f, :body, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>: <span class="hljs-string"><span class="hljs-string">"form-control"</span></span> %&gt; &lt;%= error_tag f, :body %&gt; &lt;/div&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"form-group"</span></span>&gt; &lt;%= submit <span class="hljs-string"><span class="hljs-string">"Submit"</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>: <span class="hljs-string"><span class="hljs-string">"btn btn-primary create-comment"</span></span> %&gt; &lt;/div&gt;</code> </pre> <br><p>  Now it is necessary to implement each of the broadcasting capabilities properly, so let's return to the ‚Äújavascript field‚Äù and continue! </p><br><h2>  Implementing a user id through Phoenix.Token </h2><br><p>  We will need a way to check whether the user is who he claims to be and whether he has access to change the comment data.  To do this, we will use the Phoenix.Token module built into Phoenix. </p><br><p>  We start by putting a custom token in the application template.  This is quite convenient, because we probably want to display it everywhere.  In the <code>web/templates/layout/app.html.eex</code> add the following to the remaining meta tags: </p><br><pre> <code class="hljs mel">&lt;%= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user = current_user(@conn) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %&gt; &lt;%= tag :meta, name: <span class="hljs-string"><span class="hljs-string">"channel_token"</span></span>, content: Phoenix.Token.<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>(@conn, <span class="hljs-string"><span class="hljs-string">"user"</span></span>, user.id) %&gt; &lt;% end %&gt;</code> </pre> <br><p>  Here we say we want a signed token that points to the user ID (of course, if the user is logged in).  This will give us a great way to validate the user_id of a user through Javascript without having to trust hidden input fields or use other strange methods. </p><br><p>  Next in the <code>web/static/js/socket.js</code> , make a few changes to the socket connection code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Grab the user's token from the meta tag const userToken = $("meta[name='channel_token']").attr("content") // And make sure we're connecting with the user's token to persist the user id to the session const socket = new Socket("/socket", {params: {token: userToken}}) // And then connect to our socket socket.connect()</span></span></code> </pre> <br><p>  Now we will transfer the valid token back to the Phoenix code.  This time we need the file <code>web/channels/user_socket.ex</code> , in which we change the <code>connect</code> function to check the user's token: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{"token" =&gt; token}</span></span></span></span><span class="hljs-function"><span class="hljs-params">, socket)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Phoenix.Token.verify(socket, <span class="hljs-string"><span class="hljs-string">"user"</span></span>, token, <span class="hljs-symbol"><span class="hljs-symbol">max_age:</span></span> <span class="hljs-number"><span class="hljs-number">1209600</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, user_id} -&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, assign(socket, <span class="hljs-symbol"><span class="hljs-symbol">:user</span></span>, user_id)} {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span>, reason} -&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  So, we call the verify function from the Phoenix.Token module and pass the socket to it, the value to check, the token itself and the max_age value (the maximum token lifetime, for example, two weeks). </p><br><p>  If the verification is successful, then send back the {: ok, [, value extracted from the token]}} tuple, which in our case is user_id.  Then we support the connection with the user_id value stored in the socket (similar to saving the value in a session or conn). </p><br><p>  If the connection could not be verified, this is also normal.  Since we still want unauthorized users to receive updates without verified user_id, we will not assign anything, but simply return <code>{:ok, socket}</code> . </p><br><h2>  Go back to Socket.js </h2><br><p>  We will need a ton of Javascript code to support all our plans.  Consider the problem in more detail: </p><br><ol><li>  Take the postId value straight from the DOM </li><li>  Write a function to generate a new comment template </li><li>  Write a function to get the author comment </li><li>  Write a function for comment text. </li><li>  Write a function to get the comment ID </li><li>  Write a comment reset function </li><li>  Write a function to handle the creation of a comment </li><li>  Write a function to process comment approval </li><li>  Write a function to handle comment deletion </li><li>  Write function to handle comment creation event </li><li>  Write function to handle comment approval event </li><li>  Write function to handle comment deletion event </li></ol><br><p>  And I warned you that there will be a lot of javascript here :) Let's not waste time and immediately begin to write each of these functions.  Comments in this piece of code describe each of the requirements, respectively. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Import the socket library import {Socket} from "phoenix" // And import jquery for DOM manipulation import $ from "jquery" // Grab the user's token from the meta tag const userToken = $("meta[name='channel_token']").attr("content") // And make sure we're connecting with the user's token to persist the user id to the session const socket = new Socket("/socket", {params: {token: userToken}}) // And connect out socket.connect() // Our actions to listen for const CREATED_COMMENT = "CREATED_COMMENT" const APPROVED_COMMENT = "APPROVED_COMMENT" const DELETED_COMMENT = "DELETED_COMMENT" // REQ 1: Grab the current post's id from a hidden input on the page const postId = $("#post-id").val() const channel = socket.channel(`comments:${postId}`, {}) channel.join() .receive("ok", resp =&gt; { console.log("Joined successfully", resp) }) .receive("error", resp =&gt; { console.log("Unable to join", resp) }) // REQ 2: Based on a payload, return to us an HTML template for a comment // Consider this a poor version of JSX const createComment = (payload) =&gt; ` &lt;div id="comment-${payload.commentId}" class="comment" data-comment-id="${payload.commentId}"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-4"&gt; &lt;strong class="comment-author"&gt;${payload.author}&lt;/strong&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;em&gt;${payload.insertedAt}&lt;/em&gt; &lt;/div&gt; &lt;div class="col-xs-4 text-right"&gt; ${ userToken ? '&lt;button class="btn btn-xs btn-primary approve"&gt;Approve&lt;/button&gt; &lt;button class="btn btn-xs btn-danger delete"&gt;Delete&lt;/button&gt;' : '' } &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-12 comment-body"&gt; ${payload.body} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ` // REQ 3: Provide the comment's author from the form const getCommentAuthor = () =&gt; $("#comment_author").val() // REQ 4: Provide the comment's body from the form const getCommentBody = () =&gt; $("#comment_body").val() // REQ 5: Based on something being clicked, find the parent comment id const getTargetCommentId = (target) =&gt; $(target).parents(".comment").data("comment-id") // REQ 6: Reset the input fields to blank const resetFields = () =&gt; { $("#comment_author").val("") $("#comment_body").val("") } // REQ 7: Push the CREATED_COMMENT event to the socket with the appropriate author/body $(".create-comment").on("click", (event) =&gt; { event.preventDefault() channel.push(CREATED_COMMENT, { author: getCommentAuthor(), body: getCommentBody(), postId }) resetFields() }) // REQ 8: Push the APPROVED_COMMENT event to the socket with the appropriate author/body/comment id $(".comments").on("click", ".approve", (event) =&gt; { event.preventDefault() const commentId = getTargetCommentId(event.currentTarget) // Pull the approved comment author const author = $(`#comment-${commentId} .comment-author`).text().trim() // Pull the approved comment body const body = $(`#comment-${commentId} .comment-body`).text().trim() channel.push(APPROVED_COMMENT, { author, body, commentId, postId }) }) // REQ 9: Push the DELETED_COMMENT event to the socket but only pass the comment id (that's all we need) $(".comments").on("click", ".delete", (event) =&gt; { event.preventDefault() const commentId = getTargetCommentId(event.currentTarget) channel.push(DELETED_COMMENT, { commentId, postId }) }) // REQ 10: Handle receiving the CREATED_COMMENT event channel.on(CREATED_COMMENT, (payload) =&gt; { // Don't append the comment if it hasn't been approved if (!userToken &amp;&amp; !payload.approved) { return; } // Add it to the DOM using our handy template function $(".comments h2").after( createComment(payload) ) }) // REQ 11: Handle receiving the APPROVED_COMMENT event channel.on(APPROVED_COMMENT, (payload) =&gt; { // If we don't already have the right comment, then add it to the DOM if ($(`#comment-${payload.commentId}`).length === 0) { $(".comments h2").after( createComment(payload) ) } // And then remove the "Approve" button since we know it has been approved $(`#comment-${payload.commentId} .approve`).remove() }) // REQ 12: Handle receiving the DELETED_COMMENT event channel.on(DELETED_COMMENT, (payload) =&gt; { // Just delete the comment from the DOM $(`#comment-${payload.commentId}`).remove() }) export default socket</span></span></code> </pre> <br><p>  Perhaps enough with javascript.  We now have working functionality, but without any protection.  Let's add it in our Elixir code by creating a helper function to add, approve and delete comments. </p><br><h2>  Auxiliary functions for channels </h2><br><p>  With our Javascript code, everything is fine, so you probably need to add helper functions on the backend side.  Let's start with creating a new module that will become the workhorse of our interactions with the database to create / approve / delete comments.  So create a <strong>web / channels / comment_helper.ex</strong> file: </p><br><pre> <code class="hljs pgsql">defmodule Pxblog.CommentHelper <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Post <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>: [build_assoc: <span class="hljs-number"><span class="hljs-number">2</span></span>] def <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(%{"postId" =&gt; post_id, "body" =&gt; body, "author" =&gt; author}, _socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post = get_post(post_id) changeset = post |&gt; build_assoc(:comments) |&gt; <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>.changeset(%{body: body, author: author}) Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def approve(%{"postId" =&gt; post_id, "commentId" =&gt; comment_id}, %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: user_id}}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> authorize_and_perform(post_id, user_id, fn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, comment_id) changeset = <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>.changeset(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, %{approved: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}) Repo.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post_id, "commentId" =&gt; comment_id}, %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: user_id}}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> authorize_and_perform(post_id, user_id, fn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, comment_id) Repo.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp authorize_and_perform(post_id, user_id, action) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post = get_post(post_id) <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = get_user(user_id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_authorized_user?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> action.() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {:error, "User is not authorized"} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp get_user(user_id) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, user_id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp get_post(post_id) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(Post, post_id) |&gt; Repo.preload([:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, :comments]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp is_authorized_user?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id == post.user_id || Pxblog.RoleChecker.is_admin?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Let's start at the top.  We will often refer to the Comment / Post / User / Repo modules, so for the purity of the code, it is correct to add aliases for them.  We also need to import the <code>build_assoc</code> function from <code>Ecto</code> , but only the arity version 2. </p><br><p>  Then we proceed immediately to the creation of the post.  We habitually pass to the socket function, but we don‚Äôt always need it.  For example, in this case, after all, anyone can add a comment.  We associate the post_id, body, and author values ‚Äã‚Äãin the arguments with the sample so that we can work with them inside the function. </p><br><pre> <code class="hljs sql">def <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(%{<span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post_id, <span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span> =&gt; author}, _socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post = get_post(post_id) changeset = post |&gt; build_assoc(:comments) |&gt; Comment.changeset(%{<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>, author: author}) Repo.insert(changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We get the post through the function <code>get_post</code> , which has not yet been written.  This will be a private function just below.  Then create a changeset from the post to create a linked comment.  At the end we will return the result of the function Repo.insert.  This is an absolutely simple and standard code for Ecto, so there should be no surprises.  The same can be said about all other functions.  Next, take a look at the <code>approve</code> function: </p><br><pre> <code class="hljs pgsql">def approve(%{"postId" =&gt; post_id, "commentId" =&gt; comment_id}, %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: user_id}}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> authorize_and_perform(post_id, user_id, fn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, comment_id) changeset = <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>.changeset(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, %{approved: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}) Repo.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here again the necessary values ‚Äã‚Äãare matched with the sample ‚Äî post_id and comment_id from the first argument and verified user_id from the socket passed to the second.  Next, we call the helper function <code>authorize_and_perform</code> and pass into it an anonymous function that receives the comment, updates the approved flag to true through the changeset, and then sends the update to Repo.  Pretty standard code, but the <code>authorize_and_perform</code> function looks mysterious, so let's digress into parsing it: </p><br><pre> <code class="hljs sql">defp authorize_and_perform(post_id, user_id, action) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post = get_post(post_id) <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = get_user(user_id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_authorized_user?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> action.() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, <span class="hljs-string"><span class="hljs-string">"User is not authorized"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Post_id and user_id are passed to it, since both of these values ‚Äã‚Äãare required for proper authorization of actions with a comment.  Then another auxiliary function <code>is_authorized_user?</code>  which, receiving user and post, returns true or false.  If all is well, then the anonymous action function is called.  Note the point between the name and the brackets.  Otherwise, a {: error, ‚ÄúUser is not authorized‚Äù} tuple is returned, which we can intercept further if we want to display a nice error message. </p><br><p>  Authorization is performed inside the function, and then the actions passed via the <code>fn -&gt; ... end</code> block are executed.  This is a good example when a lot of logic is duplicated. </p><br><p>  With the function <code>authorize_and_perform</code> enough.  Let's move on to the <code>delete</code> function: </p><br><pre> <code class="hljs pgsql">def <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post_id, "commentId" =&gt; comment_id}, %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: user_id}}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> authorize_and_perform(post_id, user_id, fn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, comment_id) Repo.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here is the same approach.  We obtain the necessary values ‚Äã‚Äãthrough pattern matching, authorize the action, then get a comment and delete it.  It's simple! </p><br><p>  Finally, take a look at the smaller helper functions. </p><br><pre> <code class="hljs pgsql">defp get_user(user_id) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, user_id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp get_post(post_id) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>!(Post, post_id) |&gt; Repo.preload([:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, :comments]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp is_authorized_user?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id == post.user_id || Pxblog.RoleChecker.is_admin?(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Getting a user, getting a post and checking user authorization (code taken from <code>PostController</code> ).  Auxiliary functions are over.  Add them to <code>CommentChannel</code> . </p><br><h2>  Embedding helper functions in the comment channel </h2><br><p>  All we need is to replace the original code with the messages CREATED / APPROVED / DELETED with auxiliary functions.  Open the <code>web/channels/comment_channel.ex</code> file: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.CommentHelper # It <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> common <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> receive messages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the client <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> # broadcast <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> everyone <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> topic (comments:lobby). def handle_in("CREATED_COMMENT", payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} -&gt; broadcast socket, "CREATED_COMMENT", Map.merge(payload, %{insertedAt: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.inserted_at, commentId: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, approved: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved}) {:noreply, socket} {:error, _} -&gt; {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def handle_in("APPROVED_COMMENT", payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CommentHelper.approve(payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} -&gt; broadcast socket, "APPROVED_COMMENT", Map.merge(payload, %{insertedAt: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.inserted_at, commentId: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}) {:noreply, socket} {:error, _} -&gt; {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def handle_in("DELETED_COMMENT", payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, _} -&gt; broadcast socket, "DELETED_COMMENT", payload {:noreply, socket} {:error, _} -&gt; {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The principles are similar in all three calls, so let's look only at <code>create</code> : </p><br><pre> <code class="hljs pgsql"># It <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> common <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> receive messages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the client <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> # broadcast <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> everyone <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> topic (comments:lobby). def handle_in("CREATED_COMMENT", payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(payload, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} -&gt; broadcast socket, "CREATED_COMMENT", Map.merge(payload, %{insertedAt: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.inserted_at, commentId: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, approved: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved}) {:noreply, socket} {:error, _} -&gt; {:noreply, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The signature of the function has not changed, so leave it alone.  The first thing we do is add a case statement for the <code>CommentHelper.create</code> function and pass payload and socket into it (think about the pattern matching we did).  If it arrives <code>:ok</code> along with the created comment, we translate the <code>CREATED_COMMENT</code> message into the socket along with some data from the database, which Javascript does not have.  If an error has occurred, then you do not need to broadcast anything, just return the socket and carefreely move on. </p><br><p><img src="https://habrastorage.org/web/3d4/b34/155/3d4b34155ca84ebba86ace693deaf3fb.png"></p><br><h2>  Conclusion </h2><br><p>  Now the blog has an awesome real-time commenting system.  We also dived deep into the study of channels and tokens in Phoenix, and learned how to combine them to improve security.  In this regard, the example is, of course, not perfect - we still broadcast all the comments, but not all are added to the <code>div</code> .  So someone can see all the comments added, even disapproved ones.  This can be further improved by creating separate authenticated and unauthenticated channels and only broadcast messages to the necessary ones.  Considering that filtering comments only helps to avoid spam, increasing security in this case is not so important.  But this technique may be useful in the future.  We also forgot about the tests.  It is better to try not to do this, but this part turns out to be painfully long, so let's end up with tests in the next one.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This will keep the code coverage level high and remove some unnecessary code. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design is still bad, so you need to do it. </font><font style="vertical-align: inherit;">To do this, add Zurb Foundation 6 and create a clean look for our blogging platform!</font></font></p><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other series articles </font></font></h2><br><ol><li>  <a href="https://habrahabr.ru/post/311088/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/313482/">Authorization</a> </li><li>  <a href="https://habrahabr.ru/post/315252/">Adding Roles</a> </li><li>  <a href="https://habrahabr.ru/post/316368/">Process roles in controllers</a> </li><li>  <a href="https://habrahabr.ru/post/316996/">We connect ExMachina</a> </li><li>  <a href="https://habrahabr.ru/post/317550/">Markdown support</a> </li><li>  <a href="https://habrahabr.ru/post/318790/">Add comments</a> </li><li>  <a href="https://habrahabr.ru/post/323462/">We finish with comments</a> </li><li>  Channels </li><li> <a href="https://habrahabr.ru/post/333020/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Channel testing</font></font></a> </li><li>  <a href="https://habrahabr.ru/post/335048/">Conclusion</a> </li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modest conclusion from a translator </font></font></h2><br><p>  Guys!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another three dozen </font></font><a href="https://wunsh.ru/%3Futm_source%3Dhabr%26utm_medium%3Dcontent"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles on Elixir in Russian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are waiting for you on the site of our project called Wunsh. </font><font style="vertical-align: inherit;">You can also subscribe to the cool newsletter and receive the most interesting news on Elixir along with exclusive articles. </font><font style="vertical-align: inherit;">I invite you to also join the work on the </font></font><a href="https://github.com/wunsh/elixir-docs-ru"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translation of documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And if you have any questions, then </font></font><a href="https://t.me/wunsh"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connect to our chat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://t.me/wunsh_live"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">channel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Telegram.</font></font></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332094/">https://habr.com/ru/post/332094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332084/index.html">Work with heterogeneous containers with C ++ 17</a></li>
<li><a href="../332086/index.html">Automatic application deployment with Maven and Wildfly</a></li>
<li><a href="../332088/index.html">Tasks with interviews. Three adequate tasks to "think"</a></li>
<li><a href="../332090/index.html">ReactJS - my understanding of testing</a></li>
<li><a href="../332092/index.html">Nelder-Mead optimization method. Python implementation example</a></li>
<li><a href="../332098/index.html">How to protect corporate storage from encryption viruses with snapshots</a></li>
<li><a href="../332100/index.html">Tips for using FactoryGirl without ORM</a></li>
<li><a href="../332106/index.html">Quantum computer: a big boost game. Lecture in Yandex</a></li>
<li><a href="../332108/index.html">Kubernetes & production - to be or not to be?</a></li>
<li><a href="../332110/index.html">The digest of interesting materials for the mobile developer # 210 (June 26 - July 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>