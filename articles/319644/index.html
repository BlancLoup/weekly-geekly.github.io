<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating Hexagon Grid</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hexagonal meshes (hexagonal meshes) are used in some games, but they are not as simple and common as rectangle meshes. I have been collecting resource...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating Hexagon Grid</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/c47/d41/0ef/c47d410ef6544a31a6e8424ce28313dc.png" alt="image"></div><br>  Hexagonal meshes (hexagonal meshes) are used in some games, but they are not as simple and common as rectangle meshes.  I have been <a href="http://www-cs-students.stanford.edu/~amitp/gameprog.html">collecting resources on hexagonal grids</a> for almost 20 years, and I wrote this guide to the most elegant approaches implemented in the simplest code.  The article often uses the manuals of Charles Fu ( <a href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles Fu</a> ) and Clark Verbrugge.  I will describe the different ways to create meshes of hexagons, their interconnection, as well as the most common algorithms.  Many parts of this article are interactive: choosing a grid type changes the corresponding schemes, code, and texts.  <i>(Note. Lane: this applies only to the original, I advise you to study it. In translation, all the information of the original is stored, but without interactivity.)</i> . <br><a name="habracut"></a><br>  Code examples in the article are written in pseudocode, so they are easier to read and understand in order to write your own implementation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Geometry </h2><br>  Hexagons are hexagonal polygons.  In regular hexagons, all sides (faces) have the same length.  We will work only with regular hexagons.  Typically, horizontal (sharp-topped) and vertical (flat-topped) orientations are used in hexagonal meshes. <br><br><img src="https://habrastorage.org/files/ec7/be4/35f/ec7be435fafc40e7ad2837d803c5b624.png"><img src="https://habrastorage.org/files/f85/fc5/270/f85fc5270e174b8aa2888d64697b4dc9.png"><br>  <i>Hexagons with flat (left) and sharp (right) riding</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Hexagons have 6 faces.  Each face is common to two hexagons.  Hexagons have 6 corner points each.  Each corner point is common to three hexagons.  More information about centers, edges and corner points can be found in <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">my article about the parts of grids</a> (squares, hexagons and triangles). <br><br><h3>  Corners </h3><br>  In a regular hexagon, the internal angles are 120 ¬∞.  There are six ‚Äúwedges‚Äù, each of which is an equilateral triangle with internal angles of 60 ¬∞.  The corner point <i>i</i> is at a distance <code>(60¬∞ * i) + 30¬∞</code> , one <code>size</code> from the <code>center</code> .  In the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_corner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(center, size, i)</span></span></span><span class="hljs-function">: var angle_deg </span></span>= <span class="hljs-number"><span class="hljs-number">60</span></span> * i + <span class="hljs-number"><span class="hljs-number">30</span></span> var angle_rad = PI / <span class="hljs-number"><span class="hljs-number">180</span></span> * angle_deg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point(center.x + size * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle_rad), center.y + size * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle_rad))</code> </pre> <br>  To fill the hexagon, you need to get the vertices of the polygon with <code>hex_corner(‚Ä¶, 0)</code> to <code>hex_corner(‚Ä¶, 5)</code> .  To draw the outline of the hexagon, you need to use these vertices, and then draw the line again in <code>hex_corner(‚Ä¶, 0)</code> . <br><br>  The difference between the two orientations is that x and y change places, which leads to a change in angles: the angles of the hexagons with a flat top are 0 ¬∞, 60 ¬∞, 120 ¬∞, 180 ¬∞, 240 ¬∞, 300 ¬∞, and with a sharp top - 30 ¬∞, 90 ¬∞, 150 ¬∞, 210 ¬∞, 270 ¬∞, 330 ¬∞. <br><br><img src="https://habrastorage.org/files/f37/9f1/434/f379f1434923494581ed45fe60782a80.png"><img src="https://habrastorage.org/files/e95/55e/541/e9555e54148a4a35a5dff20600839b49.png"><br>  <i>Angles of hexagons with flat and sharp top</i> <br><br><h3>  Size and location </h3><br>  Now we want to arrange several hexagons together.  In horizontal orientation, the height of the hexagon <code>height = size * 2</code> .  Vertical distance between adjacent hexagons <code>vert = height * 3/4</code> . <br><br>  Width of the hexagon <code>width = sqrt(3)/2 * height</code> .  Horizontal distance between adjacent hexagons <code>horiz = width</code> . <br><br>  In some games, pixel art is used for hexagons, which does not exactly correspond to regular hexagons.  The formulas of angles and arrangements described in this section will not coincide with the size of such hexagons.  The rest of the article, describing the algorithms of the grids of hexagons, is applicable even if the hexagons are slightly stretched or compressed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/51a/ec7/3d3/51aec73d3db545e0a78e8c5642fe70b4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1c5/4e2/162/1c54e21623af4bf081f99e94972b1296.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Coordinate systems </h2><br>  Let's start assembling hexagons into a grid.  In the case of square grids, there is only one obvious way to assemble.  For hexagons, there are many approaches.  I recommend using cubic coordinates as the primary representation.  Axial or offset coordinates should be used to store maps and display coordinates for the user. <br><br><h3>  Offset Coordinates </h3><br>  The most common approach is to offset each successive column or row.  Columns are denoted by <code>col</code> or <code>q</code> .  Rows are designated <code>row</code> or <code>r</code> .  You can offset odd or even columns / rows, so horizontal and vertical hexagons have two options. <br><br><img src="https://habrastorage.org/files/ae3/1c0/892/ae31c0892c6b4df5adcd618bdbea5576.png"><br>  <i>Horizontal arrangement "odd-r"</i> <br><br><img src="https://habrastorage.org/files/236/fa9/207/236fa92079ce46739ef557e870673948.png"><br>  <i>Horizontal arrangement "even-r"</i> <br><br><img src="https://habrastorage.org/files/494/8c5/137/4948c51375f241429eb151cd79939f48.png"><br>  <i>Vertical arrangement "odd-q"</i> <br><br><img src="https://habrastorage.org/files/234/2e1/105/2342e1105d2a424bbaf58d28654e4031.png"><br>  <i>Vertical arrangement "even-q"</i> <br><br><h3>  Cubic coordinates </h3><br>  Another way to consider the grids of hexagons is to see <i>three</i> main axes in them, rather than <i>two</i> , as in the grids of squares.  They show elegant symmetry. <br><br>  Take a grid of cubes and <b>cut a</b> diagonal plane at <code>x + y + z = 0</code> .  This is a strange thought, but it will help us to simplify the algorithms of the grids of hexagons.  In particular, we will be able to use standard operations from Cartesian coordinates: summation and subtraction of coordinates, multiplication and division by a scalar quantity, as well as distances. <br><br>  Notice the three major axes on the grid of cubes and their relationship to the six <i>diagonal</i> directions of the grid of hexagons.  The diagonal axes of the grid correspond to the main direction of the grid of hexagons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a74/ce1/28d/a74ce128da0943b9bf80679b90c00d80.png"></div><br>  <i>Hexagons</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c50/5bb/1ea/c505bb1ea7e44972825a122920f10bd4.png"></div><br>  <i>Cubes</i> <br><br>  Since we already have algorithms for grids of squares and cubes, the use of cubic coordinates allows us to adapt these algorithms to the grid of hexagons.  I will use this system for most article algorithms.  To use algorithms with a different coordinate system, I will transform the cubic coordinates, execute the algorithm, and then transform them back. <br><br>  Learn how cubic coordinates work for a grid of hexagons.  When selecting hexagons, the cubic coordinates corresponding to the three axes are highlighted. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c39/1c5/a20/c391c5a2048e4842b493369ceceae1aa.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/062/652/6af/0626526aff7a4bf389944a55a226e0ef.png"></div><br><ol><li>  Each direction of the grid of cubes corresponds to a <i>line</i> on the grid of hexagons.  Try selecting a hexagon with <code>z</code> equal to 0, 1, 2, 3 to see the connection.  The line is marked in blue.  Try the same for <code>x</code> (green) and <code>y</code> (lilac). <br><br></li><li>  Each direction of the hexagon grid is a combination of two directions of the grid of cubes.  For example, the "north" of the grid of hexagons lies between <code>+y</code> and <code>-z</code> , so each step to the "north" increases <code>y</code> by 1 and decreases <code>z</code> by 1. </li></ol><br>  Cubic coordinates are a reasonable choice for a coordinate system of a grid of hexagons.  The condition is <code>x + y + z = 0</code> , so it must be preserved in the algorithms.  The condition also ensures that for each hexagon there will always be a canonical coordinate. <br><br>  There are many different coordinate systems for cubes and hexagons.  In some of them, the condition is different from <code>x + y + z = 0</code> .  I showed only one of many systems.  You can also create cubic coordinates with <code>xy</code> , <code>yz</code> , <code>zx</code> , which will have their own set of interesting properties, but I will not consider them here. <br><br>  But you can argue that you do not want to store 3 numbers for the coordinates, because you do not know how to store the map in this form. <br><br><h3>  Axial coordinates </h3><br>  An axial coordinate system, sometimes referred to as ‚Äútrapezoidal,‚Äù is constructed on the basis of two or three coordinates from a cubic coordinate system.  Since we have the condition <code>x + y + z = 0</code> , the third coordinate is not needed.  Axial coordinates are useful for storing maps and displaying coordinates to the user.  As in the case of cubic coordinates, standard summation, subtraction, multiplication, and division of Cartesian coordinates can be used with them. <br><br>  There are many cubic coordinate systems and many axial.  In this guide, I will not consider all combinations.  I will select two variables, <code>q</code> (column) and <code>r</code> (string).  In the schemes of this article, <code>q</code> corresponds to <code>x</code> , and <code>r</code> corresponds to <code>z</code> , but such a correspondence is arbitrary, because it is possible to rotate and rotate the schemes, obtaining various correspondences. <br><br>  The advantage of this system over offsets offsets is the greater clarity of the algorithms.  The disadvantage of the system is that storing a rectangular card is a bit strange;  See the section on saving maps.  Some algorithms are even clearer in cubic coordinates, but since we have the condition <code>x + y + z = 0</code> , we can calculate the third implied coordinate and use it in these algorithms.  In my projects, I call the <code>q</code> , <code>r</code> , <code>s</code> axes, so the condition looks like <code>q + r + s = 0</code> , and I can calculate <code>s = -q - r</code> when needed. <br><br><h4>  Axles </h4><br>  The offset coordinates are the first things that most people think about, because they coincide with the standard Cartesian coordinates used for square grids.  Unfortunately, one of the two axles must pass ‚Äúagainst the fur,‚Äù and this makes it all the more difficult.  The cubic and axial systems go "on the fur" and they have simpler algorithms, but storing maps is a bit more complicated.  There is another system called ‚Äúinterlaced‚Äù or ‚Äúdouble‚Äù, but here we will not consider it;  some believe that it is easier to work with it than with a cubic or axial one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/71f/0ac/d4b/71f0acd4bda84219a6f2987cf2de5867.png"></div><br>  <i>Offset coordinates, cubic and axial</i> <br><br>  <i>The axis</i> is the direction in which the corresponding coordinate increases.  The perpendicular to the axis is the line on which the coordinate remains constant.  The grid diagrams above show perpendicular lines. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Coordinate Transformation </h2><br>  It is likely that you will use axial coordinates or displacement coordinates in your project, but many algorithms are easier expressed in cubic coordinates.  Therefore, we need to be able to convert coordinates between systems. <br><br>  The axial coordinates are closely related to cubic ones, so the conversion is simple: <br><br><pre> <code class="cpp hljs">#      q = x r = z #      x = q z = r y = -xz</code> </pre> <br>  In code, these two functions can be written as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_to_hex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h)</span></span></span><span class="hljs-function">: #  var q </span></span>= hx var r = hz <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(q, r) function hex_to_cube(h): #  var x = hq var z = hr var y = -xz <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cube(x, y, z)</code> </pre> <br>  The offset coordinates are quite a bit more complicated: <br><br><pre> <code class="cpp hljs">#     -q col = x row = z + (x + (x&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> #   -q   x = col z = row - (col + (col&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> y = -xz #     -q col = x row = z + (x - (x&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> #   -q   x = col z = row - (col - (col&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> y = -xz #     -r col = x + (z + (z&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> row = z #  -r   x = col - (row + (row&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> z = row y = -xz #    -r col = x + (z - (z&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> row = z #  -r   x = col - (row - (row&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span> z = row y = -xz</code> </pre> <br>  Implementation note: I use a &amp; 1 ( <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">bitwise "AND"</a> ) instead of a% 2 ( <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25BE%25D0%25BC">division with remainder</a> ) to determine whether the number is even (0) or odd (1).  For a detailed description, see <a href="http://www.redblobgames.com/grids/hexagons/implementation.html">the notes page for my implementation</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Neighboring Hexagons </h2><br>  Given one hexagon, with which six hexagons is it adjacent?  As you might expect, the easiest way to answer is in cubic coordinates, quite simple in axial coordinates, and a bit more difficult in offset coordinates.  You may also need to calculate six "diagonal" hexagons. <br><br><h3>  Cubic coordinates </h3><br>  Moving one space in the coordinates of the hexagons leads to a change in one of the three cubic coordinates by +1 and the other by -1 (the sum must remain 0).  Three possible coordinates can be changed by +1, and the remaining two can be changed by -1.  This gives us six possible changes.  Each corresponds to one of the directions of the hexagon.  The simplest and fastest way is to precompute the changes and put them into the table of <code>Cube(dx, dy, dz)</code> cubic coordinates during compilation: <br><br><pre> <code class="cpp hljs">var directions = [ Cube(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Cube(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Cube( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Cube(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Cube(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Cube( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] function cube_direction(direction): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directions[direction] function cube_neighbor(hex, direction): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cube_add(hex, cube_direction(direction))</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/d53/5d8/d02/d535d8d0271045aaa2f4e808657b11c4.png"></div><br><h3>  Axial coordinates </h3><br>  As before, we use a cubic system to begin with.  Take the <code>Cube(dx, dy, dz)</code> table <code>Cube(dx, dy, dz)</code> and convert to the <code>Hex(dq, dr)</code> table <code>Hex(dq, dr)</code> : <br><br><pre> <code class="cpp hljs">var directions = [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] function hex_direction(direction): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directions[direction] function hex_neighbor(hex, direction): var dir = hex_direction(direction) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(hex.q + dir.q, hex.r + dir.r)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a6f/f12/b58/a6ff12b58da6457f9986b31b1e593224.png"></div><br><h3>  Offset coordinates </h3><br>  In axial coordinates, we make changes depending on where in the grid we are.  If we are in an offset column / row, then the rule is different from the case of a column / row without offset. <br><br>  As before, we create a table of numbers that need to be added to <code>col</code> and <code>row</code> .  However, this time we will have two arrays, one for odd columns / rows, and the other for even ones.  Look at <code>(1,1)</code> in the figure above for the grid map and notice how <code>col</code> and <code>row</code> change when moving in each of the six directions.  Now repeat the process for <code>(2,2)</code> .  The tables and the code will be different for each of the four types of offset grids; we give the corresponding code for each type of grid. <br><br>  <b>Odd-r</b> <br><pre> <code class="cpp hljs">var directions = [ [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ], [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] ] function offset_neighbor(hex, direction): var parity = hex.row &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> var dir = directions[parity][direction] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(hex.col + dir.col, hex.row + dir.row)</code> </pre> <br><img src="https://habrastorage.org/files/969/840/d42/969840d42c464bb1ae4e1054f6fd2d0e.png"><br>  <i>Grid for even (EVEN) and odd (ODD) rows</i> <br><br>  <b>Even-r</b> <br><pre> <code class="cpp hljs">var directions = [ [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ], [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] ] function offset_neighbor(hex, direction): var parity = hex.row &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> var dir = directions[parity][direction] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(hex.col + dir.col, hex.row + dir.row)</code> </pre> <br><img src="https://habrastorage.org/files/699/1ad/8b5/6991ad8b5b3340489ddcc153040a2203.png"><br>  <i>Grid for even (EVEN) and odd (ODD) rows</i> <br><br>  <b>Odd-q</b> <br><pre> <code class="cpp hljs">var directions = [ [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ], [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] ] function offset_neighbor(hex, direction): var parity = hex.col &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> var dir = directions[parity][direction] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(hex.col + dir.col, hex.row + dir.row)</code> </pre> <br><img src="https://habrastorage.org/files/045/5d6/8ef/0455d68ef0544061b5541803cf0fe14d.png"><br>  <i>Grid for even (EVEN) and odd (ODD) columns</i> <br><br>  <b>Even-q</b> <br><pre> <code class="cpp hljs">var directions = [ [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ], [ Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Hex(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Hex( <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] ] function offset_neighbor(hex, direction): var parity = hex.col &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> var dir = directions[parity][direction] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Hex(hex.col + dir.col, hex.row + dir.row)</code> </pre> <br><img src="https://habrastorage.org/files/b19/1b1/a0b/b191b1a0b1de40e7b560a6acd63b8ba9.png"><br>  <i>Grid for even (EVEN) and odd (ODD) columns</i> <br><br>  Using the above lookup tables is the easiest way to calculate neighbors.  If you're interested, you can also read about <a href="http://www.redblobgames.com/grids/hexagons/derive-hex-neighbor-formula.html">extracting these numbers</a> . <br><br><h3>  Diagonals </h3><br>  The displacement in the ‚Äúdiagonal‚Äù space in the coordinates of the hexagons changes one of the three cubic coordinates by ¬± 2 and the other two by ‚àì1 (the sum must remain equal to 0). <br><br><pre> <code class="cpp hljs">var diagonals = [ Cube(+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Cube(+<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>), Cube(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Cube(<span class="hljs-number"><span class="hljs-number">-2</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>), Cube(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">2</span></span>), Cube(+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) ] function cube_diagonal_neighbor(hex, direction): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cube_add(hex, diagonals[direction])</code> </pre> <br>  As before, we can convert these coordinates into axial ones, by folding one of the three coordinates, or convert them into offset coordinates, having previously calculated the results. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aea/ab1/097/aeaab1097a3f4cba9bd3baca68528df0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Distances </h2><br><h3>  Cubic coordinates </h3><br>  In a cubic coordinate system, each hexagon is a cube in three-dimensional space.  Neighboring hexagons are in a grid of hexagons at a distance of 1 from each other, but at a distance of 2 in a grid of cubes.  This makes distance calculation simple.  In the grid of squares, the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25BA%25D0%25B2%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B2">Manhattan distances</a> are equal to <code>abs(dx) + abs(dy)</code> .  In a grid of cubes, the Manhattan distances are equal to <code>abs(dx) + abs(dy) + abs(dz)</code> .  The distance in the grid of hexagons is half of them: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">function</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cube_distance</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>): <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">abs</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bx</span></span>) + <span class="hljs-selector-tag"><span class="hljs-selector-tag">abs</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ay</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">by</span></span>) + <span class="hljs-selector-tag"><span class="hljs-selector-tag">abs</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">az</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bz</span></span>)) / 2</code> </pre> <br>  The equivalent of this record will be the expression that one of the three coordinates should be the sum of the other two, and then get it as a distance.  You can choose the form of division in half or the form of the maximum value given below, but they give the same result: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(ax - bx), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(ay - by), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(az - bz))</span></span></span></span></code> </pre> <br>  In the figure, the maximum values ‚Äã‚Äãare highlighted in color.  Notice also that each color represents one of the six "diagonal" directions. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/387/e89/8cb/387e898cb92542f9a68038d1a35b44f0.gif"><br></div></div><br><h3>  Axial coordinates </h3><br>  In the axial system, the third coordinate is implicitly expressed.  Let's <a href="http://www.redblobgames.com/grids/hexagons/">convert</a> from an axial to a cubic system to calculate the distance: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">: var ac </span></span>= hex_to_cube(a) var bc = hex_to_cube(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cube_distance(ac, bc)</code> </pre> <br>  If the compiler in your case embeds (inline) <code>hex_to_cube</code> and <code>cube_distance</code> , then it will generate the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(aq - bq) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(aq + ar - bq - br) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abs</span></span></span></span><span class="hljs-function"><span class="hljs-params">(ar - br))</span></span></span><span class="hljs-function"> / 2</span></span></code> </pre> <br>  There are many different ways to record the distances between the hexagons in axial coordinates, but regardless of the recording method, the <i>distance between the hexagons in the axial system is extracted from the Manhattan distance in the cubic system</i> .  For example, <a href="http://3dmdesign.com/development/hexmap-coordinates-the-easy-way">the</a> ‚Äúdifference of differences‚Äù described <a href="http://3dmdesign.com/development/hexmap-coordinates-the-easy-way">here is</a> obtained from the record <code>aq + ar - bq - br</code> as <code>aq - bq + ar - br</code> and using the maximum value form instead of the halving <code>cube_distance</code> .  All of them are similar, if you see the connection with cubic coordinates. <br><br><h3>  Offset coordinates </h3><br>  As in the case of axial coordinates, we <a href="http://www.redblobgames.com/grids/hexagons/">convert</a> the displacement coordinates into cubic coordinates, and then use the distance of the cubic system. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">: var ac </span></span>= offset_to_cube(a) var bc = offset_to_cube(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cube_distance(ac, bc)</code> </pre> <br>  We will use the same pattern for many algorithms: convert from hexagons to cubes, execute the cubic version of the algorithm, and convert the cubic results into hexagon coordinates (axial or displacement coordinates). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Line drawing </h2><br>  How to draw a line from one hexagon to another?  I use <a href="http://www.redblobgames.com/grids/line-drawing.html">linear interpolation to draw lines</a> .  The line is uniformly sampled at <code>N+1</code> points and it is calculated in which hexagons these samples are located. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0dd/21f/b93/0dd21fb930f848389f9c3877d1403f04.gif"><br></div></div><br><ol><li>  First we calculate <code>N</code> , which will be the distance in the hexagons between the end points. </li><li>  Then we uniformly sample <code>N+1</code> points between points A and B. Using linear interpolation, we determine that for <code>i</code> values ‚Äã‚Äãfrom <code>0</code> to <code>N</code> , including them, each point will be <code>A + (B - A) * 1.0/N * i</code> .  In the figure, these control points are shown in blue.  As a result, floating point coordinates are obtained. </li><li>  Transform each control point (float) back into hexagons (int).  The algorithm is called <code>cube_round</code> (see below). </li></ol><br>  We put everything together to draw the line from A to B: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, t)</span></span></span><span class="hljs-function">: </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  float return a + (b - a) * t function cube_lerp(a, b, t): //   return Cube(lerp(ax, bx, t), lerp(ay, by, t), lerp(az, bz, t)) function cube_linedraw(a, b): var N = cube_distance(a, b) var results = [] for each 0 ‚â§ i ‚â§ N: results.append(cube_round(cube_lerp(a, b, 1.0/N * i))) return results</span></span></span></span></code> </pre> <br>  Notes: <br><br><ul><li>  There are cases when <code>cube_lerp</code> returns a point exactly on the edge between two hexagons.  Then <code>cube_round</code> shifts it in one direction or another.  Lines look better if they are shifted in one direction.  This can be done by adding an "epsilon" hexagonal <code>Cube(1e-6, 1e-6, -2e-6)</code> to one or both end points before the start of the cycle.  This ‚Äúpushes‚Äù the line in one direction so that it does not fall on the edges of the faces. </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_DDA-%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25B8">The DDA line algorithm</a> in grid squares equates <code>N</code> with the maximum distance along each of the axes.  We do the same in cubic space, which is similar to the distance in the grid of hexagons. </li><li>  The <code>cube_lerp</code> function should return a cube with coordinates in float.  If you are programming in a language with static typing, you will not be able to use the <code>Cube</code> type.  Instead, you can define the type <code>FloatCube</code> or embed (inline) the function in the line drawing code, if you do not want to define another type. </li><li>  You can optimize the code by inserting (inline) <code>cube_lerp</code> , and then calculating <code>Bx-Ax</code> , <code>Bx-Ay</code> and <code>1.0/N</code> outside the loop.  Multiplication can be converted to repeated summation.  The result is something like a DDA-line algorithm. </li><li>  To draw lines, I use axial or cubic coordinates, but if you want to work with offset coordinates, then read <a href="http://zvold.blogspot.com/2010/02/line-of-sight-on-hexagonal-grid.html">this article</a> . </li><li>  There are many options for drawing lines.  Sometimes a <a href="http://stackoverflow.com/questions/3233522/elegant-clean-special-case-straight-line-grid-traversal-algorithm">"supercover"</a> is required.  They sent me a code for drawing lines with overcoating in hexagons, but I have not studied it yet. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Movement range </h2><br><h3>  Coordinate Range </h3><br>  For a given center of a hexagon and a range of <code>N</code> which hexagons are located within <code>N</code> steps from it? <br><br>  We can do the reverse work from the distance between hexagons formula <code>distance = max(abs(dx), abs(dy), abs(dz))</code> .  To find all hexagons within <code>N</code> , we need <code>max(abs(dx), abs(dy), abs(dz)) ‚â§ N</code>  This means that we need all three values: <code>abs(dx) ‚â§ N</code> and <code>abs(dy) ‚â§ N</code> and <code>abs(dz) ‚â§ N</code>  Removing the absolute value, we get <code>-N ‚â§ dx ‚â§ N</code> and <code>-N ‚â§ dy ‚â§ N</code> and <code>-N ‚â§ dz ‚â§ N</code>  In the code, this will be a nested loop: <br><br><pre> <code class="cpp hljs">var results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each -N ‚â§ dx ‚â§ N: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each -N ‚â§ dy ‚â§ N: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each -N ‚â§ dz ‚â§ N: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dx + dy + dz = <span class="hljs-number"><span class="hljs-number">0</span></span>: results.append(cube_add(center, Cube(dx, dy, dz)))</code> </pre> <br>  This cycle will work, but will be rather ineffective.  Of all the <code>dz</code> values ‚Äã‚Äãthat we loop through, only one really satisfies the cubes condition <code>dx + dy + dz = 0</code> .  Instead, we directly calculate the value of <code>dz</code> satisfying the condition: <br><br><pre> <code class="cpp hljs">var results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each -N ‚â§ dx ‚â§ N: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each max(-N, -dx-N) ‚â§ dy ‚â§ min(N, -dx+N): var dz = -dx-dy results.append(cube_add(center, Cube(dx, dy, dz)))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This cycle takes place only at the desired coordinates. </font><font style="vertical-align: inherit;">In the figure, each range is a pair of lines. </font><font style="vertical-align: inherit;">Each line is an inequality. </font><font style="vertical-align: inherit;">We take all hexagons satisfying six inequalities.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/702/754/93a/70275493a2f641668ca3f1cc85db96b2.gif"><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intersecting ranges </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need to find hexagons that are in several ranges, then before generating a list of hexagons, you can cross ranges. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One can approach this problem from the point of view of algebra or geometry. Algebraically, each domain is expressed as conditions of inequalities in form </font></font><code>-N ‚â§ dx ‚â§ N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and we need to find the intersection of these conditions. Geometrically, each region is a cube in three-dimensional space, and we will intersect two cubes in three-dimensional space to obtain a rectangular parallelepiped in three-dimensional space. Then we project it back onto the plane </font></font><code>x + y + z = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get the hexagons. I will solve this problem algebraically. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we rewrite the condition </font></font><code>-N ‚â§ dx ‚â§ N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a more general form </font><font style="vertical-align: inherit;">, and accept </font><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">. Do the same for</font></font><code>x <sub>min</sub> ‚â§ x ‚â§ x <sub>max</sub></code><font style="vertical-align: inherit;"></font><code>x <sub>min</sub> = center.x - N</code><font style="vertical-align: inherit;"></font><code>x <sub>max</sub> = center.x + N</code><font style="vertical-align: inherit;"></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as a result, getting a general view of the code from the previous section:</font></font><br><br><pre> <code class="cpp hljs">var results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each xmin ‚â§ x ‚â§ xmax: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each max(ymin, -x-zmax) ‚â§ y ‚â§ min(ymax, -x-zmin): var z = -xy results.append(Cube(x, y, z))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The intersection of two ranges </font></font><code>a ‚â§ x ‚â§ b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>c ‚â§ x ‚â§ d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font></font><code>max(a, c) ‚â§ x ‚â§ min(b, d)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Because the area of the hexagons expressed as ranges of </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can individually to cross each of the bands </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and then use a nested loop to generate a list of the hexagons in an intersection. </font><font style="vertical-align: inherit;">For one area of ‚Äã‚Äãhexagons we accept </font><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">, similarly for </font><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To intersect two regions of hexagons, we take </font><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">max = min (H1.x + N, H2.x + N), similarly for </font><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The same pattern works for intersecting three or more areas.</font></font><code>x <sub>min</sub> = Hx - N</code><font style="vertical-align: inherit;"></font><code>x <sub>max</sub> = Hx + N</code><font style="vertical-align: inherit;"></font><code>y</code><font style="vertical-align: inherit;"></font><code>z</code><font style="vertical-align: inherit;"></font><code>x <sub>min</sub> = max(H1.x - N, H2.x - N)</code><font style="vertical-align: inherit;"></font><code>x</code><font style="vertical-align: inherit;"></font><code>y</code><font style="vertical-align: inherit;"></font><code>z</code><font style="vertical-align: inherit;"></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a5d/a95/48e/a5da9548e3934156bf369db87c567a4e.gif"><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obstacles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are obstacles, the easiest way to do this is to fill with a distance restriction (wide search). </font><font style="vertical-align: inherit;">In the figure below we are limited to four moves. </font><font style="vertical-align: inherit;">In code </font></font><code>fringes[k]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this is an array of all hexagons that can be reached in </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps. </font><font style="vertical-align: inherit;">With each pass through the main loop, we expand the level </font></font><code>k-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the level </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_reachable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start, movement)</span></span></span><span class="hljs-function">: var visited </span></span>= <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>() add start to visited var fringes = [] fringes.append([start]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; k ‚â§ movement: fringes.append([]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each cube in fringes[k<span class="hljs-number"><span class="hljs-number">-1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each <span class="hljs-number"><span class="hljs-number">0</span></span> ‚â§ dir &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>: var neighbor = cube_neighbor(cube, dir) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> neighbor <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> in visited, <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> blocked: add neighbor to visited fringes[k].append(neighbor) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visited</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c47/d41/0ef/c47d410ef6544a31a6e8424ce28313dc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turns </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a given hexagon vector (the difference between two hexagons) we may need to rotate it so that it points to another hexagon. </font><font style="vertical-align: inherit;">This is easy to do, having cubic coordinates, if you stick to a turn by 1/6 of a circle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotate 60 ¬∞ to the right shifts each coordinate one position to the right:</font></font><br><br><pre> <code class="cpp hljs"> [ x, y, z] to [-z, -x, -y]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rotate 60 ¬∞ to the left shifts each coordinate one position to the left: </font></font><br><br><pre> <code class="cpp hljs"> [ x, y, z] to [-y, -z, -x]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/bb4/714/17e/bb471417e8d349b9891dcbdbba3e26a6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/09f/fdb/2a3/09ffdb2a3ea140a1ba68dc56bbef48a0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúHaving played‚Äù [in the original of the article] with the scheme, one can notice that each turn by 60 ¬∞ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signs and physically ‚Äúrotates‚Äù the coordinates. </font><font style="vertical-align: inherit;">After turning to 120 ¬∞, the signs again become the same. </font><font style="vertical-align: inherit;">A 180 ¬∞ rotation changes signs, but the coordinates rotate to their original position. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the complete sequence of turning the position P around the center position C, leading to the new position R:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transformation of P and C positions into cubic coordinates. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Center vector calculation by subtracting: </font></font><code>P_from_C = P - C = Cube(Px - Cx, Py - Cy, Pz - Cz)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotate the vector </font></font><code>P_from_C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as described above and assign the notation to the final vector </font></font><code>R_from_C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformation vectors back into the center position of addition: </font></font><code>R = R_from_C + C = Cube(R_from_C.x + Cx, R_from_C.y + Cy, R_from_C.z + Cz)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convert the cubic position of R back to the desired coordinate system. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several stages of transformation, but each one is fairly simple. </font><font style="vertical-align: inherit;">You can shorten some of these steps by defining the rotation directly in the axial coordinates, but the hexagon vectors do not work with the offset coordinates, and I do not know how to shorten the steps for the offset coordinates. </font><font style="vertical-align: inherit;">See also the </font></font><a href="http://gamedev.stackexchange.com/questions/15237/how-do-i-rotate-a-structure-of-hexagonal-tiles-on-a-hexagonal-grid/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discussion of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> other ways to calculate rotation on stackexchange.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>  Rings </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simple ring </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To find out if a given hexagon belongs to a ring of a given radius </font></font><code>radius</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you need to calculate the distance from this hexagon to the center, and find out if it is equal </font></font><code>radius</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To get a list of all such hexagons, you need to take </font></font><code>radius</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps from the center, and then follow the turning vectors along the path along the ring.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_ring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(center, radius)</span></span></span><span class="hljs-function">: var results </span></span>= [] #      radius == <span class="hljs-number"><span class="hljs-number">0</span></span>;  , ? var cube = cube_add(center, cube_scale(cube_direction(<span class="hljs-number"><span class="hljs-number">4</span></span>), radius)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each <span class="hljs-number"><span class="hljs-number">0</span></span> ‚â§ i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each <span class="hljs-number"><span class="hljs-number">0</span></span> ‚â§ j &lt; radius: results.append(cube) cube = cube_neighbor(cube, i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code </font></font><code>cube</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starts on a ring, shown by a large arrow from the center to the corner of the circuit. </font><font style="vertical-align: inherit;">I chose angle 4 to begin with, because it corresponds to the path in which my numbers of directions move. </font><font style="vertical-align: inherit;">You may need a different starting angle. </font><font style="vertical-align: inherit;">At each stage of the internal cycle </font></font><code>cube</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moves one hexagon around the ring. </font><font style="vertical-align: inherit;">Through the </font></font><code>6 * radius</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps he completes where he started.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/960/44c/c9a/96044cc9a8b34a3e9bd9f3a22dfd2f72.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9a5/c59/67e/9a5c5967e6c4431c8a7b865da81297fd.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiral rings </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passing through the rings in a spiral pattern, we can fill the inner parts of the rings: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_spiral</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(center, radius)</span></span></span><span class="hljs-function">: var results </span></span>= [center] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each <span class="hljs-number"><span class="hljs-number">1</span></span> ‚â§ k ‚â§ radius: results = results + cube_ring(center, k) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/ad8/cc8/fab/ad8cc8fab5ab4394a03f6011ade8636c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b6e/d29/3dd/b6ed293dde5a4ebc948e514a665641d3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The area of ‚Äã‚Äãthe large hexagon is equal to the sum of all circles plus 1 for the center. </font><font style="vertical-align: inherit;">To calculate the area, use </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D1%2582%25D1%2583%25D1%2580%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2580%25D1%258F%25D0%25B4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this formula</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traversing hexagons in this way can also be used to calculate the range of motion (see above).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Area of ‚Äã‚Äãvisibility </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is visible from a given position with a given distance, and does not overlap with obstacles? The simplest way to determine this is to draw a line to each hexagon in a given range. If the line does not meet with the walls, then you see a hexagon. Move the mouse over the hexagons [on the diagram in the original article] to see the lines drawn to these hexagons and the walls with which the lines meet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm can be slow on large areas, but it is easy to implement, so I recommend starting with it.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b89/3da/3f6/b893da3f69c54dbb964d2d0a21cfdc32.gif"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many different definitions of visibility. Do you want to see the center of another hexagon from the center of the initial one? Do you want to see any part of the other hexagon from the center of the initial one? Maybe any part of another hexagon from anywhere in the starting one? Obstacles that hinder the view are smaller than a full hexagon? Scope is a trickier and more diverse concept than it seems at first glance. Let's start with the simplest algorithm, but expect that it will correctly calculate the answer in your project. There are even cases when a simple algorithm gives illogical results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clark Verbrugge manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describes an algorithm for calculating the "start from the center of scope" and move outward. " See also the </font></font><a href="https://github.com/jbochi/duelo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duelo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">, which is on Github.</font></font><a href="https://s3.amazonaws.com/jbochi/layout.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online demo scope with directions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can also read </font></font><a href="http://www.redblobgames.com/articles/visibility/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my article on the calculation of 2d visibility</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it has an algorithm that works with polygons, including hexagons. </font><font style="vertical-align: inherit;">The roguelike community has a good set of algorithms for squares grids (see </font></font><a href="http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.roguebasin.com/index.php%3Ftitle%3DPre-Computed_Visibility_Tries"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and here). </font><font style="vertical-align: inherit;">Some of them can be adapted to the grid of hexagons.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hexagons to pixels </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To convert from hexagons to pixels, it is useful to study the size and location scheme presented in the Geometry section. </font><font style="vertical-align: inherit;">In the case of axial coordinates, the transformation from hexagons to pixels must be approached, considering the basis vectors. </font><font style="vertical-align: inherit;">In the diagram, the arrow A ‚Üí Q is the basis vector q, and A ‚Üí R is the basis vector r. </font><font style="vertical-align: inherit;">The pixel coordinate is </font></font><code>q_basis * q + r_basis * r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, B in (1, 1) is the sum of the basis vectors q and r.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d85/83c/118/d8583c118b264d37aa680cc00ccf0748.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the presence of a matrix library, the operation is a simple multiplication of matrices. </font><font style="vertical-align: inherit;">However, here I will write the code without matrices. </font><font style="vertical-align: inherit;">For an axial grid </font></font><code>x = q</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>z = r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which I use in this guide, the transformation will be as follows: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For flat-topped hexagons</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.q y = size * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) * (hex.r + hex.q/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point(x, y)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For hexagons with sharp tops</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= <span class="hljs-function"><span class="hljs-function">size * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex.q + hex.r/</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> y </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.<span class="hljs-function"><span class="hljs-function">r </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The matrix approach will be convenient later when we need to convert the coordinates of the pixels back to the coordinates of the hexagons. </font><font style="vertical-align: inherit;">All we need is to invert the matrix. </font><font style="vertical-align: inherit;">For cubic coordinates, you can either use cubic basis vectors (x, y, z), or first convert them to axial, and then use axial basis vectors (q, r). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For offset coordinates, we will need to shift the number of the column or row (it will no longer be an integer). </font><font style="vertical-align: inherit;">After that, you can use the basic vectors q and r associated with the x and y axes: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odd-r</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= <span class="hljs-function"><span class="hljs-function">size * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex.col + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * (hex.row&amp;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> y </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.<span class="hljs-function"><span class="hljs-function">row </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even-r</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= <span class="hljs-function"><span class="hljs-function">size * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex.col - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * (hex.row&amp;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> y </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.<span class="hljs-function"><span class="hljs-function">row </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odd-q</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.col y = size * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) * (hex.row + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (hex.col&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point(x, y)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even-q</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset_to_pixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hex)</span></span></span><span class="hljs-function">: x </span></span>= size * <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> * hex.col y = size * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) * (hex.row - <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (hex.col&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point(x, y)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, the offset coordinates do not have basis vectors that can be used with the matrix. </font><font style="vertical-align: inherit;">This is one of the reasons why converting from pixels to hexagons is more difficult in offset coordinates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another approach is to convert the offset coordinates to cubic / axial coordinates, then use the conversion of cubic / axial coordinates to pixels. </font><font style="vertical-align: inherit;">By embedding the transform code while optimizing it, it will result in the same result as above.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From pixels to hexagons </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the most frequent questions is how to take the position of a pixel (for example, a mouse click) and convert it to the coordinate of the grid of hexagons? </font><font style="vertical-align: inherit;">I will show how this is done for axial or cubic coordinates. </font><font style="vertical-align: inherit;">For offset coordinates, the easiest way is to convert cubic coordinates to offset coordinates at the end.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/e6e/62c/6b2/e6e62c6b207b4c7e90f948e82af09495.gif"><br></div></div><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">invert the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hexagon transformation to pixels. </font><font style="vertical-align: inherit;">This will give us the fractional coordinates of the hexagon, shown in the picture with a small blue circle.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we define a hexagon containing the fractional coordinate of the hexagon. </font><font style="vertical-align: inherit;">It is shown in the figure by a highlighted hexagon.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the coordinate conversion in the pixel coordinates of hexagons we have multiplied </font></font><code>q</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the basis vectors to obtain </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It can be considered a multiplication of matrices. </font><font style="vertical-align: inherit;">Here is a matrix for hexagons with sharp tops:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e51/612/84b/e5161284baa242ec88c4d5ada013bd8c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converting pixel coordinates back to hexagon coordinates is fairly straightforward. </font><font style="vertical-align: inherit;">We can reverse the matrix:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dd9/003/e68/dd9003e68b5943b5905c019fd12e9855.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These calculations will give us fractional axial coordinates (float) for </font></font><code>q</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The function </font></font><code>hex_round()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converts fractional axial coordinates to whole axial coordinates of hexagons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the code for axial hexagons with sharp tops:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixel_to_hex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">: q </span></span>= (x * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)/<span class="hljs-number"><span class="hljs-number">3</span></span> - y / <span class="hljs-number"><span class="hljs-number">3</span></span>) / size r = y * <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> / size <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hex_round(Hex(q, r))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And here is the code for axial hexagons with flat tops: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixel_to_hex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">: q </span></span>= x * <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> / size r = (-x / <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)/<span class="hljs-number"><span class="hljs-number">3</span></span> * y) / size <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hex_round(Hex(q, r))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These three lines of code transform the pixel position into the axial coordinate of the hexagon. </font><font style="vertical-align: inherit;">If you use offset coordinates, then use </font></font><code>return cube_to_hex(cube_round(Cube(q, -qr, r)))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many other ways to convert pixels to hexagons. </font><font style="vertical-align: inherit;">On </font></font><a href="http://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are the known to me.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Round to nearest hexagon </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes we get a cubic coordinate (x, y, z) </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a floating point</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we need to know in which hexagon it should be. This turns out to be a line drawing and a conversion from pixels to hexagons. Converting a floating point value to an integer value is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rounding</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so I called this algorithm </font></font><code>cube_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In cubic coordinates, </font></font><code>x + y + z = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">even with cubic floating point coordinates. So let's round each component down to the nearest integer </font></font><code>(rx, ry, rz)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, although </font></font><code>x + y + z = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, after rounding, we have no guarantees that </font></font><code>rx + ry + rz = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, we change the component with the largest change so that the condition is </font></font><code>rx + ry + rz = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true. For example, if the change is </font></font><code>y</code> <code>abs(ry-y)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">greater</font></font><code>abs(rx-x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>abs(rz-z)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then we change it to </font></font><code>ry = -rx-rz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This guarantees us that </font></font><code>rx + ry + rz = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is the algorithm:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h)</span></span></span><span class="hljs-function">: var rx </span></span>= round(hx) var ry = round(hy) var rz = round(hz) var x_diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rx - hx) var y_diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(ry - hy) var z_diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rz - hz) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x_diff &gt; y_diff <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x_diff &gt; z_diff: rx = -ry-rz <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y_diff &gt; z_diff: ry = -rx-rz <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: rz = -rx-ry <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cube(rx, ry, rz)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For non-cubic coordinates, the easiest way is to convert them to cubic coordinates, use the rounding algorithm, and then convert them back: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex_round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h)</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cube_to_hex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cube_round(hex_to_cube(h)))</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation note: </font></font><code>cube_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>hex_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get the coordinates in float, not in int. If you have written classes </font></font><code>Cube</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Hex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, they will work fine in languages ‚Äã‚Äãwith dynamic typing, in which you can pass floating-point numbers instead of integers, and in languages ‚Äã‚Äãwith static typing with a unified type of numbers. However, in most languages ‚Äã‚Äãwith static typing, a separate class / struct type for float coordinates </font></font><code>cube_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be </font><font style="vertical-align: inherit;">needed and </font><font style="vertical-align: inherit;">will be of type </font></font><code>FloatCube ‚Üí Cube</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If you also need it </font></font><code>hex_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it will be </font></font><code>FloatHex ‚Üí Hex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using a helper function </font></font><code>floatcube_to_floathex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead </font></font><code>cube_to_hex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In languages ‚Äã‚Äãwith parameterized types (C ++, Haskell, etc.), you can define a Cube, where T is an int or float. Or you can write</font></font><code>cube_round</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to get three floating point numbers as input instead of defining a new type only for this function. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Storage of maps in axial coordinates </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most often, the axial coordinate system causes complaints because it leads to unnecessary expenditure of space when using rectangular maps. This is one of the reasons in favor of the offset coordinate system. However, all the coordinate systems of hexagons lead to the consumption of space when using triangular or hexagonal maps. We can use the same strategy for storing all these types of cards. </font></font><br><br><img src="https://habrastorage.org/files/bae/64e/3f1/bae64e3f1107497e9a13002179057e4d.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rectangular Map </font></font></i> <br><br><img src="https://habrastorage.org/files/1a1/2d4/b5d/1a12d4b5dc6145c2957327c03cee6e32.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangular Map </font></font></i> <br><br><img src="https://habrastorage.org/files/a15/188/928/a15188928756418688d4fe29808690ed.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hexagon Map </font></font></i> <br><br><img src="https://habrastorage.org/files/1c8/923/706/1c89237065954fa6b2ba7d6c5e743198.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diamond Card</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notice in the diagram that the unused space is to the right and left of each line (except for diamond-shaped cards). This gives us three options for card storage strategies:</font></font><br><br><ol><li> <b></b> .          .            . ,     . </li><li>     <b>-</b> .      ,      .        <code>q,r</code>       <code>hash_table(hash(q,r))</code> .    /   ,          . </li><li> <b></b>        .        .      .       .  ,         0,     . <br><br>        ,     ¬´ ¬ª.        <code>q,r</code> ,       <code>array[r][q - first_column[r]]</code> .    /   ,          .   <code>first_column</code>      . <br><br>     ,  ¬´ ¬ª   ¬´ ¬ª,      . <br><br><ul><li>    <code>first_column[r] == -floor(r/2)</code> .       <code>array[r][q + r/2]</code> ,         . </li><li>   ,   , <code>first_column[r] == 0</code> ,      <code>access array[r][q]</code> ‚Äî  !   ,  - (   ),   <code>array[r][q+r]</code> . </li><li>     <code>N</code> ,  <code>N = max(abs(x), abs(y), abs(z)</code> ,    <code>first_column[r] == -N - min(0, r)</code> .     <code>array[r][q + N + min(0, r)]</code> .       -  <code>r &lt; 0</code> ,        <code>array[r + N][q + N + min(0, r)]</code> . </li><li>      ,     <code>array[r][q]</code> . </li></ul></li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some games require the card to ‚Äústick together‚Äù along the edges. A square map can be wrapped only along the x axis (which roughly corresponds to a sphere) or along both x and y axes (which roughly corresponds to a torus). Folding depends on the shape of the map, and not on the shape of its elements. Folding a square map is easier done in offset coordinates. I will show how the hexagon map is rolled up in cubic coordinates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the center of the map, there are six "mirror" centers. When leaving the card, we subtract the mirror center nearest to us until we return to the main card again. On the diagram [in the original article], try to leave the central map, and watch as one of the mirror centers enters the map from the opposite side.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest implementation will be the preliminary calculation of the answers. </font><font style="vertical-align: inherit;">Create a lookup table that stores for each hexagon coming out of the map, the corresponding cube on the other side. </font><font style="vertical-align: inherit;">For each of the six mirror centers </font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and for each of the provisions on the map </font></font><code>L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">store </font></font><code>mirror_table[cube_add(M, L)] = L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each time when calculating a hexagon that is in the table of mirrors, we replace it with a non-mirrored version. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On a hexagonal map with a radius, the </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror centers will be </font></font><code>Cube(2*N+1, -N, -N-1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">six of its turns.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ccd/a8c/f5b/ccda8cf5bdf84120a304f400ee5de8fa.gif"><br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finding the way </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using search paths on graphs, for example, the A * search algorithm, Dijkstra or Floyd-Worshel algorithm, finding a path on hexagonal grids does not differ from finding a path on square grids. </font><font style="vertical-align: inherit;">The explanations and code from my pathfinding </font></font><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guideline are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> applicable to hexagonal grids.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/04e/e21/731/04ee21731c0341ed801044cdecf83ceb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [In the original article, the example is interactive, you can add and delete walls with mouse clicks] </font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighbors</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The sample code presented in the guide to finding the path calls to get the elements adjacent to the position </font></font><code>graph.neighbors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Use the function in the section "Neighboring hexagons". </font><font style="vertical-align: inherit;">Filter out impassable adjacent hexagons.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heuristic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the example of the code of the algorithm A *, a function is used </font></font><code>heuristic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that obtains the distance between two positions. </font><font style="vertical-align: inherit;">Use the distance formula multiplied by the cost of moving. </font><font style="vertical-align: inherit;">For example, if the displacement is 5 units per hexagon, then multiply the distance by 5.</font></font></li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/146/3d6/19a/1463d619a08c44798f50cbb5318a4057.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional reading </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have a </font></font><a href="http://www.redblobgames.com/grids/hexagons/implementation.html"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guide to implementing my own hex grid library</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with C ++, Java, C #, Javascript, Haxe and Python code samples.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my </font></font><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guide to grids,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I consider axial coordinate systems and the machining of faces and angles of squares, triangles, and hexagons. </font><font style="vertical-align: inherit;">I also explain how grids of squares and hexagons are connected.</font></font></li><li>   ,   ,  <a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">  </a> ,   1996 . </li><li>         1994  <a href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">   rec.games.programmer</a> . </li><li> <a href="http://devmag.org.za/2013/08/31/geometry-with-hex-coordinates/"> DevMag      </a> ,    ,   ,   .  <a href="http://www.gamelogic.co.za/downloads/HexMath2.pdf">  PDF</a> ,   . <b>   !</b>  <a href="http://gamelogic.co.za/grids/documentation-contents/quick-start-tutorial/gamelogics-hex-grids-for-unity-and-amit-patels-guide-for-hex-grids/">GameLogic Grids</a>         Unity. </li><li> <a href="http://playtechs.blogspot.com/2007/04/hex-grids.html">        </a> . </li><li> <a href="http://sc.tri-bit.com/Hex_Grids">   </a> :  ( ), ,  ()   (). </li><li> <a href="http://ondras.github.io/rot.js/manual/"> Rot.js</a>     :  (),    ( ),   (), . </li><li> <a href="http://stackoverflow.com/questions/2049196/generating-triangular-hexagonal-coordinates-xyz">   </a> :        ? </li><li> <a href="http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/">    </a>             . </li><li>  <a href="http://www.br-gs.com/tutorial/hexagon-grid.html"> </a>          . </li><li> <a href="http://stackoverflow.com/questions/2459402/hexagonal-grid-coordinates-to-pixel-coordinates">      </a> . </li><li>  <a href="http://gamedev.stackexchange.com/questions/51264/get-ring-of-tiles-in-hexagon-grid"> </a> ,   . </li><li>   <a href="http://www.webwargaming.org/hexagoncoordinates.shtml">HexPart</a>   ,         . </li><li>   <a href="http://gamedev.stackexchange.com/questions/49718/vertical-vs-horizontal-hex-grids-pros-and-cons">         </a> ? </li><li> <a href="http://arges-systems.com/blog/2011/01/10/hex-grid-line-of-sight-revisited/">    </a>   ,    . [ ] </li><li> Hexnet ,  <a href="http://hexnet.org/content/permutohedron">    </a>  ,      ,       . </li><li>   PDF     <a href="http://incompetech.com/graphpaper/hexagonal/"> </a> ,     . </li><li> <a href="http://www.reddit.com/r/gamedev/comments/19wmvn/a_data_structure_for_a_game_board_with_hexagonal/c8s9qbe">    </a>     ;     . </li><li> <a href="http://hexgridutilities.codeplex.com/documentation">Hex-Grid Utilities</a> ‚Äî   C#            , ,    ,  .  MIT. </li><li>    <a href="http://www.reddit.com/r/gamedev/comments/1dz1tr/">Reddit</a> , <a href="https://news.ycombinator.com/item%3Fid%3D5809724">Hacker News</a>  <a href="http://www.metafilter.com/128649/Hexagonal-Grids">MetaFilter</a>     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The [original] code for this article is written in a mixture of </font></font><a href="http://haxe.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haxe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and Javascript: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cube.hx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex.hx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid.hx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScreenCoordinate.hx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ui.js,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cubegrid.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (for animating cubes / hexagons). </font><font style="vertical-align: inherit;">However, if you want to write your own library of hexagonal grids, I recommend that you look into </font></font><a href="http://www.redblobgames.com/grids/hexagons/implementation.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my implementation guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instead </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to further expand this guide. </font><font style="vertical-align: inherit;">I have a </font></font><a href="https://trello.com/card/hexagonal-grids-2-0/4f1dbfdc0fc2508c1b238d7d/52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list on Trello</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/319644/">https://habr.com/ru/post/319644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319632/index.html">AT & T is preparing to launch the Internet via power lines</a></li>
<li><a href="../319636/index.html">New features of the product SCAT DPI 6.0 ‚ÄúSevastopol‚Äù from VAS Experts</a></li>
<li><a href="../319638/index.html">"Battle for a place": Scientists hope to reduce the number of wires in the data center</a></li>
<li><a href="../319640/index.html">Begin End: IPv4 addresses really end</a></li>
<li><a href="../319642/index.html">The way to go to gain invaluable experience in mobile development</a></li>
<li><a href="../319646/index.html">Competition GraphHPC-2017 for the fastest implementation of the task of Betweenness Centrality</a></li>
<li><a href="../319648/index.html">Speed ‚Äã‚Äãreading How to memorize and understand more if you learn to read eight times faster</a></li>
<li><a href="../319652/index.html">Demeter's Law</a></li>
<li><a href="../319654/index.html">7 useful tips on protecting backups from encryption viruses</a></li>
<li><a href="../319656/index.html">CodeceptJS - modern end2end tests for NodeJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>