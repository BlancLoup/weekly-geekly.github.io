<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Without knowing the ford, do not go into the water. Part three</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will continue the stories about how programmers walk along the edge without even knowing it. Talk about shift operations <<, >>. The principles of o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Without knowing the ford, do not go into the water. Part three</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/844/f4f/a16/844f4fa161ce2a621da993672f2415f3.png" alt="Shifts"><br>  I will continue the stories about how programmers walk along the edge without even knowing it.  Talk about shift operations &lt;&lt;, &gt;&gt;.  The principles of operation of shift operators are obvious and many programmers do not even know that their use according to the C / C ++ standard can lead to undefined or unspecified behavior (undefined behaviors / unspecified behavior). <br><a name="habracut"></a><br><br>  Previous articles are available here: [ <a href="http://habrahabr.ru/post/137039/">1</a> ], [ <a href="http://habrahabr.ru/post/137411/">2</a> ]. <br><br><h3>  Historical excursion </h3><br>  At the beginning of a little story.  The need for bit shift operations is obvious to any programmer.  Sooner or later, everyone is faced with the need to work with individual bits and bitmasks.  However, shear operations are much more popular than they should have been.  The reason is that by using shifts, you can multiply and divide numbers by a power of two.  For example, the operation ‚ÄúX &lt;&lt; 3‚Äù multiplies X by 8. The advantage of this method of multiplication and division was the speed of their work in the past. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now I have got a book with a description of assembler commands for processors starting from 8086 and ending with 80486 from the dusty shelf. And I found a table about the number of cycles required to perform various instructions. <br><br>  Multiplying a 16-bit register by a memory cell using the MUL instruction on an 8086 processor requires about 124-139 cycles! <br><br>  Shifting a 16-bit register by N positions using the SHL instruction on an 8086 processor requires 8 + 4 * N ticks.  That is, in the worst case, 72 tacts are obtained. <br><br>  It was possible to obtain significant acceleration when calculating arithmetic expressions using various tricks when working with bit operations.  This was the reason for the massive use of shifts, at the beginning, in assembly language, then in C and C ++ languages.  The first C / C ++ compilers were simple.  A person could get a gain in speed, obviously telling the compiler that it is necessary to use a shift here, and not instructions for multiplication or division. <br><br>  With the development of processors, the benefits of using shifts have been maintained for a long time.  In the 80486 processor, multiplication began to take about 26 cycles.  It seems much better.  However, the shift began to take only 3 bars and, again, was more attractive than multiplication. <br><br>  Fortunately, these forced optimizations are mostly sunk into oblivion.  First, compilers have become intelligent and use the optimal set of instructions to calculate arithmetic expressions.  Secondly, the processors have also changed tremendously.  Pipelines appeared, transition prediction, register renaming, and much more.  Therefore, an ordinary programmer is no longer able to tell how long it takes to execute a particular instruction.  But it is clear that if the code is not perfect in some places, this can not even be noticed.  The processor will break the instructions into micro-instructions and start executing them in parallel.  To be honest, I no longer understand how everything is happening there now.  I realized that to understand the intricacies of meaningless, starting with the processor Intel Pentium.  And he concluded that you should not think that you know better how to write an optimizing code, use shifts and bit operations wherever possible.  Far from the fact that as a result, the code will be faster than the optimizer does in the compiler.  But you can definitely say that the program will become confusing and difficult to understand. <br><br>  Note.  The above does not mean that the use of bit operations can no longer bring benefits.  There are many interesting and useful tricks [ <a href="http://www.viva64.com/go.php%3Furl%3D837">3</a> ].  The main thing is not to get involved. <br><br><h3>  Indefinite behavior </h3><br>  It all started with the fact that I decided to increase in the PVS-Studio analyzer the number of warnings related to undefined behavior [ <a href="http://www.viva64.com/go.php%3Furl%3D663">4</a> ] and unspecified behavior [ <a href="http://www.viva64.com/go.php%3Furl%3D738">5</a> ].  The rule detecting incorrect use of shift operations was implemented fairly quickly and simply.  After that, I had to stop and think. <br><br>  It turned out that programmers are very fond of shifts.  And they are used in every possible way, often leading to indefinite behavior from the point of view of the standard.  But theory is one thing, practice is another.  Does it make sense to swear at the code that faithfully served for decades and has experienced more than one compiler?  Complex issue.  Despite the fact that the code is incorrect, the compilers follow no tacit agreement and process it in a uniform way. <br><br>  After much deliberation, I decided to leave this diagnostic rule in PVS-Studio without making exceptions from it.  If there are too many complaints from users, then maybe I will change my mind.  However, users may be satisfied with the ability to turn off this diagnostics or use other <a href="http://www.viva64.com/ru/d/0021/">methods of</a> suppressing warnings. <br><br>  By the way, it was these spiritual torments that prompted me to write an article.  I hope the information that I show will be interesting and useful. <br><br>  So, let's see what is written in the C ++ 11 standard about the shift operators: <br><br>  <i>The shift operators &lt;&lt; and &gt;&gt; group left-to-right.</i> <br><br>  <i>shift-expression &lt;&lt; additive-expression</i> <br><br>  <i>shift-expression &gt;&gt; additive-expression</i> <br><br>  <i>This is an integral part of the business process.</i> <br><br>  <i>1. The promoted left operand.</i>  <i>If you are on the right side of the left operand.</i> <br><br>  <i>2. The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions;</i>  <i>vacated bits are zero-filled.</i>  <i>If it is an unsigned pattern, it can be used to make it possible.</i>  <i>Otherwise, if E1 is a signed type and non-negative value, and E1 * 2 ^ E2 is representable, then that is the resulting value;</i>  <i>otherwise, the behavior is undefined.</i> <br><br>  <i>3. The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions.</i>  <i>It is an insignia of the E1 / 2 ^ E2.</i>  <i>If E1 has a signed value</i> <br><br>  Reading such texts is sad and sad.  But do not worry.  Now we will look at various incorrect situations with examples. <br><br>  The simplest case leading to undefined behavior is when the right operand has a negative value.  Example: <br><pre>  int A = 10;
 int B = A &lt;&lt; -5; </pre><br>  So, thank God, nobody does.  At least, after analyzing more than 70 open-source projects, we did not encounter such errors. <br><br>  The following case is much more interesting.  This is a shift by N bits, where N is greater than the number of bits in the left operand.  The simplest example is: <br><pre>  int A = 10;
 int B = A &lt;&lt; 100; </pre><br>  Let's see how this error may look like in practice.  The following code snippet was found by us in the Lib7z library: <br><pre>  SZ_RESULT
 SafeReadDirectUInt64 (ISzInStream * inStream, UInt64 * value)
 {
   int i;
   * value = 0;
   for (i = 0; i &lt;8; i ++)
   {
     Byte b;
     RINOK (SafeReadDirectByte (instream, &amp; b));
     * value | = ((UInt32) b &lt;&lt; (8 * i));
   }
   return SZ_OK;
 } </pre><br>  PVS-Studio diagnostic message: V610 Undefined behavior.  Check the shift operator '&lt;&lt;.  The right operand ('(8 * i)' = [0..56]) is the left operand.  lib7z 7zin.c 233 <br><br>  The function attempts to read the 64-bit value byte-by-byte.  Unfortunately, it will not work if the number was greater than 0x00000000FFFFFFFF.  Notice the shift "(UInt32) b &lt;&lt; (8 * i)".  The size of the left operand is 32 bits.  In this case, the shift occurs from 0 to 56 bits.  In practice, this will lead to the fact that the older part of the 64-bit value will remain filled with zeros.  In theory, there is generally undefined behavior and the result is unpredictable. <br><br>  The correct code should look like this: <br><pre>  * value | = ((UInt64) b &lt;&lt; (8 * i)); </pre><br>  The reader may wonder if the code below is correct? <br><pre>  char A = 1;
 int B = A &lt;&lt; 20; </pre><br>  Yes, it is correct.  To the left of the operator &lt;&lt; there is a variable A, consisting only of 8 bits.  But before the start of the shift operation, the left side will be expanded to type int.  Accordingly, a value of type 'int' can be shifted by 20 bits. <br><br>  And now the most interesting moment.  This is a shift in negative values.  The simplest example is: <br><pre>  int A = -1 &lt;&lt; 5;  // undefined behavior
 int B = -1 &gt;&gt; 5;  // unspecified behavior </pre><br>  In this code, there is undefined and unspecified behavior.  From a practical point of view, there is no difference.  Only one conclusion - you can not write like that. <br><br>  On this one could put an end and give a couple of examples.  Unfortunately, there are two nuances that spoil the ideal picture of the world. <br><br><h3>  Nuances that spoil the perfect picture of the world </h3><br>  <b>Nuance N1.</b>  In the old C ++ standard of 1998, situations with uncertain behavior are bypassed.  It is said how the &lt;&lt; operator behaves when shifting unsigned values.  And about sign values ‚Äã‚Äãnothing is said.  In general, the very case when reading the standard does not add clarity.  Not considered such a case and all. <br><br>  So, from the point of view of C ++ from 1998, the construction "-1 &lt;&lt; 5" does not lead to indefinite behavior.  However, how it should work is also not described. <br><br>  <b>Nuance N2.</b>  Programmers boldly shift negative values ‚Äã‚Äãin many programs.  And it will be difficult to argue with them, because the code works. <br><br>  Let us try to figure out whether, because of these nuances, we should abandon the new diagnostics.  We think not. <br><br>  In the old C ++ standard, it does not say about undefined behavior.  The new says.  It turns out that the old standard was simply not accurate enough.  By the way, in the new standard of C (I watched a draft of June 25, 2010), it is also said that shifts of negative values ‚Äã‚Äãlead to indefinite behavior.  Conclusion - should get rid of incorrect code. <br><br>  Now, regarding the ubiquitous use of dangerous shifts.  There are really a lot of them.  For example, in the JPEG library, you must fill the array with the following values: <br><pre>  11111111111111111111111111111111b
 11111111111111111111111111111101b
 11111111111111111111111111111001b
 11111111111111111111111111110001b
 ... </pre><br>  This is written as: <br><pre>  / * entry n is (-1 &lt;&lt; n) + 1 * /
 static const int extend_offset [16] = {0,
   ((-1) &lt;&lt; 1) + 1, ((-1) &lt;&lt; 2) + 1, ((-1) &lt;&lt; 3) + 1,
   ((-1) &lt;&lt; 4) + 1, ((-1) &lt;&lt; 5) + 1, ((-1) &lt;&lt; 6) + 1,
   ((-1) &lt;&lt; 7) +1, ((-1) &lt;&lt; 8) +1, ((-1) &lt;&lt; 9) +1,
   ((-1) &lt;&lt; 10) + 1, ((-1) &lt;&lt; 11) + 1, ((-1) &lt;&lt; 12) + 1,
   ((-1) &lt;&lt; 13) + 1, ((-1) &lt;&lt; 14) + 1, ((-1) &lt;&lt; 15) + 1
 }; </pre><br>  It's hard to call a jpeg library bad.  And this code is tested by time and different compilers. <br><br>  From the point of view of the standard, it should now be rewritten as follows: <br><pre>  static const int extend_offset [16] =
 {0,
   ((~ 0u) &lt;&lt; 1) |  1, ((~ 0u) &lt;&lt; 2) |  1, ((~ 0u) &lt;&lt; 3) |  one,
   ((~ 0u) &lt;&lt; 4) |  1, ((~ 0u) &lt;&lt; 5) |  1, ((~ 0u) &lt;&lt; 6) |  one,
   ((~ 0u) &lt;&lt; 7) |  1, ((~ 0u) &lt;&lt; 8) |  1, ((~ 0u) &lt;&lt; 9) |  one,
   ((~ 0u) &lt;&lt; 10) |  1, ((~ 0u) &lt;&lt; 11) |  1, ((~ 0u) &lt;&lt; 12) |  one,
   ((~ 0u) &lt;&lt; 13) |  1, ((~ 0u) &lt;&lt; 14) |  1, ((~ 0u) &lt;&lt; 15) |  one
 }; </pre><br>  But whether to make such edits you decide.  I can only give advice after all to do it.  It is not known when and how, it can manifest itself. <br><br>  You can give other examples of shifts of negative values ‚Äã‚Äãin different programs.  But they are all of the same type, so it will not be interesting to read about them. <br><br><h3>  findings </h3><br><ol><li>  Previously, the use of bit operations and shifts was a sign of a programmer's skill and allowed writing fast code.  Now it is almost not relevant.  It is much more important that the code is clear.  Use games with bats only in case of real need. </li><li>  Expressions of the form "-1 &lt;&lt; N" are now declared as incorrect and leading to undefined behavior. </li><li>  Expressions like "-1 &lt;&lt; N" are long and often used.  Therefore, it is difficult to bring real arguments against the use of such structures.  The argument is only new standards of C and C ++ languages. </li><li>  Decide for yourself whether to correct the shift in negative values ‚Äã‚Äãor not.  But I recommend a fix.  Just in case. </li><li>  Diagnostic messages regarding dangerous shifts will be available in <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> starting from version 4.60, which will be released soon. </li></ol><br><br><h3>  Additional resources </h3><br><ol><li>  Without knowing the ford, do not go into the water.  Part one.  <a href="http://habrahabr.ru/post/137039/">http://habrahabr.ru/post/137039/</a> </li><li>  Without knowing the ford, do not go into the water.  Part two.  <a href="http://habrahabr.ru/post/137411/">http://habrahabr.ru/post/137411/</a> </li><li>  Sean Eron Anderson.  Bit Twiddling Hacks.  <a href="http://www.viva64.com/go.php%3Furl%3D837">http://www.viva64.com/go.php?url=837</a> </li><li>  Wikipedia.  Undefined behavior.  <a href="http://www.viva64.com/go.php%3Furl%3D663">http://www.viva64.com/go.php?url=663</a> </li><li>  Wikipedia.  Unspeakable behavior.  <a href="http://www.viva64.com/go.php%3Furl%3D738">http://www.viva64.com/go.php?url=738</a> </li><li>  Alena C ++.  The difference between unspecified behavior and undefined behavior.  <a href="http://www.viva64.com/go.php%3Furl%3D739">http://www.viva64.com/go.php?url=739</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/141880/">https://habr.com/ru/post/141880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141875/index.html">How are we going to impose when the screens become multi-pixel and the pixels are barely distinguishable</a></li>
<li><a href="../141876/index.html">OpenStreetMap: Three New Governing Licensing Agreements</a></li>
<li><a href="../141877/index.html">Information technology and dissertation system reform</a></li>
<li><a href="../141878/index.html">Moscow.com - the most expensive non-Latin domain</a></li>
<li><a href="../141879/index.html">Russian-German student school JASS-2012. Impressions</a></li>
<li><a href="../141881/index.html">Drawing grid graphs of three-dimensional functions and contour lines to them</a></li>
<li><a href="../141882/index.html">Car open source</a></li>
<li><a href="../141883/index.html">Github has included the DCPU-16 assembler in the list of officially supported languages.</a></li>
<li><a href="../141884/index.html">Pomatrosil and quit: Google sells Motorola</a></li>
<li><a href="../141885/index.html">The perfect Android player for non-music</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>