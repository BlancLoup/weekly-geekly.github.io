<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++: Leash Pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The other day, a colleague threw such a problem: 

 ‚ÄúThere are two types of objects - Human and Dog . Human may own a dog (or may not own it). Dog may...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++: Leash Pattern</h1><div class="post__text post__text-html js-mediator-article">  The other day, a colleague threw such a problem: <br><br>  ‚ÄúThere are two types of objects - <i>Human</i> and <i>Dog</i> .  Human may own a <i>dog</i> (or may not own it).  <i>Dog</i> may have some <i>owner</i> (or may not have).  It is clear that if some object of type <i>Human</i> owns some object of type <i>Dog</i> , then for this object of type <i>Dog</i> exactly this object of type <i>Human</i> is the owner and only he.  And <i>Dog</i> must know who his <i>Human</i> , and vice versa.  How would you do this? ‚Äù <br><br>  It would seem that everything is simple - we will get two pointers on each other from the classes <i>Human</i> and <i>Dog</i> and it's in the bag.  But the implementation of this venture led me to the idea, I think, of a new design pattern. <br><a name="habracut"></a><br>  And if not a template, then at least C ++ idioms, which allow using bi-directional links in the program with static type control and a couple of useful "buns". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Note: the</b> term ‚Äúlink‚Äù is used in the article in the meaning of ‚Äúlink‚Äù, and not in the meaning of <nobr>‚ÄúC ++ link‚Äù</nobr> . <br><br>  First, let's see what the first idea with pointers is wrong with? <br><br><h4>  Lead v.1 ("in the forehead") </h4><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> {</span></span> Human* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Dog(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Human* l)</span></span></span><span class="hljs-function"> </span></span>{ link = l; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Human* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class"> {</span></span> Dog* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Human(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog* l)</span></span></span><span class="hljs-function"> </span></span>{ link = l; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Dog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } }</code> </pre> <br><br>  This implementation allows you to solve the task, as they say, ‚Äúhead on‚Äù: <br><pre> <code class="cpp hljs">Human *h = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Human(); Dog *d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); h-&gt;SetLink(d); d-&gt;SetLink(h);</code> </pre><br><br>  However, it has several obvious flaws: <br><ol><li>  You can forget to set the reciprocal link: <code>d-&gt;SetLink(h)</code> . </li><li>  You can mistakenly set a reverse link to another object: <code>d-&gt;SetLink(h2)</code> . </li><li>  After the destruction of one of the related objects, another object will refer to the deleted object. </li></ol><br>  Getting rid of these shortcomings is easy enough: <br><br><h4>  Lead v.2 (automatics) </h4><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> {</span></span> Human* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Dog(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} ~Dog() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Human* l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link == l) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Human* oldlink = link; link = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldlink) oldlink-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); link = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Human* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class"> {</span></span> Dog* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Human(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} ~Human() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog* l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link == l) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Dog* oldlink = link; link = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldlink) oldlink-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); link = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Dog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } }</code> </pre><br>  What changed? <br><br>  First, the <code>SetLink()</code> methods became more complicated.  Now, when setting the link in one direction, the method automatically sets the link in the other direction.  Forget to install one of the links is impossible.  Exactly as it is impossible to establish an incorrect back link: <br><pre> <code class="cpp hljs">Human *h1, *h2; h1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Human(); h2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Human(); Dog *d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); h1-&gt;SetLink(d); assert(h1-&gt;GetLink()-&gt;GetLink() == h1); <span class="hljs-comment"><span class="hljs-comment">//passed (d    h1) d-&gt;SetLink(h2); assert(d-&gt;GetLink()-&gt;GetLink() == d); //passed (h2    d) assert(h1-&gt;GetLink() == NULL); //passed (h1    d)</span></span></code> </pre><br>  Secondly, destructors appeared, which, when destroying an object, automatically remove the link from the associated object, if any.  Thus, by <code>GetLink()</code> you can <u>always</u> expect either a valid pointer or NULL. <br><br>  Well, now, it would seem, all the flaws are eliminated and can be used.  However, an attentive reader will note that the implementation of the classes <i>Human</i> and <i>Dog is</i> identical and differs only in the types used.  And then I thought: ‚Äúit is necessary to remake it into templates!‚Äù It is said - done. <br><br><h4>  Lead v.3 (templates) </h4><br>  A template implies parameterization by one or several types.  In our case, there are two types: <i>M</i> (My) and <i>L</i> (Link), and the template itself is respectively written as <i>O &lt;M, L&gt;</i> .  An instance of the specialization of such a template is able to store a pointer to an object of type <i>L</i> , that is, it organizes a relationship <i>M -&gt; L.</i>  To create a two-way communication between classes <i>A</i> and <i>B</i> , two symmetric specializations are used: <i>O &lt;A, B&gt;</i> and <i>O &lt;B, A&gt;</i> . <br><br>  Thus, the type <i>M</i> shows the type of the <b>inner</b> end of the link and is needed in order to correctly cast the <i>this</i> pointer, and the type <i>L</i> shows the type of the <b>outer</b> end of the link: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> {</span></span> L* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: O(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} ~O() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L* l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link == l) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; L* oldlink = link; link = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldlink) oldlink-&gt;SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); link = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;SetLink(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;M*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> L* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } };</code> </pre><br>  Using this template class is very simple: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Human, Dog&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Dog, Human&gt; {}; Human* h = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Human(); Dog* d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); h-&gt;SetLink(d);</code> </pre><br>  Fine!  We recorded our classes two times shorter! <br><br>  A nice feature of this implementation of bidirectional links is that the compiler will be able to determine some <b>logical</b> errors for us. <br><br>  For example, the absence of a class that is the response of the link.  That is, if there is a class in the code that can contain the <nobr><i>Human</i> -&gt; <i>Dog</i></nobr> link, but there is no class that can contain the <nobr><i>Dog</i> -&gt; <i>Human</i></nobr> link, then such code will not compile: <br><pre> <code class="hljs ruby">template&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> { ... };</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class">&lt;Human, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">&gt; {};</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> {};</span></span></code> </pre><br><br>  Of course, it is allowed to link objects of the same type: <br><pre> <code class="hljs ruby">template&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> { ... };</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class">&lt;Human, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">&gt; {};</span></span> Human *h1, *h2; ... h1-&gt;SetLink(h2);</code> </pre><br><br>  You can even set a link to yourself.  If this is unacceptable, it is easy to fix the <code>SetLink()</code> method <code>SetLink()</code> . <br><br>  It seems now quite good!  And what if <i>Human</i> 'u, in addition to the reference to the <i>Dog</i> object, is required to have a reference to the <i>Cat</i> object? <br><br><h4>  Lead v.4 (multiple links) </h4><br>  This can also be easily done using multiple inheritance and a slightly modified class <i>O</i> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> {</span></span> L* link; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: O(): link(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) {} ~O() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;O&lt;L,M&gt;::SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L* l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link == l) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; L* oldlink = link; link = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldlink) oldlink-&gt;O&lt;L,M&gt;::SetLink(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); link = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link) link-&gt;O&lt;L,M&gt;::SetLink(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;M*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> L* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Human, Dog&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Human, Cat&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Dog, Human&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Cat, Human&gt; {};</code> </pre><br>  The explicit resolution of the namespace <i>O &lt;L, M&gt;</i> was <code>SetLink</code> in order to <code>SetLink</code> function from the correct base class.  The attentive reader will notice that the compiler could choose the correct <code>SetLink()</code> function according to the type of the parameter passed to it, as is done in the case of overloaded functions.  However, if these functions are in different classes (in our case, in different <u>parent</u> classes), then according to the C ++ standard, overloading does not work [1]. <br><br>  The same changes will affect users of our classes: <br><pre> <code class="cpp hljs">Human* h; Dog* d; Cat* c; ... <span class="hljs-comment"><span class="hljs-comment">// h-&gt;SetLink(d); // ,  h-&gt;O&lt;Human, Dog&gt;::SetLink(d); //,   h-&gt;O&lt;Human, Cat&gt;::SetLink(c); //      //   GetLink() // h-&gt;GetLink(); //,  Link   -      h-&gt;O&lt;Human, Dog&gt;::GetLink(); //,  </span></span></code> </pre><br>  This can be simplified by slightly modifying the <i>Human</i> class.  Add in it <code>SetLink()</code> implementations of the own <code>SetLink()</code> and <code>GetLink()</code> methods, which will call the corresponding method of one or another parent class depending on the type: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Human, Dog&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> O&lt;Human, Cat&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetLink</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> O&lt;Human,T&gt;::GetLink(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetLink</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) {</span></span> O&lt;Human,T&gt;::SetLink(l); } };</code> </pre><br>  Now everything is almost as simple as in the case of single connections: <br><pre> <code class="cpp hljs">Human* h; Dog* d; Cat* c; ... h-&gt;SetLink&lt;Dog&gt;(d); h-&gt;SetLink&lt;Cat&gt;(c); <span class="hljs-comment"><span class="hljs-comment">//   ,     h-&gt;SetLink(d); h-&gt;SetLink(c); h-&gt;GetLink&lt;Dog&gt;(); //  Dog h-&gt;GetLink&lt;Cat&gt;(); //  Cat</span></span></code> </pre><br><br><h4>  What happened? </h4><br>  It turned out a convenient (in my opinion) template class, which allows you to establish <b>bidirectional</b> connections between objects of strictly <b>defined types</b> with automatic ensuring their <b>integrity</b> . <br><br>  Yes, do not ask me why I called the template class letter <i>O.</i>  Best of all he would have come up with the name <i>Leash</i> (a leash). <br><br>  Written was tested using gcc 4.4.3. <br><br><h4>  Links </h4><br>  [1] <a href="http://bytes.com/topic/c/answers/137040-multiple-inheritance-ambiguity">bytes.com/topic/c/answers/137040-multiple-inheritance-ambiguity</a> <br><br>  Ps.  If someone knows the online version of the current C ++ standard, share the link - I would like to refer to the original source. <br><br>  Pps.  While this topic was languishing on a slow fire in the Sandbox, I had an idea how to simplify the use of <i>O</i> in the case of multiple references, and using C ++ 0x.  Stay tuned. <br></div><p>Source: <a href="https://habr.com/ru/post/126501/">https://habr.com/ru/post/126501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126496/index.html">Backup in FreeNas</a></li>
<li><a href="../126497/index.html">Neural network data compression</a></li>
<li><a href="../126498/index.html">Another project that gave way to MSTU. Bauman</a></li>
<li><a href="../126499/index.html">User rights in information systems through the lens of CMS Bitrix</a></li>
<li><a href="../126500/index.html">A group of 27,612 South Koreans sued Apple</a></li>
<li><a href="../126503/index.html">Important nuances of "computer help"</a></li>
<li><a href="../126504/index.html">Oatmeal - Why I believe all printers are from hell</a></li>
<li><a href="../126506/index.html">Avatar for car computer</a></li>
<li><a href="../126508/index.html">Transition from UFS to ZFS, dangerous operations with a ROOT partition</a></li>
<li><a href="../126509/index.html">Opening Offshore Bank Accounts with Payweb.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>