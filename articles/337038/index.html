<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript scopes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript, the scope is an important, but ambiguous concept. Scopes, with the right approach to their use, allow the use of robust design patterns...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript scopes</h1><div class="post__text post__text-html js-mediator-article">  In JavaScript, the scope is an important, but ambiguous concept.  Scopes, with the right approach to their use, allow the use of robust design patterns that help avoid unwanted side effects in programs.  In this article we will analyze the different types of scopes in JavaScript, let's talk about how they work.  A good understanding of this mechanism will allow you to improve the quality of the code. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/337038/"><img src="https://habrastorage.org/web/d01/097/209/d0109720903640f3a138cada915583c2.jpg"></a> <br>  <i><font color="#999999">Image for request "scopes".</font></i>  <i><font color="#999999">Sorry if you caused a nostalgia)</font></i> <br><br>  An elementary definition of the scope is as follows: this is the area where the compiler searches for variables and functions when it needs them.  Think it sounds too easy?  We offer to understand together. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Javascript interpreter</font> </h2><br>  Before talking about scopes, you need to discuss the JavaScript interpreter, consider how it affects different scopes.  When executing a JS code, the interpreter passes through it twice. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first pass through the code, also called the compilation pass, is the one that most strongly affects the scopes.  The interpreter scans the code for declarations of variables and functions and raises these declarations to the top of the current scope.  It is important to note that only variable declarations are raised, and the assignment operations remain as they are - for the next pass, called the performance pass. <br><br>  In order to better understand this, consider a simple code snippet: <br><br><pre><code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wow = <span class="hljs-string"><span class="hljs-string">'wow'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wow</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pow = <span class="hljs-string"><span class="hljs-string">'pow'</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo); <span class="hljs-comment"><span class="hljs-comment">// 'foo'  console.log(wow); // 'zoom' } bar('zoom'); console.log(pow); // ReferenceError: pow is not defined</span></span></code> </pre> <br>  This code, after compilation, will look something like this: <br><br><pre> <code class="hljs lua"><span class="hljs-string"><span class="hljs-string">'use strict'</span></span> //         var foo; var wow; //    ,   ,       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wow)</span></span></span></span> { var <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span> = <span class="hljs-string"><span class="hljs-string">'pow'</span></span>; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(foo); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(wow); } foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; wow = <span class="hljs-string"><span class="hljs-string">'wow'</span></span>; bar(<span class="hljs-string"><span class="hljs-string">'zoom'</span></span>); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>); // ReferenceError: <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span> is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined</code> </pre> <br>  Here we must pay attention to the fact that the ads rise to the top of their current scope.  This, as will be seen below, is very important for understanding the scopes in JavaScript. <br><br>  For example, the variable <code>pow</code> was declared in the <code>bar</code> function, since this is its scope.  Note that the variable is not declared in the parent, with respect to the function, scope. <br><br>  The <code>wow</code> parameter of the <code>bar</code> function is also declared in the function scope.  In fact, all the parameters of the function are implicitly declared in its scope, and that is why the <code>console.log(wow)</code> command in the ninth line, inside the function, displays the <code>zoom</code> instead of <code>wow</code> . <br><br><h2>  <font color="#3AC1EF">Lexical scope</font> </h2><br>  Having considered the features of the JavaScript interpreter and addressing the topic of raising variables and functions, we can proceed to talk about the scope.  Let's start with the lexical scope.  It can be said that this is a scope that is formed at compile time.  In other words, the <b>decision on the boundaries of this scope is made at compile time</b> .  For the purposes of this article, we will ignore the exceptions to this rule that occur in code that uses <code>eval</code> or <code>with</code> commands.  We believe that these commands, in any case, should not be used. <br><br>  The second pass of the interpreter is the one during which values ‚Äã‚Äãare assigned to variables and functions are executed.  In the above code example, it is during this pass that the <code>bar()</code> call is performed in line 12. <br><br>  The interpreter needs to find the declaration <code>bar</code> before making this call, it does it, starting with the search in the current scope.  At that moment, the current is the global scope.  Thanks to the first pass, i.e. compilation, we know that the <code>bar</code> declaration is at the top of the code, so the interpreter can find it and perform the function. <br><br>  If we look at line 8, where is the <code>console.log(foo);</code> command <code>console.log(foo);</code>  , the interpreter, before executing this command, will need to find the declaration <code>foo</code> .  The first thing he does, again, is looking for the current scope, which at this moment is the scope of the function <code>bar</code> , and not the global scope.  Is the variable <code>foo</code> declared in the function scope?  No, it is not.  It then goes up a level, to the parent scope, and looks for a variable declaration there.  The scope in which the function is declared is the global scope.  Is the variable foo declared in the global scope?  Yes it is.  Therefore, the interpreter can take the value of a variable and execute the command. <br><br>  In general, we can say that the meaning of the lexical scope is that the scope is determined after compilation, and when the interpreter needs to find a declaration of a variable or function, it first looks in the current scope, but if it finds what it needs, fails, it goes into the parent scope, continuing the search on the same principle.  The highest level to which it can go is called the global scope. <br><br>  If what the interpreter is looking for is not in the global scope, it will generate a <code>ReferenceError</code> error. <br><br>  In addition, since the interpreter first searches for what it needs in the current scope, and only then in the parent, the lexical scope introduces the concept of shading variables in JavaScript.  This means that the variable <code>foo</code> declared in the current scope of the function will shade or hide the variable with the same name declared in the parent scope.  Take a look at the following example in order to better understand this idea: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo); } bar();</code> </pre> <br>  This code will print the string <code>bar</code> in the console, not <code>foo</code> , since declaring the variable <code>foo</code> in the sixth line will block the declaration of the variable with the same name in the third line. <br><br>  Variable shading is a design pattern that can be useful if you want to mask some variables and prevent them from being accessed from specific scopes.  I must say that I usually avoid using this technique, applying it only if it is absolutely impossible to do without it, as I am sure that using the same variable names leads to confusion in team development.  The use of shading can lead to the fact that the developer can decide that the variable does not store what is actually in it. <br><br><h2>  <font color="#3AC1EF">Functional scope</font> </h2><br>  As we have seen, when considering the lexical scope, the interpreter declares variables in the current scope, which means that the variables declared in the function are declared in the functional scope.  This scope is limited to the function itself and its descendants ‚Äî other functions declared inside this function. <br><br>  Variables declared in the functional scope cannot be accessed externally.  This is a very powerful design pattern that you can use if you want to create private properties and have access to them only inside the functional scope.  Here's what it looks like: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">amount</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _conversionRate = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        return amount * _conversionRate; } console.log(convert(5)); console.log(_conversionRate); // ReferenceError: _conversionRate is not defined</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Block scope</font> </h2><br>  Block scope is similar to functional, but it is not limited to a function, but a block of code. <br><br>  In ES3, the <code>catch</code> expression in the <code>try / catch</code> construct has a block scope, which means that this expression has its own scope.  It is important to note that the <code>try</code> expression does not have a block scope, only the <code>catch</code> expression has it.  Consider an example: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bar); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'In catch block'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err);</code> </pre> <br>  This code will generate an error on the fifth line when we try to access <code>bar</code> , which causes the interpreter to go to the <code>catch</code> expression.  In the scope of the expression declared variable <code>err</code> , which will not be accessible from the outside.  In fact, the error will be displayed when we try to output the value of the variable <code>err</code> to the log in the line <code>console.log(err)</code>  This is what this code will output: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span> catch block ReferenceError: bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined   (...<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span> stack here...) foo ReferenceError: <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined (...<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span> stack here...)</code> </pre> <br>  Note that the variable <code>foo</code> is available outside the <code>try / catch</code> construct, and <code>err</code> is not. <br><br>  If we talk about ES6, then using the <code>let</code> and <code>const</code> keywords, variables and constants implicitly join the current block scope instead of the functional scope.  This means that these constructs are limited to the block in which they are used, whether it be an <code>if</code> block, a <code>for</code> block, or a function.  Here is an example that will help to better understand this: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> condition = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName = <span class="hljs-string"><span class="hljs-string">'John'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     let lastName = 'Doe'; //     if   const fullName = firstName + ' ' + lastName; //     if } console.log(firstName); // John console.log(lastName); // ReferenceError console.log(fullName); // ReferenceError } bar();</span></span></code> </pre> <br>  The <code>let</code> and <code>const</code> keywords allow us to use the principle of least disclosure.  Following this principle means that the variable must be available in the smallest possible scope.  Prior to ES6, developers often achieved a blocky scope effect using the stylistic method of declaring variables with the <code>var</code> keyword in an instantly executed functional expression (Immediately Invoked Function Expression, IIFE), but now, thanks to <code>let</code> and <code>const</code> , you can apply a functional approach.  Some of the main advantages of this principle are to avoid unwanted access to variables, and thus reduce the likelihood of errors.  In addition, it allows the garbage collector to free memory from unnecessary variables when leaving the block scope. <br><br><h2>  <font color="#3AC1EF">Immediately executable function expressions</font> </h2><br>  IIFE is a very popular JavaScript design pattern that allows functions to create a new block scope.  IIFE are ordinary functional expressions that we execute immediately after they are processed by the interpreter.  Here is an example of IIFE: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'in function bar'</span></span>); })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo);</code> </pre> <br>  This code will print the line <code>in function bar</code> before the output of <code>foo</code> , since the <code>bar</code> function is executed immediately, without the need to explicitly call it using a <code>bar()</code> .  This happens for the following reasons: <br><br><ul><li>  There is an opening bracket in front of the function keyword (and its corresponding closing one), which turns this construct, from a function declaration, into a functional expression. <br></li><li>  Here there are two brackets at the end, thanks to which the functional expression is executed immediately. <br></li></ul><br>  As we have already seen, this allows you to hide variables from code from external scopes, to restrict access, and in order not to pollute external scopes with unnecessary variables. <br><br>  IIFE is also very useful if you are performing an asynchronous operation and want to save the state of variables in the IIFE scope.  Here is an example of this behavior: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'index: '</span></span> + i); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre> <br>  It can be expected that this code will output 0, 1, 2, 3, 4. However, the actual result of the execution of this <code>for</code> loop, in which the asynchronous <code>setTimeout</code> operation is called, will look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  The reason for this is that by the time 1000 milliseconds have elapsed, the execution of the <code>for</code> loop will end and counter <code>i</code> will be equal to 5. <br><br>  In order for the code to work as expected, it would output a sequence of numbers from 0 to 4, we need to use IIFE to preserve the required scope: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'index: '</span></span> + index);   }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); })(i) }</code> </pre> <br>  In this example, we pass the value of <code>i</code> to IIFE.  A functional expression will have its own scope, which is no longer affected by what happens in the <code>for</code> loop.  This is what this code will output: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We looked at various scopes in JavaScript, talked about their features, described some simple design patterns.  In fact, you can still talk and talk about areas of visibility in JavaScript, but I believe that this material provides a good basis, using which you will be able to deepen and expand your knowledge on your own. <br><br>  I hope this story has helped you better understand the scope in JavaScript, and thus improve the quality of your programs.  We can also recommend for reading <a href="https://habrahabr.ru/post/239863/">this publication</a> on Habr√©. <br><br>  Dear JS developers!  Please share some interesting techniques for working with scopes in JavaScript. </div><p>Source: <a href="https://habr.com/ru/post/337038/">https://habr.com/ru/post/337038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337026/index.html">GSoC 2017 Project Report: ReactOS Apps Manager</a></li>
<li><a href="../337028/index.html">Bayes Summer | Deep | Bayes Summer School Materials in In-Depth Learning</a></li>
<li><a href="../337030/index.html">How recursion works - explanation in flowcharts and video</a></li>
<li><a href="../337034/index.html">Call for free using ENUMER blockchain service</a></li>
<li><a href="../337036/index.html">Wolfenstein 3D pixel-by-pixel fill</a></li>
<li><a href="../337040/index.html">‚ÄúRise of Machinery Learning‚Äù or combine a hobby in Data Science and analyzing the spectra of light bulbs</a></li>
<li><a href="../337042/index.html">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a></li>
<li><a href="../337044/index.html">We write GraphQL API server on Yii2 with a client on Polymer + Apollo. Part 2. Client</a></li>
<li><a href="../337046/index.html">We write GraphQL API server on Yii2 with a client on Polymer + Apollo. Part 3. Mutations</a></li>
<li><a href="../337048/index.html">Sir, your team is not a team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>