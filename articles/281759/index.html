<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin overview and comparison with C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the author: 
 This article is a note on the knee and is rather a brief overview of Kotlin, including a small comparison with the C # language in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin overview and comparison with C #</h1><div class="post__text post__text-html js-mediator-article"><h1>  From the author: </h1><br>  This article is a note on the knee and is rather a brief overview of Kotlin, including a small comparison with the C # language in terms of syntax.  This is my opinion and my thoughts about this relatively young language in the world of the Java platform, which in my opinion has a good chance of success. <br><br><a name="habracut"></a><br>  Kotlin is a statically typed object-oriented programming language compiled for Java platforms (also JavaScript).  Developed since 2010 by JetBrains.  The release took place not so long ago.  The authors aimed to make the language more concise and type-safe than Java, and simpler than Scala.  The consequence of simplification compared with Scala is also faster compilation and better language support in the IDE.  In addition, when the company announced the development of this language, a storm of criticism fell upon it that developers would better bring the Scala plugin to mind (which, as I understand it, still does not have a normal IDE).  However, for a company, a programming language is quite an important tool, and Java developers are not in a hurry to introduce new functionality into the language.  And it‚Äôs not even the case that they don‚Äôt want it, but because there is too much code written and too many systems running on this platform.  And here it is necessary to pull backward compatibility as ballast.  And even if in the latest, 8 versions of the language, they added new features (like lambda expressions, for example), the Enterprise world did not rush to update the JVM, which makes programmers sit on the version that the customer has.  As experience shows, some custom-made enterprises and companies <i>have recently</i> updated their machines to version 7, and it will be too expensive for a customer‚Äôs company to force several hundred machines to upgrade to version 8.  From my point of view, such a latency of a language in development characterizes it as a sufficiently developed and powerful tool that can give an idea of ‚Äã‚Äãhow often it is used.  However, compared to other Java languages, it sometimes seems verbose, but this is my opinion as a person who has programmed enough in C # and used for example the same LINQ, lambda expressions, and other syntax sugar buns that make the code more compact. <br>  Therefore, people at JetBrains decided to make a language that, with full compatibility with Java, will provide additional features that simplify the programmer‚Äôs daily work and increase productivity. <br><br><h2>  Acquaintance ... </h2><br>  I ran into him by chance.  Programming in Java, I missed the buns from C # and I would like to somehow please myself and meet the requirements of the customer.  After reviewing the Kotlin documentation, I realized that this is what I need.  Documentation of 150 pages is quite easy to read, the language is simple to learn and quite concise.  However, what I liked the most was that it has quite a lot in common with C # and working with the language becomes even more pleasant.  Still, do not want to forget .NET. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Goodies ... </h2><br><h3>  Work with classes </h3><br>  Well, now let's move on to the most interesting and consider some features of the language and what I like about it. <br>  How to declare a class in Kotlin: <br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-comment"><span class="hljs-comment">//var -   , val -   var age: Int constructor(name: String, age: Int) { this.name = name this.age = age } }</span></span></code> </pre> <br>  Almost nothing unusual, except that the constructor is marked with the constructor keyword.  In fact, this is a secondary constructor from the point of view of Kotlin (a), and the primary or primary constructor is part of the class header: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, var age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, var age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  The exact same syntax is equivalent to the code that was described earlier.  The variables name and age are also present in the class and were respectively created in the primary constructor with var (an interesting enough feature).  At first glance it is unusual, but after a while you realize that it is very convenient.  But the main constructor cannot contain any code, so there is an initialization block (init), which is called every time an object is created: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, var age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span>{ init { <span class="hljs-comment"><span class="hljs-comment">//-  } }</span></span></code> </pre><br>  Interesting in my opinion.  You can also make a chain of constructors: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">//,  null,        ,    ,   C# var age: Int = 0 //   ,    , getter  setter    constructor(name: String, age: Int) : this(name) { this.age = age } }</span></span></code> </pre><br>  Interestingly implemented here are the properties and the complete syntax for the declaration: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> &lt;propertyName&gt;: &lt;<span class="hljs-type"><span class="hljs-type">PropertyType</span></span>&gt; [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;]</code> </pre><br>  The initializer, getter, and setter are optional when describing a class, as shown in the first example.  If the variable is described as val, then setter is denied accordingly.  How to describe properties: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> get() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Name man: $field"</span></span> <span class="hljs-comment"><span class="hljs-comment">//field -   ,     .  getter    , field      } private set(value) { //       field = value } var age: Int constructor(name: String, age: Int) { this.name = name this.age = age } }</span></span></code> </pre><br><h3>  Data classes </h3><br>  Of interest are Data Classes.  These classes are used to store data and do nothing else.  The compiler automatically deduces members from all properties declared in the main constructor: <br><ul><li>  equals () / hashCode () </li><li>  the toString () method of the Man form ("Alex", 26) </li><li>  functions for the corresponding properties in the order of their declaration (destructured declarations) </li><li>  copy () function </li></ul><br>  This provides convenience when working with classes of this type: <br><pre> <code class="scala hljs">data <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Man</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, var age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">args: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">&gt;</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> man = <span class="hljs-type"><span class="hljs-type">Man</span></span>(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     new println(man) // Man(name=Alex, age=26) //  val (name, age) = man //  : val name = man.component1(); val age = man.component2(); println(name) // Alex println(age) // 26 // copy() var man2 = man.copy() //  ,   var man2 = man.copy(age = 20) // ,     println(man2) //Man(name=Alex, age=20) }</span></span></code> </pre><br>  On this description of classes, I would like to finish and go to the part of the language that is its highlight. <br><br><h3>  Functions and Lambdas </h3><br>  Functions in Kotlin are declared using the fun keyword and can be defined globally without being tied to a specific class. <br><pre> <code class="scala hljs">fun f1(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  fun f1(x: Int): Int = x * 2 //   fun main(args: Array&lt;String&gt;) { println(f1(5)) // 10 }</span></span></code> </pre><br>  Functions can also be called using infix notation when: <br><ul><li>  They are member functions or extension functions. </li><li>  They have one parameter. </li><li>  They are tagged with the infix keyword. </li></ul><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   Int infix fun Int.extent(x: Int): Int { return this + x } //  infix fun Int.extent(x: Int) = this + x fun main(args: Array&lt;String&gt;) { // -   infix  println(5 extent 10) // 15 //   println(5.extent(10)) }</span></span></code> </pre><br>  Functions also have named parameters and default argument values. <br>  You can pass a variable number of arguments: <br><pre> <code class="scala hljs">fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; asList(vararg ts: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t in ts) <span class="hljs-comment"><span class="hljs-comment">// ts is an Array result.add(t) return result } fun main(args: Array&lt;String&gt;) { val list = asList(1, 2, 3) // ,     }</span></span></code> </pre><br>  Local functions are supported (C # 7.0 also implemented this function) <br><pre> <code class="scala hljs">fun f1(x: <span class="hljs-type"><span class="hljs-type">Man</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> { fun isTeenager(age: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age in <span class="hljs-number"><span class="hljs-number">13.</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isTeenager(x.age)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Man teenager"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Man is not a teenager"</span></span> }</code> </pre><br><h3>  Higher order functions and lambda expressions </h3><br>  Of particular interest is this part of the language.  Higher-order functions are usually called functions that take other functions as arguments or return another function as a result.  In this case, the basic idea is that the functions have the same status as other data objects.  The use of higher-order functions leads to abstract and compact programs, taking into account the complexity of their calculations. <br>  Consider an example of a higher order function: <br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ,     fun&lt;T&gt; List&lt;T&gt;.filter(transform: (T) -&gt; Boolean): List&lt;T&gt; { val result = arrayListOf&lt;T&gt;() for (item in this) { if (transform(item)) { result.add(item) } } return result } fun main(args: Array&lt;String&gt;) { val list = arrayListOf(1, 4, 6, 7, 9, 2, 5, 8) val listEven = list.filter { item -&gt; item % 2 == 0 } listEven.forEach { item -&gt; print(item.toString() + " ") } // : 4 6 2 8 }</span></span></code> </pre><br>  This approach allows you to write LINQ-style code: <br><pre> <code class="scala hljs">strings.filter { it.length == <span class="hljs-number"><span class="hljs-number">5</span></span> }.sortBy { it }.map { it.toUpperCase() }</code> </pre><br>  The full syntax of the lambda expression is as follows: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = { x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; x + y }</code> </pre><br>  Moreover, if you leave additional annotations, it will look like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = { x, y -&gt; x + y }</code> </pre><br>  Parameters are always indicated in parentheses, which are then passed to the body with -&gt;. <br>  One thing that is missing from the lambda expression syntax is the ability to specify the type of the return value.  In most cases, this is unnecessary because the return type can be inferred automatically.  However, if you need to specify it explicitly, you can use an alternative syntax: an <i>anonymous function</i> . <br><pre> <code class="scala hljs">fun(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = x + y <span class="hljs-comment"><span class="hljs-comment">//  val listEven = list.filter(fun(item) = item % 2 == 0)</span></span></code> </pre><br><h3>  Currying and partial application of the function </h3><br>  Consider as an example the currying and partial application of the function and compare the implementation on Kotlin and C #. <br>  Some people sometimes confuse (and I did some time ago) the terms <i>currying</i> and <i>partial use of a function</i> and use them interchangeably.  Both currying and partial application are ways to convert one kind of function into another. <br><br><h4>  Partial application of the function </h4><br>  Partial application takes a function with N parameters and a value for one of these parameters and returns a function with N-1 parameters, such that, when called, it will collect all the necessary values ‚Äã‚Äã(the first argument passed to the function of the partial application and the rest N-1 arguments passed to the return function).  Thus, these two calls must be equivalent to a method with three parameters.  In C #, delegates will be used for this.  Of course, they are not a complete replacement for higher-order functions, but more than enough to demonstrate. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Int32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Int32 a, Int32 b, Int32 c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c; } <span class="hljs-comment"><span class="hljs-comment">//  ApplyPartial             static Func&lt;T2, T3, TResult&gt; ApplyPartial&lt;T1, T2, T3, TResult&gt; (Func&lt;T1, T2, T3, TResult&gt; function, T1 arg1) { return (b, c) =&gt; function(arg1, b, c); } static Func&lt;T3, TResult&gt; ApplyPartial&lt;T2, T3, TResult&gt; (Func&lt;T2, T3, TResult&gt; function, T2 arg2) { return (c) =&gt; function(arg2, c); } static Func&lt;TResult&gt; ApplyPartial&lt;T3, TResult&gt; (Func&lt;T3, TResult&gt; function, T3 arg3) { return () =&gt; function(arg3); } static void Main(string[] args) { Func&lt;Int32, Int32, Int32, Int32&gt; function = SampleFunc; Func&lt;Int32, Int32, Int32&gt; partial1 = ApplyPartial(function, 1); Func&lt;Int32, Int32&gt; partial2 = ApplyPartial(partial1, 2); Func&lt;Int32&gt; partial3 = ApplyPartial(partial2, 3); var resp = partial3(); //      Console.WriteLine(resp); Console.ReadKey(); } }</span></span></code> </pre><br>  Generalizations make the ApplyPatrial method look more complicated than it actually is.  The absence of higher order types in C # means that a method implementation is needed for each delegate we want to use.  For this, you may need an Action family. <br>  Sample Kotlin code: <br><pre> <code class="scala hljs">fun sampleFunc(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>, b: <span class="hljs-type"><span class="hljs-type">Int</span></span>, c: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c } fun f3(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>, b: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sampleFunc(a, b, <span class="hljs-number"><span class="hljs-number">3</span></span>) } fun f2(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1(a, <span class="hljs-number"><span class="hljs-number">2</span></span>) } fun f1(): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-comment"><span class="hljs-comment">//    - val sampleFunc = { a: Int, b: Int, c: Int -&gt; a + b + c } val f3 = { a: Int, b: Int -&gt; sampleFunc(a, b, 3) } val f2 = { a: Int -&gt; f3(a, 2) } val f1 = { -&gt; f2(1) } fun main(args: Array&lt;String&gt;) { println(f1()) // 6 }</span></span></code> </pre><br>  In Kotlin, as in C #, you need to create a separate function (object) to get a function with N-1 arguments.  The approaches are the same for languages, only in Kotlin it is more convenient to do this due to a more compact syntax. <br><br><h4>  Carring </h4><br>  While a partial application converts a function with N parameters into a function with N-1 parameters, applying one argument, currying decomposes the function into functions from one argument.  We do not pass any additional arguments to the Curry method, except for the function being transformed: <br><ul><li>  Curry (f) returns a function f1, such that ... </li><li>  f1 (a) returns the function f2, such that ... </li><li>  f2 (b) returns the function f3, such that ... </li><li>  f3 (c) causes f (a, b, c) </li></ul><br>  The implementation in C # will look like this: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Int32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Int32 a, Int32 b, Int32 c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;T1, Func&lt;T2, Func&lt;T3, TResult&gt;&gt;&gt; Curry&lt;T1, T2, T3, TResult&gt; (Func&lt;T1, T2, T3, TResult&gt; function) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a =&gt; b =&gt; c =&gt; function(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Func&lt;Int32, Int32, Int32, Int32&gt; function = SampleFunc; <span class="hljs-comment"><span class="hljs-comment">//    Func&lt;Int32, Func&lt;Int32, Func&lt;Int32, Int32&gt;&gt;&gt; f1 = Curry(function); Func&lt;Int32, Func&lt;Int32, Int32&gt;&gt; f2 = f1(1); Func&lt;Int32, Int32&gt; f3 = f2(2); Int32 result = f3(3); //     ... var curried = Curry(function); result = curried(1)(2)(3); Console.WriteLine(result); // 6 Console.ReadKey(); } }</span></span></code> </pre><br>  Code on Kotlin: <br><pre> <code class="scala hljs">fun curry(body: (a: <span class="hljs-type"><span class="hljs-type">Int</span></span>, b: <span class="hljs-type"><span class="hljs-type">Int</span></span>, c: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>): (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>): (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun(b: <span class="hljs-type"><span class="hljs-type">Int</span></span>): (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun(c: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = body(a, b, c) } } } <span class="hljs-comment"><span class="hljs-comment">//   fun curry(body: (a: Int, b: Int, c: Int) -&gt; Int) = fun(a: Int) = fun(b: Int) = fun(c: Int) = body(a, b, c) fun main(args: Array&lt;String&gt;) { val f = curry { a: Int, b: Int, c: Int -&gt; a + b + c } val response = f(1)(1)(1) println(response) }</span></span></code> </pre><br><h3>  Inline function </h3><br>  The use of higher functions leads to overhead.  Memory allocation, on objects of functions, and also the subsequent cleaning.  In many cases, this kind of cost can be eliminated by substituting lambda expressions.  Consider a function that accepts a function as parameters, accepts a lock object and functions, acquires a lock, performs functions, and removes the lock: <br><pre> <code class="scala hljs">fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; lock(lock: <span class="hljs-type"><span class="hljs-type">Lock</span></span>, body: () -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> { lock.lock() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { lock.unlock() } }</code> </pre><br>  However, when you call, the object is created.  Instead of creating an object, the compiler may insert the following code: <br><pre> <code class="scala hljs">l.lock() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { l.unlock() }</code> </pre><br>  To force the compiler to do this, you need to add an inline modifier in the method declaration: <br><pre> <code class="scala hljs">inline fun lock&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;(lock: <span class="hljs-type"><span class="hljs-type">Lock</span></span>, body: () -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  However, you should not embed large functions, this can affect performance.  If there is a need to embed not all functions, you can add the noinline modifier: <br><pre> <code class="scala hljs">inline fun foo(inlined: () -&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span>, noinline notInlined: () -&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><br><h3>  Conclusion... </h3><br>  Kotlin is quite an interesting language, which is a pleasure to learn.  I like its compact syntax and the wide possibilities it provides.  Separate merit is worth mentioning the fact that it can be used together with Java in one project, which is also quite interesting and gives greater flexibility when creating a project.  This language allows you to quickly develop a program and, moreover, to make it quite beautiful.  Similar syntax with the same C # makes it easier to master, and more pleasant.  Therefore, if someone suddenly wants to switch to the Java platform from the .NET platform, this language will probably leave a pleasant impression. <br><br>  PS an interesting opinion about this language as Java-programmers, and C #.  Would you use Kotlin in your projects? </div><p>Source: <a href="https://habr.com/ru/post/281759/">https://habr.com/ru/post/281759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281747/index.html">Aggregate functions in dplyr</a></li>
<li><a href="../281749/index.html">Test lab v.9 - countdown</a></li>
<li><a href="../281751/index.html">Is RemoteApp vulnerable?</a></li>
<li><a href="../281755/index.html">Unicode character properties in V8 regular expressions</a></li>
<li><a href="../281757/index.html">Configuring the VPN router TP-Link TL-ER6020 to work with 3CX Phone System</a></li>
<li><a href="../281763/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 27. "Web War One"</a></li>
<li><a href="../281765/index.html">Sphere: how to monitor billions of kilowatt-hours</a></li>
<li><a href="../281767/index.html">Generating shaders GLSL, HLSL, Metal</a></li>
<li><a href="../281769/index.html">Explanation of the branching experiment, or philosophical research on benchmarks in vacuum and in ... reality</a></li>
<li><a href="../281771/index.html">The digest of interesting materials for the mobile developer # 149 (April 11-17)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>