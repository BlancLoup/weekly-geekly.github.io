<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32, C ++ and FreeRTOS. Development from scratch. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Not so long ago, my department encountered the difficulty of finding new software engineers for embedded software development. Experien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32, C ++ and FreeRTOS. Development from scratch. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Not so long ago, my department encountered the difficulty of finding new software engineers for embedded software development.  Experienced and intelligent did not like the level of wages, and the young simply do not exist in our city.  Therefore, under the patronage of our glorious global company headquartered somewhere in St. Louis, we first began to recruit students for internship, and then we decided to go the other way and do two whole software development courses, and there we could choose the most ‚Äúintelligent‚Äù if you need new employees.  It is much cheaper and allows you to reach the maximum number of applicants. <br>  I digress a bit from the topic, I myself programmed the last time a long time ago, and generally more on C #, and the last global project on a microcontroller (PIC16 in C language) was made back in 2007. <br>  Therefore, I had to deal with modern microcontrollers, the C ++ language and the real-time operating system. <br>  Of course, all our projects are already using RTOS and are being written in C ++, but as a developer, I don‚Äôt take part in them, but I‚Äôm involved in <s>parasitism in</s> managing projects for developing such software. <br><br><h4>  Selection </h4><br>  I had time for everything about everything for 1 month.  From the beginning of June 2015 to the beginning of July 2015, because then I was going on vacation, and after the holidays I was usually full of work.  We had to do everything quickly and clearly. <br>  Having a little consultation with colleagues, I found out that the fashionable direction of ARM Cortex is different cores and you can order Olimex STM32P152 from available debug boards that cost $ 25.  They came very quickly - 6 boards for about 2000 rubles.  It is worth noting that these fees were purchased by us for the university, where the course itself will take place. <br><img src="https://habrastorage.org/files/32f/807/a31/32f807a31f76405380da7e50d996a805.png" alt="image"><br><a name="habracut"></a><br><h4>  Baseline: Objective </h4><br>  First of all, it was necessary to determine what information and what to give to students.  For myself, I decided that the main goal would be to show the entire software development process for devices using the STM32 microprocessor, the C ++ programming language and the FreeRTOS real-time operating system, ranging from requirements and architecture development to coding. <br><br><h4>  Baseline: Limitations </h4><br>  So, the task of our project is to create a demo application for the Olimex STM32P152 debugging board, according to coding standards (which I will not give here) written in C ++ using FreeRTOS. <br>  The application should be clear, simple and unobtrusive, without abstruse constructions inherent in the C ++ language.  The architecture should be described in the UML language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Baseline: Functional Requirements </h4><br>  SR0: The device should measure three parameters (have three variables): <u>microprocessor temperature</u> , <u>voltage VDDA</u> , <u>voltage from a variable resistor</u> <br>  SR1: The device should display the value of these variables on the <b>indicator</b> . <br>  SR2: The unit of measurement for the <u>microprocessor temperature</u> is degrees Celsius, for the other parameters it is volts. <br>  SR3: When you press <b>button 1</b> , the <b>display</b> should show a screen with the next variable to be measured, <br>  SR4: When you press <b>button 1,</b> <b>LED 1</b> must change its state <br>  SR5: When you press <b>button 2</b> , the <b>display</b> should change the display mode of variables from constantly showing the variable to consecutive (changing screens every 1.5 seconds) when you next press from consecutive to constant, <br>  SR6: When you press <b>button 2,</b> <b>LED 2</b> should change its state. <br>  SR7: <b>LED 3</b> should blink once every 1 second. <br><br>  In short - these are all the requirements for this task. <br>  It is clear that the task is not so difficult, but allows you to almost completely show the whole process of developing any device for the given requirements. <br><br><h4>  Development: getting started </h4><br>  And so the requirements are ready, you can proceed.  Let's start with the infrastructure.  First, I created a project in IAR for C ++, there is nothing new here.  This article describes everything <a href="http://chipspace.ru/cplusplus/">Creating a C ++ project in IAR for STM32</a> .  We will not stop here. <br><br><h4>  Development: wrapper for FreeRTOS </h4><br>  Since I was going to use C ++, and the operating system is written in C, I need C ++ wrapper for FreeRTOS.  Ideally, you could write a wrapper so that it fits most RTOSs, and then in projects you could not depend on the type of RTOS, but I didn‚Äôt bother with that and in this situation I chose only those functions of the operating system that I need , and only wrapped them, stupidly copying the signature of methods. <br>  A static static method void run (void * parameters) has also been added;  This is exactly the function, the pointer to which will be used when creating the task. <br>  In order to be able to call the class instance method in the task, an iActiveObject interface was made with the virtual function virtual void run (void) = 0;  and a global attribute for storing a pointer to a task. <br><div class="spoiler">  <b class="spoiler_title">iActiveObject.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   class iActiveObject { public: virtual void run(void) = 0; void *taskHandle; };</span></span></span></span></code> </pre> <br></div></div><br>  Any object that wants to be a task (active) must inherit this interface and implement the run () method.  A pointer to this object is passed to the run () function of the wrapper as a parameter. <br>  On paper, it looked like this: <br><img src="https://habrastorage.org/files/a31/9d5/42a/a319d542a52e4064a1cbf6e179b403b5.png" alt="image"><br>  I entrusted the task of implementing this picture to a gifted young specialist who successfully coped with it and in a couple of days issued such an empty working draft in IAR 6.50 <br>  <a href="https://yadi.sk/d/ku1eZwzDhfaBk">Empty project with FreeRTOS wrapper in IAR 6.50</a> <br>  An improved version of the wrapper can be taken from this article <a href="https://habr.com/post/420467/">C ++ wrapper for "all" Real-Time Operating Systems for Cortex M4</a> <br><br><h4>  Development: General Architecture </h4><br>  While the young specialist was doing the wrapper, I was wondering about the software architecture.  For myself, I selected 3 packages: <br>  AHardware - a package containing classes for the operation and control of equipment (LEDs, Indicator, ADC, and so on) <br>  Application - a package containing application-level classes and knowing nothing about iron, so it can be portrayed to any microcontroller without modification, well, provided that the wrapper is not developed by a human snowflake.  And in this case it is not so :) <br><img src="https://habrastorage.org/files/7d6/53a/05e/7d653a05e4b446b7891ed0263748c094.png" alt="image"><br>  FreeRTOS - package with ported OSes and a wrapper for it. <br>  Having drawn a little, the following picture turned out: <br><img src="https://habrastorage.org/files/37b/99a/ac1/37b99aac1dcf44c6b665c4432696fc8b.png" alt="image"><br><br><h4>  Development: Blinking LED </h4><br>  As usual, development begins with the most interesting and challenging :) - implementing the SR7 requirement: <b>LED 3</b> should blink every 1 second, it seemed to me exactly the task, having mastered which I can move forward. <br>  The first thing was to deal with the ports of the microcontroller and the frequency setting.  And I must say that over the past 8 years since my last microcontroller project, a lot has changed and it seemed like nothing at all.  It was necessary to read the data sheet for these sections very carefully and in the end to understand that everything is rather trivial, just there are many more settings (than in PIC 16). <br>  As a result, the entire port configuration was dropped in __low_level_init ().  And in general, the entire configuration of the hardware, which will not be changed in the course of the program, I put in this function.  It is called before main (), before initializing all variables and executing the constructors of global class instances. <br><div class="spoiler">  <b class="spoiler_title">Configuring ports for LEDs</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  - //PE.10, PE.11 -  stat3  stat4 //PA.4, PA.5 -  stat1  stat 2 //  PE.10, PE.11, PA.4, PA.5  , c.174 CD00240194.pdf GPIOE-&gt;MODER |= GPIO_MODER_MODER10_0; GPIOE-&gt;MODER |= GPIO_MODER_MODER11_0; GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; GPIOA-&gt;MODER |= GPIO_MODER_MODER5_0;</span></span></code> </pre><br></div></div><br>  Well, the iron is set up and I sat down again for drawing, this time - the class of control of the LEDs.  After half an hour it turned out this: <br><img src="https://habrastorage.org/files/41a/acf/44c/41aacf44ccfc4d21b4f9cc76fc3b15ef.png" alt="image"><br>  And then the realization of this miracle: <br><div class="spoiler">  <b class="spoiler_title">LedsDriver.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   tU8 #define LEDS_NUMBER 4 class cLedsDriver { public: explicit cLedsDriver(void); void ledOn(const tU8 led); void ledOff(const tU8 led); void ledToggle(const tU8 led); private: static tPort ledsPort[LEDS_NUMBER]; static const tU16 ledsPin[LEDS_NUMBER]; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">ledsdriver.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ledsdriver.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     tLeds #include &lt;stm32l1xx.h&gt; // STM32 #include "susuassert.h" // for ASSERT #include "types.h" //   tPort, tU16, tU8 #include "bitutil.h" //      #define LED1_PIN GPIO_OTYPER_ODR_4 #define LED1_PORT GPIOA #define LED2_PIN GPIO_OTYPER_ODR_5 #define LED2_PORT GPIOA #define LED3_PIN GPIO_OTYPER_ODR_10 #define LED3_PORT GPIOE #define LED4_PIN GPIO_OTYPER_ODR_11 #define LED4_PORT GPIOE tPort cLedsDriver::ledsPort[LEDS_NUMBER] = {LED1_PORT, LED2_PORT, LED3_PORT, LED4_PORT}; const tU16 cLedsDriver::ledsPin[LEDS_NUMBER] = {LED1_PIN, LED2_PIN, LED3_PIN, LED4_PIN}; /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cLedsDriver::cLedsDriver(void) { } /******************************************************************************* * Function: ledOn * Description:    ******************************************************************************/ void cLedsDriver::ledOn(const tU8 led) { ASSERT(led &lt; LEDS_NUMBER); SETBIT(this-&gt;ledsPort[led]-&gt;ODR, this-&gt;ledsPin[led]); } /******************************************************************************* * Function: ledOff * Description:    ******************************************************************************/ void cLedsDriver::ledOff(const tU8 led) { ASSERT(led &lt; LEDS_NUMBER); CLRBIT(this-&gt;ledsPort[led]-&gt;ODR, this-&gt;ledsPin[led]); } /******************************************************************************* * Function: ledToggle * Description:     ******************************************************************************/ void cLedsDriver::ledToggle(const tU8 led) { ASSERT(led &lt; LEDS_NUMBER); TOGGLEBIT(this-&gt;ledsPort[led]-&gt;ODR, this-&gt;ledsPin[led]); }</span></span></span></span></code> </pre><br></div></div><br>  Now again you need to draw a little to make the class of control of the logic of the LEDs - class cLedsDirector.  This will be the active class, i.e.  its run () function will be launched in the task.  As I wrote above, all my active classes must inherit the iActiveObject interface.  Therefore, the drawing does not look difficult either. <br><img src="https://habrastorage.org/files/0ef/6c6/025/0ef6c6025c764df0a841f48bb71c38c2.png" alt="image"><br>  Again, the implementation is also simple and a human snowflake, like me: <br><div class="spoiler">  <b class="spoiler_title">ledsdirector.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ledsdriver.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// cLedsDriver #include "iactiveobject.h" // iActiveObject typedef enum { LD_led1 = 0, LD_led2 = 1, LD_led3 = 2, LD_led4 = 3, LD_none = 4 } tLeds; class cLedsDirector: public iActiveObject { public: explicit cLedsDirector(void); void run(void); private: cLedsDriver* pLedsDriver; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">ledsdirector.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ledsdirector.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "frtoswrapper.h" //  oRTOS #include "types.h" // l  #define LED_DELAY (tU32)500/portTICK_PERIOD_MS /******************************************************************************* * Function: constructor * Description:    cLedsDriver ******************************************************************************/ cLedsDirector::cLedsDirector(void) { this-&gt;pLedsDriver = new cLedsDriver(); } /******************************************************************************* * Function: runTask * Description:   . led3   ******************************************************************************/ void cLedsDirector::run(void) { for(;;) { oRTOS.taskDelay(LED_DELAY); this-&gt;pLedsDriver-&gt;ledToggle(LD_led3); } }</span></span></span></span></code> </pre><br></div></div><br>  Well, everything is written, it remains just a little - to create an instance of the cLedsDirector class and the task in main () and check how it all works. <br><div class="spoiler">  <b class="spoiler_title">main () function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEDSDIRECTOR_STACK_SIZE configMINIMAL_STACK_SIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEDSDIRECTOR_PRIORITY (tU32)2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      ,  oRTOS   //     RTOS ,  -    //  ,     cRTOS oRTOS; .... void main(void) { cLedsDirector *pLedsDirector = new cLedsDirector(); oRTOS.taskCreate(pLedsDirector, LEDSDIRECTOR_STACK_SIZE, LEDSDIRECTOR_PRIORITY, "Leds"); oRTOS.startScheduler(); }</span></span></span></span></code> </pre><br></div></div><br>  We start on a payment, and about a miracle - works from the first.  So I did everything right.  There is an implementation of the first requirement.  We will go further.  For now let's save the project <br>  <a href="https://yadi.sk/d/Et1nxVnXhfeJh">Project blinking LED in IAR 6.50</a> <br><br><h4>  Development: Buttons </h4><br>  The LEDs are working, now you can realize the requirements of the SR6: When you press the <b>button 2, the</b> <b>LED 2</b> should change its state and SR4: When you press the <b>button 1, the</b> <b>LED 1</b> should change its state. <br>  I decided to do the buttons without interruptions, and in general I will not use interruptions in this project, although nothing prohibits the use of interrupts, but I just decided so. <br>  According to the procedure, draw the class cButtonsDriver. <br><img src="https://habrastorage.org/files/4f2/997/91b/4f299791b139478985e13ba43e85610f.png" alt="image"><br>  Here I must say one thing: the first time my buttons did not work, or rather only one earned.  The second did not work.  Having understood, I realized that one button is pulled to zero, and the second to one.  Therefore, pressing is determined from them in different ways.  To define a click, I introduced the additional attribute -buttonsTrigger (which was not originally in the architecture).  It shows by what value the button is considered to be pressed by 0 or 1. And then after that, everything began to work like a clock. <br>  The implementation is very simple. <br><div class="spoiler">  <b class="spoiler_title">buttonsdriver.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    tU16  tU8 #define BUTTONS_NUMBER 2 typedef enum { BS_buttonNotPressed = 0, BS_buttonPressed = 1 } tButtonState; class cButtonsDriver { public: explicit cButtonsDriver(); tButtonState getButtonState(const tU8 button); private: static tPort buttonsPort[BUTTONS_NUMBER]; static const tU16 buttonsPin[BUTTONS_NUMBER]; static const tBoolean buttonsTrigger[BUTTONS_NUMBER]; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">buttonsdriver.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"buttonsdriver.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     tLeds #include &lt;stm32l1xx.h&gt; // STM32 #include "susuassert.h" //for ASSERT #include "types.h" //  tPort, tU16, tU8 #define BUTTON1_PIN GPIO_OTYPER_IDR_13 #define BUTTON1_PORT GPIOC #define BUTTON2_PIN GPIO_OTYPER_IDR_0 #define BUTTON2_PORT GPIOA tPort cButtonsDriver::buttonsPort[BUTTONS_NUMBER] = {BUTTON1_PORT, BUTTON2_PORT}; const tU16 cButtonsDriver::buttonsPin[BUTTONS_NUMBER] = {BUTTON1_PIN, BUTTON2_PIN}; //   ,     0,   1 const tBoolean cButtonsDriver::buttonsTrigger[BUTTONS_NUMBER] = {FALSE, TRUE}; /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cButtonsDriver::cButtonsDriver() { } /******************************************************************************* * Function: getButtonState * Description:   ,    ******************************************************************************/ tButtonState cButtonsDriver::getButtonState(const tU8 button) { tButtonState eState = BS_buttonNotPressed; ASSERT(button &lt; BUTTONS_NUMBER); //     ,    1,   0, //    ,    ,   //            //      . tBoolean isLogicalZero = !(this-&gt;buttonsPort[button]-&gt;IDR &amp; this-&gt;buttonsPin[button]); if(isLogicalZero ^ this-&gt;buttonsTrigger[button]) { eState = BS_buttonPressed; } return eState; }</span></span></span></span></code> </pre><br></div></div><br>  Well, with the driver done, now we need to think about the task, which will periodically poll the buttons. <br>  The picture looks very similar to the active class for LEDs, and it is true, why reinvent the wheel: <br><img src="https://habrastorage.org/files/c90/2d9/5fb/c902d95fb01c4536894471f0f433dbc2.png" alt="image"><br><br>  Pressing the button should somehow notify those tasks that need to know about it.  You can do this in several ways: Through events, either use a queue, or use the latest FreeRTOS notification property (Notify). <br>  Let's analyze the requirements.  At the touch of a button, we should do two things: First, change LEDs 1 and 2 to change their states, and second, the display mode and screens should change on the indicator.  The problem is that the queues and events can be taken only one task, after which the second does not know about it, and then the architecture will be complicated.  We'll have to redirect events, let's say that the LED task will have to redirect the event or the queue from the buttons to the Indicator task.  Something in this did not suit me, and I decided to make a notification of a specific task.  That is, our task of polling the buttons after determining the click will only notify those tasks that need these events. <br>  For this, an array of pTaskToNotify pointers was added to the tasks that need to be notified. <br>  Now implementation: <br><div class="spoiler">  <b class="spoiler_title">buttonscontroller.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   tU32 #include "iactiveobject.h" // iActiveObject #include "buttonsdriver.h" // cButtonsDriver #include "frtosWrapper.h" //  tTaskHandle typedef enum { BT_button1 = 0, BT_button2 = 1, BT_none = 2 } tButtons; class cButtonsController: public iActiveObject { public: explicit cButtonsController(const tTaskHandle *pTaskToNotify, const tU32 countOfNotifiedTask); tButtons getPressedButton(void) const { return pressedButton; }; void run(void); private: cButtonsDriver* pButtonsDriver; tButtons getButton(void); tButtons pressedButton; const tTaskHandle *pTaskToNotify; tU32 countOfNotifiedTask; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">buttonscontroller.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"buttonscontroller.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "susuassert.h" //  ASSERT #include "types.h" //   tPort, tU16, tU8 #include "bitutil.h" //      #define BUTTON_TASK_DELAY (tU32) 50/portTICK_PERIOD_MS #define NEXT_PRESS_DELAY (tU32) 500/portTICK_PERIOD_MS /******************************************************************************* * Function: constructor * Description:         *  .     . ******************************************************************************/ cButtonsController::cButtonsController(const tTaskHandle *pTaskToNotify, const tU32 countOfNotifiedTask) { ASSERT(pTaskToNotify != NULL); this-&gt;pButtonsDriver = new cButtonsDriver(); this-&gt;pTaskToNotify = pTaskToNotify; this-&gt;countOfNotifiedTask = countOfNotifiedTask; } /******************************************************************************* * Function: run * Description:        *   ******************************************************************************/ void cButtonsController::run(void) { tRtosStatus eStatus = RS_fail; tButtons eButtonPreviousState = BT_none; tButtons eButtonCurrentState = BT_none; const tTaskHandle *pTaskHandle; tU32 i = 0; for(;;) { eButtonPreviousState = this-&gt;getButton(); if (eButtonPreviousState != BT_none) { //     oRTOS.taskDelay(BUTTON_TASK_DELAY); eButtonCurrentState = this-&gt;getButton(); if (eButtonPreviousState == eButtonCurrentState) { pTaskHandle = this-&gt;pTaskToNotify; i = 0; //   ,       while ((pTaskHandle != NULL) &amp;&amp; (i != countOfNotifiedTask)) { eStatus = oRTOS.taskNotify(*(pTaskHandle), (tU32)eButtonCurrentState, eSetValueWithOverwrite); if(eStatus == RS_fail) { ;//  } pTaskHandle++; i++; } //        0.5  oRTOS.taskDelay(NEXT_PRESS_DELAY); } } oRTOS.taskDelay(BUTTON_TASK_DELAY); } } /******************************************************************************* * Function: getPressedButton * Description:      ******************************************************************************/ tButtons cButtonsController::getButton(void) { tButtons eButton = BT_none; if (BS_buttonPressed == this-&gt;pButtonsDriver-&gt;getButtonState(BT_button1)) { eButton = BT_button1; } else if (BS_buttonPressed == this-&gt;pButtonsDriver-&gt;getButtonState(BT_button2)) { eButton = BT_button2; } this-&gt;pressedButton = eButton; return eButton; }</span></span></span></span></code> </pre><br></div></div><br>  Now in main you need to create a task list for the alert and a new task for polling the buttons: <br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stm32l1xx.h&gt; //  STM2 #include "ledsdirector.h" //   cLedsDirector #include "buttonscontroller.h" //   cButtonsController #include "types.h" //    #include "frtoswrapper.h" //  cRtos #define LEDS_TASK_HANDLE_INDEX 0 #define BUTTON_TASKS_NOTYFIED_NUM 1 #define LEDSDIRECTOR_STACK_SIZE configMINIMAL_STACK_SIZE #define LEDSDIRECTOR_PRIORITY (tU32)2 #define BUTTONSCONTROLLER_STACK_SIZE 256//configMINIMAL_STACK_SIZE #define BUTTONSCONTROLLER_PRIORITY (tU32)3 //      ,  oRTOS   //     RTOS ,  -    //  ,     :) cRTOS oRTOS; .. void main( void ) { // ButtonControllera       // ,    .       //,    static tTaskHandle tasksToNotifyFromButton[BUTTON_TASKS_NOTYFIED_NUM]; cLedsDirector *pLedsDirector = new cLedsDirector(); oRTOS.taskCreate(pLedsDirector, LEDSDIRECTOR_STACK_SIZE, LEDSDIRECTOR_PRIORITY, "Leds"); tasksToNotifyFromButton[LEDS_TASK_HANDLE_INDEX] = pLedsDirector-&gt;taskHandle; cButtonsController *pButtonsController = new cButtonsController(tasksToNotifyFromButton, BUTTON_TASKS_NOTYFIED_NUM); oRTOS.taskCreate(pButtonsController, BUTTONSCONTROLLER_STACK_SIZE, BUTTONSCONTROLLER_PRIORITY, "Buttons"); oRTOS.startScheduler(); }</span></span></span></span></code> </pre><br></div></div><br>  We start, check and everything works - it‚Äôs just amazing :) That's what it means at first to draw. <br>  As usual we save the project: <br>  <a href="https://yadi.sk/d/GO8wDJF2hfm3f">Design Buttons and LEDs for IAR 6.50</a> <br>  An improved project with an example of a new wrapper can be found here: <br>  <a href="https://yadi.sk/d/kgp_-bz_3aKnQr">Project at IAR 8.30</a> <br>  And the project began to look like this: <br><img src="https://habrastorage.org/files/ad3/818/415/ad3818415a3c4a22bb870004156865a6.png" alt="image"><br><br>  So, for some three days I implemented three requirements - not a bad speed, considering that I have only 7 of them. And having decided that for the remaining 2.5 weeks I‚Äôll do it for sure, I went to the lake for two days. <br>  As it turned out later, in vain I was so optimistic about things, but this is already in the second part. </div><p>Source: <a href="https://habr.com/ru/post/261807/">https://habr.com/ru/post/261807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261787/index.html">Remote injection of Wi-Fi frames</a></li>
<li><a href="../261789/index.html">And do not you go to the clouds?</a></li>
<li><a href="../261799/index.html">Receive notifications from external services, or why Hooksler was made</a></li>
<li><a href="../261801/index.html">Introducing Nim: writing a console 2048</a></li>
<li><a href="../261803/index.html">Magic of tensor algebra: Part 4 - Dynamics of a point in a tensor statement</a></li>
<li><a href="../261811/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ167 (June 29 - July 4, 2015)</a></li>
<li><a href="../261813/index.html">Ford recalls almost 500 thousand cars because of a bug in software</a></li>
<li><a href="../261817/index.html">Creating a Worker from another domain</a></li>
<li><a href="../261819/index.html">Unpleasant aspects of working with Images.xcassets: size and memory</a></li>
<li><a href="../261823/index.html">STM32, C ++ and FreeRTOS. Development from scratch. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>