<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Client application security: practical tips for Front-end developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, the majority of BlackHat hacker attacks are aimed at compromising the server data of web applications and services. At the same time, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Client application security: practical tips for Front-end developer</h1><div class="post__text post__text-html js-mediator-article"><p>  As you know, the majority of BlackHat hacker attacks are aimed at compromising the server data of web applications and services.  At the same time, the client part of the attack today is not less.  According to the dry definition, any attack is a set of measures by the hacker aimed at the network and data transfer, data and their substitution, infrastructure and technical features of the implementation of a web application.  Therefore, international companies require development engineers to take a more responsible and careful approach to client application security. </p><br><p>  Using the example of my project, I will talk about how client applications are attacking today and how you can avoid these threats. </p><a name="habracut"></a><br><img alt="Top 10 threats for 2013 - 2017" src="https://habrastorage.org/webt/ys/zg/d7/yszgd7tqw75npl5bx9pliitikte.jpeg"><br>  <i>Top 10 threats for the years 2013 - 2017.</i> <br><br><p>  As you can see, among the main threats are injections, error handling, authentication bypass, and insecurity of sensitive data.  The threat of using components with known vulnerabilities is still relevant.  New threats also appeared: hacking of the access control mechanism, unsafe deserialization and data serialization, insufficiently detailed logging and monitoring. </p><br><p>  In 2001, Marc Kerfi and Dennis Gruvz founded the <a href="https://www.owasp.org/index.php/Main_Page">OWASP</a> (Open Web Application Security Project).  This is an international OpenSource project for sharing experience on combating vulnerabilities in client applications, in which a huge number of application security engineers take part.  The OWASP community fills the portal with a variety of vulnerability information articles, training materials, tools for testing and repelling attacks.  It describes the real attacks, reveals their aspects and describes what needs to be done to prevent threats. </p><br><p>  To understand what threats are dangerous for the project, it is necessary to thoroughly test it.  To do this, the network has applications, frameworks and online services that automatically identify certain vulnerabilities.  For local testing, I recommend using applications and frameworks, and for testing projects in operation, it is very useful to add online services. </p><br><img src="https://habrastorage.org/webt/zh/c7/ll/zhc7lln_b43msp-lkz7ah0iapmw.jpeg"><br><br><p>  But even if the testing tools did not tell you in the reports about significant vulnerabilities (which is unlikely), pay attention to storing sensitive data in the version control system, building the application, authentication mechanism, password hashing algorithm, encryption functions and monitoring the entire web application.  In this case, it is better to play it safe and not blindly trust automatics. </p><br><h2>  Git </h2><br><p>  First, let's talk about sensitive data in Git.  In the ideal case, a separate secret storage is allocated for storing sensitive data.  From it, when assembling for commissioning, confidential data is tightened and stitched into the application.  Today, Hashicorp Vault, Keywhiz, Docker secrets, Azure Key Vault and several others are popular. </p><br><p>  But what if you do not have such a repository?  You can use tools to encode and hide files with secrets that will enhance the capabilities of version control systems. </p><br><p> The first thing that comes to mind is the BlackBox universal solution.  It can be used with any version control system, for example, Mercurial, Git, etc.  In addition, there are two extensions for Git: git-crypt and git-secret.  I recommend using the second one, because it seemed to me most convenient to use and more understandable in terms of description in official documentation.  After installing the git-secret, you need to initialize it in the Git-repository.  Don't forget to specify the extension used in the <b>.gitattributes</b> file.  Next, configure the availability of secrets: determine the users you want to provide access to sensitive data.  Then add files with sensitive data and <code>git-secret-hide</code> them through <code>git-secret-hide</code> .  You can get hidden files through <code>git-secret-reveal.</code> </p><br> <code>brew install git-secret              //  <br> git secret init                      //  <br> git secret tell your@gpg.email       &amp;nbsp//   <br> git secret add &lt;files...&gt;             //   <br> git secret hide                      &amp;nbsp//   <br> git secret reveal                    &amp;nbsp//    <br></code> <br><h2>  Webpack </h2><br><p>  Another way to eliminate threats is to configure the webpack correctly.  To protect against XSS, XEE and similar attacks, you need to think about adhering to the CORS (Cross-origin resource sharing) and CSP (Content Security Policy) policies.  In both cases, it is important to observe the headers in order to verify the authenticity of certain scripts that are used in the project.  Browsers have mechanisms for verifying the reliability of one or another source, for example, Safari will issue warnings at every step if CORS and CSP are configured incorrectly. </p><br><p>  There are two ways to comply with CORS and CSP.  The first is to configure the headers of the response to requests in the server part.  The second is to prescribe both policies through meta tags and attributes.  The latter method is recommended if you have lazy back-end developers, they are always busy and they are not up to security policies.  Meta tags can be written immediately when building the application.  This will help us with such plugins as html-webpack-plugin, html-webpack-exclude-assets-plugin, script-ext-html-webpack-plugin, csp-html-webpack-plugin and crypto.  In addition, if you have third-party resources in the project (for example, links to external fonts used in CSS; resources loaded from CDN, etc.), I recommend using webpack-subresource-integrity-plugin.  Thus, you will inform the browser that the loaded resources in the script are reliable, there are no implementations in them, they are whole and uncorrupted.  And even if someone has introduced malicious data into the resource, and you have loaded it, you should be prepared for this and secure your project from such threats. </p><br><p>  I want to pay <b>special attention</b> to the sequence in which and how instances of classes for plugins are created.  The sequence must be exactly this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SHA256 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> CRYPTO.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update( str, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>).digest(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sha256Str = SHA256( <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() ); [‚Ä¶] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackPlugin({   <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'public/index.html'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptExtHtmlWebpackPlugin({    <span class="hljs-attr"><span class="hljs-attr">custom</span></span>: [{           <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>,           <span class="hljs-attr"><span class="hljs-attr">attribute</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce'</span></span>,           <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce-'</span></span> + sha256Str    }] }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackExcludeAssetsPlugin(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CspHtmlWebpackPlugin({    <span class="hljs-string"><span class="hljs-string">'base-uri'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'object-src'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'none\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'script-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'unsafe-eval\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'nonce-'</span></span> + sha256Str + <span class="hljs-string"><span class="hljs-string">'\''</span></span>],    <span class="hljs-string"><span class="hljs-string">'style-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'unsafe-inline\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>] }, {    <span class="hljs-attr"><span class="hljs-attr">devAllowUnsafe</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,    <span class="hljs-attr"><span class="hljs-attr">hashingMethod</span></span>: <span class="hljs-string"><span class="hljs-string">'sha256'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SriPlugin({    <span class="hljs-attr"><span class="hljs-attr">hashFuncNames</span></span>: [<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, <span class="hljs-string"><span class="hljs-string">'sha384'</span></span>],    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), [‚Ä¶]</code> </pre><br><p>  Then, when assembling, the meta tag <code>http-equiv=content-security-policy</code> appears in the <code>&lt;hed&gt;</code> tag.  The <code>content</code> attribute will contain directives that tell which scripts and resources can be trusted. </p><br><p>  The <code>base-uri</code> directive shows which base URL is used to download scripts, CSS, images and other things. </p><br><p>  Objects are usually not loaded, so in the directive <code>object-sr</code> c put <code>none</code> . </p><br><p>  The <code>script-src</code> directive applies to JS scripts. </p><br><p>  Do not forget to prescribe each type attribute <code>nnce-&lt;hshVlue&gt;</code> .  And the hash needs to be calculated using the SHA256 or SHA512 algorithm. </p><br><p>  As for the <code>style-src</code> directive, our project has a feature: we use styled-components to prescribe CSS for each component and isolate them from each other.  And therefore, it is necessary to indicate that we use <code>unsafe-inline</code> and <code>self</code> in <code>style-src</code> , otherwise the styled-components will fall off. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/9x/di/ny/9xdinyh5msrmdszkkdayka1tqya.jpeg"><br><br><p>  For the <code>script</code> tag, the attributes will be automatically set <code>nnce-&lt;hshVlue&gt;</code> , <code>integrity</code> and <code>cross-origin</code> .  They tell the browser that resources are being pulled from reliable sources.  Otherwise, if the browser sees that the resource does not correspond to CSP or CORS, then it simply does not load this script or CSS file, but in the console it will write something like: <i>‚ÄúPay attention to this script, to this line where you initialize him.</i>  <i>Look, you have something wrong! "</i> . </p><br><p>  The <a href="https://developer.mozilla.org/">MDN</a> , OWASP and <a href="https://www.w3.org/">W3C</a> documentation has recommendations on how to enforce CSP and CORS policies.  In addition, any penetration testing toolkit will report compliance with the CORS and CSP rules in the project.  Any framework or tool that will conduct automatic testing of the project will indicate shortcomings. </p><br><h2>  User Authentication </h2><br><p>  We use OpenID Connect and the Kerberos protocol.  A fairly common standard is OpenID used to authenticate external users. </p><br><p>  Kerberos is more suitable for the internal network, in the bank it is used for automatic authentication of employees.  Suppose there is a local machine on which an employee of the organization works.  He once authenticated on this machine, and then he will not need to enter his login and password again: the employee logs into any application and the system authenticates it immediately.  Kerberos has fine tuning for the local machine, and this is difficult because you have to configure it for <b>each computer and each browser.</b>  If Internet Explorer normally tightens default settings, and Chrome tightens IE settings, then Firefox has to be configured separately.  Safari on MacOS X itself will find the settings, and for Safari on Windows you will need to specify them manually. </p><br><p>  You need to check your application in all browsers, whether it works everywhere as needed.  For example, if I work on Windows, I put Safari locally and test my project in it, and if I work on a Mac, I raise Windows on a virtual machine to drive the application on the corresponding browser versions. </p><br><p>  Authentication in modern applications can be implemented using the Passport.js and express-session packages, as well as the Auth0 SDK. </p><br><p>  If you are unable to develop an authentication service through OpenID Connect or any other protocol, then use a proxy layer, such as Auth0 and the like, so that authentication occurs through a third-party company that specializes in providing users with secure access to Internet resources. </p><br><p>  When we add an application to Node.js, I recommend using Passport.js, express-session, etc. packages on the server.  To ensure security on the client, we independently raise the component for authentication.  In the authentication form, do not forget to specify the autocomplete off attribute to exclude auto-completion of form fields. </p><br><h2>  Password Hashing </h2><br><p>  The OWASP website recommends not using password hashing mechanisms built into databases.  For this, it is better to use packages such as Argon2, PBKDF2, ccrypt and bcrypt.  In my practice, I use Argon2 - this is a wrapper for GCC, PGP / GPG, etc. algorithms, but it is required to install the GCC package first.  Argon2 use pattern: </p><br><br><pre> <code class="bash hljs">1.  GCC &gt;= 4.8 install $ brew install gcc</code> </pre> <br><pre> <code class="bash hljs">2.     - $ npm install -g node-gyp</code> </pre> <br><pre> <code class="bash hljs">3.   Argon2 $ npm install argon2</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ARGON <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; ARGON.generateSalt().then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">salt: string</span></span></span><span class="hljs-function">) =&gt;</span></span> {  ARGON.hash(<span class="hljs-string"><span class="hljs-string">'some-user-password'</span></span>, salt)    .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash : string</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Successfully created Argon2 hash:'</span></span>, hash);       <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> store the hash in the user database  }); }); argon2.verify( 'previously-created-argon-hash-here', 'some-user-password').then(() =&gt; {  console.log('Successful password supplied!');  // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> log the user in }).catch(() =&gt; {  console.log('Invalid password supplied!'); });</span></span></code> </pre> <br><h2>  Obfuscation </h2><br><p>  Obfuscation allows you to modify the code so that it can not be disassembled into its components.  After all, attackers - and not only they - very often use reverse engineering: the programmer takes a JS-file and begins to analyze the source code.  Thus, he can learn the methods used or understand the mechanism of the work of a script to inject malicious code.  Or use these mechanisms to hack a web application and conduct an invisible attack. </p><br><p>  Hackers do not climb on the rampage.  First, they conduct resource exploration, determine vulnerabilities and attack vector.  For example, they manipulate data or exploit vulnerabilities contained in transport protocols.  The attack vector can be directed to the vulnerabilities of one or another operating system; there are a lot of them in any UNIX system.  But vulnerabilities can only be exploited if the administrator has poorly configured security policies, such as incorrectly specifying URLs that go outside. </p><br><p>  So, reverse engineering is used for reconnaissance.  It is impossible to completely eliminate it, but it can be very difficult.  For this purpose, various obfuscators are used, in my case - javascript-obfuscator.  On its base, a webpack plugin was made - webpack-obfuscator.  Also for webpack created obfuscator-loader.  This package has recommended settings of different levels of paranoia: low, medium and high, they can be found on the official website.  If you use this obfuscator, then remember that it works very poorly with the minification mechanism built into the webpack.  Do not use minification and obfuscation together, otherwise the obfuscator can completely break the script code. </p><br><p>  In addition, obfuscator increases the volume of the script and its loading.  Here you need to decide for yourself: either you increase security, stability and reliability, but lose in convenience and speed;  or take care of speed, but forget about safety, about following any guidelines. </p><br><h2>  Logging and monitoring of threats </h2><br><p>  There is such a threat as using packages with known vulnerabilities.  Threat analyzers such as npm audit, Snyk and LGTM will help in such situations.  Npm audit is a standard utility that is built into npm, but you have to constantly call this command or come up with crutches.  Therefore, I advise you to use Snyk.  This project has its own database with vulnerabilities.  When you start checking, Snyk refers to this database and confidentially uploads the report to your Snyk project, which is inaccessible to outsiders.  True, you can check your project for free only 300 times, and when you check for each pre-commit, these 300 free attempts end very quickly.  Therefore, it is better to run the check on pre-push or pre-merge hooks. </p><br><p>  Man - the most important vulnerability of any system.  Therefore, be sure to check the project before starting to build the application, because even the source code may contain something malicious.  It is good when only one person has access to the project, but usually we work as teams.  And what if a ‚Äúwell-wisher‚Äù appeared who decided to leave the company ‚Äúbeautifully‚Äù and leave a trace behind him?  This, too, must be borne in mind. </p><br><p>  I recommend using the Snyk package from the very beginning of the project, and run the check from the console.  Everything is simple: after installation, set the username and password to the account, but the testing itself can be performed as follows: </p><br><ul><li>  After installing the dependency npm i snyk ‚ÄîD and specifying package.json ‚Äúsnyk‚Äù: true, run: </li></ul><br><pre> <code class="bash hljs">./node_modules/.bin/snyk wizard --dev</code> </pre> <br><ul><li>  In package.json add scripts and settings: </li></ul><br><pre> <code class="javascript hljs">{ ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {  ...  <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run test:jest"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"test:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk test --dev"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"prepare"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prepare:snyk"</span></span>,  <span class="hljs-string"><span class="hljs-string">"prepare:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk protect"</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {  <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"commit-msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"commitlint -E HUSKY_GIT_PARAMS"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-commit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run lint &amp;&amp; npm run test:jest"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-push"</span></span>: [    <span class="hljs-string"><span class="hljs-string">"npm run test:snyk"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run lint"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run test:jest"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run build:production"</span></span>   ],   ...  } }, <span class="hljs-string"><span class="hljs-string">"snyk"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Above, we looked at local security checks.  I recommend using LGTM to check packages for known threats.  Use this project in conjunction with GitHub or Bitbucket (I have not tried it yet, it was not necessary), and the code will be checked immediately with each push. </p><br><h2>  Application monitoring </h2><br><p>  In the field of Front-end, the tools have already been settled, tools for every taste are available for logging and monitoring the client part.  The most famous are Sentry, TrackJS and InsightOps.  Sentry server can be deployed on its physical servers.  For example, in our two projects a separate server was used, fully configured for logging the operation of applications.  We went to the URL and threw all the logs there.  If an error occurs in the application, it is wrapped in a try catch block and sent to the Sentry server through the methods of the raven package.  Everything is simple and convenient.  If you see incomprehensible URLs in Sentry that you did not register, if you see introductions or incomprehensible messages, it means that you are being hacked.  In my practice, this is met regularly.  For example, one of the projects - a service for circumventing ad blockers and antiviruses - was constantly trying to counteract and hack it. </p><br><p>  I also recommend using Grafana for monitoring.  It is important to consider a system of criteria and indicators that will be monitored by the system.  We tuned in for traffic, for advertising returns, for the degree of ad rendering, for the number of banners that came from Yandex, and so on.  (projects in Rambler Group).  We needed to understand how Yandex works with our requests, because it is a third-party service, which means it should be monitored, because if it refuses, the entire project can collapse completely. </p><br><p>  If you monitor all communication with third-party services, then very quickly you will find any error.  A story from my practice: we saw that the answers to advertising had suddenly ceased to come from Yandex.  It turned out that they had technical malfunctions and the entire advertising network lay tight.  And it was not Yandex that informed us first, but we called them and asked to see what was happening with their services. </p><br><p>  What is the best monitor?  Take a small URL, list the GET parameters and send a GET request to this URL.  In the server part, process this URL, write the log to the database and raise the monitoring on Grafana.  It's simple. </p><br><p>  That's all.  In the future I will try to continue writing on the topic of protecting web applications from threats.  Anyone who has read to the end - I wish security to your projects))) </p><br><h3>  List of sources for reading on the topic: </h3><br><p>  <a href="https://www.owasp.org/index.php/Main_Page">www.owasp.org/index.php/Main_Page</a> </p><br><p>  <a href="https://tproger.ru/translations/webapp-security/">tproger.ru/translations/webapp-security</a> </p><br><p>  <a href="https://www.linkedin.com/pulse/even-faster-single-page-application-9security-sergei-iastrebov/">S. Hawks.</a>  <a href="https://www.linkedin.com/pulse/even-faster-single-page-application-9security-sergei-iastrebov/">Even Faster Single Page Application: security</a> </p><br><p>  Seacord, Robert C. The CERT C secure coding standard / Robert C. Seacord.  - 2008 </p><br><p>  Chetan Karande.  Securing Node Applications - 2017 </p><br><p>  Steven Palmer.  Web Application Vulnerabilities Detect, Exploit, Prevent - 2011 </p><br><p>  Robert Shimonski, Sean-Philip Oriyano.  Client-Side Attacks and Defense - 2012 </p><br><p>  Marcus Pinto, Dafydd Stuttard.  Hacker's Web Application Handbook: Finding and Exploiting Security Flaws, 2nd Edition - 2011 </p><br><p>  Karl Duuna.  Secure Your Node.js Web Application - 2015 </p></div><p>Source: <a href="https://habr.com/ru/post/445932/">https://habr.com/ru/post/445932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445920/index.html">LIVE: How to curb iOS development in large teams</a></li>
<li><a href="../445922/index.html">Why watch online broadcasts if you can read Habr</a></li>
<li><a href="../445924/index.html">ARRIVALS: when smart watches get weird</a></li>
<li><a href="../445926/index.html">The US UFO secret program has also been researching wormholes and additional measurements.</a></li>
<li><a href="../445928/index.html">How we increased Tensorflow Serving performance by 70%</a></li>
<li><a href="../445936/index.html">Electronics development. About microcontrollers on fingers</a></li>
<li><a href="../445940/index.html">AMA with Habr, v 7.0. Lemon, Donates and News</a></li>
<li><a href="../445946/index.html">MWC: instructions for use</a></li>
<li><a href="../445948/index.html">C ++ Inheritance: beginner, intermediate, advanced</a></li>
<li><a href="../445952/index.html">Trillion Little Shingles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>