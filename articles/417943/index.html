<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Serverless and React 2: sleight of hand and no fraud</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Is it possible to simply tell front-end developers about the work of the "cloudless" Serverless architecture within AWS (Amazon Web Services)? Why not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Serverless and React 2: sleight of hand and no fraud</h1><div class="post__text post__text-html js-mediator-article">  Is it possible to simply tell front-end developers about the work of the "cloudless" Serverless architecture within AWS (Amazon Web Services)?  Why not.  Let's render a React / Redux application in the AWS architecture, and then talk about the pros and cons of AWS-lambda. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wJcXVjemrEY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>The material is based on the transcript of the <a href="https://holyjs-piter.ru/talks/5cyioitrdyamiisaeasmug/">report by Marina Mironovich</a> from our spring conference HolyJS 2018 in St. Petersburg.</i> <br><a name="habracut"></a><br>  Officially Marina is the lead developer of EPAM.  Now she works in a solution architect group for a customer and because of this she participates in a large number of projects.  Therefore, it will be easier for us to outline the circle of its current interests than to list all the technologies with which it works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/caf/b0d/0e6cafb0de05d040b8b7bc30ab969b34.jpg" align="left">  <i>First of all, I am interested in all cloud technologies, in particular, AWS, because I work a lot with this in production.</i>  <i>But I try to keep up with everything else.</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>The frontend is my first love and seems forever.</i>  <i>In particular, I am currently working with React and React Native, so I know a little more about this.</i>  <i>I also try to follow everything else.</i>  <i>I am interested in everything related to documenting a project, for example, UML diagrams.</i>  <i>Since I am in the solution architect group, I have to do a lot of this.</i> <i><br><br></i> <br><br><h2>  Part 1. Background </h2><br>  I had an idea to talk about Serverless about a year ago.  I wanted to talk about Serverless for front-end developers easily and naturally.  So that you do not need any additional knowledge to use it, especially technologies now allow you to do it. <br><br>  To some extent, the idea was implemented - I <a href="https://events.yandex.ru/lib/talks/4904/">told about Serverless</a> on FrontTalks 2017. But it turned out that 45 minutes is not enough for a simple and understandable story.  Therefore, the report was divided into two parts, and now the second ‚Äúseries‚Äù is before you.  Who has not seen the first - do not worry, it does not hurt to understand what is written below.  As in the decent series, I will start with a brief summary of the previous part.  Then go to the juice itself - we will render the React / Redux application.  And finally, I will talk about the pros and cons of cloud functions in principle (in particular, AWS-lambda) and what else can be done with them.  I hope that this part will be useful to all those who are already familiar with AWS-lambda.  The most important thing is that the world does not end at Amazon, so let's talk about what else is in the area of ‚Äã‚Äãcloud functions. <br><br><h3>  What will i use </h3><br>  To render an application, I will use many Amazon services: <br><br><ol><li>  S3 is, consider, a file system in the clouds.  There we will store static assets. <br></li><li>  IAM (access rights for users and services) - implicitly, but it will be used in the background so that the services communicate with each other. <br></li><li>  API Gateway (URL to access the site) - you will see the URL by which we can call our lambda. <br></li><li>  CloudFormation (for deployment) - will be used implicitly in the background. <br></li><li>  AWS Lambda - we came here for this. <br></li></ol><br><h3>  What is serverless and what is AWS Lambda? </h3><br>  In fact, Serverless is a big deception, because of course there is a server: somewhere it all starts.  But what happens there? <br><br>  We write a function, and this function runs on the servers.  Of course, it runs not just like that, but in some kind of container.  And, actually, this function in the container on the server is called lambda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/2c6/ff1/6ad2c6ff181236d39a29121e8b607a96.png"></div><br>  In the case of lambda, we can forget about the servers.  I would even say this: when you write a lambda function, it‚Äôs bad to think about them.  We work with lambda not in the way we work with the server. <br><br><h3>  How to lambda </h3><br>  A logical question arises: if we do not have a server, how do we deploy it?  There is SSH on the server, we uploaded the code, launched it - everything is fine.  What to do with lambda? <br><br>  <b>Option 1. We can not deploy it</b> <br><br>  AWS in the console made for us a sweet and gentle IDE, where we can come and write a function right there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08e/1cd/f73/08e1cdf73c5d5fec2c6315e0207e51ed.png"><br><br>  It's cute, but not very expandable. <br><br>  <b>Option 2. We can make a zip and download it from the command line</b> <br><br>  How do we make a zip file? <br><br> <code>zip -r build/lambda.zip index.js [node_modules/] [package.json] <br></code> <br>  If you use node_modules, all of this is stored in one archive. <br>  Further, depending on whether you are creating a new function or you already have such a function, you are doing either <br><br> <code>aws lambda create-function... <br></code> <br>  or <br><br> <code>aws lambda update-function-code... <br></code> <br>  What is the problem?  First, the AWS CLI wants to know whether a function is being created or whether you already have one.  These are two different teams.  If you want to update not only the code, but also some attributes of this function, problems begin.  The number of these commands is growing, and you need to sit with the directory and think about which command to use. <br><br>  We can do it better and easier.  We have frameworks for this. <br><br><h3>  AWS Lambda Framework </h3><br>  There are a lot of such frameworks.  This is primarily AWS CloudFormation, which works in conjunction with the AWS CLI.  CloudFormation is a Json file describing your services.  You describe them in a Json file, then the AWS CLI says ‚Äúexecute‚Äù and it will automatically create everything for you in the AWS service. <br><br>  But it is still difficult for such a simple task as rendering something.  Here, the entry threshold is too large - you need to read what structure CloudFormation has, etc. <br><br>  Let's try to simplify.  And here different frameworks appear: APEX, Zappa (only for Python), Claudia.js.  I have listed only a few, randomly. <br><br>  The problem and strength of these frameworks is that they are highly specialized.  It means that they do some simple task very well.  For example, Claudia.js is very good for creating a REST API.  It will make the AWS call API Gateway, it will create a lambda for you, it will all beautifully work.  But if you need to add a little more, the problems start - you have to add something, help, search, etc. <br><br>  Zappa is written only for Python.  And you want something more ambitious.  And here comes Terraform and my love Serverless. <br><br>  Serverless is somewhere in the middle between a very large CloudFormation, which can do almost everything, and these highly specialized frameworks.  Almost everything can be deployed in it, but it is still quite easy to do.  In addition, it has a very easy syntax. <br><br>  Terraform - to some extent similar to CloudFormation.  Terraform is open source, everything can be deployed in it - or almost everything.  And when AWS creates services, you can add something new there.  But he is big and complicated. <br><br>  To be honest, in production, we use Terraform, because with Terraform everything that we have comes up easier - Serverless will not describe all this.  But Terraform is very complicated.  And when I write something for work, I first write it on Serverless, test it for operability and only after my configuration is tested and tested, I rewrite it to Terraform (this is ‚Äúentertainment‚Äù for a couple of days). <br><br><h3>  Serverless </h3><br>  Why I love Serverless? <br><br><ol><li>  Serverless has a system that allows you to create plugins.  In my opinion, this is salvation from everything.  Serverless - open source.  But to add something in open source is not always easy.  You need to understand what is happening in the existing code, observe the guidelines, at least the codestyle, give PR to the PR, forget about this PR, and it will dust for three years.  As a result, you forknite, and it will have you lie somewhere separately.  All this is not very cool.  But when there are plugins, everything is simplified.  It is necessary to add something - you are creating a small plugin on your knee.  To do this, you no longer need to understand what is happening inside Serverless (if this is not a super-custom question).  You simply use the available API, save the plugin somewhere or deploy it for everyone.  And everything works for you.  In addition, there is already a large zoo of plugins and people who write these plugins.  That is, perhaps something has already been decided for you. <br></li><li>  Serverless helps to run lambda locally.  A big enough minus of lambda is that AWS did not think about how we will debug it and test it.  But Serverless allows you to run everything locally, see what happens (it even does it in conjunction with API Gateway). <br></li></ol><br><h3>  Demonstration </h3><br>  Now I will show how it all really works.  Over the next one and a half to two minutes we will be able to create a service that will render our HTML page. <br>  First, in the new folder, I will launch the SLS Create template: <br><br> <code><br> mkdir sls-holyjs <br> cd sls-holyjs <br> sls create --template aws-nodejs-ecma-script <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/4d2/620/2e5/4d26202e5337684014e9f43fb25771d3.png"><br><br> <code>npm install <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/bee/67c/81f/bee67c81fbb0b19e21432a73b69751dc.png"><br><br>  Serverless developers took care of us - made it possible to create services from templates.  In this case, I use the <code>nodejs-ecma-script</code> template, which will create for me some files, such as the webpack configuration, package.json, some functions and serverless.yml: <br><br> <code>ls <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/35b/6c6/86a/35b6c686a1fbe3e323ddb939147d1b3d.png"><br><br>  I don't need all the features.  I will delete the first, the second rename to holyjs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/599/ae0/030599ae094881637ae09ee3daf33ffd.png"><br><br>  I will slightly correct serveless.yml, where I have a description of all the necessary services: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85d/0ba/f9b/85d0baf9bad8e2918866f5a97c096017.png"><br><br>  Well, then correct the response that the function returns: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e13/07a/d85/e1307ad8550ea44532f79e6db27d561c.png"><br><br>  I‚Äôll make HTML ‚ÄúHello HolyJS‚Äù and add a handle for rendering. <br><br>  Further: <br><br> <code>sls deploy <br></code> <br>  And voila!  There is a URL where I can see in my public access what is being rendered: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/228/4f3/b94/2284f3b9487a8d70a9244652d99874ff.png"><br><br>  Trust but check.  I will go to the AWS Console and check that the holyjs function has been created for me: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e62/458/e98/e62458e98369c7022c280c419f79be55.png"><br><br>  As you can see, Serverless will assemble it using a webpack before it is laid down.  In addition, the rest of the infrastructure, which is described there - API Gateway, etc., will be created. <br><br>  When I want to remove this: <br><br> <code>sls remove <br></code> <br>  All infrastructure, which is described in serverless.yml, will be removed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/8fb/f2d/ad78fbf2d65cbcaef9094673bcca4026.png"><br><br>  If someone lags behind the process described here, I invite you to simply revise my <a href="https://events.yandex.ru/lib/talks/4904/">previous report</a> . <br><br><h3>  Launch lambda locally </h3><br>  I mentioned that lambda can be run locally.  There are two options for starting. <br><br>  <b>Option 1. We just run everything in the terminal.</b> <br><br>  We get what our function returns. <br><br> <code><br> sls invoke local -f [fn_name] <br></code> <br>  <b>Option 2. Launch lambda locally serverless-offline</b> <br><br>  Do not forget, we make an isomorphic application, it will be HTML and CSS, so in the terminal it‚Äôs somehow not very interesting to look at long HTML lines.  There you can check that the function works.  But I would like to launch and render it in a browser.  Accordingly, I need a bunch of API gateway with lambda. <br><br>  To do this, there is a separate serverless-offline plugin that will launch your lambda on any port (this is written), then display a URL in the terminal where you can access it. <br><br> <code>sls offline --port 8000 start <br></code> <br>  The best part is that there is a hot reloading.  That is, you write the function code, update your browser and update what the function returns.  You do not need to restart everything. <br><br>  This was a summary of the first part of the report.  Now we come to the main part. <br><br><h2>  Part 2. Rendering with AWS </h2><br>  The project described below is <a href="https://github.com/Marina-Miranovich/lambda-react">already</a> on GitHub.  If you're interested, you can download the code there. <br><br>  Let's start with how it all works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/f9d/a97/f03f9da976ac1723c15aad19dd631689.png"><br><br>  Suppose there is a user - me. <br><br><ul><li>  I open the site. <br></li><li>  At no URL, we access the API gateway.  I want to note that API Gateway is already an AWS service, we are already in the clouds. <br></li><li>  API Gateway will cause lambda. <br></li><li>  Lambda will render the site, and all this will return to the browser. <br></li><li>  The browser will start to render and realize that there are not enough static files.  Then he will turn to the S3 bucket (our file system, where we will store all the statics; in the S3 bucket you can put everything - fonts, images, CSS, JS). <br></li><li>  The data from the S3 bucket will return to the browser. <br></li><li>  The browser will render the page. <br></li><li>  Everyone is happy. <br></li></ul><br>  Let's do a little code review of what I wrote. <br><br>  If you go to GitHub, you will see the following file structure: <br><br> <code><b>lambda-react</b> <br> README.md <br> <b>config <br> package.json</b> <br> public <br> scripts <br> <b>serverless.yml <br> src</b> <br> yarn.lock <br></code> <br>  All this is generated automatically in the React / Redux tool kit.  In fact, here we will be interested in literally a couple of files and they will have to be slightly corrected: <br><br><ul><li>  config <br></li><li>  package.json <br></li><li>  serverless.yml - because we will deploy, <br></li><li>  src - nowhere without it. <br></li></ul><br><h3>  Let's start with the configuration </h3><br>  To have everything gathered on the server, we need to add another webpack.config: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c0/990/786/6c099078652d80adcdcb70518187644f.png"><br><br>  This webpack.config will already be generated for you if you use the template.  And there the variable <code>slsw.lib.entries</code> will automatically be substituted, which will point to your lambda handlers.  If you want, you can change it yourself by specifying something else. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/90e/c6a/53590ec6ae4247d42bab7deca58a0b62.png"><br><br>  We will need to render everything for the node ( <code>target: 'node'</code> ).  In principle, all other loaders remain the same as for the normal React application. <br><br><h3>  Next in package.json </h3><br>  We will simply add a couple of scripts - start and build have already been generated with React / Redux - nothing changes.  Add a script to run the lambda, and a script to deploy the lambda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/822/8c4/4e28228c43ebd1548ff77f0f2d3421a2.png"><br><br><h3>  serverless.yml </h3><br>  A very small file - only 17 lines, all of them below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/404/6fa/0c54046fa5a2461532d6f7638aaf650b.png"><br><br>  What is interesting to us?  First of all handler.  There the full path to the file is <code>src/lambda/handler</code> ( <code>src/lambda/handler</code> ) and the handler function is specified through the dot. <br><br>  If you really want, in one file you can register several handlers.  There is also a path to the webpack, which should collect all this.  In principle, everything: the rest is already generated automatically. <br><br><h3>  The most interesting is src </h3><br>  Here is a huge React / Redux application (in my case it is not huge - per page).  In the additional lambda folder there is everything we need to render lambda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/b29/61a/3f4b2961a0c6f9218b715d6f013c53bf.png"><br><br>  These are 2 files: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/df3/485/f10df348528805e990f1d781a2406226.png"><br><br>  Let's start with the handler.  The most important is the 13th line.  This is the renderer, which is the very lambda that will be called in the clouds: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/d02/4a2/3ddd024a27fe4ccd1d919885f56f1009.png"><br><br>  As you can see, the <code>render ()</code> function returns a promise, from which you must catch all exceptions.  This is a feature of the lambda, otherwise the lambda will not end immediately, but will work until the timeout.  You will have to pay extra money for a code that has already fallen.  To avoid this, you need to finish the work of the lambda as early as possible - first of all, catch and handle all exceptions.  Later we will come back to this. <br><br>  If we have no errors or exceptions, we call the <code>createResponse</code> function, which takes literally five lines.  We will simply add all headers so that it is rendered correctly in the browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/15c/025/1c315c025f85e3d63a70a9843cb0a8d3.png"><br><br>  Here the most interesting is the <code>render</code> function, which will render our page: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/336/0b8/d3d3360b83d7d5c329c5177719029ba8.png"><br><br>  This function comes to us from renderer.js.  Let's see what is there. <br><br>  An isomorphic application is being rendered there.  Moreover, it is rendered on any server - it does not matter here whether it is lambda or not. <br><br>  I will not tell you in detail about what an isomorphic application is, how to render it, because this is a completely different topic, and there are people who told it better than me.  Here are some tutorials that I found, just a few minutes googling: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e3/366/3d0/1e33663d08624d7649ae4cb084571b98.png"><br><br>  If you know any other reports, you can advise, I will give them links on my twitter. <br><br>  In order not to lose anyone, I will simply go over the tops, tell you what is happening there. <br>  First of all, we need to render this into an HTML string with React / Redux. <br><br>  This is done through the standard React method - <code>renderToString</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/69f/3e8/81f69f3e89005f3ff76e389a65a6d731.png"><br><br>  Next, we have to render styles so that we don‚Äôt blink content.  This is not a very trivial task.  There are several npm packages that solve it.  For example, I used a <code>node-style-loader</code> , which will collect everything in <code>styleTag</code> , and then it can be inserted into HTML. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/509/827/653/509827653575b822318cc8746c893b1b.png"><br><br>  If there are packages better, it is up to you. <br><br>  Next we need to pass the Redux state.  Once you render on the server, you probably want to get some data, and you do not want Redux to re-request and re-render it again.  This is a fairly standard task.  On the main Redux site, there are examples of how to do this: we create an object and then pass it through a global variable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/732/726/151/7327261516c4747f0994c83f5237668b.png"><br>  Now a little closer to the lambda. <br><br>  It is necessary to do error handling.  We want to catch everything and do something with them, at least stop the development of the lambda.  For example, I made it through a <code>promise</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe4/eb4/827/fe4eb4827fd43e48c17a84767612da2d.png"><br><br>  Next you need to substitute our URL for static files.  And for this we need to find out where the lambda is running - locally or somewhere in the clouds.  How to find out? <br><br>  We will do this through environment variables: <br><br> <code><br> <br> ‚Ä¶ <br> const bundleUrl = process.env.NODE_ENV === 'AWS' ? <br> AWS_URL : LOCAL_URL; <br></code> <br>  An interesting question: how are the environment variables configured in lambda.  Really easy enough.  In yml, you can pass any variables to the <code>environment</code> .  When it comes, they will be available: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bf/a6d/083/6bfa6d083ab79f39cf033342e7e1cec6.png"><br><br>  Well, and a bonus - after we have tightened the lambda, we want to close all the static assets.  To do this, they have already written a plugin where you can designate the S3-basket where you want to add something: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/784/43d/2a3/78443d2a3bcfbf351429efa9f98e9965.png"><br>  In total, we made an isomorphic application in about five minutes to show that this is all easy. <br><br>  Now let's talk a little about theory - about the pros and cons of lambda. <br><br>  Let's start with the bad. <br><br><h3>  Cons lambda functions </h3><br>  The downside may be (or maybe not) the time of a cold start.  For example, for the lambda on Node.js, which we are writing now, the time of a cold start does not mean much. <br><br>  The graph below shows the cold start time.  And this can be a big deal especially for Java and C # (notice the orange dots) - you don't want five or six seconds for you to take just the beginning of the code. <br><br>  For Node.js, the start time is almost zero - 30 - 50 ms.  Of course, for someone this can also be a problem.  But the functions can be reheated (although this is not the topic of this report).  If someone is interested in how these tests were conducted, welcome to acloud.guru, they will tell you everything ( <a href="https://read.acloud.guru/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda-a15e26d12c76">in the article</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/11b/185/cb711b1856839c3b9ee9d0a268e0b4cc.png"><br><br>  So what are the cons? <br><br><h3>  Function code size limits </h3><br>  The code must be less than 50 MB.  Is it possible to write such a large function?  Please do not forget about node_modules.  If you connect something, especially if there are binary files, you can really easily go over 50 MB, even for zip files.  I had such cases.  But this is an additional reason to see what you connect to the node_modules. <br><br><h3>  Time limits </h3><br>  By default, the function is executed a second.  If it does not end in a second, you will have a timeout.  But this time can be increased in the settings.  When creating a function, you can set the value to five minutes.  Five minutes is a hard deadline.  For the site is not a problem.  But if you want to do something more interesting on lambdas, for example, image processing, translating text into sound or sound into text, etc., such calculations can easily take more than five minutes.  And it will be a problem.  What to do with it?  Optimize or not use lambda. <br><br>  Another interesting thing that arises in connection with the limitation on the execution time of the lambda.  Recall the scheme of our site.  Everything worked fine, until the product came and did not want to on the site real time feed - show the news in real time.  We know that this is implemented with WebSocket.  But WebSockets don't work for five minutes, they have to be kept longer.  And here the limit of five minutes becomes a problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a3/baa/e78/4a3baae784a50a373e56e5e3652187c9.png"><br><br>  A small note.  For AWS, this is no longer a problem.  They found how to get around this.  But generally speaking, as soon as web sockets appear, lambda is not a solution for you.  You need to go back to the good old server. <br><br><h3>  Number of parallel functions per minute </h3><br>  Above is a limit from 500 to 3000, depending on the region where you are.  In my opinion, in Europe, almost everywhere 500. 3000 is supported in the United States. <br><br>  If you have a busy site and you expect more than three thousand requests per minute (which is easy to imagine) this becomes a problem.  But before we talk about this minus, let's talk a little bit about how the lambda scales. <br><br>  We receive a request, and we have a lambda.  While this lambda is being fulfilled, two more requests come to us - two more lambdas are launched from us.  People are starting to come to our website, requests appear and more and more lambdas are launched. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a1/58e/a49/4a158ea4922c44333fbe590440dde1b3.png"><br><br>  At the same time you pay for the time when lambda is performed.  Suppose you pay one cent for one second of lambda execution.  If you have 10 lambdas for a second, then you pay 10 cents for that second.  If you have a million lambdas in a second, it will be about 10 thousand dollars.  Unpleasant figure. <br><br>  Therefore, AWS decided that they do not want to empty your wallet in a second if you did your tests incorrectly and start DDOS yourself, causing lambdas, or DDOS came you someone else.  Therefore, a limit of three thousand was established - so that you have the opportunity to react to the situation. <br><br>  If the load of 3000 requests is regular for you, you can write to AWS and they will raise the limit. <br><br><h3>  Stateless </h3><br>  This is the last, again, controversial minus. <br><br>  What is stateless?  Here is a joke about goldfish - they just do not hold the context: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/c26/620/b03c26620417a57fec13f48b896c7ef9.png"><br><br>  Lambda, called the second time, does not know anything about the first call. <br><br>  Let me show it with an example.  Suppose I have a system - a big black box.  And this system, among other things, is able to send SMS. <br><br>  A user comes and says: send an SMS template number 1. And the system sends it to a real device. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/1e9/dea/ad01e9dead7ca1c6a23788c5179f1b3f.png"><br><br>  At some point, the product expresses a desire to find out what goes there and check that nothing has broken anywhere in this system.  To do this, we will replace the real device with some kind of test number - for example, Twilio can do it.  He will call Webhook, send the SMS text, we will process this SMS text in the application (we need to check that our template has become the correct SMS text). <br><br>  To check, we need to know what was sent - we will do this through a test application.  It remains to compare and display the results. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5be/881/81f/5be88181fc05100d0f9000d2eb3be124.png"><br><br>  Let's try doing the same thing on lambda. <br><br>  Lambda will send SMS, SMS will come to Twilio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bce/e3d/499/bcee3d4993dc73090829810748f97ea4.png"><br><br>  I drew a dotted line not accidentally, because SMS can come back in minutes, hours or days - it depends on your operator, that is, it is not a synchronous call.  By this time, lambda will forget everything, and we will not be able to check the SMS. <br><br>  I would say that this is not a minus, but a feature.  The scheme can be altered.  There are several options to do this, I will offer my own.  If we have stateless, and we want to keep something, then we should definitely use the storage, for example, the database, S3, and anything that will store our context. <br><br>  In the scheme with SMS storage will be sent to the test number.  And when Webhook calls it - I suggest calling, for example, the second lambda, because this is a slightly different function.  And the second lambda will already be able to go and retrieve from the database the SMS that went, check it and display the results. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/fdc/2c3/d7ffdc2c3761dbadd4d2500daadd68db.png"><br><br>  Bingo! <br><br>     ,     ,   .   ,    node.js    express-.     ,     .  ,   ,   ,   ‚Äî .  How is this possible? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have a server, and a container is started in it. Launching a container is quite an expensive operation. First, it is necessary to make this container. Only after it is created will the function code be deployed there and can it be executed. After your function has completed, the container is not killed, because AWS thinks you can call this function again. AWS never wrote how much the container lives after the function has stopped. We did the experiments. In my opinion, for a node it is three minutes, for Java they can hold a container for 12-15 minutes. But this means that when the call to the next function comes, it will be called in the same container and in the same environment. If you use node cache somewhere, you create variables there, etc. - if you have not cleaned them, they will remain there. So if you write on lambda,you have to forget about the cache in general, otherwise you can get into unpleasant situations. It is difficult to otdebezhit.</font></font><br><br><h3>  - </h3><br>  ,      . <br><br><ul><li>      ,   .  ,     javascript,  .  ,        javascript-,        . <br></li><li>      ,   ,   . ,   ,  .   ,             . <br></li><li>    AWS- ‚Äî            (DynamoDB, Alexa, API Gateway,  . .). <br></li></ul><br><h3>      ? </h3><br>      ‚Äî      ,       ,   REST API.        ,     ,         . <br><br>  ,     ,  ‚Ä¶  . <br><br><ul><li> HTTP Services ‚Äî     . REST API,  API endpoint ‚Äî  .   .    ,   enterprise   node.js   middleware.    java,    ,     js ,     .         . <br></li><li> IoT ‚Äî ,   Alexa      - -,         ,  . <br></li><li> Chat Bots ‚Äî    ,   IoT. <br></li><li> Image/Video conversions. <br></li><li> Machine learning. <br></li><li> Batch Jobs ‚Äî -  ,  Batch Job     . <br></li></ul><br>   Amazon, Google, Azure, IBM, Twillio ‚Äî         cloud functions.     ,               .     open source (      ,  open source ‚Äî ).  open source    .        .         ‚Äî Dockers farm, Kubernetes ‚Äî    . <br><br>  , , -,      .       AWS   ,    open source    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below are not all the development. </font><font style="vertical-align: inherit;">I just chose a bigger and more interesting. </font><font style="vertical-align: inherit;">The complete list is huge: a lot of startups are starting to work on this topic now:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iron functions </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fnproject </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Openfaas </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apache OpenWhisk </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kubeless </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fission </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried Fnproject and spent only a couple of hours to transfer this isomorphic application to Fnproject and run it locally with the Kubernetes container. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still scaling fast. </font><font style="vertical-align: inherit;">You will have a bunch of API Gateway (of course, without the rest of the services), but you still have the URL that causes the lambda. </font><font style="vertical-align: inherit;">And in fact, almost everyone can forget about the servers, as promised, except for one person who will deploy this framework and set up this Kubernetes orchestra to be used so that happy developers can use it.</font></font><br><br><blockquote>  .   <a href="https://habr.com/company/jugru/blog/419289/"></a>  HolyJS 2018 Moscow,   24-25   .  <a href="https://holyjs-moscow.ru/"></a>      ,     Early Bird-. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/417943/">https://habr.com/ru/post/417943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417933/index.html">Security Week 27: Counterfeit iPhone and Security Price</a></li>
<li><a href="../417935/index.html">Memo on artificial intelligence, machine learning, deep learning and big data</a></li>
<li><a href="../417937/index.html">Do "iron" people make software?</a></li>
<li><a href="../417939/index.html">Optimizing the rendering of scenes from the Disney cartoon "Moana". Parts 4 and 5</a></li>
<li><a href="../417941/index.html">Where does the water in the kettle go?</a></li>
<li><a href="../417945/index.html">What tools does the Parker sun probe have?</a></li>
<li><a href="../417947/index.html">Data visualization for your web project</a></li>
<li><a href="../417949/index.html">As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.2</a></li>
<li><a href="../417951/index.html">Writing Java Friendly Kotlin Code</a></li>
<li><a href="../417953/index.html">Trends in FPGA Design. Transfer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>