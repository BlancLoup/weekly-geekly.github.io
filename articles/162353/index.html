<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using async and await in C # best practices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The async and await keywords entered in C # 5.0 greatly simplify asynchronous programming. They also hide behind them some difficulties that, if you l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using async and await in C # best practices</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0a4/ad8/7bf/0a4ad87bfba73819105e3decad42452a.png" align="right"><br>  The async and await keywords entered in C # 5.0 greatly simplify asynchronous programming.  They also hide behind them some difficulties that, if you lose your guard, can add problems to your code.  The practices described below will be useful to you if you create asynchronous code for .NET applications. <br><a name="habracut"></a><br><br>  <b>Use async / await only for places that can last ‚Äúlong‚Äù</b> <br><br>  Everything is simple here.  Creating a <code>Task</code> and other structures to manage asynchronous operations adds some overhead.  If your operation is really long, for example, performing an IO request, then these expenses will not be noticeable in general.  And if your operation is short or takes several processor cycles, then it may be better to perform this operation synchronously. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, the team that worked on the .NET Framework did a good job of choosing functionality, which should be asynchronous.  So, if the framework method ends on <code>Async</code> and returns a task, then most likely you should use it asynchronously. <br><br>  <b>Prefer async / await instead of task</b> <br><br>  Writing asynchronous code using <code>async/await</code> makes the process of creating code and reading it much easier than using <code>Task</code> tasks. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyWebService.FetchDataAsync() .ContinueWith(t =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data (t.Result)); }</code> </pre><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> MyWebService.FetchDataAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data (result); }</code> </pre><br>  In terms of performance, both of the methods presented above have a small overhead, but they scale somewhat differently as the number of tasks in them increases: <br><ul><li>  <code>Task</code> builds a chain of continuations that increases in accordance with the number of tasks connected in series, and the state of the system is controlled through the closures found by the compiler. </li><li>  <code>Async/await</code> builds a state machine that does not use additional resources when adding new steps.  However, the compiler can define more variables for storing state machine stacks, depending on your code (and compiler).  The <a href="http://msdn.microsoft.com/en-us/magazine/hh456402.aspx">article on MSDN describes</a> the details of what is happening. </li></ul><br>  In most scenarios, <code>async/await</code> will use less resources and run faster than task tasks. <br><br>  <b>Use the already completed empty static task for the conditional code.</b> <br><br>  Sometimes you want to run a task only under some condition.  Unfortunately, <code>await</code> will cause a <code>NullReferenceException</code> if it receives <code>null</code> instead of a task, and handling this will make your code less readable. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> getLatestData</span></span></span><span class="hljs-function">)</span></span> { Task&lt;WebData&gt; task = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getLatestData) task = MyWebService.FetchDataAsync(); <span class="hljs-comment"><span class="hljs-comment">//     //      null WebData result = null; if (task != null) result = await task; return new Data (result); }</span></span></code> </pre> <br>  One way to simplify the code a bit is to use an empty task that has already been completed.  The resulting code will be cleaner: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> getLatestData</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = getLatestData ? MyWebService.FetchDataAsync() : Empty&lt;WebData&gt;.Task; <span class="hljs-comment"><span class="hljs-comment">//     // task   null return new Data (await task); }</span></span></code> </pre><br>  Make sure the task is static and created as completed.  For example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Empty</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _task; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Task&lt;T&gt; _task = System.Threading.Tasks.Task.FromResult(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T)); }</code> </pre><br><br>  <b>Performance: prefer to cache the tasks themselves, rather than their data</b> <br><br>  There are some overhead when creating tasks.  If you cache your results, but then convert them back to tasks, you may create additional task objects. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; GetContentsOfUrl(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> url) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cache.TryGetValue(url, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> bytes)) <span class="hljs-comment"><span class="hljs-comment">//     return Task&lt;byte[]&gt;.Factory.StartNew(() =&gt; bytes); bytes = MyWebService.GetContentsAsync(url) .ContinueWith(t =&gt; { _cache.Add(url, t.Result); return t.Result; ); } //    (      ) private static Dictionary&lt;string, byte[]&gt; _cache = new Dictionary&lt;string, byte[]&gt;();</span></span></code> </pre><br>  Instead, it will be better to copy the tasks themselves to the cache.  In this case, the code using them can wait for the task that has already been completed.  In Task Parallel Library there are optimizations to ensure that the code waiting for the execution of an already completed task <a href="http://blogs.msdn.com/b/lucian/archive/2011/04/15/async-ctp-refresh-design-changes.aspx">runs faster</a> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; GetContentsOfUrl(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> url) { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; bytes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_cache.TryGetValue(url, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> bytes)) { bytes = MyWebService.GetContentsAsync(url); _cache.Add(url, bytes); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes; } <span class="hljs-comment"><span class="hljs-comment">//    (      ) private static Dictionary&lt;string, Task&lt;byte[]&gt;&gt; _cache = new Dictionary&lt;string, Task&lt;byte[]&gt;&gt;();</span></span></code> </pre><br><br>  <b>Productivity: understand how await saves state</b> <br><br>  When you use <code>async/await</code> , the compiler creates a state machine that stores variables and a stack.  For example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> MyWebService.GetDataAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> otherData = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> MyWebService.GetOtherDataAsync(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} = "</span></span><span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">", data, otherdata); }</span></span></code> </pre><br>  This will create a state object with several variables.  See how the compiler saves method variables: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential), CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &lt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>__state; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AsyncTaskMethodBuilder &lt;&gt;t__builder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Action &lt;&gt;t__MoveNextDelegate; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data &lt;data&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>__1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OtherData &lt;otherData&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>__2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &lt;&gt;t__stack; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &lt;&gt;t__awaiter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; [DebuggerHidden] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre><br>  <i>Note 1.</i> If you declare a variable, it will be stored in an object that stores the state.  This can cause objects to remain in memory longer than you might expect. <br><br>  <i>Note 2.</i> But if you do not declare a variable and use the <code>Async</code> value of the call with <code>await</code> , the variable will fall into the internal stack: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = MyWebService.GetDataAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> otherData = MyWebService.GetOtherDataAsync(); <span class="hljs-comment"><span class="hljs-comment">//        //      await- Console.WriteLine("{0} = "1", await data, await otherdata); }</span></span></code> </pre><br>  You shouldn't worry too much about this until you see performance problems.  If you still decide to delve into the optimization, on MSDN there is a good article about this: <a href="http://msdn.microsoft.com/en-us/magazine/hh456402.aspx">Async Performance: Understanding the Costs of Async and Await</a> . <br><br>  <b>Stability: async / await is not Task.Wait</b> <br><br>  The state machine generated by <code>async/await</code> is not the same as <code>Task.ContinueWith/Wait</code> .  In general, you can replace the implementation from <code>Task</code> with <code>await</code> , but there may be some performance and stability issues.  Let's take a closer look. <br><br>  <b>Stability: Know your sync context</b> <br><br>  .NET code is always executed in some context.  This context defines the current user and other values ‚Äã‚Äãrequired by the framework.  In some execution contexts, the code runs in a synchronization context that controls the execution of tasks and other asynchronous work. <br><br>  By default, after <code>await</code> code will continue to work in the context in which it was launched.  This is convenient because basically you want the security context to be restored, and you want your code after await to have access to the Windows UI objects, if it already had access to them at startup.  Note that <code>Task.Factory.StartNew</code> does not restore context. <br><br>  Some synchronization contexts do not support re-entry into them and are single-threaded.  This means that only one unit of work can be performed in this context at a time.  An example of this might be a Windows UI thread or an ASP.NET context. <br><br>  In such single-threaded synchronization contexts, it's pretty easy to get a deadlock.  If you create a task in a single-threaded context, and then you wait in the same context, your waiting code will block the execution of the background task. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// DEADLOCK:     //  ,        var data = GetDataAsync().Result; return View(data); } private async Task&lt;string&gt; GetDataAsync() { //     var result = await MyWebService.GetDataAsync(); return result.ToString(); }</span></span></code> </pre><br><br>  <b>Stability: do not use <code>Wait</code> to wait for the task to finish right here.</b> <br><br>  As a general rule, if you create asynchronous code, be careful with <code>Wait</code> .  (c <code>await</code> is somewhat better.) <br><br>  Do not use <code>Wait</code> for tasks in single-threaded synchronization contexts, such as: <br><ul><li>  UI Streams </li><li>  ASP.NET Context </li></ul><br>  The good news is that the framework allows you to return a <code>Task</code> in certain cases, and the framework itself will wait for the task to be completed.  Trust him this process: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;ActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    async/await   Task var data = await GetDataAsync(); return View(data); }</span></span></code> </pre><br>  If you are creating asynchronous libraries, your users will have to write asynchronous code.  Previously, this was a problem, since writing asynchronous code was tedious and vulnerable to errors, but with the advent of <code>async/await</code> much of the complexity is now handled by the compiler.  And your code gets more reliability, and now you are less likely to be forced to contend with the nuances of <code>ThreadPool</code> . <br><br>  <b>Stability: Consider using <code>ConfigureAwait</code> if you are creating a library.</b> <br><br>  If you <i>must</i> wait for a task <i>to</i> be executed in one of these contexts, you can use <code>ConfigureAwait</code> to tell the system that it should not perform a background task in your context.  The disadvantage of this is that the background task will not have access to the same synchronization context, so you will lose access to the Windows UI or <code>HttpContext</code> (although you will still have your security context). <br><br>  If you create a ‚Äúlibrary‚Äù function that returns a <code>Task</code> , you most likely do not know how it will be called.  So it may be safer to add <code>ConfigureAwait(false)</code> to your task before returning it. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ConfigureAwait(false)  ,   //        var result = await MyWebService.GetDataAsync().ConfigureAwait(false); return result.ToString(); }</span></span></code> </pre><br><br>  <b>Stability: understand how exceptions behave</b> <br><br>  When you look at an asynchronous code, it is sometimes hard to say what happens to exceptions.  Will it be passed to the calling function, or to the code that is waiting for the task to be completed? <br><br>  The rules in this case are quite straightforward, but still it is sometimes difficult to answer a question just by looking at the code. <br><br>  Some examples are: <br><ul><li>  Exceptions thrown from the async / await method itself will be sent to the code waiting for the task to complete (awaiter). <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContentsOfUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,  //    if (url == null) throw new ArgumentNullException(); var data = await MyWebService.GetContentsOfUrl(); return data.DoStuffToIt(); }</span></span></code> </pre><br></li><li>  Exceptions triggered from the <code>Task</code> delegate will also be sent to the code waiting for the task (awaiter). <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContentsOfUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task&lt;Data&gt;.Factory.StartNew(() =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      ,  //    if (url == null) throw new ArgumentNullException(); var data = await MyWebService.GetContentsOfUrl(); return data.DoStuffToIt(); } }</span></span></code> </pre><br></li><li>  Exceptions thrown during Task creation will be sent to the code that called this method (caller) (which is obvious in general): <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;Data&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContentsOfUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        if (url == null) throw new ArgumentNullException(); return Task&lt;Data&gt;.Factory.StartNew(() =&gt; { var data = await MyWebService.GetContentsOfUrl(); return data.DoStuffToIt(); } }</span></span></code> </pre><br></li></ul><br>  The last example is one of the reasons why I prefer <code>async/await</code> instead of creating task chains through <code>Task</code> . <br><br>  <b>Additional links</b> (in English) <br><ul><li>  MSDN: <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/04/12/10293335.aspx">Async / Await FAQ</a> </li><li>  About await optimization ‚Äú <a href="http://blogs.msdn.com/b/lucian/archive/2011/04/15/async-ctp-refresh-design-changes.aspx">fast track</a> ‚Äù </li><li>  MSDN: <a href="http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx">Await, and UI, and deadlocks!</a>  <a href="http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx">Oh my!</a> </li><li>  MSDN: <a href="http://msdn.microsoft.com/en-us/magazine/hh456402.aspx">Async Performance: Understanding the Costs of Async and Await</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/162353/">https://habr.com/ru/post/162353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162341/index.html">Features of working with time in different time zones</a></li>
<li><a href="../162343/index.html">Runetology (177): Levon Oganesyan, Founder of the Delivery Club</a></li>
<li><a href="../162345/index.html">AWS Insight: Reservations for EC2 - how it works</a></li>
<li><a href="../162347/index.html">Saving files from the Internet to Google Drive</a></li>
<li><a href="../162351/index.html">Broadcast Final Selection Skolkovo MD</a></li>
<li><a href="../162355/index.html">Retention, or why the user will return to the game? Continuation</a></li>
<li><a href="../162357/index.html">Translation of "ANSI Common Lisp" in electronic form</a></li>
<li><a href="../162359/index.html">Salary Survey Testers</a></li>
<li><a href="../162363/index.html">Mail.Ru rating: right on target</a></li>
<li><a href="../162365/index.html">As we celebrated "Halloween" '2012!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>