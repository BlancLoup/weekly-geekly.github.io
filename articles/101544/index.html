<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Versioning and data history</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing databases, it is often necessary to provide support for versioning and storing object history. For example, an employee may change pos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Versioning and data history</h1><div class="post__text post__text-html js-mediator-article">  When developing databases, it is often necessary to provide support for versioning and storing object history.  For example, an employee may change position, the position in turn may change salary - in multidimensional modeling this is called Slowly changing dimensions (hereinafter SCD) - rarely changing dimensions, that is, dimensions whose non-key attributes tend to change over time.  In total there are 6 main types (methods) of <abbr>SCD</abbr> , which determine how the history of changes can be reflected in the model. <br><br><a name="habracut"></a><br><br><h3>  Type 0 </h3><br>  It lies in the fact that the data after the first hit in the table further never change.  This method is practically not used by anyone, because  It does not support versioning.  It is needed only as a zero point of reference for the SCD methodology. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Type 1 </h3><br>  Type 1 is the usual rewriting of old data with new ones.  In its pure form, this method also does not contain versioning and is used only where history is not actually needed.  However, in some DBMS for this type, it is possible to add limited support for versioning by the means of the DBMS itself (for example, Flashback query in Oracle) or by tracking changes through triggers. <br><br><h5>  Advantages: </h5><ul><li>  No redundancy added </li><li>  Very simple structure </li></ul><br><h5>  Disadvantages: </h5><ul><li>  Does not store history </li></ul><br><br><h3>  Type 2 </h3><br>  This method consists in creating for each version a separate entry in the table with the addition of a key attribute field of this version, for example: version number, date of change, or date of beginning and end of the period of version existence. <br><br>  Example: <br><table border="1"><tbody><tr><th>  ID </th><th>  NAME </th><th>  POSITION_ID </th><th>  DEPT </th><th>  DATE_START </th><th>  DATE_END </th></tr><tr><td>  one </td><td>  Kolya </td><td>  21 </td><td>  2 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td></tr><tr><td>  2 </td><td>  Denis </td><td>  23 </td><td>  3 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td></tr><tr><td>  3 </td><td>  Boris </td><td>  26 </td><td>  2 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td></tr><tr><td>  four </td><td>  Sheldon </td><td>  22 </td><td>  3 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td></tr><tr><td>  five </td><td>  a penny </td><td>  25 </td><td>  2 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td></tr></tbody></table><br><br>  In this example, the default end date of the version is '01 .01.9999 ', instead of which one could specify, say, null, but then there would be a problem with creating the primary key from ID, DATE_START and DATE_END, and, moreover, The sampling condition for a specific date is simplified (" <code>where snapshot_date between DATE_START and DATE_END</code> " instead of " <code>where snapshot_date&gt;DATE_START and (snapshot_date &lt; DATE_END or DATE_END is null)</code> ". <br>  With such an implementation, when an employee leaves the company, it will be possible to simply change the end date of the current version to the date of dismissal instead of deleting employee records. <br><br><h5>  Advantages: </h5><ul><li>  Stores full and unlimited version history </li><li>  Convenient and easy access to the data of the required period </li></ul><br><h5>  Disadvantages: </h5><ul><li>  Provokes redundancy or the establishment of additional tables to store variable dimension attributes </li><li>  Complicates the structure or adds redundancy in cases where the analyst will need to reconcile the data in the fact table with specific measurement versions and the fact may not be consistent with the current version of the measurement for this fact. (For example, the client has changed audits or address, but operation / delivery by old values) </li></ul><br><br><h3>  Type 3 </h3><br>  The record itself contains additional fields for the previous attribute values.  When new data is received, old data is overwritten by current values. <br><br><table border="1"><tbody><tr><th></th><th>  ID </th><th>  UPDATE_TIME </th><th>  LAST_STATE </th><th>  CURRENT_STATE </th></tr><tr><td>  one </td><td>  one </td><td>  08/11/2010 12:58:48 </td><td>  0 </td><td>  one </td></tr><tr><td>  2 </td><td>  2 </td><td>  08/11/2010 12:29:16 </td><td>  one </td><td>  one </td></tr></tbody></table><h5>  Advantages: </h5><ul><li>  Small amount of data </li><li>  Easy and quick access to history </li></ul><br><h5>  Disadvantages: </h5><ul><li>  Limited history </li></ul><br><br><h3>  Type 4 </h3><br>  The change history is contained in a separate table: the main table is always overwritten with current data with old data transferred to another table.  Usually this type is used to audit changes or create archive tables (as I said, in Oracle, this same 4th type can be obtained from the 1st using the flashback archive).  A subtype or a hybrid of this option (with the second type), it seems to me, should be considered sectioned on the basis of the current version with the allowed movement of lines, but this is beyond the limits of modeling and rather refers to administration. <br><br>  Example: <br><blockquote><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> emp</code> </pre></blockquote><br><table border="1"><tbody><tr><th>  ID </th><th>  NAME </th><th>  POSITION_ID </th><th>  DEPT </th></tr><tr><td>  one </td><td>  Kolya </td><td>  21 </td><td>  2 </td></tr><tr><td>  2 </td><td>  Denis </td><td>  23 </td><td>  3 </td></tr><tr><td>  3 </td><td>  Boris </td><td>  26 </td><td>  2 </td></tr><tr><td>  four </td><td>  Sheldon </td><td>  22 </td><td>  3 </td></tr><tr><td>  five </td><td>  a penny </td><td>  25 </td><td>  2 </td></tr></tbody></table><br><br><blockquote><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> emp_history</code> </pre></blockquote><br><table border="1"><tbody><tr><th>  ID </th><th>  NAME </th><th>  POSITION_ID </th><th>  DEPT </th><th>  DATE </th></tr><tr><td>  one </td><td>  Kolya </td><td>  21 </td><td>  one </td><td>  08/11/2010 2:12:13 PM </td></tr><tr><td>  2 </td><td>  Denis </td><td>  23 </td><td>  2 </td><td>  08/11/2010 2:12:13 PM </td></tr><tr><td>  3 </td><td>  Boris </td><td>  26 </td><td>  one </td><td>  08/11/2010 2:12:13 PM </td></tr><tr><td>  four </td><td>  Sheldon </td><td>  22 </td><td>  2 </td><td>  08/11/2010 2:12:13 PM </td></tr></tbody></table><br><h5>  Advantages: </h5><ul><li>  Quick work with current versions </li></ul><br><h5>  Disadvantages: </h5><ul><li>  Splitting a single entity into different tables </li></ul><br><br><h3>  Hybrid Type / Type 6 (1 + 2 + 3) </h3><br>  Type 6 was coined by <a href="http://en.wikipedia.org/wiki/Ralph_Kimball">Ralph Kimball</a> as a combination of the above methods and is designed for situations that they do not take into account or for greater convenience of working with data.  It consists in introducing additional redundancy: a type 2 is taken as a basis, a surrogate attribute is added for an alternative version review (type 3), and one or all previous versions (type 1) are overwritten. <br>  Example: <br><table border="1"><tbody><tr><th>  VERSION </th><th>  ID </th><th>  NAME </th><th>  POSITION_ID </th><th>  DEPT </th><th>  DATE_START </th><th>  DATE_END </th><th>  CURRENT </th></tr><tr><td>  one </td><td>  one </td><td>  Kolya </td><td>  21 </td><td>  2 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td><td>  one </td></tr><tr><td>  one </td><td>  2 </td><td>  Denis </td><td>  23 </td><td>  3 </td><td>  08/11/2010 10:42:25 </td><td>  01/01/9999 </td><td>  one </td></tr><tr><td>  one </td><td>  3 </td><td>  Boris </td><td>  26 </td><td>  2 </td><td>  08/11/2010 10:42:25 </td><td>  08/11/2010 11:42:25 </td><td>  0 </td></tr><tr><td>  2 </td><td>  3 </td><td>  Boris </td><td>  26 </td><td>  2 </td><td>  08/11/2010 11:42:26 </td><td>  01/01/9999 </td><td>  one </td></tr></tbody></table><br><br>  In this example, for example, adding a surrogate key adds the ability to refer from the fact tables to a specific version of the dimension, which may not belong to the lifetime of the fact itself, and the indicator of the current version may help to partition by the current versions (although it would be better to call the latest version sectioning since the version may become outdated without changing the record itself).  However, the indicator of the current version can be created as a virtual computable field, without worsening normalization, if it is necessary in the table (if the DBMS supports such fields, they appeared in Oracle in the 11th version), and as a field in the view from this table. <br>  In general, any combination of basic types of SCD refers to a hybrid type, so both their disadvantages and advantages depend on your specific implementation, but one thing is sure - the choice of a hybrid type can only be due to the complexity of your model and almost always (in any case, I don‚Äôt know cases when it can be otherwise) you can get by with the main 4 types. <br><br>  Let me add a few tips on how to implement SCD: <br><ul><li>  Try to implement a mechanism for changing records in stored procedures - it is absolutely undesirable that the change code be scattered in different places, even if the change code is stored in clearly defined places in your external application; </li><li>  If you want to make a smooth transition from the 1st model to the second, you can do this: <br>  1) change the table by type 2 SCD with renaming, for example, in table_name_scd2 <br>  2) create an updated view with the name of the old table, which will produce data in the same structure as the old table; <br>  3) if you do not conduct all the changes in stored procedures (I hope this is temporary :)), which have already been changed, then create triggers that will fill in new fields in cases where they are not set by the query (when: new.start_date is null. ..) and log it in to make sure you changed everything </li><li>  In cases where the start and end version fields are used, in addition to using the primary key, which includes the object identifier and the version start and end dates, you will need to control the integrity to create a limit on non-intersection of version dates.  It is very good if your DBMS supports check constraints based on non-deterministic functions that allow you to do this (by the way, I would like to know which DBMS supports this), but if this is not the case, then you can check the condition in the trigger before creating or modifying and throw an exception in case of violation.  Example for Oracle: <br><blockquote><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> T_EMP_CHECK <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> emp <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> f_ok number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> f_ok <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> emp e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.id = :<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.date_start &lt;= :<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>.date_end <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.date_end &gt;= :<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>.date_start ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f_ok&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> DUP_VAL_ON_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> T_EMP_CHECK;</code> </pre></blockquote><br></li><li>  When moving from type 1 to type 4, you just need to create a before update trigger, in which you will store the records in a new table for archive records </li></ul><br><br>  Ps.  Habralyudi, share what interesting hybrid implementations you met? </div><p>Source: <a href="https://habr.com/ru/post/101544/">https://habr.com/ru/post/101544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../101534/index.html">As users Desire Vodafone hats poured</a></li>
<li><a href="../101535/index.html">Project management systems. Looking for alternatives to Basecamp</a></li>
<li><a href="../101539/index.html">University editors will learn to use statistics</a></li>
<li><a href="../101540/index.html">Health and coding - how to combine?</a></li>
<li><a href="../101541/index.html">Who gets funding for Internet startups?</a></li>
<li><a href="../101545/index.html">Granin. This strange life</a></li>
<li><a href="../101547/index.html">Plugin system example</a></li>
<li><a href="../101548/index.html">Toshiba Media Controller - now for Apple iPhone and iPod touch users</a></li>
<li><a href="../101549/index.html">IPhone Fourth is afraid of heat</a></li>
<li><a href="../101550/index.html">Interviews with Techdays winners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>