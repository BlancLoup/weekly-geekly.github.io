<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A bunch of different ways to read bits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Renewing the old tradition of my blog, I will take a simple task, consider an excessively long list of its alternative solutions and assess their meri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A bunch of different ways to read bits</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/094/650/be3/094650be328b83fc62b0a9bd6e8792c3.png" alt="image"></div><br>  Renewing the old tradition of my blog, I will take a simple task, consider an <em>excessively</em> long list of its alternative solutions and assess their merits. <br><br>  Our simple task will be the following: we want to read data from a byte stream, values ‚Äã‚Äãencoded with a variable number of bits.  Read individual bytes, machine words, etc.  directly supported by most processors and many programming languages, but with variable-length input / output, it is usually necessary to implement the solution yourself. <br><br>  It sounds simple enough, and in a sense it is.  The first source of problems is that this operation will actively use codecs - and yes, it will be limited to calculations, and not memory and I / O.  Therefore, we need not just a working, but also an effective implementation.  And on the way, we will face many other difficulties: interactions with I / O buffering, processing the end of the buffer, deadlocks in bit shifts defined in C / C ++ and in different processor architectures, as well as other features of bit shifts. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This post will mainly focus on a variety of different ways to implement the reader;  in fact, all the techniques considered here are similarly applicable to the recording part, but I do not want to double the number of variations of the algorithms.  They will be enough. <br><a name="habracut"></a><br><h3>  Degrees of freedom </h3><br>  ‚ÄúConsider a variable number of bits‚Äù is an insufficient description of the task.  There are many acceptable ways of packing bits into bytes, and all of them have their strengths and weaknesses, which I will discuss later.  For now let's just dwell on their differences. <br><br>  First we need to make the first important choice - the fields will be packaged as ‚Äúfirst goes MSB‚Äù or ‚Äúfirst goes LSB‚Äù (‚Äúmost significant bit‚Äù is the most significant bit and ‚Äúleast significant bit‚Äù is the least significant bit).  That is, if we call the implemented function <code>getbits</code> and execute the following code <br><br><pre> <code class="cpp hljs">a = getbits(<span class="hljs-number"><span class="hljs-number">4</span></span>); b = getbits(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  for the just-opened bitstream, we expect both values ‚Äã‚Äãto be received from the same byte, but how are they ordered in this byte?  If packaged as MSB-first, then ‚Äúa‚Äù occupies 4 bits, starting with MSB, and ‚Äúb‚Äù is below ‚Äúa‚Äù, which leads us to the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/785/5a4/de6/7855a4de6a0ad03c71fbe66c87d91499.png"></div><br>  I number the bits like this: LSB is 0 and approaching MSB, the values ‚Äã‚Äãincrease.  In many contexts, this order is standard.  LSB-first is the opposite: the first field is bit 0, and the following fields contain increasing numbers of bits: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/859/c34/8dd859c3414c505d544c421a7c3846ba.png"></div><br>  Both formats are used in common file formats.  For example, JPEG uses bit packing in the bit stream in the MSB-first format, and DEFLATE (zip) uses LSB-first. <br><br>  The next question we need to solve is what happens when the value is stretched a few bytes.  Suppose we have one more ‚Äúc‚Äù value that we want to encode in 5 bits.  What we get as a result?  We can slightly delay the solution of the problem by declaring that we are packing the values ‚Äã‚Äãinto 32-bit or 64-bit words, not bytes, but in the end we have to choose something.  And here we are suddenly faced with a variety of different options, so I will consider only the main applicants. <br><br>  We can perceive the packing of MSB-first bits as an iteration over the ‚Äúc‚Äù bit field from its MSB towards the LSB, with insertion one bit at a time.  Filling one byte, we proceed to the next.  If you follow these rules for our bit field c, then the result in our stream bits will be in the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f59/963/cbc/f59963cbc59280495e01b2925f7f7b38.png"></div><br>  Keep in mind that following these rules, we end up with the same two bytes that we would get by wrapping the MSB bits into a large integer and storing it in big-endian order.  If we instead decided to break the ‚Äúc‚Äù in such a way that its LSB is in the first byte, and its four bits of a higher order are in the second byte, it would not work.  I will call such consistent rules for packing bits "natural" rules. <br><br>  Of course, the LSB-first bit packing has its own natural rule.  It consists in inserting a new value bit by bit, starting from LSB and up, and if we do that, we will get the following bit stream as a result: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ed/9d9/fde/6ed9d9fde50537d9ba7718ba178100b3.png"></div><br>  The LSB-first natural package gives us the same bytes as the LSB-first package in a large integer, saving it in little-endian byte order.  In addition, we have obvious clumsiness in the figure: the logical conjugate packing of the ‚Äúc‚Äù field in several bytes looks interrupted on this picture, while the MSB-first packing pattern looks as we expected.  But the problem also arises in it: in the MSB-first pattern, we number the bits in the increasing order from right to left (standard), and the bytes in the order increasing from left to right (which is also standard). <br><br>  This is what happens with the LSB-first bit scheme if we draw bit 0 (LSB) in each byte to the <em>left</em> , and bit 7 (MSB) to the right: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/a63/3b3/84fa633b310377f061503f1be1f52090.png"></div><br>  If we draw it like this, the scheme will look like the way we expected.  The location of the MSB on the right seems strange if you think of a byte as a number, but it turns out to be much less strange if you think of it as an array of 8 bits (as we, in fact, work with it when performing bitwise I / O). <br><br>  Coincidentally, in some big-endian architectures (for example, in IBM POWER), the bits are numbered as follows ‚Äî bit 0 is MSB, bit 31 (or 63) is LSB.  By creating an MSB-first bit packing scheme on such a machine with a bit of 0 = MSB, and numbering our own bit fields so that their bit 0 matches the MSB, we get exactly the same scheme (but this will mean that something is slightly different ).  This standard makes the order of bits and bytes consistent (which is good), but destroys the convenient standard of matching the <em>k</em> bit to 2 <sup>k</sup> (which is not exactly good). <br><br>  And if the idea of ‚Äã‚Äãrenumbering bits in such a way that bit 0 is MSB explodes your brain, you can leave the numbering of bits unchanged, but become a rebel and draw the byte addresses increasing on the left.  Or increase the address to the right, but become a slightly different rebel and write the byte stream in reverse order.  If you choose one of these options, we get the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/094/650/be3/094650be328b83fc62b0a9bd6e8792c3.png"></div><br>  I understand that this is already beginning to confuse, and I‚Äôll stop at this, but here it‚Äôs necessary to say something important: you shouldn‚Äôt become too attached to the method of getting bytes.  It is easy to be deceived when deciding that one option is better than another simply because it looks better, but the standards for getting the bytes from left to right and the bits inside them from right to left are completely arbitrary, so whatever you choose, you end up with something strange. <br><br>  It turns out that each of the MSB-first and LSB-first packaging standards has its advantages and disadvantages, and it would be much more useful to think of them as tools with different application areas, rather than designating one of them as ‚Äúright‚Äù and others as ‚Äúwrong‚Äù.  Regarding the byte order and the need to pack values ‚Äã‚Äãinto bytes, words or something larger, I highly recommend you use the most natural order for your bit packing standard: MSB-first naturally corresponds to big-endian byte order, and LSB -first naturally corresponds to little-endian byte order.  Unless you are writing byte streams in the reverse order (believe it or not, there are logical reasons for doing this);  in this case, we get MSB-first in reverse order, corresponding to little-endian, and LSB-first in reverse order, corresponding to big-endian. <br><br>  The reason for choosing the ‚Äúnatural‚Äù order is that they give us more freedom in different implementations.  A stream with a natural order allows the use of many different decoders (and coders), each of which has its own trade-offs (and its own advantages in different cases).  ‚ÄúUnnatural‚Äù orders are usually applied with one particular implementation and, when decoded in any other way, prove to be very inconvenient. <br><br><h3>  Our first <code>getbits</code> (bit extraction) </h3><br>  Now that we have sufficiently described the problem, we can implement a solution.  A particularly simple version is possible if we assume that the entire bitstream is located in memory sequentially (as an array of bytes), and so far completely ignore the unpleasant problems like hitting the end of the array.  Let's just pretend that it is infinite!  (Either huge enough or has zero filling around the edges.) <br><br>  In this case, we can base the implementation on a purely functional ‚Äúbit extraction‚Äù function, in which I will illustrate the problems that arise and all the various bit-reading functions.  Let's start by packing the LSB-first bits: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  buf[]    integer little-endian,  "width" // ,     "pos" (LSB= 0). uint64_t bit_extract_lsb(const uint8_t *buf, size_t pos, int width) { assert(width &gt;= 0 &amp;&amp; width &lt;= 64 - 7); //  64-  little-endian,   , //    "pos" ( "buf"). uint64_t bits = read64LE(&amp;buf[pos / 8]); //     ,  //   . //   LSB     LSB . bits &gt;&gt;= pos % 8; //   "width" ,      . return bits &amp; ((1ull &lt;&lt; width) - 1); } //  ,    //  - . const uint8_t *bitstream; //    size_t bit_pos; //      . uint64_t getbits_extract_lsb(int width) { //   uint64_t result = bit_extract_lsb(bitstream, bit_pos, width); //   bit_pos += width; return result; }</span></span></code> </pre> <br>  We simply took advantage of the fact mentioned above that the LSB-first bit stream is just a big number little-endian.  First we get 64 contiguous bits arranged in bytes, starting with the first byte containing any of the bits we are interested in, right shift to get rid of the remaining 0-7 extra bits below the first bit we need, and then return the result masked to the desired width. <br><br>  Depending on the value of <code>pos</code> , this shift to the right can cost us an additional 7 bits.  Therefore, although we read the full 64 bits, the maximum amount that we can read at one time using this code is 64-7 = 57 bits. <br><br>  With <code>bitextract</code> , we can easily implement <code>getbits</code> ;  we simply track the current position of the bitstream (in bits), and execute its increment after reading. <br><br>  The corresponding option for MSB-first is quite similar, with the exception of one annoying problem, which I will discuss after demonstrating the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  buf[]    integer big-endian,  "width" // ,     "pos" (MSB= 0). uint64_t bit_extract_msb(const uint8_t *buf, size_t pos, int width) { assert(width &gt;= 1 &amp;&amp; width &lt;= 64 - 7); //  64-  big-endian,   , //    "pos" ( "buf"). uint64_t bits = read64BE(&amp;buf[pos / 8]); //     ,    . //   MSB      MSB . bits &lt;&lt;= pos % 8; //   "width" . return bits &gt;&gt; (64 - width); } uint64_t getbits_extract_msb(int width) { //   uint64_t result = bit_extract_msb(bitstream, bit_pos, width); //   bit_pos += width; return result; }</span></span></code> </pre> <br>  This code works similarly to the previous one: we read 64 contiguous bits arranged in bytes (this time big-endian), we shift <em>left</em> to even the top of the bit field we need with MSB <code>bits</code> (while earlier we did <em>right</em> shift to align bottom of our bit field with LSB <code>bits</code> ), and then make a shift to the right to position the top <code>width</code> bits below to return them, because when we call <code>getbits(3)</code> we usually expect to see a value from 0 to 7. <br><br><h3>  Boundary cases of shifts </h3><br>  So what's the problem?  This version of the code does not allow the <code>width</code> be zero.  The problem is that if we allow <code>width == 0</code> to be done, then the final shift will try to shift the 64-bit value to 64 bits to the right, and in C / C ++ this is undefined behavior!  In this case, we can perform a shift of 0-63 bytes. <br><br>  In some cases, C / C ++ leaves details undefined for backward compatibility with machines, so no one cares about that right now.  A well-known example: the absence of the requirement that the representation of signed numbers use an additional code;  Although there are architectures without additional code, all of them today are preserved only in museums. <br><br>  Unfortunately, we have not one of these cases.  This is what happens on various widely used CPU architectures when the amount of shift is outside the range: <br><br><ul><li>  For 32-bit x86 and x86-64, the shift values ‚Äã‚Äãare interpreted as mod 32 for operand widths of 32 bits and lower, and mod 64 for 64-bit operands.  That is, a shift to the right of a 64-bit value by 64 will result in the same as a shift by 0, i.e.  no operation (no-op). </li><li>  In 32-bit ARM (A32 / T32 instruction sets), the shift value is taken mod 256. A right shift of a 32-bit value by 32 (or 64) will result in 0, as well as a right shift by 255, but a right shift by 256 will leave the value intact . </li><li>  In 64-bit ARM (A64 ISA), mod 32 for 32-bit shifts and mod 64 for 64-bit shifts are taken (essentially as in x86-64). </li><li>  RISC-V also follows the same rule: distances of 32-bit shifts are taken as mod 32, distances of 64-bit shifts - as mod 64. </li><li>  In POWER / PowerPC, 32-bit shifts take the mod 64 shift value, and 64-bit shifts take the mod 128 shift value. </li></ul><br>  To confuse us even more, most of these instruction sets have SIMD extensions, and integer SIMD instructions have a different behavior when shifting outside the interval, different from non-SIMD instructions.  In short, this is one of those times when there are architectural differences between popular platforms;  For most of you, POWER and RISC-V may seem a bit outdated, but, say, 32-bit and 64-bit ARMs are currently installed on hundreds of millions of devices. <br><br>  Consequently, even if everything that the compiler does with this shift to the right - it gives the corresponding shift instruction to the right for the target architecture (and usually it does), then we will see different behavior on different architectures.  On ARM A64 and x86-64, the shift result by 64 is essentially no-op, and <code>getbits(0)</code> will therefore (usually) return a non-zero value, although you should expect zero to return. <br><br>  Why is this so important?  Of course, the <code>getbits(0)</code> in the code is not an interesting use case;  however, sometimes we need to <code>getbits(x)</code> for some variable x, where x in some cases can be zero.  In this case, it would be great if the code just worked and did not require any special checks. <br><br>  If you want this case to work, then one option is to explicitly check for <code>width == 0</code> and handle this in a special way;  Another option would be to use a non-branching expression that works with zero widths, for example, this code used in <a href="">FSE</a> <a href="http://fastcompression.blogspot.com/">Jenna Collet</a> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   "width" ,     width==0. return (bits &gt;&gt; 1) &gt;&gt; (63 - width);</span></span></code> </pre> <br>  This particular case is easier to handle for LSB-first bitstreams.  And since I mentioned them, let's talk about the operation of using a mask, which I applied to isolate the lower <code>width</code> bits: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   "width" ,      . return bits &amp; ((1ull &lt;&lt; width) - 1);</span></span></code> </pre> <br>  There is a similar form that is slightly less expensive in architectures with a three-instruction and-with-complement (AND-NOT) instruction.  These include many RISC CPUs, as well as x86s with <a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI1</a> .  Namely, we can take a mask of all bits-units, shift left to add <code>width</code> zeros to the bottom, and then add everything: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bits &amp; ~(~<span class="hljs-number"><span class="hljs-number">0u</span></span>ll &lt;&lt; width);</code> </pre> <br>  If you have x86 not only with BMI1, but also with BMI2 support, you can also use the <code>BZHI</code> instruction, specially created for this case, if you figure out how to get the compiler to give it (or use an assembler).  Another option that in some cases would be preferable is to simply prepare a small bitmask lookup table, which simplifies the code to this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bits &amp; width_to_mask_table[width];</code> </pre> <br>  Preparing a lookup table storing the result of two integer operations may seem like a ridiculous action, especially because calculating the address of the loaded table element usually involves both shifting and adding ‚Äî exactly the same operations that we would have done if we hadn't tables!  - but there is a method in this madness: the calculation of the required address can be performed as part of the memory access in one load instruction, for example, on machines with x86 and ARM, therefore <em>these</em> shift and addition are calculated in the Address Generation Unit (AGU) as part of the loading pipeline in the CPU, and not with instructions for integer arithmetic and shift.  That is, such a counterintuitive solution of replacing two integer ALU instructions with a single instruction of loading an integer can lead to a significant acceleration of code with active bit I / O, because it balances the load between different operating units better. <br><br>  Another interesting property is that the LSB-first version using the mask lookup table performs one shift by a variable (to shift the bits already read).  This is important, because for many (often trivial!) Reasons, in many micro-architectures, shifts of integers by variables are more costly than shifts by constant values ‚Äã‚Äãof compile time.  For example, Cell PPU / Xbox 360 Xenon was notorious for having shifted by a variable distance, slowing down the processor core for a terribly long time - 12 cycles, and the usual shifts were built into the pipeline and performed in two cycles.  On many Intel x86 microarchitectures, ‚Äútraditional‚Äù x86 shifts ( <code>SHR reg, cl</code> and the like) are three times more expensive than shifts by the compile time constant. <br><br>  It seems that this is another reason for rejecting the MSB-first option: the above options perform two or three shifts per bit extraction operation, two of which have a variable distance.  But there is a trick by which you can return to a single shift operation, namely using a cyclic instead of the usual shift: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  buf[]    integer big-endian,  "width" // ,     "pos" (MSB= 0). uint64_t bit_extract_rot(const uint8_t *buf, size_t pos, int width) { assert(width &gt;= 0 &amp;&amp; width &lt;= 64 - 7); //  64-  big-endian,   , //    "pos" ( "buf"). uint64_t bits = read64BE(&amp;buf[pos &gt;&gt; 3]); //   ,        LSB. bits = rotate_left64(bits, (pos &amp; 7) + width); //   "width" . // (   ,       //      - LSB-first.) return bits &amp; width_to_mask_table[width]; }</span></span></code> </pre> <br>  Here, turning left (you have to figure out for yourself how best to use it in your C compiler) first performs the work of the original left shift, and then turns to additional ‚Äúwidth‚Äù bits to make the bit field roll from the most significant bits of the value to the least significant ,         ,     LSB-first. <br><br> , ,       8     3,  mod-8      AND  7.   ,         ,      . <br><br>        ( RAD Game Tools)     Cell PPU  Xbox 360,  ,           .  ,         <code>width == 0</code> ;   ‚Äî     ,   (  )   ,           C. <br><br>           ,        .           -:    ‚Äî    ,    ,    ,           ,     ,   ,                   ! <br><br> ,              ,    .    ¬´ ¬ª     ,     ,        . <br><br>       ,      ,    (     ).       <code>getbits</code>  -    .     . <br><br><h3>  1:        </h3><br>  -¬´¬ª ,        .      ;     ,    ,          ,   . <br><br>               ,        .       ,    ¬´ ¬ª: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        //  ,    . uint64_t bitbuf = 0; //     int bitcount = 0; //    </span></span></code> </pre> <br>             ,   ,        . <br><br>         <code>getbits</code> ,      ,       MSB-first: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// :  "bitbuf"  "bitcount" ,   // MSB  ;    "bitbuf" -  0. uint64_t getbits1_msb(int count) { assert(count &gt;= 1 &amp;&amp; count &lt;= 57); //    ,       // Big endian;      , //    . while (bitcount &lt; count) { bitbuf |= (uint64_t)getbyte() &lt;&lt; (56 - bitcount); bitcount += 8; } //      ;   // "count"   "bitbuf"   . uint64_t result = bitbuf &gt;&gt; (64 - count); //       bitbuf &lt;&lt;= count; bitcount -= count; return result; }</span></span></code> </pre> <br>   ,      <code>count</code> ‚â•1,     ,     .       ;  ,   ,     -  ,       . <br><br>    :   ,         .  ,         ,       .  ,  <code>getbyte()</code>      <a href="https://fgiesen.wordpress.com/2011/11/21/buffer-centric-io/">  -</a> ,           ;    ,  <em></em>      - .     8   ,         57 ;    ,      ,      . <br><br>      <code>count</code>   ,    .      ,       MSB . <br><br>   ,           ,    ¬´¬ª (refill), ¬´¬ª (peek)  ¬´¬ª (consume).  ¬´¬ª ,        ; ¬´¬ª      ,   ,  ¬´¬ª  ,    .       ;  ,    ,     LSB-first,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// :  "bitbuf"  "bitcount" ,   // LSB   ;    "bitbuf" -  0. void refill1_lsb(int count) { assert(count &gt;= 0 &amp;&amp; count &lt;= 57); //      . while (bitcount &lt; count) { bitbuf |= (uint64_t)getbyte() &lt;&lt; bitcount; bitcount += 8; } } uint64_t peekbits1_lsb(int count) { assert(bit_count &gt;= count); return bitbuf &amp; ((1ull &lt;&lt; count) - 1); } void consume1_lsb(int count) { assert(bit_count &gt;= count); bitbuf &gt;&gt;= count; bitcount -= count; } uint64_t getbits1_lsb(int count) { refill1_lsb(count); uint64_t result = peekbits1_lsb(count); consume1_lsb(count); return result; }</span></span></code> </pre> <br>  <code>getbits</code>          . ,         MSB-first,  ,       <code>peekbits</code>  <code>consume</code> ;        .          ,            ,   -   . <br><br><h3>   </h3><br>     ‚Äî       .      : ,      ,    : <br><br><pre> <code class="cpp hljs"> a = getbits(<span class="hljs-number"><span class="hljs-number">4</span></span>); b = getbits(<span class="hljs-number"><span class="hljs-number">3</span></span>); c = getbits(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  <code>getbits</code>  ,  ,      (    )   .   ;   ,    4+3+5=12    ,      : <br><br><pre> <code class="cpp hljs"> refill(<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>); a = getbits_no_refill(<span class="hljs-number"><span class="hljs-number">4</span></span>); b = getbits_no_refill(<span class="hljs-number"><span class="hljs-number">3</span></span>); c = getbits_no_refill(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  <code>getbits_no_refill</code> ‚Äî     getbits,   <code>peekbits</code>  <code>consume</code> , ,    ,  .           <code>getbits</code> ,        ,    .  ,     ;    ,    ,        , ,  : <br><br><pre> <code class="cpp hljs"> temp = getbits(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">28</span></span>) result = temp; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = <span class="hljs-number"><span class="hljs-number">28</span></span> + (temp - <span class="hljs-number"><span class="hljs-number">28</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span> + getbits(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>      ,    0  27   5 ,    28  91   9 .   ,        ,      .   ,    9 ,      ,      : <br><br><pre> <code class="cpp hljs"> refill(<span class="hljs-number"><span class="hljs-number">9</span></span>); temp = getbits_no_refill(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">28</span></span>) result = temp; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = <span class="hljs-number"><span class="hljs-number">28</span></span> + (temp - <span class="hljs-number"><span class="hljs-number">28</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span> + getbits_no_refill(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>   ,  ,          ,         ( <code>consume</code> ) . ,     MSB-first,       : <br><br><pre> <code class="cpp hljs"> refill(<span class="hljs-number"><span class="hljs-number">9</span></span>); temp = peekbits(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">28</span></span>) { result = temp; consume(<span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ""  ""     , //      ! ! result = getbits_no_refill(9) - 28*16 + 28; }</span></span></code> </pre> <br>   <em></em>       ,     ,       ,              .         (,  )                .    ,           (..         ).  <em></em> ,     -            ( ,          .) <br><br>    .        ,    ,  ,      :    <code>getbits</code>        .           ,      9 ,        5 .    ,   ,           . <br><br>      <em>lookahead</em> .           ,      .     ,     ,             ;  ,         . ,            ;            . <br><br>      ,    -   .   : <br><br><ul><li>          -  , ,         -  .    ,     . </li><li>     ,    ,    <code>getbits</code> , ,      (  -  ,    );                  ,    -     (   ). </li><li>    ,          lookahead    ,        ,    . ,    64-  ,    ,       - 8-  (,    - ).         ,          ,    . </li><li>   ,    -,   ,       ,         .  ,    lookahead          ,        ,     .  ,       C <a href="http://pubs.opengroup.org/onlinepubs/009696899/functions/ungetc.html"><code>ungetc</code></a> ,      <code>ungetc</code>   ,     .             -. </li></ul><br>      ‚Äî     ,      :     -   ‚Äî   ;    -    ‚Äî   ,      -       .      ,     .     <a href="https://fgiesen.wordpress.com/2011/11/21/buffer-centric-io/"></a>  <a href="https://fgiesen.wordpress.com/2016/01/02/end-of-buffer-checks-in-decompressors/"> </a> ,     ;      , ,  <code>bitcount</code>         .    ,     lookahead,      - .   ,    ,       . <br><br><h3>  2:   <em></em>   64    </h3><br>       ,      .        64 ,        7 ,       ,    <code>getbits1</code>         ;      57 ,         (     65 ,    ),    ,   <code>getbits1</code> . 57  ‚Äî    ,       32- ,      25  (32-7),     ,   . <br><br>  ,     ,     (          MSB-first,     RAD). ,           MSB-first  LSB-first,        .   LSB-first: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// : "bitbuf"  "bitcount" ,   // LSB  ; 1 &lt;= bitcount &lt;= 64 uint64_t bitbuf = 0; //     int bitcount = 0; //     uint64_t lookahead = 0; //  64  bool have_lookahead = false; //   ,   ! void initialize() { bitbuf = get_uint64LE(); bitcount = 64; have_lookahead = false; } void ensure_lookahead() { //   lookahead,  //     . if (!have_lookahead) { lookahead = get_uint64LE(); have_lookahead = true; } } uint64_t peekbits2_lsb(int count) { assert(bitcount &gt;= 1); assert(count &gt;= 0 &amp;&amp; count &lt;= 64); if (count &lt;= bitcount) { //    buf return bitbuf &amp; width_to_mask_table[count]; } else { ensure_lookahead(); //   bitbuf  lookahead // ( lookahead      buf) uint64_t next_bits = bitbuf; next_bits |= lookahead &lt;&lt; bitcount; return next_bits &amp; width_to_mask_table[count]; } } void consume2_lsb(int count) { assert(bitcount &gt;= 1); assert(count &gt;= 0 &amp;&amp; count &lt;= 64); if (count &lt; bitcount) { // -   buf //    bitbuf &gt;&gt;= count; bitcount -= count; } else { //    buf  ensure_lookahead(); //      lookahead int lookahead_consumed = count - bitcount; bitbuf = lookahead &gt;&gt; lookahead_consumed; bitcount = 64 - lookahead_consumed; have_lookahead = false; } assert(bitcount &gt;= 1); } uint64_t getbits2_lsb(int count) { uint64_t result = peekbits2_lsb(count); consume2_lsb(count); return result; }</span></span></code> </pre> <br>     ,    ,       <em></em>  .      ,      ,           ,      PC.  , ,     <code>width_to_mask_table</code> ,      :   ,           ,      0-64  <code>width</code>   64- ,  IBM POWER.      ,        , , ,  . <br><br>      :         .  ,       64- ,      <code>peekbits</code> ,    64-     (    <code>get_uint64LE()</code> ),   ,    . , <code>consume</code> ,          <code>width</code> .  ,        lookahead (     ,   )    <code>have_lookahead</code> ,  ,    lookahead      . <br><br>     ,        (   ). , ,  <code>peekbits</code>  <code>count &lt;= bitcount</code> ,       ,  <code>consume</code>  <code>count &lt; bitcount</code> .   :  <code>next_bits</code>  <code>peekbits</code>       <code>bitcount</code> .      ,  <code>bitcount</code> &lt; <code>count</code> ‚â§ 64,   <code>bitcount &lt; 64</code>    .  <code>consume</code>  :     <code>lookahead_consumed = count - bitcount</code> . ,  , ,  <code>lookahead_consumed</code> ‚â• 0;   ,  <code>count</code>   64,  <code>bitcount</code>   1,    <code>lookahead_consumed</code> ‚â§ 64 ‚Äì 1 = 63.  ,   , ¬´     ;      ,    ¬ª. <br><br>     ,      : ,        64- uint.    1    ,    ;    ,    ,         .    ,       ,        ,     , ,     RISC. <br><br>  ,    ,     . ,     ,      ,        <code>have_lookahead</code> ;        lookahead,        lookahead. <br><br><h3>  3:     </h3><br>           .      ,        ,        refill/peek/consume,   - .       ,    (    ),   .       MSB: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bitptr; <span class="hljs-comment"><span class="hljs-comment">//     uint64_t bitbuf = 0; //    64  int bitpos = 0; //       void refill3_msb() { assert(bitpos &lt;= 64); //        bitptr += bitpos &gt;&gt; 3; //  (Refill) bitbuf = read64BE(bitptr); //     ,     // (     ;   , //     .) bitpos &amp;= 7; } uint64_t peekbits3_msb(int count) { assert(bitpos + count &lt;= 64); assert(count &gt;= 1 &amp;&amp; count &lt;= 64 - 7); //       uint64_t remaining = bitbuf &lt;&lt; bitpos; //   "count"  return remaining &gt;&gt; (64 - count); } void consume3_msb(int count) { bitpos += count; }</span></span></code> </pre> <br>       <code>getbits</code> ,    refill / peek / consume,      ,      . <br><br>    .          ¬´refill¬ª  ¬´peek¬ª/¬´consume¬ª,   ,       .  ,   !  ,   64-  big-endian     (      x86  ARM).  ,         ; .     ¬´lookahead¬ª. <br><br><h3>  4:   lookahead </h3><br>       lookahead  .   ,        RAD          Kraken ( <b>:</b>     Yann,      Xpack       Kraken.     , ,    ,   ,          .        ‚Äî  .  <a href="https://fgiesen.wordpress.com/2018/02/20/reading-bits-in-far-too-many-ways-part-2/"> </a> ).       (   ,        refill   ),        (     ,        ),         ;  -   ,       ,     ! ,      LSB-first,      ,   LSB-first/MSB-first   ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bitptr; <span class="hljs-comment"><span class="hljs-comment">//        buf uint64_t bitbuf = 0; //     int bitcount = 0; //     void refill4_lsb() { //          //   . bitbuf |= read64LE(bitptr) &lt;&lt; bitcount; //       bitptr += (63 - bitcount) &gt;&gt; 3; //     bitcount |= 56; // now bitcount is in [56,63] } uint64_t peekbits4_lsb(int count) { assert(count &gt;= 0 &amp;&amp; count &lt;= 56); assert(count &lt;= bitcount); return bitbuf &amp; ((1ull &lt;&lt; count) - 1); } void consume4_lsb(int count) { assert(count &lt;= bitcount); bitbuf &gt;&gt;= count; bitcount -= count; }</span></span></code> </pre> <br>      peek  consume,          -       56 . <br><br>    refill,        .  64  little-endian                .    <code>bitptr</code> / <code>bitcount</code>  . <br><br>    <code>bitcount</code> .  ,    ,  refill      57  64 .      ,      56  63  (      ).  But why?     ,    refill <code>bitcount</code>    - ,  8;  ,  <code>bitcount &amp; 7</code> ( 3 )  .     refill,   [56,63]   ,          OR. <br><br>      :      ?        <code>bitcount</code> : <br><br><ul><li>  56 ‚â§ <code>bitcount</code> ‚â§ 63,               . </li><li>  48 ‚â§ <code>bitcount</code> ‚â§ 55,     1  (   <code>bit_ptr</code>    ). </li><li>  40 ‚â§ <code>bitcount</code> ‚â§ 47,     2 . </li></ul><br>   .    <code>(63 - bitcount) &gt;&gt; 3</code> ,     <code>bitptr</code> . <br><br>    <code>bitbuf</code>  <code>bitcount</code>  OR     .    ,     OR      ,     . ,       (-     consume),      ;        . <br><br>  ,   ,      ?     , ,    3? <br><br>    :    ,     <code>refill</code> ,       <code>bitcount</code> .   ,          <em></em> refill.            .     ,      L1,      (  3-5 ,          ),    <code>bitcount</code>    -       (.     ,    ). <br><br>      <code>bitcount</code> ,   ,             refill;              ,      load    ISA (,      MSB-first  little-endian ).  ,     <code>bitcount</code> ,  ,     ,      . <br><br>    ,      refill  ,        .      2016         Kraken-,        10% (    refill  ,   ). </div><p>Source: <a href="https://habr.com/ru/post/359122/">https://habr.com/ru/post/359122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../359110/index.html">New attack technique based on Meltdown. Using speculative instructions for detecting virtualization</a></li>
<li><a href="../359114/index.html">What is business: a conversation on concepts</a></li>
<li><a href="../359116/index.html">Reverse engineering of the device firmware on the example of a flashing "rhino". Part 1</a></li>
<li><a href="../359118/index.html">It's time to grow up for IT communities: why do we gather activists at RHS?</a></li>
<li><a href="../359120/index.html">Experiments with kube-proxy and node unavailability in Kubernetes</a></li>
<li><a href="../359124/index.html">TOTAL 3 months: Alternative to paid shutdown of advertising in the free Android application</a></li>
<li><a href="../359130/index.html">How we made a highload ++ game with voxel graphics and VR</a></li>
<li><a href="../359132/index.html">Go 1.11: AVX-512 with Go</a></li>
<li><a href="../359134/index.html">How to write a decentralized multiblockchein exchange in a day</a></li>
<li><a href="../359136/index.html">Machine learning and a polypropylene extruder: history 3 places on the hakatone Sibur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>