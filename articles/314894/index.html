<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Many JS packages in one repository</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Not so long ago, we began to develop a comprehensive project that has or plans several types of front-end, many back-end services, command line...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Many JS packages in one repository</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/463/9d9/d54/4639d9d543994917b17cc4aad8f1d96c.jpg" alt="image"></p><br><p>  Hello!  Not so long ago, we began to develop a comprehensive project that has or plans several types of front-end, many back-end services, command line interface, demons, and a lot more.  All this, in turn, has a sharp code, and completely new applications should be possible to assemble from existing bricks in a simple and understandable way. </p><br><p>  If you don‚Äôt get bored with the terminology, we make a platform.  Platform for visual programming for DIY-electronics. </p><br><p>  Despite the fact that the project is at an early stage, the code base has already threatened to turn into a mush.  To do this, we transferred the project to the so-called monorepo-approach.  On Habr√© there were no materials on this topic, so I will try to fill the gap. </p><a name="habracut"></a><br><h2>  What was at the beginning </h2><br><p>  It all started pretty traditional.  Our repository looked like this: </p><br><pre><code class="hljs pgsql">dist/ node_modules/ src/ assets/ components/ containers/ reducer/ actions.js actionTypes.js constants.js test/ package.json</code> </pre> <br><p>  Those who deal with the React + Redux stack will instantly recognize the pattern.  The <code>src/</code> front-end source code is located; by a command, they are collected by the Webpack into <code>dist/</code> wherefrom the front-end can be served as a simple static. </p><br><h2>  Expanding </h2><br><p>  Such a structure works well if the application is not very large.  But we quickly got a lot of React-components and containers, Redux-reducers and-actions, which began to crowd in their directories. </p><br><p>  The semantic division into groups suggested itself: something was responsible for rendering the graph of the user‚Äôs program, something for editing tools of this graph, something for navigating through files and tabs, something for displaying informational messages, etc. </p><br><p>  It's time to share.  At this point, there was a choice in front of two generally accepted approaches of separation. </p><br><p>  Rails style: </p><br><pre> <code class="hljs mel">src/ components/ project/ projectBrowser/ <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>/ messages/ containers/ project/ projectBrowser/ <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>/ messages/ reducers/ project/ projectBrowser/ <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>/ messages/ actions/ project.js projectBrowser.js <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>.js messages.js ...</code> </pre> <br><p>  Or pod style: </p><br><pre> <code class="hljs mel">src/ project/ components/ containers/ reducers/ actions.js actionTypes.js constants.js projectBrowser/ components/ containers/ reducers/ actions.js actionTypes.js constants.js <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>/ components/ containers/ reducers/ actions.js actionTypes.js constants.js messages/ components/ containers/ reducers/ actions.js actionTypes.js constants.js</code> </pre> <br><p>  The Rails approach is good because the layers are well defined.  The structure of ‚Äúpackages‚Äù is regulated and does not provoke inventions. </p><br><p>  But therein lies the problem.  We want, let us assume, now the CLI interface.  React for command line utilities makes little sense: the components and containers layers are not needed.  But you need somewhere to put modules for a nice output in the terminal, for parsing arguments, etc.  There are no layers for this, you only have to add for CLI. </p><br><p>  Then we invent something else and see that it does not climb into the structure again.  We'll have to inflate again.  Inevitably there will be a garbage dump with the name <code>utils</code> , <code>helpers</code> , <code>tools</code> , <code>shared</code> or whatever it is usually disguised by something unclear.  Bad option. </p><br><p>  And most importantly: there is no simple way to tear out some kind of ‚Äúpackage‚Äù from the code base, to say that now it is something independent, throw it onto a diskette and send it by mail. </p><br><p>  Therefore, we stopped at the pod-concept. </p><br><h2>  Ways up </h2><br><p>  Now, if one package wants to use the benefits of another package, it must import it in a relative path: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/editor/containers/Editor.jsx import { validateProject } from '../../core/project/selectors'</span></span></code> </pre> <br><p>  There is something controversial about this.  Although packages are separated by directories, there is a strict assumption about their placement.  The number of "dots" varies depending on the nesting of the module that imports.  Among other things, it also makes refactoring difficult. </p><br><p>  It would be desirable as with libraries: to begin importing from the name of the library, and so that someone can figure out for us where to get this library: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/xod-editor/containers/Editor.jsx import { validateProject } from 'xod-core/project/selectors'</span></span></code> </pre> <br><p>  Core evolved xod-core to eliminate the possibility of conflicts with third-party libraries in the case of using simple names.  XOD is the name of the project we are doing. </p><br><p>  So, how to come to this?  That's right, make real JS packages that run through NPM and <code>node_modules</code> , exactly as it does with libraries. </p><br><p>  The classic approach is to have a repository with its <code>package.json</code> , versioning, etc. for each JS package. </p><br><p>  However, with dynamic development, juggling with a dozen repositories with npm install, build, publish, npm link, git pull, git push even feels like hell.  You need to somehow leave everything in one repository. </p><br><p>  As long as we refactor the structure, clearly highlighting the packages: </p><br><pre> <code class="hljs axapta">node_modules/ xod-cli/ bin/ src/ test/ xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>/ dist/ src/ test/ xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>-browser/ ... xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>-electron/ xod-core/ xod-espruino/ xod-fs/ xod-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>/ package.json</code> </pre> <br><h2>  Linking </h2><br><p>  In theory, for such scenarios, there is an <a href="https://docs.npmjs.com/cli/link">npm link</a> , but it is just elementary to correctly link all the links on a new machine; to reproduce the structure of the project is no longer easy: npm link is not stateless.  And everything is done for the sake of simplicity.  So no, thanks. </p><br><p>  There is a trick that is based on how Node looks for modules.  Namely: the node runs up the file tree in search of <code>node_modules/</code> , starting from the directory where the importing module is located. </p><br><p>  Thus, we can make the symlinks we need with our hands inside <code>src/</code> .  On the one hand, we will make our own packages visible for import and do not conflict with the usual dependencies from <code>package.json</code> . </p><br><pre> <code class="hljs kotlin">node_modules/ react/ redux/ webpack/ xod-client/ dist/ src/ node_modules/ xod-core -&gt; ../../../xod-core/src <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">package</span></span>-js-files.js xod-core/ src/ project/ selectors.js <span class="hljs-keyword"><span class="hljs-keyword">package</span></span>.json</code> </pre> <br><p>  Hurray, regardless of the position of the importing module, we can do: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateProject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'xod-core/project/selectors'</span></span></code> </pre> <br><p>  Simlinks can be safely stored in a Git repository.  And while Windows is not found among developers, everything will work fine: the code is immediately ready for assembly after the clone. </p><br><h2>  Turning to package </h2><br><p>  What turned out is not yet full JS-packages.  In order for the package to be filled with NPM and on equal terms with all rights used in third-party projects, you need to provide each with its own <code>package.json</code> and prescribe its sole dependencies.  Now we have the only description of the mega-package is at the root.  All dependencies of all packages have been dumped there.  We fix: </p><br><pre> <code class="hljs pgsql">xod-client/ dist/ node_modules/ babel/ ramda/ react/ redux/ webpack/ src/ node_modules/ package.json xod-core/ node_modules/ babel/ ramda/ webpack/ src/ package.json package.json Makefile ‚Üê </code> </pre> <br><p>  The symlink story continues to work as it did, but each package received its own meta-information, its own dependencies, which are necessary only for him.  The structure has become more manageable. </p><br><p>  Only now, having 10 packages, in order to make the same <code>npm install</code> , it is necessary to go into each directory and run the script for each package.  Not cool. </p><br><p>  To return the ability to build, test, lint or run in one command, we added a <code>Makefile</code> .  With content type: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">install</span></span>: npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-cli &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span> &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>-browser &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>-electron &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-core &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cd xod-espruino &amp;&amp; npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre> <br><p>  And so for every action.  A little awkward, but it works. </p><br><h2>  Stupid builds </h2><br><p>  The problem of such a structure surfaced rather quickly.  The fact that each package began to have its own dependencies from an academic point of view is good, but from a practical point of view it led to the fact that the same dependencies began to be established several times.  On one only <code>make install</code> took under 10 minutes. </p><br><p>  The lion's share of time was eaten off by the installation of the Webpack, Babel and their friends. </p><br><p>  Additionally, during the build, the same source files were transported / packaged several times: once per package.  Not productive. </p><br><p>  Solution: let each package build itself into its <code>dist/</code> once, and dependent packages use ready-made artifacts.  The build tools themselves can be put once in the root <code>node_modules/</code> . </p><br><p>  With this approach, symlinks between packages are sufficient to migrate from <code>src/</code> to <code>dist/</code> and slightly tweak the Webpack configs so that it does not process "foreign" sources. </p><br><p>  You should also separately make sure that the order of the build is not broken: the packages on which depend must be built before the dependent packages. </p><br><p>  All tools from dev-dependencies moved to the root: Webpack, Babel, Mocha, ESLint. </p><br><p>  This pair of measures returned the full build and check on the CI server in three minutes.  Correspondingly, on localhost, things went brighter. </p><br><h2>  Lerna </h2><br><p>  While we moved the package directories back and forth, I came across <a href="https://github.com/lerna/lerna">Lerna</a> .  This is a tool that was extracted from Babel at one time and just helps keep many packages in one repository.  <a href="https://github.com/babel/babel/tree/master/packages">This is done</a> , of course, in Babel himself. </p><br><p>  Among the utilities, Lerna allows you to run the npm command inside each package, bump the version of each package, and most importantly it allows you to do the so-called bootstraping. </p><br><p>  Bootstrapping is the creation of symlinks to local packages, as we did, only automatically (based on the <code>package.json</code> package) and in its regular <code>node_modules/</code> , and not in <code>src/</code> .  The final step of bootstrapping is to install third dependencies for each of the packages.  And all this is cross-platform. </p><br><p>  Everything is good, only Lerna is incompatible with the current structure in two articles: </p><br><ul><li>  Packages must be in the <code>packages/</code> subdirectory </li><li>  Simlinks are created directly on the package directory, and not on its subdirectory like <code>dist/</code> or <code>src/</code> </li></ul><br><p>  The first problem is solved trivially.  With the second all harder. </p><br><p>  The fact is that we will not be able to write: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateProject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'xod-core/project/selectors'</span></span></code> </pre> <br><p>  It is necessary to write everywhere: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateProject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'xod-core/dist/project/selectors'</span></span></code> </pre> <br><p>  There is something unnatural about it.  But what if any package wants to build for several types of targets, and the appropriate subdirectories appear in its <code>dist/</code> ?  It is necessary to rewrite absolutely all import paths.  Bad bad. </p><br><p>  The <code>package.json</code> file allows you to specify a so-called main file, for example, <code>dist/index.js</code> , but does not allow you to specify a "main directory".  Based on what I read, this is the official position of the node and will not change.  To not dabbled. </p><br><p>  How to be?  Exhale, look at the experience of others.  And the experience is such that almost anywhere you will not find imports with paths.  Those.  if there is a <code>foo</code> library, you simply import directly from it: <code>import { blabla } from 'foo'</code> .  No <code>import {blabla } from 'foo/bla/bla'</code> . </p><br><p>  And this is pretty damn good, we thought.  The package acquires a clear, clear framework: it has an API from a number of functions, constants, classes that neighbors can use.  This API can be described in its own <code>README.md</code> , cut from this repository, placed in a separate, published independently, etc. </p><br><p>  Inside, conditionally, even though the grass does not grow, but I will show you kindly: a good and beautiful API. </p><br><p>  As a result, all of our numerous imports of the form: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateProject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'xod-core/project/selectors'</span></span></code> </pre> <br><p>  turned into elegant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateProject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'xod-core'</span></span> validateProject(...) <span class="hljs-comment"><span class="hljs-comment">//  import core from 'xod-core' core.validateProject(...)</span></span></code> </pre> <br><p>  The packages themselves, in their root <code>index.js</code> simply re-export the necessary characters for everything. </p><br><h2>  Conclusion </h2><br><p>  As a result, we got a pretty nice structure, which is comfortable to work with and one feels that it will withstand more than one thousand commits. </p><br><pre> <code class="hljs pgsql">node_modules/ webpack/ babel/ mocha/ eslint/ packages/ xod-cli/ xod-client/ dist/ node_modules/ src/ api/ editor/ messages/ processes/ projectBrowser/ <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js test/ package.json weback.config.js xod-client-browser/ xod-client-electron/ xod-core/ xod-espruino/ xod-fs/ .babelrc dist/ node_modules/ src/ backup.js <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>.js save.js package.json xod-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>/ package.json lerna.json</code> </pre> <br><p>  The most attentive ones might have noticed that I started the examples with the separation of front-end components, and continued with some larger packages.  And there is.  The whole front with us and now lies inside one <code>xod-client</code> .  There he is organized in the style of pods.  It turned out that while he is not so tight.  And when it starts to reap, we know what to do: take it to the upper level, in separate packages. </p><br><p>  TODO: </p><br><ul><li>  Lerna is not yet friends with <a href="https://github.com/yarnpkg/yarn">Yarn</a> .  We are waiting for the developers to agree and <code>npm install</code> will become a rocket for mono-repositories as well. </li><li>  Lerna is able to execute the npm script in each package, but cannot do this, given the cross dependencies.  Therefore, you have to manually register the build order in the root <code>package.json</code> .  It is worth trying to simplify this through Gulp. </li></ul><br><p>  I do not pretend that the presented approach is ‚Äúcorrect‚Äù.  So it happened with us and it was formed on the basis of the evolutionary changes that the project went through.  If someone will be useful to the thoughts, I will be glad;) </p><br><p>  <strong>PS</strong> In the project we are looking for the full-stack of the JS developer.  If you can recommend someone for this <a href="https://moikrug.ru/vacancies/1000029954">vacancy</a> , I will be immensely grateful. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/314894/">https://habr.com/ru/post/314894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314882/index.html">Blue screen of death when copying via Remote Desktop is now available on the server platform</a></li>
<li><a href="../314884/index.html">The protagonists of the modern online project</a></li>
<li><a href="../314886/index.html">Development based on the COREmanager framework. How our partners created a solution for outsourcing technical support</a></li>
<li><a href="../314888/index.html">Desktop virtualization: what's new, what are the trends and where are we going?</a></li>
<li><a href="../314892/index.html">You can download materials from the Nanometer ASIC workshop (RUSNANO / MISiS / Imagination Technologies) - educational program for all chips</a></li>
<li><a href="../314896/index.html">Mobile Antifraud Overview</a></li>
<li><a href="../314898/index.html">Alarm for fridge. Not life, but ‚Äúraspberry‚Äù with RaspberryPi 3</a></li>
<li><a href="../314900/index.html">Typical backup errors and how to avoid them</a></li>
<li><a href="../314902/index.html">Hammer, termite and magnetic field for quick data destruction</a></li>
<li><a href="../314904/index.html">Using MS Cognitive Services to analyze your Instagram profile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>