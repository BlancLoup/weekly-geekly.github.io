<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tips and tricks for deploying a test automation process from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 The tips and recommendations described below were formed on the basis of the experience of creating testing and automation from scratch in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tips and tricks for deploying a test automation process from scratch</h1><div class="post__text post__text-html js-mediator-article"><h2>  Foreword </h2><br>  The tips and recommendations described below were formed on the basis of the experience of creating testing and automation from scratch in two companies and the start of similar work in the third.  Accordingly, there are no complaints about the laurels of an all-knowing specialist; this is rather an attempt to share experience, formed in the form of a step-by-step guide on a topical topic recently - testing automation in the company. <br><br>  If you decide to read this, you should immediately take into account that the topic of creating autotests in the programming language and choosing tools for your specific project will be given little space here because it is impossible to unify them and display a strict list for you on which projects which tools will be better. .  Here, of course, you have to dig yourself. <br><br>  But on how to approach testing in general, where to start, how to think out a test plan and start to form test cases, how to select tests for further automation, estimate the time of work and whether you need automation at all and will be described below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      PS: And finally - this text would never have been formed if it were not for the useful lectures of Alexei Barantsev and Natalia Rukol, as well as the gulf of information written by good people in recent years on this topic. <br><br>  Now everything, you are warned - you can start the story. <br><a name="habracut"></a><br><h2>  Part 1 - Deploy Test Automation </h2><br><h3>  1. The choice of test automation strategy (hereinafter - AT) </h3><br>  There are several generally accepted variants of the AT strategy used.  From the choice of a specific strategy depends on the order and intensity of certain works on AT.  The choice of strategy is not the most important task, but it is best to start the process of deploying automation.  I will give 3 variants of strategies that are characteristic of the very beginning of the deployment of automation.  Of course, there are more strategy options; you can see the complete list at the seminars of Natalia Rukol. <br><br>  <i>1.1 ‚ÄúLet's try‚Äù strategy</i> <br><br>  It is used in the case when AT has never been in the project or in the company, and a cautious start is planned with a moderate allocation of resources. <br><br>  It makes sense to apply the strategy when: <br><br><ul><li>  There are no exact goals of automation (to cover 40% of the code of a particular module by a certain date, reducing the cost of manual testing, etc.). </li><li>  AT on the project has never been used before. </li><li>  Testers have no (or very little) AT experience. </li><li>  Allocated resources are moderate or low. </li></ul><br>  Description of the strategy: <br><br><ul><li>  To pay more attention to the preparatory stages of testing (drawing up test plans, test cases, etc.). </li><li>  Pay more attention to tools that can be used as an aid in manual testing. </li><li>  Experiment more with AT technology and methodologies.  No one is waiting for urgent results and you can experiment. </li><li>  To work with the project, starting from the top level, at the beginning without delving into the automation of specific modules. </li></ul><br>  <i>1.2 Strategy "Here the target"</i> <br><br>  Feature of the strategy is the orientation to a specific result.  The goal of a new stage of AT is chosen / determined, and the tasks are oriented towards the achievement of this result. <br><br>  It makes sense to apply the strategy when: <br><br><ul><li>  When the preliminary work has already been done on the project, there is some kind of background in the form of test plans, test cases, optimally - autotests of the previous AT stage. </li><li>  There is a specific goal of AT (not global - 80% of autotests for six months, but rather 50% of autotests of a specific module for a month) </li><li>  Specific tools have been chosen to fulfill a specific goal, optimally if specialists have a technical background for working with tools. </li></ul><br>  Description of the strategy: <br><br><ul><li>  A progressive strategy, somewhat reminiscent of Agile development methodology.  Moving forward in stages.  Autotesting coverage of the module behind the module, to complete the implementation of meta tasks of the form (80% for six months). </li><li>  At each stage, a new goal is set (most likely continuing the most recently completed goal, but not necessarily), and tools are chosen to implement this goal. </li><li>  Deep focus on a specific goal, writing test cases, autotests, not for the whole project, but exclusively for a specific task. </li></ul><br>  <i>1.3 Strategy "Operation Uranum"</i> <br><br>  In essence, the strategy is constant and methodical work on the AT according to priorities set once every 2-3 weeks.  Optimally - the presence of constantly working on the automation of a person who is not particularly distracted by third-party tasks. <br><br>  It makes sense to apply the strategy when: <br><br><ul><li>  There are no specific goals, there is only a general wish "so that everything is good."  If ‚ÄúHere the target‚Äù reminds of how Agile works, then this strategy is close in spirit to the methodology of Waterfall. </li><li>  There is a resource in the form of at least one person permanently acting on a project, who is closely engaged in the task of automation. </li><li>  There are no clearly defined goals for AT, but there are wishes (priorities) that can be set for a sufficiently long period of time (these modules are more important than those, more mistakes are traditionally in the backend / front-end, because great efforts should be directed to it). </li></ul><br>  Description of the strategy: <br><br><ul><li>  The idea of ‚Äã‚Äãthe strategy is described above, constant and methodical work, taking into account the priorities set. </li><li>  At the beginning, an emphasis is needed on the basic part, because one way or another, within the framework of this strategy, the entire project is automated, without full focus on specific modules. </li></ul><br>  <b><i>Summarizing:</i></b> <br><br>  It is worth considering the general logic and strategy of automation, however, I would suggest the following option: At the beginning for 1 month (3-4 weeks), use the Let's try strategy, prepare the basis for further work, not diving deeply into writing the code itself tests and deep concrete modules.  Upon completion of this stage we will have a ready basis for further work.  And then you need to choose how it will be convenient to work further - roughly speaking, by waterfall or Agile.  And continue to act in accordance with the chosen strategy. <br><br><h3>  2. Parallel tasks </h3><br>  This item makes sense if there are several people working on or will be working on testing a project.  Then there is a crucial point in parallelizing tasks in a team.  If one person will work on your team on AT, you can safely skip this item. <br><br>  From the point of view of competences and close to each other knowledge, the testing automation process can be divided into roles that encapsulate various similar tasks. <br><br>  <b>Roles</b> <br><br>  <i>Architecture</i> <br><br><ul><li>  Selection of tools </li><li>  Selection of approaches </li></ul><br>  <i>Development</i> <br><br><ul><li>  Test development and debugging </li><li>  Support, update </li><li>  Error correction </li></ul><br>  <i>Test design</i> <br><br><ul><li>  Test selection </li><li>  Test Design </li><li>  Test Data Design </li></ul><br>  <i>Control</i> <br><br><ul><li>  Planning </li><li>  Collecting metrics </li><li>  Training </li></ul><br>  <i>Testing</i> <br><ul><li>  Error localization </li><li>  Making mistakes </li><li>  Preparation of test data </li></ul><br>  If several people work on testing the project, then it is logical to parallelize the roles described above to specific people.  In this case, it makes sense to assign the role of ‚ÄúManagement‚Äù to one person, to divide the roles of ‚ÄúTest Design‚Äù and ‚ÄúTesting‚Äù to all, and the roles of ‚ÄúArchitecture‚Äù and ‚ÄúDevelopment‚Äù to one or two heroes. <br><br>  The logic is as follows. <br><br><ol><li>  There is a clear test manager for this project who plans, sets deadlines, and is responsible if they do not comply. </li><li>  There are two common types of testers - manual testers and automators.  At the same time, the tasks of the roles ‚ÄúTest Design‚Äù and ‚ÄúTesting‚Äù are equally relevant for both types.  Accordingly, all testers write and design tests that can later be used in manual testing and automation. </li><li>  Further, manual testers according to the created test plans and test cases carry out manual testing, the automation specialists finish the necessary tests to a form suitable for development and are engaged in automation. </li></ol><br>  However, if you have a man-orchestra, he will do everything at once, but he will not be a professional in everything. <br><br><h3>  3. Creating a test plan </h3><br>  After choosing the AT strategy, the next important point will be the starting point of the work - creating a test plan.  The test plan must be coordinated with the developers and product managers, since errors at the stage of creating a test plan can come back significantly later. <br><br>  In a good way, a test plan should be made for any relatively large project on which testers work.  I describe a less formalized test plan than the option that is usually used in large offices, yet the gulf of formalities is not needed for internal use. <br><br>  The test plan consists of the following points: <br><br>  <b>3.1 Object of testing.</b> <br><br>  A brief description of the project, the main characteristics (web / desctop, ui on iOs, Android, works in specific browsers / OSes, and so on). <br><br>  <b>3.2 Composition of the project.</b> <br><br>  A logically broken list of separate, isolated from each other components and modules of the project (with possible decomposition, but without going into details), as well as functions outside of large modules. <br><br>  In each module, list the set of available functions (without delving into the little things).  From this list, the manager and test designer will be repelled when defining tasks for testing and automation for a new sprint (for example: ‚Äúchanges were made to the data editing module, the file upload module was affected and the function of sending notifications to the client was completely redone‚Äù). <br><br>  <b>3.3 Testing strategy and planned types of testing on the project.</b> <br><br>  Strategies are described in claim 1. In the case of automation, usually only one type of testing is used - regression (deep testing of the entire application, running the tests created earlier).  By and large, autotests can be used in other types of testing, but as long as they do not reach at least 40% of the coverage, there will be no principal benefit from this. <br><br>  However, if the test plan is planned to be used not only by automation engineers, but also by hand-held testers, then you need to consider the entire testing strategy (not automation), select or mark the used / desired types of testing and write down this paragraph as well. <br><br>  <b>3.4 Sequence of testing.</b> <br><br>  How will the preparation for testing, assessment of the timing of the tasks, the collection and analysis of statistics for testing. <br>  If you have no idea what to write in this paragraph - you can safely skip it. <br><br>  <b>3.5 Criteria for completing testing</b> <br><br>  Briefly describe - when testing is considered completed in this release.  If there are any specific criteria - describe them. <br><br>  <i><b>Summarizing:</b></i> <br><br>  It is necessary to write a test plan, without it all further automation will be chaotic and unsystematic.  If in manual testing (in very bad manual testing), you can do without a test plan, test cases, and use monkey testers with relative success, then this will not work in automation. <br><br><h3>  4. Definition of primary tasks </h3><br>  After choosing a strategy and drawing up a test plan, you should choose a set of tasks with which we will begin testing automation. <br><br>  The most common types of tasks that are set before automation: <br><br><ul><li>  Full Automation of Acceptance Testing (Smoke Testing) - the type of testing that is carried out first after receiving the build by the testing department.  As part of Smoke Testing, the functionality is checked that should work always and in any conditions, and if it does not work, it is considered by agreement with the developers that the build cannot be accepted for testing. </li><li>  Maximize the number of defects found.  In this case, you must first select those modules (or aspects of functionality) of the system that are most often subject to changes in the logic of operation, and then select the most routine tests (that is, tests where the same steps with small variations are performed on a large amount of data). </li><li>  Minimization of the "human factor" in manual testing.  Then, again, the most routine tests that require the most care from the tester (at the same time, easily automated) are selected.  For example, testing the user interface (for example, checking the names of 60 columns in a table), checking the contents of a combo box with 123 elements, checking the export of a table on a web page in Excel, etc. </li><li>  Finding the majority of system crashes.  Here you can apply "random" tests. </li></ul><br>  At the very beginning of the deployment of automation, I recommend setting the task of automating acceptance testing as the least time consuming.  In this case, the solution of the problem will allow to start acceptance testing already on the next accepted build. <br><br>  The main criterion for smoke tests should be their relative simplicity and at the same time mandatory verification of the project‚Äôs critical functionality. <br><br>  It also implies that Smoke tests will be positive (verifying the correct behavior of the system, while negative - checking whether the system will work incorrectly), so as not to waste time on unnecessary checks. <br><br>  <i><b>Summarizing:</b></i> <br><br>  Making the list of primary tasks for automation, it will be logical to be the first to describe and automate the smoke tests.  In the future, they can be included in the project and run with each build.  Due to their limited number, the execution of these tests should not particularly slow down the assembly, but each time it will be possible to know for sure whether the critical functions still work. <br><br><h3>  5. Writing test cases for selected tasks </h3><br>  With regard to test cases, it is customary to divide the testing process into two parts: testing according to ready-made scenarios (test cases) and research testing. <br><br>  With regard to research testing, everything is quite understandable, it exists in two variations, either the study of new functionality without much prior preparation, or in the form of a banal decoy.  Scenario testing implies that time was expended and test scenarios were created for the project's functionality to cover the largest possible amount. <br><br>  The most reasonable, from my point of view, is a reasonable combination of approaches, in which new functions and modules are tested in a research style, trying to test possible and unlikely scenarios, and upon completion of testing, test cases are created, which are then used for regression testing. <br><br>  Three options for further use of test cases, except for the obvious: <br><br><ul><li>  To form the checklists for the project modules from the test cases, the test will speed up, but the main problem areas will be checked. </li><li>  Training beginners - the tester who came to the project can study the project from the point of view of test cases, since they capture many not obvious moments of the application. </li><li>  Further use as the basis of autotests.  If a system approach is used when deploying an AT, then writing and further use of test cases is perfectly logical - in fact, a test case is a ready-made auto-test script. </li></ul><br>  I will not describe in detail the principles for describing test cases. I will describe a lot of materials on this topic in the network, I will describe briefly. <br><br>  A good test case consists of the following items: <br><br><ol><li>  The name (description) is a very brief description of what the test checks. </li><li>  Preliminary state of the system - a description of the state of the system in which it should be at the time of the start of the test case. </li><li>  The sequence of steps - sequentially described actions that verify the goal stated in the Title. </li><li>  The expected result is the state of the system, which we are waiting for after passing the sequence of test case steps. </li></ol><br>  For convenient storage of test cases, there are many solutions, but one of those that I used proved to be quite good Testlink application, and the best - sitechco.ru system, a convenient free system for creating / storing and tracking test cases. <br><br>  <i><b>Summarizing:</b></i> <br><br>  For further AT, you need to write test cases for the tasks set out in Clause 4.  They will simultaneously serve as the beginning of the creation of normal regression testing and will serve as a basis for further autotests. <br><br>  As a recommendation, a tester planning to write test cases is recommended to read about pair wise, equivalence classes and test design techniques.  Having studied at least superficially these topics to write good and useful test cases will become much easier. <br><br><h3>  6. The choice of tools for automation </h3><br>  Obviously - the tools for AT are selected depending on the platform on which the application runs. <br><br>  I will give an example of choosing a toolkit for a project consisting of two parts - Backend on AngularJS and Frontend - a client for tablets and phones based on iOS. <br><br>  <b>1. Backend</b> <br><br>  <i>Karma + Protractor (Jasmine).</i> <br><br>  Pros: I recommend using the Protractor tool as a shell, it is ideal for applications written in AngularJS.  Protractor simulates user interaction, allows you to create autotests created by the BDD framework Jasmine.  Well, Karma allows you to run these tests in different browsers. <br><br>  Cons: The tester should be able to write at least simple JS scripts.  Or the programmer must write these scripts to him, which with the development of AT can become overhead. <br><br>  <i>Selenium Webdriver.</i> <br><br>  Pros: A convenient, simple and reliable tool for automating the testing of GUI web applications.  A lot of documentation, an abyss of examples, in general, is convenient.  In the most primitive version does not require any programming knowledge from the tester. <br>  Cons: Protractor is written by the AngularJS team to test AngularJS, while Selenium is universal.  From my point of view, it will be more convenient to write tests for Protractor + Jasmine on the AngularJS project.  In case serious self-testing is planned, and not just assistance to manual testers, then the tester will still need to know the programming language (java, python, ruby, c #), since flexible configuration of tests requires programming knowledge. <br><br>  <b>2. Frontend</b> <br><br>  <i>Calabash + Cucumber.</i> <br><br>  By and large, the most convenient tools for automating iOS applications on tablets and phones is Calabash + Cucumber.  Calabash is a framework for automating functional testing, which, in essence, is the driver that controls the operation of an application on a device or simulator.  Cucumber provides a test infrastructure (running tests, parsing scripts, generating reports). <br><br>  It should be borne in mind that Calabash is a paid solution (https://xamarin.com/test-cloud). <br><br>  <i><b>Summarizing:</b></i> <br><br>  Testing automation tools are described above, but these are far from the only available tools and I would recommend to anyone who sets up all of this infrastructure and deploys ATs in a company to dig deeper into the network, something new and more convenient than what I‚Äôve chosen instruments. <br><br><h3>  7. Selection of tests for automation </h3><br>  So, for the current stage, we have formed a test plan and described some of the functionality of the modules as test cases.  The next task will be the selection of the necessary tests from the existing variety of test cases.  Right now you only have test cases prepared for Smoke testing, but after a few iterations of the development of test cases in the project will become significantly more, and not all of them make sense to automate. <br><br>  <b>1. It is very difficult to automate the following things:</b> <br><br><ol><li>  Checking the opening of a file in a third-party program (for example, checking the correctness of a document sent for printing) </li><li>  Checking the image content (there are programs that allow to partially solve this problem, but in a simple cut of the tasks, such tests are best not automated, but left for manual testing) </li><li>  Checks related to ajax scripts (this problem is easier to solve, different applications have their own solutions, but on the whole, ajax is much more difficult to automate). </li></ol><br>  <b>2. Disposal of monotonous work.</b> <br><br>  As practice shows, testing just one function may require several test cases (for example, we have an input field in which you can enter any two-digit number. It can be checked with 1-2 tests, ‚Äú2 characters‚Äù, ‚Äú1 character‚Äù. If check more thoroughly - then add a test for the absence of value, zero, limit value and a negative test with character input).  The advantage of autotests before manual testing in this case is that if we have one test that checks for data entry in the field - we can easily increase their number by changing the input parameters. <br><br>  By and large autotests and should close the most tedious and monotonous part of testing, leaving testers room for research testing. <br><br>  Accordingly, when choosing test cases for automation, this should also be taken into account. <br><br>  <b>3. Ease of tests.</b> <br><br>  And the last important criterion for the selection of test cases for automation is the relative simplicity of the tests.  The more diverse steps in the test - the worse the test case itself, the more difficult it will be to automate and the more difficult it will be to find a bug if this auto test fails at launch. <br><br>  Try to choose to automate test cases of small volumes, gradually gaining experience and automating more and more complex test cases, until you decide what length of test is optimal for you. <br><br>  <b>8. Design tests for automation</b> <br>  Test cases selected for automation will most likely need to be added and corrected, since test cases are usually written in simple human language, while test cases for further automation should be supplemented with the necessary technical details, for ease of translation into code (with time, it will come to understand which tests need to be described in a living language, and which - to be described in detail and clearly even at the stage of creating test cases). <br><br>  Accordingly, it is possible to form the following recommendations on the content of test cases intended for automation: <br><br>  <b>1. The expected result in automated test cases should be described very clearly and specifically.</b> <br><br><ul><li>  Bad: Result - the Forms page opens. </li><li>  Good: Result - the Forms page opens, the page contains a search form &lt;input type = "text" placeholder = "Search" ..&gt;, there is an element css = div.presentations_thumbnail_box and link = Notes. </li></ul><br>  <b>2. Take into account the synchronization features of the browser and the application running the tests.</b> <br><br>  For example, in the test, click on the link and the next step in the action on the new page.  In this case, the page may load for a long time, and the application, without waiting for the download of the desired item to launch, will fall out with an error.  Often this is easily solved by setting the item loading wait parameter. <br><br><ul><li>  Bad: Click on the ‚ÄúForms‚Äù link in the top menu.  Confirm the changes made. </li><li>  Good: Click on the ‚ÄúForms‚Äù link in the top menu.  Wait until the form appears with the text ‚ÄúDo you want to save changes?‚Äù.  Click on the "OK" button. </li></ul><br>  <b>3. It is not necessary to register hard values ‚Äã‚Äãin the test case.</b> <br><br>  Only if it is not necessary.  In most cases, when creating a test environment, suitable data is determined, so it is more optimal to select values ‚Äã‚Äãwhen creating an autotest. <br><br><ul><li>  Bad: Open slide ‚Äúslide 1_11‚Äù </li><li>  Good: The first slide of the presentation is open. </li></ul><br>  <b>4. Automated test cases should be independent.</b> <br>  There are exceptions to any rule, but in most cases it should be assumed that we do not know which test cases will be performed before and after our test case. <br><br><ul><li>  Bad: From the file created by the previous test ... </li></ul><br>  <b>5. It is necessary to carefully study the documentation for the tools used.</b> <br><br>  So you can avoid a situation where, due to an incorrectly chosen command, the test case becomes falsely positive, i.e.  Successfully passes in a situation when the application is not working correctly. <br><br>  <i><b>Summarizing:</b></i> <br><br>  A correctly written test case designed for automation will be much more similar to a miniature technical task for developing a small program than a description of the correct behavior of the application under test that is understandable to humans.  Below I will point out a few test cases, reworked for automation.  The rest, I think, the project tester will be able to remake by the rules described above himself. <br><br><h3>  9. Configure the application stack for automation </h3><br>  The next step (or a parallel task in the case of several specialists) will be the deployment of a stack of applications, which we will use in further work on creating and launching autotests. <br>  I will not describe these or other installation options in detail, all information is on the network, for each option I will attach 1-2 links to start searching for a solution. <br><br>  <b>Backend</b> <br><br>  <i>1. Karma + Protractor (Jasmine)</i> <br><br>  - Karma + Protractor - Great tool deployment <a href="http://mherman.org/blog/2015/04/09/testing-angularjs-with-protractor-and-karma-part-1/">guide</a> - <a href="http://mherman.org/blog/2015/04/09/testing-angularjs-with-protractor-and-karma-part-1/">mherman.org/blog/2015/04/09/testing-angularjs-with-protractor-and-karma-part-1/#.VpY21vmLSUk</a> <br>  - Protractor + Jasmine - Install and configure Jasmine <a href="http://engineering.wingify.com/posts/e2e-testing-with-webdriverjs-jasmine/">engineering.wingify.com/posts/e2e-testing-with-webdriverjs-jasmine</a> <br><br>  If you select this scheme, it will be necessary to ‚Äúfriends‚Äù Karma and one of the Continuous Integration systems to automatically run the tests.  I offer two of the most interesting options that seemed to me - Jenkins and Teamcity. <br><br>  - Teamcity - The solution is quite simple, which consists in installing the <a href="http://karma-runner.github.io/0.13/plus/teamcity.html">karma-runner-reporter</a> plugin; <br>  - Jenkins - Similarly - a simple solution, installing the <a href="https://www.npmjs.com/package/karma-jenkins-reporter">karma-jenkins-reporter</a> plugin. <br><br>  <i>2. Selenium Webdriver</i> <br><br>  The decision itself is not too elegant, but this is written above.  If you still decide to go in a simple way, then it suffices to put: <br><br>  - <a href="http://docs.seleniumhq.org/download/">Selenium IDE</a> ; <br>  - The principles of working with Selenium Webdriver in case the tests obtained from the IDE are clearly not enough to <a href="http://selenium2.ru/docs/webdriver.html">read here</a> . <br><br>  After installing the tools, it will remain to run them on the Continuous integration system.      (  ),   ‚Äî Teamcity  Jenkins. <br><br> ‚Äî Teamcity ‚Äî    IDE     (C#, Java, Python, Ruby),      Teamcity.     ‚Äî <a href="http://habrahabr.ru/post/230519/"> </a> . <br> ‚Äî Jenkins (  ‚Äî <a href="https://saucelabs.com/resources/articles/selenium-jenkins-how-to-do-it-yourself-and-the-sauce-labs-advantage"></a> ). <br><br> <b>Frontend</b> <br><br> <i>1. Calabash+Cucumber</i> <br><br> ‚Äî <a href="https://www.moncefbelyamani.com/ios-automated-testing-with-calabash-cucumber-ruby/"> </a> ; <br> ‚Äî <a href="http://www.qwinix.io/mobility/ios-automated-testing-with-calabash-cucumber/"> </a> ; <br><br>     ‚Äî  Calabash     Continuous integration . <br><br> ‚Äî Teamcity ‚Äî   ,   , <a href="http://habrahabr.ru/company/mailru/blog/244807/"> </a> . <br> ‚Äî Jenkins ‚Äî     , <a href="http://www.snap-interactive.com/blog/ios-continuous-automation-using-jenkins-and-calabash/">   </a> . <br><br> <i><b>:</b></i> <br><br>   ‚Äî      ‚Äî     ‚Äî    ,        . ,      ,        ‚Äî       . <br><br><h3> 10.    </h3><br>              . ,          ¬´¬ª,     ,    ,          .  ,      ,       ,     ,     ,      . <br><br>       ,   ‚Äî    . <br> ,             . <br><br>    ,   ,    ,   ‚Äî       .          . ,       ,              . <br><br><ul><li>  ‚Äî            .  ,  ,       .  . </li><li>  ‚Äî ,         ,     .          . </li></ul><br><br><h3> 11.     </h3><br>         ‚Äî  ,   ,           ‚Äî     : <br><br><ul><li> Protractor + Jasmine ‚Äî <a href="https://angular.github.io/protractor/">angular.github.io/protractor/#/tutorial</a> </li><li> Selenium IDE ‚Äî <a href="http://forworktests.blogspot.ru/2013/03/selenium.html">forworktests.blogspot.ru/2013/03/selenium.html</a> </li><li> Selenium Webdriver ‚Äî <a href="http://www.seleniumhq.org/docs/03_webdriver.jsp">www.seleniumhq.org/docs/03_webdriver.jsp</a> </li><li> Calabash ‚Äî <a href="http://habrahabr.ru/post/219655/">habrahabr.ru/post/219655</a> </li></ul><br>          <a href="http://www.protesting.ru/automation/practice/automation_from_scratch.html"> </a> . <br><br>  <b>Good luck!</b> <br><br><h3> <i> 11  </i> </h3><br>     , ,           ‚Äî      . <br><br>       -,  ,           ,         ,    . <br><br>       ,       , maintenance  sustain .      ,   ,         . <br> ,     ! <br><br>         ! <br><br> <b>,   !</b> <br><br><h2>  2 ‚Äî       </h2><br><h3> 12.    </h3><br>  -    ,          ,      .  ,   ,                 .  ,         ,        -   . <br><br>       : <br><br> <b>1.     .</b> <br><br>              : <br><br><ol><li>   ,   ( ,    ),    ,       ‚Äî   TAuto. </li><li>  ,     -  -,        ‚Äî   TMan. </li><li>  ( ,     ) ,         ‚Äî   TManRun. </li><li>  ,           ‚Äî   TAutoRun. </li><li>  ,         ‚Äî   TAutoMull. </li><li>             (        ‚Äî      ) ‚Äî   N. </li><li>     ,       .     R. </li></ol><br>    : <br><br> <b>TManTotal = N*Tman + N*R*TManRun <br> TAutoTotal = TAuto + N*TAutoRun + N*R*TAutoMull</b> <br><br> ,  ,  <b>TManTotal &gt;= TAutoTotal</b>   . <br><br>              ,          ,   ,    . <br><br> <b>2.   </b> <br><br>  ( ‚Äî    )      . <br><br> ,      , : <br><br> <i>1.   .</i> <br><br>   ,         ,    . ,               .          .     .  And so on. <br><br>          (  ),           .   ,     ? <br><br>  ,                   . <br><br>           -    ‚Äî       . <br><br> <i>2.  .</i> <br><br>  ,        ,      -  .  , , ,      ,      .         ,    ,         . <br><br> <i>3.   .</i> <br><br> ,    ,        ,            .                  ,     . <br><br>     ,        . <br><br>              ‚Äî , , .           .   ‚Äî          ,            ,     . <br><br> <i>4.   .</i> <br><br>              . <br><br>   : <br><br> <i> :</i> <br><br><ul><li>  </li><li>  </li><li>  </li><li>  </li></ul><br>   ,     . <br><br> <i>  :</i> <br><br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  ... </li></ul><br>       ,           ‚Äî        . <br><br> <i> :</i> <br><br><ul><li>  </li><li>   </li></ul><br>    ,       (   ,    ,   ),      ,    ,        .            .       ,     CI    .       . <br><br> <i> :</i> <br><br><ul><li>   ‚Äî   ‚Äî   /stable   5 ,            . </li><li>    ‚Äî      changeset'     . </li><li>    ‚Äî ,     . </li><li>   ‚Äî    . </li></ul><br><br> <i><b>:</b></i> <br><br>        ,             .    .           . <br><br><h3> 13.     </h3><br>          ( ),    ,        . ,         ‚Äî    ,     . <br><br>         ,      : <br><br> <b>1. .</b> <br><br>     ,         .       :       ,    ,     ,           . <br><br>   ,   ,       : <br><br><ul><li>      ?             . </li><li>      ?           ,   ,        ‚Äî    . </li></ul><br>   ,     ,    .    : <br><br><ul><li>       : ¬´        ?¬ª.    ,    .  ,        ,      . </li><li>  ,            . </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Replicated. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we can collect statistics on the implementation of similar tasks assigned to us - then the tasks relate to replicable. </font><font style="vertical-align: inherit;">These are usually tasks for creating autotests without using new types of tests, expanding coverage with auto tests, regular tasks for supporting tests and infrastructure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such tasks are quite simple to evaluate, because the like of them have already been completed and we know the approximate time of their execution. </font><font style="vertical-align: inherit;">Help us:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collection of preliminary statistics on the execution time of similar automation tasks. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collection of statistics on the risks that we encountered in performing similar tasks. </font></font></li></ul><br> <i><b>:</b></i> <br><br>       ,        ,   . <br><br> <i><b> :</b></i> <br><br>   ,       ,               .    ,    ,  ! </div><p>Source: <a href="https://habr.com/ru/post/275171/">https://habr.com/ru/post/275171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275161/index.html">Hacking bank cards, cars and instant messengers and other features of education at the best magistracy in the Netherlands</a></li>
<li><a href="../275163/index.html">IaaS useful digest</a></li>
<li><a href="../275165/index.html">Safe doors, or continue to design ACS TP</a></li>
<li><a href="../275167/index.html">Intelligence agencies allegedly exploited Juniper vulnerabilities</a></li>
<li><a href="../275169/index.html">Algorithmic Trading: Finding an Efficient Data Processing Method Using FPGA</a></li>
<li><a href="../275173/index.html">User feedback based on Intel RealSense technology</a></li>
<li><a href="../275175/index.html">Support our students</a></li>
<li><a href="../275181/index.html">Chrome add-on PushAll returns the capabilities of the Alert Center and complements it</a></li>
<li><a href="../275183/index.html">OpenSSH cryptographic software fixes dangerous vulnerability</a></li>
<li><a href="../275185/index.html">Security Week 02: Vulnerable Webcams, Continuing the Story with Juniper, Zero-Day in Silverlight and How It Was Found</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>