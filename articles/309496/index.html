<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ASP.NET MVC + VM: splitting complex views into simple ones using view models using the example of an event calendar</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to write on this topic, because I constantly use view models in ASP.NET MVC web applications, and often I have to explain the essence of thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ASP.NET MVC + VM: splitting complex views into simple ones using view models using the example of an event calendar</h1><div class="post__text post__text-html js-mediator-article">  I decided to write on this topic, because I constantly use view models in ASP.NET MVC web applications, and often I have to explain the essence of this approach to my colleagues, and we‚Äôve not found.  This article focuses primarily on beginners. <br><br>  Imagine that we need to display a calendar of some events for the current month.  This is a rather complicated construction.  The calendar should contain a title with the name of the current month and year, a line with the names of the days and, in fact, the days themselves (6 rows of 7 days), each of which has a date and, optionally, a certain set of events, the names of which need to be displayed, having previously downloaded them from the database.  Also suppose that weekends and holidays should be marked in a special way.  That is, in the end, you should get something like this: <br><br><img src="https://habrastorage.org/files/584/38b/38d/58438b38d4ad41b996e525580024bd10.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h2>  Some theory </h2><br>  The MVC design pattern and its concept of dividing the application into 3 parts (model, presentation, and controller) are familiar to every developer. <br><br>  Under the model, you can simply understand only the data (objects of the subject area, which are often called ‚Äúmodels‚Äù), and the data combined with a certain logic of their processing.  (The storage of data should be separated into a separate, independent layer.) That is, ideally we will have a model that exists and functions regardless of how its data is displayed and stored. <br><br>  Consider, for example, online shopping.  Often, in such projects, the frontend occupies only a small part of the entire functionality, most of which is concentrated in various administrative subsystems, such as order accounting and customer interaction, warehouse accounting, analytics, API and so on.  It is obvious that the functioning of such subsystems (which, by the way, can easily be executed and in the form of individual applications) in the context of a single and common model is very important.  The implementation of such functions as calculating the value of a specific position (including current promotions and discounts) or the total amount of the order should be the same for the entire project. <br><br>  Let's imagine now the main page of a typical online store.  It certainly has a place for a list of categories, several popular products, news and other things.  That is, the transfer to the representation of any one object of the model is definitely not enough.  But after all, to form a set of objects necessary to display such a representation, a certain logic is required.  Yes, and these sets of objects may be similar for different representations, so it would be wrong to place such logic directly in the controller.  (The two most common problems of bad code are duplication and long, illegible methods.) But this logic cannot be part of the model either, since it applies to a particular representation.  That's where the species models come to the rescue. <br><br>  In essence, a model of a view (it would be more correct to call it a view model) encapsulates a set of all the data necessary for a particular view (or even several views).  As representations can consist of other representations, a species model can consist of other species models.  In the case of the main page of the online store, we could define a model of the type of this page, which would include sets of models of types of categories, products and news.  In turn, the model of the type of goods may consist of models of the types of photographs, comments, and so on.  It is noteworthy that all these types of models (except, perhaps, models of the main page) can be reused.  However, this does not solve the problem of the need to have the logic for the formation of the entire graph of these objects, which, as we have already discussed above, is directly a bad idea to put directly into the controller. <br><br>  View model builders are ideal for isolating and reusing model view initialization code ‚Äî a parallel hierarchy of classes that generate objects of view models of corresponding types.  The builders of the parent view models can use the builders of the child view models to build the entire necessary hierarchy, calling each other in a chain, from top to bottom.  Let's pay attention that for simple models of types where initialization is reduced only to installation of the values ‚Äã‚Äãreceived from the controller, application of the builder is redundant and cumbersome - in this case, the usual constructor will suffice. <br><br>  On this, I think, it's time to move on to practice. <br><br><h2>  Practice </h2><br>  We now return to our calendar of events as a simpler example.  To begin with, we will prepare an empty ASP.NET MVC web application (I will use ASP.NET Core to demonstrate at the same time the capabilities of the new platform, but in the context of our example, this does not matter).  Add in it the only controller DefaultController with a single action (action) Calendar in it - it will be responsible for displaying the calendar.  We also add the corresponding view (for now, without any content).  If we run our application now, we should get a blank page.  (At the end of the article you will find a link to the finished test project posted on GitHub.) <br><br>  As we have already seen above, in order to transfer all the necessary data to our view, we will need an appropriate view model.  Let's call it CalendarViewModel.  (It is very convenient to place the view models in the ViewModels folder of the project, following the structure of the Views folder; later I will provide the corresponding screenshot.) We will immediately add to it an obvious Date property of type DateTime.  We need it to display the current month and year.  It should be such a class: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalendarViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime Date { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Now let's add a builder for our view model (there is no special need for it now, but later it will appear - let's do it in advance): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalendarViewModelBuilder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CalendarViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalendarViewModel() { Date = DateTime.Now }; } }</code> </pre><br>  As you can see, the Build builder method takes no parameters and returns a new object of the CalendarViewModel class - a ready-made view model. <br><br>  Now we specify our CalendarViewModel class as a view model for the Calendar view and add the month and year display from this view model: <br><br><pre> <code class="cs hljs">@model AspNetCoreViewModels.ViewModels.Default.Calendar.CalendarViewModel &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"header"</span></span>&gt; @Model.Date.ToString(<span class="hljs-string"><span class="hljs-string">"MMMM yyyy"</span></span>) &lt;/div&gt; &lt;/div&gt;</code> </pre><br>  Next, use the CalendarViewModelBuilder builder to transfer the view model to the view.  Our controller should take the following form: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DefaultController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calendar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalendarViewModelBuilder().Build()); } }</code> </pre><br>  Now we can start the application again, and this time something will already be displayed (I did a bit of tinkering with styles, so the future calendar already has some decoration): <br><br><img src="https://habrastorage.org/files/ec5/f7b/41e/ec5f7b41e86e4574b82c418802bb628a.png"><br><br>  Let's now output a string with the names of the days.  Since this is static information and it will not be used anywhere else, just add the appropriate markup directly to the view.  It should turn out like this: <br><br><pre> <code class="cs hljs">@model AspNetCoreViewModels.ViewModels.Default.Calendar.CalendarViewModel &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"header"</span></span>&gt; @Model.Date.ToString(<span class="hljs-string"><span class="hljs-string">"MMMM yyyy"</span></span>) &lt;/div&gt; &lt;table cellpadding=<span class="hljs-string"><span class="hljs-string">"0"</span></span> cellspacing=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;</code> </pre><br>  In a browser, it looks like this: <br><br><img src="https://habrastorage.org/files/59b/27f/713/59b27f71347c48128bee086ed557f194.png"><br><br>  Now came the turn of the most interesting - the display of days.  To do this, add a separate partial view _Day and a model of the form DayViewModel for it.  (It is also quite possible that later in our project we might want to display days with planned events regardless of the calendar. For example, as a separate block of events for today. We will keep this in mind.) <br><br>  For now, let's add a DateTime Date property to the DayViewModel class and 3 more bool properties ‚Äî IsNotCurrentMonth, IsWeekendOrHoliday, and IsToday: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DayViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime Date { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsNotCurrentMonth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsWeekendOrHoliday { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsToday { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  The build method of the builder this time takes one parameter - the date: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DayViewModelBuilder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DayViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DayViewModel() { Date = date, IsNotCurrentMonth = date.Month != DateTime.Now.Month, IsWeekendOrHoliday = date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday, IsToday = date.Date == DateTime.Now.Date }; } }</code> </pre><br>  As you can see, the builder initializes all the properties of the view model.  The IsNotCurrentMonth flag determines whether the day is outside the current month (in order to be able to highlight it in gray).  The IsWeekendOrHoliday set means that the day is a weekend or holiday, and IsToday means today (accordingly, we will highlight such days in red or green). <br><br>  The _Day partial view may look like this (note, we don‚Äôt specifically use the td tag here so that this partial view can be used separately from the calendar): <br><pre> <code class="cs hljs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"day @(this.Model.IsNotCurrentMonth ? "</span></span>not-current-month<span class="hljs-string"><span class="hljs-string">" : null) @(this.Model.IsWeekendOrHoliday ? "</span></span>weekend-or-holiday<span class="hljs-string"><span class="hljs-string">" : null) @(this.Model.IsToday ? "</span></span>today<span class="hljs-string"><span class="hljs-string">" : null)"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"date"</span></span>&gt; @Model.Date.Day.ToString(<span class="hljs-string"><span class="hljs-string">"00"</span></span>) &lt;/div&gt; &lt;/div&gt;</code> </pre><br>  Depending on the values ‚Äã‚Äãof the IsNotCurrentMonth, IsWeekendOrHoliday, and IsToday properties, the corresponding CSS classes are set. <br><br>  It remains to add a set of day view models to the calendar view model and make the calendar view model builder initialize this set. <br><br>  Reflecting on which logic is best implemented in the view model builder, and which one directly in the view, one should proceed from the results of a simple test: do you have to duplicate this logic again if you need to replace the view?  If so, then the logic should be placed in the view model builder.  If not, directly in the view (this means that the code is too specific and refers only to a specific display method).  Although if logic means something truly voluminous, then perhaps the best solution would be to make an additional view model for a specific view and transfer this logic to the Build method of its builder.  In our case, we could represent days as an array of 42 elements (6 rows of 7 days each), but in this case, in the Calendar view, we need logic to split this array into lines.  Therefore, perhaps it would be more appropriate to immediately make the array two-dimensional (unless we assume that in the future we will need to output the days in some other way than with a table): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalendarViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime Date { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DayViewModel[,] Days { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  The Build method of the builder of this view model can now be supplemented with the following logic: <br><br><pre> <code class="cs hljs">DayViewModel[,] days = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DayViewModel[<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>]; DateTime date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(DateTime.Now.Year, DateTime.Now.Month, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)date.DayOfWeek; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) offset = <span class="hljs-number"><span class="hljs-number">7</span></span>; offset--; date = date.AddDays(offset * <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j != <span class="hljs-number"><span class="hljs-number">7</span></span>; j++) { days[i, j] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DayViewModelBuilder().Build(date); date = date.AddDays(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Run the application and see what happened: <br><br><img src="https://habrastorage.org/files/e6c/5cd/146/e6c5cd146d174286bd78623f8081f2aa.png"><br><br>  Almost done.  Now let's deal with events.  First, we need to add the Event class to our model: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Event</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime Date { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Secondly, we will add some kind of fake data access layer, which in fact will simply return predefined objects for given dates.  I will not dwell on this in detail, its implementation (using the templates Unit of Work and Repository in its simplest form + using the built-in ASP.NET Core DI) can be viewed in a test project. <br><br>  Immediately add the EventViewModel view model, the builder for it, and partly the _Event view. <br><br>  EventViewModel class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime Date { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Build method of EventViewModelBuilder class: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EventViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Event @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventViewModel() { Date = @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.Date, Name = @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.Name }; }</code> </pre><br>  As you can see, in this case, the set of model view properties is almost identical to the set of model properties, therefore, in order not to project each property of one class onto a property of another class, we should use something like <a href="http://automapper.org/">AutoMapper</a> . <br><br>  Partial view of _Event: <br><br><pre> <code class="cs hljs">@model AspNetCoreViewModels.ViewModels.Shared.EventViewModel &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"event"</span></span>&gt; @Model.Date.ToString(<span class="hljs-string"><span class="hljs-string">"HH:mm"</span></span>)&lt;br /&gt; @Model.Name &lt;/div&gt;</code> </pre><br>  Obviously, all this can be reused, regardless of days or calendar. <br><br>  To finish our application, we need to add an IEnumerable type Events property to the DayViewModel class and initialize it in the day view model builder.  To do this, we need the daytime model builder to access the data access layer, which we have presented by implementing the Unit of Work pattern.  I would not like to touch on this now in detail so as not to enlarge an already large article.  In short, all calls to the data access layer within a single request to the controller should occur in the context of a single instance of the class of our unit of work.  That is, such an instance must be created when creating a controller object (for example, using DI) and transferred to all builders of view models along the chain.  Therefore, I added another abstract class ViewModelBuilderBase, whose constructor takes one storage argument of type IStorage and stores it in a protected variable so that all heirs can access it.  Now the Build method of the DayViewModelBuilder class can be extended by initializing the Events property: <br><br><pre> <code class="cs hljs">Events = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Storage.EventRepository.FilteredByDate(date).Select( e =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventViewModelBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Storage).Build(e) )</code> </pre><br>  As you can see, we access the EventRepository repository and use its FilteredByDate method to select all events for a given date, and then use the LINQ Select method and the EventViewModelBuilder builder to project each object of the Event model onto an object of the EventViewModel view model. <br><br>  If we now add the output of the events to the _Day partial view, then our application will be ready and by running it we will get what was depicted in the first screenshot: <br><br><pre> <code class="cs hljs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"events"</span></span>&gt; @<span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model.Events) { @Html.Partial(<span class="hljs-string"><span class="hljs-string">"_Event"</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) } &lt;/div&gt;</code> </pre><br>  That's all.  The final project structure: <br><br><img src="https://habrastorage.org/files/705/9ad/dee/7059addeef8940ab9ce2b361feb622a7.png"><br><br><h2>  Conclusion </h2><br>  I <a href="https://github.com/DmitrySikorsky/AspNetCoreViewModels">posted this project</a> on GitHub so that you can see it live.  Again, it is implemented on an ASP.NET Core.  <a href="https://www.microsoft.com/net/core">Here</a> you can find everything you need to run it. <br><br>  I hope I managed to explain the essence of this approach and demonstrate a simple way to implement it.  I did not mention anything at all about using view models to display forms, although this is no less a common scenario for using them.  If it is interesting, I can describe it in the next article.  Perhaps due to the use of the ‚Äúdatabase‚Äù the example seemed too confusing, but I would certainly like to touch on this aspect.  In general, thank you for your attention and I will be glad to hear criticism! </div><p>Source: <a href="https://habr.com/ru/post/309496/">https://habr.com/ru/post/309496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309484/index.html">OpenBSD Songs</a></li>
<li><a href="../309486/index.html">Optimizing multicast traffic on a local network using IGMP snooping</a></li>
<li><a href="../309488/index.html">Contributing to PostgreSQL: examples of real patches, part 1 of N</a></li>
<li><a href="../309490/index.html">PostgreSQL integration with MS SQL Server</a></li>
<li><a href="../309492/index.html">How to make a web-studio effective and start earning? 15 steps from WebCanape</a></li>
<li><a href="../309500/index.html">We invite developers to Droidcon Moscow 2016</a></li>
<li><a href="../309502/index.html">Spherical testing in vacuum: How to eat, how it should be, how it will be</a></li>
<li><a href="../309504/index.html">We write, collect and run HelloWorld for Android in Notepad. Java 8 and Android N</a></li>
<li><a href="../309506/index.html">Meet CALayer</a></li>
<li><a href="../309508/index.html">What is a convolutional neural network</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>