<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compile-time reflection D, practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 In the last article , the basic elements of the compile-time reflection, those building blocks of which ‚Äúreal‚Äù metaconstructions ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compile-time reflection D, practice</h1><div class="post__text post__text-html js-mediator-article">  Good day, Habr! <br><br>  In the last <a href="http://habrahabr.ru/post/261349/">article</a> , the basic elements of the compile-time reflection, those building blocks of which ‚Äúreal‚Äù metaconstructions are built, were considered.  In this article I want to show some of these techniques.  Let's try to implement signals and slots, similar to those in Qt, would be something like this: <br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> XObject { @‚Äã<span class="hljs-function"><span class="hljs-function">signal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> :</span></span> XObject { @‚Äã<span class="hljs-function"><span class="hljs-function">slot </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ writefln( <span class="hljs-string"><span class="hljs-string">"Bar.print: %s"</span></span>, str ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo, b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar; connect( a.message, b.print ); a.message( <span class="hljs-string"><span class="hljs-string">"hello habr"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Bar.print: hello habr }</span></span></code> </pre> <br>  Caution: a lot of code (with comments). <br><a name="habracut"></a><br>  Approximately, but not so =) But by and large not worse, everything has its own reasons, we will talk about them.  Final version: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Foo : XObject { mixin MixX; //     ,  mixin   @‚Äãsignal <span class="hljs-type"><span class="hljs-type">void</span></span> _message( string str ) {} //  ,   } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Bar : XObject { mixin MixX; //      slot,         <span class="hljs-type"><span class="hljs-type">void</span></span> print( string str ) { writefln( "Bar.print: %s", str ); } } <span class="hljs-type"><span class="hljs-type">void</span></span> main() { auto a = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo, b = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar; <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>( a.signal_message, &amp;b.print ); //    a.message( "hello habr" ); // Bar.print: hello habr }</code> </pre><br>  <a href="">The annoying rule</a> says that if the function was declared via mixin and there is the same, but simple (usually declared), then the function declared through mixin is replaced with a simple completely, even if the simple has no body.  Because of this, you need to declare essentially a different function with the body. <br><br>  Now let's start in order.  First of all, you need to realize that the approach with an array of delegates is "not very."  Of course, it all depends on the task.  In our case, we assume that there are several small requirements: <br><ol><li>  any object can be valid and no </li><li>  it is possible to translate an object into an invalid state (after creation it is valid) </li><li>  an object can have child objects </li><li>  if the parent ceases to be valid, the children also cease to be such </li><li>  no slots call of a valid object should be made (will not make sense) </li></ol><br>  By logic, the child objects are wholly owned by the parent. <br>  In D, class objects are managed by the collector, the destructor is called when garbage is collected or using the function destroy (obj).  There is also one thing: you can't manage memory when garbage collection.  Because of this, we cannot remove the object to be deleted from any list, and the collector himself will not do anything while the object is in such a list.  Considering the initial requirements and the idea of ‚Äã‚Äãthe collector, we conclude that we need the concept of ContextHandler.  This will be our basic interface. <br><div class="spoiler">  <b class="spoiler_title">Not complete, but sufficient for understanding, ContextHandler code</b> <div class="spoiler_text"><pre> <code class="hljs ruby">interface ContextHandler { <span class="hljs-symbol"><span class="hljs-symbol">protected:</span></span> void selfDestroyCtx(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-symbol"><span class="hljs-symbol">public:</span></span> @‚Äãproperty { ContextHandler parentCH(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ContextHandler[] childCH(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } final { T registerCH(T)( T obj, bool force=<span class="hljs-literal"><span class="hljs-literal">true</span></span> ) /<span class="hljs-regexp"><span class="hljs-regexp">/      if( is( T == class ) ) { if( auto ch = cast(ContextHandler)obj ) if( force || ( !force &amp;&amp; ch.parentCH is null ) ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ force -      obj    ... return obj; } T newCH(T,Args...)( Args args ) { return registerCH( new T(args) ); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    void destroyCtx() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       { foreach( c; childCH ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      c.destroyCtx(); selfDestroyCtx(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   } } }</span></span></code> </pre></div></div><br>  This is essentially a tree.  When an object is dealated, it does the same with its children.  Let's return to it later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The following concepts refer to the concept of "slot."  Although we have not created a separate UDA for slots, it makes sense to create a slot as such. <br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignalConnector</span></span></span><span class="hljs-class"> //   </span></span>{ void disconnect( SlotContext ); void disonnectAll(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SlotContext</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContextHandler //      </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">    { mixin MixContextHandler; // ContextHandler  mixin template     protected: size_t[SignalConnector] signals; //  </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">    public: void connect</span></span></span></span>( SignalConnector sc ) { signals[sc]++; } void disconnect( SignalConnector sc ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> signals ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( signals[sc] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) signals[sc]--; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> signals.remove(sc); } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void selfDestroyCtx() <span class="hljs-comment"><span class="hljs-comment">//        { foreach( sig, count; signals ) sig.disconnect(this); } } //    interface SlotHandler { SlotContext slotContext() @property; } class Slot(Args...) //    { protected: Func func; //  SlotContext ctrl; //  public: alias Func = void delegate(Args); this( SlotContext ctrl, Func func ) { this.ctrl = ctrl; this.func = func; } this( SlotHandler hndl, Func func ) { this( hndl.slotContext, func ); } void opCall( Args args ) { func( args ); } SlotContext context() @‚Äãproperty { return ctrl; } }</span></span></code> </pre><br>  Immediately consider the signal <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Args</span></span></span><span class="hljs-class">...) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SignalConnector</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContextHandler</span></span></span><span class="hljs-class"> { mixin </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MixContextHandler</span></span></span><span class="hljs-class">; protected: alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Slot</span></span></span><span class="hljs-class">!</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Args</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class">[] slots; //    public: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class"> connect( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> ) { if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connected</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) ) { slots ~= s; s.context.connect(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">); } return s; } void disconnect( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> ) //   { slots = slots.filter!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">).array; s.context.disconnect(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">); } void disconnect( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SlotContext</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> ) //     { foreach( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slots</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">).filter!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">) ) s.disconnect(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">); slots = slots .map!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">)) .filter!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[1] !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">) .map!(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[0]) .array; } void disconnect( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SlotHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sh</span></span></span><span class="hljs-class"> ) { disconnect( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sh</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slotContext</span></span></span><span class="hljs-class"> ); } void disonnectAll() //     { slots = []; foreach( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slots</span></span></span><span class="hljs-class"> ) s.context.disconnect( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> ); } //         void opCall( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> ) { foreach( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slots</span></span></span><span class="hljs-class"> ) s(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">); } protected: bool connected( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSlot</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> ) { return canFind(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slots</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">); } void selfDestroyCtx() { disonnectAll(); } //        }</span></span></code> </pre><br>  And finally, we got to the most interesting: the XBase interface and the intermediate class XObject (MixX is inserted and the default constructor is created).  The XBase interface extends ContextHandler with just a couple of functions, the most important is mixin template MixX.  All the magic of metaprogramming happens in it.  First, the logic of all actions should be explained.  UDA @ signal marks the functions that should be the basis for creating real signaling functions and the signal objects themselves.  Almost everything is taken from the marked functions: the name (without the initial underscore), the access level (public, protected) and, of course, the arguments.  Of the attributes, only @ system is allowed, since we want the signals to work with any slots.  The present signal function calls the opCall of the corresponding signal object, passing all the arguments.  In order not to create all signal objects in each new class, we will implement in MixX the function that does this for us.  Why create a separate function-signal and signal object?  In order for the signal to be a function, oddly enough.  This will allow to implement interfaces in classes that inherit XObject or implement XBase, as well as connect signals with the call of other signals: <br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Messager</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Drawable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//       class A : Drawable, XBase { mixin MixX; this() { prepareXBase(); } //    @‚Äãsignal void _onDraw() {} } class B : A, Messager { mixin MixX; @‚Äãsignal void _onMessage( string msg ) {} } class Printer : XObject { mixin MixX; void print( string msg ) { } } auto a = new B; auto b = new B; auto p = new Printer; connect( a.signal_onMessage, &amp;b.onMessage ); //     connect( &amp;p.print, b.signal_onMessage ); //  connect     ...</span></span></code> </pre><br>  Let's go back to XBase.  We will sort the code in parts: <br><pre> <code class="hljs coffeescript">interface XBase : SlotHandler, ContextHandler { public: enum signal; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       UDA,    enum protected: void createSlotContext(); void createSignals(); final void prepareXBase() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       ,  XBase { createSlotContext(); createSignals(); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> XBase   SlotHandler,         final auto newSlot(Args...)( void delegate(Args) f ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newCH!(Slot!Args)( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f ); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    ,       final auto connect(Args...)( Signal!Args sig, void delegate(Args) f ) { auto ret = newSlot!Args(f); sig.connect( ret ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } mixin template MixX() { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.traits; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ++,   mixin template  ,     static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X_BASE_IMPL)) ) { enum X_BASE_IMPL = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; mixin MixContextHandler; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ContextHandler <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  SlotHandler private SlotContext __slot_context; final { public SlotContext slotContext() @‚Äãproperty { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __slot_context; } protected void createSlotContext() { __slot_context = newCH!SlotContext; } } } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         mixin defineSignals; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        override protected { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  createSignal   ,       static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isAbstractFunction!createSignals ) void createSignals() { mixin( mix.createSignalsMixinString!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      createSignals    void createSignals() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.createSignals(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> mix.createSignalsMixinString        ,       mixin( mix.createSignalsMixinString!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) ); } } } ... }</code> </pre><br>  It should immediately make a reservation that mix is ‚Äã‚Äãa structure in which all methods of working with strings are concentrated.  Perhaps this is not the best solution, but it allows you to reduce the amount of names that fall into the final class, while keeping everything in the right place (in the XBase interface).  And once started talking, consider this structure. <br><pre> <code class="hljs lua"> static struct __MixHelper { import std.algorithm, std.array; enum NAME_RULE = <span class="hljs-string"><span class="hljs-string">"must starts with '_'"</span></span>; static pure @‚Äãsafe: //           bool testName( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'_'</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> getMixName( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">1.</span></span>.$]; } //      ,     - <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signalMixinString(T,alias temp)() @‚Äãproperty { ... } //        enum signal_prefix = <span class="hljs-string"><span class="hljs-string">"signal_"</span></span>; //      createSignals <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> createSignalsMixinString(T)() @‚Äãproperty { auto signals = [ __traits(derivedMembers,T) ] .filter!(a=&gt;a.startsWith(signal_prefix)); //    ,       /+     signal_       +           +/ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signals .map!(a=&gt;<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(<span class="hljs-string"><span class="hljs-string">"%1$s = newCH!(typeof(%1$s));"</span></span>,a)) // signal_onSomething = newCH!(typeof(signal_onSomething); .join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); //   ,       } //      template functionFmt(alias fun) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isSomeFunction!fun ) { enum functionFmt = <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>( <span class="hljs-string"><span class="hljs-string">"%s %s%s"</span></span>, (ReturnType!fun).stringof, //     __traits(identifier,fun), //   (ParameterTypeTuple!fun).stringof ); //    } } protected enum mix = __MixHelper.init;</code> </pre><br>  Returning to MixX, the most difficult part of it will be the mixin defineSignals. <br><pre> <code class="hljs cmake"> //         @‚Äãsignal    defineSignalsImpl mixin template defineSignals() { mixin defineSignalsImpl!( typeof(this), getFunctionsWithAttrib!( typeof(this), signal ) ); } //  ,       (   ,   ) mixin template defineSignalsImpl(T,<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>...) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.length == <span class="hljs-number"><span class="hljs-number">0</span></span> ) {} //   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { // <span class="hljs-string"><span class="hljs-string">"  "</span></span> mixin defineSignalsImpl!(T,<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..$/<span class="hljs-number"><span class="hljs-number">2</span></span>]); mixin defineSignalsImpl!(T,<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[$/<span class="hljs-number"><span class="hljs-number">2</span></span>..$]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mixin( mix.signalMixinString!(T,<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ); //  ,      }</code> </pre><br>  The getFunctionsWithAttrib template and mix.signalMixinString are roughly equivalent in complexity, but first consider mix.signalMixinString, as I cut out the __MixHelper story: <br><pre> <code class="hljs perl"> string signalMixinString(T,alias temp)() @‚Äãproperty { enum temp_name = __traits(identifier,temp); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -   enum func_name = mix.getMixName( temp_name ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      //  -    @‚Äã<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> enum temp_attribs = <span class="hljs-keyword"><span class="hljs-keyword">sort</span></span>([__traits(getFunctionAttributes,temp)]).array; static assert( temp_attribs == [<span class="hljs-string"><span class="hljs-string">"@‚Äãsystem"</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail Mix X for '%s': template signal function allows only @‚Äãsystem attrib"</span></span>, T.stringof ) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,         static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( __traits(hasMember,T,func_name) ) { alias base = AT!(__traits(getMember,T,func_name)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    //     static assert( isAbstractFunction!base, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail Mix X for '%s': target signal function '%s' must be abstract in base class"</span></span>, T.stringof, func_name ) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        @‚Äã<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> enum base_attribs = <span class="hljs-keyword"><span class="hljs-keyword">sort</span></span>([__traits(getFunctionAttributes,base)]).array; static assert( temp_attribs == [<span class="hljs-string"><span class="hljs-string">"@system"</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail Mix X for '%s': target signal function allows only @system attrib"</span></span>, T.stringof ) ); enum need_override = true; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> enum need_override = false; enum signal_name = signal_prefix ~ func_name; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      alias     ,      enum args_define = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"alias %sArgs = ParameterTypeTuple!%s;"</span></span>, func_name, temp_name ); enum temp_protection = __traits(getProtection,temp); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        ,   - enum signal_define = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"%s Signal!(%sArgs) %s;"</span></span>, temp_protection, func_name, signal_name ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       ,    opCall   enum func_impl = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"final %1$s %2$s void %3$s(%3$sArgs args) { %4$s(args); }"</span></span>, (need_override ? <span class="hljs-string"><span class="hljs-string">"override"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>), temp_protection, func_name, signal_name ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    (     ),      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [args_define, signal_define, func_impl].join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br>  Let's get back to the list of marked functions. <br><pre> <code class="hljs perl"> template getFunctionsWithAttrib(T, Attr) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;b&gt;&lt;<span class="hljs-regexp"><span class="hljs-regexp">/b&gt;:       ,      T /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/            alias getFunctionsWithAttrib = impl!( __traits(derivedMembers,T) ); enum AttrName = __traits(identifier,Attr); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  std.typetuple  ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      staticMap /</span></span> anySatisfy template isAttr(A) { template isAttr(T) { enum isAttr = __traits(isSame,T,A); } } //     template impl( names... ) { alias empty = TypeTuple!(); static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( names.length == <span class="hljs-number"><span class="hljs-number">1</span></span> ) { enum name = names[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,   __traits(derivedMembers,T)   alias, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   this   ,     static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( __traits(compiles, { alias member = AT!(__traits(getMember,T,name)); } ) ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   :    alias some = __traits(...) //     template AT(alias T) { alias AT = T; } alias member = AT!(__traits(getMember,T,name)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,       alias attribs = TypeTuple!(__traits(getAttributes,member)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( anySatisfy!( isAttr!Attr, attribs ) ) { enum RULE = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"%s must be a void function"</span></span>, AttrName ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      static assert( isSomeFunction!member, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail mix X for '%s': %s, found '%s %s' with @%s attrib"</span></span>, T.stringof, RULE, typeof(member).stringof, name, AttrName ) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -    void static assert( is( ReturnType!member == void ), <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail mix X for '%s': %s, found '%s' with @%s attrib"</span></span>, T.stringof, RULE, mix.functionFmt!member, AttrName ) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -    <span class="hljs-number"><span class="hljs-number">_</span></span> static assert( mix.testName( name ), <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">"fail mix X for '%s': @%s name %s"</span></span>, T.stringof, mix.functionFmt!member, AttrName, mix.NAME_RULE ) ); alias impl = member; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-string"><span class="hljs-string">""</span></span>  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> alias impl = empty; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> alias impl = empty; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> alias impl = TypeTuple!( impl!(names[<span class="hljs-number"><span class="hljs-number">0</span></span>..$/<span class="hljs-number"><span class="hljs-number">2</span></span>]), impl!(names[$/<span class="hljs-number"><span class="hljs-number">2</span></span>..$]) ); } }</code> </pre><br>  Checks can be inserted and more, depending on the task. <br><br>  It remains to consider the function connect.  It looks rather strange against the background of metaprogramming: <br><pre> <code class="hljs perl">void <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(T,Args...)( Signal!Args sig, T delegate(Args) slot ) { auto slot_handler = cast(XBase)cast(Object)(slot.ptr); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      enforce( slot_handler, <span class="hljs-string"><span class="hljs-string">"slot context is not XBase"</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            ,    void static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( is(T==void) ) slot_handler.connect( sig, slot ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> slot_handler.connect( sig, (Args args){ slot(args); } ); } void <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(T,Args...)( T delegate(Args) slot, Signal!Args sig ) { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>( sig, slot ); }</code> </pre><br>  Why didn't I do such a hack for a signal?  For example, so that you can call connect like at the beginning of the article: <br><pre> <code class="hljs lisp"> connect( <span class="hljs-name"><span class="hljs-name">a</span></span>.message, b.print )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Firstly, in this case, you need to fix the order of the signal and the slot, which would be well worth reflecting in the name.  But the most important reason: do not succeed.  This form <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> connect!(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> sig, <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> slot)() ...</code> </pre>  does not allow to save the context, alias passes essentially Class.method where Class is the name of the class, not an object.  And you need to enter additional.  check for matching signal and slot arguments.  A form with delegates <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T,Args...</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">delegate</span></span></span></span><span class="hljs-function"><span class="hljs-params">(Args</span></span></span><span class="hljs-function">) sig, T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Args</span></span></span><span class="hljs-function">) slot )</span></span> { ... } <span class="hljs-comment"><span class="hljs-comment">//    connect( &amp;a.message, &amp;b.print );</span></span></code> </pre>  loses information about the class that contains the signal.  I couldn‚Äôt find a function pointer (sig.funcptr) to display its name, and it would have happened at runtime, and the name of the signal object would need to be constructed somehow, and returned from the dictionary (SignalConnector [string]) did not look like would.  On this implemented as implemented =) <br><br>  The sample code is available on <a href="https://github.com/deviator/xobj">github</a> and as a <a href="http://code.dlang.org/packages/xobj">dub</a> package. </div><p>Source: <a href="https://habr.com/ru/post/261641/">https://habr.com/ru/post/261641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261625/index.html">Effective resizing of images using ImageMagick</a></li>
<li><a href="../261627/index.html">Changes in the PMP exam in 2015</a></li>
<li><a href="../261629/index.html">We write our simplified OpenGL on Rust - part 1 (draw a line)</a></li>
<li><a href="../261631/index.html">Ciklum Kiev invites to Speakers' Corner dedicated to the development for the Apple Watch</a></li>
<li><a href="../261637/index.html">Google Developer Launchpad - Google Startup Program</a></li>
<li><a href="../261647/index.html">Apple released iOS 8.4</a></li>
<li><a href="../261649/index.html">Misunderstanding about async / await and multithreading in C #</a></li>
<li><a href="../261651/index.html">WebP device</a></li>
<li><a href="../261653/index.html">The easiest way to start an encrypted chat</a></li>
<li><a href="../261655/index.html">New Intel IoT Developer Kit released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>