<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to remove all control characters from a string - the story of one stormy optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It turned out that I was able to optimize the code of the cluster problem, which was part of the Big Cluster Algorithm and was doing a very simple thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to remove all control characters from a string - the story of one stormy optimization</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage1/dea8696e/a59fd82c/6aaee854/adc25d55.jpg">  It turned out that I was able to optimize the code of the cluster problem, which was part of the Big Cluster Algorithm and was doing a very simple thing: depending on the contents of the fields, the input stream from <em>n</em> fields needed to be redistributed into the output stream from <em>m</em> fields and almost calm down.  Almost - because there were lines of arbitrary type inside the fields that needed to be ‚Äúcleared‚Äù - to carry out the simplest, seemingly, operation of deleting all control characters from the line. <br><br>  It turned out that this operation is not as ‚Äúsimplest‚Äù as it seems, especially if we consider it in modern languages ‚Äã‚Äãwith a virtual machine.  Below, I will show how you can replace a single line solution with a couple of dozen lines of solution, increasing the algorithm performance by ~ 10 times.  At once I will make a reservation that the examples will be related to Java, but similar reasoning will be true for most other languages ‚Äã‚Äãand virtual machines - first of all, for .NET-based. <br><a name="habracut"></a><br>  In fact, the whole activity of the algorithm was reduced to: <br><ol><li>  Get from the outside (over the network or from disk) a set of N fields: (in <sub>1</sub> , in <sub>2</sub> , ..., in <sub>n</sub> ) </li><li>  Do a dozen simplest operations like copying in to out with checks for simple conditions </li><li>  Clear all lines in (out <sub>1</sub> , out <sub>2</sub> , ..., out <sub>m</sub> ) from control characters </li><li>  Send them further (write to disk or send over the network) </li></ol><br>  From my point of view, it would be logical for such a task to be rested against a disk or a network ‚Äî the load on the processor here should be minimal.  However, the simplest profiling showed something completely different.  The original version contained a line on which 80-90% of the working time of the algorithm was spent - it was exactly one line that did operation 3, here it is: <br><br>  <b>Option 1</b> <br><pre><code class="java hljs">s = s.replaceAll(<span class="hljs-string"><span class="hljs-string">"\\p{Cntrl}"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br>  I even know <a href="http://thiamteck.blogspot.com/2008/09/java-remove-non-printable-characters.html">where this line came from</a> - a quick search on Google for the phrase ‚Äújava strip non-printable characters‚Äù gives exactly this option.  So, the task is clear, the goals are clear, the programmer's pride is hurt (‚Äúhow can I really not be able to disperse this unfortunate line‚Äù), let's go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We quickly do a simple binding that measures the time of the algorithm, isolate it from the rest of the code, generate a test input line, which we will run millions of times through the algorithm and measure the performance.  It turns out that the first version processes <b>517009</b> lines per second.  We take several measurements, we understand that the accuracy of our measurements and experiments is about 2-3% - i.e.  roughly speaking, it is possible not to look at the last 4 digits at all, but to look at the fifth digit from the end, but not to look.  Those.  results somewhere between <b>500..540</b> thousand. <br><br>  We recall what exactly we have for the lines and what we need to filter and what is <code>\p{Cntrl}</code> .  We understand that this element is essentially equivalent to the choice of characters with codes from 0 to 31 inclusive, plus 127. Just in case, we quickly check whether something gives if we change this <code>\p{Cntrl}</code> to a more trivial enumeration of all characters. in a regular expression through an operator of the type <code>[az]</code> , in our case: <br><br>  <b>Option 2</b> <br><pre> <code class="java hljs">s = s.replaceAll(<span class="hljs-string"><span class="hljs-string">"[\\x00-\\x1F]"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  No, it does not.  All the same <b>520000 ¬± 3%</b> . <br><br>  We recall that in the wonderful language Java, the compiler, the virtual machine and stdlibs often live a separate life and most likely do not optimize such a simple operation - despite the fact that the same regular expression is repeated millions of times, it is re-compiled each time.  Peeping into the <a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">documentation on String # replaceAll confirms</a> this guess.  We are trying to take this very compilation out of the brackets: <br><br>  <b>Option 3</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern KILL_CC_PATTERN = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"[\\x00-\\x1F]"</span></span>); ... Matcher m = KILL_CC_PATTERN.matcher(s); s = m.replaceAll(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  Suddenly, instead of one line - three, and the performance increased to <b>640000 ¬± 3%</b> - not many times, but suddenly + 23% we played. <br><br>  We do not think long to do better.  We try what happens if we go through the string manually in a loop, analyzing character by character (pulling them out through <a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">String # codePointAt</a> ), and saving it in another string.  The subconscious mind automatically suggests that not only in a string, but in a <a href="http://download.oracle.com/javase/6/docs/api/java/lang/StringBuilder.html">StringBuilder</a> or <a href="http://download.oracle.com/javase/6/docs/api/java/lang/StringBuffer.html">StringBuffer</a> .  In our case, it makes no difference what to use ‚Äî in our case, the cluster makes parallelization, starting N independent processes in parallel.  A quick glance at the documentation shows that it is recommended to pre-initialize a StringBuilder with some capacity ‚Äî the number of expected characters in the result.  There is no reason not to believe the documentation, so let's do it - we know for sure that as a result, we will obviously have no more than was originally in the line. <br><br>  <b>Option 4</b> <br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(s.length()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; s.length(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ch = s.codePointAt(j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) sb.appendCodePoint(ch); } s = sb.toString();</code> </pre><br>  7 lines instead of 1, but already <b>710000 ¬± 3%</b> lines per second.  This is + 37% - more than a third. <br><br>  We continue to think further.  A simple thought skips through - what will happen if I remove the work with Unicode codepoints and go on to using ordinary Java chars?  We will lose the opportunity to look at all sorts of surrogates, composites, etc.  as a whole - but from the point of view of stripping - nothing will be wrong.  We try: <br><br>  <b>Option 5</b> <br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(s.length()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; s.length(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = s.charAt(j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) sb.append(ch); } s = sb.toString();</code> </pre><br>  The same 7 lines, the change is insignificant at first glance, but the performance suddenly jumps to <b>1052000 ¬± 3%</b> !  This is already cool - a little more than 2 times relative to the original (+ 103%). <br><br>  Can it be done even faster?  Can!  Let's look inside StringBuilder, suddenly see that this is not some kind of wild magic that goes deep into the C-code of the JVM, but quite a solution in pure Java.  Inside StringBuilder, trite data structures are stored that link character strings through char arrays.  In our case, all these structures are unnecessarily - we are not going to insert something in the middle of the line, push it, etc.  You can really do everything stupidly on arrays, almost a C-way: <br><br>  <b>Option 6</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[s.length()]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; s.length(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = s.charAt(j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) { res[newLen] = ch; newLen++; } } s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(res, <span class="hljs-number"><span class="hljs-number">0</span></span>, newLen);</code> </pre><br>  The lines became 10, but the productivity doubled: as many as <b>2022000 ¬± 3%</b> !  This is 4 times faster than the original regexp. <br><br>  What else can you optimize?  The call to <code>append</code> is essentially optimized, but is it possible to somehow optimize the passage through the string using <code>String#charAt()</code> ?  It turns out too.  Having drunk another cup of coffee, let's try to peep inside the <a href="http://google.com/codesearch">sources of the String class</a> and the same StringBuilder.  There we will see that inside the String all the work goes with the same <code>char[]</code> , i.e.  You can reduce the number of method calls (operations like <code>invokevirtual</code> in terms of bytecode), reducing them to operations like <code>aload</code> , <code>iload</code> , <code>castore</code> , etc.  - which are very ‚Äúcheap‚Äù and well optimized by the JVM. <br><br>  Thus, everything is trivial: you can leave many charAt () calls by replacing them with one <a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">String # getChars</a> .  Checking: <br><br>  <b>Option 7</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] oldChars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[s.length()]; s.getChars(<span class="hljs-number"><span class="hljs-number">0</span></span>, s.length(), oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] newChars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[s.length()]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; s.length(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = oldChars[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) { newChars[newLen] = ch; newLen++; } } s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(newChars, <span class="hljs-number"><span class="hljs-number">0</span></span>, newLen);</code> </pre><br>  Another small miracle occurs: 12 lines, but <b>2500000 ¬± 3%</b> , i.e.  5 times faster than the original. <br><br>  Surely, we did the initial task a long time ago - the cluster algorithm started abutting on something else and not on this operation, and I spent on these micro-optimizations already quite indecently long time, so here my own brain preferred to surrender and accept the fact that it is hardly possible to do even faster.  After a while, for the sake of sports interest, I returned to the task and tried several more hypotheses: <br><ul><li>  What happens if instead of String # getChars () use <a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html">String # getBytes ()</a> ?  Nothing good will happen, inside Java it stores lines in the form of arrays of 16-bit numbers of type char;  operations like getBytes () are quite expensive, because  Conversion to any encoding (be it utf-8, any two-byte encoding or one-byte encoding) is a non-trivial operation.  The slowest, oddly enough, was the option to convert to windows-1251. </li><li>  Adding final wherever possible, contrary to traditionally established opinion, gives no increase </li><li>  Using the increment inside an array operation - <code>newChars[newLen++]</code> - doesn‚Äôt give anything except the reduction of the code by 1 line </li><li>  Parallelization in this particular place does not give anything - the cost of generating 2-3-4 threads and working on the line in parts is incommensurable with the gain from such parallelization;  plus, in the original task, parallelization and so provided a cluster framework </li></ul><br>  In continuation of sports interest, I <a href="http://stackoverflow.com/questions/7161534/">threw this puzzle on stackoverflow</a> and there I was prompted by several rather ancient, but, to my surprise, effective methods, in fact in pure C-style: <br><br>  <b>Option 8</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.length(); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] oldChars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[length]; s.getChars(<span class="hljs-number"><span class="hljs-number">0</span></span>, length, oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = oldChars[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) { oldChars[newLen] = ch; newLen++; } } s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>, newLen);</code> </pre><br>  Oddly enough, it gives as much as <b>3,100,000 ¬± 3%</b> lines per second, i.e.  almost 6 times faster than the original, and another 24% faster than the previous best version. <br><br>  The main gain is achieved by two banal, well-known with C, but still quite working constructs: predicting the length of the string in the variable length (saving on calls to String # length () - for some reason I hoped naively that the JVM would do it for me) and using the same oldChars array at the same time to store both the old and the new line (using the fact that from the old line we always need the j-th character, and at the time of reading the j-th character is always j &lt;= newLen). <br><br>  It would seem much further - but there is also the ninth option.  In fact, you can avoid any allocation at all by sacrificing the thread safety of this function and allocating a static buffer in advance.  We will play on the fact that most of the lines in the source stream are generally limited to some specific value from above - for example, 1024 characters.  Only for very isolated cases, it will be necessary to allocate a larger buffer - respectively, we will do this: <br><br>  <b>Option 9</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.length(); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] oldChars = (length &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>) ? buf : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[length]; s.getChars(<span class="hljs-number"><span class="hljs-number">0</span></span>, length, oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = oldChars[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) { oldChars[newLen] = ch; newLen++; } } s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>, newLen);</code> </pre><br>  A trifle seems to be, but it gives as much as <b>3490000 ¬± 3%</b> lines per second, i.e.  6.7 √ó increase (or + 12.5% ‚Äã‚Äãcompared to the previous version). <br><br>  The final version on which I have so far stopped is the tenth.  In fact, the last thing to save on is to create a new String object - it is especially a pity to do this, if in practice 99.9% of the lines passing through the algorithm do not need stripping and the output is equal to the input. <br><br>  <b>Option 10</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.length(); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] oldChars = (length &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>) ? buf : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[length]; s.getChars(<span class="hljs-number"><span class="hljs-number">0</span></span>, length, oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = oldChars[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span>) { oldChars[newLen] = ch; newLen++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLen != length) s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(oldChars, <span class="hljs-number"><span class="hljs-number">0</span></span>, newLen);</code> </pre><br>  This is a bit of cheating, because it uses a priori knowledge of the input stream, but it's worth it.  The final best result is <b>5350000</b> lines per second when processing a stream, in which only 0.1% of lines should be processed.  The increase is already 10 √ó from the original or + 53% from the previous version. <br><br><h1>  Conclusions and morals </h1><ul><li>  5-6 hours of work on 1 line can turn it into 15 lines and make it 10 times faster;  high price, but it is adequate, if we are talking about a really narrow place </li><li>  Reading Java stdlibs and JVM code can be quite useful. </li><li>  It is not always necessary to rush imprudently into religion "how everything is slow, let's rewrite everything on JNI" - often the problem can be solved without JNI </li><li>  Working with codepoints in Java will almost always be slower than working with char;  it's worth it to make it a rule to motivate why you need codepoints if you really want to use them </li><li>  The built-in Java regexps, firstly, have a damned API (inciting thereby to compile the same expressions too often), and secondly, they are rather slow on such simple operations;  However, the fact that embedded Java regexps is slow is <a href="http://www.tusker.org/regex/regex_benchmark.html">something everyone knows</a> </li><li>  Any complex data structures (StringBuffer, StringBuilder, String) in Java often work inside base arrays of primitive types, and often do so less optimally than we would like </li><li>  A lot of old tricks (final, work with bytes instead of wide characters) do not work </li><li>  A lot of old tricks (rendering the result of a frequently used method to a variable, saving on memory allocation, reuse) work very well </li></ul><br>  Hm  Maybe someone knows ways how to make it even faster? <br><br>  <i>PS The author of a wonderful photo at the beginning of the article is <a href="http://www.flickr.com/photos/jcolivera/">JcOlivera.com</a> , the photo is distributed under CC-BY-NC-ND.</i> </div><p>Source: <a href="https://habr.com/ru/post/126954/">https://habr.com/ru/post/126954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126945/index.html">Original texts: Yandex against copy-paste</a></li>
<li><a href="../126947/index.html">iPIF Margin notes about your second app</a></li>
<li><a href="../126948/index.html">Positive bias or what is common to the global crisis with a broken deadline</a></li>
<li><a href="../126949/index.html">Professional</a></li>
<li><a href="../126950/index.html">HeidiSQL - client to mysql / mssql servers</a></li>
<li><a href="../126955/index.html">Hacking nic.ly and Habrahabr</a></li>
<li><a href="../126957/index.html">Bots for browser games on AutoIT</a></li>
<li><a href="../126959/index.html">Orchard CMS extension: module creation</a></li>
<li><a href="../126960/index.html">CNET provides detailed information on hacker attacks.</a></li>
<li><a href="../126963/index.html">Alerts from Zabbix phone call</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>