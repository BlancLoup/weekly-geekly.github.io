<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Many to many link and upsert in Ecto 2.1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous chapter, we talked about many_to_many associations and how to map external data into associated entities using Ecto.Changeset.cast_ass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Many to many link and upsert in Ecto 2.1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="http://aserafin.pl/public/images/yes_we_can.jpg"></div><br><p> In the previous chapter, we talked about many_to_many associations and how to map external data into associated entities using <code>Ecto.Changeset.cast_assoc/3</code> .  Then we were forced to follow the rules imposed by the <code>cast_assoc/3</code> function, but this is not always possible or desirable. </p><br><p>  In this chapter, we will look at <code>Ecto.Changeset.put_assoc/4</code> versus <code>cast_assoc/3</code> and look at a few examples.  We will also take a look at the upsert function, which will appear in Ecto 2.1. </p><br><a name="habracut"></a><br><h2 id="put_assoc-vs-cast_assoc">  put_assoc vs cast_assoc </h2><br><p>  Imagine that we are creating a blog application that has posts and each post can have a lot of tags.  And also, each tag can refer to several posts.  This is a classic scenario where you can use <code>many_to_many</code> communication.  Our migration will look like this: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:posts) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :title <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">body</span></span> timestamps() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:tags) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> timestamps() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> unique_index(:tags, [:<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:posts_tags, primary_key: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :post_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:posts) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :tag_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:tags) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Notice that we added a unique index to the tag name, because we do not need tags with the same name in our database.  It is important to add an index at the database level, instead of using validations, as there is always a chance that two tags with the same name will be validated and inserted at the same time, which will lead to duplicate entries. </p><br><p>  Now, imagine also that the user enters tags as a list of words, separated by commas, like for example: ‚Äúelixir, erlang, ecto‚Äù.  When this data is received on the server, we will divide them into separate tags, link them to the desired post, and create those tags that are not yet in the database. </p><br><p>  So far, the conditions above sound reasonable, but they will definitely cause problems when using <code>cast_assoc/3</code> .  We remember that <code>cast_assoc/3</code> is a changeset function, created to obtain external parameters, and to compare them with the associated data in our model.  Ecto requires tags to be sent as a list of maps (list of maps).  However, in our case, we expect tags as a string, separated by a comma. </p><br><p>  Moreover, <code>cast_assoc/3</code> relies on the primary key value for each tag, in order to decide whether to insert it, update it, or delete it.  Again, since the user simply sends the string, we do not have information about the primary key. </p><br><p>  When we cannot deal with <code>cast_assoc/3</code> , it is time to use <code>put_assoc/4</code> .  In <code>put_assoc/4</code> , we get the Ecto structure or changeset, instead of parameters, which allows us to manipulate the data the way we want.  Let's define a schema and a changeset function for a post that can accept tags as a string: </p><br><pre> <code class="hljs sql">defmodule MyApp.Post <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Ecto.Schema <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> <span class="hljs-string"><span class="hljs-string">"posts"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :title <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">body</span></span> many_to_many :tags, MyApp.Tag, join_through: <span class="hljs-string"><span class="hljs-string">"posts_tags"</span></span> timestamps() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> changeset(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, params \\ %{}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> |&gt; Ecto.Changeset.cast(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, [:title, :<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>]) |&gt; Ecto.Changeset.put_assoc(:tags, parse_tags(params)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp parse_tags(params) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (params[<span class="hljs-string"><span class="hljs-string">"tags"</span></span>] || <span class="hljs-string"><span class="hljs-string">""</span></span>) |&gt; String.split(<span class="hljs-string"><span class="hljs-string">","</span></span>) |&gt; Enum.map(&amp;String.trim/<span class="hljs-number"><span class="hljs-number">1</span></span>) |&gt; Enum.reject(&amp; &amp;<span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-string"><span class="hljs-string">""</span></span>) |&gt; Enum.map(&amp;get_or_insert_tag/<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp get_or_insert_tag(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.get_by(MyApp.Tag, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) || Repo.insert!(MyApp.Tag, %Tag{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In the changeset function above, we brought all tag processing into a separate function called <code>parse_tags/1</code> , which checks for the existence of a parameter, divides it into values ‚Äã‚Äãusing <code>String.split/2</code> , then deletes the extra spaces with <code>String.trim/1</code> , deletes everything blank lines and at the end checks whether the tag exists in the database, and if not, creates it. </p><br><p>  Function <code>parse_tags/1</code> Returns a list of <code>MyApp.Tag</code> structures, which we throw into <code>put_assoc/3</code> .  Calling <code>put_assoc/3</code> , we tell Ecto that from now on these tags will be linked to the post.  If tags that were previously associated will not be received in <code>put_assoc/3</code> , then Ecto will bother to remove the association between the post and the remote tag in the database. </p><br><p>  And this is all that is needed to use the <code>many_to_many</code> connection with <code>put_assoc/3</code> .  The <code>put_assoc/3</code> function works with <code>has_many</code> , <code>belongs_to</code> and all other types of associations.  However, our code is not ready for production, let's see why. </p><br><h2 id="ogranicheniya-i-sostoyanie-gonki">  Limitations and race conditions </h2><br><p>  Recall that we added a unique index to the column <code>:name</code> tag.  We did this to protect ourselves from duplicate tags in the database. </p><br><p>  Adding a unique index and then using <code>get_by</code> with <code>insert!</code>  To get or insert a tag, we create a potential error in our application.  If two posts go at the same time with the same tags, then there is a chance that a check for the presence of a tag will occur at the same time, and both processes will decide that such a tag does not exist in the database.  When this happens, only one process will succeed, while the second will fail with an error.  This is a race condition (your lane is race condition): your code will fall with an error from time to time when certain conditions are met.  And these conditions will occur depending on the time. </p><br><p>  Many developers believe that such errors never happen in practice, or if they do, they are insignificant.  But in practice, the occurrence of these errors greatly impairs the user experience.  I heard an example of ‚Äúfirst hand‚Äù from a company that develops mobile games.  In their game, players can complete quests, and each quest you choose a second player (guest) from a certain list to complete the quest with you.  At the end of the quest, you can add a second player as a friend. </p><br><p>  Initially, the guest list was random, but after a while, users began to complain that sometimes old accounts, often inactive, appear in the guest list.  To remedy this situation, the developers began to sort the game list by the most active players in recent times.  This meant that if you played recently, then there is a high chance someone will appear on the guest list. </p><br><p>  However, when they made these changes, users began to see a lot of errors, and they, furious, came to the game forums.  This happened because when they sorted the list by activity, as soon as two players log in, their characters will most likely appear on each other guest list.  If these players choose each other, then only the first player, who will have time to add the second as a friend, will be able to do this, the second will not, because the relationship with this user will already exist!  Not only is this a problem, but the fact is that all the progress made for the quest will be lost, because the server will not be able to properly save the results to the database.  It is clear why users started complaining. </p><br><p>  Long story short: we must deal with the state of the race. </p><br><p>  Fortunately, Ecto provides us with a mechanism for handling database constraint errors. </p><br><h2 id="proverka-na-constraint-errors">  Check for constraint errors </h2><br><p>  When our function <code>get_or_insert_tag(name)</code> falls due to the fact that the tag already exists in the database, we need to handle this script.  Let's rewrite this function, keeping in mind the state of the race. </p><br><pre> <code class="hljs pgsql">defp get_or_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %Tag{} |&gt; Ecto.Changeset.change(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>) |&gt; Ecto.Changeset.unique_constraint(:<span class="hljs-type"><span class="hljs-type">name</span></span>) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, tag} -&gt; tag {:error, _} -&gt; Repo.get_by!(MyApp.Tag, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Instead of writing the tag directly, we first compile a changeset that allows us to use the <code>unique_constraint</code> annotation.  Now <code>Repo.insert</code> will not fall due to the error associated with the unique index on <code>:name</code> , but will return <code>{:error, changeset}</code> tuple.  Therefore, if the <code>Repo.insert</code> is successful, it means that the tag has been saved, otherwise, if the tag exists, then we just get it with <code>Repo.get_by!</code>  . </p><br><p>  Although the mechanism described above repairs a race condition, it is quite expensive.  We need to process two requests for each tag that already exists in the database: (unsuccessful) insert and then retrieve the tag from the repository.  Given that this is a fairly common scenario, we can rewrite it all as follows: </p><br><pre> <code class="hljs pgsql">defp get_or_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.get_by(MyApp.Tag, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>) || maybe_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp maybe_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %Tag{} |&gt; Ecto.Changeset.change(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>) |&gt; Ecto.Changeset.unique_constraint(:<span class="hljs-type"><span class="hljs-type">name</span></span>) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, tag} -&gt; tag {:error, _} -&gt; Repo.get_by!(MyApp.Tag, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The code above creates one request for each existing tag, two requests for each new tag, and 3 requests in the race state.  All this on average will work a little better, but Ecto 2.1 allows you to do better. </p><br><h2 id="upserts">  Upserts </h2><br><p>  Ecto 2.1 supports the so-called ‚Äúupsert‚Äù command, which is an abbreviation for ‚Äúupdate or insert‚Äù.  The idea is that when we try to write to the database and get an error, for example due to a unique index, we can decide whether the database will throw an error (the default), ignore the error (no error), or update the conflicting entity. </p><br><p>  The ‚Äúupsert‚Äù feature in Ecto 2.1 works with the <code>:on_conflict</code> parameter.  Let's rewrite the <code>get_or_insert_tag(name)</code> again using the <code>:on_conflict</code> parameter.  Remember that ‚Äúupsert‚Äù is a new feature of PostgreSQL 9.5, so make sure you have this version of the base. </p><br><p>  Let's try to use <code>:on_conflict</code> with the parameter <code>:nothing</code> as below: </p><br><pre> <code class="hljs pgsql">defp get_or_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>!(%MyApp.Tag{<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>}, on_conflict: :<span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Although the function above will not cause an error, in the event of a conflict, it will also not update the resulting structure, and will return a tag without an ID.  One solution is to force the update to occur even in the event of a conflict, even if the update involves changing the tag name.  In this case, PostgreSQL also requires <code>:conflict_target</code> parameter, which indicates the column (or list of columns) in which we expect an error: </p><br><pre> <code class="hljs pgsql">defp get_or_insert_tag(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>!(%MyApp.Tag{<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>}, on_conflict: [<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>]], conflict_target: :<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  And that's it!  We try to write the tag to the database, and if it already exists, then we tell Ecto to update the name to the current value, update the tag and get its id.  This decision is definitely one step ahead of the rest, it makes one request for each tag.  If 10 tags are received, there will be absolutely 10 requests.  How can we even improve it? </p><br><h2 id="upserts-i-insert_all">  Upserts and insert_all </h2><br><p>  Ecto 2.1 adds <code>:on_conflict</code> parameter not only to the <code>Repo.insert/2</code> , but also to the <code>Repo.insert_all/3</code> function introduced in Ecto 2.0.  This means that we can write down all the missing tags in one request, and one more get them all.  Let's see how the <code>Post</code> scheme will look like after these changes: </p><br><pre> <code class="hljs pgsql">defmodule MyApp.Post <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.<span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "posts" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :title <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :body many_to_many :tags, MyApp.Tag, join_through: "posts_tags" timestamps() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # Changeset <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same def changeset(struct, params \\ %{}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> struct |&gt; Ecto.Changeset.cast(struct, [:title, :body]) |&gt; Ecto.Changeset.put_assoc(:tags, parse_tags(params)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # Parse tags has slightly changed defp parse_tags(params) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (params["tags"] || "") |&gt; String.split(",") |&gt; Enum.map(&amp;String.trim/<span class="hljs-number"><span class="hljs-number">1</span></span>) |&gt; Enum.reject(&amp; &amp;<span class="hljs-number"><span class="hljs-number">1</span></span> == "") |&gt; insert_and_get_all() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp insert_and_get_all([]) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp insert_and_get_all(names) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> maps = Enum.map(names, &amp;%{<span class="hljs-type"><span class="hljs-type">name</span></span>: &amp;<span class="hljs-number"><span class="hljs-number">1</span></span>}) Repo.insert_all MyApp.Tag, maps, on_conflict: :<span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyApp.Tag, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: t.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ^names) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Instead of trying to write and retrieve each tag individually, the code above works with all tags at once, first creating a list of maps (comment lane list of maps) that is passed to <code>insert_all</code> and then receives all tags with the necessary names.  Now, despite how many tags we get, we always make only two requests (except for the option when no tags are received, then we will immediately return an empty list).  This solution is possible due to the introduction of the parameter in Ecto 2.1 <code>:on_conflict</code> , which guarantees that <code>insert_all</code> will not fail with an error if the tag received already exists. </p><br><p>  Finally, do not forget that we did not use transactions in any of the examples above.  This decision was deliberate.  Getting or writing tags is an idempotent operation, that is, we can repeat it as many times as you like, and always get the same result.  Therefore, if we cannot write a post to the database due to a validation error, the user will try to submit the form again, and each time we will perform an operation to receive or write tags.  In case this is not required, all operations can be wrapped in a transaction, or modeled using an <code>Ecto.multi</code> abstraction, which we will discuss in the following chapters. </p><br><p>  ¬ª <a href="http://blog.plataformatec.com.br/2016/12/many-to-many-and-upserts/%3Futm_source%3Delixir-status%26utm_medium%3Dsocial%26utm_campaign%3Dblog-post-promotion">Original</a> <br>  ¬ªAuthor: Jose Valim </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/317602/">https://habr.com/ru/post/317602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317580/index.html">Android and the ‚ÄúInternet of Things‚Äù are closer to each other</a></li>
<li><a href="../317584/index.html">How IT professionals work. Konstantin Osipov, developer and founder of the Tarantool project</a></li>
<li><a href="../317588/index.html">The Tale of Lost Time</a></li>
<li><a href="../317596/index.html">Mitap TechTalks from EXANTE and HSE</a></li>
<li><a href="../317598/index.html">Add-on to Avito. Startup or architecture example</a></li>
<li><a href="../317610/index.html">Test task as a means of collecting ideas</a></li>
<li><a href="../317612/index.html">Exporting tabular data from applications written under .NET in C #</a></li>
<li><a href="../317618/index.html">These companies are luring digital professionals from all the rest.</a></li>
<li><a href="../317620/index.html">DotNext - Moscow 2016. How it was</a></li>
<li><a href="../317622/index.html">Create your own ‚ÄúNeural Patterns‚Äù with the help of Deep Learning.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>