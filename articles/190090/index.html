<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Model-View in QML. Part Two: Custom Submissions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not always ready representations ideally approach. Consider the components that allow you to create a fully customized view and achieve great flexibil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Model-View in QML. Part Two: Custom Submissions</h1><div class="post__text post__text-html js-mediator-article">  Not always ready representations ideally approach.  Consider the components that allow you to create a fully customized view and achieve great flexibility in building the interface.  And from me a small bonus for patient readers :) <br><br>  Model-View in QML: <br><ol><li>  <a href="http://habrahabr.ru/post/181712/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/181712/">Part zero, introductory</a> </li><li>  <a href="http://habrahabr.ru/post/184416/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/184416/">Part One: Predefined Component Views</a> </li><li>  Model-View in QML.  Part Two: Custom Submissions </li><li>  <a href="http://habrahabr.ru/post/195706/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/195706/">Part Three: Models in QML and JavaScript</a> </li><li>  <a href="https://habrahabr.ru/post/302428/">Model-View in QML.</a>  <a href="https://habrahabr.ru/post/302428/">Part Four: C ++ Models</a> </li></ol><br><a name="habracut"></a><br><h5>  1. PathView </h5><br>  This component partly belongs to the same group of ready-made mappings, but the location of elements is completely controlled by the user.  This is achieved by the fact that the component allows you to arrange elements along a certain path, which is composed of straight lines, curves and arcs.  The path may be closed, but it is not necessary.  Throughout the way, we can also control the properties of the elements.  For example, you can make it so that in a certain place the element becomes larger and it seems that it is closer to the user.  In addition to this, those elements that should appear to be further away from the user can be made translucent.  In general, the possibilities for customizing the appearance of the elements are many. <br><br>  The main purpose of PathView is not just to display data, but also to make it look visually appealing.  It is with this component that things like CoverFlow are done (a popular way to display album covers in multimedia players). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  1) simple example </h6><br>  Let's start with a simple example, placing the elements along the curve (to be perfectly accurate, we use the quadratic <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">Bezier curve</a> ) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span> height: <span class="hljs-number"><span class="hljs-number">200</span></span> PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: <span class="hljs-number"><span class="hljs-number">30</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> startY: <span class="hljs-number"><span class="hljs-number">0</span></span> PathQuad { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width y: <span class="hljs-number"><span class="hljs-number">0</span></span> controlX: view.width / <span class="hljs-number"><span class="hljs-number">2</span></span> controlY: view.height } } delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> height: <span class="hljs-number"><span class="hljs-number">20</span></span> color: <span class="hljs-string"><span class="hljs-string">"orchid"</span></span> border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } }</code> </pre> <br>  The path is described with the help of an object of the Path type, into which we place objects describing parts of this path.  In our case, the path consists of a single section in the form of a curve. <br><br>  The parameters startX and startY describe the coordinates of the start of the path.  It ends where its last section ends.  In the section, on the contrary, not the beginning, but the end is specified, using the parameters x and y.  In our case, the curve is built on three points: in addition to the end and the beginning, we need another coordinate, on which it depends on what the bend will be.  For its coordinates are the properties controlX and controlY.  For a part of the way, coordinates are specified relative to the parent  Path object.  There are special properties that allow you to set the coordinates relative to the beginning of the path.  Such properties have the prefix relative (for example, relativeControlY). <br><br>  Let's see what we got: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/bdd/084/300/bdd08430008f84c4314e596713d6b22c.png"></div><br><br>  Since all elements are placed in the PathView, we can drag the elements with the mouse and will move along the path. <br><br><h6>  2) closed path </h6><br>  In the previous example, the path is unlocked.  After an element reaches its path, it appears at the beginning.  Not much harder to make the path closed.  For this, it is necessary that the coordinates of its beginning and end coincide.  The Path object even has a special property closed, which reflects whether it is closed. <br><br>  Let's slightly redo the first example and make a closed path of two Bezier curves (PathQuad): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span> height: <span class="hljs-number"><span class="hljs-number">400</span></span> PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: <span class="hljs-number"><span class="hljs-number">50</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">2</span></span> startY: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> PathQuad { <span class="hljs-attr"><span class="hljs-attr">relativeX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> y: view.height controlX: view.width controlY: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathQuad { <span class="hljs-attr"><span class="hljs-attr">relativeX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> controlX: <span class="hljs-number"><span class="hljs-number">0</span></span> controlY: <span class="hljs-number"><span class="hljs-number">0</span></span> } } delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> height: <span class="hljs-number"><span class="hljs-number">20</span></span> color: <span class="hljs-string"><span class="hljs-string">"hotpink"</span></span> border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } }</code> </pre><br>  Each element of the path begins where the previous one ends.  The last segment we end where the whole path begins. <br>  As a result, we get the following figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/8a0/237/7cd/8a02377cd8a4829379a4f3c535ce3bb5.png"></div><br><br><h6>  3) elements of the path </h6><br>  In addition to the curve considered, QtQuick has cubic Bezier curves - the same as the quadratic, but with two control points (PathCubic), a curve with an arbitrary number of points (PathCurve), an arc ‚Äî that is,  part of a circle (PathArk) and a straight line (PathLine).  In addition, you can specify a curve with a description in SVG format using the PathSvg component.  All these components can be combined to make the right path. <br><br>  There are additional components that do not control the placement of elements and their parameters.  One of them is PathPercent, which allows you to control the distribution of elements along sections of the path.  By default, the elements are distributed evenly, but with the help of this component it is possible to specify for parts of the path which part of the elements the number will be located there.  To do this, a PathPercent object is placed after the path section, the value parameter of which contains a part of the elements for this path (for example, 0.5 for half of the elements). <br><br>  Consider this with an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span> height: <span class="hljs-number"><span class="hljs-number">200</span></span> PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: <span class="hljs-number"><span class="hljs-number">20</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> startY: height PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">4</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.49</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">4</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.51</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width y: view.height } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> height: <span class="hljs-number"><span class="hljs-number">20</span></span> color: <span class="hljs-string"><span class="hljs-string">"orchid"</span></span> border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } }</code> </pre><br>  We make a path of two arcs and one straight line in the middle.  At the same time we are doing so that the elements concentrate on the extreme parts of the path.  And it turns out that the central area contains only one element: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/e46/d4d/21d/e46d4d21db2becd0f770c103bd58d7de.png"></div><br><br>  Another additional element of the path is the PathAttribute, which allows you to control the parameters of elements, depending on their location on the path.  In the delegate, these parameters will be available through the attached PathView.name properties, where the name is set using the name property. <br><br>  PathAttribute sets the parameter values ‚Äã‚Äãat the point in the path where it is located.  The values ‚Äã‚Äãof the parameters of the elements in the section of the path that is between two PathAttribute objects will smoothly move from the values ‚Äã‚Äãof one PathAttribute to another.  If on one side there is no this object, then zero values ‚Äã‚Äãwill be taken. <br><br>  Let's make it so that the central object is twice as large and that the extreme elements are translucent: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { property int itemSize: <span class="hljs-number"><span class="hljs-number">20</span></span> width: <span class="hljs-number"><span class="hljs-number">500</span></span> height: <span class="hljs-number"><span class="hljs-number">200</span></span> PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: <span class="hljs-number"><span class="hljs-number">20</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> startY: height PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">4</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.49</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize * <span class="hljs-number"><span class="hljs-number">2</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">1</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">4</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize * <span class="hljs-number"><span class="hljs-number">2</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">1</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.51</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width y: view.height } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: PathView.size height: PathView.size color: <span class="hljs-string"><span class="hljs-string">"orchid"</span></span> opacity: PathView.opacity border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } }</code> </pre><br>  And we get the elements in which the size and transparency are smoothly changed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/14a/53e/caf/14a53ecafc871e1aa5228afdb335216a.png"></div><br><br>  If you do not need a smooth transition, but you just need to make different sized elements, you can surround each such section of the path with PathView objects, and add additional sections of zero-length path between adjacent sections, where the transition from one parameter value to another will take place.  But due to the zero size, there are no elements there and this will not be seen. <br><br>  To demonstrate, we will slightly modify the previous example and make so that each of the three parts of the path is surrounded by PathAttribute objects, and between these parts we place PathLine objects of zero length. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { property int itemSize: <span class="hljs-number"><span class="hljs-number">20</span></span> width: <span class="hljs-number"><span class="hljs-number">500</span></span> height: <span class="hljs-number"><span class="hljs-number">200</span></span> PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: <span class="hljs-number"><span class="hljs-number">20</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> startY: height PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathCurve { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width / <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">4</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"size"</span></span>; value: itemSize } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.49</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">relativeX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; relativeY: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  PathAttribute { name: "size"; value: itemSize * 2 } PathAttribute { name: "opacity"; value: 1 } PathLine { x: view.width / 5 * 3 y: view.height / 4 } PathAttribute { name: "size"; value: itemSize * 2 } PathAttribute { name: "opacity"; value: 1 } PathPercent { value: 0.51 } PathLine { relativeX: 0; relativeY: 0 } //  PathAttribute { name: "size"; value: itemSize } PathAttribute { name: "opacity"; value: 0.5 } PathCurve { x: view.width / 5 * 4 y: view.height / 2 } PathCurve { x: view.width y: view.height } PathPercent { value: 1 } PathAttribute { name: "size"; value: itemSize } PathAttribute { name: "opacity"; value: 0.5 } } delegate: Rectangle { width: PathView.size height: PathView.size color: "orchid" opacity: PathView.opacity border { color: "black" width: 1 } } } }</span></span></code> </pre><br>  As a result, we obtain small translucent elements along the edges and one large and opaque element in the center: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/330/57d/1ef/33057d1eff733736521c880291942600.png"></div><br><br><h6>  4) CoverFlow </h6><br>  At the beginning of the section, I mentioned CoverFlow.  As a bonus to those who read up to this point, a small example of the implementation :) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { property int itemAngle: <span class="hljs-number"><span class="hljs-number">60</span></span> property int itemSize: <span class="hljs-number"><span class="hljs-number">300</span></span> width: <span class="hljs-number"><span class="hljs-number">1200</span></span> height: <span class="hljs-number"><span class="hljs-number">400</span></span> ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> text: <span class="hljs-string"><span class="hljs-string">"first"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"lightgreen"</span></span> text: <span class="hljs-string"><span class="hljs-string">"second"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orchid"</span></span> text: <span class="hljs-string"><span class="hljs-string">"third"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"tomato"</span></span> text: <span class="hljs-string"><span class="hljs-string">"fourth"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span> text: <span class="hljs-string"><span class="hljs-string">"fifth"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"hotpink"</span></span> text: <span class="hljs-string"><span class="hljs-string">"sixth"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"darkseagreen"</span></span> text: <span class="hljs-string"><span class="hljs-string">"seventh"</span></span> } } PathView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.fill: parent model: dataModel pathItemCount: <span class="hljs-number"><span class="hljs-number">6</span></span> path: Path { <span class="hljs-attr"><span class="hljs-attr">startX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> startY: height / <span class="hljs-number"><span class="hljs-number">2</span></span> PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"z"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: itemAngle } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: (view.width - itemSize) / <span class="hljs-number"><span class="hljs-number">2</span></span> y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: itemAngle } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.49</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"z"</span></span>; value: <span class="hljs-number"><span class="hljs-number">10</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">relativeX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; relativeY: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: (view.width - itemSize) / <span class="hljs-number"><span class="hljs-number">2</span></span> + itemSize y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0.51</span></span> } PathLine { <span class="hljs-attr"><span class="hljs-attr">relativeX</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; relativeY: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"z"</span></span>; value: <span class="hljs-number"><span class="hljs-number">10</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: -itemAngle } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; value: itemSize } PathLine { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: view.width y: view.height / <span class="hljs-number"><span class="hljs-number">2</span></span> } PathPercent { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"z"</span></span>; value: <span class="hljs-number"><span class="hljs-number">0</span></span> } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"angle"</span></span>; value: -itemAngle } PathAttribute { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; value: itemSize } } delegate: Rectangle { property real rotationAngle: PathView.angle property real rotationOrigin: PathView.origin width: itemSize height: width z: PathView.z color: model.color border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } transform: Rotation { axis { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; y: <span class="hljs-number"><span class="hljs-number">1</span></span>; z: <span class="hljs-number"><span class="hljs-number">0</span></span> } angle: rotationAngle origin.x: rotationOrigin } Text { anchors.centerIn: parent font.pointSize: <span class="hljs-number"><span class="hljs-number">32</span></span> text: model.text } } } }</code> </pre><br>  For a start, let's see the resulting result, and then analyze the implementation.  And we got something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/f32/0ef/8fa/f320ef8faf934d02bfb70d3c31ac3463.png"></div><br><br>  All elements, except the central one, are rotated around the Y axis. To do this, we assign delegates the transformation of rotation using the Rotation component.  In the axis property you need to set 1 for those axes around which the object will rotate. <br>  For elements, we change several parameters: the angle of rotation, the location along the Z axis, and the point of rotation (origin).  From an angle, everything is simple and obvious: the elements that are on the left rotate by 60 degrees, and those on the right, respectively, by -60.  But the rest of the parameters should stay in more detail. <br><br>  The Z coordinate determines which element will be ‚Äúhigher‚Äù, i.e.  when two objects in some place intersect, the object at which less Z will be blocked by an object at which Z coordinate is greater.  By default, in PathView, an item with a large index overlaps the previous one.  In CoverFlow for the elements on the left you need to be the opposite: ‚Äúabove‚Äù are those elements that are closer to the center.  If nothing is done, the last element will be added to the last but one, and that in turn will be placed on the element in front of it, etc.  Therefore, we change the Z coordinate so that the further the element is from the center, the ‚Äúlower‚Äù it is.  In our example, the dimensions are such that the elements do not overlap, but if you slightly reduce the width of the window, the overlap will immediately appear: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/607/2a8/807/6072a8807e1bf746259c4f103f4bf9eb.png"></div><br><br>  Finally, the turning point.  We set a point on our rectangle around which the rotation will take place.  By default, this is the upper left corner, i.e.  point with coordinates (0, 0).  Since  we rotate an element around the Y axis, then the Y coordinate itself does not matter here.  But on X pay attention.  In the case of elements located on the left side, we set these coordinates to 0 and rotate the element around the left edge and it turns out that the right edge visually gets farther.  If we do the same for the elements on the right, then it turns out that the elements on the left we turn "from ourselves", and the elements on the right - "to ourselves", i.e.  the left edge will be close, and the right will be even closer and the right side will be larger.  As a result, we get such a situation that the elements on the left and right will be of different sizes, which we do not need at all.  We all turn the elements ‚Äúfrom ourselves‚Äù and for this purpose in the elements to the right we shift the turning point to the upper right corner so that they rotate around their right edge. <br><br>  In previous examples, the PathView displayed all the elements from the model.  The number of items that can be displayed simultaneously can be limited using the pathItemCount parameter.  Here I set it equal to six. <br><br>  Summarizing, we can say that using QML, such a popular way of presenting data as CoverFlow, is quite simply implemented using elements from the standard library. <br><br><h6>  Short summary </h6><br>  PathView is a component focused primarily on creating an attractive interface.  This tool has great flexibility, allowing you to place elements not only in a straight line, but also along an arbitrary path, as well as change the delegate‚Äôs parameters depending on which part of the path it is in. <br><br><h5>  2. Its presentation </h5><br>  QML gives us the tools to make our presentation if we have such a need.  This is not very difficult and is realized by combining simple elements. <br><br>  First we need to create delegate objects for each element of the model.  For this we use a special component - Repeater.  He deals exclusively with the creation of elements, no positioning, etc.  things he does not do.  It is used in the same way as the components of * View: we give it a model and a delegate and it will create delegate instances for each element of the model. <br><br>  For positioning, we can apply the Row and Column elements in which we place our Repeater.  Elements created with Repeater become the children of its parent, i.e.  in this case, Row or Column, which position their elements as a row or column, respectively. <br><br>  There is only the task of navigation.  If there are so many elements that all of them do not fit into the space allotted to them, we need to implement scrolling of elements.  It is done using the Flickable component, which processes the mouse wheel and gestures of the touch screen or the same mouse and scrolls the elements. <br><br>  For example, we will make the elements arranged not vertically, but horizontally: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> text: <span class="hljs-string"><span class="hljs-string">"first"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"lightgreen"</span></span> text: <span class="hljs-string"><span class="hljs-string">"second"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orchid"</span></span> text: <span class="hljs-string"><span class="hljs-string">"third"</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"tomato"</span></span> text: <span class="hljs-string"><span class="hljs-string">"fourth"</span></span> } } Flickable { anchors.fill: parent contentWidth: row.width Row { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: row height: parent.height Repeater { <span class="hljs-attr"><span class="hljs-attr">model</span></span>: dataModel delegate: Item { <span class="hljs-attr"><span class="hljs-attr">height</span></span>: parent.height width: <span class="hljs-number"><span class="hljs-number">100</span></span> Rectangle { anchors.margins: <span class="hljs-number"><span class="hljs-number">5</span></span> anchors.fill: parent color: model.color border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } Text { anchors.centerIn: parent renderType: Text.NativeRendering text: model.text } } } } } } }</code> </pre><br>  We set the height of the Row element to be fixed, and the width will automatically change, depending on the total width of its children.  At Flickable, we set the contentWidth - this is, as you might guess, the width of its content.  If it is larger than the width of the Flickable itself, it will enable them to scroll.  In our example, the last element just does not hold and you can make sure that the scrolling works. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/bcd/392/661/bcd392661c83cf757c438a17861eceb1.png"></div><br><br>  As you can see, the QtQuick library allows you to do without the use of ready-made views and create your own from simple components, which will also work well. <br><br><h5>  findings </h5><br>  Standard components allow realizing representations of the most diverse types: from tables to elements arranged along an arbitrary path.  In addition to ready-made views, you can create your own completely from the basic components. <br><br>  PathView is designed to create a display focused on a beautiful appearance and animation and allows you to set the trajectory of the elements, vary the parameters of the element, depending on its location and the density of the elements in different parts of the path. </div><p>Source: <a href="https://habr.com/ru/post/190090/">https://habr.com/ru/post/190090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190078/index.html">HOT Watch: ‚Äúsmart‚Äù watches with the ability to talk ... on the palm of your hand</a></li>
<li><a href="../190080/index.html">Problem understanding</a></li>
<li><a href="../190082/index.html">A brief sketch of the history of Lisp machines</a></li>
<li><a href="../190084/index.html">1C-Bitrix - CMS from marketers. Advantages and disadvantages</a></li>
<li><a href="../190088/index.html">Thunderargs: practice of use. Part 2</a></li>
<li><a href="../190092/index.html">Humble Origin Bundle - sale of 8 epic games from EA</a></li>
<li><a href="../190096/index.html">Nested routing in AngularJS</a></li>
<li><a href="../190100/index.html">How I was a phone phreaker</a></li>
<li><a href="../190102/index.html">Moving ActionBar to the next level</a></li>
<li><a href="../190104/index.html">Setting up JavaCV in Windows 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>