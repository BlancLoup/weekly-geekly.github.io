<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Put the objects on the stream, the pattern of the factory of objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, reader. I want to share with you the knowledge of one of the patterns I use most often - the factory of objects, for this pattern another na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Put the objects on the stream, the pattern of the factory of objects</h1><div class="post__text post__text-html js-mediator-article">  Good day, reader.  I want to share with you the knowledge of one of the patterns I use most often - the factory of objects, for this pattern another name is also appropriate - the virtual designer. <br><br>  What is this pattern? <br><br>  Proceeding from the name, it is easy to guess that this is a certain, definite factory (or factory) that creates objects.  Once again I will express the word definite.  As in real life, the factory has a certain specialization, creating products or devices of a particular type.  And the factory, which produces, for example, furniture, can not produce, for example, also components for smartphones.  By analogy with programming, a factory of objects can only create objects of a certain type that use a single interface.  The main advantages of this pattern in C ++ are the simplified creation of objects of various classes using a single interface.  Often, libraries that develop programmers need not only to be able to work with certain objects, but also to create them.  The most obvious example is downloading files of various formats.  We do not know which file we will upload in advance, but we have a list of possible formats.  The user specifies the file, the library tries to determine the file type and call the appropriate loader for it.  In most cases, programmers use constructions like switch or if to determine which class instance they need to create.  And the more possible options appear, the more this structure expands, later turning into an ugly monster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What can a factory of objects offer us? <br>  First, a simple method of creating objects, which will reduce the switch / if to the 1st line. <br>  Secondly, convenient methods for working with factory objects.  We can always know for sure whether a particular class is registered with it, the number of registered classes, as well as convenient methods for adding and removing instances of classes in a factory.  With the help of the factory, you can limit the set of possible classes that it will create using a certain configuration. <br><br><a name="habracut"></a><br><h4>  Creating a concrete factory </h4><br>  To begin with, we implement a specific factory, without using templates, in order to understand how it should work. <br>  And so, we need a class that can create objects that support a single interface.  Let's call this interface Foo, and the factory, respectively, FooFactory.  As an identifier to create an object, take a string. <br><br><pre><code class="cpp hljs">lass FooFactory { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FooFactory(); ~<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  And so, so far everything is fine, but only a couple of lines of code are written.  And how are we going to add classes and actually create their instances?  Let us examine the problems in order.  Before you create an object, you need to add a class to the factory.  Obviously, we need some kind of function.  But how to transfer a class to a function, not an object? <br><br>  Alternatively, you can use the cloning strategy.  That is, to create an object, place it in a factory, and when calling the create method of a factory, call a function of type clone ().  The option is frankly a bad one, which forces the programmer not only to add the clone function to the Foo interface, and to implement it in all specific classes.  And besides, when adding an object to the factory, we will need to create it ‚Äî that is, allocate memory for the object.  And objects can be quite heavy.  Yes, of course, in the modern world, the problem of memory / performance is not so acute, but C ++ is such a language that allows optimizing both high-level and low-level constructions, and why not use it. <br><br>  Another option is when adding a class to a factory, passing a pointer to a function to the method that will create an object of the type you need.  In this case, there are even more problems than in the previous version.  It will be necessary to implement this function for each specific class being created, and when adding a class to the factory, pass this function as a parameter.  You can of course make macros, but it will look very unattractive, not to mention the fact that many believe that macros in C ++ are evil. <br><br>  But on the other hand, C ++ has templates that will help solve this not simple task.  To create objects of type Foo, we will use other auxiliary objects that will take on the job of creating objects of the class we need.  In common, such classes are called creator or instantiator.  An abstract creator class is created, which usually has only one method ‚Äî the creation of an object of a specific interface;  And on its basis concrete classes creators are already created.  Thanks to the abstract creator class, we can store a set of concrete creators in any container.  In this case, the templates will play the role of macros, allowing you to generate code for a specific creator based on the template parameter. <br><br>  The abstract class for creating objects of type Foo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstractFooCreator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  And a template class in which the actual code will be generated to create an object of a particular class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fooCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstractFooCreator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C(); } };</code> </pre><br>  Thus, we can already write our template method to add a class to the factory.  The only thing we need is to choose a container for storing our creators.  The obvious choice is std :: map. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, abstractFooCreator*&gt; FactoryMap; FactoryMap _factory; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; id) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FactoryMap::iterator it = _factory.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it == _factory.end()) _factory[id] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fooCreator&lt;C&gt;(); }</code> </pre><br>  Now we have the first working version of the factory, in which you can add classes that support the Foo interface. <br>  Well, in fact, our 2nd problem, namely the creation of objects of the desired type, has practically already been solved, since in fact it depended only on how we will store the creators. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FactoryMap::iterator it = _factory.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != _factory.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it-&gt;second-&gt;create(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Collect all the code to see the full picture. <br><br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstractFooCreator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fooCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> abstractFooCreator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C(); } }; lass FooFactory { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, abstractFooCreator*&gt; FactoryMap; FactoryMap _factory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FooFactory(); ~<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; id) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FactoryMap::iterator it = _factory.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it == _factory.end()) _factory[id] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fooCreator&lt;C&gt;(); } <span class="hljs-function"><span class="hljs-function">Foo * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FactoryMap::iterator it = _factory.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != _factory.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it-&gt;second-&gt;create(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre><br></div></div><br><br>  Well, a small example of how to use this factory.  Adding classes to the factory: <br><br><pre> <code class="cpp hljs">FooFactory factory; factory.add&lt;MyFoo&gt;(<span class="hljs-string"><span class="hljs-string">"MyFoo"</span></span>); factory.add&lt;MyFoo2&gt;(<span class="hljs-string"><span class="hljs-string">"MyFoo2"</span></span>); factory.add&lt;ImprovedFoo&gt;(<span class="hljs-string"><span class="hljs-string">"ImprovedFoo"</span></span>);</code> </pre><br>  Creating an object with a factory: <br><br><pre> <code class="cpp hljs">Foo * p = factory.create(<span class="hljs-string"><span class="hljs-string">"MyFoo2"</span></span>);</code> </pre><br>  So simply with the help of the factory you can manage the creation of objects that support a single interface. <br><br><h4>  Creating a template factory </h4><br>  Well, now we will create, on the basis of this particular example, a very specific pattern. <br><br>  What does our factory need to satisfy our capabilities?  Of course, this is an assignment of an identifier type, which can be either an enum or std :: string or any other type suitable for an identifier.  The second is the actual type of objects that we will create, whose role in the example above was performed by the Foo class. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectFactory() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ObjectFactory(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdType</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-function"><span class="hljs-function">Base * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br>  This is what our template factory will look like. <br>  We proceed to its implementation.  As in the Foo example, we need to solve the problem of creating objects of a particular type.  That is, we need an abstract class that has a method for creating an object of type Base, and a concrete creator class that inherits this abstract class and implements this method using a template parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCreator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AbstractCreator() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractCreator(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Base* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractCreator&lt;Base&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Creator() { } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Creator() {} <span class="hljs-function"><span class="hljs-function">Base * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C(); } };</code> </pre><br>  Well, now you just need to use these classes in our factory. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> AbstractCreator&lt;Base&gt; AbstractFactory; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;IdType, AbstractFactory*&gt; FactoryMap; FactoryMap _factory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectFactory() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ObjectFactory(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdType</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">) {</span></span> registerClass(id, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;C, Base&gt;()); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IdType &amp; id, AbstractFactory * p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FactoryMap::iterator it = _factory.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it == _factory.end()) _factory[id] = p; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p; } };</code> </pre><br>  What was significant compared to the example of Foo?  Of course, this is the registerClass method, which takes as an argument an object of the AbstractFactory type, which, in turn, can create objects of that class, which we specify as a template parameter for the add method. <br><br><h4>  Add the ability to set the behavior of the factory </h4><br>  I will omit, so far the creation of the remaining simple methods, such as checking the existence of the desired class in the factory, their number and deletion - a full listing can be viewed at the end.  I propose to make the factory even more flexible.  Indeed, besides the fact that we set the type of the identifier for the factory and the base class, the interface of which must be implemented by the classes placed in the factory, we can also add a customization of the behavior of our factory in case of certain errors.  What if the requested type is not in the factory at creation?  Return zero or throw an exception?  What should I do when I try to delete a nonexistent class or when I try to add an already registered object to the factory?  To be able to change the behavior of the factory, we need to use a different design pattern ‚Äî a strategy, also known as a policy.  This pattern is very well covered in the book A. Alexandrecu ‚ÄúModern Design in C ++‚Äù. <br><br>  In projects that I support is necessary, so far, only 2 behaviors.  Failure to respond to an error, and throwing a special type of exception, used in my projects.  The only parameter that is needed for debugging and in general for a detailed description of the error is the identifier, which we pass to the functions of creation, deletion, etc.  Thus, our policy interface should look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactoryIgnoreErrorPolicy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Base * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRemoveFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDuplicateRegistered</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span></span>{} };</code> </pre><br><br>  In addition to the actual functions that implement the behavior, the policy class also requires the type of interface that implements the factory and the type of identifier for which the error occurred and which is passed to all methods.  By analogy with IgnoreErrorPolicy, I will cite as an example the same policy that throws an exception in case of an error. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactoryException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectFactoryException(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; msg) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>() : _msg(msg) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ObjectFactoryException() <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * what() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _msg.c_str(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactoryThrowExceptionErrorPolicy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> strm; strm &lt;&lt; msg &lt;&lt; <span class="hljs-string"><span class="hljs-string">", requested type id : "</span></span> &lt;&lt; type; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strm.str(); } <span class="hljs-function"><span class="hljs-function">Base * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ObjectFactoryException(generateMessage(<span class="hljs-string"><span class="hljs-string">"ObjectFactory - can't create object (not registered)"</span></span>, type)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRemoveFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ObjectFactoryException(generateMessage(<span class="hljs-string"><span class="hljs-string">"ObjectFactory - can't remove class (not registered)"</span></span>, type)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDuplicateRegistered</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ObjectFactoryException(generateMessage(<span class="hljs-string"><span class="hljs-string">"ObjectFactory - class already registered"</span></span>, type)); } };</code> </pre><br></div></div><br>  Now let's build our policy into the factory.  This can be done in several ways - simply inherit from the policy class, or use the policy class as a factory attribute.  In both cases, the only problem is how to set the template parameters for the policy class from the factory class.  This will help us a great feature of C ++ - template template parameters.  When declaring a factory class, we indicate that we want to pass as a parameter not just some class, but a template class.  It will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> &lt;class, class&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactoryErrorPolicy</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactoryIgnoreErrorPolicy</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectFactory</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectFactoryErrorPolicy&lt;Base, IdType&gt; { ‚Ä¶</code> </pre><br>  As the 3rd parameter, the template &lt;class, class&gt; class is specified ... <br>  Immediately, a default policy is set for this parameter.  If you need to set a different policy, then when typedef a factory you need to specify the name of the class with the necessary policy as the last parameter, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ObjectFactory&lt;Foo, FooType, ObjectFactoryThrowExceptionPolicy&gt; FooFactory;</code> </pre><br>  In my case, I use the error ignoring policy much more often, so I set it as a default parameter.  You can go even further and make the policy dynamic, with the ability to change it at runtime, but for me at the moment this is not relevant and so far in my small practice such a mechanism has not been required.  Actually for this reason I chose the method of inheritance from the class of the policy, and not using it as an attribute of the factory. <br><br><h4>  Listing </h4><br><br>  Well, now is the time to take stock and present a full listing of the pattern with my implementation. <br><div class="spoiler">  <b class="spoiler_title">listing</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;map&gt; #include &lt;string&gt; #include &lt;memory&gt; #include &lt;sstream&gt; namespace grs { /*  ,       */ template &lt;class Base&gt; class AbstractCreator { public: AbstractCreator() { } virtual ~AbstractCreator() { } virtual Base* create() const = 0; private: AbstractCreator(const AbstractCreator&amp;); AbstractCreator&amp; operator = (const AbstractCreator&amp;); }; template &lt;class C, class Base&gt; class Creator : public AbstractCreator&lt;Base&gt; { public: Creator() { } virtual ~Creator() { } Base * create() const { return new C(); } }; /*    */ class ObjectFactoryException : public std::exception { std::string _msg; public: ObjectFactoryException(const std::string &amp; msg) throw() : _msg(msg) {} virtual ~ObjectFactoryException() throw() {} virtual const char * what() const throw() { return _msg.c_str(); } }; template &lt;class Base, class Type&gt; class ObjectFactoryIgnoreErrorPolicy { public: Base * onCreateFailed(const Type &amp; type) const { return 0; } void onRemoveFailed(const Type &amp; type) { } void onDuplicateRegistered(const Type &amp; type) { } }; template &lt;class Base, class Type&gt; class ObjectFactoryThrowExceptionErrorPolicy { public: std::string generateMessage(const char * msg, const Type &amp; type) const { std::stringstream strm; strm &lt;&lt; msg &lt;&lt; ", requested type id : " &lt;&lt; type; return strm.str(); } Base * onCreateFailed(const Type &amp; type) const { throw ObjectFactoryException(generateMessage("ObjectFactory - can't create object (not registered)", type)); } void onRemoveFailed(const Type &amp; type) { throw ObjectFactoryException(generateMessage("ObjectFactory - can't remove class (not registered)", type)); } void onDuplicateRegistered(const Type &amp; type) { throw ObjectFactoryException(generateMessage("ObjectFactory - class already registered", type)); } }; /*  */ template &lt;class Base, class IdType = int, template &lt;class, class&gt; class ObjectFactoryErrorPolicy = ObjectFactoryIgnoreErrorPolicy &gt; class ObjectFactory : public ObjectFactoryErrorPolicy&lt;Base, IdType&gt; { protected: typedef AbstractCreator&lt;Base&gt; AbstractFactory; typedef std::map&lt;IdType, AbstractFactory*&gt; FactoryMap; public: ObjectFactory() { } virtual ~ObjectFactory() { for (typename FactoryMap::iterator it = _map.begin(), endIt = _map.end(); it != endIt; ++it) delete it-&gt;second; } Base * create(const IdType &amp; id) const { typename FactoryMap::const_iterator it = _map.find(id); if (it != _map.end()) return it-&gt;second-&gt;create(); return onCreateFailed(id); } template &lt;class C&gt; void add(const IdType &amp; id) { registerClass(id, new Creator&lt;C, Base&gt;); } void remove(const IdType &amp; id) { typename FactoryMap::iterator it = _map.find(id); if (it != _map.end()) { delete it-&gt;second; _map.erase(it); } else onRemoveFailed(id); } bool isRegistered(const IdType &amp; id) const { return _map.find(id) != _map.end(); } size_t size() const { return _map.size(); } protected: void registerClass(const IdType &amp; id, AbstractFactory * pAbstractFactory) { std::auto_ptr&lt;AbstractFactory&gt; ptr(pAbstractFactory); typename FactoryMap::iterator it = _map.find(id); if (it == _map.end()) _map[id] = ptr.release(); else onDuplicateRegistered(id); } private: ObjectFactory(const ObjectFactory&amp;); ObjectFactory&amp; operator = (const ObjectFactory&amp;); FactoryMap _map; }; } // end of grs namespace</span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">A small example of using the factory</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ObjectFactory.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; enum Type { fooType, barType, maskedType, unknownType, firstType = fooType, lastType = maskedType, }; std::ostream &amp; operator &lt;&lt; (std::ostream &amp; strm, const Type &amp; type) { const char * names[] = {"foo", "bar", "masked"}; if (type &lt; firstType || type &gt; lastType) return strm &lt;&lt; "unknown type(" &lt;&lt; int(type) &lt;&lt; ")"; return strm &lt;&lt; names[type]; }; class Base { public: virtual ~Base() {} virtual Type type() const = 0; }; class Foo : public Base { public: virtual Type type() const { return fooType; } }; class Bar : public Foo { public: virtual Type type() const { return barType; } }; class MaskedFoo : public Foo { public: virtual Type type() const { return barType; } }; typedef grs::ObjectFactory&lt;Base, Type&gt; TypeFactory; void checkType(TypeFactory &amp; factory, Type type) { std::auto_ptr&lt;Base&gt; p; p.reset(factory.create(type)); std::cout &lt;&lt; "Object with type : " &lt;&lt; type; if (p.get()) { if (type == p-&gt;type()) std::cout &lt;&lt; " - successfully created\n"; else std::cout &lt;&lt; " - created, but type mismatch\n"; } else std::cout &lt;&lt; " - create failed\n"; } int main() { TypeFactory factory; factory.add&lt;Foo&gt;(fooType); factory.add&lt;Bar&gt;(barType); factory.add&lt;MaskedFoo&gt;(maskedType); checkType(factory, fooType); checkType(factory, barType); checkType(factory, maskedType); checkType(factory, unknownType); return 0; }</span></span></span></span></code> </pre><br></div></div><br><br>  Also, along with an example, the pattern can be taken from <a href="https://bitbucket.org/rtorsten/torstenutils/src">bitbucket</a> , besides it there are several other useful classes. <br><br>  That's all.  Good and creative coding! <br><br><h4>  Links </h4><br>  If you are interested in design patterns, I advise you to pay attention to these books.  In A.Aleksandresku's book, the features of C ++ syntax are very well conveyed when working with templates.  And in the book of the gang of 4 you can find all the most popular patterns used in many programming languages. <br><ul><li>  <a href="http://www.ozon.ru/context/detail/id/3829080/">A.Aleksandrescu - Modern design in C ++</a> </li><li>  <a href="http://www.ozon.ru/context/detail/id/2457392/">Gang of 4 - Design Patterns</a> <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/129202/">https://habr.com/ru/post/129202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129195/index.html">Normalization of relationships. First and second normal forms</a></li>
<li><a href="../129196/index.html">QNX RTOS: loosely coupled cross-tasking PPS</a></li>
<li><a href="../129198/index.html">Profit Zynga fell by 95%</a></li>
<li><a href="../129199/index.html">Cloud4Y at InfoSecurity Russia. StorageExpo. Documation '2011</a></li>
<li><a href="../129201/index.html">The implementation of dictionary objects, as in Javascript</a></li>
<li><a href="../129204/index.html">The story of a hack or how they tried to lead away everything, but did not take away anything</a></li>
<li><a href="../129205/index.html">On-the-fly Compilation in Erlang</a></li>
<li><a href="../129206/index.html">Zynga launched CityVille on Google+</a></li>
<li><a href="../129207/index.html">Writing your own linux daemon with auto repair feature</a></li>
<li><a href="../129208/index.html">Sea, sun, student projects: Mat Fur Summer School</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>