<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of interactive diagrams using OOP on the example of the prototype editor of UML diagrams. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Software developers often have to face the need to create two-dimensional interactive graphic components. Programmers who were previously accustomed t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of interactive diagrams using OOP on the example of the prototype editor of UML diagrams. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Software developers often have to face the need to create two-dimensional interactive graphic components.  Programmers who were previously accustomed to working only with data processing algorithms face great difficulties when such problems occur, unless you can do with some very primitive solution, such as a static image with predefined "active" areas.  The non-standard task of many frightens and forces them to look for ready-made tools and libraries for drawing graphs.  But no matter how multifunctional a library is, it will be something missing in it to solve exactly your problem. <br><br>  In this article, we will examine in detail the creation from scratch of a component with interactive, drag-and-drop elements in an object-oriented development environment.  As an example, we will build a prototype UML editor. <br><img src="https://habrastorage.org/files/7af/a12/d83/7afa12d8342f416eb6d625416257c44f.png"><br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br><h3>  Basic solution requirements </h3><br>  The list of tasks requiring the implementation of interactive graphics is quite extensive.  It can be <br><ul><li>  conventional equipment diagrams (installations, conveyors, transport systems) on which the operation status of the nodes is displayed, ‚Äúat the click of the mouse‚Äù the user wants to receive additional information or enter control commands, </li><li>  analytical graphs (histograms, bubble charts), ‚Äúat the click of a mouse‚Äù on which elements the user wants to receive information, or the user wants to directly ‚Äúdrag‚Äù elements with the mouse, changing the picture in the right direction to find out the necessary numerical indicators, </li><li>  visual analysis of data represented in the form of graphs (for example: relationships between legal entities in the database), the user wants to ‚Äúdrag‚Äù the elements of the graph manually in order to finally insert the resulting image into the printed report, </li><li>  all means of visual modeling / designing of any of the blocks, in particular, all CASE-tools, </li></ul><br>  - and so on and so forth.  Although the appearance of all these diagrams is different, in all cases you need to implement some general requirements.  Here they are: <br><ul><li>  The picture should consist of discrete elements of different graphic complexity, </li><li>  The picture should be scalable and scrollable, i.e. the user should be able to see any of the fragments of the diagram using a larger scale, using the zoom and scroll bars, <br><img src="https://habrastorage.org/files/f35/9df/b62/f359dfb621344b90a14dbd8783614bd3.gif"></li><li>  Some of the elements of the picture must be ‚Äúclickable‚Äù, i.e. the system must at each moment ‚Äúunderstand‚Äù what element the mouse pointer is pointing at, be able to show tooltips for them, <br><img src="https://habrastorage.org/files/114/2ba/518/1142ba518fa14327a86014df51beed0f.gif"><br></li><li>  Some of the ‚Äúclickable‚Äù elements should be ‚Äúselectable‚Äù, i.e. the user should be able to ‚Äúput a selection‚Äù on the element by a mouse click, the selection of a group of elements should be available with the Shift key pressed and using the ‚Äúrectangular lasso‚Äù.  With selected objects, depending on the task, some actions or changes in properties can be performed. </li><li>  Some of the ‚Äúclickable‚Äù elements should be ‚Äúdraggable‚Äù, i.e. the user should be able to move one element or a group of selected elements with the mouse: <br><img src="https://habrastorage.org/files/c01/6ad/a8a/c016ada8a8dd4cc4af4987c3f016675b.gif"><br></li></ul><br>  The importance of the possibility of "dragging" items should be emphasized.  If your task includes the need to visualize graphs, you need to remember: none of the numerous algorithms for automatically locating graph nodes on a plane can provide a solution that is completely satisfactory in all cases, and for the convenience of the user, manual rearrangement of graph nodes is simply necessary. <br>  What are the "ingredients" needed to prepare this "dish"?  In this article, we will show general principles that can be applied in any development environment when all <b>four key conditions</b> are met: <br><ol><li>  Object Oriented Programming Language. </li><li>  The availability of the object ‚Äúcanvas‚Äù (Canvas), with the possibility of drawing graphic primitives (lines, arcs, polygons, etc.). </li><li>  Components that implement manageable scroll bars. </li><li>  Availability of mouse event handling. </li></ol><br>  Our illustrative example is a prototype of the UML Use Case-diagrams editor, we will use the beautiful diagram from <a href="http://creately.com/blog/diagrams/use-case-diagram-tutorial/">this manual</a> .  The source code of our example is available at <a href="https://github.com/inponomarev/graphexample">https://github.com/inponomarev/graphexample</a> and can be compiled using Maven.  If you want to learn more about the principles outlined in the article, I strongly recommend that you download these sources and study them along with the article. <br><br>  The example is built in Java 8 with the standard Swing library.  However, there is nothing Java-specific in the principles outlined.  We first implemented the principles outlined here in Delphi (Windows applications), and then in Google Web Toolkit (web applications with graphics output on HTML Canvas).  If the above four conditions are met, the proposed example can be converted to another development environment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  The difficulties of the "naive" approach </h3><br>  In general, drawing some kind of scheme on the screen using the methods of displaying graphic primitives is a task that is not difficult.  Stick, stick, cucumber (with a similar exercise in the BASIC language once upon a time I first became acquainted with programming): <br><pre><code class="java hljs">canvas.drawOval(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); canvas.drawLine(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); canvas.drawLine(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); canvas.drawLine(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); canvas.drawLine(<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br><img src="https://habrastorage.org/files/8a7/ae3/b3b/8a7ae3b3ba30492dac9469f4ef61332d.png"><br>  But so far our ‚Äúlittle man‚Äù has not ‚Äúcome to life‚Äù: he cannot be singled out, scaled, moved on the canvas, he does not know how to interact with the society of other ‚Äúlittle men‚Äù.  So you need to write the code responsible for all these operations.  For a simple picture, this seems simple, however, as the complexity of what we want to get, we are waiting for problems. <br><ul><li>  With the complexity of the picture, the length of the ‚Äúdrawing procedure‚Äù increases.  For a complex scheme, the procedure becomes very long and confusing. </li><li>  The code that draws the picture itself ‚Äúby magic‚Äù does not set a criterion by which it would be possible to determine the object currently selected by the mouse cursor.  We have to write a separate procedure that defines the object over which the mouse cursor is located, and at the same time, we must constantly synchronize the drawing procedure code and the object recognition procedures. </li><li>  Along with the complexity of the drawing procedure, the complexity of the recognition procedure increases. </li></ul><br>  An attempt to solve the problem "in the forehead" with the complication of procedures is doomed to failure due to the rapid complication of the source code, the amount of which will grow like an avalanche as the diagram becomes more complex.  However, the use of object-oriented development, the universal principle of "divide and conquer", as well as design patterns give us powerful enough tools to gracefully deal with the problems listed and implement the necessary functionality. <br><br>  So, we proceed to the decision. <br><br><h2>  Task decomposition  Class structure </h2><br>  Let's start by breaking down the task into small pieces by building a hierarchical list of what we need to draw. <br>  First, draw a picture that we want to get, on a blackboard or on paper: <br><br><img src="https://habrastorage.org/files/54d/698/c22/54d698c22a624edfa427169a32bbbd77.png" width="600"><br><br>  And build the following hierarchy: <br><ul><li>  The whole diagram <br><ul><li>  <i>Roles (Actors)</i> <br><ul><li>  <i>Role signatures</i> </li></ul></li><li>  <i>Use Cases</i> </li><li>  Inheritance (generalizations) </li><li>  Associations </li><li>  Dependencies (dependencies) <br><ul><li>  <i>Signatures of dependency stereotypes</i> </li></ul></li></ul><br></li></ul><br><br>  Our example is, in fact, very simple, so the hierarchy was shallow.  The more complex the picture, the wider and deeper the hierarchy will be. <br><br>  Please note that some items are <i>in italics</i> .  These are the objects in the diagram that we want to make selected and moved using the mouse cursor. <br><br>  Each of the points in this hierarchy will correspond to a drawing class, and the hierarchical relationship between them allows the <b>Composite</b> pattern to be used ‚Äî the ‚Äúlinker‚Äù, which (I quote the book <a href="https://ru.wikipedia.org/wiki/Design_Patterns">‚ÄúDesign Patterns‚Äù</a> ) ‚Äúassembles objects into tree structures to represent part-whole hierarchies, allows‚Ä¶ uniformly to treat individual and composite objects ".  That is, doing exactly what we need. <br><br>  On the class diagram, our system has the following form: <br><img src="https://habrastorage.org/files/c22/8ec/6e9/c228ec6e912043b9b19177c2ca36be9d.png"><br><br>  At the top of the class diagram are two classes (DiagramPanel and DiagramObject), which ‚Äúdo not know anything‚Äù about the specifics of the diagram being drawn and form a framework on the basis of which diagrams of various types can be made.  DiagramPanel (in our case, this is the heir to the javax.swing.JPanel class) is a visual component of the interface responsible for displaying the diagram and its interaction with the user.  The DiagramPanel object contains a link to the DiagramObject - the root drawing object corresponding to the highest level of the drawing hierarchy (in our case it will be an instance of the UseCaseDiagram class). <br><br>  DiagramObject is the base class of all drawing objects, which implements their hierarchy through the Composite pattern and much more, which will be discussed further. <br><br>  At the bottom is an example of using the framework.  The Example class (the successor of javax.swing.JFrame) is the main application window, which in our example contains an instance of DiagramPanel as one single component.  All other classes are descendants of DiagramObject.  They correspond to the tasks in the hierarchical drawing list.  Please note that the inheritance hierarchy of these classes and the drawing hierarchy are different hierarchies! <br><br>  The rendering hierarchy, as described above, looks like this: <br><br><ul><li>  UseCaseDiagram - whole diagram, <br><ul><li>  <i>DiagramActor - the role</i> <br><ul><li>  <i>Label - the role signature,</i> </li></ul></li><li>  <i>DiagramUseCase - use case,</i> </li><li>  DiagramGeneralization - inheritance, </li><li>  DiagramAssociation - communication, </li><li>  DiagramDependency - dependency, <br><ul><li>  <i>Label - the signature of the dependence stereotype.</i> </li></ul></li></ul><br></li></ul><br><br>  Next we describe in detail the device of the DiagramObject and DiagramPanel classes and how they should be used. <br><br><h2>  Class DiagramObject and its heirs </h2><br><h3>  Data structure </h3><br>  The DiagramObject class is designed so that inside each of its instances there is a doubly linked list of subordinate renderers.  This is achieved with the help of the variables previous, next, first and last, which allow to refer to the neighboring elements in lists and hierarchy.  When objects are instantiated, we get something like this: <br><br><img src="https://habrastorage.org/files/7a6/1b5/a97/7a61b5a972294ab9a356bf2e68b322e5.png"><br><br>  This data structure, similar to a simple doubly linked list, is good in that we can assemble the hierarchy we need in O (N) time, and in O (1) time, if necessary, and modify it by deleting a given element or inserting a new one into the list after which -or specified item.  Access to the elements of this structure is of interest to us only sequential, corresponding to a tree-by-depth walkthrough, which is achieved by passing through the links.  The movement along the red arrows corresponds to a round trip, and along the blue arrows - the round trip. <br><br>  To add a new object to the internal DiagramObject list, use the addToQueue method (DiagramObject subObj): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (last!=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) { last.next = subObj; subObj.previous = last; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first = subObj; subObj.previous = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } subObj.next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; subObj.parent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; last = subObj;</code> </pre><br><br>  In order to collect the desired picture, it remains only to instantiate the necessary number of necessary drawing devices and combine them into a queue in the right order.  In our example, most of this work takes place in the UseCaseDiagram class constructor: <br><pre> <code class="java hljs">DiagramActor a1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramActor(<span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>); addToQueue(a1); DiagramActor a2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramActor(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-string"><span class="hljs-string">"NFRC Customer"</span></span>); addToQueue(a2); DiagramActor a3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramActor(<span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-string"><span class="hljs-string">"Bank Employee"</span></span>); addToQueue(a3); ‚Ä¶ DiagramUseCase uc1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramUseCase(<span class="hljs-number"><span class="hljs-number">250</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-string"><span class="hljs-string">"Open account"</span></span>); addToQueue(uc1); DiagramUseCase uc2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramUseCase(<span class="hljs-number"><span class="hljs-number">250</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-string"><span class="hljs-string">"Deposit funds"</span></span>); addToQueue(uc2); ‚Ä¶ addToQueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramAssociation(a1, uc1)); addToQueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramAssociation(a1, uc2)); ‚Ä¶ addToQueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramDependency(uc2, uc5, DependencyStereotype.EXTEND)); addToQueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramDependency(uc2, uc6, DependencyStereotype.INCLUDE)); ‚Ä¶ addToQueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagramGeneralization(a2, a1));</code> </pre><br><br>  In real life, of course, this is not the case: instead of ‚Äústitching into the code‚Äù the process of creating drawing objects, you will need to transfer the data model of your system to the root class constructor.  By traversing the objects of this model already in cycles, you will create a renderer.  For example, for each instance of the class Actor associated with the current diagram (corresponding to the ‚Äúrole‚Äù in your ‚ÄúUML document model‚Äù), you must instantiate an object of the DiagramActor drawing class. <br><br>  It is convenient when the renderers store references to the corresponding model objects.  It is more convenient to transfer these links directly in the form of the parameters of the designers of renderers.  In our example, instead of them, world coordinates of objects and their parameters, such as name and stereotype, are transmitted. <br><br><h3>  World and screen coordinates </h3><br>  Since we have used the term ‚Äúworld coordinates‚Äù, we need to clarify what it is in our case.  Our ‚Äúworld coordinates‚Äù are the coordinates of the chart objects on ‚Äúimaginary graph paper‚Äù, on which the whole diagram fits, which has a origin in the upper left corner and does not undergo any scaling.  World coordinates coincide with screen ones if the scale of the picture is 1: 1 and the scroll bars are in their minimum positions.  The world coordinate, in contrast to the screen, is not an integer type, but takes the value with a floating point.  This is to prevent pixelization of the image while increasing its scale.  For example, although at a scale of 1: 1, the value of world coordinate 0.3 is indistinguishable from zero screen pixels, at a scale of 100: 1 it turns into 30 screen pixels. <br><br>  It is convenient to calculate and store the model of the diagram in world coordinates, since they are not dependent on such short-term user actions as zooming and scrolling. <br><br>  To translate world coordinates into screen classes, the DiagramObject class contains important methods scaleX (...), scaleY (...) and simply scale (...).  The first two apply a scale factor to the world coordinate and take into account the shift of the horizontal and vertical scroll bars, respectively.  The latter method, scale (...), applies a scale factor, but does not take into account the shift: it is necessary to calculate not the position, but the size (for example, the width of a rectangle or the radius of a circle). <br><br><h3>  Diagram drawing from the DiagramObject point of view.  Independent, semi-independent and dependent objects </h3><br><br>  To draw the diagram, the draw (Graphics canvas, double aDX, double aDY, double scale) method of the root DiagramObject is called.  Its parameters are: <br><ul><li>  canvas - drawing context </li><li>  aDX, aDY - scroll bar positions </li><li>  scale - scale (1.0 - for scale 1: 1, more / less - for increase / decrease). </li></ul><br>  This method implements the <b>Template Method</b> design pattern (template method) and looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.canvas = canvas; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scale = scale; dX = aDX; dY = aDY; saveCanvasSetup(); internalDraw(canvas); restoreCanvasSetup(); DiagramObject curObj = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (assigned(curObj)) { curObj.draw(canvas, aDX, aDY, scale); curObj = curObj.next; }</code> </pre><br><br>  That is, the draw (...) method: <br><ul><li>  remembers the parameters in the object fields (they are then repeatedly used by different methods), </li><li>  saves with saveCanvasSetup () all settings of the rendering context (color, pens, font size, etc.), </li><li>  calls the internalDraw () method, which at the DiagramObject level does nothing, and in its successors is overridden by the object's drawing procedure, </li><li>  restores using restoreCanvasSetup () settings that could be broken after executing internalDraw, </li><li>  runs through all its sub-objects in turn and calls the draw method for each of them. </li></ul><br>  Thus, the invariant part of the algorithm is implemented in the draw (...) method, and the variable part (the actual drawing) is implemented in the successor classes, which is the essence of the Template Method pattern. <br><br>  The purpose of the saveCanvasSetup () and restoreCanvasSetup () methods is to save the state of the drawing context, so that each of the drawing objects receives it in an ‚Äúuntouched‚Äù form.  If these methods are not used, and in one of the heirs of the renderers, for example, the color of the ink is changed to red, then everything that will be drawn further will be painted in red.  The implementation of these methods depends on your development environment and the possibilities provided by the drawing engine.  In Delphi and Java Swing, for example, you need to save a lot of context parameters, and HTML Canvas2D specifically for this purpose has ready save () and restore () methods that immediately save the entire context state to a special stack. <br><br>  Here is the internalDraw method in the DiagramActor class (compare with the ‚Äúnaive example‚Äù we started with): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ACTOR_WIDTH = <span class="hljs-number"><span class="hljs-number">25.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ACTOR_HEIGHT = <span class="hljs-number"><span class="hljs-number">35.0</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internalDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Graphics canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mX = getmX(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mY = getmY(); canvas.drawOval(scaleX(mX + <span class="hljs-number"><span class="hljs-number">10</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">0</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>), scale(<span class="hljs-number"><span class="hljs-number">10</span></span>), scale(<span class="hljs-number"><span class="hljs-number">10</span></span>)); canvas.drawLine(scaleX(mX + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">10</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleX(mX + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">25</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>)); canvas.drawLine(scaleX(mX + <span class="hljs-number"><span class="hljs-number">5</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleX(mX + <span class="hljs-number"><span class="hljs-number">25</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>)); canvas.drawLine(scaleX(mX + <span class="hljs-number"><span class="hljs-number">5</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">35</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleX(mX + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">25</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>)); canvas.drawLine(scaleX(mX + <span class="hljs-number"><span class="hljs-number">25</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">35</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleX(mX + <span class="hljs-number"><span class="hljs-number">15</span></span> - ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>), scaleY(mY + <span class="hljs-number"><span class="hljs-number">25</span></span> - ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre><br><br>  At the point (mX, mY) is the middle of the object.  Since the origin of the coordinates of the ‚Äúnaive example‚Äù is in the upper left corner, they must be shifted by half the width and half of the height of the object.  The ‚Äúnaive example‚Äù did not take into account the need to scale and shift the image, but we take this into account by converting world coordinates to screen using the methods scaleX (...), scaleY (...) and scale (...). <br><br>  The DiagramActor and DiagramUseCase objects are completely ‚Äúindependent‚Äù, their positions are entirely determined by the internal state stored in the fields mX and mY.  At the same time, all sorts of connecting arrows of their own state do not have - their position on the screen is completely determined by the positions of the objects they connect, they are completely ‚Äúnot independent‚Äù, they pass along a straight line connecting the centers of the objects: <br><br><img src="https://habrastorage.org/files/ad1/4a4/3ef/ad14a43efa6a4844820455318beb7798.gif"><br><br>  And separately you should pay attention to the signatures to the objects.  In their internal state, they do not store absolute coordinates, but an offset relative to the parent drawing object, so they behave semi-independently: <br><br><img src="https://habrastorage.org/files/98d/47c/9c1/98d47c9c10164f78934ff73c4eb4239a.gif"><br><br><h3>  Detecting the object under the mouse cursor </h3><br>  Having dealt with the drawing, we proceed to the question of how the diagram ‚Äúunderstands‚Äù the object we clicked on.  It turns out that the task of defining an object under the mouse cursor is very similar to the task of drawing and is in a certain sense symmetrical to it. <br><br>  First, we note that for each given object of the diagram, it is not difficult to write a method that determines, by the coordinates of the mouse cursor, whether the cursor is over this object or not. <br><br>  For example, for the DiagramActor we are talking about getting into a rectangular area: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internalTestHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dX = x - getmX(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dY = y - getmY(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dY &gt; -ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; dY &lt; ACTOR_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; dX &gt; -ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; dX &lt; ACTOR_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br>  For DiagramUseCase we are talking about getting into an area that looks like an ellipse: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internalTestHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dX = <span class="hljs-number"><span class="hljs-number">2</span></span> * getScale() * (x - getmX()) / (width + <span class="hljs-number"><span class="hljs-number">2</span></span> * MARGIN / getScale()); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dY = <span class="hljs-number"><span class="hljs-number">2</span></span> * (y - getmY()) / HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dX * dX + dY * dY &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Now, if we want to determine the object that the cursor is currently over, we can use the sequential iteration method to call internalTestHit for each of the chart objects, and the first one that returns true will be the required object.  Only this should be done in the reverse order of rendering (moving along the blue arrows in the illustration showing the data structure)!  If the mouse cursor is in the area where several objects intersect, the search in the reverse order will ensure that the cursor hits the object drawn later than the others, that is, visually located ‚Äúabove the others‚Äù. <br><br><img src="https://habrastorage.org/files/aa4/e8e/069/aa4e8e069a8e4b12a94e69d1b2123cad.gif" width="300"><br><br>  Here is how it is implemented in another DiagramObject template method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> DiagramObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ DiagramObject result; DiagramObject curObj = last; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (assigned(curObj)) { result = curObj.testHit(x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assigned(result)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; curObj = curObj.previous; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (internalTestHit(x / scale + dX, y / scale + dY)) result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  The DiagramPanel object calls the testHit method of the root drawing object.  During its execution, a recursion occurs that performs a traversal of the drawing tree in depth in the direction opposite to the drawing direction.  The first object found is returned: this will be the ‚Äúhighest‚Äù object from the user's point of view, which is under the mouse cursor. <br><br><h3>  Defining the current context under the mouse cursor </h3><br>  The object under the mouse cursor may be only an integral part of a larger object and not have an independent value.  If we want to perform some operation on an object and clicked on its part, then the operation still needs to be performed on the parent object.  Correct context can be shown with the help of <b>delegation</b> - reception associated with the use of the Composite pattern (see the book on Design Patterns).  In our example, we use delegation to get the object's tooltip: for example, if the user hovers the mouse cursor over the Actor's signature, he receives the same hint as when the cursor is actually pointing at the Actor. <br><br>  The idea is very simple: the getHint () method of the DiagramObject class does the following: if its own implementation of the internalGetHint () method is able to return a hint string, then it is returned as well.  If it is not able, then the parent (in the drawing hierarchy) object is accessed - can it perform the getHint () method operation?  In the event that it is also ‚Äúnot taken‚Äù, the ‚Äútransfer of responsibility‚Äù will continue to the very root drawing object.  In addition to the delegation mechanism, we reapply the <b>Template Method</b> pattern: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder hintStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (internalGetHint(hintStr)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hintStr.toString(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assigned(parent)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parent.getHint(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internalGetHint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder hintStr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br><h3>  DiagramObject Helper Methods </h3><br>  The DiagramObject heirs can override the following methods ‚Äî their use in the DiagramPanel class will become clear from the following: <br><br><ul><li>  boolean isCollectable () - whether it will be possible to capture an object using a "lasso" (rectangular selection).  Used by the DiagramPanel mechanisms, which will be discussed further </li><li>  boolean isMoveable () - whether the object is moved with the help of Drag and Drop.  In our example, the diagram nodes (Actor and UseCase) are movable and captured with a lasso, and the connecting lines (Association, Generalization, Dependency) are not. </li><li>  double getMinX (), getMinY (), getMaxX (), getMaxY () - world coordinates of the leftmost, highest, rightmost and lowest point of the object.  First, you need to work correctly rectangular selection (to select an object, you need to capture it entirely), and secondly, they are used in the default implementation of the method internalDrawSelection () to draw a selection of an object at its corners. </li><li>  final int minX (), minY (), maxX (), maxY () is the same, but already translated into screen coordinates (not redefinable methods). </li></ul><br><h3>  Drawing selection </h3><br>  And finally, another important functionality implemented at the DiagramObject level that can be redefined in its successors is the selection drawing, that is, a graphic label by which the user can understand that the object is in the selected state.  By default, these are four blue square dots in the corners of the object: <br><img src="https://habrastorage.org/files/804/f2a/f1a/804f2af1a09245df94e66718b2e33f9e.png"><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internalDrawSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Graphics canvas, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dY)</span></span></span><span class="hljs-function"> </span></span>{ canvas.setColor(Color.BLUE); canvas.setXORMode(Color.WHITE); canvas.fillRect(minX() + dX - L, minY() + dY - L, L, L); canvas.fillRect(maxX() + dX, minY() + dY - L, L, L); canvas.fillRect(minX() + dX - L, maxY() + dY, L, L); canvas.fillRect(maxX() + dX, maxY() + dY, L, L); canvas.setPaintMode(); }</code> </pre><br>  Pay attention to the integer (and therefore, in screen coordinates) parameters dX, dY and to the setXORMode () call that switches the rendering context to ‚ÄúXOR mode‚Äù: in this mode, to erase the previously drawn image, just draw it again .    ,   Drag&amp;Drop   :  ,  ¬´¬ª    ,   ,        ,     dX, dY          : <br><br><img src="https://habrastorage.org/files/549/5ad/5f3/5495ad5f32294ca98e07323ac931c911.gif"><br>      ,     internalDrawSelection    DiagramObject,      (   drag&amp;drop) -  . <br><br><h2>  * * * </h2><br>  ,    DrawObject.  <a href="https://habrahabr.ru/post/303800/">  </a>     DiagramPanel,       , ,    drag&amp;drop.     , ,    <a href="https://github.com/inponomarev/graphexample">https://github.com/inponomarev/graphexample</a>       Maven. </div><p>Source: <a href="https://habr.com/ru/post/303794/">https://habr.com/ru/post/303794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303782/index.html">[Go] [JS] And again about processing marc formats</a></li>
<li><a href="../303784/index.html">Do you have any ideas? We have Tabtabus! How was the third IT festival in nature</a></li>
<li><a href="../303786/index.html">Coding standards and other IT practices</a></li>
<li><a href="../303788/index.html">Hardcore startups. Part 1: How to make your dream come true</a></li>
<li><a href="../303790/index.html">IoT: from smart bulbs to advanced production technologies</a></li>
<li><a href="../303796/index.html">Dell Storage SC9000: Intelligent Storage for Efficient Data Center</a></li>
<li><a href="../303798/index.html">Core Data + Swift for the smallest: minimum necessary (part 2)</a></li>
<li><a href="../303800/index.html">The implementation of interactive diagrams using OOP on the example of the prototype editor of UML diagrams. Part 2</a></li>
<li><a href="../303802/index.html">Big Data Brain</a></li>
<li><a href="../303804/index.html">The ‚ÄúMake with Ada‚Äù competition for developers of embedded systems has begun.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>