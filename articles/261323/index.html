<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenCL. How to start</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heavy start 
 Hello! Some time ago I started digging a thread with OpenCL under C #. But I came across difficulties due to the fact that it is not tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenCL. How to start</h1><div class="post__text post__text-html js-mediator-article"><h3>  Heavy start </h3><br>  Hello!  Some time ago I started digging a thread with OpenCL under C #.  But I came across difficulties due to the fact that it is not that under C #, but in general there is very little material on this topic.  Any input on OpenCL can be found <a href="http://habrahabr.ru/post/72650/">here</a> .  Just a simple, but working start, OpenCL is described <a href="http://habrahabr.ru/post/124873/">here</a> .  I don‚Äôt want to offend the authors one iota, but all the articles that I found in Russian (including Habr√©s) suffer from the same problem - there are <b>very few examples</b> .  There is <a href="https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/">documentation,</a> there is a lot of it and, as is customary, for good documentation it is difficult to read.  In my article (and if everything goes well, then in a series of articles), I will try to describe this area in more detail, from the point of view of the person who started to dig it from scratch.  I think this approach will be useful to those who want to quickly start in high-performance computing. <br><a name="habracut"></a><br>  Initially, I wanted to write an OpenCL miniscutorial article that contained information about what it was, how it was arranged, how to write code and some recommendations based on my experience.  But in the process I realized that even if I was brief, I would be confined to the limitations of the length of the article.  Because, IMHO, the article should be of such volume that it was not difficult to assimilate its volume.  According to this, in this article (which will be the first) I plan to describe, then how to start in OpenCL, check that locally everything is correctly configured, and write the simplest program.  Questions about the memory device, architecture and other things will be described in the following articles. <br><br>  Friends, I would immediately like to say that my experience in OpenCL so far, unfortunately, is far from the level guru / iodine, but I will try to answer the questions with all my might.  And if I don‚Äôt know something, I‚Äôll share the resources and the vision of how it really should work. <br><br><h3>  What.  Where.  How. </h3><br>  OpenCL is a technology associated with parallel computing on various types of graphics and CPUs.  The topic of parallel computing on GPU has recently been widely promoted along with CUDA technology.  This promotion was mainly provided by the efforts of Nvidia.  The differences between OpenGL and CUDA <a href="http://habrahabr.ru/post/72247/">have already been widely discussed</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      OpenCL allows you to work with both the CPU and the GPU, but I think it will be more interesting for us to focus on working with the GPU.  To use this technology, you need a little bit modern graphics card.  The main thing is to check that the device is functioning normally.  Just in case, I remind you that this can be done in the device manager. <br><br><img src="https://habrastorage.org/files/231/b54/fab/231b54fab6f04c9583f6ac0f92da8119.png"><br><br>  If in this window you see any file or vornings, then you will have a direct route to the site of the manufacturer of your video card.  Fresh drivers should solve the problem with the functioning of iron and as a result give access to the OpenCL facilities. <br><br>  I originally planned to use OpenCL over C #.  But I came across the problem that all existing frameworks like Cloo or OpenCLNet are self-written and Khronos has nothing to do with them and therefore does not guarantee their stable operation.  Well, we all remember the main problem - <b>very few examples</b> .  Based on this, at first I would like to present examples written in C ++, and only then, having received confirmation that OpenCL behaves as we expect, to screw the proxy in the form of a C # framework. <br>  So, to use OpenCL through C ++ you need to find its API.  To do this, open the variable environment, and there are looking for a variable with a scary name, hinting with its name to the manufacturer of your video card.  I have this variable called <u><i>"AMDAPPSDKROOT"</i></u> .  After that, you can see what lies on the specified path.  There look for <i><u>include \ CL</u></i> daddy. <br><br><img src="https://habrastorage.org/files/614/ab3/9e8/614ab39e8e79414090aeebd1ab2b34fc.png"><br><br>  By the way, usually in the daddy include, next to the CL folder is the GL folder, which provides access to the famous graphic library. <br><br>  Now we create a project in Visual Studio, connect the include folder in my project properties (in my case $ (AMDAPPSDKROOT) \ include \) and go to battle! <br><br><h3>  Infrastructure </h3><br>  We have to remember that we will work with OpenCL <b>not through the API</b> , <b>but using the API</b> .  It seems that these two phrases are almost identical, but it is not.  For example, remember OpenGL.  How does the work work there (the simplified version) - first we set up some common parameters, and then directly from the code we call methods like ‚Äúdraw a sphere‚Äù, ‚Äúchange the parameters of the light source‚Äù, etc. <br>  So in the OpenCL script is different: <br><ol><li>  Using the API, we get access to devices that support OpenCL.  This part of the application is usually called the <b>host</b> ; </li><li>  We write the code that will be executed on the device.  This code is called <b>kernel</b> .  This host code knows nothing at all.  Any host can pull it. </li><li>  Using the API, we load the kernel code and run its execution on the selected device. </li></ol><br>  As you can see, our application will have an integrated infrastructure.  Let's tackle it! <br><br>  Since in the previous step we prudently connected the include <u><i>folder</i></u> , now you can simply add a link to the header file <u><i>cl.h</i></u> , which will give access to the API.  When adding cl.h, it‚Äôs worth adding a platform selection check: <br><br><pre><code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> __APPLE__ <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">OpenCL</span></span>/opencl.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#else</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">CL</span></span>/cl.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre> <br>  Now it is necessary to choose a device on which our code will work and create a context in which our variables will live.  How to do this is shown below: <br><br><pre> <code class="hljs vhdl"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ret = clGetPlatformIDs(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;platform_id, &amp;ret_num_platforms); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;device_id, &amp;ret_num_devices); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span> = clCreateContext(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;device_id, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;ret); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> command_queue = clCreateCommandQueue(<span class="hljs-keyword"><span class="hljs-keyword">context</span></span>, device_id, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;ret);</code> </pre><br>  Pay attention to the variable <b>ret</b> .  This is a variable that contains a numeric value that a function returns.  If <u>ret == 0</u> , then the function is executed correctly, if not, then an error has occurred. <br>  The <b>CL_DEVICE_TYPE_DEFAULT</b> constant also deserves attention, it asks for a device that is used for computations on OpenCL by default.  Instead of this constant, others can be used.  For example: <br><ul><li>  <b>CL_DEVICE_TYPE_CPU</b> - will query the existing CPU. </li><li>  <b>CL_DEVICE_TYPE_GPU</b> - will query the existing GPU. </li></ul><br><h3>  Kernel </h3><br>  Fine.  Set up the infrastructure.  Now we take on the kernel.  Kernel is simply a declaration function that starts with the <u>__kernel keyword</u> .  The OpenCL programming language syntax is based on the <b>C99 standard</b> , but it has a number of specific and very important changes.  This will be (I really hope) a separate article.  While basic information: <br><ol><li>  The code that will be twitched from the host part, for execution, must begin with the keyword __ kernel; </li><li>  A function with the keyword __kernel always returns <b>void</b> ; </li><li>  There are qualifiers of memory types: <b>__global</b> , <b>__local</b> , <b>__constant</b> , <b>__private</b> , which will determine in which memory the variables will be stored.  If there is no qualifier before the variable, then it is __private; </li><li>  "Communication" between the host and the kernel will be through the parameters of the kernel.  In order for kernel to send something to the host via a parameter, the parameter must be with the __global qualifier (for now, we will only use __global); </li><li>  The kernel code is usually stored in a file with the <b>cl</b> extension.  But in fact, such code can be generated <i>on the fly</i> .  This allows you to bypass some limitations.  But more about that another time :) </li></ol><br>  The simplest kernel example is shown below: <br><br><pre> <code class="hljs cs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   id. int gid = get_global_id(0); message[gid] += gid; }</span></span></code> </pre><br><br>  What does this code do?  The first is to get the global id <b>work-item</b> which is currently running.  The work item is what our kernel does.  Since we deal with parallel computations, for each work-item a separate kernel is created which knows nothing about others.  And no one can guarantee in what order all the work-item will work.  But more about this will be in a separate article (I have already repeated this).  In our example, this is essentially the index of the element in the array, because we will process each element of the array in a separate work-item.  I think the second line of the line in the kernel is unnecessary to comment :) <br><br><h3>  We form kernel </h3><br>  The next step is to compile, what lies in the * .cl file.  This is done as follows: <br><br><pre> <code class="hljs cpp">cl_program program = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; cl_kernel kernel = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; FILE *fp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fileName[] = <span class="hljs-string"><span class="hljs-string">"../forTest.cl"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> source_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *source_str; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fp = fopen(fileName, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fp) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to load kernel.\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } source_str = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(MAX_SOURCE_SIZE); source_size = fread(source_str, <span class="hljs-number"><span class="hljs-number">1</span></span>, MAX_SOURCE_SIZE, fp); fclose(fp); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%f"</span></span>, a); } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> program = clCreateProgramWithSource(context, <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)&amp;source_str, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)&amp;source_size, &amp;ret); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = clBuildProgram(program, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;device_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> kernel = clCreateKernel(program, <span class="hljs-string"><span class="hljs-string">"test"</span></span>, &amp;ret);</code> </pre><br>  The types <b>cl_program</b> and <b>cl_kernel are</b> defined in cl.h.  The script itself is quite simple - we load the file, create the binary (clCreateProgramWithSource) and compile it.  If the ret variable still contains 0, then you did everything right.  And it remains only to create the kernel itself.  It is important that the name passed to the clCreateKernel command matches the kernel name in the cl file.  In our case, this is <u>"test"</u> . <br><br><h3>  Options </h3><br>  I have already mentioned that the ‚Äúcommunication‚Äù of the kernel with the host occurs at the expense of writing / reading in the parameters that are transferred to the kernel.  In our case, this is the <b>message</b> parameter.  Parameters that allow the host to communicate with the kernel like this are called <b>buffers (buffer)</b> .  Let's create such a buffer on the host side and pass it to kernel via the API: <br><br><pre> <code class="hljs objectivec">cl_mem memobj = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> memLenth = <span class="hljs-number"><span class="hljs-number">10</span></span>; cl_int* mem = (cl_int *)malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cl_int) * memLenth); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> memobj = clCreateBuffer(context, <span class="hljs-built_in"><span class="hljs-built_in">CL_MEM_READ_WRITE</span></span>, memLenth * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cl_int), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;ret); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ret = clEnqueueWriteBuffer(command_queue, memobj, <span class="hljs-built_in"><span class="hljs-built_in">CL_TRUE</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, memLenth * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cl_int), mem, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = clSetKernelArg(kernel, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cl_mem), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;memobj);</code> </pre><br><br>  It is important to note the constant <b>CL_MEM_READ_WRITE</b> , it means that we have rights for the buffer to read and write on the kernel side.  Constants of the <b>CL_MEM_WRITE_ONLY</b> , <b>CL_MEM_READ_ONLY</b> type can also be used. Also in the clSetKernelArg method, the second argument is important, it contains the index of the parameter.  In this case, 0, since the message parameter comes first in the kernel signature.  If he were second, we would write: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = clSetKernelArg(kernel, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cl_mem), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;memobj);</code> </pre><br><br>  <b>clEnqueueWriteBuffer</b> writes data from the mem array to the memobj buffer. <br>  Well, in general, everything is ready.  It remains only to execute the kernel. <br><br><h3>  Execute the kernel </h3><br>  Let's drive, send the code for execution: <br><br><pre> <code class="hljs objectivec">size_t global_work_size[<span class="hljs-number"><span class="hljs-number">1</span></span>] = { <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = clEnqueueNDRangeKernel(command_queue, kernel, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, global_work_size, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ret = clEnqueueReadBuffer(command_queue, memobj, <span class="hljs-built_in"><span class="hljs-built_in">CL_TRUE</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, memLenth * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>), mem, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br><br>  <b>global_work_size</b> contains the number of work-items to be created.  I have already said that we will have our own work-item for processing each element of the array.  We have 10 elements in the array, therefore the work-item contains 10. <b>clEnqueueNDRangeKernel</b> does not have to generate special questions - it just starts the specified kernel a specified number of times.  <b>clEnqueueReadBuffer</b> reads data from a buffer named memobj and puts the data into a mem array.  The data in mem is our result! <br><br><h3>  Results and conclusions </h3><br>  Friends, this is how I represent the start in OpenCL for a beginner.  I hope for your constructive comments in the comments so that you can make updates in the future.  I tried to be brief, but still the volume came out not small.  So I can say that I can still find material for 2-3 articles. <br><br>  Thank you, everyone who read to the end! <br></div><p>Source: <a href="https://habr.com/ru/post/261323/">https://habr.com/ru/post/261323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261305/index.html">The digest of interesting materials for the mobile # 109 developer (June 22-28)</a></li>
<li><a href="../261307/index.html">Workers and shared workers</a></li>
<li><a href="../261309/index.html">Retina authentication methods</a></li>
<li><a href="../261311/index.html">Webinar "New Features of WebLogic 12c Application Server"</a></li>
<li><a href="../261313/index.html">2 in 1: the premiere of the "official" laptop at the opening of the official youtube channel</a></li>
<li><a href="../261327/index.html">PHP Digest number 65 - interesting news, materials and tools (June 14 - 28, 2015)</a></li>
<li><a href="../261331/index.html">Black datamining archeology: what could be more effective than a dictionary attack?</a></li>
<li><a href="../261335/index.html">The digest of interesting materials from the world of Drupal # 10</a></li>
<li><a href="../261337/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ166 (June 22 - 28, 2015)</a></li>
<li><a href="../261339/index.html">It's hard to go simplicity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>