<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ROS: Map of the depths on the Raspberry Pi "little blood"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you use ROS when creating robots, you probably know that it has support for working with stereo cameras. You can build, for example, a map of the d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ROS: Map of the depths on the Raspberry Pi "little blood"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/jl/ks/vn/jlksvndgnvhxzgvr_jmo19ni580.jpeg" alt="image"><br><br>  If you use ROS when creating robots, you probably know that it has support for working with stereo cameras.  You can build, for example, a map of the depths of the visible part of space or a cloud of points.  And I wondered how easy it would be to use a Raspberry-based StereoPi stereo camera in ROS.  Earlier, I was already convinced that the depth map is perfectly built by the forces of OpenCV, but I never dealt with ROS.  And I decided to try.  I want to talk about my adventures in finding a solution. <br><a name="habracut"></a><br><h3>  1. Does ROS on a Raspberry Pi ever happen? </h3><br>  At first I decided to find out if it was possible to build a ROS for the Raspberry Pi.  The first thing Google suggested to me is a list of instructions for installing different versions of ROS on the Raspberry Pi, namely this page of the <a href="http://wiki.ros.org/ROSberryPi/Setting%2520up%2520ROS%2520on%2520RaspberryPi">ROS wiki</a> <br><br>  Great, there is already something to push off!  I remembered well how much the OpenCV build on Raspberry took (about eight hours), so I decided to search for ready-made images of MicroSD cards to save time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  2. Are there ready images of microSD cards with ROS for Raspberry? </h3><br>  It turned out that this issue has already been resolved by several development teams.  If you do not take one-time build enthusiasts, then a couple of images were highlighted, which are constantly updated with the release of new versions of the OS and ROS. <br><br>  The first option is ROS installed on the native Raspbian OS from the ROSbots team, here is a page with an updated link to the image: <a href="https://medium.com/%40rosbots/ready-to-use-image-raspbian-stretch-ros-opencv-324d6f8dcd96">ready-to-use-image-raspbian-stretch-ros-opencv</a> <br><br>  The second is <a href="https://downloads.ubiquityrobotics.com/">images from Ubiquiti Robotics on ubunt</a> . <br><br>  Well, the second question was also quickly closed.  It's time to dive deep. <br><br><h3>  3. How does ROS work with the Raspberry Pi camera? </h3><br>  And which stereo cameras are generally supported in ROS?  I looked at the page with stereo cameras, for which the presence of ready-made drivers for ROS is stated, this one: <br><br>  <a href="http://wiki.ros.org/Sensors">wiki.ros.org/Sensors</a> <br><br>  There were two sections: <br>  <i><b>2.3 3D Sensors (range finders &amp; RGB-D cameras)</b></i> <i><br></i>  <i><b>2.5 Cameras</b></i> <br>  It turned out that the first section lists not only stereo cameras, but also TOF sensors, and scanning lidars - in general, everything that can immediately provide information in 3D.  And in the second there are stereo cameras.  Attempting to look at the drivers for several stereo cameras did not add to my joy, as I hinted at a serious immersion in the code. <br><br>  Well, step back.  How does the work with one Raspberry Pi camera in ROS go? <br><br>  Three pleasant surprises awaited me here: <br><br><ul><li>  it turns out that for ROS there is a special <b><i>raspicam_node</i></b> node just for working with the Raspberry Pi camera </li><li>  The soda nodes lie on github, the code is actively maintained and well documented: <a href="https://github.com/UbiquityRobotics/raspicam_node">github.com/UbiquityRobotics/raspicam_node</a> </li><li>  Rohan Agrawal node author ( <a href="https://github.com/rohbotics">@Rohbotics</a> ) works for a company that actively supports one of the ready-made images for Raspberry Pi </li></ul><br>  I looked at the raspicam_node githabby repository and looked into the issues.  There I found an open issue with the capacious name ‚Äústereo mode‚Äù almost seven months old, without answers and comments.  Actually, in it further and all events developed. <br><br><h3>  4. Hardcore or not? </h3><br>  In order not to ask children's questions to the authors, I decided to look at the source code and evaluate what the addition of stereo mode threatens.  I was more interested in the sishnaya part here: <a href="https://github.com/UbiquityRobotics/raspicam_node/tree/kinetic/src">github.com/UbiquityRobotics/raspicam_node/tree/kinetic/src</a> <br>  Well, the guys wrote a driver plunging to the level of MMAL.  I also remembered that the source codes for the work of raspberry in stereo were also open (evolution can be followed <a href="https://www.raspberrypi.org/forums/viewtopic.php%3Ff%3D43%26t%3D85012%26sid%3D3ccbc2eceb9cfc2d57ff1fa5be46fb02">here on the raspberry forum</a> ), and the task of writing a full-fledged stereo driver is solvable, but ambitious.  Looking at the description of the drivers of other cameras, I realized that it was necessary to publish not only the left and right pictures, but also to output the parameters of both cameras, apply my own calibration results to each one and do many other things.  It pulled on experiments a month or two long.  Therefore, I decided to parallelize the approach, namely, to write the author a question about stereo support, and to look for a simpler, but working solution myself. <br><br><h3>  5. Dialogues with the author </h3><br>  In the branch about stereo mode on github I asked the author a question, mentioning that the stereo has been supported by raspberries since 2014, and suggested, if necessary, send him a debugging board for experiments.  Let me remind you that I still doubted that in this distribution kit the stereo will work as in the native Raspbian. <br><br>  Rohan answered surprisingly quickly, saying that their distrib uses the crimson kernel and everything should work.  And asked to check it out on one of their assemblies. <br><br>  Raspberry core!  Hooray!  Theoretically, the stereo image should be captured without dancing with a tambourine! <br><br>  I downloaded and deployed their latest image <a href="https://downloads.ubiquityrobotics.com/pi.html">from the link from Rohan</a> and ran a simple python script to capture the stereo pair.  It worked! <br><br><img src="https://habrastorage.org/webt/vh/6i/fg/vh6ifg37hbuzr0khcyxnuxpq5fa.jpeg" alt="image"><br><br>  After that, Rohan wrote that he would look at the driver code for stereo, and wrote a couple of questions.  For example, in our stereo mode we get one glued picture, but we would need to cut it into two - left and right.  And the second question about the calibration parameters of each camera is how to deal with it. <br><br>  I said that as a first step, you can take pictures from cameras independently.  Yes, they will not be synchronized in the capture time and settings (such as brightness-contrast-white balance), but as a first step it may well go. <br><br>  Rohan promptly <a href="https://github.com/UbiquityRobotics/raspicam_node/pull/55">rolled out a patch</a> , allowing you to directly indicate from ROS which camera to take pictures from.  I checked it - the choice of the camera works, already an excellent result. <br><br><h3>  6. Unexpected help </h3><br>  And here in the thread appears a comment from the user Wezzoid.  He told me that he was doing a project based on a stereo camera on Pi Compute 3 using crimson devborda.  His four-legged walking robot tracked the position of the object in space, changed the position of the cameras and kept the specified distance to it (the project is laid out on hackaday.io <a href="https://hackaday.io/project/159212-augmented-mekamon-robot">here</a> ). <br><br><img src="https://habrastorage.org/webt/og/sp/iy/ogspiywmjvs67yhodxpbes0pd-8.jpeg" alt="image"><br><br>  And he shared the code in which he captured the picture, cut it with python tools in half and published it as the nodes of the left and right cameras. <br>  Python in these matters is not a very quick comrade, so he used a low resolution of 320x240 and a good life hack.  If we capture the side-by-sibe stereo image (one camera on the left on the stereo image, the second on the right), then the python should cut each of the 240 lines in half.  But if you make a top-bottom picture (the left camera is the upper half of the frame, the right is the bottom), then the python cuts the array in half in one operation.  What was successfully done by the user Wezzoid. <br>  Plus, he put his python code on Pastebin, which did this operation.  Here he is: <br><br><div class="spoiler">  <b class="spoiler_title">Wezzoid code for publishing nodes of two cameras from a stereo pair</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # picamera stereo ROS node using dual CSI Pi CS3 board # Wes Freeman 2018 # modified from code by Adrian Rosebrock, pyimagesearch.com # and jensenb, https://gist.github.com/jensenb/7303362 from picamera.array import PiRGBArray from picamera import PiCamera import time import rospy from sensor_msgs.msg import CameraInfo, Image import yaml import io import signal # for ctrl-C handling import sys def parse_calibration_yaml(calib_file): with file(calib_file, 'r') as f: params = yaml.load(f) cam_info = CameraInfo() cam_info.height = params['image_height'] cam_info.width = params['image_width'] cam_info.distortion_model = params['distortion_model'] cam_info.K = params['camera_matrix']['data'] cam_info.D = params['distortion_coefficients']['data'] cam_info.R = params['rectification_matrix']['data'] cam_info.P = params['projection_matrix']['data'] return cam_info # cam resolution res_x = 320 #320 # per camera res_y = 240 #240 target_FPS = 15 # initialize the camera print "Init camera..." camera = PiCamera(stereo_mode = 'top-bottom',stereo_decimate=False) camera.resolution = (res_x, res_y*2) # top-bottom stereo camera.framerate = target_FPS # using several camera options can cause instability, hangs after a while camera.exposure_mode = 'antishake' #camera.video_stabilization = True # fussy about res? stream = io.BytesIO() # ---------------------------------------------------------- #setup the publishers print "init publishers" # queue_size should be roughly equal to FPS or that causes lag? left_img_pub = rospy.Publisher('left/image_raw', Image, queue_size=1) right_img_pub = rospy.Publisher('right/image_raw', Image, queue_size=1) left_cam_pub = rospy.Publisher('left/camera_info', CameraInfo, queue_size=1) right_cam_pub = rospy.Publisher('right/camera_info', CameraInfo, queue_size=1) rospy.init_node('stereo_pub') # init messages left_img_msg = Image() left_img_msg.height = res_y left_img_msg.width = res_x left_img_msg.step = res_x*3 # bytes per row: pixels * channels * bytes per channel (1 normally) left_img_msg.encoding = 'rgb8' left_img_msg.header.frame_id = 'stereo_camera' # TF frame right_img_msg = Image() right_img_msg.height = res_y right_img_msg.width = res_x right_img_msg.step = res_x*3 right_img_msg.encoding = 'rgb8' right_img_msg.header.frame_id = 'stereo_camera' imageBytes = res_x*res_y*3 # parse the left and right camera calibration yaml files left_cam_info = parse_calibration_yaml('/home/pi/catkin_ws/src/mmstereocam/camera_info/left.yaml') right_cam_info = parse_calibration_yaml('/home/pi/catkin_ws/src/mmstereocam/camera_info/right.yaml') # --------------------------------------------------------------- # this is supposed to shut down gracefully on CTRL-C but doesn't quite work: def signal_handler(signal, frame): print 'CTRL-C caught' print 'closing camera' camera.close() time.sleep(1) print 'camera closed' sys.exit(0) signal.signal(signal.SIGINT, signal_handler) #----------------------------------------------------------- print "Setup done, entering main loop" framecount=0 frametimer=time.time() toggle = True # capture frames from the camera for frame in camera.capture_continuous(stream, format="rgb", use_video_port=True): framecount +=1 stamp = rospy.Time.now() left_img_msg.header.stamp = stamp right_img_msg.header.stamp = stamp left_cam_info.header.stamp = stamp right_cam_info.header.stamp = stamp left_cam_pub.publish(left_cam_info) right_cam_pub.publish(right_cam_info) frameBytes = stream.getvalue() left_img_msg.data = frameBytes[:imageBytes] right_img_msg.data = frameBytes[imageBytes:] #publish the image pair left_img_pub.publish(left_img_msg) right_img_pub.publish(right_img_msg) # console info if time.time() &gt; frametimer +1.0: if toggle: indicator = ' o' # just so it's obviously alive if values aren't changing else: indicator = ' -' toggle = not toggle print 'approx publish rate:', framecount, 'target FPS:', target_FPS, indicator frametimer=time.time() framecount=0 # clear the stream ready for next frame stream.truncate(0) stream.seek(0)</span></span></code> </pre> <br></div></div><br><h3>  7. Start the publication of the nodes of the left and right cameras </h3><br>  At the first start, the code cursed that there was no access to YML files with camera parameters.  I used the V2 crimson cameras and remembered that on the githabe bundled <i><b>raspicam_node</b></i> had ready files with calibration results for different camera models: <a href="https://github.com/UbiquityRobotics/raspicam_node/tree/kinetic/camera_info">github.com/UbiquityRobotics/raspicam_node/tree/kinetic/camera_info</a> <br>  I took one of them, made two copies and saved them with the names left.yml and right.yml, writing in them the resolution of the cameras from the author's script.  Here's what happened for the left camera: <br><br><div class="spoiler">  <b class="spoiler_title">left.yml</b> <div class="spoiler_text"><pre> <code class="xml hljs">image_width: 320 image_height: 240 camera_name: left camera_matrix: rows: 3 cols: 3 data: [1276.704618338571, 0, 634.8876509199106, 0, 1274.342831275509, 379.8318028940378, 0, 0, 1] distortion_model: plumb_bob distortion_coefficients: rows: 1 cols: 5 data: [0.1465167016954302, -0.2847343180128725, 0.00134017721235817, -0.004309553450829512, 0] rectification_matrix: rows: 3 cols: 3 data: [1, 0, 0, 0, 1, 0, 0, 0, 1] projection_matrix: rows: 3 cols: 4 data: [1300.127197265625, 0, 630.215390285608, 0, 0, 1300.670166015625, 380.1702884455881, 0, 0, 0, 1, 0]</code> </pre> <br></div></div><br>  For the right camera name is replaced by right, and the file itself is named right.yml.  The rest of the file is identical. <br><br>  Since I didn‚Äôt plan to do a complex project, I didn‚Äôt repeat the author‚Äôs long paths with nested subfolders and just put the files in the root of the home folder next to the python script.  The code started successfully, displaying status messages in the console. <br><br><img src="https://habrastorage.org/webt/sz/oi/my/szoimymcugjmfggyfdez98l3kku.jpeg" alt="image"><br><br>  It only remained to see what was eventually published by our left and right cameras.  For this, I launched rqt_image_view.  The / left / image_raw and / right / image_raw items appeared in the drop-down menu. When selecting them, I saw images from the left and right cameras. <br><br><img src="https://habrastorage.org/webt/og/1i/du/og1iduqsqdfjq_j2ijp-fkzfxhm.jpeg" alt="image"><br><br>  Well, this thing has earned!  Now the fun part. <br><br><h3>  8. Watch the depth map. </h3><br>  To view the depth map, I did not invent my approach and went through the classic <a href="http://wiki.ros.org/stereo_image_proc/Tutorials/ChoosingGoodStereoParameters">manual from ROS to set up stereo parameters</a> . <br>  From there I found out that it would be good to publish both nodes in a specific namespace, and not at the root as Wezzoid did.  As a result, the old lines of the publication of the form <br><br><pre> <code class="python hljs">left_img_pub = rospy.Publisher(<span class="hljs-string"><span class="hljs-string">'left/image_raw'</span></span>, Image, queue_size=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  began to look like this: <br><br><pre> <code class="python hljs">left_img_pub = rospy.Publisher(<span class="hljs-string"><span class="hljs-string">'stereo/right/image_raw'</span></span>, Image, queue_size=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  After that, we start the stereo stereo processing node for stereo_image_proc: <br><br><pre> <code class="bash hljs">ROS_NAMESPACE=stereo rosrun stereo_image_proc stereo_ige_proc</code> </pre> <br>  Well, we also want to look at the result, so we start the viewer: <br><br><pre> <code class="bash hljs">rosrun image_view stereo_view stereo:=/stereo image:=image_rect_color</code> </pre> <br>  And to configure the parameters of the depth map, run the configuration utility: <br><br><pre> <code class="bash hljs">rosrun rqt_reconfigure rqt_reconfigure</code> </pre> <br>  As a result, we see the picture given at the very beginning of the article.  Here is a slightly larger fragment: <br><br><img src="https://habrastorage.org/webt/qc/oy/s8/qcoys8o4-yrwfxgc7kynjrxhd9m.jpeg" alt="image"><br><br>  I posted all the files on the github: <a href="https://github.com/realizator/StereoPi-ROS-depth-map-test">github.com/realizator/StereoPi-ROS-depth-map-test</a> <br><br><h3>  9. Future plans </h3><br>  After my publication of the result in the discussion on the githaba, Rohan wrote ‚ÄúCool!  Hike I need to pick up my StereoPi.  We wrote off with him by mail, I sent him a fee.  I hope that with a working iron in his hands it will be easier for him to finish and debug a full-fledged stereo driver for ROS and Raspberry. <br><br><h3>  10. Results </h3><br>  The depth map from the stereo image on raspberry in ROS can be obtained, and in several ways.  The path chosen for quick verification is not the most optimal in terms of performance, but can be used for application purposes.  The beauty of its simplicity and the ability to immediately begin experiments. <br><br>  Well, from the funny: after receiving the results, I noticed that Wezzoid, who proposed his solution, was the author of the question about the publication of two stereo images.  He asked, he decided. </div><p>Source: <a href="https://habr.com/ru/post/431092/">https://habr.com/ru/post/431092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431082/index.html">Kotlin: Looking for Head of Marketing</a></li>
<li><a href="../431084/index.html">In any incomprehensible situation - write scripts</a></li>
<li><a href="../431086/index.html">Everything you wanted to know about PVS-Studio and did not hesitate to ask</a></li>
<li><a href="../431088/index.html">File management done wrong - Part 1: Hailing from the 90s</a></li>
<li><a href="../431090/index.html">One VC bot, one C # and an orange</a></li>
<li><a href="../431094/index.html">Solitaire sorting</a></li>
<li><a href="../431096/index.html">How to build a chat bot product</a></li>
<li><a href="../431098/index.html">Even a fire is not an obstacle, or Zimbra speed recovery after a disaster</a></li>
<li><a href="../431102/index.html">How the physical address is displayed in rows and banks DRAM</a></li>
<li><a href="../431104/index.html">How we at Neoflex develop the expertise of DevOps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>