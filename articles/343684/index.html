<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regression tests for memory leaks, or how to write a memory profiler for .NET applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a rule, memory profilers begin to use when the application is already guaranteed to ‚Äúflow,‚Äù users actively send emails that are dazzling with task ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regression tests for memory leaks, or how to write a memory profiler for .NET applications</h1><div class="post__text post__text-html js-mediator-article"><p>  As a rule, memory profilers begin to use when the application is already guaranteed to ‚Äúflow,‚Äù users actively send emails that are dazzling with task manager screenshots and need to spend a lot of time profiling and searching for the cause.  Finally, when developers find and fix a leak, release a new beautiful version of the application, devoid of the same drawbacks, there is a risk that after some time the leak will return, because the application is growing, and developers may also make mistakes. </p><br><p>  Automated regression error testing has long been the mainstream of high-quality software development.  Such tests help to prevent errors from reaching the user, as well as to quickly figure out what change in the code led to an error, thereby minimizing the time it was fixed. </p><br><p>  Why don't we take the same approach to memory leaks? </p><br><p><img src="https://habrastorage.org/webt/m6/xh/n0/m6xhn0vhcd533ssonhtar05d_gu.png"></p><a name="habracut"></a><br><p>  We asked this question, once again receiving an OutOfMemoryException during the passage of regression autotests on x86 agents. </p><br><p>  A few words about our product: we are developing <a href="http://pilotems.com/ru/">Pilot-ICE</a> - an engineering data management system.  The application is written in .NET / WPF, and for regression testing we use the <a href="https://habrahabr.ru/company/2gis/blog/220337/">Winium.Cruciatus</a> framework, based on UIAutomation.  Tests "click" through the UI all the available functionality of the application, checking the logic of work. </p><br><p>  The idea of ‚Äã‚Äãimplementing tests for memory leaks is as follows: at certain points in the passing of tests, connect to an application and check the number of instances of objects of certain types in memory. </p><br><h2 id="analiz-suschestvuyuschih-resheniy">  Analysis of existing solutions </h2><br><p>  We looked at most of the popular .NET memory profilers, and they all save snapshots of memory in a proprietary format that can be opened for analysis only in the appropriate browser.  No opportunity was found for automated snapshots analysis in any of them. </p><br><p>  The dotMemory Unit stands apart - a free unit testing framework that allows you to analyze memory leaks in tests.  Unfortunately, in it, memory analysis is limited to the process that runs the tests.  Connect to an external process using the dotMemory Unit at the moment is not possible. </p><br><h2 id="pishem-svoy-profilirovschik">  We write your profiler </h2><br><p>  So, not finding a suitable ready-made solution, it was decided to write my own memory profiler.  What he should be able to do: </p><br><ol><li>  Call garbage collection in the application </li><li>  Get the number of objects of a given type in the application's memory </li><li>  Analyze what keeps these objects from being collected by the GC (Garbage Collector). </li></ol><br><p>  At the same time, I wanted to make it so that I did not have to modify the application under test. </p><br><h3 id="sborka-musora">  Garbage collection </h3><br><p>  As you know, the GC.Collect () method, which starts garbage collection in all generations, can be used to call garbage collection in a .NET application.  This method is not recommended for use in production code, and memory profiling is almost the only adequate scenario for its use.  Garbage collection prior to profiling is needed to eliminate the false positives of the profiler on unreachable objects, which GC just could not reach. <br>  The difficulty is that garbage collection must be started in an external process, and there are several possible solutions for this: </p><br><ol><li>  Connect to the debugger API process and trigger garbage collection </li><li>  Get involved in the process and start garbage collection from there. </li><li>  Via ETW (Event Tracing for Windows) with the GCHeapCollect command <br>  We chose the second path as the easiest to implement.  Managed Injector was borrowed from the <a href="https://github.com/cplotts/snoopwpf">Snoop for WPF</a> project.  It allows specifying the path with the assembly, class and method in it to load this assembly into the external application domain and run the specified method.  In our case, after the introduction of the process, the named pipe server is started, which, upon a command from the client (profiler), starts the garbage collection process. </li></ol><br><h3 id="analiz-pamyati-prilozheniya">  Application memory analysis </h3><br><p>  To analyze the application's memory, we used the <a href="https://github.com/Microsoft/clrmd">CLR MD</a> library, which provides an API similar to the SOS debug extension in WinDbg.  With it, you can connect to the process, bypass all the objects in the heaps, get a list of root links (GC root) and objects dependent on them.  By and large, everything that we need is already implemented, we just need to take advantage of it all. </p><br><p>  This is how you can get the number of objects of a certain type in memory using CLR MD: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataTarget = DataTarget.AttachToProcess(pid, msecTimeout: <span class="hljs-number"><span class="hljs-number">5000</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runtime = dataTarget.ClrVersions.First().CreateRuntime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtime.Heap.EnumerateObjects().Count(o =&gt; o.Type.Name == type); } }</code> </pre> <br><p>  The most difficult, but quite solvable moment is getting information about what keeps the object from being collected by the garbage collector.  To do this, it is necessary to bypass all dependency trees of root links, remembering along the detour path. </p><br><h2 id="continuous-integration">  Continuous integration </h2><br><p>  Next, we embedded all the developments in the regression test code.  Information about the names of periodically flowing types and the maximum number of instances of this type that can be in memory was added to the tests.  The verification algorithm is as follows: after the end of the test, garbage collection is first started, then the analysis of the number of objects of the types of interest is launched, if their number is greater than the reference, the problem is reported and the build is marked as ‚Äúfallen‚Äù.  In addition, diagnostic information is collected that keeps these objects from garbage collection and is added to build artifacts.  Here is how it looks for TeamCity: </p><br><p><img src="https://habrastorage.org/webt/vq/lr/5_/vqlr5_cxd9z84owhqnqtjhkwreq.png"></p><br><h2 id="sharing-is-caring-vstrechayte-asconnetmemoryprofiler">  Sharing is caring.  Meet Ascon.NetMemoryProfiler </h2><br><p>  The resulting decision came out pretty general, and we decided to share it with the community.  The project code can be found in the <a href="https://github.com/hindikaynen/NetMemoryProfiler">repository on github</a> , besides, the solution in a ready-for-use form is available in the form of a <a href="https://www.nuget.org/packages/Ascon.NetMemoryProfiler">nuget package</a> called Ascon.NetMemoryProfiler.  Distributed under the Apache 2.0 license. <br>  Below is an example of using the API.  Minimalistic, but describing almost all the functionality provided: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    MyApp //  ,       using (var session = Profiler.AttachToProcess("MyApp")) { //       "MyApp.Foo" var objects = session.GetAliveObjects(x =&gt; x.Type == "MyApp.Foo"); //  ,       var retentions = session.FindRetentions(objects); }</span></span></code> </pre> <br><p>  Consider the example of a simple application, how to write a test for memory leaks.  Let's make a test project, add the Ascon.NetMemoryProfiler package to it. </p><br><p>  <strong>Install-Package Ascon.NetMemoryProfiler</strong> </p><br><p>  We write the basis for the test: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MemoryLeakTests</span></span> { [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemoryLeakTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> session = Profiler.AttachToProcess(<span class="hljs-string"><span class="hljs-string">"LeakingApp"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objects = session.GetAliveObjects(x =&gt; x.Type.EndsWith(<span class="hljs-string"><span class="hljs-string">"LeakingObjectTypeName"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objects.Any()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> retentions = session.FindRetentions(objects); Assert.Fail(DumpRetentions(retentions)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DumpRetentions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;RetentionsInfo&gt; retentions</span></span></span><span class="hljs-function">)</span></span> { StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> retentions.GroupBy(x =&gt; x.Instance.TypeName)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instances = <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>.ToList(); sb.AppendLine(<span class="hljs-string"><span class="hljs-string">$"Found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{instances.Count}</span></span></span><span class="hljs-string"> instances of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Key}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; instances.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance = instances[i]; sb.AppendLine(<span class="hljs-string"><span class="hljs-string">$"Instance </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> retentionPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instance.RetentionPaths) { sb.AppendLine(retentionPath); sb.AppendLine(<span class="hljs-string"><span class="hljs-string">"----------------------------"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); } }</code> </pre> <br><p>  Let's create a new WPF application, and add several windows and a view-model to it, into which we will intentionally implement different variants of memory leaks: </p><br><h3 id="utechka-cherez-eventhandler">  EventHandler leak </h3><br><p>  Perhaps the most common type of memory leak.  The object that owns the event after the subscription begins to keep a strict reference to the subscriber, thereby preventing the garbage collector from removing the subscriber for the entire lifetime of the object that owns the event.  Example: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventHandlerLeakViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHandlerLeakViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Dispatcher.CurrentDispatcher.ShutdownStarted += OnShutdownStarted; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnShutdownStarted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  In this case, the lifetime of the Dispatcher.CurrentDispatcher coincides with the lifetime of the application, and the EventHandlerLeakViewModel will not be released even after the associated window is closed. <br>  Check it out.  We start the application, open the window, close it, run the test, having previously specified the process name and the type name for the search in it.  We get the result: </p><br><blockquote>  Found 1 instances of LeakingApp.EventHandlerLeakViewModel <br>  Instance 1: <br>  static var System.Windows.Application._appInstance <br>  LeakingApp.App <br>  MS.Win32.HwndWrapper <br>  System.Windows.Threading.Dispatcher <br>  System.EventHandler </blockquote><p>  You can fix a leak by unsubscribing from an event in time (for example, when closing a window), or by using weak events (weak events). </p><br><h3 id="utechka-cherez-wpf-binding">  WPF binding leak </h3><br><p>  A rather unobvious way to get a memory leak in a WPF application.  If the target binding object is not DependencyObject and does not support the INotifyPropertyChanged interface, then this object will live in memory forever.  Example: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d:DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{d:DesignInstance local:BindingLeakViewModel}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Title}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TextWrapping</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Wrap"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Margin</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"5"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BindingLeakViewModel</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingLeakViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Title = <span class="hljs-string"><span class="hljs-string">"Hello world."</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Title { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Run the test.  We get the following result: </p><br><blockquote>  Found 1 instances of LeakingApp.BindingLeakViewModel <br>  Instance 1: <br>  static var System.ComponentModel.ReflectTypeDescriptionProvider._propertyCache <br>  System.Collections.Hashtable <br>  System.Collections.Hashtable + bucket [] <br>  System.ComponentModel.PropertyDescriptor [] <br>  System.ComponentModel.ReflectPropertyDescriptor <br>  System.Collections.Hashtable <br>  System.Collections.Hashtable + bucket [] </blockquote><p>  To eliminate such a leak, you must support the INotifyPropertyChanged interface from the BindingLeakViewModel class, or define the binding as a one-time (OneTime). </p><br><h3 id="utechka-cherez-wpf-collection-binding">  WPF collection binding leak </h3><br><p>  When linking to a collection that does not support the INotifyCollectionChanged interface, the collection will never be compiled by the GC.  Example: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ItemsSource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Items}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d:DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{d:DesignInstance local:CollectionLeakViewModel}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl.ItemTemplate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DataTemplate</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataType</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"local:MyCollectionItem"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Title}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DataTemplate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl.ItemTemplate</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectionLeakViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; Items { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CollectionLeakViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); Items.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyCollectionItem { Title = <span class="hljs-string"><span class="hljs-string">"Item 1"</span></span> }); } <span class="hljs-comment"><span class="hljs-comment">// ... } public class MyCollectionItem : INotifyPropertyChanged { public string Title { get; set; } // ... }</span></span></code> </pre> <br><p>  We will correct the test so that it searches for instances of the MyCollectionItem type, and run it. </p><br><blockquote>  Found 1 instances of LeakingApp.MyCollectionItem <br>  Instance 1: <br>  static var System.Windows.Data.CollectionViewSource.DefaultSource <br>  System.Windows.Data.CollectionViewSource <br>  System.Windows.Threading.Dispatcher <br>  System.Windows.Input.InputManager <br>  System.Collections.Hashtable <br>  System.Collections.Hashtable + bucket [] <br>  System.Windows.Input.InputProviderSite <br>  MS.Internal.SecurityCriticalDataClass &lt;System.Windows.Input.IInputProvider&gt; <br>  System.Windows.Interop.HwndStylusInputProvider <br>  MS.Internal.SecurityCriticalDataClass &lt;System.Windows.Input.StylusWisp.WispLogic&gt; <br>  System.Windows.Input.StylusWisp.WispLogic <br>  System.Collections.Generic.Dictionary &lt;System.Object, System.Windows.Input.PenContexts&gt; <br>  System.Collections.Generic.Dictionary + Entry &lt;System.Object, System.Windows.Input.PenContexts&gt; [] <br>  System.Windows.Input.PenContexts <br>  System.Windows.Interop.HwndSource <br>  LeakingApp.CollectionLeakView <br>  System.Windows.Controls.Border <br>  System.Windows.Documents.AdornerDecorator <br>  System.Windows.Controls.ContentPresenter <br>  System.Windows.Controls.StackPanel <br>  System.Windows.Controls.UIElementCollection <br>  System.Windows.Media.VisualCollection <br>  System.Windows.Media.Visual [] <br>  System.Windows.Controls.ItemsControl <br>  System.Windows.Controls.StackPanel <br>  System.Windows.Controls.ItemContainerGenerator <br>  System.Windows.Controls.ItemCollection <br>  System.Windows.Data.ListCollectionView </blockquote><p>  You can fix a leak by using an ObservableCollection instead of a List. <br></p><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  You can write regression tests for leaks in a .NET application, and it‚Äôs not even difficult at all, especially if you already have automated tests that work with a real application. </p><br><p>  Link to <a href="https://github.com/hindikaynen/NetMemoryProfiler">repository</a> and <a href="https://www.nuget.org/packages/Ascon.NetMemoryProfiler">nuget package</a> . </p><br><p>  Download, use in your .NET projects to monitor memory leaks.  We will welcome suggestions and suggestions. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/343684/">https://habr.com/ru/post/343684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343674/index.html">Outbound call center call center: create a predictive dialer in 3CX Call Flow Designer</a></li>
<li><a href="../343676/index.html">Write your insurance agent: Ingosstrakh organizes hackathon</a></li>
<li><a href="../343678/index.html">Is it true that the future of CPaaS is for ‚ÄúServerless‚Äù technologies?</a></li>
<li><a href="../343680/index.html">Secrets of React and Redux in the development of web applications</a></li>
<li><a href="../343682/index.html">Administering Juniper Switches with Ansible</a></li>
<li><a href="../343688/index.html">Implementation of the simplest investment strategy based on API MOEX (Moscow Exchange)</a></li>
<li><a href="../343690/index.html">How to get on the road to OS development</a></li>
<li><a href="../343692/index.html">Open the CrackMe winter contest: break-rover</a></li>
<li><a href="../343694/index.html">Arduino and segment LCD indicator</a></li>
<li><a href="../343696/index.html">Latent parasites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>