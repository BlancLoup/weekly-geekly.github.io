<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arrays in PHP 7: Hash Tables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hash tables are used everywhere, in every serious C program. In fact, they allow the programmer to store values ‚Äã‚Äãin an ‚Äúarray‚Äù, indexing it with stri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arrays in PHP 7: Hash Tables</h1><div class="post__text post__text-html js-mediator-article">  Hash tables are used everywhere, in every serious C program.  In fact, they allow the programmer to store values ‚Äã‚Äãin an ‚Äúarray‚Äù, indexing it with strings, while in C, only integer keys of the array are allowed.  In a hash table, the lower case keys are first hashed and then reduced to the size of the table.  There may be collisions, so we need an algorithm for their resolution.  There are several such algorithms, and the linked list strategy (linked list) is used in PHP. <br><br>  There are a lot of great articles on the Web detailing the structure of hash tables and their implementation.  You can start with <a href="http://preshing.com/">http://preshing.com/</a> .  But keep in mind, options for the structure of hash tables are myriad, and none of them are perfect, each has compromises, despite the optimization of processor cycles, memory usage, or good scaling of the environment.  Some options are better when adding data, others when searching, etc. Choose the implementation depending on what is more important to you. <br><br>  Hash tables in PHP 5 are discussed in detail in the <a href="http://www.phpinternalsbook.com/hashtables/basic_structure.html">phpinternalsbook</a> material, which I wrote with <a href="http://nikic.github.io/">Nikic</a> , the author of a <a href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">good article on hash tables in PHP 7</a> .  Perhaps you will find it interesting too.  True, it was written before the release, so some things in it are slightly different. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here we take a closer look at how the hash tables in PHP 7 are arranged, how to work with them from the point of view of the C language and how to manage them using PHP tools (using structures called arrays).  The source code is mainly available in <a href="">zend_hash.c</a> .  Do not forget that we use hash tables everywhere (usually in the role of dictionaries), therefore, we need to design them so that they are quickly processed by the processor and consume little memory.  These structures have a decisive impact on the overall performance of PHP, since local arrays are not the only place where hash tables are used. <br><a name="habracut"></a><br><h1>  Hash Table Design </h1><br>  There are a number of provisions that we will examine in detail below: <br><br><ul><li> The key can be a string or an integer.  In the first case, the structure is <code>zend_string</code> , in the second - <code>zend_ulong</code> . </li><li>  A hash table must always remember the order in which its elements are added. </li><li>  The size of the hash table changes automatically.  Depending on the circumstances, it independently decreases or increases. </li><li>  From the point of view of internal implementation, the size of the table is always equal to two in degree.  This is done to improve performance and align the placement of data in memory. </li><li>  All values ‚Äã‚Äãin the hash table are stored in a <code>zval</code> structure, nowhere else.  <code>Zval</code> 's can contain data of any type. </li></ul><br>  Consider the <code>HashTable</code> structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_array</span></span></span><span class="hljs-class"> {</span></span> zend_refcounted_h gc; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar reserve) } v; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> flags; <span class="hljs-comment"><span class="hljs-comment">/*  32  */</span></span> } u; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nTableMask; <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äî nTableSize */</span></span> Bucket *arData; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nNumUsed; <span class="hljs-comment"><span class="hljs-comment">/*     arData */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nNumOfElements; <span class="hljs-comment"><span class="hljs-comment">/*      arData */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nTableSize; <span class="hljs-comment"><span class="hljs-comment">/*  ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nInternalPointer; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> zend_long nNextFreeElement; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dtor_func_t</span></span> pDestructor; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> };</code> </pre><br>  Some fields are rarely used, and therefore we will not talk about them. <br><br>  The size of this structure is <b>56 bytes</b> (according to model LP64). <br><br>  The most interesting data field is <code>arData</code> , which is a kind of pointer to the memory area of ‚Äã‚Äãthe <code>Bucket</code> chain.  <code>Bucket</code> itself is a single cell in the array: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bucket</span></span></span><span class="hljs-class"> {</span></span> zval val; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> zend_ulong h; <span class="hljs-comment"><span class="hljs-comment">/*  (  ) */</span></span> zend_string *key; <span class="hljs-comment"><span class="hljs-comment">/*    NULL    */</span></span> } Bucket;</code> </pre><br>  As you can see, <code>zval</code> will be stored in the <code>Bucket</code> structure.  Note that it does not use a pointer to <code>zval</code> , but the structure itself.  This is done because in PHP 7, <code>zval</code> 's are no longer placed on the heap (unlike PHP 5), but the target value stored in <code>zval</code> in the form of a pointer (for example, a PHP string) can be placed in PHP 7. <br><br>  Let's look at the picture, how is the placement in memory: <br><br><img src="https://habrastorage.org/files/c37/c27/e99/c37c27e990434db2bb258f4a98cc6855.png"><br><br>  As you can see, the data placed in the hash table is stored in the adjacent memory section: <code>arData</code> . <br><br><h3>  Adding items while maintaining order </h3><br>  PHP must preserve the order of the elements when they are added to the array.  If you apply the <code>foreach</code> instruction to the array, you will receive the data exactly in the order in which they were placed in the array, regardless of their keys: <br><br><pre> <code class="cpp hljs">$a = [<span class="hljs-number"><span class="hljs-number">9</span></span>=&gt;<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span>, []]; var_dump($a); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) { [<span class="hljs-number"><span class="hljs-number">9</span></span>]=&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>) [<span class="hljs-number"><span class="hljs-number">10</span></span>]=&gt; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } }</code> </pre><br>  This is an important point that imposes a number of restrictions on the implementation of hash tables.  All data is stored in memory next to each other.  In <code>zval</code> 'ah, they are stored packed in a <code>Bucket</code> ' s, which are located in the fields of the <code>arData</code> C-array.  Like that: <br><br><pre> <code class="cpp hljs">$a = [<span class="hljs-number"><span class="hljs-number">3</span></span>=&gt; <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span> =&gt; []];</code> </pre><br><img src="https://habrastorage.org/files/e4d/200/7eb/e4d2007eb80445d9b5f11d129bd53d9c.png"><br><br>  Thanks to this approach, you can easily iterate the hash table: you just need to <code>arData</code> array.  In fact, this is a fast sequential memory scan, consuming very few processor cache resources.  All data from <code>arData</code> can be placed in one line, and access to each cell takes about 1 nanosecond.  Note: in order to increase the efficiency of using the processor cache, <code>arData</code> aligned in accordance with the 64-bit model (the optimizing alignment of 64-bit full instructions is also used).  The hash table iteration code might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; Bucket p; zval val; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ht-&gt;nTableSize; i++) { p = ht-&gt;arData[i]; val = p.val; <span class="hljs-comment"><span class="hljs-comment">/*  -   val */</span></span> }</code> </pre><br>  The data is sorted and transferred to the next cell <code>arData</code> .  To perform this procedure, it is enough just to remember the next available cell in this array, which is stored in the <code>nNumUsed</code> field.  Each time we add a new value, we put it <code>ht-&gt;nNumUsed++</code> .  When the number of elements in <code>nNumUsed</code> reaches the number of elements in the hash table ( <code>nNumOfElements</code> ), we run the compact or resize algorithm, which we will discuss below. <br><br>  A simplified view of adding elements to a hash table using string keys: <br><br><pre> <code class="cpp hljs">idx = ht-&gt;nNumUsed++; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> ht-&gt;nNumOfElements++; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> p = ht-&gt;arData + idx; <span class="hljs-comment"><span class="hljs-comment">/*     bucket  arData */</span></span> p-&gt;key = key; <span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> p-&gt;h = h = ZSTR_H(key); <span class="hljs-comment"><span class="hljs-comment">/*   bucket    */</span></span> ZVAL_COPY_VALUE(&amp;p-&gt;val, pData); <span class="hljs-comment"><span class="hljs-comment">/*     bucket':   */</span></span></code> </pre><br><h3>  Erase values </h3><br>  When a value is deleted, the <code>arData</code> array <code>arData</code> not decrease or regroup.  Otherwise, performance would be disastrous, since we would have to move data in memory.  Therefore, when deleting data from a hash table, the corresponding cell in <code>arData</code> simply marked in a special way: <code>zval</code> UNDEF. <br><br><img src="https://habrastorage.org/files/287/63a/417/28763a417a3a4d97adc5f06331605c41.png"><br><br>  Consequently, the iteration code needs to be slightly rebuilt so that it can process such ‚Äúempty‚Äù cells: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; Bucket p; zval val; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ht-&gt;nTableSize; i++) { p = ht-&gt;arData[i]; val = p.val; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE(val) == IS_UNDEF) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  -   val */</span></span> }</code> </pre><br>  Below we will look at what happens when the hash table is resized and how the <code>arData</code> array needs to be reorganized so that the ‚Äúempty‚Äù cells disappear (compaction). <br><br><h3>  Key Hashing </h3><br>  Keys must be hashed and compressed, then converted from a compressed hashed value and indexed in <code>arData</code> .  The key will be compressed, even if it is integer.  This is necessary in order to fit into the array boundaries. <br><br>  It must be remembered that we cannot index compressed values ‚Äã‚Äãas they are directly in <code>arData</code> .  After all, this will mean that the keys used for the array index directly correspond to the keys obtained from the hash, which violates one of the properties of the hash tables in PHP: preserving the order of the elements. <br><br>  For example: if you add first by key foo, and then by key bar, then the first will be hashed / compressed to key 5, and the second to key 3. If the data foo is stored in <code>arData[5]</code> , and the data bar is in <code>arData[3]</code> , it turns out that the data bar go <b>to the</b> data foo.  And when iterating <code>arData</code> elements will not be transferred in the order in which they were added. <br><br><img src="https://habrastorage.org/files/2af/c4e/9ca/2afc4e9ca1d14ad382978050bdf9e906.png"><br><br>  So, we hash and then compress the key so that it fits in the designated <code>arData</code> boundaries.  But we do not use it as it is, unlike PHP 5. You must first convert the key using the translation table.  It simply matches one integer value resulting from hashing / compression, and another integer value used for addressing within the <code>arData</code> array. <br><br>  There is one caveat: the conversion table memory is prudently located <b>behind the</b> <code>arData</code> vector.  This does not allow the table to use another area of ‚Äã‚Äãmemory, because it is already located next to <code>arData</code> and, therefore, remains in the same address space.  This helps improve data locality.  This is what the described scheme looks like in the case of an 8-element hash table (the minimum possible size): <br><br><img src="https://habrastorage.org/files/adc/2f2/12a/adc2f212a01d427ebb099ba7b5698cbe.png"><br><br>  Now our foo key is hashed into DJB33X and compressed to the required size ( <code>nTableMask</code> ).  The resulting value is an index that can be used to access the <code>arData</code> <b>transformation</b> <code>arData</code> (and not straight cells!). <br><br>  Access to these cells occurs through a negative offset from the starting position of <code>arData</code> .  Two memory areas were merged, so we can store data in memory sequentially.  <code>nTableMask</code> corresponds to a negative value of the table size, so, taking it as a module, we get a value from 0 to ‚Äì7.  Now you can access the memory.  When placing the whole <code>arData</code> buffer in it, we calculate its size using the formula: <br><br> <code>  *  bucket' +   * (uint32)  .</code> <br> <br>  Below you can clearly see how the buffer is divided into two parts: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_HASH_SIZE(nTableMask) (((size_t)(uint32_t)-(int32_t)(nTableMask)) * sizeof(uint32_t)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_DATA_SIZE(nTableSize) ((size_t)(nTableSize) * sizeof(Bucket)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_SIZE_EX(nTableSize, nTableMask) (HT_DATA_SIZE((nTableSize)) + HT_HASH_SIZE((nTableMask))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_SIZE(ht) HT_SIZE_EX((ht)-&gt;nTableSize, (ht)-&gt;nTableMask) Bucket *arData; arData = emalloc(HT_SIZE(ht)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre><br>  When the macros are executed, we get: <br><br><pre> <code class="cpp hljs">(((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(((ht)-&gt;nTableSize)) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Bucket)) + (((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>)(((ht)-&gt;nTableMask))) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)))</code> </pre><br>  Wonderful. <br><br><h3>  Collision resolution </h3><br>  Now we will understand how collisions are resolved.  As you remember, in a hash table, multiple keys for hashing and compression can correspond to the same conversion index.  So, having received a transformation index, we use it to extract data back from <code>arData</code> and compare hashes and keys, checking whether this is necessary.  If the data is incorrect, we go through the linked list using the field <code>zval.u2.next</code> , which reflects the next cell for entering data. <br><br>  Note that the linked list is not memory scattered like traditional linked lists.  Instead of walking through several pointers placed in memory, received from a heap - and probably scattered in the address space - we read from memory the full vector <code>arData</code> .  <b>And this is one of the main reasons for increasing the performance of hash tables in PHP 7, as well as the entire language.</b> <br><br>  In PHP 7, hash tables have very high data locality.  In most cases, access occurs in 1 nanosecond, since the data is usually located in the first level processor cache. <br><br>  Let's see how you can add elements to the hash, as well as resolve conflicts: <br><br><pre> <code class="cpp hljs">idx = ht-&gt;nNumUsed++; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> ht-&gt;nNumOfElements++; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> p = ht-&gt;arData + idx; <span class="hljs-comment"><span class="hljs-comment">/*   arData bucket    */</span></span> p-&gt;key = key; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> p-&gt;h = h = ZSTR_H(key); <span class="hljs-comment"><span class="hljs-comment">/*   bucket    */</span></span> ZVAL_COPY_VALUE(&amp;p-&gt;val, pData); <span class="hljs-comment"><span class="hljs-comment">/*     bucket':   */</span></span> nIndex = h | ht-&gt;nTableMask; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex); <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span></code> </pre><br>  The same with deletion: <br><br><pre> <code class="cpp hljs">h = zend_string_hash_val(key); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> nIndex = h | ht-&gt;nTableMask; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> idx = HT_HASH(ht, nIndex); <span class="hljs-comment"><span class="hljs-comment">/*  ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idx != HT_INVALID_IDX) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> p = HT_HASH_TO_BUCKET(ht, idx); <span class="hljs-comment"><span class="hljs-comment">/*  bucket    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;key == key) || <span class="hljs-comment"><span class="hljs-comment">/*  ?    ? */</span></span> (p-&gt;h == h &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">/* ...    */</span></span> p-&gt;key &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">/*   (   ) */</span></span> ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*     ? */</span></span> _zend_hash_del_el_ex(ht, idx, p, prev); <span class="hljs-comment"><span class="hljs-comment">/*   !   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } prev = p; idx = Z_NEXT(p-&gt;val); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FAILURE;</code> </pre><br><h3>  Hash Conversion and Initialization Cells </h3><br>  <code>HT_INVALID_IDX</code> is a special flag that we put in the conversion table.  It means "this transformation leads nowhere, no need to continue." <br><br>  Two-stage initialization gives certain advantages, allowing you to minimize the impact of an empty, just-created hash table (a frequent case in PHP).  When creating a table, we simultaneously create bucket cells in <code>arData</code> and two transformation cells, in which we place the <code>HT_INVALID_IDX</code> flag.  Then we apply a mask that directs the transformation to the first cell ( <code>HT_INVALID_IDX</code> , there is no data here). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_MIN_MASK ((uint32_t) -2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_HASH_SIZE(nTableMask) (((size_t)(uint32_t)-(int32_t)(nTableMask)) * sizeof(uint32_t)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HT_SET_DATA_ADDR(ht, ptr) do { (ht)-&gt;arData = (Bucket*)(((char*)(ptr)) + HT_HASH_SIZE((ht)-&gt;nTableMask)); } while (0) static const uint32_t uninitialized_bucket[-HT_MIN_MASK] = {HT_INVALID_IDX, HT_INVALID_IDX}; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* hash lazy init */</span></span></span><span class="hljs-meta"> ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span><span class="hljs-meta"> ht-&gt;nTableSize = zend_hash_check_size(nSize); ht-&gt;nTableMask = HT_MIN_MASK; HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket); ht-&gt;nNumUsed = 0; ht-&gt;nNumOfElements = 0; }</span></span></code> </pre><br>  Please note that you can not use a bunch.  Quite enough static constant memory area (static const memory zone), so it turns out much easier ( <code>uninitialized_bucket</code> ). <br><br>  After adding the first element, we completely initialize the hash table.  In other words, we create the last required transformation cells depending on the requested size (by default, it starts with 8 cells).  Placement in memory comes from a heap. <br><br><pre> <code class="cpp hljs">(ht)-&gt;nTableMask = -(ht)-&gt;nTableSize; HT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)-&gt;u.flags &amp; HASH_FLAG_PERSISTENT)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;HT_HASH(ht, (ht)-&gt;nTableMask), HT_INVALID_IDX, HT_HASH_SIZE((ht)-&gt;nTableMask))</code> </pre><br>  The <code>HT_HASH</code> macro allows <code>HT_HASH</code> to access the transformation cells in the part of the memory-allocated buffer for which a negative offset is used.  The table mask is always negative because the cells of the translation table are indexed to the minus from the beginning of the <code>arData</code> buffer.  Here C programming is revealed in all its glory: billions of cells are available to you, swim in this infinity, just don't drown. <br><br>  An example of a lazy initialized (lazy-initialized) hash table: it was created, but so far no hash has been placed in it. <br><br><img src="https://habrastorage.org/files/01e/33b/b2a/01e33bb2a85a46f3952969c2712d9957.png"><br><br><h3>  Hash Fragmentation, Magnification and Compaction </h3><br>  If the hash table is full and you need to add new elements, you have to increase its size.  This is a big advantage of hash tables compared to classic hard-limited arrays in C. With each increase, the size of the hash table doubles.  I remind you that when increasing the size of the table, we pre-allocate the <code>arBucket</code> C-array in memory, and put special UNDEF values ‚Äã‚Äãin the empty cells.  As a result, we cheerfully lose memory.  Losses are calculated by the formula: <br><br> <code>(  ‚Äì  ) *  Bucket</code> <br> <br>  All this memory consists of UNDEF cells and waits for data to be placed into it. <br><br>  For example, you have 1024 cells in a hash table, and you add a new item.  The table grows to 2048 cells, of which 1023 are empty.  1023 * 32 bytes = approximately 32 KB.  This is one of the drawbacks of implementing hash tables in PHP. <br><br>  It must be remembered that a hash table may consist entirely of UNDEF cells alone.  If you add and delete many items, the table will be fragmented.  But in order to preserve the order of the elements, we add everything new only at the end of <code>arData</code> , rather than inserting spaces into the resulting spaces.  Therefore, a situation may arise when we reach the end of <code>arData</code> , although UNDEF cells are still present in it. <br><br>  An example of a highly fragmented 8-cell hash table: <br><br><img src="https://habrastorage.org/files/9aa/a91/9b3/9aaa919b3f88467dbfb12c4a9118b545.png"><br><br>  As you remember, new values ‚Äã‚Äãcannot be stored in UNDEF cells.  In the above scheme, when iterating a hash table, we go from <code>arData[0]</code> to <code>arData[7]</code> . <br><br>  By increasing the size, you can reduce the <code>arData</code> vector and eventually fill the empty cells by simply redistributing the data.  When a table is given a command to resize, it first of all tries to compact itself.  It then calculates whether it will have to increase again after compaction.  And if it turns out that yes, then the table is doubled.  After that, the vector <code>arData</code> begins to occupy twice as much memory <code>(realloc())</code> .  If it is not necessary to increase, then the data is simply redistributed into cells already allocated in memory.  It uses an algorithm that we cannot use every time we remove items, because it spends too many CPU resources, and the exhaust is not so great.  You remember the famous programmer compromise between the processor and memory? <br><br>  This illustration shows the previous fragmented hash table after compression: <br><br><img src="https://habrastorage.org/files/b64/0e9/180/b640e9180784449191430e2808ed553c.png"><br><br>  The algorithm scans <code>arData</code> and fills each UNDEF cell with data from the next non-UUNDEF cell.  Simplified it looks like this: <br><br><pre> <code class="cpp hljs">Bucket *p; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nIndex, i; HT_HASH_RESET(ht); i = <span class="hljs-number"><span class="hljs-number">0</span></span>; p = ht-&gt;arData; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(Z_TYPE(p-&gt;val) == IS_UNDEF)) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = i; Bucket *q = p; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++i &lt; ht-&gt;nNumUsed) { p++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(Z_TYPE_INFO(p-&gt;val) != IS_UNDEF)) { ZVAL_COPY_VALUE(&amp;q-&gt;val, &amp;p-&gt;val); q-&gt;h = p-&gt;h; nIndex = q-&gt;h | ht-&gt;nTableMask; q-&gt;key = p-&gt;key; Z_NEXT(q-&gt;val) = HT_HASH(ht, nIndex); HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(ht-&gt;nInternalPointer == i)) { ht-&gt;nInternalPointer = j; } q++; j++; } } ht-&gt;nNumUsed = j; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } nIndex = p-&gt;h | ht-&gt;nTableMask; Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex); HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i); p++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++i &lt; ht-&gt;nNumUsed);</code> </pre><br><h1>  Hash table API </h1><br>  Well, now we know the main points of the implementation of the hash table in PHP 7. Let's now consider its public API. <br><br>  There‚Äôs really nothing to talk about (well, in PHP 5, the API is made much better).  Just when using the API function, do not forget about three things: <br><br><ul><li>  About your operation (add, delete, clear, destroy, etc.). </li><li>  About the type of your key (integer or lowercase). </li><li>  About the type of data you want to store. </li></ul><br><br>  Whatever your key, lowercase or integer, the main thing: the API should be aware that the lowercase keys get hashes from <code>zend_string</code> , and the integer keys are immediately used as a hash.  Therefore, you can meet <code>zend_hash_add(ht, zend_string, data)</code> or <code>zend_hash_index_add(ht, long, data)</code> . <br><br>  Sometimes a key can be a simple pair (char * / int).  In this case, you need to use another API, for example <code>zend_hash_str_add(ht, char *, int, data)</code> .  Remember that, be that as it may, the hash table will turn to <code>zend_string</code> , turn your string key into it and calculate its hash, spending some amount of processor resources.  If you can use <code>zend_string</code> , use.  Surely they have already calculated their hashes, so the API will simply take them.  For example, the PHP compiler computes the hash of each part of the string that is used, like <code>zend_string</code> .  OPCache stores a similar hash in shared memory.  As the author of extensions, I recommend to initialize all your <code>zend_string</code> literals in <code>zend_string</code> . <br><br>  Now about the data that you are going to store in a hash table.  Again, this can be anything, the hash table will still put the data in the <code>zval</code> present in each <code>Bucket</code> .  In PHP 7, zvals can store any kind of data.  In general, the hash table API expects you to package the data in <code>zval</code> , which the API perceives as a value. <br><br>  The situation can be somewhat simplified if you have a pointer to the storage or memory area (the data referenced by the pointer).  Then the API places this pointer or memory area in zval, and then zval itself uses the pointer as data. <br><br>  Examples will help to understand the idea: <br><br><pre> <code class="cpp hljs">zend_hash_str_add_mem(hashtable *, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) zend_hash_index_del(hashtable *, zend_ulong) zend_hash_update_ptr(hashtable *, zend_string *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) zend_hash_index_add_empty_element(hashtable *, zend_ulong)</code> </pre><br>  When retrieving data, you get either zval * or NULL.  If a pointer is used as a value, the API may return as is: <br><br><pre> <code class="cpp hljs">zend_hash_index_find(hashtable *, zend_string *) : <span class="hljs-function"><span class="hljs-function">zval * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_hash_find_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hashtable *, zend_string *)</span></span></span><span class="hljs-function"> : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_hash_index_find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hashtable *, zend_ulong)</span></span></span><span class="hljs-function"> : zval *</span></span></code> </pre><br>  As for the _new API like <code>zend_hash_add_new()</code> , it is better not to use it.  It uses the engine for internal needs.  This API causes the hash table to store data, even if it is already available in the hash (the same key).  As a result, you will have duplicates, which may not have the best effect on your work.  So you can use this API only if you are completely sure that there is no data in the hash that you are going to add.  This will avoid having to search for them. <br><br> :     5, API <code>zend_symtable_api()</code>         : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> zend_always_inline zval *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_symtable_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashTable *ht, zend_string *key, zval *pData)</span></span></span><span class="hljs-function"> </span></span>{ zend_ulong idx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_HANDLE_NUMERIC(key, idx)) { <span class="hljs-comment"><span class="hljs-comment">/* handle numeric key */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_hash_index_update(ht, idx, pData); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_hash_update(ht, key, pData); } }</code> </pre><br>           ,      : , zval‚Ä¶      <code>ZEND_HASH_FOREACH</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_HASH_FOREACH(_ht, indirect) do { \ Bucket *_p = (_ht)-&gt;arData; \ Bucket *_end = _p + (_ht)-&gt;nNumUsed; \ for (; _p != _end; _p++) { \ zval *_z = &amp;_p-&gt;val; \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (indirect &amp;&amp; Z_TYPE_P(_z) == IS_INDIRECT) { \ _z = Z_INDIRECT_P(_z); \ } \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (UNEXPECTED(Z_TYPE_P(_z) == IS_UNDEF)) continue; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_HASH_FOREACH_END() \ } \ } while (0)</span></span></code> </pre><br><h1>  ¬´ -¬ª </h1><br> ,     :     <code>arData</code>   ,     ,     <code>arData</code> .       -:    - <code>arData</code> .     -           ,         . <br><br>       :           .    <code>arData</code>           ,     .        ,        . <br><br>    ¬´ -¬ª (packed hashtable): <br><br><img src="https://habrastorage.org/files/a8a/1a2/d58/a8a1a2d586bc4725bfba1663e13bdae4.png"><br><br>  ,         .   <code>arData[0]</code>          .          , 2 * uint32 = 8 .     .  ,       ,    . <br><br>   :    , ,    ( /),   -     .         bucket'. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ZEND_FASTCALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_hash_packed_to_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashTable *ht)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *new_data, *old_data = HT_GET_DATA_ADDR(ht); Bucket *old_buckets = ht-&gt;arData; ht-&gt;u.flags &amp;= ~HASH_FLAG_PACKED; new_data = pemalloc(HT_SIZE_EX(ht-&gt;nTableSize, -ht-&gt;nTableSize), (ht)-&gt;u.flags &amp; HASH_FLAG_PERSISTENT); ht-&gt;nTableMask = -ht-&gt;nTableSize; HT_SET_DATA_ADDR(ht, new_data); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(ht-&gt;arData, old_buckets, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Bucket) * ht-&gt;nNumUsed); pefree(old_data, (ht)-&gt;u.flags &amp; HASH_FLAG_PERSISTENT); zend_hash_rehash(ht); }</code> </pre><br> - <code>u.flags</code>   ,  ,    -.  ,         -,     .        ,          .  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht, zend_ulong h, zval *pData, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> flag ZEND_FILE_LINE_DC) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nIndex; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx; Bucket *p; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(!(ht-&gt;u.flags &amp; HASH_FLAG_INITIALIZED))) { CHECK_INIT(ht, h &lt; ht-&gt;nTableSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h &lt; ht-&gt;nTableSize) { p = ht-&gt;arData + h; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> add_to_packed; } <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> add_to_hash; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ht-&gt;u.flags &amp; HASH_FLAG_PACKED) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(h &lt; ht-&gt;nTableSize)) { p = ht-&gt;arData + h; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((h &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; ht-&gt;nTableSize &amp;&amp; (ht-&gt;nTableSize &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; ht-&gt;nNumOfElements) { zend_hash_packed_grow(ht); p = ht-&gt;arData + h; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> convert_to_hash; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre><br> :  -     ,  . <br><br><ul><li> :        : <code>(_ - 2) * (uint32)</code> .     ,     . </li><li> :            .        ,          . </li></ul><br>                (,  42  60),  -    ¬´¬ª.        (   ‚Äî  )    .    -   API: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> ZEND_FASTCALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_hash_real_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashTable *ht, zend_bool packed)</span></span></span></span></code> </pre><br>   ,  <code>zend_hash_real_init()</code> ‚Äî   ,   ¬´¬ª ( <code>zend_hash_init()</code> ). ,   ¬´¬ª,  -  .     ,     . <br><br><h1>    </h1><br>  ,      -    . <br><br><h3>  -     </h3><br>      (packed array): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, memory_get_usage()); } $a = range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20000</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* range()    */</span></span> m(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">5000</span></span>; $i++) { <span class="hljs-comment"><span class="hljs-comment">/*      , *       : *    ¬´¬ª  */</span></span> $a[] = $i; } m(); <span class="hljs-comment"><span class="hljs-comment">/*         * -   ¬´¬ª,   *     */</span></span> $a[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; m();</code> </pre><br>   ,   : <br><br><pre> <code class="php hljs"><span class="hljs-number"><span class="hljs-number">1406744</span></span> <span class="hljs-number"><span class="hljs-number">1406776</span></span> <span class="hljs-number"><span class="hljs-number">1533752</span></span></code> </pre><br>              130  (   25 000 ). <br><br>       : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, memory_get_usage()); } <span class="hljs-comment"><span class="hljs-comment">/*  -    .   *   32 768  (2^15).    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">32768</span></span>; $i++) { $a[$i] = $i; } m(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">32768</span></span>; $i++) { unset($a[$i]); } m(); <span class="hljs-comment"><span class="hljs-comment">/*   .  -  , *        */</span></span> $a[] = <span class="hljs-number"><span class="hljs-number">42</span></span>; m();</code> </pre><br>  Results: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1406864</span></span> <span class="hljs-number"><span class="hljs-number">1406896</span></span> <span class="hljs-number"><span class="hljs-number">1533872</span></span></code> </pre><br>       ,     (  , modulo noise).   <code>unset()</code>        <code>arData</code>  32 768 ,  UNDEF-zval'. <br><br>   -   <b> </b> .  <code>nNumUsed</code> ,     <code>arData</code>     ?     ,    ,     . <br><br>   ? <br><br>    ‚Äî ,      UNDEF-.     :     , <b>     </b>    ,     ,     .        ,   ,    ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ,   , : */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*          (idx). *   ,      */</span></span> $a[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; m();</code> </pre><br>  : <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1406864</span></span> <span class="hljs-number"><span class="hljs-number">1406896</span></span> <span class="hljs-number"><span class="hljs-number">1406896</span></span></code> </pre><br>  See the difference?        32 768  65 538 ,   .        32 767 .      <code>Bucket</code> ,    <code>zval</code> ,    <code>long</code> (   42),    .   zval    long. :) ,    <b> </b>  32 768 ,     , ,   .        , ,    . .,    ,           UNDEF-zval'  ¬´¬ª . <br><br>        <b></b> -,    .       ,  ,   ,       .       ¬´¬ª ,          ( <code>idx 0</code> ),    ‚Äî  UNDEF-zval. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, memory_get_usage()); } <span class="hljs-comment"><span class="hljs-comment">/*  -    .   *   32 768  (2^15).       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">32768</span></span>; $i++) { <span class="hljs-comment"><span class="hljs-comment">/*   ,       */</span></span> $a[<span class="hljs-string"><span class="hljs-string">' '</span></span> . $i] = $i; } m(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">32768</span></span>; $i++) { unset($a[<span class="hljs-string"><span class="hljs-string">' '</span></span> . $i]); } m(); <span class="hljs-comment"><span class="hljs-comment">/*         . *   ,      */</span></span> $a[] = <span class="hljs-number"><span class="hljs-number">42</span></span>; m();</code> </pre><br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2582480</span></span> <span class="hljs-number"><span class="hljs-number">1533936</span></span> <span class="hljs-number"><span class="hljs-number">1533936</span></span></code> </pre><br>   .    2,5 .   <code>unset()</code>      ,   .   32 768  <code>zend_string</code> ,        1,5 . <br><br>     ,      ,      .    ,     ,    .   42   idx 0,    .  The end of the story. <br><br>  ,      -    ,     .           ?       ,        (,   ?) /      ,      .              .       ,     .      ¬´¬ª  20  32  ,       . <br><br><h3>   (Immutable arrays) </h3><br>   ‚Äî    OPCache.   OPCache,       , . .    .   OPCache ,               .  ,  AST-. ,   ‚Äî   AST-.  For example: <br><br><pre> <code class="cpp hljs">$a = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>];</code> </pre><br>  <code>$a</code> ‚Äî  AST-.  ,     ,      .  OPCache     AST-,       ( )     ,     .    OPCache     <a href="http://jpauli.github.io/2015/03/05/opcache.html">  </a> . <br><br>  , OPCache    ,    <i>IS_ARRAY_IMMUTABLE</i>  <i>IS_TYPE_IMMUTABLE</i> .    <i>IS_IMMUTABLE</i> ,       .       ,     .       . <br><br>   : <br><br><pre> <code class="cpp hljs">$ar = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++$i) { $ar[] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]; }</code> </pre><br>     400    OPCache,    ‚Äî  35 .  OPCache ,        8-     <code>$ar</code> .        8- .    OPCache,    8-   <i>IS_IMMUTABLE</i>       <code>$ar</code>      ,       . <br><br> ,         , , <code>$ar[42][3] = 'foo';</code> ,  8-   <code>$ar[42]</code>       . <br><br>   -    ,   .   , PHP- ‚Äî     - Zend.        PHP,      .  -    . ,      / .        -.       OPArray       (   )    (   ).  PHP   ,    OPArray:     .    OPCache      <i>IMMUTABLE</i> ,        .     ,              . <br><br> OPCache       ,   .       ,         (      ,   ). ,  -   OPCache     ,    PHP-      .      PHP. <br><br>       .  ,         : <br><br><pre> <code class="cpp hljs">$a = [<span class="hljs-number"><span class="hljs-number">1</span></span>]; $b = [<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>      .     ,      ( <a href="http://jpauli.github.io/2015/09/18/php-string-management.html">interned strings</a> ),       ,      .   ‚Äî  ,    ( ,   ,     ),               runtime' PHP.         (    ).  ,        OPCache. </div><p>Source: <a href="https://habr.com/ru/post/308240/">https://habr.com/ru/post/308240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308226/index.html">Who are you, Professor Malan?</a></li>
<li><a href="../308228/index.html">How Clojure helps speed up the writing of Selenium tests</a></li>
<li><a href="../308232/index.html">How it works and what the ‚Äúdeep‚Äù integration of ‚ÄúBitrix24‚Äù and the UniSender email newsletter service can do</a></li>
<li><a href="../308234/index.html">What is lead</a></li>
<li><a href="../308236/index.html">Linux Vulnerability Audit with Vulners.com</a></li>
<li><a href="../308242/index.html">We break garbage collection and deserialization in PHP</a></li>
<li><a href="../308246/index.html">OpenStreetView launch</a></li>
<li><a href="../308248/index.html">Trello Clone on Phoenix and React. Parts 6-7</a></li>
<li><a href="../308254/index.html">Choosing an html-parser for Apache.JMeter</a></li>
<li><a href="../308256/index.html">The creation of the game "Words from the Word"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>