<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Future testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing to translate a series of notes by James Whittaker entitled "The Future of Testing". This series in the original was published at the end of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Future testing</h1><div class="post__text post__text-html js-mediator-article">  Continuing to translate a series of notes by James Whittaker entitled "The Future of Testing".  This series in the original was published at the end of 2008, and in it James made a number of predictions as to what the work of testers will look like in the future, in 10-20 years.  His predictions are largely based on the ideas that developed and continue to grow at Microsoft, where James was working at the time. <br><br>  In the translation, we have collected all the notes in the series in one article, consisting of eight parts (the last four parts are presented in this post): <ol><li>  Testosourcing </li><li>  Virtualization </li><li>  Information </li><li>  Move testing to top </li><li>  Visualization </li><li>  Culture testing </li><li>  Testers in the role of designers </li><li>  Testing after release </li></ol><a name="habracut"></a><h3>  5. Visualization </h3><br>  What can a computer program look like?  Wouldn't it be helpful to have a visualization of a program that could be used during development and testing?  At a glance it would be clear to us which parts of the product were still left unfinished.  Dependencies, interfaces, and data would be easier to understand, and hopefully it would be easier to test them.  At the very least, we could observe during development how the product grows and develops, and during testing to look at how input data is processed and how interaction with the environment takes place. <br><br>  Other engineering disciplines have such visualizations.  Take those who make cars.  All people involved in the assembly process can see the car.  They can see that the bumpers or the steering wheel are not installed on the car.  They can observe the assembly along the entire length of the conveyor, from the empty body to the full-featured product, ready to be shipped to the dealer.  How much is left to complete?  Well, twenty meters to the end of the line! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The fact that all participants in the car assembly process have a common vision of the product is very useful.  They use common terms that everyone can understand, since every part, every connection, every interface is where it should be, and then when it should be there. <br><br>  Unfortunately, this is not our world.  We are constantly tormented by the questions ‚Äúhow much is left to complete?‚Äù, ‚ÄúWhat tasks have not been accomplished?‚Äù.  This is a problem that 21st century testers will solve. <br><br>  Architects and developers are already engaged in it.  Visual Studio contains a large number of diagrams and visualizations - from sequence diagrams to dependency graphs.  Testers also solve this problem.  Inside the walls of the ‚Äúempire‚Äù, there are already visualization systems for viewing code changes on the Xbox (objects whose code has changed, are highlighted in green when rendering, and after testing the backlight disappears) to determine insufficiently thoroughly tested complex sections of Windows code (heat maps showing the coverage ratio code and complexity of the code performed in three-dimensional space, can detect problem areas).  These visualizations look impressive, they are beautiful and allow testers to determine at a glance what they need testing. <br><br>  We need more similar visualizations, but this task needs to be approached carefully.  We cannot simply accept diagrams provided by UML and modeling groups.  These visualizations are designed to solve other problems that may or may not coincide with those encountered in ours.  Many of the existing visualizations are designed to help architects or developers, but their needs are different from ours.  We need to think about it from the standpoint of testers.  We need visualizations that associate requirements with code, tests with interfaces, changes in code with a user interface, code coverage with controls.  Isn't it great when you launch a test application and see that the controls ‚Äúglow‚Äù with an intensity that reflects the test coverage or the number of tests in which they were involved?  Or would it be nice to see an animated graph of network usage or real-time interaction with the database?  Why can't we see network traffic or SQL queries right away?  We do not see much of what is hidden inside our application, and it's time to pull it to the surface and use it to improve the quality of the program. <br><br>  This task can be solved in the near future, and many smart people are working on it. <br><br>  This is testing programs in bright colors. <br><br><h3>  6. Culture testing </h3> <br>  A couple of months ago, I attended a lecture given by one of the Leading Microsoft Specialists (however, it may have been an Outstanding Engineer, I don‚Äôt understand very well the difference between them).  Like all our Leading Specialists, he was incredibly clever and when he presented projects to develop several new products that he did with his colleagues, something came down to me. <br><br>  Apparently, I could not keep it in myself, and I had an expression on my face resembling that which sometimes happens with people with kidney stones.  The Leading Specialist noticed this (just like the girl who was sitting next to me, but I don‚Äôt want to talk about it) and after the lecture approached me.  This is how our conversation began: <br><br>  - James - (well, he knew my name!) - I see that you have any doubts about my project or product, about which I told.  I would like to hear your opinion. <br><br>  - No, no problems with your product or with the project.  My doubts concern <em>you</em> . <br><br>  - Sorry? <br><br>  ‚ÄúPeople like you scare me,‚Äù I said. ‚ÄúYou spend all your time on dreams of new opportunities and ways of using, you design interfaces and protocols.‚Äù  You are an important person, and people listen to you and do what you dream.  But you do all this <em>without having a clue about testing</em> . <br><br>  And at that moment he tried to do the right thing - turn to testers for help.  He invited me to participate in the evaluation of product design.  That was exactly what was expected of him. <br><br>  But this is absolutely not what is needed. <br><br>  Attracting a tester to design a product is better than not doing it at all.  But not much better.  Testers will focus on testability issues.  Developers on the possibility of implementation.  And who take into account both aspects?  Who will decide who is right and when it is necessary to compromise?  No one.  Attracting a tester to the design provides only a slight improvement;  attracting designers (and all other participants) to testing is the future. <br><br>  Seriously, why do people who create software have so little testing experience?  And why didn't we try to change that?  Maybe we, testers, are too entrenched in their role and are now jealously guarding the keys to our intellectual realm?  Is testing so full of secrets and riddles that developers can not comprehend it?  Or maybe the developers are accustomed to dumping this ‚Äúnot very interesting‚Äù part of the work for us and now take it for granted? <br><br>  Including testers in the development team does not help.  Involving them in the early stages too.  We have projects with a one-to-one ratio of developers and testers, but the products produced still do not look quite reliable.  There are projects where the ‚Äúworst‚Äù ratio of the number of developers to the number of testers who produce products is clearly better.  I think in the future we will see that the separation of roles does not work.  This division, on the contrary, contributes to the fact that testing is applied too late, and it is impossible to use its full potential. <br><br>  The current culture of testing and separation of roles is flawed, and the right way is to combine roles.  Quality should be the work of everyone.  Think of it in Tolkien's terms: <em>one role to rule over all!</em> <br><br>  Imagine a world in which every participant in the development process has knowledge of testing.  The architect knows how to test, the designer knows this, the developer also does not lag behind, and they all apply this knowledge in everything they do, constantly and consistently.  This does not eliminate the need for the existence of dedicated testers - someone has to present an independent opinion, it will simply lead to better testing.  If every decision made at any of the development stages is subjected to the correct checks, then the final testing will be able to achieve the level of thoroughness that we can only dream of right now.  If each project participant understands testing, imagine what several dedicated testers can accomplish! <br><br>  For this utopia to become a reality, huge changes in the testing culture will be required.  Testing should be included in the programs of all educational institutions graduating programmers.  As the developer grows, the training in testing should not stop, but, on the contrary, should become more powerful and sophisticated.  We need to reach a level where everyone interested in the project understands testing, and <em>they have no choice but to apply the principles of testing in everything they do</em> .  One day, tools will appear to support this.  One day we will be at the turn, when it‚Äôs just not possible to write a program that cannot be tested, and not because some cool tester achieved this, but because each project participant worked on it. <br><br>  Testing is too important a role to ‚Äúlag behind‚Äù the development process.  Design decisions that are important from the point of view of testing are made at an early stage, and this is when testing should begin.  You can not also give testing in the hands of the only selected role responsible for quality.  On the contrary, we need such cultural changes that will make the quality of each work, and the principles of testing will penetrate into everything we do. <br><br><h3>  7. Testers in the role of designers </h3><br>  In the modern world, testers mostly occupy the last line of defense, but this is often not recognized when evaluating work and while distributing bonuses.  If we find a serious bug - well, so we should have found it, so it was expected.  If we miss a bug, they ask us questions.  Testers are often referred to as such - ignored if you do, and scolded, if not. <br><br>  But everything changes, and this too will change soon, because it must change.  My friend Roger Sherman (Microsoft‚Äôs first corporate testing director) describes this change by comparing testing with a caterpillar that becomes a butterfly.  According to Roger, the butterfly that should come out of testing is design. <br><br>  And I can not disagree with him.  If testing and testing techniques are applied at earlier stages of the development process, the work of testers will be more similar to designing programs than to verification.  We will focus more on developing a quality strategy for <em>all</em> software artifacts, and not just for executable code.  We will spend more time <em>identifying the</em> need for testing than doing test cases.  We will monitor and evaluate automation, not create and debug it.  We will spend more time analyzing the state of ready-made tests than creating new ones.  We will become designers, and our work will rise to a higher level of abstraction and shift closer to the beginning of the life cycle. <br><br>  At Microsoft, this role is played by test architects, and I think most of the testing work is moving in this direction.  If you have read the previous six parts, then you understand what changes are required so that this design-oriented role can come out on top. <br><br>  It looks like a bright future, but there is definitely a fly in the ointment.  The source of the problem is in the types of errors and testing methods that we successfully use now.  It would not be an exaggeration to say that we are better looking for structural errors (crashes, hangups and defects associated with the program itself, with its internal structure, rather than functionality) than with business logic errors.  But in the future, which I am talking about, there will be many technological solutions to eliminate structural errors.  This will free testers to work with business logic errors, and this is such a category of problems with which, I think, in general, our entire industry does not know how to cope in an organized or systematic way. <br><br>  Finding business logic errors means that we need to understand the business logic itself.  Understanding business logic means closer interaction with customers and competitors, it means immersion in the area of ‚Äã‚Äãknowledge in which our software works, it means not only engaging in the early stages of the development cycle, but also participating in work on prototypes, requirements, usability and so on, as we have never done before. <br><br>  Working in the initial stages of the development cycle is very difficult, and testers do not have relevant experience.  In order to start successfully, we must be ready to meet these new problems, we must be ready to master new ways of thinking, new approaches to users and to quality. <br><br>  The work at the beginning of the pipeline is definitely different from what we are doing now, and this is the place where many, many testers will find their place as the future becomes present. <br><br><h3>  8. Testing after release </h3><br>  This is the final part of my predictions about the future of testing.  Hope you liked the previous ones.  And finally, I saved one of my possibly most contradictory predictions: in the future we will supply test code with software products and will be able to execute it remotely.  I already anticipate hacker smiles and resentment of privacy advocates, but I will come back to this a little later. <br><br>  I was in the Windows group when Vista was released, and I remember how I showed it to my eight-year-old son one evening at home.  He plays a lot (and it works, if you can believe it) on the computer, and he really liked the Aero interface, the cute gadgets on the sidebar, and the speed with which his favorite games worked (at the time it was Line Rider and Zoo Tycoon ), really impressed him.  I also thought: ‚ÄúWhat a pity that he does not maintain a sectoral blog,‚Äù but I digress from the topic. <br><br>  So, at the end he asked me a question that awe every tester: ‚ÄúDad, what did you do here?‚Äù <br><br>  I fell silent, which is rather unusual for me, and muttered something unintelligible.  How do you explain to an eight-year-old child that you worked on something for several months (I just started working at Microsoft and joined the work on Vista at the very end), but didn‚Äôt actually do anything?  I tried to get by with standard answers to this terrible question (exclamation marks are required, they help me convince myself that there is some truth in my words): <br><br>  ‚ÄúI worked to make it better!‚Äù <br><br>  ‚ÄúThat it works the way it works ... thanks to me!‚Äù <br><br>  ‚ÄúIf not for us, testers, it would be a threat to society!‚Äù <br><br>  The last of these statements I particularly like.  However, they all sound equally unconvincing.  How can it be that I have been working on the product for so long, and I can‚Äôt demonstrate anything as a contribution, except for the absence of some errors. <br><br>  It seems to me that at that very moment I had this idea: the test code should come with the program, it should continue to exist after the release and do its work in the absence of testers.  This is not a pathetic attempt to give me and my colleagues the opportunity to point out something for bragging, but a way to provide ongoing testing and diagnostics.  Let's face it, at the time of release we can never say that testing has been fully completed, so why should we stop? <br><br>  We already do some of this.  The Watson technology (you probably know the ‚Äúsend / not send error report‚Äù message in Windows applications) included in Windows allows us to collect error data as soon as they occur during operation.  The next logical step should be the ability to do something with the information received. <br><br>  Watson currently collects error data and captures relevant debug information.  Then some poor fellow developer should get through all this data and figure out how to fix it with Windows updates.  In 2004 it was a revolutionary idea, and it is still relevant.  In a few years, this will probably be considered an outdated approach. <br><br>  What if that same poor fellow can run additional tests and take full advantage of the test infrastructure that existed before the product was released?  What if he can install fixes and run regression testing in the environment in which the failure occurred?  What if he can install updates into the operational environment and ask the application to perform regression testing himself? <br><br>  He will not be a poor fellow, that's for sure.  But since testing and test artifacts are lost after final assembly and product delivery, this is now impossible. <br><br>  To achieve such capabilities, the application must keep the pre-test data and always have it with you.  And this means that the possibility of self-testing will be one of the main features of the software of the future.  Our job will be to find a way to incorporate our ‚Äútesting magic‚Äù into the product itself.  And our reward will be the joy of how the eyes of our children shine when they see that the most first-class feature of the product is the one we designed! <br><br>  Oh yeah, about hackers and privacy advocates: do not be afraid!  Hugh Thompson and I had long warned about the inclusion of a test code in the delivery (see chapter Attack No. 10 in the book How to Crack Software Protection).  Since we know how to hack, we have the chance to do it right. <br>  Conclusion <br><br>  Colleagues, even if you disagree with the ideas expressed by James - think about what will happen to testing not in a year, not in two, but in half a century.  You need to start building this future now.  And we will build it with you, so it will be the way we make it. <br><br>  Those who want to get acquainted with a more detailed version of the predictions of James Whittaker can watch and listen to the recording of his <a href="http://www.youtube.com/watch%3Fv%3DPug_5Tl2UxQ">speech at the GTAC conference</a> , as well as the <a href="http://www.utest.com/webinars/future-software-testing">webinar</a> recording <a href="http://www.utest.com/webinars/future-software-testing">organized by uTest</a> . </div><p>Source: <a href="https://habr.com/ru/post/83274/">https://habr.com/ru/post/83274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../83266/index.html">I carry everything with me</a></li>
<li><a href="../83269/index.html">Barbara Liskov substitution principle</a></li>
<li><a href="../83270/index.html">Michael Jordan "Nike Commercial" Failure "on Microsoft's Creative Destruction</a></li>
<li><a href="../83272/index.html">Interesting economy - lunch at a restaurant is cheaper than homemade</a></li>
<li><a href="../83273/index.html">The third mention of the Menusator</a></li>
<li><a href="../83275/index.html">Arduino microcontrollers for students of Nizhny Novgorod RadioTechnical College</a></li>
<li><a href="../83277/index.html">How to work with a manager</a></li>
<li><a href="../83279/index.html">Every Build You Break</a></li>
<li><a href="../83286/index.html">Handheld game consoles - small digest</a></li>
<li><a href="../83287/index.html">Qualities of a successful entrepreneur - Ability to change course (3/11)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>