<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux demon on PHP5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, today I will describe a rather amusing puzzle, from the domain of a little directly connected with web programming, or rather the creation o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux demon on PHP5</h1><div class="post__text post__text-html js-mediator-article">  Good day, today I will describe a rather amusing puzzle, from the domain of a little directly connected with web programming, or rather the creation of a PHP daemon.  It is clear that the first question will be: "Why is it necessary?" Well, we will deal sequentially. <br><br><a name="habracut"></a><br>  It would seem that a rare perversion to write programs of this kind in languages ‚Äã‚Äãlike PHP, but that if there is a need to continuously monitor or process any continuous or non-regular process, and a small script is needed.  As a rule, you don‚Äôt have a competent specialist who can‚Äôt shoot through your leg with C ++ or don‚Äôt cut off your leg with C, or just a good application programmer.  In these cases, each is spinning as it may, and there appear a wide variety of chimeras and hybrids, such as scripts running with the <em>set_time_limit (0)</em> parameter, scripts starting with cron every second (yes, yes, I saw this) and other, not less crutchy things. <br><br>  Actually about the formulation of the problem.  In the process of working on a project, the need to integrate with an external program complex has emerged.  The only way to communicate with the program is to communicate by means of its own protocol through the network port, wait for the event to occur, parse the answer, process, save to the database.  It would seem difficult to write a script with an infinite loop, inside which all the necessary magic would happen and voila!  At the very beginning, I argued about the same, but it soon became clear that this approach has a significant drawback, one of which is incorrect data appearing at the time of the death of the script.  The server reboots and data remains in the database that could not be processed or deleted.  Unpleasant, very unpleasant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, let's understand, we have a classic LAMP on CentOS, third-party software and a strong desire not to fasten any other tools or ‚ÄúGod forbid to program in C‚Äù.  I thought that it would not be bad at all if the original script could be taught to recognize the signals of the operating system so that it completes its work correctly.  For those who don‚Äôt know, in general terms, Linux manages processes with signals that tell the process how it should behave.  Upon receipt of such a signal, the process must change its behavior or do nothing if it is not required for its operation.  For me personally, the SIGTERM signal is most interesting.  This signal indicates that the process should complete its work.  A list of all existing signals can be found here: <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25B3%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258B_(UNIX)">UNIX signals</a> <br><br>  There is also another feature, each process in Linux is somehow connected with the terminal from where it was launched and inherits input / output streams from it, so as soon as you close the terminal in which you started the script, it will immediately complete its execution.  In order to avoid such a situation, you need to create a child process, make it basic, finish off the parent and untie the remaining process from the input / output of the terminal in which it was running.  I agree, it sounds complicated, confusing and not clear, but in practice everything is much simpler than it looks. <br><br>  What do we need to work?  In principle, not so much, actually PHP itself, in my case this PHP5.6 and several extensions: <br><br><ul><li>  <a href="http://php.net/manual/ru/book.posix.php">POSIX extension</a> </li><li>  <a href="http://php.net/manual/ru/book.pcntl.php">Pcntl extension</a> </li></ul><br>  Now that we have everything we need, let's start writing the code. <br><br>  As mentioned above, to start our daemon, in accordance with the rules of work of similar programs in Linux, it must be untied from the terminal where it was launched. To do this, use the <em>pcntl_fork ()</em> function, it creates a child copy of the current process and returns its numeric id if successful.  And of course to finish off the parent process. <br><br><pre><code class="hljs perl">&lt;?php //    $child_pid = pcntl_fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( $child_pid ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,   ... <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }         ,      . //    ... posix_setsid();</code> </pre> <br>  Thus, the operating system will know that we are capable of determining our behavior and will place the pid of our process in a queue for receiving system signals. <br><br>  Now the most interesting thing awaits us - it is necessary to determine exactly how we will work and interact with the operating system.  I decided to bring this functionality to a separate class, just in case this code is still needed.  Let's begin, for a start it is necessary to decide what the class should be able to do. <br><br>  Receive and process operating system signals; <br>  Be able to understand whether a demon is running or not; <br>  Run the task necessary for demonization; <br>  Know when to stop; <br><br>  To implement these tasks, it is worth analyzing the functions that will be useful to us.  The <a href="http://php.net/manual/ru/function.pcntl-signal.php"><em>pcntl_signal ()</em></a> function is needed in order to assign a handler function to a signal.  Takes as arguments: the signal for which the handler is assigned and the function or method of the class responsible for processing the signal.  The <a href="http://php.net/manual/ru/function.getmypid.php"><em>getmypid ()</em></a> function, which returns the pid of the current process.  Finally, the <a href="http://php.net/manual/ru/function.posix-kill.php"><em>posix_kill ()</em></a> function, which sends a signal to the specified process, takes two arguments: the pid of the process to which the signal should be sent and the signal itself, which should be sent. <br><br>  In order to control the state of our own process, we need a flag that determines whether it is time to complete the process or not.  There is also some subtlety, in order to save CPU resources, it is necessary to make pauses, during which the application will just wait for the next iteration of the cycle, thereby not loading the system with constant requests.  You must define these parameters as class fields. <br><br><pre> <code class="hljs bash">&lt;?php class Daemon { protected <span class="hljs-variable"><span class="hljs-variable">$stop</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$sleep</span></span> = 1;        ,    : //     public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> signalHandler(<span class="hljs-variable"><span class="hljs-variable">$signo</span></span>) { switch(<span class="hljs-variable"><span class="hljs-variable">$signo</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIGTERM: //       ... <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // default: //             ... } }</code> </pre> <br>  As you can see, the method accepts a signal as an argument, which is sent to it, and depending on what signal is sent to the daemon, it performs certain actions. <br><br>  Now we need to know for sure whether our demon is running or not.  How would we do this, because the demon can be run from different terminals or several times in a row.  If several instances of the same script will try to simultaneously access the same resources, I think it will be extremely unpleasant.  To avoid this situation, we can use the old way as the world, during the execution of the program, create a file in a certain place with the program process pid recorded there and delete it every time our application closes.  Thus, by checking for the existence of this file, we can know whether there are running copies of our application.  To solve this problem, we define the method of our class. <br><br><pre> <code class="hljs bash">//       ,        ... public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> isDaemonActive(<span class="hljs-variable"><span class="hljs-variable">$pid_file</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( is_file(<span class="hljs-variable"><span class="hljs-variable">$pid_file</span></span>) ) { <span class="hljs-variable"><span class="hljs-variable">$pid</span></span> = file_get_contents(<span class="hljs-variable"><span class="hljs-variable">$pid_file</span></span>); //    ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(posix_kill(<span class="hljs-variable"><span class="hljs-variable">$pid</span></span>,0)) { //   ... <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // pid- ,   ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!unlink(<span class="hljs-variable"><span class="hljs-variable">$pid_file</span></span>)) { //    pid-. ... <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(-1); } } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Here we check all possible variants of events, whether the file exists, and if yes, what process was created, check whether such a process exists, if the process that created the file does not exist, since the process ended unexpectedly, try to delete the file. <br><br>  It's time to think, and how are we going to perform the actual operations for which everything was intended?  There are many implementation options.  In my case, it was necessary to wait for the results from the third-party service, without this data the process itself was useless and did not perform any actions on the existing data or resources, so I implemented all the processing into a function that received or did not receive data from the third-party service.  If there was no data, the function should be called until they appeared.  Thus, the class method I wrote, which implements the payload, depended on two parameters: the internal state of the daemon and the results of the work of the data processing function from the third-party service. <br><br><pre> <code class="hljs perl">//             ... public function run($func) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,   ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!$this-&gt;stop){ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ... //    ... $resp = $func(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,    ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!empty($resp)){ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } //   ,    ... }<span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(true); <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>($this-&gt;<span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>); } }</code> </pre> <br>  Thus, I have two conditionally infinite loops, an inner one, which waits until the function is executed and an outer one, which waits until the state of the daemon changes.  Nobody says that my implementation is the most correct, the implementation of the method can be overridden as convenient, not forgetting to watch whether it is time to complete the process or not. <br><br>  Now comes the climax, you need to tie it all together and run, I think it's time to write a constructor for our class. <br><br><pre> <code class="hljs bash">//          pid           ... //      ,   ... public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> __construct(<span class="hljs-variable"><span class="hljs-variable">$file</span></span> = <span class="hljs-string"><span class="hljs-string">'/tmp/daemon.pid'</span></span>,<span class="hljs-variable"><span class="hljs-variable">$sleep</span></span>=1) { //      ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;isDaemonActive(<span class="hljs-variable"><span class="hljs-variable">$file</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Daemon is already exsist!\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(0); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;sleep = <span class="hljs-variable"><span class="hljs-variable">$sleep</span></span>; //  ,       ... pcntl_signal(SIGTERM,[<span class="hljs-variable"><span class="hljs-variable">$this</span></span>,<span class="hljs-string"><span class="hljs-string">'signalHandler'</span></span>]); //  pid      getmypid()     pid ... file_put_contents(<span class="hljs-variable"><span class="hljs-variable">$file</span></span>, getmypid()); }</code> </pre> <br>  We check with the help of the file whether the process is running or not, if it is running, display the corresponding warning, set a delay, assign signal handlers (in this case only one), create a file and write our pid there, so that we know other copies of the process that we are already working.  We are done with the class. <br><br>  Now back to writing the demon script itself.  We settled on the fact that we finished all the preparations for launching the demon. <br><br><pre> <code class="hljs bash">//      ... include(__DIR__.<span class="hljs-string"><span class="hljs-string">'/Daemon.php'</span></span>); include(__DIR__.<span class="hljs-string"><span class="hljs-string">'/ExampleClass.php'</span></span>); //    ... <span class="hljs-variable"><span class="hljs-variable">$example</span></span> = new ExampleClass(); //        ,    ... //    -               ... <span class="hljs-variable"><span class="hljs-variable">$func</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() use (<span class="hljs-variable"><span class="hljs-variable">$example</span></span>){ //     ... <span class="hljs-variable"><span class="hljs-variable">$example</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; //   ,       pid... <span class="hljs-variable"><span class="hljs-variable">$daemon</span></span> = new Daemon(<span class="hljs-string"><span class="hljs-string">'/tmp/daemon.pid'</span></span>); //      -... fclose(STDIN); fclose(STDOUT); fclose(STDERR); //  -       ... <span class="hljs-variable"><span class="hljs-variable">$STDIN</span></span> = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-variable"><span class="hljs-variable">$STDOUT</span></span> = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>); <span class="hljs-variable"><span class="hljs-variable">$STDERR</span></span> = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>); //     ... <span class="hljs-variable"><span class="hljs-variable">$daemon</span></span>-&gt;run(<span class="hljs-variable"><span class="hljs-variable">$func</span></span>);</code> </pre> <br>  We connect all the libraries we need, including the file with our Daemon.php class, describe the function that will perform the payload, create an instance of the Daemon class with the parameters we need, untie the standard I / O from the current terminal and redirect them in / dev / null (if we would have done it earlier, we would have risked not seeing error messages during the script execution), passing the daemon class to the run method, our function, which will be executed by the daemon. <br><br>  That's all.  Our daemon works and communicates perfectly with the OS.  All good and good luck. <br><br>  PS The source codes for the daemon are available here: <a href="https://github.com/Liar233/php-daemon/">https://github.com/Liar233/php-daemon/</a> . <br></div><p>Source: <a href="https://habr.com/ru/post/276709/">https://habr.com/ru/post/276709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276697/index.html">Hacker Christmas Tree, or How to spend Children's Day in a non-children's company</a></li>
<li><a href="../276699/index.html">Experience lectures on the introduction of design patterns</a></li>
<li><a href="../276701/index.html">Meeting with Eugene Burmaco: Macros in Scala</a></li>
<li><a href="../276705/index.html">Testing and graph theory: installer</a></li>
<li><a href="../276707/index.html">Analysis of user and developer activity</a></li>
<li><a href="../276711/index.html">SQLite Query Profiling for Qt Applications</a></li>
<li><a href="../276715/index.html">3CX SBC - now with encryption and resiliency</a></li>
<li><a href="../276719/index.html">java.net.URL or the old horse will not spoil the furrow</a></li>
<li><a href="../276723/index.html">View the source (almost) total</a></li>
<li><a href="../276725/index.html">Monitoring Task Execution in IPython Notebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>