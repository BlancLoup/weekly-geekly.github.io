<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write (unedited) Haskell interpreter with alex and happy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! In this article, we will look at how to do-it-yourself a (unedited) Haskell interpreter. Interested please under the cat! 

 Once I got the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write (unedited) Haskell interpreter with alex and happy</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  In this article, we will look at how to do-it-yourself a (unedited) Haskell interpreter.  Interested please under the cat! <br><br>  Once I got the idea to write my own interpreter, moreover on Haskell.  Writing it from scratch is not a job for the faint of heart, and why, if everything is already written for this by other, (possibly) more experienced people! <br><a name="habracut"></a><br><h3>  Step 1: the wording of the TOR to themselves </h3><br>  Our (un) interpreter will work like this: <br><br> <code>let a = 2 in a*2 <br> 4 <br> let a = 8 in (let b = a - 1 in a*b) <br> 56 <br></code> <br>  Only let-in, only Int, from operations: addition, subtraction, multiplication, division (integer).  Go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Step 2: alex </h3><br>  The first thing we need is a lexer (a program that will divide the code into parts ‚Äî tokens).  Those who wrote their translators on the great and mighty C probably remembered flex - the great and mighty lexer generator.  We will use an equally great and mighty alex - also a lexer generator, but for Haskell.  Download alex <a href="https://www.haskell.org/alex/">from here</a> or <br><br> <code>$ sudo apt-get install alex</code> <br> <br>  then open your favorite text editor and write: <br><br><pre> <code class="haskell hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Lex <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> } %wrapper <span class="hljs-string"><span class="hljs-string">"basic"</span></span> $digit = <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span> $alpha = [a-zA-<span class="hljs-type"><span class="hljs-type">Z</span></span>] tokens :- $white ; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { \s -&gt; <span class="hljs-type"><span class="hljs-type">TLet</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { \s -&gt; <span class="hljs-type"><span class="hljs-type">TIn</span></span> } $digit+ { \s -&gt; <span class="hljs-type"><span class="hljs-type">TNum</span></span> (read s)} [\=\+\-\*\/\(\)] { \s -&gt; <span class="hljs-type"><span class="hljs-type">TSym</span></span> (head s)} $alpha [$alpha $digit \_ \']* { \s -&gt; <span class="hljs-type"><span class="hljs-type">TVar</span></span> s} { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Token</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TLet</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TIn</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TNum</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSym</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br>  Scary. <br><br>  In fact, everything is simple.  First we declare the Lex module (the code in curly brackets is pure Haskell), then we say that we want to use the basic wrapper, that is, without any frills - cheap and angry, then the definitions of character sets (charsets) go - the name of the charset should begin with $, the value is (almost) a regular expression.  $ digit is all numbers, $ alpha is all letters.  Now the most important thing is tokens.  after: - their definitions should go, the regular expression on the left, the token on the right.  We ignore spaces (on the left is a charset for whitespace, a semicolon on the right), let is TLet token, in - TIn, one or more digits - TNum, all sorts of pluses and minuses - TSym, letters, underscore and '- TVar.  Further we see that all the scary words on the letter T are values ‚Äã‚Äãof the type Token - nothing complicated. <br><br>  Now is the time of magic. <br><br>  Save the file as Lex.x, then <br><br> <code>$ alex Lex.x</code> <br> <br>  Done!  Unas is a module of our lexer - Lex.hs! <br><br><h3>  Step 3: happy </h3><br>  Now we need a parser generator - happy.  Its counterparts for C are bison and yacc.  Download it <a href="https://www.haskell.org/happy/">from here</a> or <br><br> <code>$ sudo apt-get install happy</code> <br> <br>  Create the file Synt.y <br><br><pre> <code class="haskell hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Synt <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lex } %name synt %tokentype { Token } %error { parseError } %token let { TLet } in { TIn } num { TNum $$ } var { TVar $$ } '=' { TSym '=' } '+' { TSym '+' } '-' { TSym '-' } '*' { TSym '*' } '/' { TSym '/' } '(' { <span class="hljs-type"><span class="hljs-type">TSym</span></span> '(' } ')' { TSym ')' } %% Exp: let var '=' Exp in Exp { Let $2 $4 $6 } | Exp1 { Exp1 $1 } Exp1: Exp1 '+' Term { Plus $1 $3 } | Exp1 '-' Term { Minus $1 $3 } | Term { Term $1 } Term: Term '*' Factor { Mul $1 $3 } | Term '/' Factor { Div $1 $3 } | Factor { Factor $1 } Factor: num { Num $1 } | var { Var $1 } | '(' <span class="hljs-type"><span class="hljs-type">Exp</span></span> ')' { Brack $2 } { parseError :: [Token] -&gt; a parseError _ = error "Parse error" data Exp = Let String Exp Exp | Exp1 Exp1 deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Exp1 = Plus Exp1 Term | Minus Exp1 Term | Term Term deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Term = Mul Term Factor | Div Term Factor | Factor Factor deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Factor = Num Int | Var String | Brack Exp deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) }</code> </pre><br>  More scary. <br><br>  Here, too, the Haskell code is taken in curly brackets, so first we declare the Synt module, then import Lex (we need the Token type from there).  "% name synt" means that our parser function will be called synt, "% tokentype {Token}" - that we use the type Token as the type of tokens <s>would never have guessed</s> , "% error {parseError}" sets the function that will be handle errors. <br><br>  Next come the matching tokens for their pseudonyms.  But now it will be scary.  We say that expression (Exp) is let variable = expression in expression or subexpression (Exp1).  In the first case, you need to create a Let construct (its type is Exp, see the declaration below), and take the second, fourth, and sixth words (i.e. var, Exp and Exp) as arguments, and in the second case, create the Exp1 construct with the first word as an argument.  Exp1 can be an addition or subtraction operation with the first and third words as arguments or Term.  Term is similar, but for addition and multiplication operations.  The reader will ask: ‚ÄúWhy break into two types, is it really impossible to stuff multiplication and division in Exp1?‚Äù The fact is that the work of the parser is to build a so-called ‚Äúparsing tree‚Äù.  The most deeply nested operations are performed first.  Term will be deeper than Exp1, so multiplication operations will be performed earlier than additions!  Factor, in turn, can be a number, a variable or an expression in parentheses - again for the order of actions.  Next, we declare the parseError function to "handle" errors and all data types like Exp or Factor. <br><br>  That's it, the parser is ready! <br><br> <code>$ happy Synt.y</code> <br> <br>  Now we have a file Synt.hs <br><br><h3>  Last spurt: the interpreter </h3><br>  The interpreter code is presented below: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Map <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Synt newtype Context = Context {getContext :: M.Map String Int} deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) pull :: Maybe a -&gt; a pull (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span>) = m pull Nothing = error "Undefined variable" createContext :: Context createContext = Context {getContext = M.empty} getValue :: Context -&gt; String -&gt; Maybe Int getValue ctx name = M.lookup name $ getContext ctx solveExp :: Context -&gt; Exp -&gt; Maybe Int solveExp ctx exp = case exp of (<span class="hljs-type"><span class="hljs-type">Let</span></span> <span class="hljs-title"><span class="hljs-title">name</span></span> <span class="hljs-title"><span class="hljs-title">expl</span></span> <span class="hljs-title"><span class="hljs-title">rexp</span></span>) -&gt; solveExp newCtx rexp where newCtx = Context {getContext = M.insert name (<span class="hljs-title"><span class="hljs-title">pull</span></span> (<span class="hljs-title"><span class="hljs-title">solveExp</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">expl</span></span>)) (<span class="hljs-title"><span class="hljs-title">getContext</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span>)} (<span class="hljs-type"><span class="hljs-type">Exp1</span></span> <span class="hljs-title"><span class="hljs-title">exp1</span></span>) -&gt; solveExp1 ctx exp1 solveExp1 :: Context -&gt; Exp1 -&gt; Maybe Int solveExp1 ctx exp1 = case exp1 of (<span class="hljs-type"><span class="hljs-type">Plus</span></span> <span class="hljs-title"><span class="hljs-title">lexp1</span></span> <span class="hljs-title"><span class="hljs-title">rterm</span></span>) -&gt; (+) &lt;$&gt; (<span class="hljs-title"><span class="hljs-title">solveExp1</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">lexp1</span></span>) &lt;*&gt; (<span class="hljs-title"><span class="hljs-title">solveTerm</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">rterm</span></span>) (<span class="hljs-type"><span class="hljs-type">Minus</span></span> <span class="hljs-title"><span class="hljs-title">lexp1</span></span> <span class="hljs-title"><span class="hljs-title">rterm</span></span>) -&gt; (-) &lt;$&gt; (<span class="hljs-title"><span class="hljs-title">solveExp1</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">lexp1</span></span>) &lt;*&gt; (<span class="hljs-title"><span class="hljs-title">solveTerm</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">rterm</span></span>) (<span class="hljs-type"><span class="hljs-type">Term</span></span> <span class="hljs-title"><span class="hljs-title">term</span></span>) -&gt; solveTerm ctx term solveTerm :: Context -&gt; Term -&gt; Maybe Int solveTerm ctx term = case term of (<span class="hljs-type"><span class="hljs-type">Mul</span></span> <span class="hljs-title"><span class="hljs-title">lterm</span></span> <span class="hljs-title"><span class="hljs-title">rfactor</span></span>) -&gt; (*) &lt;$&gt; (<span class="hljs-title"><span class="hljs-title">solveTerm</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">lterm</span></span>) &lt;*&gt; (<span class="hljs-title"><span class="hljs-title">solveFactor</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">rfactor</span></span>) (<span class="hljs-type"><span class="hljs-type">Div</span></span> <span class="hljs-title"><span class="hljs-title">lterm</span></span> <span class="hljs-title"><span class="hljs-title">rfactor</span></span>) -&gt; (<span class="hljs-title"><span class="hljs-title">div</span></span>) &lt;$&gt; (<span class="hljs-title"><span class="hljs-title">solveTerm</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">lterm</span></span>) &lt;*&gt; (<span class="hljs-title"><span class="hljs-title">solveFactor</span></span> <span class="hljs-title"><span class="hljs-title">ctx</span></span> <span class="hljs-title"><span class="hljs-title">rfactor</span></span>) (<span class="hljs-type"><span class="hljs-type">Factor</span></span> <span class="hljs-title"><span class="hljs-title">factor</span></span>) -&gt; solveFactor ctx factor solveFactor :: Context -&gt; Factor -&gt; Maybe Int solveFactor ctx factor = case factor of (<span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) (<span class="hljs-type"><span class="hljs-type">Var</span></span> <span class="hljs-title"><span class="hljs-title">s</span></span>) -&gt; getValue ctx s (<span class="hljs-type"><span class="hljs-type">Brack</span></span> <span class="hljs-title"><span class="hljs-title">exp</span></span>) -&gt; solveExp ctx exp main = do s &lt;- getContents mapM putStrLn $ (<span class="hljs-title"><span class="hljs-title">map</span></span> (<span class="hljs-title"><span class="hljs-title">show</span></span> . <span class="hljs-title"><span class="hljs-title">pull</span></span> . (<span class="hljs-title"><span class="hljs-title">solveExp</span></span> <span class="hljs-title"><span class="hljs-title">createContext</span></span>) . synt . alexScanTokens) . lines) s</code> </pre><br>  Here we declare a Context type that contains an associative array (Map) with variable names and their values, a pull function that returns the value of a variable, if it exists, otherwise it raises an error.  The createContext function simply creates an empty context, getValue looks for the value of a variable in the context.  Now the fun part!  To understand what is happening here, imagine that the line of our code is: <br><br> <code>8</code> <br> <br>  Then the parsing tree will be like this: <br><br> <code>let res = Exp (Exp1 (Term (Num 8)))</code> <br> <br>  and the result (i.e. 8) will be after <br><br> <code>((solveFactor ctx) &lt;- (solveTerm ctx) &lt;- (solveExp1 ctx) &lt;- (solveExp ctx)) res</code> <br> <br>  This is not Haskell code, but a scheme: solveExp will pass res solveExp1, etc. <br>  ctx here is just a context. <br><br>  That is, the work of the solveExp function is that if the input let-in construct adds a variable to the context and evaluates Exp after in, if it is otherwise just calculate Exp1. <br>  The function solveExp1 adds or subtracts, solveTerm multiplies and divides.  solveFactor gets the values ‚Äã‚Äãof variables, returns numbers, and if Exp goes in brackets to it, then solveExp passes it <s>(not again, but again)</s> . <br><br>  The main function takes stdin strings to EOF, splits them into a list of strings, allocates tokens (alexScanTokens) into each, passes through the parser (synt), calculates the value of the expression (solveExp) with an empty context (createContext), and makes from Maybe Int Int, and then String, and then displays the result. <br><br>  Everything!  Now everything is exactly!  We compile everything, and our interpreter is ready!  Feedback, comments, suggestions - please in the comments. </div><p>Source: <a href="https://habr.com/ru/post/335366/">https://habr.com/ru/post/335366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335354/index.html">As I wrote a mobile application on react-native</a></li>
<li><a href="../335356/index.html">How do we help for Renga</a></li>
<li><a href="../335360/index.html">Investigation of compliance of online stores with Law 152 of the Federal Law "On Personal Data"</a></li>
<li><a href="../335362/index.html">The history of trade cash registers</a></li>
<li><a href="../335364/index.html">Why am I still using Vim?</a></li>
<li><a href="../335368/index.html">DevOps is not a technology issue. DevOps is a business issue. (transfer)</a></li>
<li><a href="../335370/index.html">How to # developer go to Unity</a></li>
<li><a href="../335372/index.html">Development of an application interface for lifelong use on the example of a mobile diabetes diary</a></li>
<li><a href="../335376/index.html">Programming Contest: JSDash (Intermediate Results 3)</a></li>
<li><a href="../335378/index.html">RailsClub 2017: Interview with Anton Davydov. It is important not to stop and offer conceptually new solutions.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>