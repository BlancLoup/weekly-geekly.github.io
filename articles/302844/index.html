<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prepare a simple blog on microservices, write your microframe in php and run everything on Docker with examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="But what if I tell you that a new product can immediately begin to write on microservice architecture, and not engage in the cutting of a monolith? Is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prepare a simple blog on microservices, write your microframe in php and run everything on Docker with examples</h1><div class="post__text post__text-html js-mediator-article"><p>  But what if I tell you that a new product can immediately begin to write on microservice architecture, and not engage in the cutting of a monolith?  Is this generally normal?  Conveniently?  Want to know the answer? </p><br><p>  Task: you need to write for the weekend (time limited to 10-15 hours) spherical blog on microservices, in php, without using any frameworks.  You can use common sense.  And let's forget about what the frontend is and remember that we cannot live without virtualization.  Choose a Docker.  Interesting?  Forward under the cat. </p><br><img src="https://habrastorage.org/files/f7f/b56/6a3/f7fb566a3f724874bf53cdb8e3b37d7a.jpg" alt="image"><br><a name="habracut"></a><br><h2>  Microservices </h2><br><p>  If you are interested in a microservice approach, but you don‚Äôt know where to start, start with Sam Newman‚Äôs book Building Microservices.  I will try to describe a little the main points of this approach, if you have any additions, please write in the comments.  And in general, for any reason to write, I do not claim the truth of any of the approaches described below, especially in your particular case. </p><br><p>  We will consider everything on the example of the above blog.  Of course, this is a task for the sake of the task, but I would like to note that even in this version, it will work and will work well (quickly and without problems). </p><br><p>  The essence of microservices is easy to understand in comparison with the monolithic architecture.  What does a regular blog engine look like?  Roughly speaking, this is just one application.  Work with articles, comments, pages, users and other functional units is enclosed in a single package of source code, which is not divided in any way. </p><br><img src="https://habrastorage.org/files/2ab/12f/727/2ab12f727bf64c26a88ec978a2901ca4.png"><br><p>  Where all the connections between components are calls within the code, some kind of relationships between classes, patterns, etc.  or even just govnokod, if you can not separate one from another. </p><br><p>  What will our blog look like?  Yes, about the same, to be honest. </p><br><img src="https://habrastorage.org/files/d70/fa5/f0b/d70fa5f0b7bc4dd4b62bee66d51f30b3.png"><br><p>  The only difference is that the squares with components are no longer components enclosed in the code of one application, but the arrows are no longer system calls to classes within this code.  Now - these are separate components, and arrows - the usual requests for http. </p><br><p>  Why do you need it?  We will immediately determine that probably not everyone needs this.  This should be very convenient if you are a large enough company capable of allocating a development team for each service.  I think even medium-sized companies, if you select a person for each service, it will be good too.  However, even if you are alone for the whole company, you can find something interesting in microservices. </p><br><p>  How big should the service be?  Borders are difficult to carry out, the error will cost you dearly, but, in short, service is a certain unit of your system that you can completely rewrite in a short time.  Empirically let the week you or your team should cope with the service.  The main idea here - services should be small.  They should not be turned into a pile of monoliths. </p><br><p>  So, the positive things that I was able to highlight for myself, in general, they all pass under the same trend: Incredible convenience for development: </p><br><ul><li>  Fault tolerance.  Since the connections between the services are no longer rigid, the service may die due to someone‚Äôs stupidity (for example, the comment service), but on the whole it will have no effect on the blog, except that comments are lost. </li><li>  Tongue.  You can develop a new service on anything.  In general, the choice of language ceases to resemble the search for a silver bullet, for each component of the system you can choose the tool that suits it the most at the current time.  Why?  Because it is no longer expensive for a company (service is small), you can always roll out the old service back, you can even use the same services written in different languages ‚Äã‚Äãat the same time to understand what is best.  The cost of error is immeasurably less. </li><li>  Scalability.  Does the application slow down and fail?  Need a huge new server for the entire application, and better than 10?  Forget it.  Now you can scale services.  Just add more services :) </li><li>  In general, high speed, as a result of all that higher. </li></ul><br><p>  What should be able to our application?  So it is not very much. <br>  Four pages: </p><br><ul><li>  List of posts </li><li>  Open post with comments </li><li>  Add post </li><li>  Authorization </li></ul><br><p>  The functional is simple: </p><br><ul><li>  An authorized user can add a post. </li><li>  Anyone can comment on it. </li></ul><br><h2>  Docker </h2><br><img src="https://habrastorage.org/files/743/e1a/9b0/743e1a9b0777466d87d636ba86d11220.png"><br><p>  Everything, we will not be more about the theory, let's saw application.  We will have it on docker.  It is almost impossible to develop such a distributed application on a single machine without virtualization.  The job description of the docker will be represented by scraps, since it goes beyond the topic of this article.  It is assumed that you know something about him. </p><br><p>  By the way, here is a link to a turnip from which you can download and start a blog, see something by the code below.  <a href="https://github.com/gregory-vc/blog">https://github.com/gregory-vc/blog</a> </p><br><p>  How many containers will there be in our simplest blog?  A container is, by the way, essentially a virtualization of a separate server that communicates over the network with other containers, though if you carry out a hard analogy container = server, some containers will have to be abandoned, but nonetheless.  For the simplest implementation of a blog on microservices, I counted 24 containers.  Let's get a look. </p><br><ul><li>  Common containers: base for authorization service, main blog base, radish. </li><li>  Service Gateway: php, source code container, nginx. </li><li>  Service for work with posts: (php, source code container, nginx) x 2 </li><li>  Service for work with comments: also x 2 </li><li>  Authorization and authentication service: also x 2 </li></ul><br><p>  Why on two copies of some services?  Because one will not be interesting and not clear. </p><br><p>  The docker-compose file that will deploy all of this with one command looks like this: <br>  <a href="">https://github.com/gregory-vc/blog/blob/master/host/docker-compose.yml</a> <br>  From the most interesting, let's consider the php container settings of our gateway. </p><br><pre><code class="hljs mel"><span class="hljs-string"><span class="hljs-string">'php_gate'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: <span class="hljs-string"><span class="hljs-string">'tattoor/blog_php'</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'php_gate'</span></span> volumes_from: [<span class="hljs-string"><span class="hljs-string">'source_gate'</span></span>] volumes: [<span class="hljs-string"><span class="hljs-string">'./logs/php/gate/:/var/log/dev_php'</span></span>] links: - nginx_post_1:post1.blog - nginx_post_2:post2.blog - nginx_comment_1:comment1.blog - nginx_comment_2:comment2.blog - nginx_auth_1:auth1.blog - nginx_auth_2:auth2.blog - redis environment: - POST_1_HOST=post1.blog - POST_1_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span> - POST_2_HOST=post2.blog - POST_2_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span> - COMMENT_1_HOST=comment1.blog - COMMENT_1_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span> - COMMENT_2_HOST=comment2.blog - COMMENT_2_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span> - AUTH_1_HOST=auth1.blog - AUTH_1_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span> - AUTH_2_HOST=auth2.blog - AUTH_2_PORT=<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  The links container description section is basically just editing / etc / hosts / </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> exec php_gate cat /etc/hosts <span class="hljs-number"><span class="hljs-number">172.17.0.36</span></span> auth1.blog 86b8b266477d nginx_auth_1 <span class="hljs-number"><span class="hljs-number">172.17.0.36</span></span> nginx_auth_1 86b8b266477d <span class="hljs-number"><span class="hljs-number">172.17.0.21</span></span> comment1.blog 836bacb42e78 nginx_comment_1 <span class="hljs-number"><span class="hljs-number">172.17.0.19</span></span> comment2.blog c554a8888801 nginx_comment_2 <span class="hljs-number"><span class="hljs-number">172.17.0.20</span></span> post2.blog 37f81921419c nginx_post_2 <span class="hljs-number"><span class="hljs-number">172.17.0.7</span></span> redis a1932016be87 <span class="hljs-number"><span class="hljs-number">172.17.0.37</span></span> auth2.blog 5715045a213b nginx_auth_2 <span class="hljs-number"><span class="hljs-number">172.17.0.37</span></span> nginx_auth_2 5715045a213b <span class="hljs-number"><span class="hljs-number">172.17.0.21</span></span> nginx_comment_1 836bacb42e78 <span class="hljs-number"><span class="hljs-number">172.17.0.19</span></span> nginx_comment_2 c554a8888801 <span class="hljs-number"><span class="hljs-number">172.17.0.22</span></span> nginx_post_1 1cc1ef5ab896 <span class="hljs-number"><span class="hljs-number">172.17.0.22</span></span> post1.blog 1cc1ef5ab896 nginx_post_1 <span class="hljs-number"><span class="hljs-number">172.17.0.20</span></span> nginx_post_2 37f81921419c <span class="hljs-number"><span class="hljs-number">172.17.0.23</span></span> fafe93f31a67</code> </pre> <br><p>  Where at the designated host we simply have access to another container through the internal network of the docker. </p><br><p>  And the environment section is just a designation of variables that we can get with you inside the application via getenv ().  It is designed so that the docker-compose file is a single entry point to configure the entire application. </p><br><p>  While the structure of our services looks like simple directories lying nearby, </p><br><ul><li>  Auth </li><li>  Comment </li><li>  Gate </li><li>  Post </li></ul><br><p>  But, in fact, when you start the docker of hosts, each of these directories is inside a separate isolated container.  This is done somehow like this: </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'source_post_1'</span></span>: volumes: [<span class="hljs-string"><span class="hljs-string">'../Services/Post:/home/gregory/source/'</span></span>]</code> </pre> <br><p>  That is, even though they are now nearby, it will not be possible to incline the class of another service or something like that from one service at startup.  Nearby they are exclusively from convenience, in real life they should be each in their repository, not touching each other at all. </p><br><h2>  Gate service </h2><br><img src="https://habrastorage.org/files/ad9/8a0/05c/ad98a005c1f947f3850acf98ee5e3e52.png"><br><p>  This service will be the entry point to our blog, it is he who will render the templates, display the result and pull the services he needs.  By the way, there are different approaches, for example, you can refuse a single entry point and implement everything on the frontend.  That is, the browser itself will go to the necessary services and collect the result directly in the browser.  What can I say, it all depends on your particular case, and there and there are pros and cons. </p><br><p>  So, we have php and nothing else.  Although, let's take at least composer, where without it.  Create two more directories, one with our microframe, which we now write, the second for public scripts, js, and other resources. </p><br><p>  Looks like that: </p><br><ul><li>  My </li><li>  public </li><li>  composer.json </li></ul><br><p>  In the composer, just specify where to do autoload, so that we don‚Äôt bother with this, and connect the generated autoload to public / index.php </p><br><p>  So, we already have something, let's decide what else we need? </p><br><ul><li>  MVC, which means controllers </li><li>  Place for business logic </li><li>  Templates </li><li>  Template engine </li></ul><br><p>  Not bad, what else? </p><br><ul><li>  A little di, the simplest, in the form of storage facilities. </li><li>  Self storage </li><li>  Request </li><li>  Answer </li><li>  Routing, oh yeah, you should start with it. </li><li>  Sessions and stuff on the little things. </li></ul><br><p>  Let's write here such a repository of objects so as not to create them anywhere, but to be able to access (inject) the applications already created at any point with all the necessary dependencies (dependency).  We will not be entertained with Reflection and other interesting things, our time is strictly limited. </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'Request'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Request()); <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'Router'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Router()); <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'Redirect'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Redirect()); <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> App());</code> </pre> <br><p>  In Di, using this storage we simply add all the objects that we need. <br>  In public, we start Di, we get a router, we register all URLs that will be useful to us, we get the application and start it. </p><br><pre> <code class="hljs php"> $router-&gt;get(<span class="hljs-string"><span class="hljs-string">'/logout/'</span></span>, <span class="hljs-string"><span class="hljs-string">'AuthController@logout'</span></span>); $router-&gt;get(<span class="hljs-string"><span class="hljs-string">'/404'</span></span>, <span class="hljs-string"><span class="hljs-string">'SystemController@notFound'</span></span>); $router-&gt;post(<span class="hljs-string"><span class="hljs-string">'/post/add_request/'</span></span>, <span class="hljs-string"><span class="hljs-string">'PostController@add'</span></span>)</code> </pre> <br><p>  In the application we get the request, the map in the router is the existing action of the existing controller for this request, at the same time we also write to the request all the post or het variables that came to us. </p><br><p>  Execute the controller method, get the response, render the response and show the result of our work, that's all. </p><br><pre> <code class="hljs php"> $current_request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;router-&gt;getCurrent(); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $current_request-&gt;controller; $response = $controller-&gt;{$current_request-&gt;method}(); $response-&gt;render();</code> </pre> <br><p>  The framework is there, now we need to work with services, create a directory with services, create a class for each service, describe access points to each of the services.  We inherit them from the main class of services, where we implement query options. </p><br><p>  <a href="https://github.com/gregory-vc/blog/blob/master/Services/Gate/My/Engine/Service.php">https://github.com/gregory-vc/blog/blob/master/Services/Gate/My/Engine/Service.php</a> </p><br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($method, $params = [])</span></span></span><span class="hljs-function"> </span></span>{ $service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $service-&gt;executeGet($method, $params); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($method, $params = [])</span></span></span><span class="hljs-function"> </span></span>{ $service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $service-&gt;executePost($method, $params); }</code> </pre> <br><p>  There at the request we select a random connector from the service provided, something like that </p><br><pre> <code class="hljs perl"> $rand_connector = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, $count_connector) % $count_connector;</code> </pre> <br><p>  Make a request from the controller and render it like this: </p><br><pre> <code class="hljs php"> $posts = Post::get(<span class="hljs-string"><span class="hljs-string">'all'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;response-&gt;html(<span class="hljs-string"><span class="hljs-string">'posts'</span></span>, $posts);</code> </pre> <br><p>  We need to render, but how?  We have no template engines.  Write your own?  Well no.  Just use php. </p><br><pre> <code class="hljs php"> ob_start(); <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span>($layout_template); $contents = ob_get_contents(); ob_end_clean(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;content = $contents;</code> </pre> <br><p>  Extremely powerful template engine the size of 4 lines. </p><br><h2>  Post and comment service </h2><br><p>  What's next?  Now we can make inquiries and render the result, now we need to write services giving the answer.  Everything is just copying our new engine to other services, changing urls and writing work with models and databases, instead of remote services. </p><br><p>  Implement working with models, standard findAll, findBy, add, save: <br>  <a href="https://github.com/gregory-vc/blog/blob/master/Services/Auth/My/Engine/Model.php">https://github.com/gregory-vc/blog/blob/master/Services/Auth/My/Engine/Model.php</a> </p><br><p>  So?  To be honest, this is almost all that we need, not counting authorization. <br>  We can make gate requests for any service, from any other service to any other. </p><br><p>  Authorization service <br>  The scheme is simple: we have users and their access on the authorization server, we make an authorization request from the gateway, generate a token, return it to the gateway and another user, put the user and the token into the session and that's it.  Unforgettable to send a token with a request to add a post, because what?  That's right, the service of the posts will go to the authorization service and ask, is it true that this token is good?  Depending on the result, different generators are generated. </p><br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($user, $password)</span></span></span><span class="hljs-function"> </span></span>{ $hash = hash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, $password); $user = User::findBy([ <span class="hljs-string"><span class="hljs-string">'login'</span></span> =&gt; $user, <span class="hljs-string"><span class="hljs-string">'password'</span></span> =&gt; $hash ]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($user) &amp;&amp; is_array($user)) { $user = current($user); $user[<span class="hljs-string"><span class="hljs-string">'token'</span></span>] = bin2hex(random_bytes(<span class="hljs-number"><span class="hljs-number">30</span></span>)); User::save($user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'login'</span></span> =&gt; $user[<span class="hljs-string"><span class="hljs-string">'login'</span></span>], <span class="hljs-string"><span class="hljs-string">'token'</span></span> =&gt; $user[<span class="hljs-string"><span class="hljs-string">'token'</span></span>] ]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">'Not found user'</span></span>); } }</code> </pre> <br><h2>  Result </h2><br><p>  In general, you can download and deploy it in one command, remind the repository: <a href="https://github.com/gregory-vc/blog">https://github.com/gregory-vc/blog</a> </p><br><p>  Where appropriate in meaning, I brought out for clarity which particular node was generated by one or another block. </p><br><p>  I was also impressed by the time of page generation.  This is 5-9 ms for a page with a post and a few comments (!).  Yes, all this is biased, yes, all this is parrots, yes, microservices have nothing to do with it, yes, depending on what to compare.  But.  The same laravel generates its page, generally without requests and data, just a greeting, in 90 ms, on my own machine.  It is 10-20 times longer. </p><br><p>  I understand what is happening there much more than anything else, do not compare, but nevertheless, I will try to express the thought: for the concrete task of a separate isolated microservice it is not necessary for all this.  For service comments, I threw out the class of work with services on the network.  For the gateway service, I threw out the base work class.  For each service I collected only what he needed.  And the right service should be quite a bit :) </p><br><p>  And the main thing is the incredible potential for scaling this blog for unbelievable loads.  No one will interfere, for example, then take and rewrite the comment service on Go. </p><br><h2>  Problems </h2><br><p>  Network overhead <br>  Not knowing how another service works, we can completely get into a situation where it is not that it works poorly and spoils everything, it also uses our service (!) So that we can give our results. </p><br><p>  Let me remind you how to try it all </p><br><pre> <code class="hljs sql">Clone git clone https://github.com/gregory-vc/blog.git . <span class="hljs-keyword"><span class="hljs-keyword">Install</span></span> Docker: wget -qO- https://get.docker.com/ | sh sudo usermod -aG docker <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> python-pip sudo pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> docker-compose Compile chmod <span class="hljs-number"><span class="hljs-number">744</span></span> compile ./compile chmod <span class="hljs-number"><span class="hljs-number">744</span></span> upload_db ./upload_db Run <span class="hljs-keyword"><span class="hljs-keyword">http</span></span>://gate.blog:<span class="hljs-number"><span class="hljs-number">30001</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span></code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302844/">https://habr.com/ru/post/302844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302834/index.html">Multiplayer in fast games (Part III: the appearance of the enemy)</a></li>
<li><a href="../302836/index.html">Another major fraud using payment cards</a></li>
<li><a href="../302838/index.html">Lab penetration testing v.9: nothing is impossible</a></li>
<li><a href="../302840/index.html">Install and configure Collectd to collect and send data to Graphite (Grafana)</a></li>
<li><a href="../302842/index.html">How Microsoft implemented Yammer (Part II)</a></li>
<li><a href="../302846/index.html">Deploy Wordpress to VPS with Windows Server 2012. Step-by-Step Guide</a></li>
<li><a href="../302848/index.html">Features console indie development in the Russian province</a></li>
<li><a href="../302852/index.html">Tony Robbins seminar review ‚ÄúFree your inner strength‚Äù. Day 3: Go ahead to your new life (part 1)</a></li>
<li><a href="../302856/index.html">The future of browsers and artificial intelligence. Zen in Yandex Browser</a></li>
<li><a href="../302860/index.html">Create arkanoid in pure javascript from scratch. CANVAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>