<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generators of discretely distributed random variables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the post Generators of continuously distributed random variables . This chapter takes into account that all the theo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generators of discretely distributed random variables</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the post <a href="http://habrahabr.ru/post/263993/">Generators of continuously distributed random variables</a> .  This chapter takes into account that all the theorems from the previous article have already been proved and the generators mentioned in it have already been implemented.  As before, we have a certain basic generator of natural numbers from 0 to RAND_MAX: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BasicRandGenerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> randomVariable; <span class="hljs-comment"><span class="hljs-comment">// some magic here ... return randomVariable; }</span></span></code> </pre> <br>  With discrete values, everything is more intuitive.  The distribution function of a discrete random variable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/99e/65a/4a5/99e65a4a51ed4235aa4e234029198627.png"></div><br>  Despite the simplicity of the distribution of discrete random variables, it is sometimes more difficult to generate them, rather than continuous ones.  We begin, as last time, with a trivial example. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <font color="#089">Bernoulli distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/594/995/aef/594995aef57c42a597c5c2770afcf282.png"></div><br><img src="https://habrastorage.org/files/792/3a5/cb7/7923a5cb7e36429cacaad61739956285.png"><br><a name="habracut"></a><br>  Perhaps the fastest of the obvious ways to generate a random variable with a Bernoulli distribution is to do it in a similar way (all generators return double only for the unity of the interface): <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setup(<span class="hljs-type"><span class="hljs-type">double</span></span> p) { unsigned long long boundary = (<span class="hljs-number"><span class="hljs-number">1</span></span> - p) * RAND_MAX; // we <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">large</span></span> sampling } <span class="hljs-type"><span class="hljs-type">double</span></span> Bernoulli(<span class="hljs-type"><span class="hljs-type">double</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BasicRandGenerator() &gt; boundary; }</code> </pre><br>  Sometimes you can do it faster.  ‚ÄúSometimes‚Äù means ‚Äúin the case in which the parameter p is a power 1/2‚Äù.  The fact is that if the integer returned by the BasicRandGenerator () function is a uniformly distributed random variable, then every bit of it is equally distributed.  This means that in the binary representation the number consists of bits distributed across Bernoulli.  Since in these articles the base generator function returns unsigned long long, we have 64 bits.  Here is a trick you can turn for p = 1/2: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bernoulli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> maxDecimals = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> decimals = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> X = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decimals == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/// refresh decimals = maxDecimals; X = BasicRandGenerator(); } else { --decimals; X &gt;&gt;= 1; } return X &amp; 1; }</span></span></code> </pre><br>  If the operation time of the BasicRandGenerator () function is not sufficiently small, and cryptostability and the size of the generator period can be neglected, then for such cases there is an algorithm using only one uniformly distributed random variable for any sample size from the Bernoulli distribution: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> setup(double p) { <span class="hljs-attribute"><span class="hljs-attribute">q</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - p; <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-attribute"><span class="hljs-attribute">double</span></span> Bernoulli(double p) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (U &gt; q) { <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> -= q; <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> /= p; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> /= q; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Why does this algorithm work?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/b58/624/591/b5862459180b4fd197b65e5b78d7f2b3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f96/acd/832/f96acd832ac2415db05edab4eef37014.png"></div><br></div></div><br><br><h4>  <font color="#089">Uniform distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bfb/a14/4df/bfba144dfaee41ffb3548a43afbf87c6.png"></div><br><img src="https://habrastorage.org/files/424/7d1/6f8/4247d16f823c4a12bd6b16409cf41c30.png"><br><br>  I am sure that any of you will remember that his first random integer generator from a to b looked like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UniformDiscrete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + rand() % (b - a + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Well, and this is quite the right decision.  With the only and not always correct assumption - you have a good basic generator.  If it is defective like the old C-shny rand (), then you will get an even number for an odd number each time.  If you do not trust your generator, then write this way: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UniformDiscrete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + round(BasicRandGenerator() * (b - a) / RAND_MAX); }</code> </pre><br>  It should also be noted that the distribution will not be completely even if RAND_MAX is not divided by the length of the interval b - a + 1 completely.  However, the difference will not be so significant if this length is small enough. <br><br><h4>  <font color="#089">Geometric distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e49/155/542/e4915554219f4d52aa6eb7601f321dda.png"></div><br><img src="https://habrastorage.org/files/132/0d9/9a3/1320d99a3b0048b2bb89f3ea13ec3dd8.png"><br><br>  A random variable with a geometric distribution with the parameter p is a random variable with an exponential distribution with the parameter -ln (1 - p), rounded down to the nearest integer. <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  Let W be a random variable distributed exponentially with the -ln (1 - p) parameter.  Then: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4dd/ce6/96e/4ddce696e19d485d8301a89310b28a82.png"></div><br></div></div><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{ rate = -ln(<span class="hljs-number"><span class="hljs-number">1</span></span> - p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Geometric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Exponential(rate)); }</code> </pre><br>  Can it be done faster?  Sometimes.  Let's look at the distribution function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b23/6ac/c0b/b236acc0b05a4583aeb7ff9e4e0843fb.png"></div><br>  and use the ordinary inversion method: generate a standard uniformly distributed random variable U and return the minimum value of k for which this sum is greater than U: <br><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> GeometricExponential(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> = p, prod = p, q = <span class="hljs-number"><span class="hljs-number">1</span></span> - p; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (U &lt; <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>) { prod *= q; <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> += prod; ++k; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k; }</code> </pre><br>  Such a consistent search is quite effective, given that the values ‚Äã‚Äãof a random variable with a geometric distribution are concentrated near zero.  The algorithm, however, quickly loses its speed with too small values ‚Äã‚Äãof p, and in this case it is better to use the exponential generator. <br>  There is a secret.  The values ‚Äã‚Äãof p, (1-p) * p, (1-p) ^ 2 * p, ... can be calculated in advance and memorized.  The question is where to stay.  And then the geometric distribution property, which it inherited from the exponential - the lack of memory: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/744/3a9/b76/7443a9b762ba48439317d5436683a37b.png"></div><br>  Thanks to this property, you can remember only a few first values ‚Äã‚Äã(1-p) ^ i * p and then use recursion: <br><br><pre> <code class="hljs pgsql">// works nice <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0.2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tableSize = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> setupTable(<span class="hljs-type"><span class="hljs-type">double</span></span> p) { <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = p; <span class="hljs-type"><span class="hljs-type">double</span></span> prod = p, q = <span class="hljs-number"><span class="hljs-number">1</span></span> - p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; tableSize; ++i) { prod *= q; <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + prod; } } <span class="hljs-type"><span class="hljs-type">double</span></span> GeometricTable(<span class="hljs-type"><span class="hljs-type">double</span></span> p) { <span class="hljs-type"><span class="hljs-type">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); /// handle tail <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> recursion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U &gt; <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[tableSize - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableSize + GeometricTable(p); /// handle the main body <span class="hljs-type"><span class="hljs-type">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (U &gt; <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[x]) ++x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre><br><br><h4>  <font color="#089">Binomial distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/261/815/4b6/2618154b61574a3097c1e904b04004a8.png"></div><br><img src="https://habrastorage.org/files/362/a20/9be/362a209be1a24fa384af9b5c4c833759.png"><br><br>  By definition, a random variable with a binomial distribution is the sum of n random variables with a Bernoulli distribution: <br><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> BinomialBernoulli(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != n; ++i) <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> += Bernoulli(p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>; }</code> </pre><br>  However, there is a linear dependence on n that needs to be circumvented.  You can use the theorem: if Y_1, Y_2, ... are random variables with a geometric distribution with the parameter p and X is the smallest integer, such that: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d26/c9d/6d3/d26c9d6d356a499d8d2a7d3a2aee389a.png"></div><br>  then X has a binomial distribution. <br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  By definition, a random variable with a geometric distribution of Y is the number of Bernoulli's experiments before the first success.  There is an alternative definition: Z = Y + 1 is the number of Bernoulli‚Äôs experiments up to and including the first success.  This means that the sum of independent Z_i is the number of Bernoulli's experiments up to X + 1 success inclusive.  And this sum is greater than n if and only if among the first n tests no more than X are successful.  Respectively: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/842/a22/0f0/842a220f063049bcba3cc3b3071e6c86.png"></div><br>  qed <br></div></div><br>  The running time of the next code grows only with increasing n * p. <br><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> BinomialGeometric(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> X = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; do { <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> += Geometric(p) + <span class="hljs-number"><span class="hljs-number">1.0</span></span>; ++X; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> &lt;= n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X; }</code> </pre><br>  And yet, the time complexity is growing. <br>  The binomial distribution has one feature.  As n grows, it tends to a normal distribution, or, if p ~ 1 / n, it tends to a Poisson distribution.  Having generators for these distributions, they can replace the generator for the binomial in such cases.  But what if this is not enough?  In the Luc Devroye book "Non-Uniform Random Variate Generation" there is an example of an algorithm that works equally fast for any large n * p values.  The idea of ‚Äã‚Äãthe algorithm is to sample with a deviation using normal and exponential distributions.  Unfortunately, the story about the operation of this algorithm will be too large for this article, but in this book it is fully described. <br><br><h4>  <font color="#089">Poisson distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e17/cba/d3e/e17cbad3e4314e10983c3907ce8d15bc.png"></div><br><img src="https://habrastorage.org/files/7b5/657/993/7b56579932ae4300bef692441cde30fd.png"><br><br>  If W_i is a random variable with standard exponential distribution with density lambda, then: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a9/96b/c0e/1a996bc0e7224352a5b5ffe99b684347.png"></div><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  Let f_k (y) be the density of the standard Erlang distribution (sums of k standard exponentially distributed random variables): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7ae/6fd/f29/7ae6fdf29edf4ac69bbf41f0f10f8690.png"></div><br>  then <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/907/a99/8b9/907a998b9d874cea9a3d91bff8b66065.png"></div><br>  and the probability to get k: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2a7/4e9/c73/2a74e9c73f894fc0b34290921151efeb.png"></div><br>  coincides with the Poisson distribution.  qed <br></div></div><br>  Using this property, you can write a generator in terms of a sum of exponentially distributed values ‚Äã‚Äãwith a density rate: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PoissonExponential</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { s += Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); ++k; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &lt; rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k; }</code> </pre><br>  The Knut algorithm is based on this property.  Instead of the sum of exponential values, each of which can be obtained by the inversion method using -ln (U), the product of uniform random variables is used: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1e9/692/637/1e96926372c143c0aeaf39b155fce5c0.png"></div><br>  and then: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9a6/b83/d5a/9a6b83d5a9994388a5595b7cd1ea4c39.png"></div><br>  Remembering in advance the value of exp (-rate), sequentially multiply U_i until the product exceeds it. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rate)</span></span></span><span class="hljs-function"> expRateInv </span></span>= <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-rate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PoissonKnuth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>, prod = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (prod &gt; expRateInv) { prod *= Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); ++k; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k; }</code> </pre><br>  You can use the generation of only one random variable and the method of inversion: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/23a/6a6/2e5/23a6a62e57f64899ac89aa894f01abe6.png"></div><br>  It is better to start the search for k satisfying this condition with the most probable value, that is, with a floor (rate).  We compare U with the probability that X &lt;floor (rate) and go up if U is more, or down in another case: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setup(<span class="hljs-type"><span class="hljs-type">double</span></span> rate) floorLambda = floor(rate); FFloorLambda = F(floorLamda); // P(X &lt; floorLambda) PFloorLambda = P(floorLambda); // P(X = floorLambda) } <span class="hljs-type"><span class="hljs-type">double</span></span> PoissonInversion(<span class="hljs-type"><span class="hljs-type">double</span></span>) { <span class="hljs-type"><span class="hljs-type">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">int</span></span> k = floorLambda; <span class="hljs-type"><span class="hljs-type">double</span></span> s = FFloorLambda, p = PFloorLambda; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s &lt; U) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ++k; p *= lambda / k; s += p; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &lt; U); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { s -= p; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &gt; U) { p /= lambda / k; <span class="hljs-comment"><span class="hljs-comment">--k; s -= p; } } return k; }</span></span></code> </pre><br>  The problem of all three generators in one - their complexity grows with the density parameter.  But there is a salvation - for large values ‚Äã‚Äãof density, the Poisson distribution tends to a normal distribution.  You can also use a complex algorithm from the above-mentioned book ‚ÄúNon-Uniform Random Variate Generation‚Äù, well, or simply approximate, neglecting accuracy in the name of speed (depending on what the task is). <br><br><h4>  <font color="#089">Negative binomial distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0f6/4cf/fcd/0f64cffcd84941a8aa0f04b62b054a5f.png"></div><br><img src="https://habrastorage.org/files/e4e/efb/eb0/e4eefbeb0bf9469fa4d4e4337ad8c1af.png"><br><br>  The negative binomial distribution is also referred to as the Pascal distribution (if r is integer) and the Field distribution (if r can be real).  Using the characteristic function, it is easy to prove that the Pascal distribution is the sum of r geometrically distributed quantities with the parameter 1 - p: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pascal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != r; ++i) x += Geometric(<span class="hljs-number"><span class="hljs-number">1</span></span> - p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre><br>  The problem with this algorithm is obvious - linear dependence on r.  We need something that will work equally well with any parameter.  And this will help us a great property.  If the random variable X has a Poisson distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/034/dc5/ad9/034dc5ad968c4e5da9f47de05bb0733d.png"></div><br>  where density is random and has a gamma distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/701/434/8af/7014348af9754038a57c4803e33aced8.png"></div><br>  then X has a negative binomial distribution.  Therefore, it is sometimes called the Poisson gamma distribution. <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/758/e85/9a9/758e859a9b3d48a2a12c88689b4825c5.png"></div><br></div></div><br>  Now, we can quickly write a random value generator with Pascal distribution for large values ‚Äã‚Äãof the parameter r. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pascal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Poisson(Gamma(r, p / (<span class="hljs-number"><span class="hljs-number">1</span></span> - p))); }</code> </pre><br><br><h4>  <font color="#089">Hypergeometric distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/83a/154/d0f/83a154d0f6c8490e8cab2e895e28645d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/559/598/597/559598597ca64dbaa54e538478634c7b.png"></div><br>  Imagine that there are N balls in the urn and K of them are white.  You pull n balls.  The number of whites among them will have a hypergeometric distribution.  In general, it is better to take an algorithm using this definition: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HyperGeometric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>, p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(K) / N; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Bernoulli(p) &amp;&amp; ++sum == K) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; p = (K - sum) / (N - i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Or you can use a sample with a deviation through the binomial distribution with parameters: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/abb/f41/a17/abbf41a175ac4dfba28858c1a0d77408.png"></div><br>  and constant M: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ebf/6bc/472/ebf6bc472d3941e993a2932d31280c9c.png"></div><br>  The algorithm with the binomial distribution works well in extreme cases for large n and even larger N (such that n &lt;&lt; N).  Otherwise, it is better to use the previous one, despite its growing complexity with increasing input parameters. <br><br><h4>  <font color="#089">Logarithmic distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/24c/8b3/ee3/24c8b3ee3215449e8d480b619e8709b8.png"></div><br><img src="https://habrastorage.org/files/723/d1f/72b/723d1f72bc93492fa87fc03928a4dc04.png"><br><br>  There is a useful theorem for this distribution.  If U and V are uniformly distributed random variables from 0 to 1, then <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d86/562/ae1/d86562ae14504011a577f64b6f286a3e.png"></div><br>  will have a logarithmic distribution. <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  Remembering the generators for the exponential and geometric distributions, it is easy to see that X, given by the formula above, satisfies the following distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e8b/9b6/e99/e8b9b6e99b53427897627aed86ff540c.png"></div><br>  Let us prove that X has a logarithmic distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/482/8aa/712/4828aa7122df4de695d7c8e37e162652.png"></div><br>  qed <br></div></div><br>  To speed up the algorithm, you can use two tricks.  First, if V&gt; p, then X = 1, since  p&gt; = 1- (1-p) ^ U.  Second: let q = 1- (1-p) ^ U, then if V&gt; q, then X = 1, if V&gt; q ^ 2, then X = 2, etc.  Thus, it is possible to return the most probable values ‚Äã‚Äã1 and 2 without frequent counts of logarithms. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{ logQInv = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logarithmic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> V = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (V &gt;= p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(U / logQInv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (V &gt; y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (V &lt;= y * y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(V) / <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span>; }</code> </pre><br><br><h4>  <font color="#089">Zeta distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/be4/534/640/be4534640928488294915f54a3460bac.png"></div><br>  The denominator is the Riemann zeta function: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/89f/ac3/841/89fac38416a343dca149dc83388cc7eb.png"></div><br><img src="https://habrastorage.org/files/39a/17d/4bb/39a17d4bb3894bb8b27c18f4c8e548b0.png"><br><br>  For zeta distribution, there is an algorithm that allows not to calculate the Riemannian zeta function.  It is only necessary to be able to generate a Pareto distribution.  Proof can be attached at the request of readers. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setup(<span class="hljs-type"><span class="hljs-type">double</span></span> s) { <span class="hljs-type"><span class="hljs-type">double</span></span> sm1 = s - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; b = <span class="hljs-number"><span class="hljs-number">1</span></span> - pow(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, -sm1); } <span class="hljs-type"><span class="hljs-type">double</span></span> Zeta(<span class="hljs-type"><span class="hljs-type">double</span></span>) { /// rejection sampling <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rounded down Pareto distribution <span class="hljs-type"><span class="hljs-type">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-type"><span class="hljs-type">double</span></span> X = floor(Pareto(sm1, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-type"><span class="hljs-type">double</span></span> T = pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + <span class="hljs-number"><span class="hljs-number">1.0</span></span> / X, sm1); <span class="hljs-type"><span class="hljs-type">double</span></span> V = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (V * X * (T - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;= T * b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++iter &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>; /// doesn<span class="hljs-string"><span class="hljs-string">'t work }</span></span></code> </pre><br><br>  Finally, small algorithms for other complex distributions: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Skellam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Poisson(m1) - Poisson(m2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Planck</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> G = Gamma(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Z = Zeta(a + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> G / (b * Z); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Yule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ro</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> prob = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / Pareto(ro, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Geometric(prob) + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  <a href="https://github.com/Quanteeks/RandLib">Implementing these and other C ++ generators 17</a> </div><p>Source: <a href="https://habr.com/ru/post/265321/">https://habr.com/ru/post/265321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265311/index.html">Safe as in a safe</a></li>
<li><a href="../265313/index.html">How to configure the iOS device and RAD Studio XE8 (Delphi, C ++ Builder)</a></li>
<li><a href="../265315/index.html">Who is a designer?</a></li>
<li><a href="../265317/index.html">HP and Microsoft - a symbiosis of progress</a></li>
<li><a href="../265319/index.html">Requests in CoreData with aggregate functions and grouping in one line</a></li>
<li><a href="../265323/index.html">Numeric types and C ++ containers in terms of performance</a></li>
<li><a href="../265325/index.html">Linux Piter Conference Announcement</a></li>
<li><a href="../265327/index.html">Distributed cron and batch scheduler in a Prun cluster</a></li>
<li><a href="../265329/index.html">Install and configure the generation of tiles based on OSM data under Windows</a></li>
<li><a href="../265335/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 9. "Opportunities"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>