<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Design and architecture in the OP. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ascending design in OP. The idea is the basis of good design. Antipatterns in haskell 

 Some theory 
 In the last part, we built a high-level applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Design and architecture in the OP. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <strong>Ascending design in OP.</strong>  <strong>The idea is the basis of good design.</strong>  <strong>Antipatterns in haskell</strong> <br><br><h5>  Some theory </h5><br>  <a href="http://habrahabr.ru/post/211871/">In the last part,</a> we built a high-level application architecture.  We defined subsystems and their connections, and also divided the program into three layers: Application, Game Logic, Views.  Logically, the next stage is the design of the application.  In terms of importance, this stage is not inferior to the previous one, since it is during the design that we must support all functional requirements, determine the actual structure of the subsystems, describe the main technical problems, apply any typical solutions, or come up with others.  But first we will try to answer the question: what is it, good software design?  By what criteria do we determine the "good" design? <br><a name="habracut"></a><br>  Here are three possible answers: <br><br><ol><li>  <strong>Completeness</strong> .  A good design is one in which all requirements are taken into account with minimal actual costs for implementation, maintenance and introduction of new functionality. </li><li>  <strong>Performance</strong> .  A good design is one in which development goals are achieved. </li><li>  <strong>Simplicity</strong>  A good design is one in which the objective complexity of the domain is successfully mapped to simple working concepts. </li></ol><br>  From the latter follows the consequence that a good design should be easy to explain in 10 minutes without sacrificing accuracy and completeness (S. Teplyakov, " <a href="http://sergeyteplyakov.blogspot.ru/2012/07/blog-post.html">About Design</a> "). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The above can be illustrated with a diagram: <br><br><div class="spoiler">  <b class="spoiler_title">Chart: Goals-Requirements-Simplicity</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ca5/c5a/dc2/ca5c5adc2be72594a3321b4d351f05d8.png"></div></div><br><br>  Here the outer triangle describes an ideal hypothetical system in which each of the three criteria is 100% satisfied.  The red triangle shows the current state of affairs.  The center of gravity of the outer triangle is the zero point.  Note that when the criterion is shifted to the "negative" side, we see various problem situations that should not be in any way, since this is more like sabotage. <br><br>  Examples of problem situations: <br><br><ol><li>  Requirements are not met, but the development goals have been achieved: it means that the team imitates vigorous activity in the pursuit of bonuses or because of a different motivation.  The team has achieved its own internal goals;  they do not coincide with the goals of the market or company, and the product does not do what is expected of it. </li><li>  The goals were not achieved, but all the requirements were met: for two years we made the Tic-Tac-Toe game, it‚Äôs all good, you can even rob the cows there ... But we didn‚Äôt have time for the contest - it ended a long time ago, and now we are out of work. </li><li>  Requirements are met, goals are achieved, the code is quickly written, but ... the framework being the basis for the design is overly complicated, lost, written under the current situation, and only two people from the team understand how it works. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Diagrams of problem situations</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/f6c/239/39e/f6c23939e910b353409abef5448fefb6.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/817/bbe/ee2/817bbeee298100a303fca06e2e117a29.png"></td></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/b12/225/077/b12225077b775023ad0de2765c81e4af.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/9ac/84e/e37/9ac84ee373a334160d4eee0ed6dfd541.png"></td></tr></tbody></table></div></div><br>  Now it became clear why good design is so important.  But none of the above criteria says anything about what needs to be done to get it.  In the literature there is usually no answer to this question either;  You can find general advice like: ‚Äúfollow the principles of such and such‚Äù, ‚Äúuse patterns‚Äù, ‚Äúmodel the process of the name of that‚Äù.  The tips are right: you can get a great code.  There is only one problem: code is not design.  Even with the code itself, there is no guarantee that all three criteria for the ‚Äúgoodness‚Äù of the design will be satisfied.  Especially - to make the design <a href="http://tonsky.livejournal.com/243192.html">simple</a> and complete. <br><br>  Where does this come from?  Take for example the end-to-end modeling process using UML.  The developer reveals the following diagrams: Use Cases ‚Üí User Scenarios ‚Üí Sequence Diagrams ‚Üí Object Diagrams ‚Üí Communication Diagrams ‚Üí Class Diagrams ‚Üí‚Ä¶.  At the same time, the terms of the domain become classes, modules, packages and interactions (for example, <a href="http://stackoverflow.com/questions/2431025/use-case-to-class-diagram-how-do-i">like this</a> or <a href="http://www.dcs.gla.ac.uk/~simon/teaching/MechEngSE3/L89_ModelDynBehaviour.pdf">this way</a> ).  The goal is simple: identify all entities and actions with them;  that is, to develop a system "in the forehead," as we see and understand.  We simply translate our knowledge of the system into the model of this system, and it is impossible to say in advance how many entities there will be, how many elements, and what the network of connections will be - even taking into account any generalizations.  It is very difficult to introduce DSL, since a domain-specific language does not directly follow from one diagram.  Is the model simple and complete?  Unknown. <br><br>  At the top level of abstraction, our world is imperative.  We always have a state, there is always a sequence of actions with this state.  ‚ÄúGoing to the crossroads, look left, then right, and if there are no cars, move on.‚Äù  Transferring this level of abstraction one-to-one into the design, we get an imperative solution that does not fit the functional paradigm.  In contrast, deeper levels of abstraction of the world are not imperative, because they are based on properties and laws, and not on entities and actions.  "You can cross the road when there is no danger."  It would be a mistake to use the imperative approach to describe the physical world: ‚ÄúIf in the next second the earth is not yet reached, increase the speed of fall by the value of g‚Äù.  When applied to AF, this problem is only exacerbated.  We will see further that the ‚Äúhead on‚Äù approach leads to serious conceptual problems.  The code is not idiomatic, hard-to-manage, it becomes overcomplicated, and all the benefits of AF are simply lost.  But if we decompose the subject area into properties and laws, we will get a solution that fits perfectly with the OP. <br><br>  We fix this in the fourth criterion of "goodness" of design: <br><br>  4. <strong>Fundamentality</strong> .  A good design is one that is based on the right idea, which describes the subject area at a fundamental level.  In other words, ‚Äúwhat it is,‚Äù and not ‚Äúhow it works.‚Äù <br><br><div class="spoiler">  <b class="spoiler_title">Chart: The right idea is the basis of a good design.</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/4c5/4e1/dcc/4c54e1dccd8e0d278c4667267d144a45.png"></div></div><br><br>  Right ideas are important everywhere.  Any scientific concept is the essence of a certain idea from which all the consequences are derived.  The basis of the Riemann integral is the idea of ‚Äã‚Äãthe sum of the infinitesimal.  Einstein's GTR is based on the equivalence of inertial and gravitational masses.  At the heart of the Scala language is the position that everything is an object, and any object is a function.  And in Lisp, everything is lists.  The idea plays a crucial role in building software design. <br><br>  For example, consider parsing ini-file.  What is the difference between <a href="http://gnosis.cx/publish/programming/charming_python_4.html">good</a> and <a href="http://www.expertcore.org/viewtopic.php%3Fstyle%3D4%26f%3D8%26t%3D4319">bad</a> design?  In the first case, the idea is applied that the configuration and state machine can exist separately.  As a result, the state machine can work with any configuration, irrespective of what it does.  In the second case, these entities are mixed, the code looks unprincipled, it cannot be reused.  And here is what a solution to the same problem might look like with the use of another idea: <a href="http://habrahabr.ru/post/50337/">Parsec</a> , <a href="http://habrahabr.ru/post/50976/">Boost.Spirit</a> .  We used combinatorial DSL, and simply transferred the properties of the ini-file - its grammar - into the code. <br><br>  Coming up with DSL, we will implement the idea of ‚Äã‚Äãhow you can map the complexity of the subject area to an understandable formal language.  Thanks to the right idea, we can encode not the entities as such, but the sets of their properties;  then any entity can be expressed by combining properties.  At the same time, there will be obviously less properties, and fewer interactions (by the way, this is what physicists are striving for in the search for the fundamental foundations of the Universe). <br><br>  Thus, the fourth criterion allows us to come to a good design in practice.  But this will already be a bottom-up design approach, starting from the lowest levels that we have learned from a good idea. <br><br><h5>  Some practice </h5><br>  Not to be unfounded, let's follow the evolution of design ideas for the game ‚ÄúThe Amoeba World‚Äù.  This is a strategic game about the world inhabited by amoebas.  The player is invited once every 10 seconds to give orders to his colony of amoebae and then just watch how events will develop.  Amoebas produce and absorb energy, grow, fight for territory and resources.  The resource is energy.  The amoeba is almost entirely composed of plasma interspersed with organelles: the nucleus, which functions as a battery, the mitochondria, the energy sources, and the organelles for defense and attack.  The world of the game is endless and is a square grid.  In addition to amoebas, it has canyons, rivers, stones, sources of additional energy and other objects.  The world has three layers: ground, air and underground, with its objects and laws. <br><br>  What are the requirements for the content of the game? <br><br><ul><li>  Extensibility: you can easily add objects to the game world. </li><li>  Variability: objects can be complex and simple, active and passive, expensive and cheap, strong and fragile. </li></ul><br>  In this case, I would like some polymorphism in the interaction of objects.  How can this be implemented? <br><br>  <strong>Frontal solution.</strong>  <strong>Antipattern God ADT</strong> <br><br>  The first idea that came to mind is to make a single universal algebraic data type for the objects of the game world, and to keep these objects in the Data.Map structure.  Like this: <br><blockquote>  <font color="#06c">module</font> GameLogic <font color="#339933">.</font>  Types <font color="#06c">where</font> <br>  <font color="#06c">import</font> <font color="#06c">qualified</font> Data <font color="#339933">.</font>  Map <font color="#06c">as</font> m <br>  <font color="#06c">data</font> Item <font color="#66cc66"><b>=</b></font> Karyon <font color="#339933">...</font> <br>  <font color="#339933">|</font>  Plasma <font color="#339933">...</font> <br>  <font color="#339933">|</font>  Mitochondrion <font color="#339933">...</font> <br>  <font color="#339933">|</font>  Stone ... <br><br>  <font color="#06c">type</font> World <font color="#66cc66"><b>=</b></font> M.  Map Point Item <br>  <font color="#06c">type</font> OperatedWorld <font color="#66cc66"><b>=</b></font> World </blockquote><br>  The iterations of the world will be represented as a function of stepWorld.  In it, we will go through each object on the map and call the function apply for it.  In it, the value of the World type is the world at the last iteration, and in the value of the OperatedWorld type, the results of the apply function accumulate. <br><blockquote>  <font color="#06c">module</font> GameLogic <font color="#339933">.</font>  Logic <font color="#06c">where</font> <br>  <font color="#06c">import</font> GameLogic <font color="#339933">.</font>  Types <br>  stepWorld <font color="#66cc66"><b>::</b></font> World <font color="#339933">-&gt;</font> World <br>  apply <font color="#66cc66"><b>::</b></font> World <font color="#339933">-&gt;</font> Item <font color="#339933">-&gt;</font> OperatedWorld <font color="#339933">-&gt;</font> OperatedWorld </blockquote><br>  The solution looks simple and just as easy to implement.  However, in the near future we will need some other functions, which will be compared with the sample of the Item type.  And we will inevitably get into a problem situation: with each update of the Item type we will have to edit all these functions: <br><blockquote>  apply w <font>(</font> Karyon <font color="#339933">...</font> <font>)</font> ow <font color="#66cc66"><b>=</b></font> <font color="#339933">...</font> <br>  apply w <font>(</font> Plasma <font color="#339933">...</font> <font>)</font> ow <font color="#66cc66"><b>=</b></font> <font color="#339933">...</font> <br>  apply w <font>(</font> Mitochondrion <font color="#339933">...</font> <font>)</font> ow <font color="#66cc66"><b>=</b></font> <font color="#339933">...</font> <br>  <font color="#339933">...</font> <br>  getEnergy <font color="#66cc66"><b>::</b></font> Item <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <br>  getEnergy <font>(</font> Karyon e b c <font>)</font> <font color="#66cc66"><b>=</b></font> e <br>  getEnergy <font>(</font> Mitochondrion e f g <font>)</font> <font color="#66cc66"><b>=</b></font> e <br>  getEnergy <font color="#339933">_</font> <font color="#66cc66"><b>=</b></font> <font>error</font> <font>"getEnergy unsupported."</font> </blockquote><br>  We tied too much to the data type Item.  If we write a simple game like "Tic-tac-toe" or "Game of Life" - you can stop here.  But in the case of The Amoeba World, this approach seems out of place.  You need to come up with something else to remove pattern matching, add generosity and get rid of naive code. <br><br>  Expand our requirements: <br><br><ul><li>  <strong>Modularity</strong> : objects are in different modules. </li><li>  <strong>Locality</strong> : adding an object does not require updating other modules. </li><li>  <strong>Polymorphism</strong> : objects with the same interface interact with the world in different ways. </li></ul><br>  Well, now the requirements look more serious.  Let's try to figure it out. <br><br>  <strong>Antipattern "Existential Class Types"</strong> <br><br>  To fulfill both the requirement of modularity and locality, we will have to make the module of a specific object contain everything necessary for interacting with other objects on the game map.  At the same time, the above-mentioned GameLogic.Logic and GameLogic.Types modules should not change when a new module is added.  To make this possible, consider the following design idea: each object on the map is a separate type (Plasma, Karyon) for which there is an activate function ‚Äî the inheritor of the apply function. <br><blockquote>  <font color="#5d478b">- module GameLogic.Karyon:</font> <br>  activate <font color="#66cc66"><b>::</b></font> Karyon <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> World <font color="#339933">-&gt;</font> OperatedWorld <font color="#339933">-&gt;</font> OperatedWorld <br>  <font color="#5d478b">- module GameLogic.Plasma:</font> <br>  activate <font color="#66cc66"><b>::</b></font> Plasma <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> World <font color="#339933">-&gt;</font> OperatedWorld <font color="#339933">-&gt;</font> OperatedWorld <br></blockquote><br>  These functions are generalized by the type class <font color="#339933">.</font>  Let's call it Active: <br><blockquote>  <font color="#06c">class</font> Active i <font color="#06c">where</font> <br>  activate <font color="#66cc66"><b>::</b></font> i <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> World <font color="#339933">-&gt;</font> OperatedWorld <font color="#339933">-&gt;</font> OperatedWorld </blockquote><br>  Having this interface, we will go through all the objects of the map and activate them, no matter what type they are.  In OOP languages, this is a common solution, and it works through dynamic dispatching, but if we try to adapt the World type to Haskell, we will have difficulty compiling. <br><blockquote>  <font color="#06c">type</font> World <font color="#66cc66"><b>=</b></font> M.  Map Point <font color="#339933">????</font> </blockquote><br>  We want to keep different types of objects in the Map container: Karyon, Plasma, or something else, and this is a problem, because Haskell collections are not heterogeneous.  The problem is <a href="http://www.haskell.org/haskellwiki/Heterogenous_collections">known</a> , it has several solutions;  we are interested in a solution based on an existential data type.  In this article we confine ourselves to a brief statement of the idea and an explanation of why this is an <a href="http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">anti-pattern</a> .  For more detailed explanations, see the article by Roman Dushkin ‚Äú <a href="http://fprog.ru/2010/issue4/roman-dushkin-existentials/">Monomorphism, polymorphism and existential types</a> ‚Äù. <br><br>  To begin with, we will make the following blanks of the types of interest to us and implement the activate function for them. <br><blockquote>  <font color="#06c">module</font> GameLogic <font color="#339933">.</font>  Plasma <font color="#06c">where</font> <br>  <font color="#06c">data</font> Plasma <font color="#66cc66"><b>=</b></font> Plasma <font>{</font> plasmaPlayer <font color="#66cc66"><b>::</b></font> Player <font>}</font> <br>  <font color="#06c">instance</font> Active Karyon <font color="#06c">where</font> <br>  activate <font>(</font> Plasma pl <font>)</font> <font color="#66cc66"><b>=</b></font> <font>undefined</font> <br><br>  <font color="#06c">module</font> GameLogic <font color="#339933">.</font>  Karyon <font color="#06c">where</font> <br>  <font color="#06c">data</font> Karyon <font color="#66cc66"><b>=</b></font> Karyon <font>{</font> karyonPlayer <font color="#66cc66"><b>::</b></font> Player <br>  <font color="#339933">,</font> karyonEnergy <font color="#66cc66"><b>::</b></font> Energy <font>}</font> <br>  <font color="#06c">instance</font> Active Plasma <font color="#06c">where</font> <br>  activate <font>(</font> Karyon pl e <font>)</font> <font color="#66cc66"><b>=</b></font> <font>undefined</font> </blockquote><br>  Now you need to create a heterogeneous map of the world.  To do this, we define the existential type-wrapper ActiveItem, which can already be stored in the world map: <br><blockquote>  <font color="#5d478b">- module GameLogic.Types:</font> <br>  <i><font color="#5d478b">{- # LANGUAGE ExistentialQuantification # -}</font></i> <br>  <font color="#06c">data</font> ActiveItem <font color="#66cc66"><b>=</b></font> <font color="#06c">forall</font> i <font color="#339933">.</font>  Active i <font color="#339933">=&gt;</font> MkActiveItem i <br>  <font color="#06c">type</font> World <font color="#66cc66"><b>=</b></font> M.  Map Point ActiveItem <br>  packItem <font color="#66cc66"><b>::</b></font> Active i <font color="#339933">=&gt;</font> i <font color="#339933">-&gt;</font> ActiveItem <br>  packItem <font color="#66cc66"><b>=</b></font> MkActiveItem </blockquote><br>  The ActiveItem type does not know anything about type i except that for the latter there is an instance of the type class Active.  When we pack any object like Karyon or Plasma, we lose information about the type, but we can put it in any collection: <br><blockquote>  packedKaryon <font color="#66cc66"><b>=</b></font> packItem <font>(</font> Karyon <font color="red">1,100</font> <font>)</font> <br>  packedPlasma <font color="#66cc66"><b>=</b></font> packItem <font>(</font> Plasma <font color="red">1</font> <font>)</font> <br>  world <font color="#66cc66"><b>=</b></font> M.  fromList <font>[</font> <font>(</font> Point <font color="red">1</font> <font color="red">1</font> <font color="red">1</font> <font color="#339933">,</font> packedKaryon <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> Point <font color="red">1</font> <font color="red">1</font> <font color="red">2</font> <font color="#339933">,</font> packedPlasma <font>)</font> <font>]</font> </blockquote><br>  Now you can go through the objects of the map and call for each its own version of activate something like this: <br><blockquote>  stepWorld world <font color="#66cc66"><b>=</b></font> M.  foldrWithKey f M.  empty world <br>  <font color="#06c">where</font> <br>  f point <font>(</font> MkActiveItem i <font>)</font> operatedWorld <font color="#66cc66"><b>=</b></font> activate i point world operatedWorld </blockquote><br>  You can slightly reduce the record by defining an instance of the Active type class for ActiveItem: <br><blockquote>  <font color="#06c">instance</font> Active ActiveItem <font color="#06c">where</font> <br>  activate <font>(</font> MkActiveItem i <font>)</font> <font color="#66cc66"><b>=</b></font> activate i <br>  ... <br>  stepWorld world <font color="#66cc66"><b>=</b></font> M.  foldrWithKey activate M.  empty world <br>  <font color="#06c">where</font> <br>  f point i <font color="#66cc66"><b>=</b></font> activate i point world </blockquote><br>  We have achieved the desired - we have spread the functionality of changing the card according to different types and modules.  What is wrong with this code?  The ‚ÄúExistential type class‚Äù pattern is useful if all you need to do with objects in the collection is to serialize them (the Show type class), render it on a 3D scene (the Figure type class with the render function is like in R. Dushkin‚Äôs article), or still somehow be used for unmutable purposes.  The anti-pattern ‚ÄúExistential Class of Types‚Äù shows the <a href="http://stackoverflow.com/questions/7787317/list-of-different-types">inapplicability of</a> OOP thinking in the functional world.  Understanding map elements as objects, we inevitably come to the fact that we need new and new functions for working with them, and the type class becomes inconsistent, and other types of types appear.  In the case of the game ‚ÄúThe Amoeba World‚Äù, this practice led to the fact that I really wanted to somehow return from the ‚Äúinterface‚Äù Active another ‚Äúinterface‚Äù - the Interactable type class to make different objects interact in a generic way.  (See <a href="">eafd64de12</a> commit). Perhaps the solution to this OOP problem exists in Haskell, but the author could not find it, which is for the best, since this is a dead-end path. <br><br>  <strong>Let-functions and antipattern "Object type"</strong> <br><br>  Let-functions are unsupportable functions with a large number of arguments, let- and where-expressions.  Let-functions themselves are not anti-patterns, but a sign that the current design does not give us other tools for expressing logic.  Very often, let-functions are a functional wrapper over an imperative code ‚Äî and this, as we have already found out, is not an idiomatic approach. <br><br>  An example from ‚ÄúThe Amoeba World‚Äù (commit <a href="">3a0500a217</a> ): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><blockquote>  activatePieceGrowing <font color="#66cc66"><b>::</b></font> Player <font color="#339933">-&gt;</font> Bounds <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> Direction <font color="#339933">-&gt;</font> <font>(</font> World <font color="#339933">,</font> Annotations <font color="#339933">,</font> Energy <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> World <font color="#339933">,</font> Annotations <font color="#339933">,</font> Energy <font>)</font> <br>  activatePieceGrowing <font color="#339933">_</font> <font color="#339933">_</font> <font color="#339933">_</font> <font color="#339933">_</font> actRes <font color="#339933">@</font> <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">,</font> <font color="red">0</font> <font>)</font> <font color="#66cc66"><b>=</b></font> actRes <br>  activatePieceGrowing pl bounds p dir <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">,</font> e <font>)</font> <font color="#66cc66"><b>=</b></font> <font color="#06c">case</font> growPlasmaFunc <font color="#06c">of</font> <br>  Left ann <font color="#339933">-&gt;</font> <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">++</font> <font>[</font> ann <font>]</font> <font color="#339933">,</font> e <font>)</font> <br>  Right <font>(</font> w <font>', anns'</font> <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> w <font>', anns ++ anns'</font> <font color="#339933">,</font> e <font color="#339933">-</font> <font color="red">1</font> <font>)</font> <br>  <font color="#06c">where</font> <br>  growPlasmaFunc <font color="#66cc66"><b>=</b></font> growPlasma pl bounds p dir w <br><br>  activatePiece <font color="#66cc66"><b>::</b></font> Point <font color="#339933">-&gt;</font> Karyon <font color="#339933">-&gt;</font> Shift <font color="#339933">-&gt;</font> <font>(</font> World <font color="#339933">,</font> Annotations <font color="#339933">,</font> Energy <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> World <font color="#339933">,</font> Annotations <font color="#339933">,</font> Energy <font>)</font> <br>  activatePiece <font color="#339933">_</font> <font>(</font> KaryonFiller <font>{</font> <font>}</font> <font>)</font> <font color="#339933">_</font> r <font color="#66cc66"><b>=</b></font> r <br>  activatePiece p <font color="#339933">@</font> <font>(</font> Karyon <font color="#339933">_</font> pl <font color="#339933">_</font> <font color="#339933">_</font> bound <font>)</font> sh activationData <font color="#339933">|</font>  isCornerShift sh <font color="#66cc66"><b>=</b></font> <font color="#06c">let</font> <br>  actFunc <font color="#66cc66"><b>=</b></font> activatePieceGrowing pl <font>[</font> bound p <font>]</font> p <font>(</font> subDirection2 sh <font>)</font> <br>  <font color="#339933">.</font>  activatePieceGrowing pl <font>[</font> bound p <font>]</font> p <font>(</font> subDirection1 sh <font>)</font> <br>  <font color="#06c">in</font> actFunc activationData <br>  activatePiece p <font color="#339933">@</font> <font>(</font> Karyon <font color="#339933">_</font> pl <font color="#339933">_</font> <font color="#339933">_</font> bound <font>)</font> sh activationData <font color="#66cc66"><b>=</b></font> <font color="#06c">let</font> <br>  actFunc <font color="#66cc66"><b>=</b></font> activatePieceGrowing pl <font>[</font> bound p <font>]</font> p <font>(</font> direction sh <font>)</font> <br>  <font color="#06c">in</font> actFunc activationData </blockquote></div></div><br>  Partially, the code can be improved by bringing immutable data into context with the help of the Reader monad, but this will not save imperativeness (commit <a href="">8df9b7a224</a> ): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><blockquote>  activatePiece <font color="#66cc66"><b>::</b></font> ActivationData <font color="#339933">-&gt;</font> R.  Reader ActivationContext ActivationData <br>  activatePiece actData <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  isCornerPiece <font color="#339933">&lt;-</font> askIsCornerPiece <br>  <font color="#06c">if</font> isCornerPiece <font color="#06c">then</font> activateCornerPiece actData <br>  <font color="#06c">else</font> activateOrdinaryPiece actData <br><br>  activatePieceGrowing <font color="#66cc66"><b>::</b></font> Direction <font color="#339933">-&gt;</font> ActivationData <font color="#339933">-&gt;</font> R.  Reader ActivationContext ActivationData <br>  activatePieceGrowing <font color="#339933">_</font> actData <font color="#339933">@</font> <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">,</font> <font color="red">0</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>return</font> actData <br>  activatePieceGrowing dir actData <font color="#339933">@</font> <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">,</font> e <font>)</font> <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font>(</font> pl <font color="#339933">,</font> bounds <font color="#339933">,</font> p <font>)</font> <font color="#339933">&lt;-</font> askLocals <br>  <font color="#06c">case</font> growPlasma pl bounds p dir w <font color="#06c">of</font> <br>  Left ann <font color="#339933">-&gt;</font> <font>return</font> <font>(</font> w <font color="#339933">,</font> anns <font color="#339933">++</font> <font>[</font> ann <font>]</font> <font color="#339933">,</font> e <font>)</font> <br>  Right <font>(</font> w <font>', anns'</font> <font>)</font> <font color="#339933">-&gt;</font> <font>return</font> <font>(</font> w <font>', anns ++ anns'</font> <font color="#339933">,</font> e <font color="#339933">-</font> <font color="red">1</font> <font>)</font> <br>  <font color="#06c">where</font> <br>  askLocals <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font>(</font> ActivationContext k p <font color="#339933">_</font> <font>)</font> <font color="#339933">&lt;-</font> R.  ask <br>  <font>return</font> <font>(</font> karyonPlayer k <font color="#339933">,</font> <font>[</font> karyonBound k p <font>]</font> <font color="#339933">,</font> p <font>)</font> </blockquote></div></div><br>  The above code arose due to the fact that the entire design is based on object ATD Karyon, Border and others.  ‚ÄúObject Type‚Äù is the main anti-pattern of the early design of the game ‚ÄúThe Amoeba World‚Äù.  Because of it, a bulky unsupported code with poor structure was born.  The idea of ‚Äã‚Äãobject types obviously derives from OOP thinking, which leads to dire consequences when we try to implement it in functional programming.  Therefore, the requirements of modularity, locality and polymorphism should not be understood straightforwardly.  They do not impose an explicit restriction that objects must be types, and interfaces must be type classes. <br><br>  In the following parts, we will look at more ‚Äúfunctional‚Äù design ideas, when the subject area is described by a set of properties and laws, but not objects and interactions. </div><p>Source: <a href="https://habr.com/ru/post/215161/">https://habr.com/ru/post/215161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215139/index.html">Implicit php code call techniques used in malicious scripts</a></li>
<li><a href="../215141/index.html">Is there an API for Kiosk apps on Android?</a></li>
<li><a href="../215147/index.html">Log4j 1.x performance in synchronous and asynchronous mode</a></li>
<li><a href="../215149/index.html">Personal experience: the benefits of "independent" RSS-reader</a></li>
<li><a href="../215151/index.html">The logic of thinking. Part 8. Selection of factors in the wave networks</a></li>
<li><a href="../215163/index.html">My tool for time tracking and invoicing</a></li>
<li><a href="../215167/index.html">The Linux Foundation and EdX begin a free course on Introduction to Linux.</a></li>
<li><a href="../215171/index.html">Simple filter tapes VK for "bad" words and what he can become</a></li>
<li><a href="../215173/index.html">Statistics using javascript libraries and CDN</a></li>
<li><a href="../215175/index.html">Firefox Download Panel Improvements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>