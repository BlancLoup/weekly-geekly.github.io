<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improving HTML5 canvas performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I have been lucky to stumble upon interesting articles for translation. This time is an HTML5Rocks article on HTML5 canvas performance. The a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improving HTML5 canvas performance</h1><div class="post__text post__text-html js-mediator-article">  <i>Recently I have been lucky to stumble upon interesting articles for translation.</i>  <i>This time is an <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/">HTML5Rocks</a> article on HTML5 canvas performance.</i>  <i>The author writes about some kind of wall, which developers come up against when creating applications.</i>  <i>Some time ago, I rested in it when porting the good old game to canvas.</i> <i><br><br></i>  <i>Unfortunately, the graphics in the original inserted through the iframe.</i>  <i>I could take pictures and place their images, but the author himself is positioning the graphics relevant and updated, so I simply placed links to them.</i>  <i>Enjoy reading!</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1d/142/f24/d1d142f24b5ba717a2dd04a2efdf5936.png" alt="image"><br><ol><li>  <a href="http://habrahabr.ru/post/127014/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Performance testing</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Pre-draw on virtual canvas</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Group calls</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Avoid unnecessary state changes.</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Draw only the difference, not the entire canvas.</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Use layered canvas for complex scenes.</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Avoid shadowBlur</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Various ways to clear the screen</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Avoid non-integer coordinates</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Optimize animations with 'requestAnimationFrame'</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Most canvas mobile implementations are slow.</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Conclusion</a> </li><li>  <a href="http://habrahabr.ru/post/127014/">Links</a> </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="1"></a><br><h4>  Introduction </h4><br>  HTML5 canvas, which began as an experiment by Apple, is the most widely accepted standard for 2D <a href="http://en.wikipedia.org/wiki/Immediate_mode">direct graphics</a> on the Internet.  Many developers use it in a wide range of multimedia projects, visualizations and games.  Be that as it may, with the increasing complexity of applications, developers inadvertently stumble upon a performance wall. <a name="habracut"></a><br><br>  There are many scattered canvas scans everywhere.  This article aims to bring them together to create a more readable resource for developers.  The article includes both fundamental optimizations that apply to all areas of computer graphics, as well as specific techniques for canvas that change as canvas implementations evolve.  In particular, as GPU acceleration is used, some of the techniques described will become less relevant.  This will be indicated if necessary. <br><br>  Keep in mind this article is not an HTML5 canvas tutorial.  But you can study the relevant <a href="http://www.html5rocks.com/en/tutorials/">articles</a> on HTML5Rocks, here is this chapter on <a href="http://diveintohtml5.org/canvas.html">Dive into HTML5</a> and lessons on <a href="https://developer.mozilla.org/en/canvas_tutorial">MDN</a> . <br><br><a name="2"></a><br><h4>  Performance testing </h4><br>  In the fast-paced world of HTML5 canvas, <a href="http://jsperf.com/">JSPerf</a> ( <a href="http://jsperf.com/">jsperf.com</a> ) helps you verify that all of the proposed optimizations are still working.  JSPerf is a web application that allows developers to write JavaScript performance tests.  Each test focuses on the result that you are trying to get (for example, cleaning the canvas) and includes different approaches.  JSPerf runs each option as much as possible in a short period of time and displays a statistically meaningful number of iterations per second.  More is always better! <br><br>  Visitors to the JSPerf page can run tests in their browser and allow JSPerf to store normalized results on <a href="http://www.browserscope.org/">Browserscope</a> ( <a href="http://www.browserscope.org/">browserscope.org</a> ).  Since the optimization techniques in this article are stored on JSPerf, you can always go back and see actual information about whether this technique is still applicable.  I wrote a small helper <a href="https://github.com/borismus/jsperfview">application</a> that displays these results as graphs used in the article. <br><br>  All performance test results in this article are tied to the browser version.  This seems to be the limit, since we don‚Äôt know under which OS the browser was launched, or, more importantly, whether the HTML5 canvas hardware acceleration was enabled when testing was in progress.  You can determine whether hardware acceleration is enabled in Chrome by typing <code>about:gpu</code> in the address bar. <br><br><a name="3"></a><br><h4>  Pre-draw on virtual canvas </h4><br>  If you draw similar primitives on the screen over many frames (as is often the case when writing a game), you can gain significant performance gains by drawing large pieces outside the scene.  Preliminary drawing involves the use of virtual (or virtual) canvases, on which temporary images are drawn, and then copying virtual canvases onto the visible.  For those familiar with computer graphics, this technique is also known as the <a href="http://en.wikipedia.org/wiki/Display_list">display list</a> . <br><br>  For example, suppose you redraw Mario at 60 frames per second.  You can draw his hat, mustache and ‚ÄúM‚Äù in each frame or pre-draw it before running the animation. <br><br>  without pre-rendering: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// canvas, context are defined function render() { drawMario(context); requestAnimationFrame(render); }</span></span></code> </pre><br>  pre-rendering: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); m_canvas.width = <span class="hljs-number"><span class="hljs-number">64</span></span>; m_canvas.height = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_context = m_canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); drawMario(m_context); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.drawImage(m_canvas, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><br>  Pay attention to requestAnimationFrame, the use of which will be described in more detail a little later.  The following graph demonstrates the benefits of using pre-rendering ( <a href="http://jsperf.com/render-vs-prerender">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBiDqJQHDA">graph</a> . <br><br>  This technique is especially effective when drawing is complex (drawMario).  A good example is drawing a text, which is a very expensive operation.  Here's how dramatic performance increases with pre-rendering text ( <a href="http://jsperf.com/render-vs-prerender/3">jsperf</a> ): <br><br>  Anyway, you can see in the example above the poor performance of the ‚Äúpre-rendered loose‚Äù test.  When previewing, it is important to make sure that your temporary canvas has a ‚Äútight‚Äù size for your image, otherwise the performance gain will meet with a loss of performance when copying one large canvas to another (which looks like a function of the size of the target canvas).  A suitable canvas for the example above is smaller: <br><pre> <code class="javascript hljs">can2.width = <span class="hljs-number"><span class="hljs-number">100</span></span>; can2.height = <span class="hljs-number"><span class="hljs-number">40</span></span>;</code> </pre><br>  In comparison with the large: <br><pre> <code class="javascript hljs">can3.width = <span class="hljs-number"><span class="hljs-number">300</span></span>; can3.height = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><br><br><a name="4"></a><br><h4>  Group calls </h4><br>  Since rendering is an expensive operation, it is much more efficient to load the drawing state machine with long lists of commands, and then unload them into the video buffer. <br><br>  For example, when drawing multiple lines, it is much better to do one path with all the lines and draw it in one call.  In other words, how to draw separate lines: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; context.beginPath(); context.moveTo(p1.x, p1.y); context.lineTo(p2.x, p2.y); context.stroke(); }</code> </pre> <br><br>  It is better to draw one broken line: <br><pre> <code class="javascript hljs">context.beginPath(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; context.moveTo(p1.x, p1.y); context.lineTo(p2.x, p2.y); } context.stroke();</code> </pre><br><br>  This also applies to canvas.  When drawing a complex path, for example, it‚Äôs better to place all the points on it right away than to draw the segments separately ( <a href="http://jsperf.com/batching-line-drawing-calls/2">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBjf9K4HDA">graph</a> . <br><br>  But keep in mind that with canvas there is an important exception to this rule: if the primitives of the object being drawn have small surrounding rectangles (bounding box), it may turn out to be more efficient to draw them separately ( <a href="http://jsperf.com/batching-line-drawing-calls">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBjRzK4HDA">graph</a> . <br><br><a name="5"></a><br><h4>  Avoid unnecessary state changes. </h4><br>  Canvas is implemented on the basis of a finite state machine, which tracks things like fill and stroke styles, like previous points that make up the current path.  When trying to optimize, there is a temptation to focus on drawing.  But manipulations with the state machine also lead to costs. <br><br>  If you use multiple fill colors in a scene, it is cheaper to paint by color than by positioning it on the canvas.  To draw a small stripe texture, you can draw a line, change the color, draw the following, and so on: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; STRIPES; i++) { context.fillStyle = (i % <span class="hljs-number"><span class="hljs-number">2</span></span> ? COLOR1 : COLOR2); context.fillRect(i * GAP, <span class="hljs-number"><span class="hljs-number">0</span></span>, GAP, <span class="hljs-number"><span class="hljs-number">480</span></span>); }</code> </pre> <br><br>  Or draw all the even and odd stripes: <br><pre> <code class="javascript hljs">context.fillStyle = COLOR1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; STRIPES/<span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { context.fillRect((i*<span class="hljs-number"><span class="hljs-number">2</span></span>) * GAP, <span class="hljs-number"><span class="hljs-number">0</span></span>, GAP, <span class="hljs-number"><span class="hljs-number">480</span></span>); } context.fillStyle = COLOR2; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; STRIPES/<span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { context.fillRect((i*<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) * GAP, <span class="hljs-number"><span class="hljs-number">0</span></span>, GAP, <span class="hljs-number"><span class="hljs-number">480</span></span>); }</code> </pre> <br><br>  A comparison of these methods is presented in the following test ( <a href="http://jsperf.com/changing-canvas-state/3">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBiG69oHDA">graph</a> . <br><br>  As expected, the first option is slower, as well as manipulating the state of the road. <br><br><a name="6"></a><br><h4>  Draw only the difference, not the entire canvas. </h4><br>  As you can imagine, the smaller part of the screen we draw, the cheaper it is.  If you have only minor differences between redraws, you can get significant performance gains by drawing only the difference.  In other words, how to clear the entire screen before drawing: <br><pre> <code class="javascript hljs">context.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, canvas.width, canvas.height);</code> </pre><br><br>  Keep track of the bounding box being rendered and clean only it. <br><pre> <code class="javascript hljs">context.fillRect(last.x, last.y, last.width, last.height);</code> </pre><br><br>  This is shown in the following test, which includes a white dot crossing the screen ( <a href="http://jsperf.com/partial-re-rendering/2">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBivw8wHDA">graph</a> . <br><br>  If you understand computer graphics, you should be aware of this technique called ‚Äúredraw regions‚Äù, in which the previous bounding box is saved and then cleared with each drawing. <br><br>  This technique applies to pixel-by-pixel rendering, as in this discussion <a href="http://jsconf.eu/2010/speaker/lessons_learnt_pushing_browser.html">of the Nintendo JavaScript emulator</a> . <br><br><a name="7"></a><br><h4>  Use layered canvas for complex scenes. </h4><br>  As mentioned earlier, drawing large images is expensive and should be avoided.  In addition to using an offscreen buffer (pre-rendering section), we can use canvases overlaid on each other.  Using the transparency of the upper layer, we can rely on the GPU to apply the alpha channel during rendering.  You use this with two absolutely positioned canvases on top of each other, like this: <br><pre> <code class="javascript hljs">&lt;canvas id=<span class="hljs-string"><span class="hljs-string">"bg"</span></span> width=<span class="hljs-string"><span class="hljs-string">"640"</span></span> height=<span class="hljs-string"><span class="hljs-string">"480"</span></span> style=<span class="hljs-string"><span class="hljs-string">"position: absolute; z-index: 0"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;canvas id=<span class="hljs-string"><span class="hljs-string">"fg"</span></span> width=<span class="hljs-string"><span class="hljs-string">"640"</span></span> height=<span class="hljs-string"><span class="hljs-string">"480"</span></span> style=<span class="hljs-string"><span class="hljs-string">"position: absolute; z-index: 1"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><br>  The advantage over a single canvas is that when drawing or clearing the top, we do not affect the background.  If a game or multimedia application can be split into 2 layers, it is better to draw them in different canvases to get a significant performance boost.  The following graph compares the naive version with one canvas and the one where you redraw or clear the top layer ( <a href="http://jsperf.com/layered-canvases/3">jsperf</a> ) as needed: the <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBjeg68HDA">graph</a> . <br><br>  Often, one can benefit from flawed human perception and draw the background only once or less than the top layer (which attracts most of the user's attention).  For example, you can N draws the top layer to draw the background only 1 time. <br><br>  This method also applies to any other number of layers, if your application works better with this structure. <br><br><a name="8"></a><br><h4>  Avoid shadowBlur </h4><br>  Like other graphical environments, HTML5 canvas allows developers to blur primitives, but this operation is very expensive: <br><pre> <code class="javascript hljs">context.shadowOffsetX = <span class="hljs-number"><span class="hljs-number">5</span></span>; context.shadowOffsetY = <span class="hljs-number"><span class="hljs-number">5</span></span>; context.shadowBlur = <span class="hljs-number"><span class="hljs-number">4</span></span>; context.shadowColor = <span class="hljs-string"><span class="hljs-string">'rgba(255, 0, 0, 0.5)'</span></span>; context.fillRect(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br><br>  The test demonstrates the same scene, rendered with shadow and without shadow, and a drastic difference in performance ( <a href="http://jsperf.com/shadowblur-performance">jsperf</a> ): the <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBiwja8HDA">graph</a> . <br><br><a name="9"></a><br><h4>  Various ways to clear the screen </h4><br>  Since canvas is a paradigm of <a href="http://en.wikipedia.org/wiki/Immediate_mode">direct graphics mode</a> , the scene must be redrawn every frame.  Because of this, clearing the canvas is an operation of fundamental importance in applications and games. <br><br>  As stated in the section ‚ÄúAvoid unnecessary state changes,‚Äù clearing the entire canvas is often undesirable, but if you are required to do this, there are two ways to do this: call context.clearRect (0, 0, width, height) or use the hack: canvas.width = canvas .width ;. <br><br>  At the time of writing, clearRect overtakes width reset, but, in some cases, using width reset is much faster in Chrome 14 ( <a href="http://jsperf.com/canvas-clear-speed">jsperf</a> ): <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBj_2JEGDA">graph</a> . <br><br>  Be careful with these tricks because it depends heavily on the implementation of canvas.  For more information, see the <a href="http://simonsarris.com/blog/346-how-you-clear-your-canvas-matters">Simon Sarris article on cleaning the canvas</a> . <br><br><a name="10"></a><br><h4>  Avoid non-integer coordinates </h4><br>  HTML5 canvas supports sub-pixel rendering and there is no way to turn it off.  If you draw with non-integer coordinates, it automatically uses anti-aliasing to smooth the lines.  Here is the visual effect of sub-pixel performance from the <a href="http://sebleedelisle.com/2011/02/html5-canvas-sprite-optimisation">Seb Lee-Delisle article</a> : <br><img src="http://www.html5rocks.com/en/tutorials/canvas/performance/bunny.png" alt="bunny"><br><br>  If a smoothed sprite is not what you need, it will be much faster to translate your coordinates using Math.floor or Math.round ( <a href="http://jsperf.com/drawimage-whole-pixels">jsperf</a> ): a <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBiRk-kDDA">graph</a> . <br><br>  To translate non-integer coordinates into integers, there are several ingenious techniques, most of which are based on adding half to the number and applying bitwise operations to remove the mantis. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With a bitwise or. rounded = (0.5 + somenum) | 0; // A double bitwise not. rounded = ~~ (0.5 + somenum); // Finally, a left bitwise shift. rounded = (0.5 + somenum) &lt;&lt; 0;</span></span></code> </pre><br><br>  Full performance breakdown here ( <a href="http://jsperf.com/math-round-vs-hack/3">jsperf</a> ): <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/embed.html%3Fid%3Dagt1YS1wcm9maWxlcnINCxIEVGVzdBj36qAEDA">graph</a> . <br><br>  This optimization method will no longer make sense from the moment canvas implementations become GPU-accelerated, which allows you to quickly draw non-integer coordinates. <br><br><a name="11"></a><br><h4>  Optimize animations with `requestAnimationFrame` </h4><br>  A relatively new requestAnimationFrame API is recommended for implementing interactive applications in the browser.  Instead of ordering the browser to render at a specific frequency, you politely ask it to call rendering and let you know when it is finished.  As a nice addition, if the page is inactive, the browser is smart enough not to draw. <br><br>  The call to requestAnimationFrame is aimed at 60 FPS, but does not guarantee it, so you should keep track of how much time has passed since the last rendering.  It might look like this: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastRender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() - lastRender; x += delta; y += delta; context.fillRect(x, y, W, H); requestAnimationFrame(render); } render();</code> </pre> <br><br>  Keep in mind that using requestAnimationFrame applies to both canvas and other techniques like WebGL. <br><br>  At the time of writing, the API was only available for Chrome, Safari and Firefox, so you should use it <a href="http://paulirish.com/2011/requestanimationframe-for-smart-animating/">carefully</a> . <br><br><a name="12"></a><br><h4>  Most canvas mobile implementations are slow. </h4><br>  Let's talk about the mobile platform.  Unfortunately, at the time of writing, only iOS 5.0 beta with Safari 5.1 used canvas hardware acceleration.  Without it, mobile browsers simply do not have a sufficiently powerful CPU for modern canvas applications.  Several of the tests above demonstrate the order of decline in the performance of the mobile platform compared to the desktop, significantly limiting the types of cross-platform applications that can be expected to work successfully. <br><br><a name="13"></a><br><h4>  Conclusion </h4><br>  This article has covered an extensive set of useful optimizations that will help you develop high-performance HTML5 canvas applications.  Now that you have learned something new here, dare and optimize your incredible creations.  Or, if you do not yet have a game or application for optimization, see <a href="http://www.chromeexperiments.com/">Chrome Experiments</a> or <a href="http://creativejs.com/">Creative JS</a> for inspiration. <br><br><a name="14"></a><br><h4>  Links </h4><br><ul><li>  <a href="http://en.wikipedia.org/wiki/Immediate_mode">Immediate</a> mode vs.  <a href="http://en.wikipedia.org/wiki/Retained_mode">retained</a> mode. </li><li>  Other HTML5Rocks <a href="http://www.html5rocks.com/en/tutorials/">canvas articles</a> . </li><li>  The <a href="http://diveintohtml5.org/canvas.html">Canvas section</a> of Dive into HTML5. </li><li>  <a href="http://jsperf.com/">JSPerf</a> lets you create create JS performance tests. </li><li>  <a href="http://www.browserscope.org/">Browserscope</a> stores browser performance data. </li><li>  <a href="https://github.com/borismus/jsperfview">JSPerfView</a> , which renders JSPerf tests as charts. </li><li>  Simon's <a href="http://simonsarris.com/blog/346-how-you-clear-your-canvas-matters">blog post</a> on clearing the canvas. </li><li>  Sebastian's <a href="http://sebleedelisle.com/2011/02/html5-canvas-sprite-optimisation">blog post</a> on sub-pixel rendering performance. </li><li>  Paul's <a href="http://paulirish.com/2011/requestanimationframe-for-smart-animating/">blog post</a> using the <code>requestAnimationFrame</code> . </li><li>  Ben's <a href="http://jsconf.eu/2010/speaker/lessons_learnt_pushing_browser.html">talk</a> about optimizing a JS NES emulator. </li></ul><br><br><h4>  Selected Comments </h4><br>  <i><a href="https://habrahabr.ru/users/mikenerevarin/" class="user_link">mikenerevarin</a> <a href="http://habrahabr.ru/blogs/webdev/127014/">#</a></i> <br><blockquote>  On mobile devices, the situation is completely reversed - multilayered canvases greatly slow down, you have to use a 1 + scene prerender in the background (moreover, the div‚Äôs background is the size of a canvas and located below it, because inexplicably the background of the canvas also slows down much). <br>  In many more clever ways, it is possible to achieve quite a normal speed of work on a mobile phone. </blockquote><br>  <i><a href="https://habrahabr.ru/users/theshock/" class="user_link">Theshock</a> <a href="http://habrahabr.ru/blogs/webdev/127014/">#</a></i> <br><blockquote>  ... <br>  Judging by the code, it means that instead of each frame drawing graphic primitives, it is better to draw them once to the buffer and then draw from the buffer, and it‚Äôs true to draw a circle according to mathematical calculations, which are made in .arc or a curve, according to mathematical The calculations that are made in bezierCurveTo are much slower than just copying a picture of the appropriate size. <br><br>  But the real "double buffering" does not make much sense - the browser has its own back buffer, and the back buffer is drawn onto the main layer: <br>  1. Takes too much time. <br>  2. Prevents search bottlenecks <br>  ... </blockquote></div><p>Source: <a href="https://habr.com/ru/post/127014/">https://habr.com/ru/post/127014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127006/index.html">Short URLs on Google Maps</a></li>
<li><a href="../127007/index.html">Acceleration of parallel computing</a></li>
<li><a href="../127008/index.html">300 thousand cubs to learn English</a></li>
<li><a href="../127009/index.html">Control of DB structure change</a></li>
<li><a href="../127013/index.html">Depth of software as the ability to solve unplanned tasks</a></li>
<li><a href="../127016/index.html">Pagodabox - hosting PHP projects</a></li>
<li><a href="../127020/index.html">velcom Android Belarus a year later</a></li>
<li><a href="../127023/index.html">GStreamer: Linux-flavored codecs</a></li>
<li><a href="../127024/index.html">Steve Jobs left Apple CEO</a></li>
<li><a href="../127026/index.html">Samsung Galaxy S, S II, Ace phones are banned in Europe due to patent infringement by Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>