<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Maximum overload - adventures in JavaScript in the C ++ world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to properly extend the capabilities of a programming language using operator overloading. 

 Creators and minters of programming languages ‚Äã‚Äãare o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Maximum overload - adventures in JavaScript in the C ++ world</h1><div class="post__text post__text-html js-mediator-article">  How to properly extend the capabilities of a programming language using operator overloading. <br><br>  Creators and minters of programming languages ‚Äã‚Äãare often asked to add new features to the language.  The most frequent answer that can be heard from them is: <br><br>  "And why, after all, what you are offering can be made available with the means of the language." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Operator overloading appeared in C ++ at the request of physicists and mathematicians, who wanted to conveniently operate on self-made data types, large numbers, matrices. <br><br>  Although physicists and mathematicians liked this opportunity, programmers, including the creators of C ++, never really liked operator overloading.  Too complicated, a lot of implicitness, so overloading operators was fixed opinion of something harmful and used in rare cases. <br><br>  Today I will try to show why it is so difficult and how to properly use overload using the example of creating one new type called var whose behavior will be as close as possible to a similar type in JavaScript. <br><a name="habracut"></a><br>  That is, we will try to create a class that will be able to contain either a number, or a string, or an array, or an object.  A type that can be initialized with language literals.  A type that is correctly converted where appropriate. <br><br>  First, let's declare the class itself: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> };</code> </pre> <br><br>  (Why is struct and not class? The only difference between them is that by default all members are public in the struct. To simplify the readability of the code, there will be a struct.) <br><br>  Let's try to put a numeric value and a string value into var: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> num; };</code> </pre><br><br>  Now you need to write constructors.  They are called when you write: <br><br><pre> <code class="cpp hljs">var i = <span class="hljs-number"><span class="hljs-number">100</span></span>; var s = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> num; var (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> initial) { num = initial; } var (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *initial) { str = initial; } }</code> </pre><br><br>  Great, now that everything comes alive, we need to display the value on the screen: <br><br><pre> <code class="cpp hljs">var i = <span class="hljs-number"><span class="hljs-number">100</span></span>, s = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(i); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(s);</code> </pre><br><br>  How to achieve this? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var x)</span></span></span><span class="hljs-function"> </span></span>{ ....     ? }</code> </pre><br><br>  How do we know which of the two contents is used in a given var instance? <br><br>  Clearly, you need to add an internal type.  But how to do that?  It is logical to use enum: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> varType { varNum, varStr };</code> </pre><br><br>  Change the class definition: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> varType type; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> num; var (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> initial); var (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *initial); };</code> </pre><br><br>  Now in the constructors you need to assign the type: <br><br><pre> <code class="cpp hljs">var::var (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> initial) { type = varNum; num = initial; } var::var (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *initial) { type = varStr; str = initial; }</code> </pre><br><br>  Well, now you can return to log (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varNum) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%f\n"</span></span>, x.num); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varStr) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, x.str); }</code> </pre><br><br>  And now we need to block the assignment operator: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> initial) { type = varNum; num = initial; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *initial) { type = varStr; str = initial; }</code> </pre><br><br>  Now you can write: <br><br><pre> <code class="cpp hljs">var a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>;</code> </pre><br><br>  Interestingly, the assignment operator is a complete copy of the constructor.  Maybe worth re-use?  So do.  Everywhere in the "assignment designer" you can simply call the "assignment operator". <br><br>  At the moment here is our full working code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; enum varType { varNum, varStr }; struct var { varType type; char *str; double num; var (double initial); var (char *initial); void operator = (double initial); void operator = (char *initial); }; var::var (double initial) { (*this) = initial; } var::var (char *initial) { (*this) = initial; } void var::operator = (double initial) { type = varNum; num = initial; } void var::operator = (char *initial) { type = varStr; str = initial; } void log(var x) { if (x.type == varNum) printf("%f\n", x.num); if (x.type == varStr) printf("%s\n", x.str); } int main() { var x = 100, s = "hello"; log(x); log(s); }</span></span></span></span></code> </pre><br><br>  And what if we just write: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var y; }</code> </pre><br><br>  The compiler will curse us!  We cannot declare a variable without initializing it.  Disorder, what's the matter?  And the fact that all of our designers require initial values. <br><br>  We need an ‚Äúempty‚Äù constructor, which is the default constructor, the default constructor.  But what will the variable be equal to if it is not equal yet?  It is not yet known whether it will be a number or a string, or something else. <br><br>  To do this, we introduce the concept of "empty value", known as null or undefined. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> varType { varNull, varNum, varStr }; var::var() { type = varNull; }</code> </pre><br><br>  Now you can simply declare variables without thinking about the type. <br><br><pre> <code class="cpp hljs">var a, b, c;</code> </pre><br><br>  And already in the code to assign values: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span>; b = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>;</code> </pre><br><br>  But we still can not write: <br><br><pre> <code class="cpp hljs">a = b;</code> </pre><br><br>  We need an assignment operator var = var: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (var src) { type = src.type; num = src.num; str = src.str; }</code> </pre><br><br>  At assignment the type will change!  And "a" will be a string. <br><br>  Let's try to move on.  Temporarily forget that our numbers and strings are unfinished.  Let's try to do an array. <br><br>  First we need a new type in enum: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> varType { varNull, varNum, varStr, varArr };</code> </pre><br><br>  Now the pointer to the buffer elements, and size: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; var *arr; ... }</code> </pre><br><br>  Now we will overload the access operator for the element: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... var <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i); ... }</code> </pre><br><br>  Such an operator is called a ‚Äúsubscript operator‚Äù or index operator. <br><br>  Our goal: to store in the array elements of type var.  That is, we are talking about recursion. <br><br>  By the way, by the same operator, we will have to refer to individual characters in the string, and to the properties of the object.  But in the case of an object, the input will be a string.  After all, the key is a string value: <br><br><pre> <code class="cpp hljs">var <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *key);</code> </pre><br><br>  No, that is no good.  We do not need a pointer to a character buffer, but a string; we do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... var <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](var key); ... }</code> </pre><br><br>  Then, when everything works, we can write: <br><br><pre> <code class="cpp hljs">x[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br><br>  or <br><br><pre> <code class="cpp hljs">x[<span class="hljs-string"><span class="hljs-string">"foo"</span></span>]</code> </pre><br><br>  The compiler converts to var!  Why?  After all, we already have constructors from literals of numbers and strings. <br><br>  It will be possible to write like this: <br><br><pre> <code class="cpp hljs">y = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; x[y];</code> </pre><br><br>  By the way, a literal, (literal) is a ‚Äúliteral meaning,‚Äù that is, the value that you typed directly in the code.  For example, the assignment ‚Äúint a = b;‚Äù is an assignment by name, and ‚Äúint a = 123;‚Äù is a literal assignment, a literal assignment, ‚Äúby literal‚Äù 123. <br><br>  One thing is not clear how var becomes an array?  Suppose we create a variable "a", and how to say that this is an array? <br><br><pre> <code class="cpp hljs">var a ???;</code> </pre><br><br>  JavaScript uses several methods: <br><br><pre> <code class="cpp hljs">var a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Array; var a = [];</code> </pre><br><br>  Let's try both: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">var </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var R; R.type = varArr; R.size = <span class="hljs-number"><span class="hljs-number">0</span></span>; R.arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> var [<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R; }</code> </pre><br><br>  So far, in order to focus on more significant things, we will pretend that 10 elements are all we need. <br><br>  Now for an interesting point, try to do something like: <br><br><pre> <code class="cpp hljs">var a = [];</code> </pre><br><br>  You cannot use [] in C ++, but you can use any identifier, that is, a name.  For example Array. <br><br><pre> <code class="cpp hljs">var a = Array;</code> </pre><br><br>  How to do it?  To do this, apply the "syntactic type", like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> varSyntax { Array };</code> </pre><br><br>  Wherever we mention the word ‚ÄúArray‚Äù, the compiler will figure out that the ‚ÄúvarSyntax‚Äù type is needed.  But the compiler chooses by type what function, constructor or operator to use. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... var (varSyntax initial) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initial == Array) { type = varArr; size = <span class="hljs-number"><span class="hljs-number">0</span></span>; arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> var[<span class="hljs-number"><span class="hljs-number">10</span></span>]; } } ... } var a = Array;</code> </pre><br><br>  Of course, where the constructor is, there is the assignment, we immediately recall and write the assignment operator of the varSyntax type. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(varSyntax initial) { ... }</code> </pre><br><br>  In the following code, first ‚Äúa‚Äù is initialized by the constructor var (varSyntax), and then ‚Äúb‚Äù is initialized by the empty constructor and assigned by the operator ‚Äúvar operator = (varSyntax)‚Äù. <br><br><pre> <code class="cpp hljs">var a = Array, b; b = Array;</code> </pre><br><br>  Since the constructor and the assignment through the "=" always go as a pair, it is logical to apply the same trick, and in the constructor reuse the code from the assignment. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... var (varSyntax initial) { (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) = initial; } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (var Syntax); ... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (varSyntax initial) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initial == Array) { type = varArr; size = <span class="hljs-number"><span class="hljs-number">0</span></span>; arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> var*[<span class="hljs-number"><span class="hljs-number">10</span></span>]; } <span class="hljs-comment"><span class="hljs-comment">// else if (initial == Object) { // ... // } }</span></span></code> </pre><br><br>  Somewhere, there, we will be able to create empty objects.  But that later. <br><br>  Well, it's time to try: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var a = Array; a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br><br><pre> <code class="cpp hljs">error: conversion from <span class="hljs-string"><span class="hljs-string">'int'</span></span> to <span class="hljs-string"><span class="hljs-string">'var'</span></span> is ambiguous a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">100.0</span></span>;</code> </pre><br><br>  Wow, that's the thing, we declared operator [] from var.  For some reason, the compiler expects an int.  If you change var [0] to var [1] then everything will be compiled.  What? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var a = Array; a[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br><br>  So, with one, compiles ... <br><br>  Only this code will not do anything yet, because we have not written operator [] yet. <br><br>  Must write!  Probably something like this: <br><br><pre> <code class="cpp hljs">var var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](var key) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[key]; }</code> </pre><br><br><pre> <code class="cpp hljs">error: no viable overloaded <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> type <span class="hljs-string"><span class="hljs-string">'var *'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i]; ~~~^~</code> </pre><br><br>  Oh, compiler, what else is wrong? <br><br>  It turns out that index access to the pointer requires an int, and the compiler does not know how to turn a var into an int. <br><br>  Well, you can define an int operator, and there is such in C ++!  But it is better, where it is possible not to create a new operator, not to create one (long history), therefore we will do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num; } ... } var var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (var i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i.toInt()]; }</code> </pre><br><br>  Compiled, but displays nothing after launch, what's the matter? <br><br>  And how, in general, can it work?  How can you read and write the contents of an element through the same operator? <br><br>  After all, both lines should work: <br><br><pre> <code class="cpp hljs">a[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a[<span class="hljs-number"><span class="hljs-number">1</span></span>]);</code> </pre><br><br>  In one record, in another reading.  It turns out that operator = should return a reference to the element.  Pay attention to the symbol &amp;, in this case in this case: <br><br><pre> <code class="cpp hljs">var&amp; var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (var i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i.toInt()]; }</code> </pre><br><br>  But, although, ‚Äúa [1]‚Äù worked, ‚Äúa [0]‚Äù continues to swear.  Why all the same? <br><br>  The fact is that 0 can be considered both a number and a pointer, and in our case var has two constructors, one for a number (double), the other for a pointer (char *).  Because of this, it seems to be a completely normal code, when using 0 as a literal, it suddenly produces compilation errors.  This is one of the particularly sophisticated torture of C ++ and the ambiguous call series. <br><br>  But in general, the compiler first considers zero to be integer, that is, int. <br><br>  Fortunately, it is enough to teach our var to initialize from int.  As usual, we immediately write the constructor and operator =. <br><br><pre> <code class="cpp hljs">var::var (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> initial) { (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) initial; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> initial) { (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) initial; }</code> </pre><br><br>  Here, in order to reuse the code, both calls to operator = (double) are simply redirected. <br><br>  So, what happened at the moment: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; enum varType { varNull, varNum, varStr, varArr }; enum varSyntax { Array }; struct var { varType type; char *str; double num; var (); var (double initial); var (int initial); var (char *initial); void operator = (double initial); void operator = (int initial); void operator = (char *initial); var *arr; int size; var &amp;operator [](var i); var (varSyntax initial) { (*this) = initial; } void operator= (varSyntax initial); void operator= (var src) { type = src.type; num = src.num; str = src.str; arr = src.arr; } int toInt() { return num; } }; var::var() { type = varNull; } var::var (double initial) { (*this) = initial; } var::var (int initial) { (*this) = (double)initial; } var::var (char *initial) { (*this) = initial; } void var::operator = (double initial) { type = varNum; num = initial; } void var::operator = (int initial) { (*this) = (double) initial; } void var::operator = (char *initial) { type = varStr; str = initial; } void log(var x) { if (x.type == varNum) printf("%f\n", x.num); if (x.type == varStr) printf("%s\n", x.str); } void var::operator= (varSyntax initial) { if (initial == Array) { type = varArr; size = 0; arr = new var[10]; } } var &amp;var::operator[] (var i) { return arr[i.toInt()]; } int main() { var x = 100, s = "hello"; var a = Array; a[0] = 200; log(a[0]); log(x); log(s); }</span></span></span></span></code> </pre><br><br>  By the way, what if we want to display an array on the screen? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varNum) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%f\n"</span></span>, x.num); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varStr) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, x.str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varArr) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[Array]\n"</span></span>); }</code> </pre><br><br>  So far the only way. <br><br>  But I want more. <br><br>  First, you need to make the self-tuning length of the array: <br><br><pre> <code class="cpp hljs">var &amp;var::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (var i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = i.toInt(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &gt;= size) size = pos+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[pos]; }</code> </pre><br><br>  And you need to do push () - adding one element to the end: <br><br><pre> <code class="cpp hljs">var var::push(var item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type != varArr) { var nil; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nil; } (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)[size] = item; size++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; }</code> </pre><br><br>  Since we are working with a pointer, it‚Äôs not superfluous to check the type.  In the process of preparing this article, this is how the program fell.  Well, we are not checking the size yet, we are busy with global design, but we will return to this issue. <br><br>  Now you can rewrite the log () function to display the entire array: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varNum) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%f "</span></span>, x.num); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varStr) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s "</span></span>, x.str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == varArr) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.size; i++) <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(x[i]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"]"</span></span>); } }</code> </pre><br><br>  What a minimum of work needed, what life-giving recursion does! <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var a = Array; a[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">100</span></span>; a.push(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a); }</code> </pre><br><br>  Data output after launch: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">100.000000</span></span> <span class="hljs-number"><span class="hljs-number">200.000000</span></span> [<span class="hljs-number"><span class="hljs-number">100.000000</span></span> <span class="hljs-number"><span class="hljs-number">200.000000</span></span>]</code> </pre><br><br>  Well, great, we have some basic polymorphism. <br><br>  You can even put an array in an array, and interspersed with strings and numbers. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var a = Array; a.push(<span class="hljs-number"><span class="hljs-number">100</span></span>); a.push(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); a[<span class="hljs-number"><span class="hljs-number">2</span></span>] = Array; a[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; a[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a); }</code> </pre><br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">100.000000</span></span> foo [<span class="hljs-number"><span class="hljs-number">200.000000</span></span> bar ]]</code> </pre><br><br>  I wonder what will happen if we try to write this: <br><br><pre> <code class="cpp hljs">var a = Array; var b = a.push(Array); b.push(<span class="hljs-number"><span class="hljs-number">200</span></span>); b.push(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a);</code> </pre><br><br>  Here's what: <br><br><pre> <code class="cpp hljs">[[]]</code> </pre><br><br>  Why did this happen? <br><br>  Check in such a simple way: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%\n"</span></span>, a.arr[<span class="hljs-number"><span class="hljs-number">0</span></span>].size); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%\n"</span></span>, b.size);</code> </pre><br><br>  Logically, we should see the same number: 2. <br><br>  But actually a.arr [0] .size == 0! <br><br>  The thing is that a [0] and b are two DIFFERENT variables, two different instances.  At the moment when the assignment inside the a.push () function via the return occurred, their fields matched, that is, size, arr were identical, but after b.push () there was an increase in b.size, and there was no increase in a [0]. size. <br><br>  This is a brainwashing problem that is even difficult to describe in words, and perhaps the reader is completely confused while reading the last lines, called ‚Äúpass by reference‚Äù (pass by reference). <br><br>  In C ++, usually, passing by reference is called when the argument is preceded by &amp;, but this is a special case.  In general, this means that changing the copy changes the original. <br><br>  Let's see how to solve this problem.  At first, everything connected with the array will be put into a separate class, so historically, I called it lst.  Especially do not go into his device, so grab the general essence: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> var** P; P p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capacity, size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeroInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: lst(); ~lst(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newsize)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">var </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var &amp;a)</span></span></span></span>; var&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delIns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delCount, var *item, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> insCount)</span></span></span></span>; };</code> </pre><br><br>  Let me explain that this is a small class for storing a list of pointers with the ability to dynamically change the size, and additional <code>push/pop/delIns</code> . <br><br>  This is all we need to ensure that our arrays closely match the JavaScript Array. <br><br>  Now, let's forget how ‚Äúvar‚Äù was arranged before, and try to write ‚Äúlst‚Äù into it correctly: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uses; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; Ref () { uses = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> {</span></span> varType type; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> num; Ref* ref; }; ... };</code> </pre><br><br>  First, we combined num and ref, because all the same at the same time we do not need these properties.  Memory saving. <br><br>  Secondly, instead of the direct value of everything connected with the array, we will have a link with the counter inside.  This is called reference counting. <br><br>  In the same link, we will then store the Object. <br><br>  Note that the counter is immediately set to 1. <br><br>  Whenever reference counting is programmed, two basic methods are written immediately, the ‚Äúconnector‚Äù and the ‚Äúconnector‚Äù. <br><br>  The first is ‚Äúref = src.ref, ref-&gt; uses ++‚Äù, usually it is called copy, link, attach, or, actually, reference. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::copy(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> var &amp;a) { <span class="hljs-comment"><span class="hljs-comment">//       . type = a.type; if (type == varNum || type == varBool) num = a.num; else { if (a.type == varNull) { return; } ref = a.ref; if (ref) ref-&gt;uses++; } }</span></span></code> </pre><br><br>  Secondly, the reverse process occurs, the usage counter decreases, and if it becomes zero, the original memory is freed. <br><br>  It is usually called unlink, unreference, detach.  I used to call it unref (). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> var::unref() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == varNum || type == varNull || type == varBool) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == varStr) { ref-&gt;uses--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ref-&gt;uses == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> (chr*)ref-&gt;data, <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ref; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == varArr) { ref-&gt;uses--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ref-&gt;uses == <span class="hljs-number"><span class="hljs-number">0</span></span>) { deleteLst(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == varObj) { ref-&gt;uses--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ref-&gt;uses == <span class="hljs-number"><span class="hljs-number">0</span></span>) { deleteObj(); } } type = varNull; ref = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  data in the Ref structure is of type void *, that is, just a pointer, and will store a reference to the actual instance of the array (lst) or object (obj).  When we say an object, we are talking about the object in which we will store key / value pairs in accordance with JavaScript [Object object]. <br><br>  In essence, reference counting is a form of garbage collection. <br><br>  Usually with the words "garbage collector" (garbage collector, GC) they mean an interval collector that runs on a timer, but technically reference counting is the simplest garbage collector, even according to Wikipedia classification. <br><br>  And, as you can see, it is not so simple, you can break the brain at times. <br><br>  Just so that the reader is not confused, I will repeat everything from the beginning: <br><br>  We make a class var and in it we encapsulate either a double, or lst (for an array), or chr (for strings), or keyval (for objects). <br><br>  Here is our class for working with strings: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> *s; chr (); ~chr(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUtf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAscii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAscii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUtf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toNumber</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intToStr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dblToStr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmp</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chr &amp;other)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subsize)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">chr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">substr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _strcount(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chr &amp;substring); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _cpto(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chr &amp;dest, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count); <span class="hljs-function"><span class="hljs-function">chr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(chr &amp;A, chr &amp;B, chr &amp;dest)</span></span></span></span>; };</code> </pre><br><br>  And here is a class for objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyval</span></span></span><span class="hljs-class"> {</span></span> var keys, vals; keyval (); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var key, var val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">var &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var key)</span></span></span></span>; };</code> </pre><br><br>  There is already complete recursion and polymorphism, see, keyval uses arrays in the form of var.  To become part of the var.  And it works! <br><br>  One of the most important features of using reference counting is that if you want to change an object, you must understand that all who refer to it will also receive a modified object. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var t)</span></span></span><span class="hljs-function"> </span></span>{ t += <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(t); } var s = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; f(s); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(s);</code> </pre><br><br>  Conclusion: <br><br><pre> <code class="cpp hljs">world world</code> </pre><br><br>  When transferring s to f () instead of copying all the characters of a string, only one pointer is copied and one counter is incremented. <br><br>  But after changing the string t, the string s will also change.  What we need in the case of arrays, but not in the case of strings!  This is called pass-by-reference. <br><br>  When we need the variable passed through reference counting to be changed separately from its source code, we must call the detach / unref / unlink function before each change. <br><br>  This is how Delphi strings work, for example.  This is called the term copy-on-write. <br><br>  This is considered a bad decision.  But how to refuse from copy-on-write, but to preserve the possibility of pass-by-reference and copy-pointer-and-increment (reference counting)? <br><br>  The answer has become the standard of modern programming: instead of changing the variable, make it unchanged!  This is called immutability - immutability. <br><br>  According to the principle of immutability, strings in JavaScript are set only once, and after that they cannot be changed.  All functions of working with strings that change something, cause new strings.  This greatly facilitates the hard work of carefully arranging all copy / unref, pointer checks and other work with memory. <br><br>  Here, suddenly, I have to interrupt, because the article has exceeded 20K characters that are comfortable for the reader.  But still it is necessary to overload about 20 operators!  Even operator, (comma).  Combine objects and arrays, write JSON.parse, implement comparisons of strings and booleans, write a constructor for Boolean, invent and implement a notation for initializing the values ‚Äã‚Äãof arrays and objects, solve the problem of multi-argument log (...), think of what to do with undefined, typeof , correctly implement replace / slice, etc.  And all this without a single template, only operator overloading and functions. <br><br>  So, if you are interested, we will soon continue. <br><br>  For the most curious, a link to the library repository: <br><br>  <a href="https://github.com/exebook/jslike">github.com/exebook/jslike</a> </div><p>Source: <a href="https://habr.com/ru/post/261351/">https://habr.com/ru/post/261351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261339/index.html">It's hard to go simplicity</a></li>
<li><a href="../261341/index.html">How search and parsing of chenjlogs is arranged in AllMyChanges</a></li>
<li><a href="../261345/index.html">Effective logo design, part 2: using natural templates</a></li>
<li><a href="../261347/index.html">A library that facilitates the development of forms on sites</a></li>
<li><a href="../261349/index.html">Compile-time reflection D</a></li>
<li><a href="../261353/index.html">Cordova 5.1.1 and plugin updates</a></li>
<li><a href="../261355/index.html">NetBackup 7.6 Implementation Experience</a></li>
<li><a href="../261359/index.html">Where are my files, ROBOCOPY?</a></li>
<li><a href="../261361/index.html">Stuck heads fore WiFi equipment manufacturers. (I apologize wildly, but Ruckus did everyone again)</a></li>
<li><a href="../261363/index.html">HP Education Day - a bit of everything HP has</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>