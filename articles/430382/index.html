<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript Guide, Part 4: Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we publish the fourth part of the translation of the JavaScript guide, which is dedicated to functions. 

 ‚Üí Part 1: first program, language fea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript Guide, Part 4: Functions</h1><div class="post__text post__text-html js-mediator-article">  Today we publish the fourth part of the translation of the JavaScript guide, which is dedicated to functions. <br><br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429552/">Part 1: first program, language features, standards</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429556/">Part 2: code style and program structure</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429838/">Part 3: Variables, Data Types, Expressions, Objects</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430382/">Part 4: Functions</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430380/">Part 5: Arrays and Loops</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430376/">Part 6: Exceptions, Semicolon, Pattern Literals</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431072/">Part 7: strict mode, this keyword, events, modules, mathematical calculations</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431074/">Part 8: ES6 feature overview</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431872/">Part 9: Overview of ES7, ES8, and ES9 Capabilities</a> <br><br> <a href="https://habr.com/company/ruvds/blog/430382/"><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#3AC1EF">Javascript functions</font> </h2><br>  Let's talk about the functions in JavaScript, we will do their general overview and consider the details about them, the knowledge of which will allow you to use them effectively. <br><a name="habracut"></a><br>  A function is an independent block of code that, once declared, can be called as many times as necessary.  The function may, although not necessarily, take parameters.  Functions return a single value. <br><br>  Functions in JavaScript are objects, more precisely, they are objects of type <code>Function</code> .  Their key difference from ordinary objects, giving them the exceptional capabilities they possess, is that functions can be called. <br><br>  In addition, functions in JavaScript are called ‚Äúfirst-class functions,‚Äù since they can be assigned to variables, they can be passed to other functions as arguments, and they can be returned from other functions. <br><br>  First, we will consider the features of working with functions and the corresponding syntactic constructions that existed in the language before the advent of the ES6 standard and are still relevant. <br><br>  This is what a function declaration looks like. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Nowadays, these functions are called "normal", distinguishing them from the "arrow" functions that appeared in ES6. <br><br>  The function can be assigned to a variable or a constant.  Such a construction is called a functional expression (function expression). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  You can see that in the above example, the function is assigned to a constant, but it itself does not have a name.  Such functions are called anonymous.  You can assign names to similar functions.  In this case, we are talking about a named function expression (named function expression). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  The use of such expressions increases the convenience of debugging (in error messages where the stack is traced, you can see the name of the function).  The function name in a functional expression may also be needed in order that the function could call itself, which cannot be dispensed with when implementing recursive algorithms. <br><br>  In the ES6 standard, there are arrow functions (arrow function), which are especially convenient to use in the form of so-called "inline functions" (inline functions) - as arguments passed to other functions (callbacks). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  The switch functions, in addition to the fact that the structures used to declare them, are more compact than when using ordinary functions, differ from them in some important features, which we will discuss below. <br><br><h2>  <font color="#3AC1EF">Function Parameters</font> </h2><br>  Parameters are variables that are set at the stage of the function declaration and will contain the values ‚Äã‚Äãpassed to it (these values ‚Äã‚Äãare called arguments).  Functions in JavaScript may either not have parameters, or have one or more parameters. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br>  Here are some examples of switch functions. <br><br>  Beginning with the ES6 standard, functions may have so-called default parameters. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  They are standard values ‚Äã‚Äãthat are set to the parameters of functions in the event that when it is invoked, the values ‚Äã‚Äãof some parameters are not specified.  For example, the function shown above can be called both with the transfer of all two parameters it takes, as well as in other ways. <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br>  In ES8, it is possible to put a comma after the last argument of a function (this is called trailing comma).  This feature allows you to improve the convenience of editing code when using version control systems during program development.  Details about this can be found <a href="https://habr.com/company/ruvds/blog/353174/">here</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas">here</a> . <br><br>  The arguments passed to the functions can be represented as arrays.  In order to parse these arguments, you can use an operator that looks like three points (this is the so-called "extension operator" or "spread operator").  Here's what it looks like. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br>  If functions need to take a lot of parameters, then remembering the order of their sequence can be difficult.  In such cases, objects with parameters and possibilities for destructuring ES6 objects are used. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br>  This method allows, describing parameters in the form of an object's properties and passing an object to a function, to gain access to parameters by their names without using additional constructions.  You can read more about this technique <a href="https://habr.com/company/ruvds/blog/354676/">here</a> . <br><br><h2>  <font color="#3AC1EF">Values ‚Äã‚Äãreturned from functions</font> </h2><br>  All functions return some value.  If the return command is not explicitly specified, the function will return <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br>  The execution of the function is completed either after all the code it contains is executed, or after the <code>return</code> keyword is found in the code.  When this keyword is encountered in a function, its work is completed, and control is transferred to the place from which the function was called. <br><br>  If after the <code>return</code> keyword you specify a certain value, then this value is returned to the place where the function is called as a result of the execution of this function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br>  Only one value can be returned from the function.  In order to be able to return multiple values, you can return them either as an object, using an object literal, or as an array, and when you call a function, use the structure of destructuring assignment.  The names of the parameters are saved.  In this case, if you need to work with an object or an array returned from a function, namely in the form of an object or an array, you can do without destructuring assignment. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br>  The <code>const [ name, age ] = doSomething()</code> can be read as follows: ‚Äúdeclare the <code>name</code> and <code>age</code> constants and assign them the values ‚Äã‚Äãof the array elements that the function returns‚Äù. <br>  Here's how the same thing looks like using an object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Nested functions</font> </h2><br>  Functions can be declared inside other functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br>  The scope of a nested function is limited to a function external to it; it cannot be called from outside. <br><br><h2>  <font color="#3AC1EF">Object methods</font> </h2><br>  When functions are used as properties of objects, such functions are called object methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">Keyword this</font> </h2><br>  If we compare the pointer and the usual functions used as methods of objects, we can find their important distinction, which consists in the sense of the keyword <code>this</code> .  Consider an example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br>  As you can see, calling the <code>start()</code> method leads to the expected result, but the <code>stop()</code> method obviously does not work correctly. <br><br>  This is due to the fact that the this keyword behaves differently when used in the switch and normal functions.  Namely, the keyword <code>this</code> in the arrow function contains a link to the context that includes the function.  In this case, when it comes to the browser, this context is the <code>window</code> object. <br><br>  Here is how the execution of such code in the browser console <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">Features of this keyword in normal and switch functions</font></i> <br><br>  As you can see, the call to this in a normal function means the call to the object, and <code>this</code> in the arrow function points to the <code>window</code> . <br><br>  All this means that the arrow functions are not suitable for the role of methods of objects and constructors (if you try to use the arrow function as a constructor, you will get a <code>TypeError</code> error). <br><br><h2>  <font color="#3AC1EF">Immediate Functional Expressions</font> </h2><br>  Immediately invoked functional expression (Immediately Invoked Function Expression, IIFE) is a function that is automatically called immediately after its declaration. <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  Semicolon before IIFE is optional, but its use allows you to insure against errors associated with the automatic placement of semicolons. <br><br>  In the above example, the word ‚Äú <code>executed</code> ‚Äù will go to the console, after which IIFE will exit.  IIFE, just like other functions, can return the results of their work. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br>  After executing this simple example, the line <code>IIFE</code> will <code>IIFE</code> in the console, which will be in the constant <code>something</code> after executing the immediately called functional expression.  It may seem that there is no special benefit from such a construction.  However, if some complex calculations are performed in IIFE, which need to be performed only once, after which the corresponding mechanisms are unnecessary - the utility of IIFE turns out to be obvious.  Namely, with such an approach, after the execution of IIFE, only the result returned by the function will be available in the program.  In addition, you can remember that functions can return other functions and objects.  We are talking about closures, we will talk about them below. <br><br><h2>  <font color="#3AC1EF">Elevation of functions</font> </h2><br>  Before executing the JavaScript code, it is reorganized.  We already talked about the mechanism of raising (hoisting) variables declared using the <code>var</code> keyword.  A similar mechanism works when working with functions.  Namely, we are talking about the fact that the function declarations in the course of processing the code are moved to the upper part of their scope before its execution.  As a result, for example, it turns out that you can call a function before its declaration. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br>  If you move a function call so that it goes after its declaration, nothing will change. <br><br>  If in a similar situation to use a functional expression, then a similar code will generate an error. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br>  In this case, it turns out that although the declaration of the <code>doSomething</code> variable rises to the top of the scope, this does not apply to an assignment operation. <br>  If instead of <code>var</code> in a similar situation to use the keywords <code>let</code> or <code>const</code> , such code will not work either, however, the system will <code>TypeError</code> another error message ( <code>ReferenceError</code> and not <code>TypeError</code> ), since when using <code>let</code> and <code>const</code> declarations of variables and constants are not raised. <br><br><h2>  <font color="#3AC1EF">Arrow functions</font> </h2><br>  Now we will talk more about the switch functions with which we have already met.  They can be considered one of the most significant innovations of the ES6 standard; they differ from ordinary functions not only in appearance, but also in behavioral features.  Today they are used extremely widely.  Perhaps, there is not a single modern project where they would not be used in the overwhelming majority of cases.  We can say that their appearance has forever changed the appearance of the JS-code and the features of its work. <br><br>  From a purely external point of view, the syntax of declaring switch functions is more compact than the syntax of ordinary functions.  Here is the declaration of the usual function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Here is the declaration of the switch function, which, in general, if one does not take into account the features of the switch functions, is similar to the previous one. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  If the body of the arrow function contains only one command, the result of which is returned by this function, it can be written without braces and without the keyword <code>return</code> .  For example, such a function returns the sum of the arguments passed to it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br>  As you can see, the parameters of the switch functions, as in the case of ordinary functions, are described in brackets.  At the same time, if such a function takes only one parameter, it can be specified without brackets.  For example, here is a function that returns the result of dividing the number passed to it by 2. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br>  As a result, it turns out that arrow functions are very convenient to use in situations in which small functions are needed. <br><br><h3>  <font color="#3AC1EF">‚ñç Implicit return of function results</font> </h3><br>  We have already dealt with this feature of the switch functions, but it is so important that it should be discussed in more detail.  The point is that single-line arrow functions support implicit return of the results of their work.  We have already seen an example of returning a primitive value from a single-line arrow function.  What if such a function should return an object?  In this case, the curly brackets of the object literal can confuse the system, so parentheses are used in the body of the function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçThe keyword this and arrow functions</font> </h3><br>  Above, when we looked at the features of the <code>this</code> , we compared ordinary and arrow functions.  This section is intended to draw your attention to the importance of their differences.  The keyword <code>this</code> , in itself, can cause certain difficulties, since it depends on the context of the code execution and on whether strict mode is enabled or not. <br><br>  As we have seen, when using the <code>this</code> in the method of an object represented by a normal function, <code>this</code> points to the object that owns the method.  In this case, they talk about binding the keyword <code>this</code> to a value that represents the context of the execution of the function.  In particular, if the function is called as an object method, then the this keyword is bound to this object. <br><br>  In the case of pointer functions, it turns out that the <code>this</code> binding is not performed in them, they use the <code>this</code> from the scopes containing them.  As a result, they are not recommended for use as object methods. <br><br>  The same problem arises when using functions as event handlers for DOM elements.  For example, the HTML <code>button</code> element is used to describe the buttons.  The <code>click</code> event is triggered when the mouse is clicked.  In order to respond to this event in the code, you must first get a link to the corresponding element, and then assign it a <code>click</code> event handler as a function.  As such a handler, you can use both a regular function and an arrow function.  But, if in the event handler you need to refer to the element for which it is called (that is, to <code>this</code> ), the pointer function will not work here, since the value of <code>this</code> available in it points to the <code>window</code> object.  To test this in practice, create an HTML page, the code for which is shown below, and click on the buttons. <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  In this case, clicking on these buttons will display windows containing <code>true</code> .  However, in the <code>click</code> event handler of the button with the <code>fn</code> identifier, <code>this</code> checked for the button itself, and in the button with the <code>arrowFn</code> identifier, the equality of <code>this</code> and the <code>window</code> object is checked. <br><br>  As a result, if in the event handler of the HTML element you need to refer to <code>this</code> , the switch function for processing such a handler will not work. <br><br><h2>  <font color="#3AC1EF">Closures</font> </h2><br>  Closures are an important concept in JavaScript.  In fact, if you wrote JS functions, then you also used closures.  Closures are used in some design patterns, in case you need to organize strict control of access to certain data or functions. <br><br>  When a function is invoked, it has access to everything that is in its external scope.  But to what is declared inside the function, there is no access from the outside.  That is, if a variable (or another function) was declared in the function, they are inaccessible to the external code neither during the execution of the function, nor after its completion.  However, if another function is returned from the function, this new function will have access to all that was declared in the original function.  In this case, all this will be hidden from the external code in the closure. <br><br>  Consider an example.  Here is the function that takes the name of the dog, after which it displays it in the console. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  The value returned by this function does not interest us yet, the text is output to the console using IIFE, which in this case does not play a special role, however, it will help us see the connection between this function and its variant, in which, instead of calling a function that outputs text to the console, we will return this function from the rewritten <code>bark()</code> function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  The result of the code in two cases is the same.  But in the second case, what was passed to the original function when it was called (the name of the dog, <code>Roger</code> ) is stored in the closure, after which it is used by another function returned from the original one. <br><br>  We will conduct another experiment - we will create, using the original function, two new ones for different dogs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br>  This code will output the following. <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br>  It turns out that the value of the <code>say</code> constant is bound to a function that is returned from the <code>prepareBark()</code> function. <br><br>  Note that the <code>say</code> , when you call the <code>prepareBark()</code> again, gets a new value, and the value recorded in the <code>say</code> when you first call <code>prepareBark()</code> does not change.  The point is that each time this function is called, a new closure is created. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we talked about normal and switch functions, about the features of their declaration and use, about how the keyword <code>this</code> behaves in different situations, and about closures.  Next time we will discuss arrays and loops. <br><br>  <b>Dear readers!</b>  How do you feel about the arrow functions in JavaScript? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/430382/">https://habr.com/ru/post/430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430372/index.html">Car on hydrogen. Is it time to say goodbye to gasoline?</a></li>
<li><a href="../430374/index.html">Data Engineering and more: videotapes and slides from the mitap in Wrike</a></li>
<li><a href="../430376/index.html">JavaScript Guide, Part 6: Exceptions, Semicolon, Pattern Literals</a></li>
<li><a href="../430378/index.html">J2CL - Better Late Than Never</a></li>
<li><a href="../430380/index.html">JavaScript Guide, Part 5: Arrays and Loops</a></li>
<li><a href="../430384/index.html">Creating maps of noise functions</a></li>
<li><a href="../430386/index.html">India to build solid state storage power plant</a></li>
<li><a href="../430388/index.html">Unconference Web Summit</a></li>
<li><a href="../430390/index.html">Introvert path in career and business</a></li>
<li><a href="../430394/index.html">Implementing Instant Android Search with RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>