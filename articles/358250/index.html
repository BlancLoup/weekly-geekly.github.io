<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UI components on pixel shaders: write your first shader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who can be called "pixel shaders chief and pixel commander"? Denis Radin , working in Evolution Gaming on photo-realistic web games using React and We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UI components on pixel shaders: write your first shader</h1><div class="post__text post__text-html js-mediator-article">  Who can be called "pixel shaders chief and pixel commander"?  <b>Denis Radin</b> , working in Evolution Gaming on photo-realistic web games using React and WebGL: he is known to many just by the name Pixels Commander. <br><br>  In December, at our HolyJS conference, he gave a talk on how using GLSL can improve work with UI components as compared to ‚Äúregular javascript‚Äù.  And now for Habr we have prepared a text version of this report - welcome under the cut!  At the same time we attach a video of the performance: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P-OOg9z4OUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  First, a question to the audience: how many languages ‚Äã‚Äãare well supported on the web?  (Voice from the audience: ‚ÄúNot one!‚Äù) <br>  Well, languages ‚Äã‚Äãin the browser, let's say.  Three?  Let's assume that there are four of them: HTML, CSS, JS and SVG.  SVG can also be considered a declarative language, another type, it is still not HTML. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But in fact they are even more.  There is VRML, he died, it can not be considered.  And there is GLSL (‚ÄúOpenGL Shading Language‚Äù).  And GLSL is a very special language for the web. <br><br>  Because the rest (JS, CSS, HTML) originated on the web, and from web pages they started a victorious march on other platforms (for example, mobile).  And GLSL originated in the world of computer graphics, in C ++, and came to the web from there.  And what's great about it: it works wherever OpenGL works, so if you learn it, you can use it anywhere (in Unity, Swift, Java, and so on). <br><br>  GLSL is behind crazy special effects in computer games.  And I like that it can be used to develop interesting and unusual UI components, later we will talk about them.  It is also a technology for parallel computing, which means that you can mine cryptocurrency using GLSL.  What are interested? <br><br><h2>  Story </h2><br>  Let's start with the history of GLSL.  When and why did he appear?  This chart displays the OpenGL rendering pipeline: <br><br><img src="https://habrastorage.org/webt/mx/4u/k3/mx4uk3nrxomukyacwn20lqmqpvm.jpeg"><br><br>  Initially, in the first version of OpenGL, the rendering pipeline looked like this: vertices are fed to the input, primitives are gathered from the vertices, the primitives are rasterized, clipping occurs and then the framebuffer is output. <br><br>  There is a problem here: it is not customized.  Since we have a well-defined pipeline, textures can be loaded there, but you can‚Äôt do anything special with any exact request. <br><br>  Let's look at the simplest example: draw a fog.  There is a scene.  It all consists of vertices, texture is applied to them.  In the first version of OpenGL, it looked like this: <br><br><img src="https://habrastorage.org/webt/w6/62/_g/w662_gp2k26m5ebx6zza5milwgm.jpeg"><br><br>  How can I make a fog?  In the formula, fogvalue is the distance to the camera multiplied by the fog density, and the pixel color is equal to the current pixel color multiplied by the fog color and the amount of fog.  If we perform this operation for each pixel on the screen, we will get the following result: <br><br><img src="https://habrastorage.org/webt/ys/hr/ij/yshrij4nsdd0rczpnceaay2lh7c.jpeg"><br><br>  GLSL shaders appeared in 2004 in OpenGL v2, and this was the biggest breakthrough in the history of OpenGL.  It appeared in 1991, and now, after 13 years, the next version was released. <br><br>  From now on, the rendering pipeline began to look like this: <br><br><img src="https://habrastorage.org/webt/ae/oa/cc/aeoaccepxblje6lbe3rwgg5ih0k.jpeg"><br><br>  Vertices are fed to the input, here the first vertex shader is executed, which allows you to change the geometry of the object, then primitives are built, they are rasterized, then a fragmentary shader is executed (‚Äúfragmentary‚Äù means ‚Äúpixel‚Äù, in English terminology the ‚Äúfragment shader‚Äù is often used), then clipped and displayed on screen. <br><br>  Okay, let's talk about some of the features of GLSL, because it has so many, many things that are unusual and sound strange, for JS developers so accurately. <br><br>  Well, first, what is important for us, for web developers: GLSL is part of the WebGL specification.  The gateway to GLSL will be &lt;canvas /&gt;. <br><br>  GLSL is compiled using a GPU driver.  Because of this, it is cross-platform, since it is compiled for each specific platform, and it is amazingly fast.  It is very fast, thousands of times faster than JavaScript, because it compiles specifically for the platform and runs on a special piece of hardware for which it was intended. <br><br>  At the same time, it is launched into many processes, for example, a card; if you follow the news of iron, a GTX 970 card, it simultaneously runs 1664 shader processes.  Imagine how much you can mine? <br><br>  In general, this way the mining is performed, and everything else, all parallel computations are CUDA platforms, they work through shaders.  They come in many forms, not always GLSL, but on the web we have GLSL shaders, part of the OpenGL specification. <br><br>  There are certain features associated with the fact that data is sent only once.  Since the execution is parallel, for the entire passage, for the entire screen, the data is loaded into the shader once, and this should be taken into account. <br><br>  GLSL is a strongly typed language.  There are types float, integer, boolean, vectors 2-3-4 component (which, in fact, are 2-3-4-element arrays), 2-3-4-dimensional matrices also exist. <br><br>  It is a language sharpened by mathematics, and it has all the wonderful trigonometric and mathematical functions that you can imagine: radians to degrees, degrees to radians, sine, arc cosine, tangent, matrix multiplication, multiplication of vectors, various derivatives, etc. . <br><br><h2>  Practice </h2><br>  Good.  From theory let's move on to practice.  Consider the simplest pixel shader. <br><br><img src="https://habrastorage.org/webt/gx/ev/ud/gxevuduimymwtjh_opag01ysgbo.png"><br><br>  First we set the radius of the circle, it is a variable of type float.  Then the center is a two-component vector.  Notice that the origin in GLSL is not in the upper left, but in the lower left.  You can play around a bit with the coordinates, move this circle somewhere. <br><br>  Then comes the main function, which is the entry point to any shader.  It first calculates the distance to the center using the built-in function distance, the coordinates of the current pixel and the coordinates of the center. <br><br>  Further, the inCircle float variable is calculated: if our pixel is inside the circle, it is equal to one, and if outside it is zero. <br><br>  And the last operation is the outgoing parameter gl_FragColor, which determines the color that will be on the screen.  We assign him the above inCircle.  That is, if we are inside a circle, there will be one here. <br><br>  This is a very interesting shorthand: a four-component vector is created from one float variable, the value of this variable is assigned to all the components of the vector at once.  It uses RGBA notation, that is, four components are RGB and alpha channel. <br><br>  And you can change it like this: <br><br><img src="https://habrastorage.org/webt/jf/f8/az/jff8azm3ie0bshgyq0o0a91xats.png"><br><br>  What's going on here?  We assign the resulting value not to all channels at once, but only to green. <br><br>  Okay, let's move on from the simplest example, which is practically useless, to solving a practical problem.  One day, on a sad Amsterdam autumn morning, I received a task at JIRA, which made my life a little more fun. <br><br>  The task was about spinner.  We wrote an operating system on JS, and we had such a cool spinner in the OS.  It worked, but there was one small problem: when there was some kind of background-process, the spinner sometimes twitched.  I was asked to figure it out. <br><br><img src="https://habrastorage.org/webt/xg/le/x-/xglex-qhjwqukrsmgx4gjyinn4u.gif"><br><br>  I began to dig and saw that the spinner was implemented using a sprite sheet: the element had a background-position change, and all these frames were scrolling. <br><br><img src="https://habrastorage.org/webt/6l/01/0q/6l010qsbh9lkgzhaycbg2bccce4.jpeg"><br><br>  In principle, it worked, but you probably know that if the background-position changes, what happens?  Repaint.  There is a constant ripaint, and it loaded the processor, it did not work very fast. <br><br>  How can I fix this?  It is possible through CSS.  Naturally, I did not immediately go into the wilds of GLSL, at first we did it all under the simplest possible way, through CSS, through hardware-accelerated properties.  Many of you know that there are hardware-accelerated properties that allow you to perform some kind of animation without repainting.  Here it can all be changed to opacity, that is, with the background-position we move to opacity. <br><br>  How can this be done using opacity?  To decompose all frames into layers and using opacity to gradually hide them and show, in general, the same effect is obtained, but without any repaints.  Hurray, QA-department confirmed the increase in speed, everyone is happy. <br><br>  The next day I received another task at JIRA.  Denis, we know that you are already an expert in spinners, we have the exact same spinner, only blue and a bit different width. <br><br>  I knew that there were many spinners, and I realized that there was a small problem there.  Firstly, this 150-frame spinner in video memory unfolds at more than 8 megabytes, I specifically counted on the resolution and bit depth of these textures (because for each frame, a texture is created as a result. And it takes 10 megabytes in RAM. download 100 kilobytes. In general, each spinner costs about 20-30 megabytes, considering that it needs to be released. For a spinner, 30 megabytes is, frankly, a lot. If there are 3-4 of them, this is 100 MB of RAM per spinner. <br><br>  We had a limit of 256 megabytes in the browser: as soon as they were reached, the entire system collapsed.  I think on mobile phones even 100 megabytes per spinner is also an unaffordable luxury. <br><br>  Okay, I get it, we have a problem.  It can be solved with GLSL.  As far as pragmatic, we will analyze later. <br><br><h2>  Write a shader </h2><br>  And now we can write a pixel shader together.  Spinner can be represented as an animated arch, which collapses and splits open: it changes the angle of beginning and end, and this arch rotates with a certain periodicity, attenuation, acceleration.  Therefore, we need to learn how to draw an arch in GLSL with the help of mathematics. <br><br>  First, install the Chrome <a href="https://chrome.google.com/webstore/detail/refined-github/hlepfoohegkhhmjieoechaddaejaokhf">Refined GitHub</a> extension, it needs to copy and paste diff from commits.  If you do not put it, you will have to copy line numbers when you try to copy the text of the diff, and you will have to delete them manually.  Therefore, Refined Github helps a lot: it lists line numbers in a separate list, and it's cool. <br><br>  Then open the <a href="http://editor.thebookofshaders.com/">online shader editor</a> and the GitHub repository of <a href="https://github.com/PixelsCommander/pixel-shaders-workshop">PixelsCommander / pixel-shaders-workshop</a> , in which you need to go through the steps. <br><br>  What we start with is a copy-paste in the GLSL editor, the first step, thanks to which we will have a circle: <br><br><img src="https://habrastorage.org/webt/fr/n0/83/frn0832eyp7zyj5fke_nxyzw9i8.png"><br><br>  What's going on here?  At the top of the new unit, it was not in the past example, here comes a uniform variable.  "Uniform" means a variable sent from javascript.  We see u_time, u_resolution, and u_mouse from JavaScript here.  The most interesting of them is u_resolution.  What she says is the dimension of the canvas.  JavaScript took the dimension of the canvas and sent us a two-component vector in GLSL, now we know the size of the canvas in GLSL. <br><br>  In PI, we determined the number pi, so as not to write it constantly with our hands.  Then u_resolution was multiplied by 0.5: this is a two-component vector (where width and height are there), and when multiplying a vector by 0.5, all its components are multiplied by 0.5 at once.  So we found half of our dimension.  After that, we took the radius as the minimum of the width and height. <br><br>  Now we have the Circle function: earlier we simply defined in main, whether we were lying inside the circle or not, but now we took it into a separate function, where we start the current pixel coordinate, center and radius. <br><br>  And in main we get isFilled as a result of the execution of the Circle function, and subtract from the isFilled unit, because we want it not to be a white circle, but a background.  That is, inverted all this wealth. <br><br>  Now the <a href="https://github.com/PixelsCommander/pixel-shaders-workshop/commit/d41af0d81e47550a4a8201cb4c63d6bf202777a2">second step</a> : we will cut the sector on the circle. <br><br><img src="https://habrastorage.org/webt/hy/9t/a8/hy9ta8szylly0wxwmsvmfobia3o.png"><br><br>  We add a function that draws a sector, and a function that says whether the angle lies between two given angles.  And besides, isFilled, we are now doing the product of the results circle and sector.  If in both cases the unit, then we are within our figure.  If circle were not taken into account, then the sector would be infinite, not bounded by a circle.  The result is as follows: <br><br><img src="https://habrastorage.org/webt/zi/9b/iz/zi9bizel48bluzksdg24yffiez0.jpeg"><br><br>  Now the <a href="https://github.com/PixelsCommander/pixel-shaders-workshop/commit/d9ca15ee60432ef3a11fd2dfee3ffe4c2890c7bd">third step</a> .  Draw an arch. <br><br><img src="https://habrastorage.org/webt/sn/by/t8/snbyt8fsmv5knnogweu1ny2d1cg.png"><br><br>  This is where a new arch feature is added.  Now we need to know its thickness, for this we will calculate the internal radius and what do we see? <br><br>  Now we have isFilled - this is the result of the execution of the arc function, with which we transfer the starting angle, the ending angle, the inner and outer radii.  Here it is all built inside on the sector that we already have, and on the two functions of the circle, which invert each other.  That is, two circles are cut off, one hides the other. <br><br>  Everything is great, everything is good, we have an arch, we are almost ready, but if you take a closer look, and I will try to help you, then you will notice that the arch is pixelated, there are "cloves" without smoothing: <br><br><img src="https://habrastorage.org/webt/bp/hi/hw/bphihwtcobpjmhkyjhn5bu8ma-u.png"><br><br>  This is because, there is no anti-aliasing, this is because when we draw a circle, we use the step function here, when we determine whether a point lies in a circle or not, and the step function hard cuts off discretely, 0 or 1 if the value is lower given, then this is 1, if higher is 0. Accordingly, our pixel can be either black or white. <br><br>  Let's get rid of it, this will be step 4. Add anti-aliasing. <br><br><img src="https://habrastorage.org/webt/su/jf/rg/sujfrgftlpttqnq5bvwhivwralw.png"><br><br>  We replace the step function with smoothstep.  A smoothstep does not just say ‚Äúeither 0 or 1‚Äù, but interpolates between two values.  Here we have ‚ÄúdistanceToCenter minus two pixels‚Äù and there is just distanceToCenter, that is, we have anti-aliasing by smearing 2 pixels.  Here you can argue about the terms, but really we just added anti-aliasing to our shader. <br><br><img src="https://habrastorage.org/webt/_m/9x/2q/_m9x2qcdw8fbm-etv_duwinooki.png"><br><br>  And the arch became smooth and silky. <br><br>  We now turn to the most difficult - to the animation.  To draw an arch is, in general, class 5 trigonometry, and there is nothing complicated.  With animation, everything is a bit more complicated, because you first need to recognize and decompose it. <br><br>  Decomposing the animation of the spinner, we find that there are actually two animations.  One is the flapping-rapping animation, and the second is the rotation animation.  In addition, at the beginning of the cycle, the animation accelerates, and at the end it slows down.  This is very similar to the behavior of the sine function: in the interval from - pi / 2 to pi / 2, acceleration first takes place, sharply soars up, and then slows down. <br><br><img src="https://habrastorage.org/webt/-m/ax/fa/-maxfa9oc3gzlpripwm8w0gvzhk.png"><br><br>  Step five.  We will apply this function to our corners of the beginning and end of the arch.  We get a collapse-splash animation, albeit a little blunt for now (let's fix this).  What's going on here?  Time closes in the period from - pi / 2 to pi / 2, then the sine function is applied to it, and all the time we get a value from zero to one - as far as we collapse-slammed.  That is, in fact, the easing function is used here, this is what in tweens, in CSS is used everywhere, here it is implemented on GLSL.  Then we multiply 360 by the result of the execution of this easing-function and get the angle of the beginning, the angle of the end, which we transfer to the function of the arch, which we wrote earlier. <br><br>  The next step is to rotate the whole spinner. <br><br><img src="https://habrastorage.org/webt/w9/pf/1e/w9pf1eih2h6hcv6aunqs2lmjwvg.png"><br><br>  With rotation, everything is simple, we already have a theoretical base prepared, we know that the sine rules and we add to startAngle and endAngle the value, which is obtained, again, from the sine, but with a twice as long period, because we have two slamming-flapping turns out just one turn. <br><br>  Thus, we received a spinner, which is almost in line with our technical task.  It remains to add a little parameterization: <br><br><img src="https://habrastorage.org/webt/9t/3e/xx/9t3exx4bjm9ockpiw5jq4z4_p_i.png"><br><br>  To do this, you need the RGB function.  It is not necessary to use it, but it‚Äôs good, because we usually take colors from Photoshop, and they have byteable channel values ‚Äã‚Äãfrom 0 to 255, you saw that in GLSL from 0 to 1, and this function allows you to send to it we are familiar with 255/255/255 and get 1/1/1 at the output. <br><br>  This function is used in main, and there is also added customization of the background, just in case of fire. <br><br><img src="https://habrastorage.org/webt/1k/x1/jx/1kx1jxs09zmdxbcn_f88lradkc8.gif"><br><br>  The result was a wonderful animated vector spinner, in which you can change the width and color.  The component is ready, it works, it is rendered on the GPU, and all this stuff takes 70 lines of code.  If you lean on, you can probably shrink up to 5 lines, which, of course, cannot be compared with the amount of information we transmitted in the sprite sheet - just heaven and earth.  If we have 30 megabytes there were just pictures, plus we need to initialize the same contexts for textures and so on, then there is an obvious progress. <br><br><h2>  What can we do about it </h2><br>  How to use the GLSL component in your web application?  As already mentioned, this is done through the WebGL context. <br><br><img src="https://habrastorage.org/webt/p1/wo/gf/p1wogfaxuuhshk31ynhdtrp-zey.jpeg"><br><br>  There is a simple way.  There is a web component called the GLSL component, and you put it in the right place on your page, this tag, inside put this GLSL code that we got in the editor.  And you get in the amount that you have this block, you get your GLSL component that works online. <br><br>  Previously, we implemented what could be done with a stretch on CSS through a sprite sheet or other tricks, though not always quickly.  But in fact, shaders are much cooler: they give control over each pixel. <br><br>  Here is the gif that shows the spinner reacting to the cursor: <br><br><img src="https://habrastorage.org/webt/7g/8m/i0/7g8mi0i9mekqjekf640zc--4qsy.gif"><br><br>  And <a href="https://youtu.be/P-OOg9z4OUg%3Ft%3D35m20s">on the video</a> you can see an even more impressive example of how GLSL gives disproportionately more features and allows you to manage each pixel.  There the spinner has already become something else. <br><br>  That is, by applying a fairly simple math, you can get some component, and after working a little more, we can add new unusual properties to it.  The possibilities of pixel shaders, in fact, are endless and limited only by your knowledge of mathematics and your skills in writing shaders. <br><br>  And what else is good for GLSL: in addition to these endless possibilities, it gives JavaScript developers, front-end developers, a breath of fresh air.  You have been writing JavaScript for some years, you understand that you are good in it, and you want something new, but you don‚Äôt want to be in the backend.  In this case, GLSL is a good way to change and diversify your life. <br><br>  Thank you very much! <br><br><blockquote>  If you liked the report, please note: next week will be held <b>HolyJS 2018 Piter</b> , and there Denis will also <a href="https://holyjs-piter.ru/talks/2tmryuscgwykqms0ouqees/">speak</a> , now with the topic ‚ÄúMining crypto in browser: GPU, WebAssembly, JavaScript and all the good things to try‚Äù.  And in the discussion area after the report, it will be possible to question him properly both on the topic of the new report and on shaders.  In addition to Denis, there will be dozens of other speakers there - see all the details <a href="https://holyjs-piter.ru/">on the</a> HolyJS <a href="https://holyjs-piter.ru/">website</a> . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/358250/">https://habr.com/ru/post/358250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358238/index.html">Women's networks: who makes the choice for us?</a></li>
<li><a href="../358242/index.html">AI.Hack St. Petersburg</a></li>
<li><a href="../358244/index.html">Playing Cap: how to put the cashier on the cashier's table</a></li>
<li><a href="../358246/index.html">Material Design 2.0 and Android P</a></li>
<li><a href="../358248/index.html">‚ÄúWe are starting! I said: let's start! ‚Äù, Or how we implemented the work with faststart-video for Android</a></li>
<li><a href="../358252/index.html">What I learned from personal experience over the years of freelancing</a></li>
<li><a href="../358256/index.html">What's New in PostgreSQL 11: Improved Casting</a></li>
<li><a href="../358258/index.html">How tickets in support turn into tickets in Jira</a></li>
<li><a href="../358260/index.html">Four ways to work with text UI in Unity</a></li>
<li><a href="../358262/index.html">Unreal Engine 4 Tutorial: Paint Filter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>