<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Capturing video from network cameras, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Network cameras are gradually replacing analog, although they are now much more expensive. Network have some obvious advantages: 


- no need for a se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Capturing video from network cameras, part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/d540d9ce/6907d7e2/9a9a5335/baf8072c.jpg" align="left">  Network cameras are gradually replacing analog, although they are now much more expensive.  Network have some obvious advantages: <br><ul><li>  no need for a separate registrar or capture board; </li><li>  noise immunity; </li><li>  simple integration into an existing network; </li><li>  no distance limit; </li><li>  availability of high resolution cameras; </li><li>  viewing the camera directly from the camera itself by http; </li><li>  the presence of various settings; </li><li>  and etc. </li></ul><br>  We are interested in a method of obtaining images from such cameras, for this we need to know, and how do they transmit them at all?  Fortunately for us, cameras use existing standards, and not something that a Chinese developer would think of.  The overwhelming majority of cameras use one or several video transmission methods; these are mainly Motion JPEG over HTTP, Motion JPEG over RTSP or H264 over RTSP.  Also, many cameras can transmit sound, but it does not interest us now. <br><br>  In this article I will consider these methods of transferring images from network cameras, and also give an example of capturing such images all on the same Python. <br><a name="habracut"></a><br><h4>  MJPEG over HTTP </h4><br>  The easiest way to transfer a picture is MJPEG over HTTP.  In this case, frames are sent to finished JPEG files through special delimiters.  For such cases, a special MIME type <a href="http://en.wikipedia.org/wiki/MIME">multipart</a> was developed.  It has several subtypes, we are interested in mixed and x-mixed-replace.  There are practically no differences between them, we will process them in exactly the same way.  The difference between them is semantic: mixed simply indicates a document consisting of several parts, these parts can be independent or can be combined;  and the type of x-mixed-replace directly indicates that each next part should replace the previous one and should be processed as an update of some presentation.  The letter "x" at the beginning of the name indicates that this type is experimental, but nevertheless it is used to the full. <br><br>  In the HTTP header, the MIME type is specified in the <code>Content-Type</code> parameter: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="tex hljs">Content-Type: multipart/mixed; boundary="some_boundary"</code> </pre><br>  or <br><br><pre> <code class="tex hljs">Content-Type: multipart/x-mixed-replace; boundary=other_boundary</code> </pre><br>  These types have a required parameter, the <code>boundary</code> parameter, which indicates how text parts of the document are separated.  To the separator are also added two hyphens to its beginning.  It is important that this separator is not met in the message itself, if its size is not indicated in the <code>Content-Size</code> . <br><br>  To understand the structure of the transfer of MJPEG over HTTP, just look at the following example: <br><br><pre> <code class="tex hljs">HTTP/1.0 200 OK Connection: close Server: MJPG-Streamer/0.2 Cache-Control: no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0 Pragma: no-cache Expires: Mon, 3 Jan 2000 12:34:56 GMT Content-Type: multipart/x-mixed-replace;boundary=boundarydonotcross --boundarydonotcross Content-Type: image/jpeg Content-Length: 23950 X-Timestamp: 0.000000 <span class="hljs-comment"><span class="hljs-comment">%Binary JPEG% --boundarydonotcross Content-Type: image/jpeg Content-Length: 24756 X-Timestamp: 0.000000 %Binary JPEG% --boundarydonotcross Content-Type: image/jpeg Content-Length: 23950 X-Timestamp: 0.000000 %Binary JPEG%</span></span></code> </pre><br>  To analyze how your network camera transmits images, you can use either a sniffer (I use <a href="http://www.wireshark.org/">WireShark</a> ) or connect to the camera via telnet, for example: <br><br><pre> <code class="bash hljs">$ telnet 192.168.0.50 80 Trying 192.168.0.50.. Connected to 192.168.0.50. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. GET /jpeg HTTP/1.1</code> </pre><br>  After the GET line, you must also send one empty line to indicate that your header has ended.  And instead of "/ jpeg" you need to write the request for which your camera gives MJPEG. <br><br>  In the example above, <code>%Binary JPEG%</code> corresponds to the information of interest to us - a JPEG image.  We also need to isolate it from the stream. <br><br>  As you can see at the beginning there is a standard HTTP header with a description of the document.  <code>Connection</code> can be both <code>close</code> and <code>keep-alive</code> , in our case it does not matter.  From the title we just need two lines: the first with the status of 200 OK, which tells us that everything is fine, now a bird will fly out;  and <code>Content-Type</code> to define the parameter <code>boundary</code> . <br><br>  After the HTTP header (after the empty string), the body of the transmitted document consists of many parts.  Each part starts with a separator, has its own title and its own document body after the empty line.  <code>Content-Type: image/jpeg</code> tells us that we actually receive JPEG images, the <code>Content-Length</code> the size of the current frame in bytes (in the first part it is 23950 bytes), and the timestamp of the current frame can be transmitted to the <code>X-Timestamp</code> these goals, the current time of the computer at the time of reception of the frame, but the <code>X-Timestamp</code> will be more accurate, as the network can have a different impact on the frame rate. <br><br><h4>  Python MJPEG over HTTP Client </h4><br>  Despite the simple format of transferring images, their reception can be implemented by different methods.  Also plays the role of TCP segmentation, or rather the approach to its processing.  The fact is that the maximum size of a transmitted message ( <a href="http://ru.wikipedia.org/wiki/MTU">MTU</a> ) over Ethernet cannot exceed 1500 bytes and we process the data every time such a packet comes to us.  If you analyze the information immediately after it arrives, it may happen that the data will not be complete and the parser will not be able to cope with its task.  And if you buffer the flow of incoming data, it is not the best effect on performance and resource intensity.  It would be safer to use buffering and start analyzing only when enough information has been accumulated (first you need to read before <code>'\r\n\r\n'</code> to select the header, and then either until you see two delimiters in the stream, or read up to an empty line, determine the size of the image and count the number of bytes).  But I used the method of processing information immediately after it arrived. <br><br>  Client code consists of two files: <code>main.py</code> and <code>http_mjpeg_client.py</code> .  In the first, the application is launched, and in the second, work with the camera is implemented.  Immediately and bring them here. <br>  <font color="gray">main.py</font> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> twisted.internet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reactor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> http_mjpeg_client <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MJPEGFactory <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'This function is invoked by the MJPEG Client protocol'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Process image # Just save it as a file in this example f = open('frame.jpg', 'wb') f.write(img) f.close() def main(): print 'Python M-JPEG Over HTTP Client 0.1' # Define connection parameters, login and password are optional. config = {'request': '/mjpeg', 'login': 'admin', 'password': 'admin', 'ip': '127.0.0.1', 'port': 8080, 'callback': processImage} # Make a connection reactor.connectTCP(config['ip'], config['port'], MJPEGFactory(config)) reactor.run() print 'Python M-JPEG Client stopped.' # this only runs if the module was *not* imported if __name__ == '__main__': main()</span></span></code> </pre><br>  <font color="gray">http_mjpeg_client.py</font> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> twisted.internet.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol, ClientFactory <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> base64 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b64encode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re debug = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MJPEGClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># A place for configuration parameters self.config = {} # I we are connected to a web server self.isConnected = False # The boundary in multipart stream self.boundary = '' # Actual image data goes here self.img = '' # Size of the image frame being downloaded self.next_img_size = 0 # Indicates that currently parsing a header self.isHeader = False def connectionMade(self): # Implement basic authorization if self.config['login']: authstring = 'Authorization: Basic ' + b64encode(self.config['login']+':'+self.config['password']) + '\r\n' else: authstring = '' # Form proper HTTP request with header to_send = 'GET ' + self.config['request'] + ' HTTP/1.1\r\n' + \ authstring + \ 'User-Agent: Python M-JPEG Client\r\n' + \ 'Keep-Alive: 300\r\n' + \ 'Connection: keep-alive\r\n\r\n' # Send it self.transport.write(to_send) if debug: print 'We say:\n', to_send def dataReceived(self, data): if debug: print 'Server said:\n', len(data), 'bytes of data.' if not self.isConnected: # Response header goes before empty line data_sp = data.strip().split('\r\n\r\n', 1) header = data_sp[0].splitlines() # Parse header for line in header: if line.endswith('200 OK'): # Connection went fine self.isConnected = True if debug: print 'Connected' if line.startswith('Content-Type: multipart'): # Got multipart r = re.search(r'boundary="?(.*)"?', line) self.boundary = r.group(1) # Extract boundary if debug: print 'Got boundary:', self.boundary # If we got more data, find a JPEG there if len(data_sp) == 2: self.findJPEG(data_sp[1]) else: # If connection is alredy made find a JPEG right away self.findJPEG(data) def findJPEG(self, data): hasMoreThanHeader = False # If we know next image size, than image header is already parsed if not self.next_img_size: # Otherwise it should be a header first for line in data.splitlines(): if line == '--'+self.boundary: self.isHeader = True if debug: print 'Got frame header' elif line == '': if self.isHeader: # If we might have more data after a header in a buffer hasMoreThanHeader = True self.isHeader = False elif self.isHeader: # Here we can parse all the header information # But we are really interested only in one if line.startswith('Content-Length:'): self.next_img_size = int(line.split(' ')[1]) if debug: print 'Next frame size:', self.next_img_size else: # How many bytes left to read remains = self.next_img_size - len(self.img) self.img += data[:remains] # We got the whole image if len(self.img) == self.next_img_size: if debug: print 'Got a frame!' # Run a callback function self.config['callback'](self.img) # Reset variables self.img = '' self.next_img_size = 0 # If something left in a buffer if data[remains:]: self.findJPEG(data[remains:]) if hasMoreThanHeader: data_sp = data.split('\r\n\r\n', 1) # If there is something after a header in a buffer if len(data_sp) == 2: self.findJPEG(data_sp[1]) def connectionLost(self, reason): print 'Connection lost, reconnecting' self.isConnected = False self.img = '' self.next_img_size = 0 self.isHeader = 0 self.boundary = '' class MJPEGFactory(ClientFactory): def __init__(self, config): self.protocol = MJPEGClient self.config = config def buildProtocol(self, addr): prot = ClientFactory.buildProtocol(self, addr) # Weird way to pass the config parameters to the protocol prot.config = self.config return prot def clientConnectionLost(self, connector, reason): # Automatic reconnection connector.connect()</span></span></code> </pre><br>  In the main file, we define the parameters for connecting to the camera in the <code>config</code> dictionary, launch the Twisted network framework reactor, and process the resulting images in the <code>processImage()</code> function.  In this example, each received frame is simply written to the current directory with the name <code>frame.jpg</code> . <br><br>  I checked the performance with the help of the <a href="http://sourceforge.net/projects/mjpg-streamer/">MJPEG streamer</a> , I started it like this: <br> <code>./mjpg_streamer -i "./input_testpicture.so" -o "./output_http.so -w ./www"</code> <br>  In this case, the <code>request</code> in the client configuration must be set equal to <code>/?action=stream</code> . <br>  He refused to transfer images from the webcam. <br><br>  I tried to document the second file well, so that it was easier for the reader to understand how the process of removing images from the stream takes place.  In words, the algorithm can be described as follows: when connecting to the camera, first of all we create an HTTP header with reference to it and send it, this is the <code>connectionMade()</code> function.  The <code>dataReceived()</code> function is called whenever new data <code>dataReceived()</code> .  In it, we check whether the transfer of JPEG data is already established or not.  If there is still no, then this means that the HTTP response header of the camera should come to us, we select it using the <code>split('\r\n\r\n', 1)</code> function <code>split('\r\n\r\n', 1)</code> , then sort it out on the shelves, highlighting the necessary parameters (status and <code>boundary</code> ).  In other cases, we immediately pass the received data to the <code>findJPEG()</code> function. <br><br>  In this function, branching also occurs depending on whether we have received the internal header of a JPEG document or not yet.  If you haven‚Äôt received it, we expect it and parse it; if it is received, then the data is directly a JPEG image and put it into the <code>self.img</code> variable until we receive all <code>self.next_img_size</code> image bytes, and when we receive we call the function passed to us through the parameter configuration <code>callback</code> , and give her just received the image. <br><br>  The <code>debug</code> parameter can be set to zero to disable the display of output. <br><br>  Download the source code from this link: <a href="http://python-mjpeg-over-http-client.googlecode.com/files/">Python MJPEG over HTTP Client</a> . <br><br>  To be continued‚Ä¶ <br><br><h4>  It is useful to read: </h4><br>  <a href="http://en.wikipedia.org/wiki/MIME">Mime</a> <br>  <a href="http://en.wikipedia.org/wiki/Motion_JPEG">Motion jpeg</a> <br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25B7%25D0%25B0%25D0%25B3%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25BE%25D0%25B2_HTTP">HTTP headers list</a> <br><br>  PS: I decided to split the article into two parts, as a single whole it turns out to be rather voluminous, but I don‚Äôt want to overload it for better understanding and more convenience. </div><p>Source: <a href="https://habr.com/ru/post/115808/">https://habr.com/ru/post/115808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115798/index.html">Constructor Theme for Wordpress</a></li>
<li><a href="../115799/index.html">Giants of the past: Catalyst 5000 (Project Synergy)</a></li>
<li><a href="../115801/index.html">How to come up with a domain name for the site - a creative approach</a></li>
<li><a href="../115804/index.html">New York Times newspaper website will be paid</a></li>
<li><a href="../115805/index.html">Projection mouse evoMouse</a></li>
<li><a href="../115811/index.html">Debian GNU / Linux 6.0.1 released</a></li>
<li><a href="../115812/index.html">Writing a whois client for Android</a></li>
<li><a href="../115813/index.html">Meet COBOL - Part 1</a></li>
<li><a href="../115815/index.html">wiki.php.net compromised</a></li>
<li><a href="../115817/index.html">IPad 2 Video Review (Part 1 and 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>