<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compile Try / Catch / Finally for JVM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead of introducing 
 The author of the article, Alan Keefer 1 , is the chief architect of Guidewire Software 2 , which develops software for the i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compile Try / Catch / Finally for JVM</h1><div class="post__text post__text-html js-mediator-article"><h4>  Instead of introducing </h4><br>  The author of the article, Alan Keefer <a href="https://habr.com/ru/post/212759/"><sup>1</sup></a> , is the chief architect of Guidewire Software <a href="https://habr.com/ru/post/212759/"><sup>2</sup></a> , which develops software for the insurance business.  While still a senior developer, he participated in the work on the Gosu <a href="https://habr.com/ru/post/212759/"><sup>3</sup></a> language.  In particular, Alan dealt with issues of compiling a language into Java bytecode. <br><br>  This article was written in 2009 and focuses on the details of a try / catch / finally implementation in JVM version 1.6.  To read it, you must have a basic knowledge of Java syntax, as well as understand the purpose of the bytecode, the sheets of which are under the cut.  Also at the end of the article are a number of examples similar to SCJP tricky tasks. <br><br><h4>  JVM insides </h4><br>  One of the things that we are currently working on for a variety of reasons is the compilation of our ‚Äúhome‚Äù language into Java bytecode.  (For reference, I can‚Äôt say when we‚Äôre done. Even approximately. Even if he‚Äôs going to future releases.) The fun is to study the insides of the JVM, and also to search for all the fucked sharp corners of our own language.  But most of all the "fun" and sharp corners deliver such operators as try / catch / finally.  Therefore, this time, I will not go into philosophy or Agile.  Instead, I‚Äôll go deep into the JVM, where most do not need (or don‚Äôt want) to go deep. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If two weeks ago you asked me about finally blocks, I would assume that their processing is implemented in the JVM: this is the basic part of the language, it should be embedded, shouldn't it?  What was my surprise when I learned: no, not so.  In fact, finally blocks are simply substituted into all places after try- or associated catch blocks.  These blocks are wrapped in ‚Äúcatch (Throwable)‚Äù, which will rethrow an exception after the finally-block finishes.  It remains only to tweak the exception table so that the substituted finally blocks are skipped.  Well, how?  (Small nuance: up to the JVM 1.6 version for the finally operator, it seems that subroutines were used instead of full substitution. But now we are talking about version 1.6, to which all of the above applies.) <a name="habracut"></a><br><br>  To understand whether this approach makes sense, rewind a little back and see how the JVM handles exceptions.  Their processing is built into the JVM as a declaration of try / catch blocks using a special method.  All that is required of you is to say ‚Äúbetween point A and point B, any exception of type E must be processed by code at point C‚Äù.  You can have as many such declarations as you need.  When an exception is passed to this method, the JVM will find the corresponding catch block depending on its type. <br><br><h4>  A simple example try / catch block </h4><br>  Consider a simple example: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleTryCatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { callSomeMethod(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { handleException(e); } }</code> </pre> <br>  For him, in the end, you will get the byte code below.  (I use the formatting that ASM Eclipse offers - an invaluable tool for studying the mechanisms of the JVM. It seems to me that the code in this format is quite easy to read. ‚ÄúL0‚Äù, etc., are code labels.) <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> simpleTryCatch()V TRYCATCHBLOCK L0 L1 L2 java/lang/RuntimeException L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL test/SimpleTryCatch.callSomeMethod()V L1 <span class="hljs-keyword"><span class="hljs-keyword">GOTO</span></span> L3 L2 ASTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">1</span></span> INVOKEVIRTUAL test/SimpleTryCatch.handleException(Ljava/lang/RuntimeException;)V L3 <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span></code> </pre><br>  So, we tell the catch operator to cover the entire try-block as a whole (but not the GOTO operator at the end), and in the case of a RuntimeException, to transfer control to L2.  If the try statement is complete, jump over the catch statement and continue execution.  If the RuntimeException handler is called, the exception is at the top of the stack, and we save it to a local variable.  Then we load the pointer to ‚Äúthis‚Äù and the exception in this order to call the handleException method.  After that, the remaining code is executed to the end.  However, if there was an additional catch block, we would jump over it. <br><br><h4>  Example try / catch / finally block </h4><br>  Now we add a finally block and an additional catch statement and see what happens in the bytecode.  Take the following completely contrived example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryCatchFinally</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { callSomeMethod(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } callSomeMethod(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { handleException(e); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { callFinallyMethod(); } }</code> </pre><br>  In this case, we get a much less understandable bytecode: <br><br><pre> <code class="hljs cmake">public tryCatchFinally(Z)V TRYCATCHBLOCK L0 L1 L2 java/lang/RuntimeException TRYCATCHBLOCK L3 L4 L2 java/lang/RuntimeException TRYCATCHBLOCK L0 L1 L5 java/lang/Exception TRYCATCHBLOCK L3 L4 L5 java/lang/Exception TRYCATCHBLOCK L0 L1 L6 TRYCATCHBLOCK L3 L7 L6 TRYCATCHBLOCK L5 L8 L6 L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callSomeMethod()V L9 ILOAD <span class="hljs-number"><span class="hljs-number">1</span></span> IFEQ L3 L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callFinallyMethod()V L10 <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> L3 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callSomeMethod()V L4 GOTO L11 L2 ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> L12 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">2</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.handleException(Ljava/lang/RuntimeException;)V L7 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callFinallyMethod()V GOTO L13 L5 ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> L8 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callFinallyMethod()V <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> L6 ASTORE <span class="hljs-number"><span class="hljs-number">3</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callFinallyMethod()V ALOAD <span class="hljs-number"><span class="hljs-number">3</span></span> ATHROW L11 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKEVIRTUAL <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>/SimpleTryCatch.callFinallyMethod()V L13 <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span></code> </pre><br>  So what happens here?  (Note that the labels are numbered in the order in which they are created by the compiler, and not in the order in which they appear in the code.) First of all, you will notice that both exception handling blocks are now divided into two: from L0 to L1 and from L3 to L4.  This was due to the fact that a finally block was inserted between L1 and L3 because of the return statement. <br><br>  Due to the fact that exceptions thrown from a finally block should not be processed by catch blocks associated with the same try statement, the corresponding range was removed from the exception table.  Entries in the table without exception type refer to the finally block.  They must handle exceptions of any type thrown from a try statement or from catch blocks, and they should ignore any substituted finally blocks.  Thus, finally blocks will not catch exceptions thrown by the same finally blocks.  There are three such records, because in addition to finally inserted inside the try block, the catch (Exception) block also contains a return statement. <br><br>  You may also be surprised to see that the finally block occurs in code 5 (five) times.  The first substituted finally, corresponding to the return statement of the try block, occurs between L1 and L3.  The second finally block is a bit more complicated: it is substituted at the end of the first catch block, which then jumps through the rest of the finally code.  (I personally believe that it was necessary to make the transition to the end instead of the next embedding.) For the third time it appears between L8 and L6 before the return statement in the second catch block.  The fourth time the finally-block appears in the code between L6 and L11, which corresponds to the case of an exceptional situation: you need to be sure that the finally-block will be executed in case of an unhandled exception thrown in a try block or any catch block.  Note that the exception is saved as if nothing had happened, the finally operator is called, after which the exception is loaded and thrown again.  In the last finally block, control passes from the end of the try block. <br><br>  If we had nested try / catch or try / finally blocks, everything would be even stranger.  The return statement of an internal try-block requires that finally-blocks of both the internal and external try be substituted in front of it.  The exception table must be configured so that the exception thrown by the internal finally is caught by external catch and finally statements, and the exception thrown by the external finally is not caught by anyone.  Now you are probably trying to imagine which set of states your compiler is forced to carry with you to know what to substitute and how to fill the exception table. <br><br>  It would be interesting to know, at least to me, how the creators of JVM decided to shove a finally statement into the compiler instead of embedding it in a virtual machine.  Obviously, doing this work with the compiler can significantly simplify the virtual machine, but it makes life a little more difficult for people like us who create another language for the JVM. <br><br><h4>  Non-standard examples </h4><br>  Understanding how the compiler is implemented makes it easier to understand some non-standard cases.  For example: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; }</code> </pre><br>  The result will be ‚Äúbar‚Äù, because the finally operator will be substituted before the return statement, which means that the return from the finally block will be called first, and the return from the try block will not be called at all. <br><br><pre> <code class="java hljs">String value = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { value = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; }</code> </pre><br>  The result will be ‚Äúfoo‚Äù, because the value for the return statement will be pushed onto the stack before the finally statement is called, after which it will be restored and returned.  (My example does not show this, but this is exactly what you will see if you look at the byte code.) Thus, changing the value of ‚Äúvalue‚Äù in a finally block has no value for the return statement.  And finally, something like: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>;</code> </pre><br>  The result will be ‚Äúbar‚Äù.  It was a surprise even for me, but everything is logical if you know that the break statement is only GOTO in bytecode.  Those.  when the finally block is substituted as part of the internal return statement, the GOTO statement is called before the RETURN instruction, which causes the loop to exit.  (The same goes for the continue statement inside the finally block.) <br><br><h4>  Conclusion </h4><br>  For our part, we decided to prohibit the return, break, and continue statements inside finally-blocks due to undefined semantics, as is done in C #.  (And I feel that a good company has gathered from those who made such a decision.) <br><br>  If someone found this article instructive, I plan to write a few notes about other interesting things that we encountered when generating bytecode.  They will apply to both the JVM itself and various inconsistencies between our language and Java, such as closures, external functions and generics. <br><br><h4>  Glossary </h4><br>  routine = sub-routine <br>  statement = statement <br>  substitution = inlining <br>  exception = exception <br>  external function = <a href="http://gosu-lang.org/docs.html">enhancement</a> = <a href="http://confluence.jetbrains.com/display/Kotlin/Extension%2Bfunctions">extension function</a> = <a href="http://en.wikipedia.org/wiki/Mixin">mixin</a> <br><br><h4>  Links </h4><br><a name="1"></a>  [1] <a href="http://devblog.guidewire.com/author/akeefer/">devblog.guidewire.com/author/akeefer</a> <br><a name="2"></a>  [2] <a href="http://www.guidewire.com/">www.guidewire.com</a> <br><a name="3"></a>  [3] <a href="http://gosu-lang.org/">gosu-lang.org</a> </div><p>Source: <a href="https://habr.com/ru/post/212759/">https://habr.com/ru/post/212759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212739/index.html">Niklaus Wirth: 80th anniversary of the classic programming</a></li>
<li><a href="../212741/index.html">How to move away after burning at work</a></li>
<li><a href="../212743/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ96 (February 9 - 15, 2014)</a></li>
<li><a href="../212755/index.html">New, innovative design of the screw from Outlaw Fasteners breaks all the centuries-old foundations</a></li>
<li><a href="../212757/index.html">Kickstarter service hacking</a></li>
<li><a href="../212761/index.html">Gearman Queue Server: Practical Experience and the Gearman Monitor && Control web application</a></li>
<li><a href="../212765/index.html">Deploying Windows Azure WebJobs</a></li>
<li><a href="../212767/index.html">Cross-browser CSS3 properties set</a></li>
<li><a href="../212769/index.html">New Userland-RootKit Azazel</a></li>
<li><a href="../212771/index.html">The construction of the world's largest thermal solar power station has been completed.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>