<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous HTTP in the Play Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing your own web applications, situations often arise in which you have to choose between synchronous and asynchronous execution of requests....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous HTTP in the Play Framework</h1><div class="post__text post__text-html js-mediator-article">  When writing your own web applications, situations often arise in which you have to choose between synchronous and asynchronous execution of requests.  On the one hand, the idea of ‚Äã‚Äãsynchronous work looks quite logical: we start some process, wait for its completion, and then continue working.  But in fact, this approach is good only in the case of simple calculations.  Imagine that in the process of execution you need, for example, to make a complex query to the database - and even better, send the request to another server and wait for the results from it.  In this case, the further work of the flow will be stopped for quite a long time - and this, of course, is not always acceptable.  In such cases asynchronous requests come to the rescue.  Let's see how work with them is implemented in the Play framework. <br><a name="habracut"></a><br><h4>  Future [Result] </h4><br>  The situation with costly calculations described above in the Play framework is solved with the help of Future [Result].  The idea behind it is simple: why wait for the result of the calculations, if instead you can switch to other tasks?  The difference for the user, of course, will not be - his browser will still wait for a response from the server.  But the server itself will be able, instead of waiting for the result, to transfer resources to handle requests from other users.  Well, as soon as we get the result, it can be quickly processed and sent to the user. <br><br>  All that is needed to execute a block of code asynchronously with the receipt of Future [Result] is to wrap it in a simple structure of the form: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> play.api.libs.concurrent.<span class="hljs-type"><span class="hljs-type">Execution</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.defaultContext <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureInt: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> { intensiveComputation()}</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And to return the resulting value - use the Action.async method: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> play.api.libs.concurrent.<span class="hljs-type"><span class="hljs-type">Execution</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.defaultContext <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span>.async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureInt = scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> { intensiveComputation() } futureInt.map(i =&gt; <span class="hljs-type"><span class="hljs-type">Ok</span></span>(<span class="hljs-string"><span class="hljs-string">"Got result: "</span></span> + i))}</code> </pre><br><br>  And this option works well as long as the code runs correctly.  But no one is immune from errors during execution, and if the error happens in a block of code that is executed asynchronously, it can lead to the result that the result will not be generated.  This means that the user will not receive a response and his browser will remain on hold until he finally closes the tab.  To avoid this, however, is quite simple: each promise (that is, Future [Result]) can be timed out: if during this time we do not get a real result, an error will be generated.  This is also done quite simply: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> play.api.libs.concurrent.<span class="hljs-type"><span class="hljs-type">Execution</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.defaultContext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.duration._ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span>.async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureInt = scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> { intensiveComputation() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeoutFuture = play.api.libs.concurrent.<span class="hljs-type"><span class="hljs-type">Promise</span></span>.timeout(<span class="hljs-string"><span class="hljs-string">"Oops"</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>second) <span class="hljs-type"><span class="hljs-type">Future</span></span>.firstCompletedOf(<span class="hljs-type"><span class="hljs-type">Seq</span></span>(futureInt, timeoutFuture)).map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> i: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Ok</span></span>(<span class="hljs-string"><span class="hljs-string">"Got result: "</span></span> + i) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">InternalServerError</span></span>(t) }}</code> </pre><br><br>  But It should be noted that with all the advantages, Future [Result] should be used wisely: after all, when using it, one of the threads will still be blocked, just in this case - not the main one.  And this can lead to a variety of problems, especially with a large number of competitive requests. <br><br><h4>  HTTP streaming responses </h4><br>  In HTTP 1.1, one connection can be used to send multiple requests ( <a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection">http://en.wikipedia.org/wiki/HTTP_persistent_connection</a> ).  With one condition: the server must include the Content-Length header in the response.  Usually, when sending replies, this condition is not so important, because Play is quite capable of calculating the size of the content on its own.  But in fact, not always everything is so simple: because in the simplest case (using SimpleResult), the framework uses the Enumerator (play.api.libs.iteratee.Enumerator) to form the response body, to calculate the length it needs to load the entire content in memory.  And in the case of large amounts of data (imagine that you want to return the video file to the user) this can lead to some problems. <br><br>  The concept of Enumerator in Play is closely related to the concept Iteratee.  A bunch of Iteratee-Enumerator serves in this framework for the non-blocking implementation of the customer-producer pattern.  In other words, Iteratee is a consumer that can generate some result based on absorbed data fragments.  Enumerator, on the other hand, is a manufacturer who supplies these fragments. <br><br>  <b>Note</b> : for standard cases of working with Enumerator, Play provides a set of factory functions for creating it: Enumerator.fromFile, for example, creates it based on the contents of the file;  Enumerator.fromStream - based on the data stream.  In general, however, an Enumerator will have to be created manually. <br><br>  But back to streaming responses.  To avoid performance problems when calculating the size of data, it is better to calculate it in advance and substitute the resulting result in the request header.  This eliminates the need to load into memory the entire contents of the Enumerator, which means that resources are saved and productivity increases.  For the example described above, the video file can be accessed as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.io.<span class="hljs-type"><span class="hljs-type">File</span></span>(<span class="hljs-string"><span class="hljs-string">"/tmp/fileToServe.mov"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fileContent: <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Byte</span></span>]] = <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>.fromFile(file) <span class="hljs-type"><span class="hljs-type">SimpleResult</span></span>( header = <span class="hljs-type"><span class="hljs-type">ResponseHeader</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-type"><span class="hljs-type">CONTENT_LENGTH</span></span> -&gt; file.length.toString)), body = fileContent )}</code> </pre><br><br>  Or just use the Play framework function, designed to transfer the file to the user: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span> { <span class="hljs-type"><span class="hljs-type">Ok</span></span>.sendFile(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.io.<span class="hljs-type"><span class="hljs-type">File</span></span>(<span class="hljs-string"><span class="hljs-string">"/tmp/fileToServe.mov"</span></span>))}</code> </pre><br><br>  In addition to the obviously much simpler approach, it has several other advantages: for example, it allows you to change the file name or display its contents directly in the browser window - this can be very convenient if you need to load an HTML template or image. <br><br>  However, all the methods described above are good only in the case of static content, that is, such that we know in advance.  But what if by the time of the beginning of the transfer all the content is not ready yet - and therefore it will be impossible to calculate its length with all the desire?  In this case, fragmented replies that use the chunked transfer encoding mechanism ( <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">http://en.wikipedia.org/wiki/Chunked_transfer_encoding</a> ) come to the rescue.  This approach eliminates the need to use Content-Length, which means that you can start transferring data as you generate them, without knowing their final size.  Can play with him Play?  You still ask: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> data = getDataStream <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataContent: <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Byte</span></span>]] = <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>.fromStream(data) <span class="hljs-type"><span class="hljs-type">ChunkedResult</span></span>( header = <span class="hljs-type"><span class="hljs-type">ResponseHeader</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>), chunks = dataContent )}</code> </pre><br><br>  Or: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> data = getDataStream <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataContent: <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Byte</span></span>]] = <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>.fromStream(data) <span class="hljs-type"><span class="hljs-type">Ok</span></span>.chunked(dataContent)}</code> </pre><br><br>  You can pass and Enumerator: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Action</span></span> { <span class="hljs-type"><span class="hljs-type">Ok</span></span>.chunked( <span class="hljs-type"><span class="hljs-type">Enumerator</span></span>(<span class="hljs-string"><span class="hljs-string">"kiki"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>).andThen(<span class="hljs-type"><span class="hljs-type">Enumerator</span></span>.eof) )}</code> </pre><br><br>  The andThen method is used to create a sequence of several Enumerator.  In this case, for example, after the data, Enumerator.eof is transmitted - a zero-length fragment that signals that the transfer is complete. <br><br>  <b>Note</b> : instead of the andThen method, you can use the &gt;&gt;&gt; operator - functionally there is no difference between them, but using the latter can increase the readability of the code, saving it from an excessive number of brackets. <br><br>  But this approach also has its drawbacks: for example, due to the fact that until the last moment the final size of the transmitted data is unknown to the browser, it cannot show the percentage of completion.  But this, in fact, is not such a big minus compared with the need to wait until the end of the generation of data before starting their transfer. <br><br><h4>  Comet sockets </h4><br>  One application of the fragmented response method described above is to create Comet sockets.  What it is?  If simple, these are answers consisting of <pre> <code class="hljs pgsql"><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(HTML)}</code> <br> <br>  <code><code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = WebSocket.<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>[String] { request =&gt; // Just consume <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ignore the <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Iteratee.consume[String]() // Send a single <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Enumerator("Hello!").andThen(Enumerator.eof) (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>)}</code> <br> <br> <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> -   -  Iteratee,   ,   ; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </pre> <code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code><code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> <pre> <code class="hljs pgsql"><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(HTML)}</code> <br> <br>  <code><code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = WebSocket.<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>[String] { request =&gt; // Just consume <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ignore the <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Iteratee.consume[String]() // Send a single <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Enumerator("Hello!").andThen(Enumerator.eof) (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>)}</code> <br> <br> <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> -   -  Iteratee,   ,   ; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </pre> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> <h4> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </h4> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> <pre> <code class="hljs pgsql"><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(HTML)}</code> <br> <br>  <code><code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = WebSocket.<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>[String] { request =&gt; // Just consume <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ignore the <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Iteratee.consume[String]() // Send a single <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Enumerator("Hello!").andThen(Enumerator.eof) (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>)}</code> <br> <br> <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> -   -  Iteratee,   ,   ; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </pre> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> <h4> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </h4> <code><code><code class="scala"> .  ,      ,    -           ,     . <br> <br>           ,     Ok.chunked  Ok.stream: <br> <br> def comet = Action { val events = Enumerator( """&lt;script&gt;console.log('kiki')&lt;/script&gt;""", """&lt;script&gt;console.log('foo')&lt;/script&gt;""", """&lt;script&gt;console.log('bar')&lt;/script&gt;""" ) Ok.stream(events &gt;&gt;&gt; Enumerator.eof).as(HTML)}</code> <br> <br>  <code class="scala">         :    Play framework: <br> <br> def comet = Action { val events = Enumerator("kiki", "foo", "bar") Ok.stream((events &amp;&gt; Comet(callback = "console.log")) &gt;&gt;&gt; Enumerator.eof)}</code> <br> <br> WebSockets <br>   Play ,   Comet sockets   .     : ,      ,  ,      ,       Ajax-.   ,  WebSockets ( <a href="http://en.wikipedia.org/wiki/WebSocket">http://en.wikipedia.org/wiki/WebSocket</a> ),        . <br> <br>  ,   WebSockets,         Action: -      .      WebSocket,     Action  , ,     ,        ,   HTTP . <br> <br>     WebSocket   : <br> <br> <code class="scala">def index = WebSocket.using[String] { request =&gt; // Just consume and ignore the input val in = Iteratee.consume[String]() // Send a single 'Hello!' message and close val out = Enumerator("Hello!").andThen(Enumerator.eof) (in, out)}</code> <br> <br> In -   -  Iteratee,   ,   ; out -   - Enumerator,    . <br> <br>  <br>  ,  ,      , Play       -      ,   .          :       ,     . <br></code></code> </div><p>Source: <a href="https://habr.com/ru/post/219471/">https://habr.com/ru/post/219471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219461/index.html">Network scan on Xerox 3220 with VPN connected</a></li>
<li><a href="../219463/index.html">Add IP phones to a separate pool of IP addresses on a Mac address</a></li>
<li><a href="../219465/index.html">10 steps to create the perfect infographic</a></li>
<li><a href="../219467/index.html">Save our eyes: LED projectors</a></li>
<li><a href="../219469/index.html">Entertaining zhirovedenie or consequence of the principle of Peter</a></li>
<li><a href="../219473/index.html">COLT 2.0 Recompiling DOM as Directive Changes</a></li>
<li><a href="../219475/index.html">Vulnerability of remember me functionality found in Laravel</a></li>
<li><a href="../219481/index.html">Using MongoDB instead of memcached: to be or not to be?</a></li>
<li><a href="../219487/index.html">"Sex" robots</a></li>
<li><a href="../219491/index.html">We fix the errors with their own hands, or a bug that "no one shakes"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>