<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UniRx - Rx for Unity3d</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I have long wanted to write an article about UniRx on Unity3d. Let's start with a little philosophy of RX programming. For example, when develo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UniRx - Rx for Unity3d</h1><div class="post__text post__text-html js-mediator-article">  Hello!  I have long wanted to write an article about UniRx on Unity3d.  Let's start with a little philosophy of RX programming.  For example, when developing a game, we create a button, observe a click event of this button and react to it with some kind of code. <br><br>  Reactive programming is all the same, only on steroids, that is, we can create data streams of everything.  And also watch them and respond.  Update, OnCollisionEnter, Coroutine, Event, Mouse input, Keyboard input, Joystick input are all streams. <br>  All that surrounds us is flows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/21/jp/sb/21jpsbnvciqez-gn2e-avj3dthm.jpeg" alt="image"></div><a name="habracut"></a><br>  In addition, we are provided with an amazing set of functions for combining, creating and filtering any of these streams.  This is where ‚Äúfunctional‚Äù magic happens.  A stream can be used as data for another.  Even several streams can be used as data in another stream.  You can combine two streams.  You can filter the stream to get another one that has only those events that interest you.  You can map data values ‚Äã‚Äãfrom one stream to another new. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Streams </h2><br>  In this example, we track the keystroke and turn it into an event. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Observable.EveryUpdate() <span class="hljs-comment"><span class="hljs-comment">//  update .Where(_ =&gt; Input.anyKeyDown) //      .Select(_ =&gt; Input.inputString) //    .Subscribe (x =&gt; { //  OnKeyDown (x); //   OnKeyDown c    }).AddTo (this); //    gameobject- } private void OnKeyDown (string keyCode) { switch (keyCode) { case "w": Debug.Log ("keyCode: W"); break; default: Debug.Log ("keyCode: "+keyCode); break; } }</span></span></code> </pre> <br><h2>  MultiThreading </h2><br>  In this example, we execute a heavy method in thread-e and use the result already obtained in main thread-e. <br><br><pre> <code class="java hljs">Observable.Start (() =&gt; { <span class="hljs-comment"><span class="hljs-comment">//  Observable  thread int n = 100000000; int res = Fibonacci(n); //    return res; //   }).ObserveOnMainThread () //     main thread- .Subscribe (xs =&gt; { //  Debug.Log ("res: "+xs); //     main thread- }).AddTo (this);</span></span></code> </pre><br>  Thus it is very convenient to perform long calculations and work with the network. <br><br><h2>  Httprequest </h2><br>  Since we are talking about working with the network, here is a small example of working with http requests. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = ObservableWWW.Get(<span class="hljs-string"><span class="hljs-string">"http://api.duckduckgo.com/?q=habrahabr&amp;format=json"</span></span>) .Subscribe(x =&gt; { <span class="hljs-comment"><span class="hljs-comment">//  Debug.Log ("res: "+x); //  }, ex =&gt; { //    Debug.Log ("error: "+ex); }); // request.Dispose ();   </span></span></code> </pre><br>  <b>Coroutines</b> <br>  Here we simultaneously launch 3 cortices, turn them into streams and merge them into one stream.  Next, subscribe to this thread. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Observable.WhenAll ( <span class="hljs-comment"><span class="hljs-comment">//  WhenAll    Observable  Observable.FromCoroutine (AsyncA), //      Observable Observable.FromCoroutine (AsyncB), Observable.FromCoroutine (AsyncC) ).Subscribe (_ =&gt; { //        WhenAll Debug.Log ("end"); }).AddTo (this); } IEnumerator AsyncA () { Debug.Log("a start"); yield return new WaitForSeconds (1); Debug.Log("a end"); } IEnumerator AsyncB () { Debug.Log("b start"); yield return new WaitForFixedUpdate (); Debug.Log("b end"); } IEnumerator AsyncC () { Debug.Log("c start"); yield return new WaitForEndOfFrame (); Debug.Log("c end"); }</span></span></code> </pre><br>  We can also run cortinas alternately. <br><br><pre> <code class="java hljs">Observable.FromCoroutine (AsyncA) <span class="hljs-comment"><span class="hljs-comment">//   AsyncA .SelectMany (AsyncB) // AsyncB     AsyncA .SelectMany (AsyncC) //    AsynC .Subscribe(_ =&gt; { Debug.Log ("end"); }).AddTo (this);</span></span></code> </pre><br><h2>  Asynchronous scene loading </h2><br><pre> <code class="java hljs">SceneManager.LoadSceneAsync (<span class="hljs-string"><span class="hljs-string">"HeavyScene"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    .AsAsyncOperationObservable () //    Observable  .Do (x =&gt; { //     Debug.Log ("progress: " + x.progress); //   }).Subscribe (_ =&gt; { //  Debug.Log ("loaded"); }).AddTo (this);</span></span></code> </pre><br>  It is very convenient to use if you first load a light scene with loading screen and already <br>  then asynchronously load a heavy scene, the animations in the loading screen will not hang. <br><br><h2>  Asynchronous resource loading </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SpriteRenderer spriteRenderer = GetComponent&lt;SpriteRenderer&gt; (); Resources.LoadAsync&lt;Sprite&gt; (<span class="hljs-string"><span class="hljs-string">"sprite"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    .AsAsyncOperationObservable () //    Observable  .Subscribe (xs =&gt; { //  if (xs.asset != null) { //   null Sprite sprite = xs.asset as Sprite; //  asset  sprite spriteRenderer.sprite = sprite; //   sprite- } }).AddTo (this); }</span></span></code> </pre><br>  This way you can load prefabs, text resources, and so on. <br><br>  It is also a very handy thing to use when you need to load heavy prefabs or sprites, the game becomes truly responsive, because while something is loading the game does not slow down. <br><br><h2>  Timers </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Observable.Timer (System.TimeSpan.FromSeconds (<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  timer Observable .Subscribe (_ =&gt; { //  Debug.Log (" 3 "); }).AddTo (disposables); //    disposable Observable.Timer (System.TimeSpan.FromSeconds (1)) //  timer Observable .Repeat () //    .Subscribe (_ =&gt; { //  Debug.Log (" 1 "); }).AddTo (disposables); //    disposable } void OnEnable () { //  disposable disposables = new CompositeDisposable(); } void OnDisable () { //   if (disposables != null) { disposables.Dispose (); } }</span></span></code> </pre><br><h2>  MessageBroker </h2><br>  UniRx MessageBroker is an RX publisher-subscriber system, filtered by type. <br><br>  Publisher Subscriber (publisher-subscriber or pub / sub English) is a behavioral design pattern of messaging in which message senders, called publishers, are not directly tied to the subscribers' program code. .  Instead, messages are divided into classes and do not contain information about their subscribers, if any.  Similarly, subscribers deal with one or more classes of messages, abstracting from specific publishers. <br><br>  Sometimes when developing a game, we need to call a method on the component to which we do not have direct access.  Of course, we can use DI or Singleton, but it all depends on the specific case.  And this is when we need to call the method on many objects, or when we just want to use MessageBroker. <br><br>  As it was written above, filtering is done by type and in order not to create a bunch of classes for each subscriber, I created a MessageBase class in which there are fields: sender (MonoBehaviour) for simplified debugging and functionality, id (int) through it, and we will do filtering, data ( System.Object) to transfer some data that needs to be cast.  Also in this class there is a static method (Create) which creates and returns us a MessageBase. <br><br>  Messagebase <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MonoBehaviour sender {get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> set;} <span class="hljs-comment"><span class="hljs-comment">// MonoBehaviour  public int id {get; private set;} // id  public System.Object data {get; private set;} //  public MessageBase (MonoBehaviour sender, int id, System.Object data) { this.sender = sender; this.id = id; this.data = data; } public static MessageBase Create (MonoBehaviour sender, int id, System.Object data) { return new MessageBase (sender, id, data); } }</span></span></code> </pre><br>  I also created the ServiceShareData class for simplified debugging where all the messages are stored for the moment.  This is to ensure that in the development process there is no leakage of the message and confusion in the code. <br><br>  ServiceShareData <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceShareData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MSG_ATTACK = <span class="hljs-number"><span class="hljs-number">1001</span></span>; }</code> </pre><br>  Example of sending a message <br><br><pre> <code class="java hljs">MessageBroker.Default .Publish (MessageBase.Create ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-comment"><span class="hljs-comment">// sender MonoBehaviour ServiceShareData.MSG_ATTACK, // message id "attack!" // data System.Ojbect ));</span></span></code> </pre><br>  The Publish method sends a class that is filtered by type.  We here send MessageBase with sender-ohm this, id by which will be filtering, and at the end of data which in theory can be anything. <br><br>  Message Acceptance Example <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompositeDisposable disposables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ disposables = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeDisposable(); MessageBroker.Default .Receive&lt;MessageBase&gt;() <span class="hljs-comment"><span class="hljs-comment">//   MessageBase .Where(msg =&gt; msg.id == ServiceShareData.MSG_ATTACK)// message  id .Subscribe(msg =&gt; { //  string data = (string)msg.data; //      //      sender-     Debug.Log ("sender:"+msg.sender.name+" receiver:"+name+" data:"+data); }).AddTo (disposables); } void OnDisable () { //  if (disposables != null) { disposables.Dispose (); } }</span></span></code> </pre><br>  The Receive method has a generic type by which it is filtered.  In Where we already do filtering by message id.  It is important to understand that the subscriber (message recipient) will cast data depending on the message id. <br><br><h2>  MVP </h2><br>  An example of a classic MVP pattern.  Where Model serves for data storage and also serialization of data deserialization and so on.  View to display this same data.  Well, Presenter is responsible for business logic. <br><br>  Model <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; count { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> set; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeModel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ count = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; (<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ReactiveProperty c 0 } }</span></span></code> </pre><br>  As you can see here there is a ReactiveProperty in this case, it is an int on steroids for changes of which we can subscribe and respond. <br><br>  View <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text someText; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button someButton; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderCount</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   count someText.text = count.ToString (); } public void AnimateButton () { //   someButton.transform .DOShakeScale (0.5F, 0.3F) //   .OnComplete (() =&gt; { //       someButton.transform.localScale = Vector3.one; }); } }</span></span></code> </pre><br>  View has a text and a button.  As well as methods for animating buttons and displaying data.  For animation, DoTween asset is used. <br><br>  Presenter <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SomeView someView; <span class="hljs-comment"><span class="hljs-comment">// view      public SomeModel someModel = new SomeModel (); // model void Start () { someModel.count // ReactiveProperty count .ObserveEveryValueChanged (x =&gt; x.Value) //     .Subscribe (xs =&gt; { //  someView.RenderCount (xs); //     }).AddTo (this); someView.someButton //  .OnClickAsObservable () //    Observable  .Subscribe (_ =&gt; OnClick (someView.someButton.GetInstanceID ())) .AddTo (this); } private void OnClick (int buttonId) { if (buttonId == someView.someButton.GetInstanceID ()) { someModel.count.Value++; someView.AnimateButton (); } } }</span></span></code> </pre><br>  As you can see, we first subscribe to the changes in the reactiveProperty in order to draw only the changes. <br><br>  Next, we subscribe to the button where, when clicked, the OnClick method will be called in which we push the instanceId (Unity3d guarantees its uniqueness) of this button. <br><br>  And in OnClick there is a check for this very intanceId, then with a click we increase the count (reactiveProperty) and animate the button. <br><br>  I will be glad to questions and comments. <br><br>  I recommend reading: <br>  <a href="https://github.com/neuecc/UniRx">github.com/neuecc/UniRx</a> <br>  <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">gist.github.com/staltz/868e7e9bc2a7b8c1f754</a> <br>  <a href="https://www.reactivemanifesto.org/">www.reactivemanifesto.org</a> <br><br>  <a href="https://bitbucket.org/Neuyazvimyi/unirx-examples">Source</a> </div><p>Source: <a href="https://habr.com/ru/post/342660/">https://habr.com/ru/post/342660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342638/index.html">How we created a new type of tariff "Turn on"</a></li>
<li><a href="../342640/index.html">Configuring Minio and Nginx for the RoR application</a></li>
<li><a href="../342644/index.html">Gorgeous assholes in the making</a></li>
<li><a href="../342654/index.html">Self-oscillations and resonance</a></li>
<li><a href="../342658/index.html">What happens in Kubernetes when starting the kubectl run? Part 1</a></li>
<li><a href="../342666/index.html">Facebook or Google? Where it is more profitable to advertise in 2017</a></li>
<li><a href="../342668/index.html">How to write your first Linux device driver. Part 3</a></li>
<li><a href="../342670/index.html">The experience of identifying one bug or how not to make out your code</a></li>
<li><a href="../342674/index.html">About the rotation matrix in simple words</a></li>
<li><a href="../342676/index.html">Detailed analysis of the crackme01_x64 solution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>