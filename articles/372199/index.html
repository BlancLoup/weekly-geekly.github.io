<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding Dependencies in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I created a small project in the Go language. After several years of working with Java, I was very surprised at how sluggishly dependency in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding Dependencies in Go</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/x4/ha/if/x4haifmwf9qggs5n0vhqywuac9c.png"></div><br>  Recently, I created a small project in the Go language.  After several years of working with Java, I was very surprised at how sluggishly dependency injection (DI) is applied in the Go ecosystem.  For my project, I decided to use the <a href="http://github.com/uber-go/dig">dig</a> library from Uber, and it really impressed me. <br><br>  I found that dependency injection allows you to solve many problems I encountered while working on Go-applications: abuse of the <code>init</code> function and global variables, excessive complexity of setting up applications, etc. <br><br>  In this article I will talk about the basics of dependency injection, as well as show an example of the application before and after applying this mechanism (via the <code>dig</code> library). <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  A quick overview of the dependency injection mechanism </h3><br>  The DI mechanism assumes that dependencies are provided to components (a <code>struct</code> in Go) when they are created externally.  This contrasts with the anti-pattern of components that themselves form their dependencies during initialization.  Let's turn to an example. <br><br>  Suppose you have a <code>Server</code> structure that requires <code>Config</code> to implement its behavior.  As one of the options, the Server can create its own Config structure during initialization. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Server <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { config *Config } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Server{ config: buildMyConfigSomehow(), } }</code> </pre><br>  It looks comfortable.  The calling operator does not need to be aware that the <code>Server</code> requires access to the <code>Config</code> .  Such information is hidden from the user function. <br><br>  However, there are drawbacks.  First of all, if we decide to change the function of creating <code>Config</code> , then along with it we will have to change all those places that cause the corresponding code.  Suppose the <code>buildMyConfigSomehow</code> function now requests an argument.  This means that access to this argument is now needed for any call to this function. <br><br>  In addition, in such a situation it will be difficult to simulate the <code>Config</code> structure for its testing without dependencies.  To test the creation of <code>Config</code> using arbitrary data (monkey testing), we will have to somehow get into the bowels of the <code>New</code> function. <br><br>  But how to solve this problem using DI: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Server <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { config *Config } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Server{ config: config, } }</code> </pre><br>  Now the <code>Server</code> and <code>Config</code> structures are created separately from each other.  We can use any suitable logic to create a <code>Config</code> , and then pass the data to the <code>New</code> function. <br><br>  In addition, if <code>Config</code> is an interface, then we can easily conduct mock testing for it.  Any argument that allows us to implement our interface, we can pass to the <code>New</code> function.  This simplifies testing the <code>Server</code> structure with the help of <code>Config</code> mock objects. <br><br>  The main disadvantage of this approach is the need to manually create a <code>Config</code> structure before we can create a <code>Server</code> .  It is very uncomfortable.  Here we have a dependency graph: first you need to create a <code>Config</code> structure, because <code>Server</code> depends on it.  In real-world applications, such graphs can grow too much, which complicates the logic of creating all the components necessary for the application to work properly. <br><br>  The situation can be corrected by DI due to the following two mechanisms: <br><br><ol><li>  The mechanism of "providing" new components.  In short, it tells the DI framework what components you need to create an object (your dependencies), as well as how to create this object after getting all the necessary components. </li><li>  The mechanism of "extraction" of the created components. </li></ol><br>  The DI framework builds a dependency graph based on the ‚Äúproviders‚Äù that you report to it, and then determines how to create your objects.  This is difficult to explain theoretically, so let's consider one relatively small practical example. <br><br><h3>  Sample application </h3><br>  As an example, let's use an HTTP server code that returns a JSON response when a client makes a <code>GET</code> request to <code>/people</code> .  We will consider it in parts.  To simplify this example, all our code will be in one package ( <code>main</code> ).  In real Go applications, this should not be done.  You can find the full code from this example <a href="http://gitlab.com/drewolson/go_di_example">here</a> . <br>  First, let's turn to the <code>Person</code> structure.  It does not implement any behavior, only a few JSON tags are declared. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"age"`</span></span> }</code> </pre> <br>  In the <code>Person</code> structure there are tags <code>Id</code> , <code>Name</code> and <code>Age</code> .  And that's all. <br><br>  Now look at the <code>Config</code> .  Like <code>Person</code> , this structure has no dependencies.  However, unlike <code>Person</code> , it has a constructor. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Enabled <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DatabasePath <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Port <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Config{ Enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, DatabasePath: <span class="hljs-string"><span class="hljs-string">"./example.db"</span></span>, Port: <span class="hljs-string"><span class="hljs-string">"8000"</span></span>, } }</code> </pre> <br>  The <code>Enabled</code> field determines whether our application will return real data.  The <code>DatabasePath</code> field indicates the path to the database (we use SQlite).  The <code>Port</code> field specifies the port on which our server will run. <br><br>  To connect to the database, we will use the following function.  It works with <code>Config</code> and returns <code>*sql.D</code> B. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sql.DB, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sql.Open(<span class="hljs-string"><span class="hljs-string">"sqlite3"</span></span>, config.DatabasePath) }</code> </pre> <br>  Now look at the <code>PersonRepository</code> structure.  She will be responsible for retrieving information about people from our database and deserializing it into appropriate <code>Person</code> structures. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> PersonRepository <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { database *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(repository *PersonRepository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span></span> { rows, _ := repository.database.Query( <span class="hljs-string"><span class="hljs-string">`SELECT id, name, age FROM people;`</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() people := []*Person{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) rows.Scan(&amp;id, &amp;name, &amp;age) people = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(people, &amp;Person{ Id: id, Name: name, Age: age, }) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> people } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewPersonRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database *sql.DB)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonRepository</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;PersonRepository{database: database} }</code> </pre><br>  The <code>PersonRepository</code> structure requires a database connection.  It provides only one function ‚Äî <code>FindAll</code> , which uses this connection to return a list of <code>Person</code> structures that correspond to information in the database. <br><br>  We need the <code>PersonService</code> structure to create a layer between the HTTP server and <code>PersonRepository</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> PersonService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { config *Config repository *PersonRepository } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service *PersonService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> service.config.Enabled { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.repository.FindAll() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []*Person{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewPersonService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config, repository *PersonRepository)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonService</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;PersonService{config: config, repository: repository} }</code> </pre><br>  <code>PersonService</code> depends not only on <code>Config</code> , but also on <code>PersonRepository</code> .  It contains the <code>FindAll</code> function, which conditionally calls the <code>PersonRepository</code> if the application is enabled. <br><br>  Finally, the <code>Server</code> structure.  It is responsible for executing the HTTP server and sending the corresponding requests to the <code>PersonService</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Server <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { config *Config personService *PersonService } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *Server)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/people"</span></span>, s.people) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mux } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *Server)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { httpServer := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":"</span></span> + s.config.Port, Handler: s.Handler(), } httpServer.ListenAndServe() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *Server)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">people</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { people := s.personService.FindAll() bytes, _ := json.Marshal(people) w.Header().Set(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>) w.WriteHeader(http.StatusOK) w.Write(bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config, service *PersonService)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Server{ config: config, personService: service, } }</code> </pre><br>  <code>Server</code> depends on the <code>PersonService</code> and <code>Config</code> structures. <br>  So, we know all the components.  So how do you now initialize them and start our system? <br><br><h3>  Great and terrible main () </h3><br>  First, let's write the <code>main()</code> function in the traditional way. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { config := NewConfig() db, err := ConnectDatabase(config) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } personRepository := NewPersonRepository(db) personService := NewPersonService(config, personRepository) server := NewServer(config, personService) server.Run() }</code> </pre><br>  First, we set the <code>Config</code> structure.  Then with its help we create a connection to the database.  After that, you can create a <code>PersonRepository</code> structure, and on its basis, a <code>PersonService</code> structure.  Finally, we use all of this to create and launch a <code>Server</code> . <br><br>  Pretty complicated process.  And what's even worse, as our application becomes more complex, the <code>main</code> function will become more and more complicated.  Every time we add dependencies to any of our components, we will have to add logic and re-revise the <code>main</code> function. <br><br>  As you might have guessed, this problem can be solved using the dependency injection mechanism.  Let's find out how to achieve this. <br><br><h3>  Container creation </h3><br>  Within the framework of the DI framework, ‚Äúcontainers‚Äù is the place where you add ‚Äúsuppliers‚Äù and from where you are requesting complete objects.  The <code>dig</code> library provides us with <code>Provide</code> and <code>Invoke</code> functions.  The first one is used to add suppliers, the second one is to retrieve completely finished objects from the container. <br><br>  First create a new container. <br><br> <code>container := dig.New()</code> <br> <br>  Now we can add suppliers.  To do this, call the <code>Provide</code> container function.  It has one argument: a function that can have any number of arguments (they reflect the dependencies of the component being created), as well as one or two return values ‚Äã‚Äã(the component provided by the function and, if necessary, an error). <br><br><pre> <code class="go hljs">container.Provide(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewConfig() })</code> </pre><br>  This code states: ‚ÄúI give the container the type <code>Config</code> .  I don't need anything else to create it. ‚Äù  Now that our container knows how to create a <code>Config</code> type, we can use it to create other types. <br><br><pre> <code class="go hljs">container.Provide(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sql.DB, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConnectDatabase(config) })</code> </pre><br>  The code says: ‚ÄúI give the container the type <code>*sql.DB</code>  To create it, I need <code>Config</code> .  In addition, if necessary, I can return the error. " <br>  In both cases, we are too verbose.  Since we already have the <code>NewConfig</code> and <code>ConnectDatabase</code> functions <code>NewConfig</code> , we can directly use them as providers for the container. <br><br><pre> <code class="go hljs">container.Provide(NewConfig) container.Provide(ConnectDatabase)</code> </pre><br>  Now you can ask the container to provide us with a fully prepared component of any of the proposed types.  For this we use the <code>Invoke</code> function.  The function argument <code>Invoke</code> is a function with any number of arguments.  They are the types that we create our container for. <br><br><pre> <code class="go hljs">container.Invoke(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database *sql.DB)</span></span></span></span> { })</code> </pre><br>  The container performs truly unbanal actions.  Here is what happens: <br><br><ul><li>  the container specifies that we need the type <code>*sql.DB</code> ; </li><li>  it finds out that this type is provided by the <code>ConnectDatabase</code> function; </li><li>  it then determines that the <code>ConnectDatabase</code> function depends on the type of Config; </li><li>  the container finds a provider of type <code>Config</code> - the function <code>NewConfig</code> ; </li><li>  <code>NewConfig</code> has no dependencies, so this function can be called; </li><li>  the resulting <code>Config</code> type resulting from the <code>NewConfig</code> function is passed to the <code>ConnectDatabase</code> function; </li><li>  the result of the function <code>ConnectionDatabase</code> , type <code>*sql.DB</code> , is returned to the <code>*sql.DB</code> the <code>Invoke</code> function. </li></ul><br>  The container does a whole lot of work for us, and in fact even does more.  He is smart enough to create only one instance of each type provided.  And this means that we will never accidentally create an extra connection to the database if we use it in several places (for example, in several repositories). <br><br><h3>  Improved main () version </h3><br>  Now that we know how the <code>dig</code> container works, let's use it to optimize the main function. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dig</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span></span> { container := dig.New() container.Provide(NewConfig) container.Provide(ConnectDatabase) container.Provide(NewPersonRepository) container.Provide(NewPersonService) container.Provide(NewServer) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { container := BuildContainer() err := container.Invoke(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server *Server)</span></span></span></span> { server.Run() }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre><br>  The only thing we haven't encountered yet is the <code>error</code> value returned by the <code>Invoke</code> function.  If any of the providers used by the <code>Invoke</code> function returns an error, the function will be suspended and returned to the caller. <br><br>  Despite the small size of this example, it is easy to note the advantages of this approach compared to the standard <code>main</code> .  The more our application becomes, the more obvious these advantages will be. <br><br>  One of the most important positive moments is the separation of the processes of creating components and their dependencies.  Suppose that our <code>PersonRepository</code> now needs access to the <code>Config</code> .  All we have to do is add <code>Config</code> as an argument to the <code>NewPersonRepository</code> constructor.  No additional code changes are required. <br><br>  Other important advantages include the reduction in the number of global variables and objects used, as well as calls to the init function (dependencies are created only once, when necessary, so you no longer need to use the error-prone <code>init</code> mechanisms).  In addition, this approach allows us to simplify testing of individual components.  Imagine that during testing you create a container and request a complete object.  Or that you need to create an object with fictitious implementations of all its dependencies (mock-object).  All this is much easier to do with the mechanism of dependency injection. <br><br><h3>  Idea worth spreading </h3><br>  I‚Äôm sure that the dependency injection mechanism allows you to create more robust applications that are also easier to test.  The larger the application, the more pronounced this is.  The Go language is great for building large applications, and the <code>dig</code> library is a great tool for dependency injection.  I think that the Go programmers community should pay more attention to DI and more often use this mechanism in applications. </div><p>Source: <a href="https://habr.com/ru/post/372199/">https://habr.com/ru/post/372199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../372189/index.html">What will happen to the eye if you look at the sun through a telescope?</a></li>
<li><a href="../372191/index.html">The boy hacked Instagram and earned $ 10,000</a></li>
<li><a href="../372193/index.html">May not forget about astronomy</a></li>
<li><a href="../372195/index.html">Intel Compute Stick with Core processor. We test the kid for boldness</a></li>
<li><a href="../372197/index.html">Windows 10 update got to live broadcasts Twitch.tv</a></li>
<li><a href="../372201/index.html">SamSat-218 is silent. Possible reason: unopened antenna</a></li>
<li><a href="../372203/index.html">BioQuark company will try to restore the brain of the dead people connected to the life support system</a></li>
<li><a href="../372205/index.html">Roskomnadzor has introduced 11-year-old dinosaur lover Stepa to the Register of Bloggers</a></li>
<li><a href="../372207/index.html">Tesla Model S Master Class: How to fly through the air at a distance of 25 meters in an accident and not kill any of the passengers</a></li>
<li><a href="../372209/index.html">‚ÄúSmart Home‚Äù from Beltelecom. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>