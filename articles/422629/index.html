<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stop feeding the loggers! Give more modifiers! Lazy Static Final Fields. Rough sketch features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It was enough that in Java loggers are initialized at the time of class initialization, why do they litter the entire launch? John Rose to the rescue!...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stop feeding the loggers! Give more modifiers! Lazy Static Final Fields. Rough sketch features</h1><div class="post__text post__text-html js-mediator-article"><p>  It was enough that in Java loggers are initialized at the time of class initialization, why do they litter the entire launch?  John Rose to the rescue! </p><br><p>  Here is what it might look like: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  This document extends the behavior of final variables, allowing you to optionally support lazy execution, both in the language itself and in the JVM.  It is proposed to improve the behavior of the existing lazy evaluation mechanisms by changing the granularity: now it will not be accurate to the class, but accurate to the specific variable. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  Motivation </h1><br><p>  Java is deeply embedded lazy calculations.  Almost every linking operation can jerk a lazy code.  For example, executing the <code>&lt;clinit&gt;</code> method (class initializer bytecode) or using the bootstrap method (for invokedynamic call site or <code>CONSTANT_Dynamic</code> constants). </p><br><p>  Class initializers are something very rough in the sense of granularity when compared to mechanisms using bootstrap methods, since their contract is to run the <em>entire</em> initialization code for the <em>entire</em> class, instead of limiting initialization to a specific class field.  The effects of such a rough initialization are difficult to predict.  It is difficult to isolate the side effects of using a <em>single</em> static class field, since the calculation of a single field leads to the calculation of <em>all</em> static fields of this class. </p><br><p>  If you touch one field, you will touch them all.  In AOT compilers, this makes it especially difficult to optimize static field references, even for fields with easily parsed constant values.  It is worthwhile among the fields to make at least <em>one</em> static static field, and it becomes impossible to analyze <em>all the</em> fields in this class.  A similar problem manifests itself with the previously proposed mechanisms for the implementation of constant convolution (during <em>javac</em> operation) for constant fields with complex initializers. </p><br><p>  An example of a re-initialized field initialization, which occurs in different projects at every step, in each file is the initialization of the logger. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  This innocuous-looking initialization launches a tremendous job under the hood that will be performed during class initialization - and yet it is extremely unlikely that a logger is really needed at the time of class initialization, and maybe not needed at all.  The ability to postpone its creation until the first real use will simplify initialization, and in some cases will allow this initialization to be avoided altogether. </p><br><p>  Final variables are very useful, they are the main mechanism of the Java API in order to indicate the constancy of values.  Lazy variables have also proven themselves.  Starting with Java 7, they began to play an increasingly important role in the internals of the JDK, being annotated with <code>@Stable</code> .  JIT can optimize both final and ‚Äústable‚Äù - variables are much better than just some variables.  Adding lazy final variables will allow this useful usage pattern to become more common, will enable to be used in more places.  Finally, using lazy final variables will allow libraries, such as the JDK, to reduce dependency on the <code>&lt;clinit&gt;</code> code, which, in turn, should reduce launch time and improve the quality of AOT optimizations. </p><br><h1 id="opisanie">  Description </h1><br><p>  The field will be able to be declared with the new <code>lazy</code> modifier, which is a contextual keyword perceived solely as a modifier.  Such a field is called lazy ( <em>lazy field</em> ), and must also have <code>static</code> and <code>final</code> modifiers. </p><br><p>  The lazy field must have an initializer.  The compiler and runtime agree to launch the initializer exactly when the variable is first used, and not during the initialization of the class to which this field belongs. </p><br><p>  Each <code>lazy static final</code> field is associated at compile time with an element of the constant pool that represents its value.  Since the elements of the constant pool themselves are lazily calculated, it is sufficient to simply assign a correctly selected value for each static lazy final variable associated with this element.  (You can bind more than one lazy variable to one element, but this is unlikely to be a useful or meaningful feature.) The attribute name is <code>LazyValue</code> , and it must refer to a constant floor element that can be ldc-stitched to a value that is convertible to a lazy field type .  Only those casts that are already used in <code>MethodHandle.invoke</code> . </p><br><p>  Thus, a lazy static field can be viewed as a named alias to a constant pool member within the class that declared the field.  Tools like compilers can in some way try to use this field. </p><br><p>  A lazy field is never a constant variable (in the sense of JLS 4.12.4) and is explicitly excluded from participation in a constant expression (in the sense of JLS 15.28).  Therefore, it never captures the <code>ConstantValue</code> attribute, even if its initializer is a constant expression.  Instead, a lazy field captures a new kind of classfile attribute called <code>LazyValue</code> , which the JVM <code>LazyValue</code> against when linking to a specific field.  The format of this new attribute is similar to the previous one, because it also points to the constant pool element, in this case, the one that resolves to the field value. </p><br><p>  When a lazy static field is linked, the normal execution process of class initializers should <em>not</em> disappear.  Instead, any <code>&lt;clinit&gt;</code> declaring class method is initialized according to the rules defined in JVMS 5.5.  In other words, <code>getstatic</code> bytecode for a lazy static field performs all the same linking as for <em>any</em> static field.  After initialization (or during the already-started initialization of the current thread), the JVM resolves the constant pool elements associated with the field, and stores the values ‚Äã‚Äãobtained from the constant pool into this same field. </p><br><p>  Since lazy static final cannot be empty, they cannot be assigned any values ‚Äã‚Äã‚Äî even in the small number of contexts where it works for empty final variables. </p><br><p>  During compilation, all lazy static fields are initialized independently of non-lazy static fields, regardless of their location in the source code.  Therefore, restrictions on the location of static fields do not apply to lazy static fields.  An initializer of a lazy static field can use any static field of the same class, regardless of the order in which they occur in the source.  An initializer of any non-static field or a class initializer can refer to a lazy field, regardless of the order in which they are relative to each other in the source code.  Usually, doing this is not the most sensible idea, because it loses the whole meaning of lazy values, but perhaps this can somehow be used in conditional expressions or on a control flow.  Therefore, lazy static fields can be treated more like fields of another class - in the sense that they can be referenced in any order from any part of the class in which they are declared. </p><br><p>  Lazy fields can be detected using the reflection API using two new API methods in <code>java.lang.reflect.Field</code> .  The new <code>isLazy</code> method returns <code>true</code> if and only if the field has the <code>lazy</code> modifier.  The new <code>isAssigned</code> method returns <code>false</code> if and only if the field is lazy and still not initialized at the time of launching <code>isAssigned</code> .  (It can return true almost on the next call in the same thread, depending on the availability of races).  There is no way to tell if a field is initialized, except with <code>isAssigned</code> . </p><br><p>  (The <code>isAssigned</code> call <code>isAssigned</code> needed only to help with rare problems associated with resolving cyclic dependencies. Perhaps we can do without implementing this method. However, people who write code with lazy variables occasionally want to know whether it is set to such a variable value or not yet, in approximately the same way as users of mutexes sometimes want to learn from a mutex, whether it is blocked or not, but they don‚Äôt really want to be blocked) </p><br><p>  There is one unusual restriction on lazy final fields: they should never be initialized to their default values.  That is, the lazy reference field should not be initialized to <code>null</code> , and numeric types should not have a null value.  A lazy boolean value can be initialized with just one value ‚Äî <code>true</code> , because <code>false</code> is its default value.  If the initializer of a lazy static field returns its default value, the linking of this field will drop with the corresponding error. </p><br><p>  This restriction is introduced in order.  to allow JVM implementations to reserve defaults as an internal watchdog value marking the state of an uninitialized field.  The default value is already set in the initial value of any field, set at the time of preparation (this is described in JLS 5.4.2).  So this value naturally already exists at the beginning of the life cycle of any field, and therefore is a logical choice for use as a watchdog value that tracks the status of this field.  Using these rules, the initial default value can never be obtained from a lazy static field.  For this, the JVM can, for example, implement a lazy field as an immutable reference to the corresponding element of the constant pool. </p><br><p>  Restrictions on default values ‚Äã‚Äãcan be circumvented by wrapping values ‚Äã‚Äã(which are possibly equal to default values) in boxes or containers of some convenient type.  The zero number can be wrapped in a non-zero reference to Integer.  Non-primitive types can be wrapped in Optional, which becomes empty if it hits null. </p><br><p>  To support freedom in the way of implementing features, the requirements for the <code>isAssigned</code> method are <code>isAssigned</code> .  If the JVM can prove that a lazy static variable can be initialized without any observable external effects, it can do this initialization at any time.  In this case, <code>isAssigned</code> will return <code>true</code> even if <code>getfield</code> never called.  Only the requirement is imposed on <code>isAssigned</code> , that if it returns <code>false</code> , then none of the side effects of variable initialization should be observed in the current thread.  And if it returns <code>true</code> , then the current thread may observe the side effects of initialization in the future.  Such a contract allows the compiler to replace <code>ldc</code> on <code>getstatic</code> for its own fields, which allows the JVM not to be engaged in tracking detailed states of final variables that have common or degenerate elements in the constant pool. </p><br><p>  Several threads can enter the race for initializing the lazy final field.  As it already happens with <code>CONSTANT_Dynamic</code> , the JVM selects an arbitrary winner of this race and provides the value of this winner to all threads involved in the race, and writes it down for all subsequent attempts to get the value.  To get around the race, specific JVM implementations can try using CAS operations, if the platform supports them - the race winner will see the previous default value, and the losers will see the non-default value that won the race. </p><br><p>  Thus, the existing rules for the single assignment of final variables continue to work and now capture all the complexities of lazy calculations. </p><br><p>  The same logic applies to secure publishing using the final fields ‚Äî it is the same for both lazy and non-lazy fields. </p><br><p>  Note that a class can convert a static field to a lazy static one without violating binary compatibility.  The <code>getstatic</code> client instruction <code>getstatic</code> identical in both cases.  When a variable declaration changes to lazy, <code>getstatic</code> linked in another way. </p><br><h1 id="alternativnye-resheniya">  Alternative solutions </h1><br><p>  You can use nested classes as containers for lazy variables. </p><br><p>  You can define something like a library API to manage lazy values ‚Äã‚Äãor (more generally) any monotonic data. </p><br><p>  Refactor what the lazy static variables were going to do so that they turned into nullar static methods and their bodies were published using ldc CONSTANT_Dynamic constants in some way. </p><br><p>  (Note. The workarounds above do not provide a binary-compatible way to evolutionally untie existing static constants from their tie to <code>&lt;clinit&gt;</code> ) </p><br><p>  If we talk about providing <em>more</em> functionality, you can allow lazy fields to be non-static or non-final, while maintaining the current correspondences and analogies between the behavior of static and non-static fields.  A constant pool cannot be a repository for non-static fields, but it can still hold bootstrap methods (depending on the current instance).  Frozen arrays (if implemented) can get the lazy option.  Such studies are a good basis for future projects based on this document.  And by the way, such opportunities make even more meaningful our decision to ban default values. </p><br><p>  Lazy variables must be initialized with their own initializing expressions.  Sometimes this seems like a very unpleasant limitation, which throws us back into the days of the invention of empty final variables.  Recall that these empty final variables can be initialized by arbitrary blocks of code, including the try-finally logic, and they can be initialized in groups rather than simultaneously.  In the future, it will be possible to try to apply the same possibilities to the lazy final variables.  Perhaps one or more lazy variables may be associated with a private block of initialization code, the task of which is to assign each variable exactly once, as it happens with a class initializer or an object constructor.  The architecture of such a feature can become clearer after the appearance of deconstructors, since the problems they solve in some sense overlap. </p><br><blockquote>  Minute advertising.  The Joker 2018 conference will take place very soon, featuring many prominent Java and JVM specialists.  View the full list of speakers and reports can be <a href="https://jokerconf.com/">on the official site</a> . </blockquote><br><h1 id="avtor">  Author </h1><br><p>  <strong>John Rose</strong> is a JVM engineer and architect at Oracle.  Lead Engineer Da Vinci Machine Project (part of OpenJDK).  Lead Engineer JSR 292 (Supporting Dynamically Typed Languages ‚Äã‚Äãon the Java Platform), deals with the specification of dynamic calls and related issues such as type profiling and advanced compiler optimizations.  Previously, he worked on inner classes, did the original HotSpot port on SPARC, the Unsafe API, and also developed many dynamic, parallel and hybrid languages, including Common Lisp, Scheme ("esh"), dynamic binding for C ++. </p><br><h1 id="perevodchik">  Translator </h1><br><p>  <strong>Oleg Chirukhin</strong> - at the time of this writing, he is working as a community manager in the company JUG.ru Group, engaged in the popularization of the Java platform.  Before joining JRG, he participated in the development of banking and state information systems, the ecosystem of self-written programming languages, and online games.  Current research interests include virtual machines, compilers, and programming languages. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422629/">https://habr.com/ru/post/422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422615/index.html">The whole truth about the RTOS. Article # 9. Scheduler: implementation</a></li>
<li><a href="../422617/index.html">The whole truth about the RTOS. Article # 8. Nucleus SE: Inside and Deployment</a></li>
<li><a href="../422623/index.html">How to secure C</a></li>
<li><a href="../422625/index.html">We talked with Troy Miles, the programmer of Neuromant</a></li>
<li><a href="../422627/index.html">MongoDB and IT Job Market Research</a></li>
<li><a href="../422631/index.html">QIWI-terminals. How to get the most out of simple technologies</a></li>
<li><a href="../422633/index.html">How we automated the control of the work of employees of the federal network of gas stations</a></li>
<li><a href="../422635/index.html">You have not finished saying the word ‚Äúhello‚Äù, and we already know who you are</a></li>
<li><a href="../422637/index.html">Gift geek: protection against avtoAlkash</a></li>
<li><a href="../422641/index.html">Polar night, water tower and smart safe: 5 student projects in the field of IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>