<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[ScanDoc] preprocessing scans</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is believed that the electronic document management system completely eliminates the work with the papers, but it is not. To digitize paper copies ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[ScanDoc] preprocessing scans</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/71e/752/7a3/71e7527a33334dd5b219ab509f71551f.jpg"></div><br><br>  It is believed that the electronic document management system completely eliminates the work with the papers, but it is not.  To digitize paper copies of documents they are usually passed through a scanner.  When the flow of documents and the quality requirements for scans exceed a certain threshold, a number of issues arise that need to be addressed programmatically. <br><br>  What problems have to be solved: <br><ul><li>  Adjust the angle of the image, because  the scanner feeder inevitably tilts the document while drawing.  Sloppiness in important documents is unacceptable. </li><li>  Highlight the useful part on the scan, the rest is to delete, since it is not informative and takes up disk space for nothing. </li><li>  Find and delete blank pages, which will necessarily be in duplex scanning. </li></ul><br><a name="habracut"></a><br>  Algorithms that solve the tasks are developed and probably even posted on the Internet, but it was not possible to find a clear description of them.  Of course, these problems are solved by expensive professional scanners, but it is not always possible to use firmware. <br>  The idea of ‚Äã‚Äãthe article was born just in the process of developing a tool to solve these problems.  I hope it will complement the available information on digitizing documents and will be useful to developers who are engaged in a similar task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider three scans of documents that we received with the help of the good old scanner Futjitsu fi-6140. <br><ol><li>  Scan of the form for obtaining a Tinkoff Bank card; </li><li>  Scan a photocopy of your passport; </li><li>  Scan mail envelope. </li></ol><br><br><img src="https://habrastorage.org/files/21b/e96/e7f/21be96e7f060462db7a0760c638964d2.jpg"><br><br><h2>  Tilt correction </h2><br>  After receiving a scan of the document, you need to bring it to a strictly vertical or horizontal view.  It is understood that arbitrary documents may be submitted to the input without any marks by which the slope can be adjusted.  Therefore, we will bind to the horizontal and vertical components of the document: lines, lines of tables, barcodes, and even fold points. <br>  First of all, we eliminate the redundancy of the image, i.e.  select the contour.  To do this, use the detector borders. <br>  We chose the Kanni Boundary Detector ‚Äî because it gives the highest-quality result. <br><br><img src="https://habrastorage.org/files/82c/34f/aef/82c34faefef047108820bc11abdd4093.jpg"><br><br>  Now on the image you should find straight lines.  For this we use the popular solution used in computer vision - Hough transformation.  I will not describe his principle in detail, it can be found on the Internet.  The essence of the transformation lies in the selection of all possible options for lines in the image and calculating the response for them.  The greater the response, the more pronounced the line.  As a result of the transformation, a phase plane will be constructed, where Y is the angle of inclination, X is the distance to the line. <br><br><img src="https://habrastorage.org/files/649/41a/0e3/64941a0e3a304349a5506acdd88249f6.jpg"><br><br>  On visualization of the phase plane, each pixel corresponds to a unique line.  The coordinates will be calculated by the most pronounced lines. <br><br>  Take the 5 most intense lines, for clarity, we show them on the contour of the original image: <br><br><img src="https://habrastorage.org/files/b24/5f6/a82/b245f6a82d1e456580881bc8a12f7f5c.jpg"><br><br>  It is seen that the angles of inclination of the lines correspond to the inclination of the coordinate axes of the document. <br><br>  To get the angle to which you want to rotate the image, we calculate the angle of deviation of the lines from the global coordinate axes (from 0 and 90 degrees), average the value and get the angle of the image.  Rotate the image on the resulting angle with a minus sign.  Now you can continue working with this image. <br><br>  !  The slope of some lines will be very different from others, i.e.  they are far from parallel.  Such lines are best excluded from the calculations so that they do not spoil the result. <br><br><img src="https://habrastorage.org/files/dff/61b/f9e/dff61bf9e4484aeb9a6b8eae971f4446.jpg"><br><br>  To work with graphics, we used a wonderful library <a href="http://www.aforgenet.com/">aforgenet</a> .  It already has an implementation of the document tilt angle search algorithm described above.  As a result, only 15 lines of code and nalon correction is ready. <br><br>  !  The GetAverageBorderColor function returns the average color of the perimeter of the source image.  It can be replaced by a constant or another more advanced function. <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentAngleCorrection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap image</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grayImage = Grayscale.CommonAlgorithms.RMY.Apply(image); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skewChecker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentSkewChecker(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> angle = skewChecker.GetSkewAngle(grayImage); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (angle &gt;= <span class="hljs-number"><span class="hljs-number">90</span></span>) { angle -= <span class="hljs-number"><span class="hljs-number">90</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (angle &lt;= <span class="hljs-number"><span class="hljs-number">-90</span></span>) { angle += <span class="hljs-number"><span class="hljs-number">90</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateBilinear(-angle, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); rotator.FillColor = GetAverageBorderColor(image); image = rotator.Apply(image); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image; }</code> </pre> <br><br><h2>  Cropping </h2><br>  We have aligned the image.  Now you need to frame his informative part.  At this stage it is important to consider some features. <br><br>  The algorithm should work properly: <br><ul><li>  with any text and background color; </li><li>  with scans of any quality; </li><li>  with documents of any type. </li></ul><br>  We took the assumption as a basis for the algorithm: there will be many differences in brightness in the informative area of ‚Äã‚Äãthe image, but not enough in an empty one.  Therefore, the solution of the problem is reduced to three actions: <br><ol><li>  We divide the images into fragments, count the number of brightness differences vertically and horizontally for each fragment. </li><li>  We are looking for fragments with a large number of brightness differences. </li><li>  Cut out the informative area. </li></ol><br>  For quick access to image pixels, it is best to work with an array of bytes.  It can be obtained as follows: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bitmapData = sourceBitmap.LockBits(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sourceBitmap.Width, sourceBitmap.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = bitmapData.Stride * sourceBitmap.Height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bytes]; System.Runtime.InteropServices.Marshal.Copy(bitmapData.Scan0, sourceBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes);</code> </pre><br>  The algorithm looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sensitivity = <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthQuantum = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regionSize = bitmapData.Width / widthQuantum; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bitmapData.Height + regionSize; y += regionSize) { <span class="hljs-comment"><span class="hljs-comment">// x processing for (var x = 0; x &lt; bitmapData.Width + regionSize; x += regionSize) { // y processing var value = 0; for (var yy = y; (yy &lt; y + regionSize) &amp;&amp; (yy &lt; bitmapData.Height); yy++) { // Horosontal counting var pixel = GetGrayPixel(sourceBytes, bitmapData.Width, x, yy); for (var xx = x; (xx &lt; x + regionSize) &amp;&amp; (xx &lt; bitmapData.Width); xx++) { var nextPixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, yy); if (Math.Abs(pixel - nextPixel) &gt; sensitivity) { value++; } pixel = nextPixel; } } for (var xx = x; (xx &lt; x + regionSize) &amp;&amp; (xx &lt; bitmapData.Width); xx++) { // Vertical counting var pixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, y); for (var yy = y; (yy &lt; y + regionSize) &amp;&amp; (yy &lt; bitmapData.Height); yy++) { var nextPixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, yy); if (Math.Abs(pixel - nextPixel) &gt; sensitivity) { value++; } pixel = nextPixel; } } // value TODO } }</span></span></code> </pre><br><br>  The variable value in the designated place will contain the number of vertical and horizontal brightness variations in the fragment being processed.  This value and fragment coordinates can, for example, be saved to the list. <br><br>  !  The GetGrayPixel function returns the average pixel intensity value. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGrayPixel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = GetShift(w, x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((s + <span class="hljs-number"><span class="hljs-number">3</span></span> &gt; src.Length) || (s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">127</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = src[s++]; b += src[s++]; b += src[s]; b = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(b / <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)b; }</code> </pre><br><br>  After applying the algorithm, we got a map of the image brightness differences.  On which we select the area including the greatest differences. <br><br><img src="https://habrastorage.org/files/992/b20/7c4/992b207c45cb495fbe9db685cb60af07.jpg"><br><br>  !  To save resources, it is better to work with a reduced copy of the image.  Then scale the result and apply to the original image. <br><br><img src="https://habrastorage.org/files/c8f/e44/857/c8fe4485703d49f6accc466cf6f560d1.jpg"><br><br>  See the result.  The algorithm worked correctly - did not leave and did not cut anything extra. <br><br><img src="https://habrastorage.org/files/c26/ba2/1a9/c26ba21a96e3426cbdc6fd3a1d228977.jpg"><br><br>  We got this result in most cases. <br><br><h2>  Remove blank pages </h2><br>  It turned out that the task of removing blank pages of documents appeared after we developed an algorithm for extracting the informative part of the document.  Therefore, to delete empty pages, we used the same algorithm, only slightly modified it.  Instead of building a map of image brightness, we counted the number of fragments with large and small brightness differences.  If there are many high-frequency blocks, the image contains valuable information and is not empty. <br>  It would seem that in order to reduce processing time, you can remove unnecessary pages and frame the image in one approach,  one loop only once.  But it is obvious that you can frame the image only after alignment.  In this case, one would also have to rotate the differential map.  Therefore, in order not to complicate our lives, we have defined the following procedure: <br>  delete blank pages -&gt; tilt correction -&gt; cropping <br>  We got one extra pass through the pixels to calculate the frequency.  But this is not a problem in our time thanks to the law of Gordon Moore. <br><br><div class="spoiler">  <b class="spoiler_title">!</b>  <b class="spoiler_title">Full cheese</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentAngleCorrection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap image</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grayImage = Grayscale.CommonAlgorithms.RMY.Apply(image); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skewChecker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentSkewChecker(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> angle = skewChecker.GetSkewAngle(grayImage); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (angle &gt;= <span class="hljs-number"><span class="hljs-number">90</span></span>) { angle -= <span class="hljs-number"><span class="hljs-number">90</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (angle &lt;= <span class="hljs-number"><span class="hljs-number">-90</span></span>) { angle += <span class="hljs-number"><span class="hljs-number">90</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateBilinear(-angle, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); rotator.FillColor = GetAverageBorderColor(image); image = rotator.Apply(image); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAverageBorderColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> widthProcImage = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)<span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceImage = bitmap; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sizeFactor = widthProcImage / sourceImage.Width; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> procBtmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(sourceImage, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round(sourceImage.Width * sizeFactor), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round(sourceImage.Height * sizeFactor)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bitmapData = procBtmp.LockBits(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, procBtmp.Width, procBtmp.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = Math.Abs(bitmapData.Stride) * procBtmp.Height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bytes]; System.Runtime.InteropServices.Marshal.Copy(bitmapData.Scan0, sourceBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); channels.Add(<span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); channels.Add(<span class="hljs-string"><span class="hljs-string">'g'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); channels.Add(<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bitmapData.Height; y++) { <span class="hljs-comment"><span class="hljs-comment">// vertical var c = GetColorPixel(sourceBytes, bitmapData.Width, 0, y); channels['r'] += cR; channels['g'] += cG; channels['b'] += cB; cnt++; c = GetColorPixel(sourceBytes, bitmapData.Width, bitmapData.Width - 1, y); channels['r'] += cR; channels['g'] += cG; channels['b'] += cB; cnt++; } for (var x = 0; x &lt; bitmapData.Width; x++) { // horisontal var c = GetColorPixel(sourceBytes, bitmapData.Width, x, 0); channels['r'] += cR; channels['g'] += cG; channels['b'] += cB; cnt++; c = GetColorPixel(sourceBytes, bitmapData.Width, x, bitmapData.Height - 1); channels['r'] += cR; channels['g'] += cG; channels['b'] += cB; cnt++; } procBtmp.UnlockBits(bitmapData); var r = (int)Math.Round(((double)channels['r']) / cnt); var g = (int)Math.Round(((double)channels['g']) / cnt); var b = (int)Math.Round(((double)channels['b']) / cnt); var color = Color.FromArgb(r &gt; 255 ? 255 : r, g &gt; 255 ? 255 : g, b &gt; 255 ? 255 : b); return color; } private static byte GetGrayPixel(byte[] src, int w, int x, int y) { var s = GetShift(w, x, y); if ((s + 3 &gt; src.Length) || (s &lt; 0)) { return 127; } int b = src[s++]; b += src[s++]; b += src[s]; b = (int)(b / 3.0); return (byte)b; } private static Color GetColorPixel(byte[] src, int w, int x, int y) { var s = GetShift(w, x, y); if ((s + 3 &gt; src.Length) || (s &lt; 0)) { return Color.Gray; } byte r = src[s++]; byte b = src[s++]; byte g = src[s]; var c = Color.FromArgb(r, g, b); return c; } private static int GetShift(int width, int x, int y) { return y * width * 3 + x * 3; } public static bool DocumentDetectInfo(Bitmap image) { const double widthProcImage = 200; const int sens = 15; const int treshold = 25; const int widthQuantum = 10; var sourceImage = image; var sizeFactor = widthProcImage / sourceImage.Width; var procBtmp = new Bitmap(sourceImage, (int)Math.Round(sourceImage.Width * sizeFactor), (int)Math.Round(sourceImage.Height * sizeFactor)); var bd = procBtmp.LockBits(new Rectangle(0, 0, procBtmp.Width, procBtmp.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb); var bytes = Math.Abs(bd.Stride) * procBtmp.Height; var source = new byte[bytes]; System.Runtime.InteropServices.Marshal.Copy(bd.Scan0, source, 0, bytes); var maxV = 0; var size = bd.Width / widthQuantum; var hight = 0; var low = 0; for (var y = 0; y &lt; bd.Height + size; y += size) { // x processing for (var x = 0; x &lt; bd.Width + size; x += size) { // y processing var value = 0; for (var yy = y; (yy &lt; y + size) &amp;&amp; (yy &lt; bd.Height); yy++) { // Horosontal counting var pixel = GetGrayPixel(source, bd.Width, x, yy); for (var xx = x; (xx &lt; x + size) &amp;&amp; (xx &lt; bd.Width); xx++) { var point = GetGrayPixel(source, bd.Width, xx, yy); if (Math.Abs(pixel - point) &gt; sens) { value++; } pixel = point; } } for (var xx = x; (xx &lt; x + size) &amp;&amp; (xx &lt; bd.Width); xx++) { // Vertical counting var pixel = GetGrayPixel(source, bd.Width, xx, y); for (var yy = y; (yy &lt; y + size) &amp;&amp; (yy &lt; bd.Height); yy++) { var point = GetGrayPixel(source, bd.Width, xx, yy); if (Math.Abs(pixel - point) &gt; sens) { value++; } pixel = point; } } maxV = Math.Max(maxV, value); if (value &gt; treshold) { hight++; } else { low++; } } } double cnt = hight + low; hight = (int)Math.Round(hight / cnt * 100); procBtmp.UnlockBits(bd); return (hight &gt; treshold); } public static Bitmap DocumentCropInfo(Bitmap image) { const double widthProcImage = 1000; const int sensitivity = 25; const int treshold = 50; const int widthQuantum = 100; var sourceImage = image; var sizeFactor = widthProcImage / sourceImage.Width; var procBtmp = new Bitmap(sourceImage, (int)Math.Round(sourceImage.Width * sizeFactor), (int)Math.Round(sourceImage.Height * sizeFactor)); var bitmapData = procBtmp.LockBits(new Rectangle(0, 0, procBtmp.Width, procBtmp.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb); var bytes = Math.Abs(bitmapData.Stride) * procBtmp.Height; var sourceBytes = new byte[bytes]; System.Runtime.InteropServices.Marshal.Copy(bitmapData.Scan0, sourceBytes, 0, bytes); var x1 = procBtmp.Width; var y1 = procBtmp.Height; var x2 = 0; var y2 = 0; var maxV = 0; var pointList = new List&lt;Point&gt;(); var regionSize = bitmapData.Width / widthQuantum; for (var y = 0; y &lt; bitmapData.Height + regionSize; y += regionSize) { // x processing for (var x = 0; x &lt; bitmapData.Width + regionSize; x += regionSize) { // y processing var value = 0; for (var yy = y; (yy &lt; y + regionSize) &amp;&amp; (yy &lt; bitmapData.Height); yy++) { // Horosontal counting var pixel = GetGrayPixel(sourceBytes, bitmapData.Width, x, yy); for (var xx = x; (xx &lt; x + regionSize) &amp;&amp; (xx &lt; bitmapData.Width); xx++) { var nextPixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, yy); if (Math.Abs(pixel - nextPixel) &gt; sensitivity) { value++; } pixel = nextPixel; } } for (var xx = x; (xx &lt; x + regionSize) &amp;&amp; (xx &lt; bitmapData.Width); xx++) { // Vertical counting var pixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, y); for (var yy = y; (yy &lt; y + regionSize) &amp;&amp; (yy &lt; bitmapData.Height); yy++) { var nextPixel = GetGrayPixel(sourceBytes, bitmapData.Width, xx, yy); if (Math.Abs(pixel - nextPixel) &gt; sensitivity) { value++; } pixel = nextPixel; } } pointList.Add(new Point() { V = value, X = x, Y = y }); maxV = Math.Max(maxV, value); } } var vFactor = 255.0 / maxV; foreach (var point in pointList) { var v = (byte)(point.V * vFactor); if (v &gt; treshold) { x1 = Math.Min(x1, point.X); y1 = Math.Min(y1, point.Y); x2 = Math.Max(x2, point.X + regionSize); y2 = Math.Max(y2, point.Y + regionSize); } } procBtmp.UnlockBits(bitmapData); x1 = (int)Math.Round((x1 - regionSize) / sizeFactor); x2 = (int)Math.Round((x2 + regionSize) / sizeFactor); y1 = (int)Math.Round((y1 - regionSize) / sizeFactor); y2 = (int)Math.Round((y2 + regionSize) / sizeFactor); var bigRect = new Rectangle(x1, y1, x2 - x1, y2 - y1); var clippedImg = CropImage(sourceImage, bigRect); return clippedImg; } public static Bitmap CropImage(Bitmap source, Rectangle section) { section.X = Math.Max(0, section.X); section.Y = Math.Max(0, section.Y); section.Width = Math.Min(source.Width, section.Width); section.Height = Math.Min(source.Height, section.Height); var bmp = new Bitmap(section.Width, section.Height); var g = Graphics.FromImage(bmp); g.DrawImage(source, 0, 0, section, GraphicsUnit.Pixel); return bmp; } private class Point { public int X; public int Y; public int V; }</span></span></code> </pre><br></div></div><br><br><h2>  Conclusion </h2><br>  Algorithms do an excellent job with their task to this day.  It is likely that this is not the most effective solution.  Therefore, we invite everyone in the comments to discuss other possible algorithms and approaches to solve a specific problem. <br><br>  <b>See you soon!</b> </div><p>Source: <a href="https://habr.com/ru/post/278073/">https://habr.com/ru/post/278073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278051/index.html">Patch gnupg or a pair of RSA-32768 in 106 minutes</a></li>
<li><a href="../278053/index.html">Apple hired the author Signal</a></li>
<li><a href="../278055/index.html">A little about data storage and experience 1cloud</a></li>
<li><a href="../278069/index.html">Machine Learning: Questions and Answers</a></li>
<li><a href="../278071/index.html">Citrix Tech Exchange Moscow 2016: how it changed my attitude to Xen</a></li>
<li><a href="../278075/index.html">How I reinvented dictionaries in Python</a></li>
<li><a href="../278083/index.html">Docker-compose switch to version 2</a></li>
<li><a href="../278085/index.html">Consul.io Part 1</a></li>
<li><a href="../278087/index.html">DIY: SQL JOIN in Java</a></li>
<li><a href="../278089/index.html">How does split-testing in Badoo work?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>