<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[Translation] Arrays, slices (and lines): The mechanism of 'insertion'</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 One of the most common features of procedural programming languages ‚Äã‚Äãis the concept of an array. Arrays may seem something simple, but...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[Translation] Arrays, slices (and lines): The mechanism of 'insertion'</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  One of the most common features of procedural programming languages ‚Äã‚Äãis the concept of an array.  Arrays may seem something simple, but on the other hand, before adding them to a language, several issues need to be solved, such as: <br><ul><li>  Fixed or variable size? </li><li>  Is size a part of type? </li><li>  What will multidimensional arrays be? </li><li>  What is the concept of an empty array? </li></ul><br>  Answers to these questions will define arrays as a simple language feature, or as the main part of its design. <br><a name="habracut"></a><br>  In the early days of Go, finding answers to these questions took years of discussion before their concept began to look the way we thought it needed.  The key step was the creation of the concept of <i>slices</i> , which are based on fixed-size arrays in order to create a flexible and extensible data structure.  However, many newcomers to Go stumble over the principles of the slices, perhaps this is due to the fact that their experience with other languages ‚Äã‚Äãhas left its mark. <br><br>  In this publication we will try to dispel all these misunderstandings.  We will achieve this piece by piece by explaining how the <b>append</b> function works, and why it works this way and no other way. <br><br><h4>  Arrays </h4><br>  Arrays are an important piece of the Go language, but, like the foundation of a building, it is hidden under more visible parts.  We must get you up to date before moving on to more interesting, powerful, and noticeable slice features. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Arrays are not often seen in Go programs, because the size of an array includes its size, which limits its use. <br><br>  For example the announcement: <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer [<span class="hljs-number"><span class="hljs-number">256</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span></code> </pre> <br>  creates a variable <b>buffer</b> that contains 256 bytes.  The type of the <b>buffer</b> variable includes the size and looks like this: <b>[256] byte</b> .  An array of 512 bytes will be of type <b>[512] byte</b> . <br><br>  The data associated with the array is simply an array of elements.  Schematically, our buffer in memory will look something like this: <br><pre> <code class="go hljs">buffer: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ... <span class="hljs-number"><span class="hljs-number">256</span></span> times ... <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span></code> </pre><br>  That is, the variable contains 256 bytes of data and nothing more.  We can access the elements using the usual indexing syntax <b>buffer [0]</b> , <b>buffer [1]</b> , and so on until <b>buffer [255]</b> (the index from 0 to 255 covers 256 elements).  Attempting to go beyond this range will cause the program to crash. <br><br>  There is a built-in <b>len</b> function that returns the number of elements in an array, a slice, and some other types.  Obviously, what exactly will return <b>len</b> for an array.  In our case, <b>len (buffer)</b> will return the value 256. <br><br>  For arrays you can find your place of application.  For example, they are good for transforming matrices, but their most frequent use in Go is storing slices. <br><br><h4>  Slices: Slice Header </h4><br>  Cuts where something interesting happens, but before you start using them, you will need to understand their need and what they are doing. <br><br>  A slice is a data structure that describes the multiple division of an array and is stored separately from a variable.  <i>Slice is not an array</i> .  A slice <i>describes a</i> portion of the array. <br><br>  If we take the <b>buffer</b> array from the previous section, then we can create a slice that will describe elements from 100 to 150 (to be exact, then from 100 to 149 inclusive) by <i>cutting the</i> array: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> = buffer[<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">150</span></span>]</code> </pre><br>  In this piece of code, to be precise, we used the full declaration of the variable.  The variable <b>slice</b> is of type <b>[] byte</b> , reads as a ‚Äúslice of bytes‚Äù and is created from the <b>buffer</b> array, by cutting starting from element 100 (inclusive) to 150 (exclusively).  In a more ‚Äúcanonical‚Äù syntax, we would omit the type that will be defined during the initialization process: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slice = buffer[<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">150</span></span>]</code> </pre><br>  And inside the function, we would use the short form of the declaration: <br><pre> <code class="go hljs">slice := buffer[<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">150</span></span>]</code> </pre><br>  What is a slice?  This is not a complete description, but from now on, think of a slice as a small structure consisting of two elements: a length and a pointer to an array element.  Consider that "behind the scenes" it looks like this: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> sliceHeader <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Length <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ZerothElement *<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } slice := sliceHeader{ Length: <span class="hljs-number"><span class="hljs-number">50</span></span>, ZerothElement: &amp;buffer[<span class="hljs-number"><span class="hljs-number">100</span></span>], }</code> </pre><br>  Of course, this is just an illustration.  Despite this, from this example it can be understood that the <b>sliceHeader</b> structure <b>is</b> inaccessible to the programmer, and the type of the pointer depends on the type of elements, but it makes it possible to understand the basic idea of ‚Äã‚Äãthe mechanics of the slices. <br><br>  So far, we have used the array cutting operation, however we can cut and cut: <br><pre> <code class="go hljs">slice2 := slice[<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br><br>  Just as before, this operation creates a new slice, but in this case from elements from 5 to 9 (inclusive) relative to the original slice, which means elements from 105 to 109 of the original array.  The basic <b>sliceHeader</b> structure for the <b>slice2</b> variable will look like this: <br><pre> <code class="go hljs">slice2 := sliceHeader{ Length: <span class="hljs-number"><span class="hljs-number">5</span></span>, ZerothElement: &amp;buffer[<span class="hljs-number"><span class="hljs-number">105</span></span>], }</code> </pre><br>  Notice that the header still points to the underlying array in the <b>buffer</b> variable. <br><br>  We can also <i>re-cut</i> , which means to cut a slice and save the result in the structure of the slice cut.  Those.  after: <br><pre> <code class="go hljs">slice = slice[<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br>  the <b>sliceHeader</b> structure for the <b>slice</b> variable will look the same as for the <b>slice2</b> variable.  You will often see re-slicing, for example to shorten the cut.  In this example, the first and last element of our slice will be omitted: <br><pre> <code class="go hljs">slice = slice[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre><br>  You can often hear from experienced Go programmers about the ‚Äúslice header‚Äù because  this is what is stored in the slice variable.  For example, when you call a function that takes a slice as an argument, such as <b><a href="http://golang.org/pkg/bytes/">bytes.IndexRune</a></b> , then a header will be passed to the function.  In this example: <br><pre> <code class="go hljs">slashPos := bytes.IndexRune(slice, <span class="hljs-string"><span class="hljs-string">'/'</span></span>)</code> </pre><br>  the <b>slice</b> argument will be passed to the <b>IndexRune</b> function and, in fact, this is just a ‚Äúslice header‚Äù. <br><br>  There is another data element in the "slice header" that we will discuss below, but first, let's take a look at what the "slice header" means when you write a program that uses slices. <br><br><h4>  Passing Cuts to Functions </h4><br>  It is very important to understand that even if the slice contains a pointer, in itself it is a value.  Under the hood, it is a structure containing a pointer and a length.  This is <i>not a</i> pointer to a structure. <br><br>  It is important. <br><br>  When we call <b>IndexRune</b> in the previous example, it takes a <i>copy of the</i> ‚Äúheader top‚Äù.  This behavior has an important consequence. <br><br>  Consider a simple function: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddOneToEachElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> slice { slice[i]++ } }</code> </pre><br>  She does exactly what is written in the title, i.e.  bypasses all elements of the slice (using the <b>for range</b> loop), increasing its elements. <br><br>  Try: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { slice := buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice); i++ { slice[i] = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(i) } fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>, slice) AddOneToEachElement(slice) fmt.Println(<span class="hljs-string"><span class="hljs-string">"after"</span></span>, slice) }</code> </pre><br>  Despite the fact that the ‚Äú <i>slice header</i> ‚Äù is passed to the function, it includes a pointer to the array elements, therefore, the original slice header and its copy describe the same array.  As a consequence, when the function is completed, the changed elements can be seen through the original slice. <br><br>  The function argument is actually a copy, and this example shows it: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubtractOneFromLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { slice = slice[<span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slice } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Before: len(slice) ="</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)) newSlice := SubtractOneFromLength(slice) fmt.Println(<span class="hljs-string"><span class="hljs-string">"After: len(slice) ="</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)) fmt.Println(<span class="hljs-string"><span class="hljs-string">"After: len(newSlice) ="</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(newSlice)) }</code> </pre><br>  Here we see that the <i>contents of the</i> argument can be changed through the function, but not its <i>title</i> .  The length is stored in the variable <b>slice</b> and does not change as a result of a function call, since a copy of the slice header, not the original, is passed to the function.  Thus, if we want to write a function that changes the title, we must return it, as we did in the example.  The variable <b>slice</b> does not change, but the return value has a new length, which is stored in <b>newSlice</b> . <br><br><h4>  Pointers to slices: Methods for obtaining </h4><br>  There is another way of writing a function that changes the title of the slice, and this is the transfer to the function a pointer to the slice.  Here is a variation of our example, to demonstrate this possibility: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PtrSubtractOneFromLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slicePtr *[]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { slice := *slicePtr *slicePtr = slice[<span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)<span class="hljs-number"><span class="hljs-number">-1</span></span>] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Before: len(slice) ="</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)) PtrSubtractOneFromLength(&amp;slice) fmt.Println(<span class="hljs-string"><span class="hljs-string">"After: len(slice) ="</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)) }</code> </pre><br>  The example may seem a bit clumsy, given the additional level of abstraction (temporary variable), but there is one case where you will use pointers to slices.  It is accepted to use the pointer as a receiver when writing a method that changes the slice. <br><br>  Let's say we wanted a method that eliminates the last slash.  We can write it like this: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> path []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *path)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TruncateAtFinalSlash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { i := bytes.LastIndex(*p, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> { *p = (*p)[<span class="hljs-number"><span class="hljs-number">0</span></span>:i] } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { pathName := path(<span class="hljs-string"><span class="hljs-string">"/usr/bin/tso"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     path pathName.TruncateAtFinalSlash() fmt.Printf("%s\n", pathName) }</span></span></code> </pre><br>  If you run the example, you will see what happens, what is required, that is, the method will change the slice. <br><br>  On the other hand, if we want to write a method for <b>path</b> that sets upper case of ASCII characters (no behavior is not defined in English letters), the method can operate on a value, not a pointer, because the value of the receiver still points to the array we need. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> path []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p path)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToUpper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, b := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> &lt;= b &amp;&amp; b &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span> { p[i] = b + <span class="hljs-string"><span class="hljs-string">'A'</span></span> - <span class="hljs-string"><span class="hljs-string">'a'</span></span> } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { pathName := path(<span class="hljs-string"><span class="hljs-string">"/usr/bin/tso"</span></span>) pathName.ToUpper() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, pathName) }</code> </pre><br>  Here, the <b>ToUpper</b> method uses two variables in <b>for range</b> in order to use the index of the element and, directly, the slice element itself.  This will avoid re-writing to <b>p [i]</b> . <br><br><h4>  Capacity </h4><br>  Consider the following function, which increases the <b>ints</b> slice by one element: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, element </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice) slice = slice[<span class="hljs-number"><span class="hljs-number">0</span></span> : n+<span class="hljs-number"><span class="hljs-number">1</span></span>] slice[n] = element <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slice }</code> </pre><br>  Now run: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iBuffer [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slice := iBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; i++ { slice = Extend(slice, i) fmt.Println(slice) } }</code> </pre><br>  Let's see how the cut grows until ... it does not grow. <br><br>  It's time to talk about the third component of the slice header: its <i>capacity</i> .  In addition to the pointer to the array and its length, the slice header contains its capacity: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> sliceHeader <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Length <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Capacity <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ZerothElement *<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre><br>  The <b>Capacity</b> field contains a record of how much space the array actually occupies - this is the maximum value that <b>Length</b> can reach.  An attempt to increase the slice above its capacity will lead to going beyond the array and will cause an emergency program termination. <br><br>  This example creates a slice <br><pre> <code class="go hljs">slice := iBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  and its title looks like: <br><pre> <code class="go hljs">slice := sliceHeader{ Length: <span class="hljs-number"><span class="hljs-number">0</span></span>, Capacity: <span class="hljs-number"><span class="hljs-number">10</span></span>, ZerothElement: &amp;iBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], }</code> </pre><br>  The <b>Capacity</b> field is equivalent to the length of the original array minus the index of the array element, which is the first slice element (zero in this case).  If you want to know the capacity of the slice, then use the function <b>cap</b> : <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice) == <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice) { fmt.Println(<span class="hljs-string"><span class="hljs-string">"slice is full!"</span></span>) }</code> </pre><br><br><h4>  Make </h4><br>  What if we want to increase the cut more than its capacity?  We can not!  By definition, capacity is the limit of growth.  But you can get the same result by creating a new array, copying the data and changing the slice describing the new array. <br><br>  Let's start with the selection.  We can use the <b>new</b> function to select a larger array and as a result of a larger slice, but it will be easier to use the <b>make</b> function.  It allocates a new array and creates a slice header.  The <b>make</b> function has three arguments: the type of the slice, the initial length, and its capacity, where the length of the array is what <b>make</b> allocates for the slice data.  As a result, this function call creates a slice of length 10 and the possibility of expanding by 5 (15-10), which you can see by running this: <br><pre> <code class="go hljs"> slice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"len: %d, cap: %d\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice))</code> </pre><br>  This fragment doubles the capacity of our <b>int</b> slice, but leaves the same length: <br><pre> <code class="go hljs"> slice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"len: %d, cap: %d\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice)) newSlice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> slice { newSlice[i] = slice[i] } slice = newSlice fmt.Printf(<span class="hljs-string"><span class="hljs-string">"len: %d, cap: %d\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice))</code> </pre><br>  After this, the cut has much more room to grow before it needs another redistribution. <br><br>  When creating cuts, it often happens that the length and capacity are the same.  The <b>make</b> function has an abbreviated version.  The default length becomes capacity, so you can specify them in one value.  After <br><pre> <code class="go hljs">gophers := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Gopher, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  at the cut of <b>gophers the</b> length and capacity will be equal to 10. <br><br><h4>  Copying </h4><br>  After we doubled the capacity of our slice in the previous section, we rewrote the cycle to copy the old data into the new slice.  Go has a built-in <b>copy</b> function that simplifies this task.  Her arguments are two slices and she copies the data from the right to the left.  Here is our example rewritten to use <b>copy</b> : <br><pre> <code class="go hljs"> newSlice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice)) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(newSlice, slice)</code> </pre><br>  The <b>copy</b> function is smart.  It copies only what it can, paying attention to the length of both arguments.  In other words, the number of elements to be copied is equal to the minimum of the lengths of both slices.  This can save a bit of ‚Äúbureaucracy‚Äù.  In addition, <b>copy</b> returns an integer value - the number of elements that were copied, although this is not always worth checking. <br><br>  The <b>copy</b> function also takes into account cases where the source and receiver intersect (note lane is like memmove () in C), which means that the function can be used to move elements inside one slice.  Below is an example of how to use the <b>copy</b> function to insert a value in the middle of the slice <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//        , //      . //        . func Insert(slice []int, index, value int) []int { //      slice = slice[0 : len(slice)+1] //  copy           copy(slice[index+1:], slice[index:]) //   . slice[index] = value //  . return slice }</span></span></code> </pre><br>  There are a few points you can notice in this function.  First, obviously, it must return the cut, because its length has changed.  Secondly, a convenient abbreviation is used.  Expression <br><pre> <code class="go hljs">slice[i:]</code> </pre><br>  means the same as <br><pre> <code class="go hljs">slice[i:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice)]</code> </pre><br>  In addition, we did not use another trick; we can also leave the first element of the expression empty;  by default it will be zero.  In this way <br><pre> <code class="go hljs">slice[:]</code> </pre><br>  Means just a slice of oneself, which is useful when slicing an array.  This expression is the shortest to say: ‚Äúa slice that describes all the elements of the array‚Äù: <br><pre> <code class="go hljs">array[:]</code> </pre><br>  But it was between times, let's try our function <b>Insert</b> . <br><pre> <code class="go hljs"> slice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  capacity &gt; length:     . for i := range slice { slice[i] = i } fmt.Println(slice) slice = Insert(slice, 5, 99) fmt.Println(slice)</span></span></code> </pre><br><br><h4>  Insert: Example </h4><br>  Several sections ago, we wrote the <b>Extend</b> function, which expanded the slice by one element.  It was wrong, at least for the reason that in the case where the cutoff capacity was too small, the function could fail with an error (in our example, the <b>Insert</b> function is subject to the same problem).  Now we know how to fix it, so let's write a reliable implementation of the <b>Extend</b> function for integer slices. <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, element </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice) { <span class="hljs-comment"><span class="hljs-comment">//  ;  . //       1,     ,      newSlice := make([]int, len(slice), 2*len(slice)+1) copy(newSlice, slice) slice = newSlice } slice = slice[0 : n+1] slice[n] = element return slice }</span></span></code> </pre><br>  In this case, it is especially important to return the slice, since when we redistributed it, the slice that we got describes a completely different array.  Here is a small piece to show what happens if the cut is filled: <br><pre> <code class="go hljs"> slice := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++ { slice = Extend(slice, i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"len=%d cap=%d slice=%v\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(slice), <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(slice), slice) fmt.Println(<span class="hljs-string"><span class="hljs-string">"address of 0th element:"</span></span>, &amp;slice[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }</code> </pre><br>  Note the redistribution when the original array of size 5 is filled.  The capacity and address of the zero element changes when a new array is allocated. <br><br>  Using the robust <b>Extend</b> function as a basis, we can write an even better function that will allow us to extend the slice with several elements.  To do this, we use the Go option by reversing the list of arguments in an array.  That is, we use the Go feature to use a variable number of function arguments. <br><br>  Let's call the function <b>Append</b> .  For the first version, we can simply call <b>Extend</b> until the function arguments have run out.  The prototype for the <b>Append</b> function looks like this: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(slice []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, items ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre><br>  This tells us that <b>Append</b> takes one argument, a slice, followed by an <b>int</b> argument from zero to infinity.  These elements are future pieces of the slice, as you can see: <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Append    . //  :    Extend. func Append(slice []int, items ...int) []int { for _, item := range items { slice = Extend(slice, item) } return slice }</span></span></code> </pre><br>  Notice that the <b>for range</b> loop is executed for each element of the <b>items</b> argument, which is of type <b>[] int</b> .  Also note the use of an empty identifier _, which drops the index, since we do not need it in the loop. <br><br>  Try it: <br><pre> <code class="go hljs"> slice := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>} fmt.Println(slice) slice = Append(slice, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) fmt.Println(slice)</code> </pre><br>  Another new technique in this example is that the slice initialization is produced by a compound literal, which consists of the type and slice elements enclosed in braces: <br><pre> <code class="go hljs"> slice := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}</code> </pre><br>  The function <b>Append</b> is also interesting for another reason.  We can not just add elements, we can pass whole slices as arguments of the function using ...: <br><pre> <code class="go hljs"> slice1 := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>} slice2 := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">66</span></span>, <span class="hljs-number"><span class="hljs-number">77</span></span>} fmt.Println(slice1) slice1 = Append(slice1, slice2...) <span class="hljs-comment"><span class="hljs-comment">// '...' ! fmt.Println(slice1)</span></span></code> </pre><br>  Of course, we can make <b>Append</b> more efficient, by single selection, based on <b>Extend</b> : <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Append    . //  . func Append(slice []int, elements ...int) []int { n := len(slice) total := len(slice) + len(elements) if total &gt; cap(slice) { // .    1.5 ,     . newSize := total*3/2 + 1 newSlice := make([]int, total, newSize) copy(newSlice, slice) slice = newSlice } slice = slice[:total] copy(slice[n:], elements) return slice }</span></span></code> </pre><br>  Notice that here we use <b>copy</b> twice to move the data slice to a new memory location and then copy the added elements to the end of the old data. <br><br>  Try it, the behavior is the same as before: <br><pre> <code class="go hljs"> slice1 := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>} slice2 := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">66</span></span>, <span class="hljs-number"><span class="hljs-number">77</span></span>} fmt.Println(slice1) slice1 = Append(slice1, slice2...) <span class="hljs-comment"><span class="hljs-comment">// '...' ! fmt.Println(slice1)</span></span></code> </pre><br><br><h4>  Append: Built-in function </h4><br>  So, we came to the conclusion that in Go you need to add the built-in function <b>append</b> .  It does the same thing as our function <b>Append</b> from the example, with the same efficiency, but it works for any type of slices. <br><br>  The weakness of Go is that any operation defined on a "generic type" must be provided at run time.  Someday this may change, but now, in order to simplify working with slices, Go provides the built-in common <b>append</b> function.  It works the same as our integer version, but for <i>any</i> type of slice. <br><br>  Remember that since the slice header is updated every time you call <b>append</b> , you need to save the resulting slice after the call.  In fact, the compiler will not allow you to call <b>append</b> without saving the result. <br><br>  Here are some single lines with a conclusion.  Try them, change and explore: <br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//    . slice := []int{1, 2, 3} slice2 := []int{55, 66, 77} fmt.Println("Start slice: ", slice) fmt.Println("Start slice2:", slice2) //    . slice = append(slice, 4) fmt.Println("Add one item:", slice) //     . slice = append(slice, slice2...) fmt.Println("Add one slice:", slice) //    (int). slice3 := append([]int(nil), slice...) fmt.Println("Copy a slice:", slice3) //      . fmt.Println("Before append to self:", slice) slice = append(slice, slice...) fmt.Println("After append to self:", slice)</span></span></code> </pre><br><br>  It is worthwhile to stop and think about the last lines of the example and understand how the slice design allows you to make such simple calls correct. <br><br>  There are many examples on the " <a href="https://code.google.com/p/go-wiki/wiki/SliceTricks">Slice Tricks</a> " wiki (community created) that use <b>append</b> , <b>copy,</b> and other ways to use slices. <br><br><h4>  Nil </h4><br>  In addition, using the newly acquired knowledge, we can understand what a ‚Äúzero‚Äù ( <b>nil</b> ) slice is.  Naturally, this is the zero value of the slice header: <br><pre> <code class="go hljs">sliceHeader{ Length: <span class="hljs-number"><span class="hljs-number">0</span></span>, Capacity: <span class="hljs-number"><span class="hljs-number">0</span></span>, ZerothElement: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, }</code> </pre><br>  or simply <br><pre> <code class="go hljs">sliceHeader{}</code> </pre><br>  The key is that the pointer is also <b>nil</b> .  This cut <br><pre> <code class="go hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  It has zero length (and may even have zero capacity), but its pointer is not <b>nil</b> , so this is still not a zero slice. <br><br>  Obviously, an empty cut can grow (assuming that it is not a zero capacity), but the ‚Äúzero‚Äù ( <b>nil</b> ) cut does not contain an array where values ‚Äã‚Äãcan be put and cannot grow, even to contain at least one element. <br><br>  It should be noted that the ‚Äúzero‚Äù ( <b>nil</b> ) cut is, in fact, equivalent to a cut of zero length, even if it does not indicate anything.  It has zero length and you can add something to it with a selection.   ,     ,   ,  ¬´¬ª ( <b>nil</b> ) . <br><br><h4>  Strings </h4><br>      Go   . <br><br>   ,   :      ,        . <br><br>      ,     (    ),            . <br><br>  ,    ,     : <br><pre> <code class="go hljs">slash := <span class="hljs-string"><span class="hljs-string">"/usr/ken"</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//   '/'</span></span></code> </pre><br>       : <br><pre> <code class="go hljs">usr := <span class="hljs-string"><span class="hljs-string">"/usr/ken"</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-comment"><span class="hljs-comment">//   "/usr"</span></span></code> </pre><br>    ,    ,    . <br><br> -           ,   : <br><pre> <code class="go hljs">str := <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(slice)</code> </pre><br>  -     : <br><pre> <code class="go hljs">slice := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(usr)</code> </pre><br>        ,       ,    .  ,           . Go     , -    .    ,            . <br><br>          ,      .   ,     .      ,               - . <br><br>  :      ,        ,         .       . <br><br> ,         ,      . <br><br><h4>  Conclusion </h4><br>    ,     .    ,  ,             .    ,   ,    . <br><br>  ,     ,       ,    ,      <b>copy</b>  <b>append</b> . <br><hr><br>   ‚Äî <a href="http://blog.golang.org/slices">blog.golang.org/slices</a> </div><p>Source: <a href="https://habr.com/ru/post/202948/">https://habr.com/ru/post/202948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202930/index.html">Watson Cookies</a></li>
<li><a href="../202934/index.html">Payoneer and Pond5: new opportunities for stockers</a></li>
<li><a href="../202942/index.html">252 characters minicraft</a></li>
<li><a href="../202944/index.html">Small Javascript programs: where to go</a></li>
<li><a href="../202946/index.html">Get message - a list of your email with a preview on the google search page</a></li>
<li><a href="../202950/index.html">Melitopol - stratosphere - Tikhonovka</a></li>
<li><a href="../202952/index.html">ScienceHub # 07: Neurointelligence and Neuromorphic Systems</a></li>
<li><a href="../202954/index.html">Creating virtual photo objects</a></li>
<li><a href="../202956/index.html">Clearance of Tesla electric vehicles increased firmware upgrade</a></li>
<li><a href="../202958/index.html">DIY-dimmer: Fees from Itead Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>