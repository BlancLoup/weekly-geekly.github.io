<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Masking Bitmaps on Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 When developing for Android, quite often there is a task to put a mask on the image. Most often you want to round the corners of the ph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search"></a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings"></a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">猬锔</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">猬锔</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Masking Bitmaps on Android</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/7a1/945/18c/7a194518c95e43a3a7a3953cb4209dd3"><br><br><h1>  Introduction </h1><br>  When developing for Android, quite often there is a task to put a mask on the image.  Most often you want to round the corners of the photos or make the image completely round.  But sometimes masks and more complex forms are used. <br><br>  In this article, I want to analyze the tools available in the Android developers arsenal for solving such problems and choose the most successful of them.  The article will be useful primarily to those who are faced with the need to implement the imposition of the mask manually, without using third-party libraries. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I assume that the reader has experience in developing for Android and is familiar with the Canvas, Drawable and Bitmap classes. <br><br>  The code used in the article can be found on <a href="https://github.com/ArkadyGamza/MaskingBitmaps">GitHub</a> . <br><a name="habracut"></a><br><h1>  Formulation of the problem </h1><br>  Suppose we have two images that are represented by Bitmap objects.  One of them contains the original image, and the second - a mask in its alpha channel.  It is required to display an image with a superimposed mask. <br><br>  Usually the mask is stored in resources, and the image is loaded over the network, but in our example both images are loaded from resources with the following code: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadImages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.picture); mMaskBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.mask_circle).extractAlpha(); }</code> </pre> <br>  Note the <code>.extractAlpha()</code> : this call creates a Bitmap with the configuration ALPHA_8, which means that one byte is spent on one pixel, which encodes the transparency of this pixel.  In such a format it is very advantageous to store masks, since the color information in them does not carry a payload and it can be thrown out. <br><br>  Now, when the images are loaded, you can move on to the most interesting - overlaying the mask.  What means for this can be used? <br><br><h1>  PorterDuff modes </h1><br>  One of the proposed solutions could be the use of PorterDuff-mode overlay images on canvas (Canvas).  Let's refresh in memory what it is. <br><br><h2>  Theory </h2><br>  We introduce the notation (as in the <a href="https://www.w3.org/TR/2002/WD-SVG11-20020215/masking.html">standard</a> ): <br><br><ul><li>  Da (destination alpha) the original pixel transparency of the canvas; </li><li>  Dc (destination color) - the original pixel color of the canvas; </li><li>  Sa (source alpha) - pixel transparency of the overlay image; </li><li>  Sc (source color) - the pixel color of the overlay image; </li><li>  Da '- transparency of the canvas canvas after overlaying; </li><li>  Dc 'is the color of the canvas piskel after overlaying. </li></ul><br>  The mode is determined by the rule by which Da 'and Dc' are determined depending on Dc, Da, Sa, Sc. <br><br>  Thus, we have 4 parameters for each pixel.  The formula by which the color and transparency of the pixel of the final image is obtained from these four parameters is the description of the blending mode. <br><br>  [Da ', Dc'] = f (Dc, Da, Sa, Sc) <br><br>  For example, for the DST_IN mode, <br><br>  Da '= Sa 路 Da <br>  Dc '= Sa 路 Dc <br><br>  or in the compact notation [Da ', Dc'] = [Sa 路 Da, Sa 路 Dc].  In the Android documentation, it looks like <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2ca/110/ba7/2ca110ba7fe6472a8020dc639bc93eb7"></div><br>  Hopefully, now you can link to overly concise Google documentation.  Without prior explanation, contemplation thereof often puts developers into a stupor: <a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html">developer.android.com/reference/android/graphics/PorterDuff.Mode.html</a> . <br><br>  But to think in your mind how the final picture of these formulas will look like is quite tiresome.  It is much more convenient to use this crib for the blending modes: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/765/371/fa4/765371fa46a84d70b354d261185dec56"></div><br>  From this cheat sheet you can immediately see the SRC_IN and DST_IN modes of interest.  They are essentially the intersection of opaque areas of the canvas and the overlay image, while DST_IN leaves the color of the canvas, and SRC_IN changes color.  If the picture was originally drawn on the canvas, then select DST_IN.  If the mask was originally painted on the canvas, select SRC_IN. <br><br>  Now that everything is clear, you can write code. <br><br><h2>  Src_in </h2><br>  Quite often on stackoverflow.com there are answers where, when using PorterDuff, it is recommended to allocate memory for the buffer.  Sometimes even it is suggested to do this with every onDraw call.  Of course, it is extremely inefficient.  You should try to avoid any allocation of memory on a heap in onDraw at all.  Its even more surprising to see Bitmap.createBitmap there, which can easily require several megabytes of memory.  A simple example: a 640 * 640 picture in the ARGB format takes up more than 1.5 MB in memory. <br><br>  To avoid this, the buffer can be allocated in advance and reused in onDraw calls. <br>  Here is an example Drawable that uses SRC_IN mode.  Memory for buffer is allocated when resizing Drawable. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaskedDrawablePorterDuffSrcIn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mPictureBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mMaskBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mBufferBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Canvas mBufferCanvas; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Paint mPaintSrcIn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Paint(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaskedDrawablePorterDuffSrcIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mPaintSrcIn.setXfermode(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap pictureBitmap)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = pictureBitmap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMaskBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap maskBitmap)</span></span></span><span class="hljs-function"> </span></span>{ mMaskBitmap = maskBitmap; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBoundsChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rect bounds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onBoundsChange(bounds); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = bounds.width(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = bounds.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (width &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || height &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mBufferBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); mBufferCanvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Canvas(mBufferBitmap); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPictureBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mMaskBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mBufferCanvas.drawBitmap(mMaskBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mBufferCanvas.drawBitmap(mPictureBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, mPaintSrcIn); <span class="hljs-comment"><span class="hljs-comment">//dump the buffer canvas.drawBitmap(mBufferBitmap, 0, 0, null); }</span></span></code> </pre><br>  In the example above, a mask is first drawn onto the buffer canvas, then a picture is drawn in the SRC_IN mode. <br><br>  The attentive reader will notice that this code is not optimal.  Why redraw the buffer canvas each time draw is called?  After all, you can do it only when something has changed. <br><br><div class="spoiler">  <b class="spoiler_title">Optimized code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaskedDrawablePorterDuffSrcIn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaskedDrawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mPictureBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mMaskBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mBufferBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Canvas mBufferCanvas; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Paint mPaintSrcIn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Paint(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MaskedDrawableFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaskedDrawableFactory() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MaskedDrawable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMaskedDrawable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaskedDrawablePorterDuffSrcIn(); } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaskedDrawablePorterDuffSrcIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mPaintSrcIn.setXfermode(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap pictureBitmap)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = pictureBitmap; redrawBufferCanvas(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMaskBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap maskBitmap)</span></span></span><span class="hljs-function"> </span></span>{ mMaskBitmap = maskBitmap; redrawBufferCanvas(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBoundsChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rect bounds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onBoundsChange(bounds); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = bounds.width(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = bounds.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (width &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || height &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mBufferBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mBufferBitmap.getWidth() == width &amp;&amp; mBufferBitmap.getHeight() == height) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mBufferBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); <span class="hljs-comment"><span class="hljs-comment">//that's too bad mBufferCanvas = new Canvas(mBufferBitmap); redrawBufferCanvas(); } private void redrawBufferCanvas() { if (mPictureBitmap == null || mMaskBitmap == null || mBufferCanvas == null) { return; } mBufferCanvas.drawBitmap(mMaskBitmap, 0, 0, null); mBufferCanvas.drawBitmap(mPictureBitmap, 0, 0, mPaintSrcIn); } @Override public void draw(Canvas canvas) { //dump the buffer canvas.drawBitmap(mBufferBitmap, 0, 0, null); } @Override public void setAlpha(int alpha) { mPaintSrcIn.setAlpha(alpha); } @Override public void setColorFilter(ColorFilter cf) { //Not implemented } @Override public int getOpacity() { return PixelFormat.UNKNOWN; } @Override public int getIntrinsicWidth() { return mMaskBitmap != null ? mMaskBitmap.getWidth() : super.getIntrinsicWidth(); } @Override public int getIntrinsicHeight() { return mMaskBitmap != null ? mMaskBitmap.getHeight() : super.getIntrinsicHeight(); } }</span></span></code> </pre><br></div></div><br><h2>  DST_IN </h2><br>  Unlike SRC_IN, when using DST_IN, you must change the order of drawing: first, a picture is drawn onto the canvas, and a mask on top.  Changes from the previous example will be as follows: <br><br><pre> <code class="java hljs">mPaintDstIn.setXfermode(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PorterDuffXfermode(PorterDuff.Mode.DST_IN)); mBufferCanvas.drawBitmap(mPictureBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mBufferCanvas.drawBitmap(mMaskBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, mPaintDstIn);</code> </pre><br>  Curiously, this code does not give the expected result if the mask is in ALPHA_8 format.  If it is presented in an inefficient format ARGB_8888, then everything is fine.  <a href="http://stackoverflow.com/questions/38552580/android-porterduff-mode-dst-in-combined-with-bitmap-config-alpha-8">The question</a> on stackoverflow.com currently hangs without an answer.  If someone knows the reason - please share knowledge in the comments. <br><br><h2>  CLEAR + DST_OVER </h2><br>  In the examples above, the memory for the buffer was allocated only when the size of the Drawable was changed, which is much better than allocating it at each drawing. <br><br>  But if you think about it, in some cases you can do without allocating a buffer at all and drawing directly onto the canvas, which we were transferred to draw.  It should be borne in mind that something has already been drawn on it. <br><br>  To do this, in the canvas, we kind of cut a hole in the shape of the mask using the CLEAR mode, and then draw a picture in the DST_OVER mode - figuratively speaking, we enclose the picture under the canvas.  Through this hole, you can see the picture and the effect is just what we need. <br><br>  Such a trick can be used when it is known that the mask and the image do not contain translucent areas, but only either completely transparent or completely opaque pixels. <br><br>  The code will look like this: <br><br><pre> <code class="java hljs">mPaintDstOver.setXfermode(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PorterDuffXfermode(PorterDuff.Mode.DST_OVER)); mPaintClear.setXfermode(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PorterDuffXfermode(PorterDuff.Mode.CLEAR)); <span class="hljs-comment"><span class="hljs-comment">//draw the mask with clear mode canvas.drawBitmap(mMaskBitmap, 0, 0, mPaintClear); //draw picture with dst over mode canvas.drawBitmap(mPictureBitmap, 0, 0, mPaintDstOver);</span></span></code> </pre><br>  This solution has problems with transparency.  If we want to implement the setAlpha method, then the window background will appear through the image, and not at all what was painted on the canvas under our Drawable.  Compare images: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f26/200/61c/f2620061c2e04a419a86bfda21b1f6e5"></div><br>  On the left - as it should be, on the right - as it turns out, if you use CLEAR + DST_OVER in combination with translucency. <br><br>  As you can see, the use of PorterDuff modes on Android is associated either with the allocation of extra memory or with restriction of use.  Fortunately, there is a way to avoid all these problems.  Just use BitmapShader. <br><br><h1>  BitmapShader </h1><br>  Usually, when shaders are mentioned, OpenGL is remembered.  But do not be afraid, the use of BitmapShader on Android does not require knowledge of the developer in this area.  In fact, the implementations of android.graphics.Shader describe an algorithm that determines the color of each pixel, that is, they are pixel shaders. <br><br>  How to use them?  Very simple: if you load the shader in Paint, then everything that is drawn using this Paint will take the color of the pixels from the shader.  The package has shader implementations for drawing gradients, combining other shaders, and (most useful in the context of our task) BitmapShader, which is initialized with a Bitmap.  This shader returns the color of the corresponding pixels from the Bitmap that was transmitted during initialization. <br><br>  There is an important clarification in the documentation: you can draw anything with a shader except Bitmap.  In fact, if the Bitmap is in ALPHA_8 format, then when drawing such a Bitmap using a shader, everything works fine.  And our mask is just in this format, so let's try to display the mask using a shader that uses images of a flower. <br><br>  Steps: <br><br><ul><li>  create a BitmapShader into which we upload a flower image; </li><li>  create Paint, in which we charge this BitmapShader; </li><li>  draw a mask with this Paint. </li></ul><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap src)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = src; mBitmapShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapShader(mPictureBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); mPaintShader.setShader(mBitmapShader); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPaintShader == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mMaskBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } canvas.drawBitmap(mMaskBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, mPaintShader); }</code> </pre><br>  It's very simple, is not it?  In fact, if the dimensions of the mask and the image do not match, then we will see not exactly what was expected.  The mask will be tiled with images, which corresponds to the used <code>Shader.TileMode.REPEAT</code> mode. <br><br>  To bring the size of the image to the size of the mask, you can use the method <a href="https://developer.android.com/reference/android/graphics/Shader.html">android.graphics.Shader # setLocalMatrix</a> , in which you need to transfer the transformation matrix.  Fortunately, there is no need to recall the course of analytical geometry: the android.graphics.Matrix class contains convenient methods for matrix formation.  We will compress the shader so that the image fits completely into the mask without distortion of proportions, and move it so as to combine the centers of the image and the mask: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateScaleMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPictureBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mMaskBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskW = mMaskBitmap.getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskH = mMaskBitmap.getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pictureW = mPictureBitmap.getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pictureH = mPictureBitmap.getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wScale = maskW / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) pictureW; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hScale = maskH / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) pictureH; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scale = Math.max(wScale, hScale); Matrix matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matrix(); matrix.setScale(scale, scale); matrix.postTranslate((maskW - pictureW * scale) / <span class="hljs-number"><span class="hljs-number">2f</span></span>, (maskH - pictureH * scale) / <span class="hljs-number"><span class="hljs-number">2f</span></span>); mBitmapShader.setLocalMatrix(matrix); }</code> </pre><br>  Also, the use of the shader gives us the ability to easily implement the methods for changing the transparency of our Drawable and installing ColorFilter.  Just call the shader methods of the same name. <br><br><div class="spoiler">  <b class="spoiler_title">Summary code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaskedDrawableBitmapShader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mPictureBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mMaskBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Paint mPaintShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Paint(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BitmapShader mBitmapShader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMaskBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap maskBitmap)</span></span></span><span class="hljs-function"> </span></span>{ mMaskBitmap = maskBitmap; updateScaleMatrix(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap src)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = src; mBitmapShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapShader(mPictureBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); mPaintShader.setShader(mBitmapShader); updateScaleMatrix(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPaintShader == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mMaskBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } canvas.drawBitmap(mMaskBitmap, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, mPaintShader); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateScaleMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPictureBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mMaskBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskW = mMaskBitmap.getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskH = mMaskBitmap.getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pictureW = mPictureBitmap.getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pictureH = mPictureBitmap.getHeight(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wScale = maskW / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) pictureW; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hScale = maskH / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) pictureH; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scale = Math.max(wScale, hScale); Matrix matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matrix(); matrix.setScale(scale, scale); matrix.postTranslate((maskW - pictureW * scale) / <span class="hljs-number"><span class="hljs-number">2f</span></span>, (maskH - pictureH * scale) / <span class="hljs-number"><span class="hljs-number">2f</span></span>); mBitmapShader.setLocalMatrix(matrix); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAlpha</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ mPaintShader.setAlpha(alpha); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setColorFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ColorFilter cf)</span></span></span><span class="hljs-function"> </span></span>{ mPaintShader.setColorFilter(cf); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOpacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PixelFormat.UNKNOWN; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntrinsicWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mMaskBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? mMaskBitmap.getWidth() : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getIntrinsicWidth(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntrinsicHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mMaskBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? mMaskBitmap.getHeight() : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getIntrinsicHeight(); } }</code> </pre><br></div></div><br>  In my opinion, this is the most successful solution to the problem: no buffer allocation is required, there are no problems with transparency.  Moreover, if the mask is of a simple geometric shape, then you can refuse to load the Bitmap with the mask and draw the mask programmatically.  This will save the memory needed to store the mask as a Bitmap. <br><br>  For example, the mask used in this article as an example is a fairly simple geometric shape that is easy to draw. <br><br><div class="spoiler">  <b class="spoiler_title">Code example</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FixedMaskDrawableBitmapShader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bitmap mPictureBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Paint mPaintShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Paint(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BitmapShader mBitmapShader; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Path mPath; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap src)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = src; mBitmapShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapShader(mPictureBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); mPaintShader.setShader(mBitmapShader); mPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(); mPath.addOval(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, getIntrinsicWidth(), getIntrinsicHeight(), Path.Direction.CW); Path subPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(); subPath.addOval(getIntrinsicWidth() * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, getIntrinsicHeight() * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, getIntrinsicWidth(), getIntrinsicHeight(), Path.Direction.CW); mPath.op(subPath, Path.Op.DIFFERENCE); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPictureBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } canvas.drawPath(mPath, mPaintShader); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAlpha</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ mPaintShader.setAlpha(alpha); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setColorFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ColorFilter cf)</span></span></span><span class="hljs-function"> </span></span>{ mPaintShader.setColorFilter(cf); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOpacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PixelFormat.UNKNOWN; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntrinsicWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPictureBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? mPictureBitmap.getWidth() : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getIntrinsicWidth(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntrinsicHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPictureBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? mPictureBitmap.getHeight() : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getIntrinsicHeight(); } }</code> </pre><br></div></div><br>  Since the shader can be used to draw anything, you can try to draw text, for example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPictureBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap src)</span></span></span><span class="hljs-function"> </span></span>{ mPictureBitmap = src; mBitmapShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapShader(mPictureBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); mPaintShader.setShader(mBitmapShader); mPaintShader.setTextSize(getIntrinsicHeight()); mPaintShader.setStyle(Paint.Style.FILL); mPaintShader.setTextAlign(Paint.Align.CENTER); mPaintShader.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPictureBitmap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } canvas.drawText(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, getIntrinsicWidth() / <span class="hljs-number"><span class="hljs-number">2</span></span>, getIntrinsicHeight() * <span class="hljs-number"><span class="hljs-number">0.9f</span></span>, mPaintShader); }</code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/b46/3d9/b96/b463d9b9635542e1971d5aefaa873ded"><br><br><h1>  RoundedBitmapDrawable </h1><br>  It is useful to know about the existence of the class RoundedBitmapDrawable in the Support Library.  It can be useful if you only need to round the edges or make the picture completely round.  Inside is used BitmapShader. <br><br><h1>  Performance </h1><br>  Let's see how the above solutions affect performance.  For this, I used RecyclerView with hundreds of items.  Graphics GPU monitor shot with fast scrolling on a fairly productive smartphone (Moto X Style). <br><br>  Let me remind you that on the graphs on the abscissa axis is time, on the ordinate axis is the number of milliseconds spent on drawing each frame.  Ideally, the graph should be placed below the green line, which corresponds to 60 FPS. <br><br><img src="https://habrastorage.org/files/9af/dce/37b/9afdce37baf44e46a2e57e4ea2225cf8"><br>  Plain BitmapDrawable (no masking) <br><br><img src="https://habrastorage.org/files/0dc/97e/a2e/0dc97ea2e4b14d43bd7cf3ae360fa152"><br>  Src_in <br><br><img src="https://habrastorage.org/files/c7b/63b/019/c7b63b019ce040c6b3c1b8c4bb1fccde"><br>  BitmapShader <br><br>  It can be seen that using BitmapShader allows you to achieve the same high frame rate as without masking the mask at all.  While the SRC_IN solution can no longer be considered sufficiently productive, the interface noticeably slows down with fast scrolling, which is confirmed by the schedule: many frames are rendered longer than 16 ms, and some more than 33 ms, that is, FPS drops below 30. <br><br><h1>  findings </h1><br>  In my opinion, the advantages of the approach using BitmapShader are obvious: no need to allocate memory for the buffer, excellent flexibility, support for translucency, high performance. <br>  It is not surprising that this approach is used in library implementations. <br><br>  Share your thoughts in the comments! <br><br>  Be with you at <a href="http://stackoverflow.com/">stackoverflow.com</a> ! </div><p>Source: <a href="https://habr.com/ru/post/310618/">https://habr.com/ru/post/310618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310606/index.html">Cluster Docker Swarm in 30 seconds</a></li>
<li><a href="../310608/index.html">Why is it profitable to create a payment business in Europe</a></li>
<li><a href="../310612/index.html">Finding out how to increase WiFi coverage</a></li>
<li><a href="../310614/index.html">IL2CPP: method calls</a></li>
<li><a href="../310616/index.html">Data Leaks in Health: The New Plague</a></li>
<li><a href="../310620/index.html">Comparison of analytical in-memory databases</a></li>
<li><a href="../310622/index.html">Using Google Cloud Speech API v2 in Asterisk to recognize Russian speech</a></li>
<li><a href="../310626/index.html">Little about energy technology and IT</a></li>
<li><a href="../310628/index.html">"Friday and the sea knee-deep": 5 skills that do not require talent</a></li>
<li><a href="../310630/index.html">"To moderate appetites": Several ways to improve the energy efficiency of data centers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>