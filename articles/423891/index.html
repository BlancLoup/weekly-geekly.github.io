<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expression trees in enterprise development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For most developers, the use of expression tree is limited to lambda expressions in LINQ. Often, we don‚Äôt attach any importance to how the technology ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expression trees in enterprise development</h1><div class="post__text post__text-html js-mediator-article">  For most developers, the use of expression tree is limited to lambda expressions in LINQ.  Often, we don‚Äôt attach any importance to how the technology works under the hood. <br><br>  In this article I will show you advanced techniques for working with expression trees: eliminating code duplication in LINQ, code generation, metaprogramming, transpiling, test automation. <br><br>  You will learn how to use expression tree directly, which pitfalls the technology has prepared and how to get around them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/e5/qh/tt/e5qhttxqyi5a27s-4dtlt2jq1mo.png"><br><br>  Under the cut - video and text transcript of <a href="https://dotnext-piter.ru/2018/spb/talks/2ijzwfkh84aecgiokae06o/">my report</a> with DotNext 2018 Piter. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J2XzsCoJM4o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  My name is Maxim Arshinov, I am the co-founder of the outsourcing company "Hightech Group".  We are developing software for business, and today I will tell you about the use of the expression tree technology in everyday work and how it began to help us. <br><br>  I never specifically wanted to study the internal structure of expression trees, it seemed that it was some kind of internal technology for the .NET Team, so that LINQ worked, and its API was not necessary for application programmers.  It turned out that there were some applied problems that needed to be solved.  So that I liked the decision, I had to crawl "in the gut." <br><br>  This whole story is stretched in time, there were different projects, different cases.  Something crawled out, and I finished writing, but I will allow myself to sacrifice historical truthfulness in favor of a greater artistic expression, so all the examples will be on the same subject model - the online store. <br><br><img src="https://habrastorage.org/webt/g5/yf/cr/g5yfcrf13ptoovmcheym1x15fdk.png"><br><br>  Imagine that we are all writing an online store.  It has products and a tick "For sale" in the admin panel.  In the public part, we will display only those products for which this tick is marked. <br><br><img src="https://habrastorage.org/webt/cg/_e/jt/cg_ejtgmxn1u0hq12ezlonenue8.png"><br><br>  We take some DbContext or NHibernate, we write Where (), IsForSale we deduce. <br><br>  Everything is good, but business rules are not the same, so we wrote them once and for all.  They evolve over time.  The manager comes in and says that it is necessary to keep track of the balance and bring only goods that have leftovers to the public part, without forgetting the check. <br><br><img src="https://habrastorage.org/webt/8e/b1/mz/8eb1mzde7casnjrrilroqxpp8ku.png"><br><br>  Easy to add such a property.  Now our business rules are encapsulated, we can reuse them. <br><br><img src="https://habrastorage.org/webt/6s/yj/09/6syj09lcwmeiktufuwl4a4wzvyq.png"><br><br>  Let's try to edit LINQ.  Is everything good here? <br>  No, this will not work, because IsAvailable does not map to the database, this is our code, and the query provider does not know how to parse it. <br><br><img src="https://habrastorage.org/webt/qb/yt/dp/qbytdpgh5ybdiua4kjpc-rouxbs.png"><br><br>  We can tell him that in our property is such a story.  But now this lambda is duplicated in both the linq-expression and the property. <br><br><pre><code class="cs hljs">Where(x =&gt; x.IsForSale &amp;&amp; x.InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) IsAvailable =&gt; IsForSale &amp;&amp; InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  So the next time this lambda changes, we have to do Ctrl + Shift + F on the project.  Naturally, we all will not find - bugs and time.  I want to avoid this. <br><br><img src="https://habrastorage.org/webt/8b/8b/j8/8b8bj8voopaagucck7rcl1j9tcg.png"><br><br>  We can go from this side and put another ToList () in front of Where ().  This is a bad decision, because if there is a million goods in the database, everyone rises to the RAM and is filtered there. <br><br><img src="https://habrastorage.org/webt/ca/2t/2g/ca2t2gbdetsmcijcefubnokpfeu.png"><br><br>  If you have three products in the store, the solution is good, but in E-commerce there are usually more of them.  This worked only because, despite the similarity of the lambda with each other, their type is completely different.  In the first case, this is the Func delegate, and in the second, the expression tree.  It looks the same, the types are different, the bytecode is completely different. <br><br><img src="https://habrastorage.org/webt/2l/qi/ya/2lqiya8v9axdrfchqrdqtrxbe4o.png"><br><br>  To go from expression to a delegate, simply call the Compile () method.  This API provides .NET: there is expression - compiled, received a delegate. <br><br>  But how to go back?  Is there something in .NET to move from delegate to expression trees?  If you are familiar with LISP, for example, then there is a citation mechanism that allows the code to be interpreted as a data structure, but in .NET there is no such thing. <br><br><h1>  Ekspreshny or delegates? </h1><br>  Considering that we have two types of lambdas, we can philosophize what is primary: expression tree or delegates. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// so slo-oooooo-ow var delegateLambda = expressionLambda.Compile();</span></span></code> </pre> <br>  At first glance, the answer is obvious: since there is a wonderful Compile () method, expression tree is primary.  And we have to get the delegate by compiling the expression.  But compilation is a slow process, and if we start to do this everywhere, we will get performance degradation.  In addition, we will get it in random places, where expression had to be compiled into a delegate, there will be a performance drop.  You can search for these places, but they will affect the server response time, and randomly. <br><br><img src="https://habrastorage.org/webt/ur/jw/y_/urjwy_veoqpl7udanxvc3-ddsl8.png"><br><br>  Therefore, they must somehow be cached.  If you listened to a report about concurrent data structures, then you know about ConcurrentDictionary (or just know about it).  I will omit the details about caching methods (with locks, not locks).  Simply, ConcurrentDictionary has a simple method GetOrAdd (), and the simplest implementation: put it into ConcurrentDictionary and cache.  The first time we get the compilation, but then everything will be quick, because the delegate has already been compiled. <br><br><img src="https://habrastorage.org/webt/h1/wp/gb/h1wpgbo_5pi3xhnfaivvvjsz4ks.png"><br><br>  Then you can use this extension method, you can use and refactor our code with IsAvailable (), describe the expression, compile and call IsAvailable () properties relative to the current object this. <br><br>  There are at least two packages that implement this: <a href="https://github.com/damieng/Linq.Translations/tree/master/Microsoft.Linq.Translations">Microsoft.Linq.Translations</a> and <a href="https://github.com/signumsoftware/framework">Signum Framework</a> (open-source framework written by a commercial company).  And there, and there is about the same story with the compilation of delegates.  A bit different API, but as I showed on the previous slide. <br><br>  However, this is not the only approach, and you can go from delegates to expressions.  For a long time on Habr√© there is <a href="https://habrahabr.ru/post/155437/">an article</a> about Delegate Decompiler, where the author claims that all compilations are bad, because they are long. <br><br>  In general, delegates had earlier expressions, and it is possible to move on from delegates to them.  For this, the author uses the methodBody.GetILAsByteArray ();  from Reflection, which really returns the entire IL-code of the method as a byte array.  If this is stuck further in Reflection, then you can get an objective representation of this case, go through it and build an expression tree.  Thus, the reverse transition is also possible, but it has to be done by hand. <br><br><img src="https://habrastorage.org/webt/_r/pp/d5/_rppd5sfv3tmy9mfacmg6wydi3k.png"><br><br>  In order not to run across all the properties, the author suggests hanging the Computed attribute to mark that this property should be inline.  Before the request, we climb into IsAvailable (), pull out its IL code, convert it to the expression tree, and replace the IsAvailable () call with what is written in this getter.  It turns out such a manual inlining. <br><br><img src="https://habrastorage.org/webt/nt/jx/g1/ntjxg17v2olokmu7ebckzs7v_uq.png"><br><br>  To make this work, before passing everything to ToList (), call the special method Decompile ().  It provides the decorator for the original queryable and inlines.  Only after that we transfer everything to the query-provider, and everything is fine with us. <br><br><img src="https://habrastorage.org/webt/ze/cz/qw/zeczqw8mzr-k72ivpyfzqrpuhrm.png"><br><br>  The only problem with this approach is that Delegate Decompiler 0.23.0 is not going to move forward, there is no Core support, and the author himself says that this is a deep alpha, there is a lot of unfinished, so you cannot use it in production.  Although we will return to this topic. <br><br><h1>  Boolean operations </h1><br>  It turns out that we have solved the problem of duplication of specific conditions. <br><br><img src="https://habrastorage.org/webt/gc/-u/5n/gc-u5nh7vip9kn5cq1d5gn3ivxm.png"><br><br>  But conditions often need to be combined using Boolean logic.  We had IsForSale (), InStock ()&gt; 0, and in between the ‚ÄúAND‚Äù condition.  If there is some other condition, or an ‚ÄúOR‚Äù condition is required. <br><br><img src="https://habrastorage.org/webt/9f/xu/hy/9fxuhyfzinahcrlertade-zam2s.png"><br><br>  In the case of "And" you can cheat and blame all the work on the query-provider, that is, to write a lot of Where () in a row, he knows how to do it. <br><br><img src="https://habrastorage.org/webt/dd/hp/c9/ddhpc9tfdvmeiadkmyfmswnr4h8.png"><br><br>  If an ‚ÄúOR‚Äù is required, it will not work, because WhereOr () is not in LINQ, and the expressions do not overload the ‚Äú||‚Äù operator. <br><br><h1>  Specs </h1><br>  If you are familiar with Evans' DDD book, or simply know something about the Pattern Specification, then there is a design pattern designed exactly for this.  There are several business rules and you want to combine operations in Boolean logic - implement the Specification. <br><br><img src="https://habrastorage.org/webt/nj/cb/4n/njcb4n2xt0g8dk3joumhmsgmuyg.png"><br><br>  Specification is such a term, an old pattern from Java.  And in Java, especially in the old, there was no LINQ, so it is implemented there only in the form of the isSatisfiedBy () method, that is, only delegates, but there is no talk about expressing there.  There is an implementation on the Internet called <a href="https://github.com/navozenko/LinqSpecs">LinqSpecs</a> , on the slide you will see it.  I filed it a bit with a file for myself, but the idea belongs to the library. <br><br>  All Boolean operators are overloaded here, true and false operators are overloaded so that the two operators ‚Äú&amp;&amp;‚Äù and ‚Äú||‚Äù work, without them only the single ampersand will work. <br><br><img src="https://habrastorage.org/webt/nh/8b/16/nh8b16hfmjec4t6yotlcmu5nbzi.png"><br><br>  Next we add implicit-statements that will force the compiler to assume that the specification is both expressions and delegates.  In any place where the Expression &lt;&gt; or Func &lt;&gt; type must come to the function, you can pass the specification.  Since the implicit operator is overloaded, the compiler will figure out and substitute either the Expression or IsSatisfiedBy properties. <br><br><img src="https://habrastorage.org/webt/pd/-t/jk/pd-tjkx5uxieorm3go74act-2gc.png"><br><br>  IsSatisfiedBy () can be implemented by caching the expression that came.  In any case, it turns out that we are going from Expression, the delegate corresponds to it, we have added support for Boolean operators.  Now you can compose all this.  Business rules can be rendered into static specifications, declared and combined. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Spec&lt;Product&gt; IsForSaleSpec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spec&lt;Product&gt;(x =&gt; x.IsForSale); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Spec&lt;Product&gt; IsInStockSpec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spec&lt;Product&gt;(x =&gt; x.InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/ru/ju/ya/rujuyaoj1ogssqq_resyqjmkutm.png"><br><br>  Each business rule is written only once, it is not lost anywhere, not duplicated, they can be combined.  People coming to the project can see what you have, what conditions, to understand the subject model. <br><br><img src="https://habrastorage.org/webt/td/5l/zi/td5lzi5sx9bcq522numfdrylehg.png"><br><br>  There is a small problem: the Expression does not have the And (), Or () and Not () methods.  These are extension-methods, they must be implemented independently. <br><br><img src="https://habrastorage.org/webt/l9/go/tj/l9gotjytui3drpptkcdtbyeymcc.png"><br><br>  The first attempt at implementation was this.  About expression tree there is quite a bit of documentation on the Internet, and it is not all detailed.  So I tried to just take Expression, press Ctrl + Space, saw OrElse (), read about it.  Passed two Expression, to compile and continue to get lambda.  It will not work. <br><br><img src="https://habrastorage.org/webt/v4/p3/8u/v4p38uvzgxubb2y8olt38ivbipq.png"><br><br>  The fact is that this Expression consists of two parts: the parameter and the body.  The second also consists of a parameter and a body.  In OrElse () it is necessary to transfer the body of expressions, that is, it is useless to compare the lambda with the "AND" and "OR", so it will not work.  We fix it, but it will not work again. <br><br>  But if the last time was NotSupportedException, that lambda is not supported, now there is a strange story about parameter 1, parameter 2, ‚Äúsomething is wrong, I won‚Äôt work‚Äù. <br><br><h1>  C # 7.0 in a Nutshell </h1><br>  Then I thought that the method of scientific spear will not work, it is necessary to understand.  I started to google and found the site of Albahari‚Äôs <a href="http://www.albahari.com/nutshell/linqkit.aspx">C # 7.0 in a Nutshell</a> . <br><br><img src="https://habrastorage.org/webt/m6/0b/ag/m60bagpqsrrcakt5wz-p05lcfyq.png"><br><br>  Joseph Albahari, who is also the developer of the popular LINQKit and LINQPad library, just describes this problem.  you can't just take and combine Expression, but if you take the magic Expression.Invoke (), it will work. <br><br>  Question: what is Expression.Invoke ()?  Go to Google again.  It creates an InvocationExpression that applies a delegate or lambda expression to the argument list. <br><br><img src="https://habrastorage.org/webt/br/du/mh/brdumhygufxqwgu5hfly1nlac0a.png"><br><br>  If I read this code to you now that we take Expression.Invoke (), we pass the parameters, then the same is written in English.  It does not become clearer.  There is some magic Expression.Invoke (), which for some reason solves this problem with parameters.  It is necessary to believe, it is not necessary to understand. <br><br><img src="https://habrastorage.org/webt/ja/88/po/ja88po-nxrjqtzdya6f8xxnfwre.png"><br><br>  At the same time, if you try to feed EF such combined Expression, it will fall again and say that Expression.Invoke () is not supported.  By the way, EF Core began to support, but EF 6 does not hold.  But Albahari suggests simply writing AsExpandable (), and it will work. <br><br><img src="https://habrastorage.org/webt/z5/4s/lq/z54slqaaitigetkidixpw-0a408.png"><br><br>  You can also substitute Expression subqueries where we need a delegate.  So that they coincide, we write Compile (), but at the same time, if you write AsExpandable (), as Albahari suggests, this Compile () will not actually happen, but somehow everything will be magically done correctly. <br><br><img src="https://habrastorage.org/webt/u_/bd/wo/u_bdwop-dd-1gf_xvq3e_d9hbj8.png"><br><br>  I did not believe the word and got into the source.  What is the AsExpandable () method?  It has query and QueryOptimizer.  We will leave the second one behind the brackets, since it is uninteresting, but simply sticks together the Expression: if there is 3 + 5, it will put 8. <br><br><img src="https://habrastorage.org/webt/l6/8j/tw/l68jtwqse6njinyczxh7xs3ilmw.png"><br><br>  It is interesting that the Expand () method is called further, after it the queryOptimizer, and then everything is transferred to the query provider somehow altered after the Expand () method. <br><br><img src="https://habrastorage.org/webt/pr/dv/oc/prdvockxs8plz7f2lyciiyu0s5y.png"><br><br>  We open it, it is Visitor, inside we see a non-original Compile (), which compiles something else.  I will not tell you what, even though there is a certain meaning in it, but we remove one compilation and replace it with another.  Great, but it smacks of marketing of the 80th level, because the performance impact is not going anywhere. <br><br><h1>  Looking for alternatives </h1><br>  I thought that this would not work and began to look for another solution.  And found.  There is such a Pete Montgomery, who also <a href="https://petemontgomery.wordpress.com/2011/02/10/a-universal-predicatebuilder/">writes</a> about this problem and claims that Albahari faked. <br><img src="https://habrastorage.org/webt/k9/pu/hy/k9puhyrru6xqi3hyozftlav_lvk.png"><br>  Pete talked to the EF developers, and they taught him to combine everything without Expression.Evoke ().  The idea is very simple: the ambush was with parameters.  The fact is that with a combination of Expression there is a parameter of the first expression and a parameter of the second.  They do not match.  The bodies were glued together, and the parameters remained hanging in the air.  They need to bind in the right way. <br><br>  To do this, you need to make a dictionary, looking at the parameters of the expressions, if the lambda is not from one parameter.  We compile a dictionary, and all the parameters of the second are rebated to the parameters of the first, so that the original parameters are included in the Expression, passed over the whole body, which we glued together. <br><img src="https://habrastorage.org/webt/yn/ct/37/ynct37iynt07424au-grgvhhz1o.png"><br>  This simple method allows you to get rid of all ambushes with Expression.Invoke ().  Moreover, in the implementation of Pete Montgomery, this is done even cooler.  It has a Compose () method that allows you to combine any expressions. <br><br><img src="https://habrastorage.org/webt/wc/of/fv/wcoffvtu4s62gggy_qqykowjtns.png"><br><br>  We take expression and through AndAlso we connect, works without Expandable ().  Such an implementation is used in boolean operations. <br><br><h1>  Specifications and assemblies </h1><br>  Everything was fine until it became clear that there are aggregates in nature.  For those who are not familiar, I will explain: if you have a domain model and you represent all the entities that are connected to each other, in the form of trees, then the tree hanging separately is an aggregate.  The order along with the order items will be called the aggregate, and the essence of the order will be the aggregation root. <br><br><img src="https://habrastorage.org/webt/zr/vr/6a/zrvr6af-865n3tluhcoivfjn68g.png"><br><br>  If, in addition to products, there are still categories with a business rule declared for them in the form of a specification, that there is a certain rating that must be over 50, as marketers said, and we want to use it so, that is good. <br><br><img src="https://habrastorage.org/webt/tp/vh/u-/tpvhu-12wisjnbsdhnmddkqpkw4.png"><br><br>  But if we want to pull the goods out of a good category, then again it is bad, because we did not have the same types.  Specification for category, but need products. <br><br><img src="https://habrastorage.org/webt/yz/cj/wp/yzcjwpjtf0jvuwff1dae8jef7ha.png"><br><br>  Again, we must somehow solve the problem.  The first option: replace Select () with SelectMany ().  I don‚Äôt like two things here.  First, I don‚Äôt know how support for SelectMany () is implemented in all popular query providers.  Secondly, if someone writes a query provider, the first thing he will do is to write a throw not implemented exception and SelectMany ().  And the third point: people think that SelectMany () is either functional, or join, usually not associated with a SELECT query. <br><br><h1>  Composition </h1><br>  I would like to use Select (), not SelectMany (). <br><br><img src="https://habrastorage.org/webt/-_/bv/qm/-_bvqmi8jssf1sva8boyiuh1vsg.png"><br><br>  At about the same time I read about category theory, about functional composition and thought that if there are specifications from the product in bool below, there is some function that can go from the product to the category, there is a specification regarding the category, then substituting the first function as the second argument, we get what we need, the specification regarding the product.  Absolutely the same as functional composition works, but for expression trees. <br><br><img src="https://habrastorage.org/webt/hg/wp/7h/hgwp7h8a0nrpv2xsfphtltel160.png"><br><br>  Then it would be possible to write such a method Where (), that from the products one should go to categories and apply the specification to this related entity.  This syntax for my subjective taste looks pretty clear. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; Where&lt;T, TParam&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; queryable, Expression&lt;Func&lt;T, TParam&gt;&gt; prop, Expression&lt;Func&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryable.Where(prop.Compose(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>)); }</code> </pre> <br>  With the Compose () method, this is also easy to do.  We take input Expression from products and we combine it together with specifications concerning a product and all. <br><br><img src="https://habrastorage.org/webt/5p/5k/re/5p5krejfyvexk6c-hf50hymykss.png"><br><br>  Now you can write such Where ().  This will work if you have a unit of any length.  Category has SuperCategory and as many further properties as you can substitute. <br><br>  ‚ÄúOnce we have a functional composition tool, and since we can compile it, and once we can build it dynamically, it means there is a smell of meta-programming!‚Äù I thought. <br><br><h1>  Projections </h1><br>  Where can we apply meta-programming to have less code to write. <br><br><img src="https://habrastorage.org/webt/z6/dw/gi/z6dwgivuday4edqii5me2z0yuw0.png"><br><br>  The first option is projections.  Pulling an entire entity is often too expensive.  Most often we pass it to the front, serialize JSON.  And it does not need the whole entity with the unit.  You can do this as efficiently as possible with LINQ by writing such a Select () manual.  Not difficult, but tedious. <br><br><img src="https://habrastorage.org/webt/1r/co/xd/1rcoxdmbzmuplg1vyuvkz5hrrqg.png"><br><br>  Instead, I suggest everyone use ProjectToType ().  At least there are two libraries that can do this: Automapper and Mapster.  For some reason, many people know that AutoMapper can do memory mapping, but not everyone knows that it has Queryable Extensions, there is also an Expression, and it can build a SQL expression.  If you are still writing manual queries and you are using LINQ, since you do not have super-serious performance restrictions, then there is no point in doing this with your hands, this is the work of the machine, and not a person. <br><br><h1>  Filtration </h1><br>  If we can do this with projections, why not do it for filtering. <br><br><img src="https://habrastorage.org/webt/wg/ei/pd/wgeipdnvwwusix--gk7_zch9nhs.png"><br><br>  Here too the code.  Comes some kind of filter.  A lot of business applications look like this: filter came, add Where (), another filter came, add Where ().  How many filters are there, so many repeat.  Nothing complicated, but a lot of copy-paste. <br><br><img src="https://habrastorage.org/webt/fd/7r/wl/fd7rwlnpkuiluiadq0zppn7_t-y.png"><br><br>  If we do something like AutoMapper, we write AutoFilter, Project and Filter, so that he can do everything, it would be cool - less code. <br><br><img src="https://habrastorage.org/webt/9g/es/tg/9gestgfo-ouzbolexklhu78gv8q.png"><br><br>  There is nothing complicated about it.  We take Expression.Property, we pass on DTO and in essence.  We find common properties that are called the same.  If they are called the same - it looks like a filter. <br><br>  Next, you need to check for null, use a constant to pull the value from the DTO, substitute it in the expression and add conversion in case you have Int and NullableInt or other Nullable so that the types match.  And put, for example, Equals (), a filter that checks for equality. <br><br><img src="https://habrastorage.org/webt/09/x6/me/09x6mep3p-rrvwo0vodcnke_8eo.png"><br><br>  After that, collect lambda and run for each property: if there are a lot of them, collect either through ‚ÄúAND‚Äù or ‚ÄúOR‚Äù, depending on how the filter works for you. <br><br><img src="https://habrastorage.org/webt/ha/vw/en/havwen3xvrbraul6plgdadjjusy.png"><br><br>  The same can be done for sorting, but it is a bit more complicated, since in the OrderBy () method there are two generics, so you have to fill them with your hands, use the Reflections to create the OrderBy () method from two generics, insert the type of entity that we take, the type of Property.  In general, it can also be done, it is not difficult. <br><br>  The question arises: where to put Where () - at the entity level, as the specifications were announced or after the projection, and there, and it will work there. <br><br><img src="https://habrastorage.org/webt/e1/4g/4g/e14g4gelsidqhaeq7avs0wgp51i.png"><br><br>  That's right and so, because specifications are by definition business rules, and we have to cherish them and not make mistakes with them.  This is a one-dimensional layer.  And filters are more about UI, which means they filter by DTO.  Therefore, you can put two Where ().  There are more questions as to how well the query provider will cope with this, but I think that ORM solutions write bad SQL anyway, and it will not be much worse.  If this is very important to you, then this story is not about vac. <br><br><img src="https://habrastorage.org/webt/46/wn/kc/46wnkcjkjayv9boma0pot5of0rs.png"><br><br>  As they say, it's better to see once than hear a hundred times. <br>  Now the store has three products: "Snickers", Subaru Impreza and "Mars".  Strange shop.  Let's try to find ‚ÄúSnickers.  There is.  Let's see what a hundred rubles.  Also "Snickers."  And for 500?  Let's get closer, there's nothing.  And for 100,500 Subaru Impreza.  Great, the same goes for sorting. <br><br>  Sort alphabetically by price.  The code there says exactly as much as it was.  These filters work for all classes as you like.  If you try to search by name, then there is also Subaru.  And I had Equals () in the presentation.  How is that?  The fact is that the code here and in the presentation is a bit different.  I commented out the line about Equals () and added some special street magic.  If we have a String type, then we need not Equals (), but call StartWith (), which I also received.  Therefore, another filter is built for the rows. <br><br><img src="https://habrastorage.org/webt/t7/fa/kp/t7fakpf7peg_v2swpq2xwksiecu.png"><br><br>  This means that here you can press Ctrl + Shift + R, select the method and write not if, but switch, and can even implement the ‚ÄúStrategy‚Äù pattern and then go insane.  Any desire to work filters you can realize.  It all depends on the types you work with.  Most importantly, the filters will work the same way. <br><br>  You can agree that the filters in all UI elements should work like this: strings are searched in one way, money in another.  All this is coordinated, once written, everything will be done correctly in different interfaces, and no other developers will break it, because this code is not at the application level, but somewhere either in an external library or in your kernel. <br><br><h1>  Validation </h1><br>  In addition to filtering and projection, you can do validation.  This idea was pushed by the <a href="https://github.com/gcanti/tcomb-validation">TComb.validation</a> JS library.  TComb is short for Type Combinators and it is based on a type system and so-called  refinements, improvements. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// null and undefined validate('a', t.Nil).isValid(); // =&gt; false validate(null, t.Nil).isValid(); // =&gt; true validate(undefined, t.Nil).isValid(); // =&gt; true // strings validate(1, t.String).isValid(); // =&gt; false validate('a', t.String).isValid(); // =&gt; true // numbers validate('a', t.Number).isValid(); // =&gt; false validate(1, t.Number).isValid(); // =&gt; true</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, primitives are declared that correspond to all types of JS, and an additional type is nill, corresponding to either undefined or zero. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// a predicate is a function with signature: (x) -&gt; boolean var predicate = function (x) { return x &gt;= 0; }; // a positive number var Positive = t.refinement(t.Number, predicate); validate(-1, Positive).isValid(); // =&gt; false validate(1, Positive).isValid(); // =&gt; true</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further interesting begins. </font><font style="vertical-align: inherit;">Each type can be enhanced with a predicate. </font><font style="vertical-align: inherit;">If we want numbers greater than zero, then we declare the predicate x&gt; = 0 and do validation on the type Positive. </font><font style="vertical-align: inherit;">So from the building blocks you can collect any of your validations. </font><font style="vertical-align: inherit;">Noticed, probably, there are also lambda expressions. </font></font><br><br><img src="https://habrastorage.org/webt/ha/wx/lj/hawxljvmttn1bc0rhh5k4fvtywe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Challenge accepted. </font><font style="vertical-align: inherit;">We take the same refinement, write it in C #, write the IsValid () method, also Expression we compile and execute. </font><font style="vertical-align: inherit;">Now we have the opportunity to carry out validation.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RefinementAttribute</span></span>: <span class="hljs-title"><span class="hljs-title">ValidationAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IValidator&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; Refinement { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefinementAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type refinmentType</span></span></span><span class="hljs-function">)</span></span> { Refinement = (IValidator&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;) Activator.CreateInstance(refinmentType); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Refinement.Validate(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>).IsValid(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We integrate with the standard DataAnnotations system in ASP.NET MVC so that it all works out of the box. We declare RefinementAttribute (), transfer the type to the constructor. The fact is that RefinementAttribute is generic, so here you have to use the type, because you cannot declare the generic attribute in .NET, unfortunately. </font></font><br><br><img src="https://habrastorage.org/webt/ml/e7/j9/mle7j92pbchiswi1ni7zfvizgou.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So mark the user class with refinement. AdultRefinement, that age is over 18. </font></font><br><br><img src="https://habrastorage.org/webt/cp/2o/yt/cp2oytz1rrhql042hddkb3va8ug.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to be completely good, let's make the validation on the client and server the same. Supporters of NoJS suggest writing back and front on JS. Well, I will write on C # both back and front, nothing terrible and just translate it into JS. You can write javascriptists on your JSX, ES6 and transpose it to JavaScript. Why can't we? We write Visitor, go through what operators are needed and write JavaScript.</font></font><br><br><img src="https://habrastorage.org/webt/lg/qe/9y/lgqe9yl63oz8p8wmlkrmyfmkkky.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separately, frequent validation cases are regular expressions, they also need to be parsed. If you have a regexp, take a StringBuilder, collect the regexp. Here I used two exclamation marks, since JS is a dynamically typed language, this expression will always be converted to bool so that everything is fine with the type. Let's see what it looks like.</font></font><br><br><pre> <code class="cs hljs">{ predicate: ‚Äúx=&gt; (x &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>)‚Äù, errorMessage: ‚ÄúFor adults only¬ª }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is our refinement, which comes from the backend, as a line predicate, since there are no lambdas and errorMessage ‚ÄúFor adults only‚Äù in JS. Let's try to fill in the form. Does not pass. We look, how it is made. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is React, we request from the back end from the UserRefinment () method of Expression and errorMessage, construct a refinment relative to number, use eval to get the lambda. If I redo it and remove the type restrictions, replace it with the usual number, validation on JS will fall off. Enter the unit, send. I do not know, it is visible or not, false is displayed here. </font></font><br><br><img src="https://habrastorage.org/webt/km/vw/ls/kmvwlsxxw5csttfvkh_rxrpbwpe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is alert. When we send onSubmit, alert of what came from the backend. And the backend is such a simple code. </font></font><br><br><img src="https://habrastorage.org/webt/xj/hm/mz/xjhmmznmn7xgzlcxedk_tgvdzcu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We simply return Ok (ModelState.IsValid), the User class, which we get from a JavaScript form. Here is the Refinement attribute.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DemoApp.Core</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span>: <span class="hljs-title"><span class="hljs-title">HasNameBase</span></span> { [Refinement(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(AdultRefinement))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Age { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, validation works on the backend, which is declared in this lambda. </font><font style="vertical-align: inherit;">And we translate it into javascript. </font><font style="vertical-align: inherit;">It turns out, we write lambda expressions on C #, and the code is executed both there, and there. </font><font style="vertical-align: inherit;">Our answer is NoJS, so can we.</font></font><br><br><h1>  Testing </h1><br><img src="https://habrastorage.org/webt/jz/fm/y0/jzfmy0ngjejazfvdrf5ld9y8cc4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually it is the Timlid that is more concerned about the number of errors in the code. Those who write unit tests know the Moq library. </font><font style="vertical-align: inherit;">You do not want to write a mock or declare a class - there is a moq, it has a fluent syntax. </font><font style="vertical-align: inherit;">You can paint as you want him to behave and slip your application for testing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These lambdas in moq are also Expression, not delegates. </font><font style="vertical-align: inherit;">He goes over the trees of expressions, applies his logic and further feeds into Castle.DynamicProxy. </font><font style="vertical-align: inherit;">And he creates the necessary classes in runtime. </font><font style="vertical-align: inherit;">But we can do that too.</font></font><br><br><img src="https://habrastorage.org/webt/tc/xo/fk/tcxofk6igzdettbtprnfewltn_q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A friend of mine recently asked if there was something like WCF in our Core. I replied that there is a webapi. He also wanted to build a proxy in WebAPI, like in WCF by WSDL. WebAPI has only swagger. But the swagger is just a text, and the friend did not want to follow every time when the API changes and what breaks. When WCF was, he connected WSDL, if the spec changed at the API, the compilation broke.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This has a definite meaning, since it‚Äôs reluctant to search, and the compiler can help. By analogy with moq, you can declare the method GetResponse &lt;&gt; () generic with your ProductController, and the lambda that goes into this method is parameterized by the controller. That is, you, starting to write a lambda, press Ctrl + Space and see all the methods that this controller has, provided that there is a library, dll with the code. There is Intellisense, write all this as if you are calling a controller.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, like Moq, we will not call it, but simply build an expression tree, go through it, pull out all the information on the routing from the API config. And instead of doing something with the controller, which we cannot perform, since we have to execute it on the server, we will simply make the POST or GET request we need, and in the opposite direction we will deserialize the response received, because of Intellisense and expression tree we know about all return types. It turns out, we write code about controllers, and actually we do Web requests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reflection Optimization </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As far as meta-programming is concerned, it strongly echoes Reflection.</font></font><br><br><img src="https://habrastorage.org/webt/gr/bq/r_/grbqr_q2oqe0rulsblvpejylomk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We know that Reflection is slow, I would like to avoid it. There are also some good Expression case studies here. The first is the CreateInstance activator. You should never use it at all, because there is Expression.New (), which you can simply drive into the lambda, compile and then get the constructors. </font></font><br><br><img src="https://habrastorage.org/webt/8u/me/lv/8umelvrhhu0ctn0gaunjp1ldmxg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I borrowed this slide from a wonderful speaker and musician Vagif. He was doing a benchmark on a blog. Here is the Activator, this is the Peak of Communism, you see how much he is trying to do everything. Constructor_Invoke, it is about half. And on the left - New and compiled lambda. There is a slight increase in performance due to the fact that it is a delegate, not a constructor, but the choice is obvious, it is clear that this is much better. </font></font><br><br><img src="https://habrastorage.org/webt/yr/sv/7k/yrsv7kspmbbmnfjxc1slzkemvx4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same can be done with getters or setters.</font></font><br><br><img src="https://habrastorage.org/webt/gf/2d/4e/gf2d4ebwaltmazxfjicoupxwrbk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is done very simply. If for some reason you are not satisfied with the Fast Memember Mark Gravelli or Fast Reflect, you do not want to drag this dependence, you can do the same. The only difficulty is that you need to keep track of all these compilations, store and warm up the cache somewhere. That is, if this is a lot, then at the start you need to compile it once. </font></font><br><br><img src="https://habrastorage.org/webt/hi/x1/e7/hix1e7peelljkkm6kewh4blyhgq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once there is a constructor, getters and setters, only the behavior and methods remain. But they can also be compiled into delegates, and you just get a big zoo of delegates who need to be able to manage. Knowing all that I have told, the idea might come to someone that if there are many delegates, many expressions, then maybe there is a place for what is called DSL, Little Languages, or a pattern interpreter, a free monad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These are all the same things, when for some task we come up with a set of commands and write our own interpreter for it. That is, we also write a compiler or interpreter inside the application that knows how to use these commands. This is how it is done in the DLR, in the part that works with the languages ‚Äã‚ÄãIronPython, IronRuby. The expression tree is used there to execute dynamic code in the CLR. The same can be done in business applications, but we haven‚Äôt noticed such a need yet and it remains outside the brackets.</font></font><br><br><h1>  Results </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I want to talk about what conclusions we came to after implementation and testing. As I said, this happened on different projects. Everything that I wrote, we do not use everywhere, but somewhere, if required, some things were used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first plus is the ability to automate the routine. If you have 100 thousand molds with filtering, pagination and all that. Mozart had a joke that with the help of dice, enough time and a glass of red wine, you can write waltzes in any quantity. Here, with the help of Expression Trees, a bit of meta-programming, you can write molds in any quantity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The amount of code is greatly reduced, as an alternative to code generation, if you do not like it, because you get a lot of code, you can not write it, leave everything in runtime.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using such code for simple tasks, we further reduce the requirements for executors, because there is very little imperative code and space for error too. Pulling a large amount of code into reusable components, we remove this class of errors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, we are so much raising the requirements for the qualifications of the designer, because questions of knowledge about working with Expression, Reflection, their optimization, about places where you can shoot yourself in the foot are coming out. There are many such nuances here, so a person unfamiliar with this API will not immediately understand why Expression just does not combine. The designer should be cooler.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some cases, Expression.Compile () can catch performance degradation. In the caching example, I had a limitation that the Expressions are static, because a Dictionary is used for caching. If someone does not know how it is arranged inside, starts to do it thoughtlessly, declares the specifications non-static inside, the cache method will not work, and we will receive calls to Compile () in random places. Exactly what I wanted to avoid.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most unpleasant minus is that the code ceases to look like a C # code, it becomes less idiomatic, static calls appear, strange additional Where () methods, some implicit operators are overloaded. This is not in the MSDN documentation, in the examples. If, say, a person with little experience comes to you, who is not used to creeping into the source code, he will most likely be in a little prostration at first, because it does not fit into the picture of the world, there are no such examples on StackOverflow, but with this will have to work somehow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, this is all I wanted to talk about today. Much of what I have said, in more detail, with the details </font></font><a href="https://habr.com/users/marshinov/posts/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">written</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Habr√©. The library code is laid out on the githaba, but it has one fatal flaw - the complete lack of documentation.</font></font><br><blockquote> 22-23     <a href="https://dotnext-moscow.ru/">DotNext 2018 Moscow</a> .       , <a href="https://dotnext-moscow.ru/registration/"></a>     ( <b>  </b>   ). </blockquote></div><p>Source: <a href="https://habr.com/ru/post/423891/">https://habr.com/ru/post/423891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423877/index.html">October 29-31: create a production-ready Kubernetes cluster</a></li>
<li><a href="../423879/index.html">Is it easy to add new features to the old framework? Flour choice on example development SObjectizer-and</a></li>
<li><a href="../423881/index.html">What were the welders for optics (part two)</a></li>
<li><a href="../423885/index.html">Invitation to the light show and a bit of insight from the future site "Circle of Light" in Moscow</a></li>
<li><a href="../423889/index.html">My disappointment in software</a></li>
<li><a href="../423893/index.html">Hello World to receive data from a Bluetooth (BLE) device via C #</a></li>
<li><a href="../423895/index.html">You don't need a lawyer. But it is not exactly</a></li>
<li><a href="../423897/index.html">Tips for using the HyperLynx DDR Wizard to analyze QDR4</a></li>
<li><a href="../423901/index.html">When speed and scaling are needed: a server of distributed iOS devices</a></li>
<li><a href="../423903/index.html">Immersion in AD: disassemble advanced attacks on Microsoft Active Directory and how to detect them</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>