<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vim in full: The library on which everything rests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


1. Introduction (vim_lib) 
2. Plugin Manager without fatal flaws (vim_lib, vim_plugmanager) 
3. Project level and file system (vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vim in full: The library on which everything rests</h1><div class="post__text post__text-html js-mediator-article"><h1>  Table of contents </h1><br><ol><li>  <a href="http://habrahabr.ru/post/259701/">Introduction</a> (vim_lib) </li><li>  <a href="http://habrahabr.ru/post/259725/">Plugin Manager without fatal flaws</a> (vim_lib, vim_plugmanager) </li><li>  <a href="http://habrahabr.ru/post/259995/">Project level and file system</a> (vim_prj, nerdtree) </li><li>  <a href="http://habrahabr.ru/post/260591/">Snippets and File Templates</a> (UltiSnips, vim_template) </li><li>  <a href="http://habrahabr.ru/post/261179/">Compiling and doing anything</a> (vim-quickrun) </li><li>  <a href="http://habrahabr.ru/post/261783/">Work with Git</a> (vim_git) </li><li>  <a href="http://habrahabr.ru/post/263487/">Deploy</a> (vim_deploy) </li><li>  <a href="http://habrahabr.ru/post/264297/">Testing with xUnit</a> (vim_unittest) </li><li>  <b>The library on which everything is kept</b> (vim_lib) </li><li>  Other useful plugins </li></ol><br>  The main problem when writing plugins for Vim is code repetition.  Unfortunately, there are no libraries for Vim that solve a lot of basic tasks, which is why all authors of plugins constantly tread on the same rake.  In this article I will try to sanctify the solution to this problem. <br><a name="habracut"></a><br><h1>  Foreword </h1><br>  To my (and maybe your) deepest regret, I already wrote this article once, but due to my own stupidity and ‚Äúfeatures‚Äù of the habr, I lost its most interesting chapter.  In a fit of rage, I decided not to rewrite it again, as I was so tired, because, dear reader, some of my thoughts will be lost.  Fortunately, the lost chapter was an introductory one and only pursued the goal to interest the reader.  Nothing important was missed, but still offensive. <br><br><h1>  Objects </h1><br>  I already wrote in Habr√© about my attempts to implement classes in Vim.  The case ended with a three-fold rewriting of the decision until I came to the solution now available.  It is based on the ideas of objects in Perl and uses prototyping. <br><br>  Consider a few examples: <br><div class="spoiler">  <b class="spoiler_title">Inheritance</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:Object = g:vim_lib<span class="hljs-comment"><span class="hljs-comment">#base#Object# let s:Class = s:Object.expand() "     "  function! s:Class.new(...) let l:obj = self.bless() "   (   bless?) let l:obj.values = (exists('a:1') &amp;&amp; type(a:1) == 3)? a:1 : [] "   return l:obj "   endfunction "    function! s:Class.length() " {{{ return len(self.values) endfunction " }}} " ... "    let g:vim_lib#base#List# = s:Class</span></span></code> </pre> <br></div></div><br>  Please note that to create an instance of a class you need: <br><ul><li>  Call the <i>bless</i> method, which will create an object.  In the example, the method takes no parameters, which is allowed only when inheriting from the base class.  If we want to inherit a class from a child class, we will need to pass an initialized instance of the parent class to this method (let's look at it a little later) </li><li>  Initialize the resulting class, setting it to the initial state. </li></ul><br>  Two questions arise: why <i>bless is</i> needed and why is it necessary to initialize the received object if <i>bless</i> is already responsible for it?  It's simple.  The <i>bless</i> method makes a very simple operation, it creates a new dictionary and copies everything that is contained in the <i>properties</i> property, as well as non-static class methods.  There are also two links: the <i>class</i> points to the class itself, and the <i>parent</i> points to an object of the parent class.  At this point, everything becomes more confusing.  If you are familiar with how objects are stored in memory in a computer using C ++, then you know that to create an object of a child class, you must create an object of the parent class.  For this, the <i>bless</i> method takes its only parameter.  This parameter represents the finished object of the parent class, to which the <i>parent</i> reference in the child class object will point.  A reference to the parent class is used to create this object.  Already confused?  Everything will fall into place after the following two examples: <br><div class="spoiler">  <b class="spoiler_title">Expand method</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! s:Class.expand() <span class="hljs-string"><span class="hljs-string">" {{{ let l:child = {'parent': self} "</span></span>       . {{{ <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:child.expand = self.expand <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:child.mix = self.mix <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:child.new = self.new <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:child.bless = self.bless <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:child.typeof = self.typeof <span class="hljs-string"><span class="hljs-string">" }}} return l:child endfunction "</span></span> }}}</code> </pre><br></div></div><br>  Take a look at the implementation of the <i>expand</i> method.  It is called on the parent class to get the descendant class.  This method only creates a new dictionary, copies the parent method into it, and creates the <i>parent</i> property (not to be confused with the object property of the same name), which points to the parent class.  This means that all classes in the hierarchy are linked through this property. <br><div class="spoiler">  <b class="spoiler_title">Bless method</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! s:Class.bless(...) <span class="hljs-string"><span class="hljs-string">" {{{ let l:obj = {'class': self, 'parent': (exists('a:1'))? a:1 : self.parent.new()} "</span></span>       . {{{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l:p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(self[l:p]) == 2 &amp;&amp; index([<span class="hljs-string"><span class="hljs-string">'expand'</span></span>, <span class="hljs-string"><span class="hljs-string">'mix'</span></span>, <span class="hljs-string"><span class="hljs-string">'bless'</span></span>, <span class="hljs-string"><span class="hljs-string">'new'</span></span>, <span class="hljs-string"><span class="hljs-string">'typeof'</span></span>], l:p) == -1 &amp;&amp; l:p[0:1] != <span class="hljs-string"><span class="hljs-string">'__'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj[l:p] = self[l:p] endif endfor <span class="hljs-string"><span class="hljs-string">" }}} "</span></span>      . {{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has_key(self, <span class="hljs-string"><span class="hljs-string">'properties'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> [l:k, l:v] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items(self.properties) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj[l:k] = deepcopy(l:v) endfor endif <span class="hljs-string"><span class="hljs-string">" }}} return l:obj endfunction "</span></span> }}}</code> </pre><br></div></div><br>  After examining the implementation of the <i>bless</i> method, you will understand how simple class instances are created.  The method creates a dictionary with references to the class and object of the parent class, and then copies into it the properties and methods of the class.  After an object is created, the designer can set its state in a special way, for example, by calculating the value of some properties or taking them as parameters: <br><div class="spoiler">  <b class="spoiler_title">Parameterized constructor</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! s:Class.new(x, y) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj = self.bless() <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj.x = a:x <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj.y = a:y <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> l:obj endfunction</code> </pre><br></div></div><br>  Has things become easier?  But it is still not clear why it is necessary to transfer an object of the parent class to <i>bless</i> , because the implementation of this method shows that the object is created and installed automatically?  It's all about the parameterization of the constructor.  If you look again at the first line of the <i>bless</i> method, you will see that it uses the default no-parameter constructor to create an object of the parent class.  What if the parent constructor is parameterized?  In this case, we have to personally create an object of the parent class and deliver it to <i>bless</i> : <br><div class="spoiler">  <b class="spoiler_title">Parent class object</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! s:Class.new(x, y) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:parent = self.parent.new(a:x) <span class="hljs-string"><span class="hljs-string">"         let l:obj = self.bless(l:parent) "</span></span>      <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> l:obj.y = a:y <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> l:obj endfunction</code> </pre><br></div></div><br>  I hope now is clear.  Let's go further: <br><div class="spoiler">  <b class="spoiler_title">Instantiation</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:List = vim_lib<span class="hljs-comment"><span class="hljs-comment">#base#List# let s:objList = s:List.new() "  </span></span></code> </pre><br></div></div><br>  Since all classes of the library (as well as plug-ins) are stored (as a rule, but not necessarily) in <i>autoload</i> , they are accessed through scopes with automatic loading of the necessary files.  In order not to permanently prescribe these long names, an alias is used by simply assigning a class (after all, a class is an object) to a variable, which is then used in the script.  To instantiate a class, the already familiar <i>new</i> method is used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The base class also provides the following methods: <br><ul><li>  typeof - the method accepts the class and checks whether the called class is a child of the parameter </li><li>  mix - the method adds all the methods and properties of the class-parameter to the called class, implementing the impurities </li></ul><br>  In general, the object model in vim_lib ends there, the rest is concrete solutions to various problems. <br><br><h1>  Library structure </h1><br>  The entire library is located in the <i>autoload</i> directory.  This allows you to load parts of it as needed and use namespaces.  The library consists of the following packages: <br><ul><li>  base - basic library components, such as dictionaries, arrays, stacks, files, and so on </li><li>  sys - system components representing editor logic, such as buffers, plugins, the editor itself </li><li>  view widgets </li></ul><br><h2>  base </h2><br>  The base package contains simple classes that represent low-level components.  This includes object representations of basic structures, such as dictionaries, lists, and stacks, as well as supporting classes for working with the file system, event model, and unit tests.  If I examine each of these classes, the article will turn into a book, therefore I will limit myself to a cursory review. <br><br><h2>  sys </h2><br>  This package includes classes that represent the components of the editor and some of its logic.  The Buffer, System and Conten classes represent the editor itself, as well as the elements with which it works (buffers and text in them), and Plugin and Autoload define the plug-in model and the editor's initialization as a whole. <br><br><h2>  view </h2><br>  The view package is still very small, as it contains a single class that represents a simple widget with overlapping stack-based buffers.  I selected this package for implementing non-standard solutions in the editor interface. <br><br><h1>  Editor Initialization Model </h1><br>  The vim_lib # sys # Autoload class deserves special attention, since it defines (but does not impose) the basic logic of initializing the editor and loading plug-ins.  This is the only library class that is not inherited from the base Object class, since this was not necessary.  By the way, the library does not require using the object model offered to it, it only offers one of the proven implementations that you can use.  But let's not go far from the topic.  The Autoload class keeps track of which directory will be used in each of the initialization steps to load the components of the editor.  These directories are called levels and while three main ones are highlighted: <br><ul><li>  System-wide - scripts in this directory are distributed to all users. </li><li>  Custom - scripts that are applied to all projects of a particular user. </li><li>  Project - scripts for a specific project </li></ul><br>  To use the proposed model, simply add the following code to <i>.vimrc</i> : <br><div class="spoiler">  <b class="spoiler_title">Autoload connection</b> <div class="spoiler_text"><pre> <code class="bash hljs">filetype off <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rtp=~/.vim/bundle/vim_lib call vim_lib<span class="hljs-comment"><span class="hljs-comment">#sys#Autoload#init('~/.vim', 'bundle') "  filetype indent plugin on</span></span></code> </pre><br></div></div><br>  The <i>init</i> method determines the root directory for the current level and the name of the directory that stores plugins.  Read more about this in one of my previous <a href="http://habrahabr.ru/post/259995/">articles</a> . <br><br><h1>  Plugin model </h1><br>  The vim_lib library also offers a unified plugin model using the vim_lib # sys # Plugin class as the base.  This class defines a set of standard methods, as well as implements the plug-in connection logic with checking conditions and dependencies. <br><br>  A plugin using this model has a structure familiar to all plug-in writers: <br><ul><li>  In the <i>plugin</i> directory there is a plugin file containing a child relative to vim_lib # sys # Plugin, which is responsible for initializing the plugin.  This class (or rather its object) is responsible for the plug-in options, its initialization, as well as for adding commands and menu items. </li><li>  The <i>autoload</i> directory <i>contains</i> the plugin's interface files.  These files contain functions that are like plug-in methods.  Since the <i>autoload</i> directory is <i>used</i> , all functions are loaded as needed. </li><li>  In directories <i>doc</i> , <i>test</i> , <i>syntax</i> and so on, there are other plug-in files (according to the old scheme) </li></ul><br><br>  Consider a few examples: <br><div class="spoiler">  <b class="spoiler_title">plugin / myPlug.vim</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:Plugin = vim_lib<span class="hljs-comment"><span class="hljs-comment">#sys#Plugin# let s:p = s:Plugin.new('myPlug', '1', {'plugins': ['vim_lib']}) "  ,   ,    let s:px = 1 "   "   ,    Vim function! s:p.run() ... endfunction "   call s:p.comm('MyCommand', 'run()') "   call s:p.menu('Run', 'run', 1) call s:p.reg() "  </span></span></code> </pre><br></div></div><br>  In this simple example, you can see that the plugin is created as an object of class vim_lib # sys # Plugin, which is filled with methods and properties, and then registered in the system.  Since the scripts in the <i>plugin</i> directory are executed when the editor is initialized, this file will be executed every time Vim is started, which allows you to create and register a plug-in object. <br><div class="spoiler">  <b class="spoiler_title">autoload / myPlug.vim</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! myPlug<span class="hljs-comment"><span class="hljs-comment">#run() echo 'Hello world' endfunction</span></span></code> </pre><br></div></div><br>  The plugin file in the <i>autoload</i> directory includes the public plugin functions that are used by the commands and menu items of the plugin.  This directory may also contain other files used by the plugin, but the <i>autoload / Plugin name.vim file</i> is the main one.  These functions are called when working with the plugin. <br><br>  To connect the plugin to the editor, simply add the following entry to your <i>.vimrc</i> : <br><div class="spoiler">  <b class="spoiler_title">Plug-in connection</b> <div class="spoiler_text"><pre> <code class="bash hljs">filetype off <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rtp=~/.vim/bundle/vim_lib call vim_lib<span class="hljs-comment"><span class="hljs-comment">#sys#Autoload#init('~/.vim', 'bundle') Plugin 'MyPlug', { \ 'options': {   }, \ 'map': {   }, \    \} filetype indent plugin on</span></span></code> </pre><br></div></div><br>  When you declare a plug-in, you can specify its options, hot keys, override commands and menu items. <br><br><h1>  Unit Tests </h1><br>  The library includes many unit tests thanks to the vim_lib # base # Test class, which implements the basic logic of unit testing using the proposed object model library. <br><br><div class="spoiler">  <b class="spoiler_title">Dict class test</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:Dict = vim_lib<span class="hljs-comment"><span class="hljs-comment">#base#Dict# let s:Test = vim_lib#base#Test#.expand() " new {{{ "" {{{ "    . " @covers vim_lib#base#Dict#.new "" }}} function s:Test.testNew_createEmptyDict() " {{{ let l:obj = s:Dict.new() call self.assertEquals(l:obj.length(), 0) endfunction " }}} "" {{{ "       . " @covers vim_lib#base#Dict#.new "" }}} function s:Test.testNew_wrapHash() " {{{ let l:obj = s:Dict.new({'a': 1, 'b': 2, 'c': 3}) call self.assertEquals(l:obj.length(), 3) call self.assertEquals(l:obj.item('a'), 1) endfunction " }}} "" {{{ "       . " @covers vim_lib#base#Dict#.new "" }}} function s:Test.testNew_wrapArray() " {{{ let l:obj = s:Dict.new([['a', 1], ['b', 2], ['c', 3]]) call self.assertEquals(l:obj.length(), 3) call self.assertEquals(l:obj.item('a'), 1) endfunction " }}} " }}} " item {{{ "" {{{ "       . " @covers vim_lib#base#Dict#.item "" }}} function s:Test.testItem_getValue() " {{{ let l:obj = s:Dict.new() call l:obj.item('a', 1) call l:obj.item('b', 2) call self.assertEquals(l:obj.item('a'), 1) call self.assertEquals(l:obj.item('b'), 2) endfunction " }}} "" {{{ "   ,      . " @covers vim_lib#base#Dict#.item "" }}} function s:Test.testItem_throwExceptionGet() " {{{ let l:obj = s:Dict.new() try call l:obj.item('a') call self.fail('testItem_throwException', 'Expected exception &lt;IndexOutOfRangeException&gt; is not thrown.') catch /IndexOutOfRangeException:.*/ endtry endfunction " }}} "" {{{ "     . " @covers vim_lib#base#Dict#.item "" }}} function s:Test.testItem_setValue() " {{{ let l:obj = s:Dict.new() call l:obj.item('a', 1) call self.assertEquals(l:obj.item('a'), 1) endfunction " }}} " }}} " keys, vals, items {{{ "" {{{ "     . " @covers vim_lib#base#Dict#.keys "" }}} function s:Test.testKeys() " {{{ let l:obj = s:Dict.new({'a': 1, 'b': 2, 'c': 3}) call self.assertEquals(l:obj.keys(), ['a', 'b', 'c']) endfunction " }}} "" {{{ "     . " @covers vim_lib#base#Dict#.vals "" }}} function s:Test.testValues() " {{{ let l:obj = s:Dict.new({'a': 1, 'b': 2, 'c': 3}) call self.assertEquals(l:obj.vals(), [1, 2, 3]) endfunction " }}} "" {{{ "     . " @covers vim_lib#base#Dict#.items "" }}} function s:Test.testItems() " {{{ let l:obj = s:Dict.new({'a': 1, 'b': 2, 'c': 3}) call self.assertEquals(l:obj.items(), [['a', 1], ['b', 2], ['c', 3]]) endfunction " }}} " }}} let g:vim_lib#base#tests#TestDict# = s:Test call s:Test.run()</span></span></code> </pre><br></div></div><br><h1>  Bye all </h1><br>  The article turned out two times shorter than what I expected.  After Habr decided to log me out and reload the page with the article, deleting half the work (I don‚Äôt know what it was, maybe a bug), I gathered my strength and finished the article, albeit in an abbreviated version.  Behind the scenes, a lot remains, because the article may seem incomprehensible and superficial.  To prevent this from happening again, I decided to move away from using the habr as the main platform for the vim_lib project, and use third-party services or my own workouts that preclude such an annoying data loss. <br><br>  If you find something incomprehensible in this article, ask, I will try to convey the features of the library in a simple and understandable language. </div><p>Source: <a href="https://habr.com/ru/post/264351/">https://habr.com/ru/post/264351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264341/index.html">STC Metrotek. Part 2. Bercut-MMT and the rake race</a></li>
<li><a href="../264343/index.html">React boilerplate - Rocket React</a></li>
<li><a href="../264345/index.html">Introduction to JavaScript Iterators on ES6</a></li>
<li><a href="../264347/index.html">The third PyCon Russia will be held in Yekaterinburg on September 18-19</a></li>
<li><a href="../264349/index.html">Underground carders market. Translation of the book "Kingpin". Chapter 6. ‚ÄúI Miss Crime‚Äù</a></li>
<li><a href="../264353/index.html">Remove excess packages from Raspbian. Or how to make your Raspbian Mini ...</a></li>
<li><a href="../264355/index.html">SpiderTest: DIY AutoTests</a></li>
<li><a href="../264359/index.html">14 new roles in Big Data</a></li>
<li><a href="../264361/index.html">A test version of the HTTP / 2 module for NGINX has been published.</a></li>
<li><a href="../264363/index.html">4 invisible UX, which you never knew</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>