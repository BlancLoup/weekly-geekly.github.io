<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous long ears</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The developers of React have a functional approach, but with the advent of MobX, it is possible to work with the state in a more or less familiar OOP ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous long ears</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/ed/b2/59edb24f426e0489107992.jpeg"></p><br><p> The developers of React have a functional approach, but with the advent of MobX, it is possible to work with the state in a more or less familiar OOP style.  Mobx tries not to impose any architecture, allowing you to work with the reactive state, as with ordinary objects.  At the same time, he makes automatic linking of calculations, when it suffices to write <code>C = A + B</code> , so that when <code>A</code> is updated, <code>C</code> updated. </p><br><p>  In HelloWorld, this looks simple, but if we add fetch, the display of load statuses and error handling, we see that a lot of copy-paste is obtained, and helpers like when, fromPromise or lazyObservable start to leak into the code.  And it is already impossible to write code as if there is no asynchrony.  I want to analyze some similar examples in MobX and try to improve its basic concept by developing the idea of ‚Äã‚Äãpseudo-sync. </p><a name="habracut"></a><br><h2 id="zagruzka-dannyh">  Data loading </h2><br><p>  Consider the simplest to-do list on MobX and React. </p><br><pre> <code class="hljs scala">const {action, observable, computed} = mobx; const {observer} = mobxReact; const {<span class="hljs-type"><span class="hljs-type">Component</span></span>} = <span class="hljs-type"><span class="hljs-type">React</span></span>; let tid = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Todo</span></span></span><span class="hljs-class"> </span></span>{ id = ++tid; <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> title; <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> finished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; constructor(title) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title; } } function fetchSomeTodos(genError) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Promise</span></span>((resolve) =&gt; setTimeout(() =&gt; { resolve([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Todo</span></span>(<span class="hljs-symbol"><span class="hljs-symbol">'Get</span></span> <span class="hljs-type"><span class="hljs-type">Coffee</span></span>'), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Todo</span></span>(<span class="hljs-symbol"><span class="hljs-symbol">'Write</span></span> simpler code') ]) }, <span class="hljs-number"><span class="hljs-number">500</span></span>)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> todos = []; <span class="hljs-meta"><span class="hljs-meta">@computed</span></span> get unfinishedTodoCount() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos.filter(todo =&gt; !todo.finished).length; } <span class="hljs-meta"><span class="hljs-meta">@action</span></span> fetchTodos() { fetchSomeTodos() .then(todos =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos = todos }) } } const <span class="hljs-type"><span class="hljs-type">TodoView</span></span> = observer(({todo}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;li&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"checkbox"</span></span> checked={todo.finished} onClick={() =&gt; todo.finished = !todo.finished} /&gt;{todo.title} &lt;/li&gt; }) <span class="hljs-type"><span class="hljs-type">TodoView</span></span>.displayName = <span class="hljs-symbol"><span class="hljs-symbol">'TodoVie</span></span>w' <span class="hljs-meta"><span class="hljs-meta">@observer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoListView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoList.fetchTodos() } render() { const {todoList} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;ul&gt; {todoList.todos.map(todo =&gt; &lt;<span class="hljs-type"><span class="hljs-type">TodoView</span></span> todo={todo} key={todo.id} /&gt; )} &lt;/ul&gt; <span class="hljs-type"><span class="hljs-type">Tasks</span></span> left: {todoList.unfinishedTodoCount} &lt;/div&gt; } } const store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">TodoList</span></span>() <span class="hljs-type"><span class="hljs-type">ReactDOM</span></span>.render(&lt;<span class="hljs-type"><span class="hljs-type">TodoListView</span></span> todoList={store} /&gt;, document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'moun</span></span>t'))</code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/hzvfsapq/">fiddle</a> </p><br><p>  In the simple case, the component should start downloading data through componentWillMount.  Each time, creating a new component that uses todoList, the programmer needs to remember that todoList.todos needs to be loaded.  If this is not done, then who will guarantee that someone up there has already downloaded this data? </p><br><p>  You can, of course, better separate the state and the UI without componentWillMount for download purposes.  This is what the MobX author Michel Weststrate says in the article <a href="https://hackernoon.com/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37">How to decouple state and UI</a> .  When you open the page, all the data needed to render it is requested from the server.  And the author suggests transferring the responsibility for initializing this download to the router. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createHistory } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'history'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'director'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> function startRouter(store) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> update state <span class="hljs-literal"><span class="hljs-literal">on</span></span> url change const router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router({ <span class="hljs-string"><span class="hljs-string">"/document/:documentId"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id)</span></span></span><span class="hljs-function"> =&gt;</span></span> store.showDocument(id), <span class="hljs-string"><span class="hljs-string">"/document/"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> store.showOverview() }).configure({ notfound: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> store.showOverview(), html5history: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }).init() }</code> </pre> <br><p>  This approach causes a problem - the router must know what exactly the data components need to be on the page being opened.  Calling the <code>store.showOverview</code> method at this point in the code breaks the encapsulation.  What will happen if during refactoring a new component was added to the page, which needs to get something from the server, and the download is not added to the router?  It is easy to make a mistake here, since the details of working with the stor are spread over different places of the application. </p><br><p>  The fetchTodos () call does not have to be in componentWillMount.  It can be disguised as a HOC, a router, a call to onClick in some button, or even directly called in index.js, as in the <a href="">example with redux-saga</a> : </p><br><pre> <code class="hljs javascript">... import rootSaga <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./sagas'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = configureStore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__INITIAL_STATE__) store.runSaga(rootSaga) ...</code> </pre> <br><p>  Where <code>store.runSaga(rootSaga)</code> immediately starts loading all the necessary data for the application. </p><br><p>  The essence is the same - in the code there will be a place where the programmer must initiate the download.  And this place will be outside the model or the fact that instead of it (for example, the saga), although by its very meaning the fact of the initialization call is just an internal detail of working with the network.  If you remove the asynchrony, it becomes unnecessary.  Moreover, the loading in such solutions does not occur after the component accesses this data, but in advance. </p><br><h2 id="obrabotka-oshibok-pri-asinhronnoy-zagruzke">  Error handling during asynchronous loading </h2><br><p>  In MobX, errors and download status will not get onto the interface by themselves.  To display them, we need to create an error property in the store for each loaded entity.  In each component with todoList.todos, you need to do the processing of this property, which in most cases will be the same - show the text or the stack trace in dev-mode.  If the programmer forgets to process them - the user will not see anything, even the words "Something went wrong." </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> todos = [] <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> error: ?<span class="hljs-type"><span class="hljs-type">Error</span></span> <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> pending = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-meta"><span class="hljs-meta">@action</span></span> fetchTodos(genError) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pending = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = <span class="hljs-literal"><span class="hljs-literal">null</span></span> fetchSomeTodos(genError) .then(todos =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos = todos; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pending = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pending = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) } } <span class="hljs-meta"><span class="hljs-meta">@observer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoListView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ componentWillMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoList.fetchTodos() } render() { const {todoList} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; {todoList.pending ? <span class="hljs-symbol"><span class="hljs-symbol">'Loading</span></span>...' : <span class="hljs-literal"><span class="hljs-literal">null</span></span>} {todoList.error ? todoList.error.message : <span class="hljs-literal"><span class="hljs-literal">null</span></span>} ... &lt;/div&gt; } }</code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/hzvfsapq/1/">fiddle</a> </p><br><h2 id="ispolzuem-frompromise">  Using fromPromise </h2><br><p>  There is a lot of sample code in the previous example, both in the stack and in the component.  To reduce copy-paste, you can use the fromPromise helper from <a href="https://github.com/mobxjs/mobx-utils">mobx-utils</a> , which, together with the value, gives the download status to this value.  Here is an example of the demonstration of his work: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoList</span></span></span><span class="hljs-class"> { @observable todoContainer constructor() { this.fetchTodos() } // ... @action fetchTodos(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">genError</span></span></span><span class="hljs-class">) { this.todoContainer = fromPromise(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchSomeTodos</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">genError</span></span></span><span class="hljs-class">)) } } const </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StatusView</span></span></span><span class="hljs-class"> = ({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchResult</span></span></span><span class="hljs-class">}) =&gt; { switch(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchResult</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state</span></span></span><span class="hljs-class">) { case "pending": return &lt;div&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Loading</span></span></span><span class="hljs-class">...&lt;/div&gt; case "rejected": return &lt;div&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ooops</span></span></span><span class="hljs-class">... {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JSON</span></span></span><span class="hljs-class">.stringify(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchResult</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">)}&lt;/div&gt; } } const </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoListView</span></span></span><span class="hljs-class"> = observer(({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoList</span></span></span><span class="hljs-class">}) =&gt; { const todoContainer = todoList.todoContainer return &lt;div&gt; {todoContainer.state === 'fulfilled' ? ... : &lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StatusView</span></span></span><span class="hljs-class"> fetchResult={todoContainer}/&gt; } ... &lt;/div&gt; })</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/hzvfsapq/2/">fiddle</a> </p><br><p>  We already have a todoContainer property that contains the value and status.  It is easier to process it in a component.  In the example above, the fetchTodos call is made in the TodoList constructor.  Unlike the routing example, this makes it possible to better encapsulate implementation details without exposing fetchTodos to the outside.  The fetchTodos method remains a private part of the TodoList implementation. </p><br><p>  Cons of this approach: </p><br><ol><li>  Laziness of loading is broken, <code>new TodoList()</code> sends request to the server </li><li>  In the component, you still need to insert checks on the status of the download and show the corresponding message. </li><li>  Okay, if only in the component.  In a real-world application, there may be many data sources and not all of them directly prokkiruyutsya in the component, some are converted through computed values.  In each such value, it is necessary to constantly check the status before any actions with the data.  As in the unfinishedTodoCount method from the example above. </li></ol><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @computed get unfinishedTodoCount() { return this.todoContainer.value ? this.todoContainer.value.filter(todo =&gt; !todo.finished).length : [] } //... }</span></span></code> </pre> <br><h2 id="ispolzuem-lazyobservable">  We use lazyObservable </h2><br><p>  To make the loading from the last example lazy, after rendering the component (and not in new TodoList), you can wrap fromPromise into the lazyObservable helper from mobx-utils.  The download will begin after the component executes todoContainer.current (). </p><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todoContainer = lazyObservable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sink</span></span></span><span class="hljs-function"> =&gt;</span></span> sink(fromPromise(fetchSomeTodos()))) } @computed get unfinishedTodoCount() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todoContainer.current() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todos &amp;&amp; todos.status === <span class="hljs-string"><span class="hljs-string">'fulfilled'</span></span> ? todos.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> !todo.finished).length : [] } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StatusView = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{fetchResult}</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fetchResult || fetchResult.state === <span class="hljs-string"><span class="hljs-string">'pending'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fetchResult.state === <span class="hljs-string"><span class="hljs-string">'rejected'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{fetchResult.value}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TodoListView = observer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{todoList}</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoContainer = todoList.todoContainer <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todos = todoContainer.current() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; {todos &amp;&amp; todos.state === 'fulfilled' ? &lt;div&gt; &lt;ul&gt; {todos.value.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt; )} &lt;/ul&gt; Tasks left: {todoList.unfinishedTodoCount} &lt;/div&gt; : &lt;StatusView fetchResult={todos}/&gt; } &lt;button onClick={() =&gt; todoContainer.refresh()}&gt;Fetch&lt;/button&gt; &lt;/div&gt; })</code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/hzvfsapq/4/">fiddle</a> </p><br><p>  The lazyObservable helper solves the problem of laziness, but it does not save from the template code in the component.  Yes, and the construction of <code>lazyObservable(sink =&gt; sink(fromPromise(fetchSomeTodos())))</code> is not as easy as <code>fetchSomeTodos().then(todos =&gt; this.todos = todos)</code> in the first version of the list. </p><br><h2 id="alternativa">  Alternative </h2><br><p>  Remember the idea of ‚Äã‚Äã"writing as if there is no asynchrony."  What if go further MobX?  Maybe someone already did it? </p><br><p>  So far, in my opinion, <a href="https://github.com/eigenmethod/mol/tree/master/atom">mol_atom has</a> advanced <a href="https://github.com/eigenmethod/mol/tree/master/atom">farthest</a> .  This library is part of the <a href="https://github.com/eigenmethod/mol">mol</a> framework from <a href="https://habrahabr.ru/users/vintage/" class="user_link">vintage</a> .  Here, in Habr√©, the author has written many articles about him and about the principles of his work (for example, <a href="https://habrahabr.ru/post/330466/">Object Reactive Programming</a> or PIU).  Mol is interesting for his original ideas that are not found anywhere else.  The problem is that he has his own ecosystem.  You can't take mol_atom and start using it in a project with a reactor, webpack, etc. So I had to write my own implementation, lom_atom.  Essentially, this is mol_atom adaptation, sharpened for use with the reactor. </p><br><h2 id="lenivaya-aktualizaciya">  Lazy update </h2><br><p>  Consider a similar example with a todo list on lom.  To begin, look at the component page. </p><br><pre> <code class="hljs lua">/** @jsx lom_h */ //... class TodoList { @force $: TodoList @mem set todos(<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>: Todo[] | Error) {} @mem get todos() { fetchSomeTodos() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(todos =&gt; { this.$.todos = todos }) .catch(<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> =&gt; { this.$.todos = <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> }) throw new mem.Wait() } // ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoListView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({todoList})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;ul&gt; {todoList.todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt; )} &lt;/ul&gt; Tasks left: {todoList.unfinishedTodoCount} &lt;/div&gt; }</code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/1/">fiddle</a> </p><br><p>  The following happens here. </p><br><ol><li>  Rendered TodoListView. </li><li>  This component will refer to todoList.todos, <code>get todos()</code> will work, and the code that loads data from the server will be executed. </li><li>  The data has not yet arrived, but the component must be shown right now.  Here we can either return some default value or, as in the example, throw an exception: <code>throw new mem.Wait()</code> . </li><li>  The decorator mem intercepts it and a proxy comes to the TodoListView todos. </li><li>  When accessing any of its properties, an exception is thrown inside the TodoListView. </li><li>  Since the redefined createElement wraps this component, and the wrapper intercepts exceptions, an ErrorableView will be shown, which is specified by the library setting. </li><li>  When data comes from the server, <code>this.$.todos = todos</code> (this. $ - means entry to the cache is performed, bypassing the <code>set todos() {}</code> call). </li></ol><br><p>  ErrorableView can be this content: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorableView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{error}: {error: Error}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {error instanceof mem.Wait ? </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Loading... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> : </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Fatal error !</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{error.message}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {error.stack.toString()} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> }</code> </pre> <br><p>  No matter what component and what data it uses, the default behavior is the same for all: with any exception, either a twist (in the case of mem.Wait) or an error text is shown.  This behavior saves code and nerves, but sometimes it needs to be overridden.  To do this, you can set a custom ErrorableView: </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoListErrorableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({error}: Error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;{error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> mem.Wait ? <span class="hljs-string"><span class="hljs-string">'pending...'</span></span> : error.message}&lt;/div&gt; } <span class="hljs-comment"><span class="hljs-comment">//... TodoListView.onError = TodoListErrorableView</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/2/">fiddle</a> </p><br><p>  You can simply catch the exception inside the TodoListView by wrapping in try / catch todoList.todos.  The exception thrown in a component drops only it, while drawing ErrorableView. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{todo}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (todo.id === <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'oops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> }</code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/3/">fiddle</a> </p><br><p>  In this example, we will see Fatal error only in place of the second todo. </p><br><p>  Such an exception-based approach provides the following benefits: </p><br><ol><li>  Any exception will be handled automatically (no more of this.error in TodoList) and the user will see an error message. </li><li>  Exceptions do not break the entire application, but only the component where it occurred. </li><li>  Load statuses are processed automatically, similar to exceptions (there is no longer this.status in TodoList). </li><li>  The idea is so simple that you don't need helpers like fromPromise or lazyObservable to turn asynchronous code into pseudo-sync.  All asynchronous operations are encapsulated in the <code>get todos()</code> handler. </li><li>  The code looks almost synchronous (except fetch, but above it you can make a wrapper that allows you to write it in a pseudo-synchronous form). </li></ol><br><p>  Compared to MobX, the boilerplate has become much smaller.  Each line is a line of business logic. </p><br><h2 id="neblokiruyuschaya-zagruzka">  Non-blocking download </h2><br><p>  And what will happen if in one component you display several loadable entities, that is, besides todos, for example, there are still users. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@force</span></span> $: TodoList <span class="hljs-meta"><span class="hljs-meta">@mem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> users(next: {name: string}[] | Error) {} <span class="hljs-meta"><span class="hljs-meta">@mem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> users() { fetchSomeUsers() .then(users =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$.users = users }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$.users = error }) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new mem.Wait() } <span class="hljs-comment"><span class="hljs-comment">//... } function TodoListView({todoList}) { const {todos, users} = todoList //... todos.map(...) users.map(...) }</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/4/">fiddle</a> </p><br><p>  If at the first render of TodoListView todos and users are not loaded, instead of them, proxy objects will come to the component.  That is, when we write <code>const {todos, users} = todoList</code> , <code>get todos()</code> and <code>get users()</code> are executed, their parallel loading is initiated, mem.Wait is thrown, mem wraps the exception in a proxy.  In the component, when accessing the todos.map properties or users.map, the mem.Wait exception is thrown and an ErrorableView is rendered.  After loading, the component will be rendered again, but with real data in todos and users. </p><br><p>  This is what the mol is called <a href="https://habrahabr.ru/post/311172/">synchronous code, but non-blocking requests</a> . </p><br><p>  In this approach, however, there is also a minus - you must first pull todos and users from todoList and then work with them, otherwise there will be a consistent download and optimization will not work. </p><br><h2 id="upravlenie-keshem">  Cache management </h2><br><p>  The examples above are pretty straightforward.  The decorator mem is such a smart cache, that is, if todos loaded once, then the second time mem will give them away from the cache. </p><br><p>  Once there is a cache, then it should be possible to write to the cache, bypassing the <code>set todos</code> handler.  So there is a cache invalidation problem.  You need a way to automatically reset the value if the dependency has changed, you also need to be able to manually reset the value, if you need to rewind data by pressing the button, and so on. </p><br><p>  Cleaning when a dependency changes and updating a component is solved in the same way as MobX.  And the problem of manual cache management is solved through the force decorator.  His work is demonstrated by the following example: </p><br><pre> <code class="hljs xml">class TodoList { @force forced: TodoList // .. } function TodoListView({todoList}) { return <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> todoList.forced.todos}&gt;Reset<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/5/">fiddle</a> </p><br><p>  When you click the Reset button, todoList.forced.todos is requested, which unconditionally executes <code>get todos</code> and refills the cache.  When assigning a value to todoList.forced.todos, the value is written to the cache, bypassing the <code>set todos</code> handler. </p><br><p>  Remember the above was the code with <code>this.$.todos = todos</code> ? </p><br><pre> <code class="hljs lua">/** @jsx lom_h */ //... class TodoList { @force $: TodoList @mem set todos(<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>: Todo[] | Error) {} @mem get todos() { fetchSomeTodos() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(todos =&gt; { this.$.todos = todos }) .catch(<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> =&gt; { this.$.todos = <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> }) throw new mem.Wait() } // ... }</code> </pre> <br><p>  A cache entry is a private detail of <code>get todos</code> .  When fetch receives data in it, it will write it to the cache directly, bypassing the <code>set todos</code> call.  No entry to todoList. $. Todos is allowed.  But resetting the cache (reading todoList. $. Todos) may well be initiated from the outside to repeat the request. </p><br><p>  The way it looks with force now is not the most intuitive solution, but it does not add helpers to the code, it practically does not distort the interface of class properties (it‚Äôs not necessary to do everything with methods), that is, it remains unobtrusive.  And it is very easy to solve a whole class of tasks that inevitably arise in MobX-like approaches.  The main thing here is to understand some of the rules: </p><br><ul><li>  Reading todoList.todos takes from the cache. </li><li>  If we want to reset the cache value, do a read from <code>todoList.$.todos</code> . </li><li>  If we want to write a new value and so that at the same time execute <code>set todos</code> (it can contain data in different api, validation), we do <code>todoList.todos = newTodos</code> . </li><li>  If we want to write the value directly to the cache without performing <code>set todos</code> , we do todoList. $. Todos.  This can only be done inside <code>get/set todos</code> . </li></ul><br><h2 id="slovari">  Dictionaries </h2><br><p>  In lom_atom, there are no observable wrappers for object properties and arrays, as in MobX.  But there is a simple key-value dictionary.  For example, if each todo needed to separately load the description by todoId, instead of a property, you can use the method, where the first argument is the key to which the description is cached, the second is the description itself. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoList</span></span></span><span class="hljs-class"> { // ... @force forced: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoList</span></span></span><span class="hljs-class"> @mem.key description(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoId</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoDescription</span></span></span><span class="hljs-class">?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Description</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error</span></span></span><span class="hljs-class">) { if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoDescription</span></span></span><span class="hljs-class"> !== </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">undefined</span></span></span><span class="hljs-class">) return todoDescription // set mode fetchTodoDescription(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoId</span></span></span><span class="hljs-class">) .then(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forced</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoId</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class">)) .catch(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forced</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoId</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">)) throw new mem.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Wait</span></span></span><span class="hljs-class">() } } function </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoListView</span></span></span><span class="hljs-class">({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoList</span></span></span><span class="hljs-class">}) { return &lt;div&gt; &lt;ul&gt; {todoList.todos.map(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todo</span></span></span><span class="hljs-class"> =&gt; &lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TodoView</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todo</span></span></span><span class="hljs-class">={</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todo</span></span></span><span class="hljs-class">} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desc</span></span></span><span class="hljs-class">={</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todoList</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todo</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)} reset={() =&gt; todoList.forced.description(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">todo</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)} key={todo.id} /&gt; )} &lt;/ul&gt; // ... &lt;/div&gt; }</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/zerkalica/b8uvngbg/8/">fiddle</a> </p><br><p>  If you run <code>todoList.description(todo.id)</code> , the method will work as a getter, similar to <code>get todos</code> . <br>  Since the method is one and the function 2 is get / set, there is a branch inside: </p><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (todoDescription !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todoDescription <span class="hljs-comment"><span class="hljs-comment">// set mode</span></span></code> </pre> <br><p>  That is, if <code>todoDescription !== undefined</code> , then the method is called as a setter: <code>todoList.description(todo.id, todo)</code> .  The key can be any serializable type, objects and arrays will be serialized into keys with some loss of performance. </p><br><h2 id="pochemu-mobx">  Why MobX? </h2><br><p>  Why did I start talking about MobX at the beginning?  The fact is that there is usually nothing in the business requirements about asynchrony - these are private details of the implementation of working with data, they try to abstract away from it in every way ‚Äî through streams, promises, async / await, fibers, etc. The abstractions are easier to win on the web and less intrusive.  For example, async / await is less intrusive compared to promises, since this is a language construct, the usual try / catch works, it is not necessary to pass functions to then / catch.  In other words, the async / await code looks more like non-asynchronous code. </p><br><p>  As an antipode of this approach, RxJS can be mentioned.  Here you need to plunge into functional programming, introduce a heavyweight library into the language and learn its API.  You build a stream of simple calculations, inserting them into a huge number of library expansion points, or replacing all operations with functions.  If still RxJS was in the standard of the language, however along with it there are most, pull-stream, beacon, ramda and many others in a similar style.  And each introduces its own specification for the implementation of the OP, which can no longer be changed without rewriting the business logic. </p><br><p>  Mobx does not introduce new specifications to describe observable structures.  Native classes remain, and decorators work transparently and do not distort the interface.  Its API is much simpler due to automatic data binding, there are no numerous wrappers visible over the data. </p><br><h2 id="pochemu-ne-mobx">  Why not MobX? </h2><br><p>  Updating data, handling statuses and errors in components is also trickling asynchrony: infrastructure, which in most cases is indirectly related to the subject area.  Applications without Fetch on MobX look simple, but it‚Äôs worth adding this necessary layer, like asynchronous ears start to stick out of each service or more or less complex component.  Either we have a template code, or helpers, cluttering up business logic and degrading the purity of the idea of ‚Äã‚Äã"writing as if there is no asynchrony."  The data structure is complicated, along with the data itself, the details of the implementation of the communication channel are leaked into the components: errors and data loading statuses. </p><br><p>  As an alternative to MobX, <a href="https://github.com/zerkalica/lom_atom">lom_atom</a> tries to solve these problems at the core, without bringing in helpers.  To adapt to the components of the reactor, <a href="https://github.com/zerkalica/reactive-di">reactive-di is used</a> (similar in meaning to mobx-react).  <a href="https://habrahabr.ru/post/338666/">I talked about it in my first article</a> , about trying to develop the idea of ‚Äã‚Äãreactor contexts, getting more flexible components in customization, a reusable alternative to HOC and better integration of components with flow-types and, in perspective, cheap SOLID. </p><br><h2 id="itog">  Total </h2><br><p>  I hope, I was able to show with the example of atoms how a small refinement of the basic concept can significantly simplify the code in typical tasks for the web and save the components from knowing the details of data acquisition.  And this is a small part of what the PIU can do.  In my opinion, this is a whole field of programming with its patterns, strengths and weaknesses.  And such things as mol_atom, MobX, <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">delegated-properties</a> in Kotlin are the first attempts to find the contours of this area.  If someone is aware of similar approaches in other languages ‚Äã‚Äãand ecosystems - write in the comments, it may be interesting. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340840/">https://habr.com/ru/post/340840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340826/index.html">The book "Angular for professionals"</a></li>
<li><a href="../340828/index.html">Live Rup #RuPostgres: questions and answers with Avito experts</a></li>
<li><a href="../340830/index.html">DockStation. Why we decided to make this project</a></li>
<li><a href="../340834/index.html">And how are they? Technical control over retail in foreign countries</a></li>
<li><a href="../340836/index.html">The process of hiring through the eyes of developers: the results of the survey ‚ÄúMy Circle‚Äù</a></li>
<li><a href="../340842/index.html">Galloping in Europe: the journey of the "Formula Student" from the Czech Republic to Moscow</a></li>
<li><a href="../340846/index.html">Life after banning Google Global Cache: Implications for providers and customers</a></li>
<li><a href="../340850/index.html">Internet content blocking: the situation on the world stage</a></li>
<li><a href="../340852/index.html">Adaptive emails without pain and suffering</a></li>
<li><a href="../340854/index.html">Smart nets for fishermen: how we taught smartphones to recognize fish</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>