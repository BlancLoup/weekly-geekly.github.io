<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>EWD: Substitution Processes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article Substitution Processes (1962) by Edsger Dijkstra . The division into paragraphs is not origi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>EWD: Substitution Processes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xe/nm/9z/xenm9zmppwwyiztkr3xec-jwiii.jpeg" alt="Edsger dijkstra" align="left"><br>  Hi, Habr!  I present to you the translation of the article <a href="https://www.cs.utexas.edu/users/EWD/ewd00xx/EWD28.PDF">Substitution Processes</a> (1962) by <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D0%25B0,_%25D0%25AD%25D0%25B4%25D1%2581%25D0%25B3%25D0%25B5%25D1%2580_%25D0%2592%25D0%25B8%25D0%25B1%25D0%25B5">Edsger Dijkstra</a> .  The division into paragraphs is not original. <br><br clear="left"><br><h2>  Introduction </h2><br>  A machine determines (by its very structure) a language, namely: its own input language - and, on the contrary, the semantic definition of a language defines a machine capable of understanding it.  In other words, a machine and a tongue are two sides of the same coin.  I'm going to describe such a medal.  I leave to you the decision of which of these two aspects of the subject of my conversation is, in your opinion, the most important, since I myself consider this choice rather ridiculous.  The language, the outline of which I am going to give you, is prohibitively difficult for a person, and the car that I am going to describe is perversely ineffective. <br><br>  Therefore, if my mental construct, nevertheless, has the right to exist, its justification must be found in other qualities.  In my opinion and judgment, you can find them in my car, at least in its exceptional simplicity and elegance, in the uniformity of the ways in which it performs quite different (at first glance) operations;  the justification of my language is its clarity and an unusually high degree of ambiguity arising from strict sequential interpretation and explicit indication of the operations performed in the program, although usually all operations are implied (and some misunderstandings arise from this).  If someone wants, he can consider my car and language invented for educational purposes. <br><a name="habracut"></a><br>  Before I begin the description, I would like to warn you about two deliberate omissions.  The system that I am going to present is the result of a careful choice between a multitude of ‚Äúneighboring possibilities‚Äù.  I will not explain my choice, I will even deliberately leave the alternatives not mentioned.  In other words, I will refrain from introducing my system as, as it were, a ‚Äúlocal optimum‚Äù, at least in a sense.  Since this reduces the persuasiveness of my presentation, I personally regret this omission; however, I must skip such explanations for the sake of brevity. <br><br>  Another question that I will not touch upon is the question of how to implement this system using an ordinary machine.  You can even raise the question (and I did it myself, for the sake of verifying that what I am doing is not stupid) whether it can be implemented at all, no matter how rude.  Take my word for it that this is possible.  I have developed a method of implementation to the extent that I could convince the most suspicious listener of this opportunity.  But I do not intend to show you the details of this implementation, because I had to include too many arbitrary decisions that, if they were mentioned, would distract attention from the basics.  In particular, the issue of memory allocation will remain intact. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Numbers and arithmetic </h2><br>  My machine manages (and manages) the units of information that I call words.  Without loss of generality, I can limit myself to a finite number of different words, each of which is represented by the same number of bits. <br><br>  The machine distinguishes between different types of words, such as numbers, operators, variables, and delimiters.  Now we will focus on the first of them: "words-numbers" and "words-operators." <br><br>  A normal arithmetic operation, such as the addition or multiplication of two numbers, contains two numerical words as input and one word, also a number, as an output.  The rules that assign numerical words (for example, derived from bits) to numerical values ‚Äã‚Äãare embodied in the operation of an arithmetic unit, which has the usual property that the same rules apply to both input and output: the output of the arithmetic unit can be entered again him in later stages of work.  Since we assume that the properties of an arithmetic unit are constant in time, we can say that numerical words have a "fixed meaning."  Since the fixed interpretation of numerical words is connected with the constant properties of the arithmetic unit, it is not surprising that we will denote the basic arithmetic operations with operator words (" <code>+</code> ", " <code>-</code> ", " <code>*</code> ", " <code>/</code> ", etc.), the meaning of which can also be considered fixed. <br><br>  The machine is running a program that mainly consists of a string of words.  At present, I will limit myself to parts of the program that prescribe the calculation of arithmetic expressions. <br><br>  Consider an expression that is usually written as: <br><br><pre> <code class="tex hljs"> 5 + 39 / (7 + 2 * 3) - 6</code> </pre> <br>  in the usual postfix notation (also known as ‚ÄúReverse Polish Notation‚Äù), this will result in the following sequence of numbers and operators (the adjacent elements in this sequence for the readable presentation on paper are separated by spaces): <br><br><pre> <code class="tex hljs"> 5 39 7 2 3 * + / + 6 -</code> </pre> <br>  A well-known mechanism specifically designed for the sequential evaluation of such expressions is what I prefer to call the ‚Äústack‚Äù.  (This device was invented and generalized independently by many people, which is why it is now known by a wide variety of names such as push down list, nesting store, cellar, last-in-first-out-memory etc.) If we consider the above sequence of numbers and operators as a line of words representing a part of a program, the machine reads this line word by word from left to right.  If she meets a numeric word, this number (i.e., a copy of that numeric word) is added to the top of the stack; if she meets an operator word, the corresponding operation is performed on the top of the stack.  In the illustration below, the lines indicate the successive states of the upper part of the stack, while the vertex itself is located on the right side of the line: <br><br><pre> <code class="tex hljs"> ... 5 ... 5 39 ... 5 39 7 ... 5 39 7 2 ... 5 39 7 2 3 ... 5 39 7 6 ... 5 39 13 ... 5 3 ... 8 ... 8 6 ... 2</code> </pre><br>  and the final result of the execution of this small part of the program is that the value of the expression was added to the stack. <br><br><h2>  Calculations and substitutions </h2><br>  As clearly shown in the example above, the machine starts by copying the text of the program word by word to the top of the stack.  Sooner or later it needs to be interrupted, otherwise our machine will simply be a copying machine.  In the above system, the copying process is interrupted by the appearance of an arbitrary statement in the program text.  Thus, the function of the operator is double: firstly, it shows that the copying should be interrupted, because now the operation needs to be performed, secondly, it sets this operation.  I propose to separate these two completely different functions: henceforth, arithmetic operators are basically processed in the same way as numbers are processed, i.e., the word of the operator is also copied onto the stack.  Every time the copying process has to be interrupted, I will indicate this in the program explicitly by inserting a special word entered from now on and denoted by ‚Äú <code>E</code> ‚Äù (from ‚ÄúEvaluate‚Äù - calculate).  Now my car has the following form: it reads the text of the program word by word from left to right, where ‚Äúreading‚Äù means the following: if the read word is not equal to ‚Äú <code>E</code> ‚Äù, its copy is added to the stack, if this word is equal to ‚Äú <code>E</code> ‚Äù, it is not is copied, and instead the operation is executed, indicated (initially) by the top word of the stack. <br><br>  According to these rules, the program prescribing the evaluation of the expression of our previous example will now consist of the following line of words: <br><br><pre> <code class="tex hljs"> 5 39 7 2 3 * E + E / E + E 6 - E</code> </pre> <br>  and under the control of this part of the program text (i.e., when this line of words is ‚Äúmachine readable‚Äù) the top part of the stack will be sequentially changed as shown in the following lines: <br><br><pre> <code class="tex hljs"> ... 5 ... 5 39 ... 5 39 7 ... 5 39 7 2 ... 5 39 7 2 3 ... 5 39 7 2 3 * ... 5 39 7 6 ... 5 39 7 6 + ... 5 39 13 ... 5 39 13 / ... 5 3 ... 5 3 + ... 8 ... 8 6 ... 8 6 ‚Äì ... 2</code> </pre><br>  As shown above, the machine performs the operation indicated by the top word of the stack when it reads the word ‚Äú <code>E</code> ‚Äù in the program text.  We confine ourselves to such programs that at the moment after reading the word ‚Äú <code>E</code> ‚Äù the top word of the stack is really an operator word (and not, for example, a numerical word).  In addition, we confine ourselves to the case when the words located directly behind the operator meet any requirements put forward by this operator.  (For example, in the case of the binary arithmetic operations described above, the two words immediately after the operator must be numbers.) <br><br>  In other words: if the operand of an arithmetic operation is an expression, we substitute its expression for its numeric value before performing the operation;  with this, we satisfy the condition that, in its essence, arithmetic operations are defined only on numerical operands. <br><br><h2>  Variable calculations </h2><br>  We consider replacing an expression or subexpression with its numerical value as ‚Äúsubstitution‚Äù, and we explicitly indicate when these substitutions should be performed, although it is unnecessary - ‚Äú <code>3 + 4</code> ‚Äù will always be equal to ‚Äú <code>7</code> ‚Äù, regardless of when we execute it. addition. <br><br>  However, the situation changes radically as soon as variables (in contrast with constant numbers) come into play.  (Below, we will denote variables in small letters, reserving capital letters for ‚Äúspecial words‚Äù such as ‚Äú <code></code> ‚Äù and others that will be introduced later.) Suppose we need to calculate the value of the expression: <br><br><pre> <code class="tex hljs"> x + 4</code> </pre> <br>  at the moment when the value of the variable <code></code> is equal to 3. This means that in the expression above, we must substitute its value for <code></code> at the time of the calculation;  only after that can we perform an arithmetic substitution (‚Äú <code>3 + 4</code> ‚Äù replace with ‚Äú <code>7</code> ‚Äù).  From something that depends on " <code>x</code> " (i.e., the expression " <code>x + 4</code> "), we get a result (i.e., " <code>7</code> ") that does not depend on future changes of " <code>x</code> ", since we replaced " <code>x</code> "on its value when performing the substitution.  We created a snapshot of the variable ‚Äú <code>x</code> ‚Äù.  Obviously, I insist on explicitly specifying when to create this snapshot of the variable " <code>x</code> " (which changes over time!). <br><br>  Now we will harvest the first fruits of our labor, since the mechanism of this explicit indication has already been introduced.  The part of the program that prescribes the evaluation of the expression: <br><br><pre> <code class="tex hljs"> x + 4</code> </pre> <br>  now looks like this: <br><br><pre> <code class="tex hljs"> x E 4 + E</code> </pre> <br>  and, in accordance with the above assumptions, the sequence of states of the stack is: <br><br><pre> <code class="tex hljs"> ... x ... 3 ... 3 4 ... 3 4 + ... 7</code> </pre><br>  Our machine invites us to describe the fact that ‚Äúthe value of the variable <code>x</code> is <code>3</code> ‚Äù in several other formulations, namely: that the state of the program execution process is such that reading the word ‚Äú <code>E</code> ‚Äù at the moment when the top word of the stack is ‚Äú <code>x</code> ‚Äù, leads to the replacement of this upper word with the number word " <code>3</code> ".  Thus, a variable in the upper part of the stack is considered as an operator of this variable, which in the process of calculation is replaced by something depending on the state of the program execution process at that moment;  such an ‚Äúoperator-variable‚Äù is performed without setting special requirements to the stack words immediately following it.  (The similarity between operators and variables will be further emphasized by our next example.) <br><br><h2>  Intermediate Calculations </h2><br>  All words read in the text of the program are added to the stack, with the exception of the word ‚Äú <code>E</code> ‚Äù, which causes the machine to perform substitution.  For the reasons that will be explained below, we would also like to be able to add the word " <code>E</code> " to the stack.  However, the framework for this extension is already present.  We introduce a special operator, denoted by the word " <code>P</code> " (from "Postponement" - deferment), which is performed in the course of calculations by a fixed substitution, i.e. it is replaced by the word " <code></code> ".  We will illustrate the use of the ‚Äú <code>P</code> ‚Äù operator in the following example. <br><br>  In this example, we have three variables with the names " <code>x</code> ", " <code>y</code> ", and " <code>plinus</code> " (plus-minus <code>plinus</code> plus or minus).  Suppose that the state of the program execution process is such that reading ‚Äú <code>plinus E</code> ‚Äù generates the word ‚Äú <code>+</code> ‚Äù at the top of the stack.  When reading the text: <br><br><pre> <code class="tex hljs"> x PE y PE plinus EPE</code> </pre> <br>  the top of the stack will have a sequence of states: <br><br><pre> <code class="tex hljs"> ... x ... x P ... x E ... x E y ... x E y P ... x E y E ... x E y E plinus ... x E y E + ... x E y E + P ... x E y E + E</code> </pre><br>  and the top of the stack, therefore, contains a string of words that, when read as part of a program, will perform the evaluation of the expression " <code>x + y</code> ".  If the value of the variable ‚Äú <code>plinus</code> ‚Äù were ‚Äú <code>-</code> ‚Äù, we would generate the expression ‚Äú <code>x - y</code> ‚Äù (i.e., a string of words that, being part of the program, will perform the evaluation of this expression). <br><br>  What we have produced is an intermediate evaluation of the expression ‚Äú <code>x plinus y</code> ‚Äù, the result of which is again an expression.  In our previous examples, the final action with the stack always left one number.  The number is a trivial example of an expression, because the production of not only numbers, but also more general expressions in the form of intermediate results, is an obvious continuation of common practice. <br><br><h2>  Variable changes </h2><br>  So far, we have described the generation of words at the top of the stack, but not what we will do with these words.  In addition, we have assumed that with respect to a given variable, the program execution process may be in such a state that the calculation of this variable will lead to a previously defined replacement, but the definition of this replacement has not been previously mentioned.  These two spaces will be filled with the introduction of assignment operators. <br><br>  To assign a value to one word, as in " <code>x := 3</code> ", we could write in our program: <br><br><pre> <code class="tex hljs"> 3 x := E</code> </pre> <br>  resulting in top of stack states: <br><br><pre> <code class="tex hljs"> ... 3 ... 3 x ... 3 x :=</code> </pre><br>  During the execution of the assignment operator ‚Äú <code>:=</code> ‚Äù, the machine examines the word immediately behind it.  This should be a variable to which the assignment should be applied;  the word following it is assigned to this variable (more on this below), and the three words at the top of the stack (which are now being processed) are removed from the stack.  Prior to the subsequent assignment (i.e., the new assignment of the variable ‚Äú <code>x</code> ‚Äù), the calculation of this variable will lead to the replacement of the top word of the stack with the word ‚Äú <code>3</code> ‚Äù. <br><br><h2>  String assignments </h2><br>  Accurately to the position of the left and right side, this is closely related to the similar assignment statement used in <code>ALGOL 60</code> .  However, we don‚Äôt have enough to assign a value from just one word, we need to assign a value from a string of words, and therefore we should be able to indicate how deeply the assigned value is pulled into the stack.  The easiest way to do this is to insert a marker in the stack, for example, the special word ‚Äú <code></code> ‚Äù (from ‚ÄúTerminal‚Äù - end) after the last word of the value assigned.  In addition, we introduce another assignment operator ‚Äú <code>:-</code> ‚Äù (called ‚Äústring assignment‚Äù as opposed to ‚Äúword assignment‚Äù, presented in the previous paragraph).  During the execution of this operator, the machine explores the top of the stack in a downward direction.  The first word (immediately under the operator " <code>:-</code> ") should be a variable, which should be assigned a value.  After that, the machine continues its word-for-word study down until it meets the special ‚Äú <code></code> ‚Äù marker: the words thus transmitted form together a string, which is perceived as an assigned value. <br><br>  The easiest way to add ‚Äú <code></code> ‚Äù to the stack is to simply insert the word ‚Äú <code></code> ‚Äù in the right place in the program that controls the stack.  However, we will not do this;  for reasons that will be explained later, we need the ability to generate " <code></code> " on top of the stack under the control of the program, which itself does not contain this word.  We can do this with the same trick that allowed us to create an ‚Äú <code>E</code> ‚Äù on top of the stack.  We introduce a new operator, denoted by the word " <code>S</code> " (say, from "Separator" is a separator, or simply because " <code>S</code> " precedes " <code>T</code> " in the alphabet), which is replaced by the word " <code>T</code> " during execution, and we will establish a rule that this is the only way to add the words " <code></code> " to the stack. <br><br>  Using all this, we have an alternative entry of the assignment operator ‚Äú <code>x := 3</code> ‚Äù, namely: <br><br><pre> <code class="tex hljs"> SE 3 x :- E</code> </pre> <br>  giving the sequence of states of the upper part of the stack: <br><br><pre> <code class="tex hljs"> ... S ... T ... T 3 ... T 3 x ... T 3 x :-</code> </pre><br>  The result of this is equivalent to the previous form, which used the assignment of the words " <code>:=</code> ". <br><br><h2>  Saving intermediate calculations to strings </h2><br>  Let's use a more powerful assignment in the example, which is an extension of one of our early ones, namely, that which describes the intermediate calculation of the expression ‚Äú <code>x plinus y</code> ‚Äù.  The result of this intermediate calculation was an expression depending on the variables ‚Äú <code>x</code> ‚Äù and ‚Äú <code>y</code> ‚Äù, and suppose we want to call this expression ‚Äú <code>z</code> ‚Äù.  To do this, we write in the program: <br><br><pre> <code class="tex hljs"> SE x PE y PE plinus EPE z :- E</code> </pre> <br>  When the last operator ‚Äú <code>E</code> ‚Äù of this line is executed, the upper part of the stack will look like this (with the same assumption regarding the value of ‚Äú <code>plinus</code> ‚Äù): <br><br><pre> <code class="tex hljs"> ... T x E y E + E z :-</code> </pre><br>  and after executing this statement, the above words will be removed from the stack, including the word " <code>T</code> " inclusive.  Before the subsequent assignment, the calculation of the variable ‚Äú <code>z</code> ‚Äù will mean the execution (‚Äúreading‚Äù) of the string assigned to it.  During the calculation of the variable " <code>z</code> ", the machine must have access to the first word of this line;  however, when she starts reading this line, she also needs to know where the last word of this line is.  We assume that the assignment statement takes this into account by adding the end marker again, and for this purpose we can use the same word " <code></code> ".  During the calculation of the variable ‚Äú <code>z</code> ‚Äù, the line assigned to it will be read as a part of the program from left to right until the end marker ‚Äú <code>T</code> ‚Äù is encountered.  The new situation associated with the last assignment can be easily represented: <br><br><pre> <code class="tex hljs"> z ‚Üí x E y E + ET</code> </pre> <br>  Similarly, our previous assignments: <br><br><pre> <code class="tex hljs"> 3 x := E</code> </pre> <br><pre> <code class="tex hljs"> SE 3 x :- E</code> </pre> <br>  will contribute to the situation presented as follows: <br><br><pre> <code class="tex hljs"> x ‚Üí 3 T</code> </pre> <br><br>  One of the most striking aspects of this arrangement is that the usual distinction between ‚Äúnumbers‚Äù and ‚Äúinstructions‚Äù has completely disappeared.  The value of a variable is defined as part of the program, the calculation of this variable implies the execution of this part of the program. <br><br><h2>  Notes on current developments </h2><br><h3>  On duality of assignments and readings </h3><br>  In addition, we would like to draw attention to a certain form of duality between appropriation, on the one hand, and reading the text, on the other.  When a machine reads a piece of program text, the top of the stack is filled under the control of that program text.  In a readable text assignment, it is created under the control of the stack contents.  Duality can also be illustrated with regard to accessibility requirements.  Words in the stack should only be available from top to bottom.  However, if the assignment statement converts the top of the stack into readable text, subsequent words become available in the other direction. <br><br>  Finally, the stack is reserved for ‚Äúanonymous intermediate results,‚Äù whereas the readable text is, in principle and at least, always ‚Äúnamed‚Äù because we create it by assigning it to a variable. <br><br><h3>  About recursion </h3><br>  The attentive reader noticed that along with the presentation of the value of the variable, we silently entered two more changes in our car. <br><br>  The first - the appearance of the word " <code></code> " in the text of the program and the "immediate response" of the machine to it is relatively simple.  According to our agreements, the word " <code></code> ", read in the text, is not copied to the top of the stack!  Instead, it causes the machine to continue reading until the word variable is immediately before the ‚Äú <code>E</code> ‚Äù operator that caused this calculation of the variable in question.  In other words, it acts as a ‚Äú <code>return</code> ‚Äù at the end of a closed subroutine. <br><br>  But computing a variable may require computing other variables (including itself): the practical definition of computing a variable is basically recursive, and the mechanism that needs the accompanying recursive definition is ... another stack!  I call this second stack the ‚Äúactivation stack‚Äù as opposed to the first one, which I call the ‚Äúanonymous stack‚Äù.  One of the functions of the activation stack is to control the reading process.  When the calculation of a variable begins, the stack of activations is filled, and when the corresponding word ‚Äú <code></code> ‚Äù is read, it decreases to its previous size.  (In the usual terminology of the machine structure: the activation stack contains a stack of order counter values, its top element is, by definition, the counter of the current order; in the same terminology, its old elements act as a stack containing return addresses.) <br><br>  <strong>Comment.</strong>  We could try to merge our two stacks into one.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This merging occurs in a completely natural way if they are to expand and contract synchronously with each other. </font><font style="vertical-align: inherit;">In general, however, this is not the case, and trying to combine these two stacks into one will give a very unnatural construction.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concept of identifier </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use the activation stack for another purpose to satisfy a very fundamental need, namely the creation of new variables. Above, I used special words (" </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", " </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", " </font></font><code>plinus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", etc.) to refer to variables, and I carefully avoided using the term "identifier". I have used the term ‚Äúvariable‚Äù in the designation of a single and unique object that exists for a certain period of time and is capable of consistently taking on different meanings. This concept of a variable should be carefully distinguished from the ‚Äúidentifier‚Äù used in </font></font><code>ALGOL 60</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because the same identifier can be used to refer to many objects, to a large number of different variables.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, we note the fact that the same identifier can play different roles due to the fact that it is found in more than one ad. </font><font style="vertical-align: inherit;">Then the lexicographic rule can determine which of these declarations in which case to apply, for all uses of the specified identifier. </font><font style="vertical-align: inherit;">This form of reuse of the same identifier can be removed by a simple renaming process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is a much more subtle case of ‚Äúrepeated use of the same identifier‚Äù, namely: as soon as a certain block appears in one or several nested activations (as in the case of a recursive procedure). </font><font style="vertical-align: inherit;">In other words: the same identifier sometimes refers to this variable, sometimes to another.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use identifiers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, an identifier denotes a variable and in order to clearly define which one, I will explicitly denote the moment when variable substitution occurs instead of an identifier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For convenience (more precisely: convenience for the machine, and not for a hypothetical user), I intend to use the same identifiers for the local variables of each activation. (What I call ‚Äúactivation‚Äù is close to the same block or procedure used </font></font><code>ALGOL 60</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) I use the special identification words ‚Äú </font></font><code>L0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù, ‚Äú </font></font><code>L1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù, ‚Äú </font></font><code>L2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù, etc. </font><font style="vertical-align: inherit;">for this purpose </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the machine starts calculating a variable, the activation stack increases by one item. The beginning of this element also contains the record that so far no local variables have been entered in this activation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the machine reads the word " </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" at the moment when the top of the anonymous stack contains one of the word identifiers (for example, " </font></font><code>L2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"), it examines the top element of the activation stack. If this is the first calculation of the identifier in the current activation, the machine creates a new variable for it (and can give this variable an empty value) and makes a record of this action in the top element of the activation stack. It then replaces the upper word of the anonymous stack with the newly created variable. During the next calculation of the same identifier within the same activation that remains current or returns to this state, the machine finds in the top element of the activation stack the record left there during the first calculation of this identifier and the upper word of the stack is replaced with the same variable.</font></font><br><br><h2>  Procedures </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can consider a more complex example. </font><font style="vertical-align: inherit;">Let the values ‚Äã‚Äãof the variables " </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", " </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" and " </font></font><code>complus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" (from "complex-plus" - complex plus) be represented as follows:</font></font><br><br><pre> <code class="tex hljs"> x ‚Üí 10 23 T</code> </pre> <br><pre> <code class="tex hljs"> y ‚Üí 5 -2 T</code> </pre> <br><pre> <code class="tex hljs"> complus ‚Üí L0 E := E L1 E := E L2 E := E L1 EE + E L1 EE L0 EE + E T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if we read the text now: </font></font><br><br><pre> <code class="tex hljs"> SE x E y E complus E z :- E</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the end result will be that we can present a new value " </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">":</font></font><br><br><pre> <code class="tex hljs"> z ‚Üí 15 21 T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and what we have done can be interpreted as the addition of two complex numbers. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In terminology </font></font><code>ALGOL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äúcomplus‚Äù is a procedure with four numerical parameters, all called by value. </font><font style="vertical-align: inherit;">The simple structure of the process allows the first of them to remain anonymous even in the body of the procedure. </font><font style="vertical-align: inherit;">In addition, it is a kind of ‚Äúprocedure with type‚Äù, that is, it accepts and returns, syntactically speaking, one value of some type instead of two primitives.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note on arbitrariness of primitives </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me finish with a trivial example. </font><font style="vertical-align: inherit;">Suppose we want to write " </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" instead of " </font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Assignment:</font></font><br><br><pre> <code class="tex hljs"> SE + PE plus :- E</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leads to the situation: </font></font><br><br><pre> <code class="tex hljs"> plus ‚Üí + ET</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then expressions: </font></font><br><br><pre> <code class="tex hljs"> x E y E plus E</code> </pre> <br><pre> <code class="tex hljs"> x E y E + E</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fully equivalent. </font><font style="vertical-align: inherit;">This example is included to show the arbitrariness of our primitives as clearly as possible.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am fully aware that the developments cited here are definitely incomplete. It is especially important to introduce a conditional operator and some equivalent " </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" if you want to create a complete system of this. At the moment I do not understand them, and I do this for two reasons. Firstly, for the sake of brevity, and secondly, because I have not yet decided: I know several possible ways, but none of them completely satisfy me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With some versions of these objects I created some more complex programs. They showed me both the strength and the weakness of my tongue, its strength - flexibility and unambiguity, weakness in that it was reasonably difficult to use it, at least for me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If, however, I demand attention to this project, I do not do it just because it enchants me and can enchant others. This report is the quintessence of my thinking after we completed our implementation </font></font><code>ALGOL 60</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This implementation was conceived at high speed, and the main rationale for the numerous decisions made during those difficult months was the recognition that our designs would lead to our goal and somehow do our job. However, the machine described in this report represents the end of the spectrum of possible implementations of the algorithmic language, which (as in the case of</font></font><code>ALGOL 60</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) satisfies recursiveness. In this capacity, everything was very understandable for me personally: it helped me a lot in evaluating various (not originally appreciated) tricks that we included intuitively, and this clearly showed us a number of alternative solutions. This justifies the hope that in the future the construction of translators and machine design will develop in the same vein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the machine presented here is so ridiculously inefficient that, in all likelihood, any practical implementation of a practical algorithmic language can be regarded as its optimization, optimization through the restriction of a language. It may be useful to compare the proposed language with my language; During the language building process, timely detection of ‚Äúcostly functions‚Äù may be helpful. Whether such an expensive function will be included in the language or not, it is more or less a political question, but it is nice that the question was asked at all, regardless of how you answer this question.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the language described in this report (or a language developed in a similar way) may be an appropriate means to formalize the semantic definition of an algebraic language. </font><font style="vertical-align: inherit;">The absence of such a strict semantic definition is one of the recognized shortcomings of the official ‚ÄúReport on Algorithmic Language </font></font><code>ALGOL 60</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äù and, having seen the huge problem caused by this defect, I sincerely hope that this report will help to avoid this error the next time an algorithmic language is developed.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acknowledgments </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A significant number of people contributed to this, consciously or not. </font><font style="vertical-align: inherit;">In addition to all my colleagues in the Computing Department of the Amsterdam Mathematical Center, I would like to mention </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25B8%25D0%25BB%25D0%25BA%25D1%2581%252C_%25D0%259C%25D0%25BE%25D1%2580%25D0%25B8%25D1%2581_%25D0%2592%25D0%25B8%25D0%25BD%25D1%2581%25D0%25B5%25D0%25BD%25D1%2582"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dr. Maurice Wilks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BA%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25B8,_%25D0%2594%25D0%25B6%25D0%25BE%25D0%25BD"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Professor John McCarthy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who turned out to be inspirational listeners, and especially </font></font><a href="https://en.wikipedia.org/wiki/Mike_Woodger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mr. Michael Woodger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : his criticism and comments (I recall his lack of enthusiasm for my The first tests in this direction now with gratitude) were a big help for me.</font></font></div><p>Source: <a href="https://habr.com/ru/post/336982/">https://habr.com/ru/post/336982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336970/index.html">RxSwift: a bit about share (), replay (), shareReplayLatestWhileConnected () and other cool operators</a></li>
<li><a href="../336972/index.html">Optimization of the process of searching for violators of land legislation</a></li>
<li><a href="../336976/index.html">‚ÄúBy whom do you see yourself in 5 years?‚Äù: Wall Street top manager's advice on the answers to the cunning questions of recruiters</a></li>
<li><a href="../336978/index.html">Traffic mirroring on Juniper MX</a></li>
<li><a href="../336980/index.html">Creating a programming language using LLVM. Part 9: Add Debugging Information</a></li>
<li><a href="../336984/index.html">Position selection procedure</a></li>
<li><a href="../336988/index.html">Programming Contest: JSDash (Results)</a></li>
<li><a href="../336992/index.html">Mobile Applications Testing Cheat Sheet</a></li>
<li><a href="../336994/index.html">Getting rid of fragment state saving libraries using pure kotlin</a></li>
<li><a href="../336998/index.html">Fast rendering of ocean waves on mobile devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>