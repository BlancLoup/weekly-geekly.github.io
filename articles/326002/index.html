<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our monads on Scala using the example of a CSV parser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently we learned a lot about monads. We have already figured out what it is and even know how to draw them, we saw reports explaining their purpose...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our monads on Scala using the example of a CSV parser</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently we learned a lot about monads.  We have already figured out <a href="https://habrahabr.ru/post/209510/">what it is</a> and even know <a href="https://habrahabr.ru/post/183150/">how to draw them, we</a> saw <a href="https://www.youtube.com/watch%3Fv%3DYCOSAazIi2Q">reports</a> explaining their purpose.  So I decided to drop into the outgoing monad train and write on this topic, until it finally became mainstream.  But I will come from a slightly different side: there will be no calculations from category theory, there will be no inserts in the <em>very best language</em> , and there will not even be scalaz / shapeless and parser-combinators libraries.  As you know, the best way to figure out how something works is to do it yourself.  Today we will write our monad. </p><br><p><img src="https://habrastorage.org/files/db5/602/80a/db560280aa1148fca543641dcb1717c4.png" alt="image"></p><br><h1 id="zadacha">  Task </h1><br><p>  Take for example the banal task: parsing a CSV file.  Suppose we need to parse the file strings into case classes, then send them to the database, serialize to json / protobuf, and so on.  Forget about escaping and quotes, for even greater simplicity, we believe that the delimiter character cannot be found in the fields.  I think that if someone decides to drag this solution into your project, it will not be difficult to twist this feature. </p><br><a name="habracut"></a><br><p>  Suppose we have the following CSV file: </p><br><pre><code class="hljs swift"><span class="hljs-number"><span class="hljs-number">1997</span></span>;<span class="hljs-type"><span class="hljs-type">Ford</span></span>;<span class="hljs-type"><span class="hljs-type">E350</span></span>;ac, <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>, moon;<span class="hljs-number"><span class="hljs-number">3000.00</span></span> <span class="hljs-number"><span class="hljs-number">1996</span></span>; <span class="hljs-type"><span class="hljs-type">Jeep</span></span>; <span class="hljs-type"><span class="hljs-type">Grand</span></span> <span class="hljs-type"><span class="hljs-type">Cherokee</span></span>; <span class="hljs-type"><span class="hljs-type">MUST</span></span> <span class="hljs-type"><span class="hljs-type">SELL!</span></span> air, moon roof, loaded; <span class="hljs-number"><span class="hljs-number">4799.00</span></span> <span class="hljs-number"><span class="hljs-number">1999</span></span>;<span class="hljs-type"><span class="hljs-type">Chevy</span></span>;<span class="hljs-type"><span class="hljs-type">Venture</span></span> <span class="hljs-string"><span class="hljs-string">"Extended Edition"</span></span>; ; <span class="hljs-number"><span class="hljs-number">4900.00</span></span></code> </pre> <br><p>  We need to deserialize it into a set of objects of the following type: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">year: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, mark: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, model: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, comment: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, price: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">BigDecimal</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><h1 id="ochevidnyy-podhod">  Obvious approach </h1><br><p>  In order to compare with something, I have to give an example from life, which the use of monads makes clearer, more pleasant, more reliable, etc. </p><br><p>  Suppose the file line is already loaded into the <code>content</code> variable: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lines = content.split('\n') <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> entities = lines.map { line =&gt; line.split(';').map(_.trim) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Array</span></span>(year, mark, model, comment, price) =&gt; <span class="hljs-type"><span class="hljs-type">Car</span></span>(year.toInt, mark, model, comment, <span class="hljs-type"><span class="hljs-type">BigDecimal</span></span>(price)) } }.toSeq</code> </pre> <br><h2 id="minusy-podhoda">  Cons of the approach: </h2><br><ul><li>  Mixing the logic of converting field types and constructing the entity itself. </li><li>  Boilerplate case matching: with an increase in the number of fields, the code will rapidly lose readability. </li><li>  It is necessary to explicitly handle cases when the number of fields does not match the expected, when the string is too long, etc. </li></ul><br><h2 id="plyusy">  Pros: </h2><br><ul><li>  Straight-forward: no additional layers of abstraction. </li></ul><br><h1 id="monadicheskiy-parser">  Monad parser </h1><br><p>  I suggest to look at the task from the other side. </p><br><ul><li>  Imagine that at the beginning we have one piece of raw data - in a particular case - a line from a file, although in fact it doesn‚Äôt matter to us: it could be a byte array, a list of words, an iterator, anything from which we can get data. </li><li>  Suppose that we write each record in several stages, each of which is the parsing of a specific field in the record.  Then for each stage we can fix the result: the value of this field (hereinafter <strong>referred to as the word</strong> ) + the remainder of the raw data (hereinafter <strong>referred to as the remainder</strong> ), which we will consider at the subsequent stages of parsing, extracting the following fields from it.  Or we will not, if the field is the last. <br>  Further, for brevity, we will call this function " <strong>handler</strong> ". </li><li>  Then in the end we will only have to combine the results of these stages into the final entity. </li></ul><br><p><img src="https://korpse.github.io/parser.svg" alt="image"></p><br><p>  Returning to the code, the handler of each stage is to have an ad like: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>]: <span class="hljs-type"><span class="hljs-type">Src</span></span> =&gt; (<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>)</code> </pre> <br><p>  Now a little about the monads themselves. </p><br><p>  In a nutshell, a monad can be described as a container containing a value + some context. <br>  Syntactically, in the case of Scala, this means that the monad must have the flatMap method, generally declared as: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">M</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]</code> </pre> <br><p>  If f is a value stored in a container, then what is the context?  Here's what: although f has only one argument, but since we can call another flatMap from within one flatMap, from the internal flatMap we will have access to all the values ‚Äã‚Äãdeclared inside the external, that is, including all the previous words. </p><br><p><img src="https://korpse.github.io/monad.svg" alt="image"></p><br><p>  Please note that it is not necessary to implement the map method from the monad, but we will still define it, it will be useful for us to create modified parsers from those already defined. </p><br><p>  You also need to define the operation of wrapping the net value into a monad.  This is not a class method, but it can be a constructor call, or the apply method of the companion object, there is no strict requirement for this, and I suggest defining the apply method for convenience. </p><br><p>  We implement the monad containing the function parse, such as we defined above and see how we can combine different parsers with it. </p><br><p>  So we need to write a class that encapsulates the parsing of a field of a particular type, which: </p><br><ol><li>  Implements the flatMap method </li><li>  Implements the map method </li><li>  You also need to define the apply operation on the companion object. </li><li>  You need to define an interface method that will be called by the final client code and will not contain unnecessary details in the declaration. </li></ol><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Src</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">private val p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Src</span></span></span></span><span class="hljs-class"><span class="hljs-params"> =&gt; (</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Src</span></span></span></span></span><span class="hljs-class">)) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">M</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">M</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>]): <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">M</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>] = <span class="hljs-type"><span class="hljs-type">Parser</span></span> { src =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (word, rest) = p(src) f(word).p(rest) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">M</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>): <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">M</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>] = <span class="hljs-type"><span class="hljs-type">Parser</span></span> { src =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (word, rest) = p(src) (f(word), rest) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(src: <span class="hljs-type"><span class="hljs-type">Src</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = p(src)._1 }</code> </pre> <br><p>  So what happens in the <strong>flatMap</strong> method? <br>  We apply the current parser's handler to the input value, then using the function - method argument we add it to the context visible to all subsequent parsers along the chain. </p><br><p>  With the <strong>map</strong> method, everything is much clearer, we simply apply its argument - the function f to the current word, and leave the rest unchanged. </p><br><p>  And the companion object containing the point operation, which is also the apply method, which is also an object call with parentheses: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>](f: <span class="hljs-type"><span class="hljs-type">Src</span></span> =&gt; (<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">Src</span></span>](f) }</code> </pre> <br><h1 id="primenenie">  Application </h1><br><p>  So what?  What advantages does this approach give us, apart from the undoubted increase of your authority among colleagues unfamiliar with monads?  Now we will see. </p><br><p>  Using the abstraction suggested above, we finally write our innovative, functional, type-safe CSV parser. </p><br><h2 id="pishem-parsery-tipov-poley">  We write field type parsers </h2><br><p>  To begin with, we implement a parser of one field of type String. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringField</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] { str =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> idx = str.indexOf(separator) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>) (str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, idx), str.substring(idx + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (str, <span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre> <br><p>  Nothing complicated, right? </p><br><p>  Now let's see how to define an Int type parser based on StringField. <br>  Even easier! </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntField</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">StringField</span></span>.map(_.toInt)</code> </pre> <br><p>  Similarly for all the rest: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigDecimalField</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">StringField</span></span>.map(<span class="hljs-type"><span class="hljs-type">BigDecimal</span></span>(_)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntField</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">StringField</span></span>.map(_.toInt) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BooleanField</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">StringField</span></span>.map(_.toBoolean) <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><h2 id="sobiraem-vse-voedino">  Putting it all together </h2><br><p>  So far, we have considered only the parsers of individual fields, but how do we collect these fields into a single entity?  This is where the <em>context</em> comes in.  Thanks to him, we can use the values ‚Äã‚Äãobtained in the overlying parsers in the underlying parsers. </p><br><p>  So, the construction of the final entity parser will look like this: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parser = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { year &lt;- <span class="hljs-type"><span class="hljs-type">IntField</span></span> mark &lt;- <span class="hljs-type"><span class="hljs-type">StringField</span></span> model &lt;- <span class="hljs-type"><span class="hljs-type">StringField</span></span> comment &lt;- <span class="hljs-type"><span class="hljs-type">StringField</span></span> price &lt;- <span class="hljs-type"><span class="hljs-type">BigDecimalField</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Car</span></span>(year, mark, model, comment, price)</code> </pre> <br><p>  In my opinion it looks very cool. <br>  If you suddenly do not feel completely confident with syntactic sugar for comprehension, then this would be approximately how it would look like a chain of flatMaps: </p><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IntField</span></span>.flatMap { year =&gt; <span class="hljs-type"><span class="hljs-type">StringField</span></span>.flatMap { mark =&gt; <span class="hljs-type"><span class="hljs-type">StringField</span></span>.flatMap { model =&gt; <span class="hljs-type"><span class="hljs-type">StringField</span></span>.flatMap { comment =&gt; <span class="hljs-type"><span class="hljs-type">BigDecimalField</span></span>.map { price =&gt; <span class="hljs-type"><span class="hljs-type">Car</span></span>(year, mark, model, comment, price) } } } } }</code> </pre> <br><p>  It looks, of course, a little worse, but it becomes obvious what contexts we are talking about, these are scopes bounded by curly braces. </p><br><p>  We got the parser parser, now all we need is to feed the source file line by line to its parse method and get the result.  For example: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = str.split('\n').map(parser.parse)</code> </pre> <br><p>  Result: </p><br><pre> <code class="hljs lisp">Array(<span class="hljs-name"><span class="hljs-name">Car</span></span>(<span class="hljs-number"><span class="hljs-number">1997</span></span>,Ford,E350,ac, abs, moon,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>), Car(<span class="hljs-number"><span class="hljs-number">1996</span></span>,Jeep,Grand Cherokee,MUST SELL! air, moon roof, loaded,<span class="hljs-number"><span class="hljs-number">4799.00</span></span>), Car(<span class="hljs-number"><span class="hljs-number">1999</span></span>,Chevy,Venture <span class="hljs-string"><span class="hljs-string">"Extended Edition"</span></span>,,<span class="hljs-number"><span class="hljs-number">4900.00</span></span>))</code> </pre> <br><h2 id="plyusy-1">  pros </h2><br><ul><li>  The final parser is described beautifully and concisely, from its declaration it is easy to understand the types and sequence of fields in the file, it is easy to change and test. </li><li>  You are a cool expert who knows a lot about OP, capable of monads and generally the most fashionable <del>  in the area </del>  in openspace. </li></ul><br><h2 id="minusy">  Minuses </h2><br><ul><li>  The presence of a generalized entity with not the most obvious logic, especially for those who are not very good at these your monads, or who have recently transferred from Java. </li></ul><br><h1 id="rezyume">  Summary </h1><br><p>  Monads and other categories in the Rock are not something that cannot be lived without.  Moreover, they are practically not imposed by the language itself.  In essence, monadnosti in Scala is a small ad-hoc contract, fulfilling which you get the opportunity to use your classes in for-comprehension.  And that is all. </p><br><p>  Nevertheless, the flexibility of the language and the ability to quite easily implement rather clever constructs on it - this is an absolute plus of the language, which unleashes hands for experiments. </p><br><p>  As to whether it is worth using such constructions in the production code: I do not know, this is the choice of each individual command.  Probably, I would first try to allocate them into separate libraries, cover them with tests and test them in every possible way (although we certainly know that with real functionaries everything works without tests).  And for the logic that is needed here and now, I would rather use a more straight-forward implementation. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326002/">https://habr.com/ru/post/326002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325990/index.html">Character Design 2B for Nier: Automata</a></li>
<li><a href="../325992/index.html">VAT and freelancers working with Upwork</a></li>
<li><a href="../325994/index.html">6 fresh examples of parsing and design improvements in simple ways</a></li>
<li><a href="../325996/index.html">e-Government of the future</a></li>
<li><a href="../325998/index.html">Parse the qualified X.509 certificates in the search for TIN, SNILS and OGRN</a></li>
<li><a href="../326004/index.html">The digest of interesting materials for the mobile developer # 198 (April 2-9)</a></li>
<li><a href="../326006/index.html">An example of creating a web application on PureQML</a></li>
<li><a href="../326008/index.html">Integration of IS with ESIA via SAML</a></li>
<li><a href="../326014/index.html">Looks like I'm not an entrepreneur</a></li>
<li><a href="../326016/index.html">Application evolution or where are we going</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>