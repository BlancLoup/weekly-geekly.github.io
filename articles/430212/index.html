<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenSceneGraph: Scene Geometry Basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 OpenGL, which is the backend for OpenSceneGraph, uses geometric primitives (such as points, lines, triangles, and polygonal faces) to b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenSceneGraph: Scene Geometry Basics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><br><h1>  Introduction </h1><br>  OpenGL, which is the backend for OpenSceneGraph, uses geometric primitives (such as points, lines, triangles, and polygonal faces) to build all objects in the three-dimensional world. <br><br>  These primitives are specified by their vertices, which include vertex coordinates, normal components, color data, and texture coordinates.  This data is stored in special arrays.  Primitives can be formed, for example, by specifying a list of vertex indices for objects describing them.  This method is called the vertex array method; it eliminates the storage of redundant vertices in memory and has good speed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, OpenGL can use the mechanism of so-called <i>display lists</i> , when primitives once prepared in video memory can be reused, which significantly speeds up the display of static objects. <br><br>  By default, OSG uses the vertex array method and the display list method to render the geometry.  However, the rendering strategy can be changed, depending on how the geometry data is presented.  In this article we will look at the basic techniques for working with geometry in OSG. <br><a name="habracut"></a><br><h1>  1. Geode and Drawable Classes </h1><br>  The class osg :: Geode is a terminal, so-called "leaf" node of the scene tree.  It cannot have child nodes, but it contains all the necessary information for rendering geometry.  His name - Geode is an abbreviation for the words geometry node. <br><br>  Geometric data to be processed by the engine are remembered in a set of objects of the osg :: Drawable class, managed by the osg :: Geode class.  The osg :: Drawable class is a purely virtual class.  A number of subclasses are inherited from it, which are three-dimensional models, images and text processed by the OpenGL pipeline.  A drawable in OSG refers to all elements that can be drawn by the engine. <br><br>  The osg :: Geode class provides a number of methods for attaching and detaching drawables: <br><br><ul><li>  Public method addDrawable () - passes a pointer to a drawable element to an instance of the class osg :: Geode.  All these elements are controlled by smart pointers osg :: ref_ptr &lt;&gt;. <br></li><li>  The public method removeDrawable () and removeDrawables () removes the object from osg :: Geode and reduces the reference count to it.  The removeDrawable () method takes as its only parameter a pointer to the element of interest, and the removeDrawables () method takes two parameters: the initial index and the number of elements to be removed from the array of osg :: Geode objects. <br></li><li>  The getDrawable () method returns a pointer to an element at the index passed as a parameter. <br></li><li>  The getNumDrawables () method returns the total number of elements attached to osg :: Geode.  For example, to remove all elements from osg :: Geode, you can use such code <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Drawing the simplest shapes </h1><br>  OSG provides the osg :: ShapeDrawable class, which is derived from the osg :: Drawable class, and is intended to create the simplest three-dimensional primitives.  This class includes an osg :: Shape object that stores information about a specific geometry and more parameters.  Primitives are generated using the setShape () method, for example <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  creates a rectangular parallelepiped with a geometric center at the point (1.0, 0.0, 0.0) with a width and height of 10 and a depth of 5 units.  The class osg :: Vec3 defines a vector in three-dimensional space (in addition, the classes osg :: Vec2 and osg :: Vec4 describe the vectors of the corresponding dimension are presented). <br><br>  The most popular primitives are represented in OSG by the classes osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder and osg :: Sphere. <br><br>  Consider an example of this mechanism. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  This example doesn‚Äôt need any particular comments: three simplest shapes are created in the program, after compiling and running we will see the following result <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  The mechanism shown in the example is simple and straightforward, but it is not the most effective way to create geometry and can be used exclusively for tests.  To create geometry in high-performance OSG-based applications, the class osg :: Geometry is used. <br><br><h1>  3. Geometry data storage: classes osg :: Array and osg :: Geometry </h1><br>  The osg :: Array class is a basic abstract class, from which several descendants are inherited, intended for storing data passed to the OpenGL functions.  Working with this class is similar to working with std :: vector from the standard C ++ library.  The following code illustrates adding a vector to an array of vertices using the push_back () method <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  OSG arrays are allocated in a heap and controlled by smart pointers.  However, this does not apply to array elements, such as osg :: Vec3 or osg :: Vec2, which can also be created on the stack. <br><br>  The osg :: Geometry class is a wrapper around OpenGL functions that work with arrays of vertices.  It is derived from the class osg :: Drawable and can easily be added to the list of objects osg :: Geode.  This class takes the above arrays as input and uses them to generate geometry using OpenGL. <br><br><h1>  4. Vertices and their attributes </h1><br>  Vertex is an atomic unit of primitives of geometry.  It has a number of attributes that describe a point of two- or three-dimensional space.  Attributes include: position, color, normal vector, texture coordinates, fog coordinates, and so on.  A vertex must always have a position in space, as for other attributes, they may optionally be present.  OpenGL supports 16 basic vertex attributes and can use different arrays to store them.  All attribute arrays are supported by the osg :: Geometry class and can be set by methods of the type set * Array (). <br><br>  <b>Vertex Attributes in OpenSceneGraph</b> <br><table><tbody><tr><th>  Attribute </th><th>  Data type </th><th>  Osg method :: Geometry </th><th>  Equivalent OpenGL call </th></tr><tr><td>  Position </td><td>  3-vector </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3-vector </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Colour </td><td>  4-vector </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Secondary color </td><td>  4-vector </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Fog Coordinates </td><td>  float </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Texture coordinates </td><td>  2- or 3-vector </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Other attributes </td><td>  User defined </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  In principle, it is necessary to set your attributes for each of the vertices, which leads to the formation of several arrays of attributes of the same size - otherwise the mismatch of the sizes of the arrays can lead to undefined behavior of the engine.  OSG supports various methods of linking vertex attributes, for example <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  means that each vertex and each vertex color are in one-to-one correspondence with each other.  However, if you look at this code <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  then he applies one color to the whole geometry.  Similarly, relationships between other attributes can be configured by calling the setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () methods and setVertexAttribBinding (). <br><br><h1>  5. Sets of primitive geometry </h1><br>  The next step after determining the arrays of the vertex attributes is a description of how the vertex data will be rendered.  The virtual class osg :: PrimitiveSet is used to control the geometric primitives generated by the render from a set of vertices.  The osg :: Geometry class provides several methods for working with sets of geometry primitives: <br><br><ul><li>  addPrimitiveSet () - passes a pointer to a set of primitives to the object osg :: Geometry. <br></li><li>  removePrimitiveSet () - remove a set of primitives.  As parameters it takes the initial index of the sets and the number of sets to be deleted. <br></li><li>  getPrimitiveSet () - returns a set of primitives by the index passed as a parameter. <br></li><li>  getNumPrimitiveSets () - returns the total number of primitive sets associated with this geometry. <br></li></ul><br>  The osg :: PrimitiveSet class is abstract and not instantiated, but several derived classes inherit from it, encapsulating sets of primitives that OpenGL operates on, such as osg :: DrawArrays and osg :: DrawElementsUInt. <br><br>  The osg :: DrawArrays class uses several consecutive elements of an array of vertices to construct a geometric primitive.  It can be created and attached to the geometry by calling the method. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  The first parameter specifies the type of the primitive mode, similar to the corresponding OpenGL primitive types: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS and GL_POLYGON. <br><br>  The first and second parameters specify the first index in the array of vertices and the number of vertices from which the geometry should be generated.  <strong>Moreover, OSG does not check whether the specified number of vertices is enough to build the geometry specified by the mode, which can lead to application crash!</strong> <br><br><h1>  6. Example - draw a colored square. </h1><br>  We implement all of the above as a simple example. <br><br><div class="spoiler">  <b class="spoiler_title">Full quad source code</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  After compiling and running, we‚Äôll get a result like this. <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  This example needs clarification.  So, first of all we create an array of vertices of the square in which their coordinates are stored. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Next, set the array of normals.  In our simple case, we do not need to create a normal for each vertex; it suffices to describe one unit vector that is perpendicular to the plane of the square. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Set a color for each of the vertices. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Now create a geometry object, where the description of our square will be stored, which will be rendered.  Pass an array of vertices to this geometry. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Transmitting an array of normals, we inform the engine that a single normal will be used for all vertices, indicating the method of linking ("binding") the normals BIND_OVAERALL <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  By passing the colors of the vertices, on the contrary, we indicate that each vertex will have its own color <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Now we create a set of primitives for geometry.  We indicate that square (GL_QUADS) faces should be generated from the array of vertices, taking the vertex with index 0 as the first vertex, and the total number of vertices will be 4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Well, the transfer of geometry and the launch of the render explain, I think you should not <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  The code above is equivalent to the following construct on pure OpenGL. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Indexing vertices in primitives </h1><br>  The osg :: DrawArrays class works well when reading vertex data directly from arrays, without gaps.  However, it is not so effective when the same vertex can belong to several faces of an object.  Consider an example <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  The cube has eight vertices.  However, as can be seen from the figure (we are looking at sweeping a cube onto a plane), some vertices belong to more than one face.  If we build a cube of 12 triangular faces, then these vertices will be repeated, and instead of an array of 8 vertices, we will get an array of 36 vertices, most of which are in fact the same vertex! <br><br>  In OSG, there are classes osg :: DrawElementsUInt, osg :: DrawElementsUByte and osg :: DrawElementsUShort, which use arrays of vertex indices as data, designed to solve the described problem.  Arrays of indices store the indexes of the vertices of the primitives that describe the faces and other elements of the geometry.  When applying these classes to a cube, it is sufficient to store an array of eight vertices, which are associated with faces through arrays of indices. <br><br>  Classes of the osg :: DrawElements * type are designed in the same way as the standard std :: vector class.  This code can be used to add indexes. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  This code defines the front face of the cube shown in the figure. <br><br>  Consider another significant example - the octahedron <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  It is interesting because it contains only six vertices, but each vertex is already in four triangular faces!  We can create an array of 24 vertices to display all eight faces using osg :: DrawArrays.  However, we will act differently - we will store vertices in an array of six elements, and generate faces using the class osg :: DrawElementsUInt. <br><br><div class="spoiler">  <b class="spoiler_title">Full source code of the octahedron example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Let's sort this code in more detail.  Of course, first of all, we create an array of six vertices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  We initialize each vertex directly, addressing the vector of its coordinates using the pointer dereference operation and operator [] operator (we remember that osg :: Array is similar in its std :: vector device). <br><br>  Now create the faces as a list of vertex indices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Faces will be triangular, there will be 8 of them, which means the list of indices should contain 24 elements.  Face indices go in this array sequentially: for example, face 0 is formed by vertices 0, 1 and 2;  face 1 - vertices 0, 4 and 1;  face 2 - vertices 4, 5 and 1, and so on.  Vertices are listed in the order of counterclockwise, if you look at the front side of the face (see the figure above). <br><br>  Further steps to create the geometry we performed in the previous examples.  The only thing we did not do was the automatic generation of smoothed (averaged) normals, which we perform in this example by calling <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  Indeed, if the vertices of the face are given, then it is easy to calculate the normal to it.  At the vertices in which several faces converge, a certain average normal is calculated - the normals of converging faces are added up and the resulting sum is normalized again.  These operations (and much more!) Can be performed by the engine itself using classes from the osgUtil library.  Therefore, in our example, in the * .pro file we will add an indication to the linker to build our program with this library. <br><br>  <strong><a href="http://octahedron.pro/">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  As a result, we get the following result <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  To understand how this works, consider the OpenGL pipeline. <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  The vertex array mechanism reduces the number of OpenGL calls.  It stores vertex data in the memory of the application that is used on the client side.  The server-side OpenGL pipeline accesses various vertex arrays.  As shown in the diagram, OpenGL retrieves data from the vertex buffer on the client side and, in an orderly manner, assembles the primitives.  This is how data is processed using the set * Array () methods of the osg :: Geometry class.  The osg :: DrawArrays class traverses these arrays directly and displays them. <br><br>  When using osg :: DrawElements *, the dimension of arrays of vertices is reduced and the number of vertices passed to the pipeline is reduced.  An array of indices allows you to create a vertex cache on the server side.  OpenGL reads the vertex data from the cache, instead of reading from the vertex buffer on the client side.  This significantly increases the overall rendering performance. <br><br><h1>  8. Polygonal mesh processing techniques </h1><br>  OpenSceneGraph supports various techniques for processing a polygonal mesh of scene geometry objects.  These preprocessing methods, such as polygon reduction and tessellation, are often used to create and optimize polygonal models.  They have a simple interface, but in the process they do a lot of complex calculations and are not very suitable for execution on the fly. <br><br>  These techniques include: <br><br><ol><li>  osgUtil :: Simplifier - reducing the number of triangles in geometry.  The public method simplify () is used to simplify the geometry of models. <br></li><li>  osgUtil :: SmootingVisitor - calculation of normals.  The smooth () method can be used to generate smoothed normals for the model, instead of their self-calculation and explicit assignment through an array of normals. <br></li><li>  osgUtil :: TangentSpaceGenerator - generation of tangent basis vectors for model vertices.  It is launched by calling the generate () method and stores the result returned by the getTangentArray (), getNormalArray () and getBinormalArray () methods.  These results can be used for various vertex attributes when writing shaders on the GLSL. <br></li><li>  osgUtil :: Tesselator - performs tessellation of a polygonal mesh - splitting complex primitives into a sequence of simple (retesselatePolygons () method) <br></li><li>  osgUtil :: TriStripVisitor - converts a geometric surface into a set of strips of triangular faces, which allows rendering with effective memory consumption.  The stripify () method converts a set of model primitives into a geometry based on the GL_TRIANGLE_STRIP set. <br></li></ol><br>  All methods accept object geometry as a parameter, passed by reference osg :: Geometry &amp;, for example: <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  where geom is an instance of a geometry, described by a smart pointer. <br><br>  The classes osg :: Simplifier, osg :: SmoothingVisitor and osg :: TriStripVisitor can work directly with the nodes of the scene graph, for example <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  The accept () method processes all the child nodes until the specified operation is applied to all end nodes of this part of the scene tree stored in nodes like osg :: Geode. <br><br>  Let's try to practice the tessellation technique. <br><br><div class="spoiler">  <b class="spoiler_title">Full tesselator sample code</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Based on the spatial position of the vertices in this example, it is clear that we are trying to create a non-convex polygon of eight vertices using the generation of one face of type GL_POLYGON.  Building and executing this example shows that the result we expect does not work ‚Äî the example is displayed incorrectly. <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  To correct this problem, the constructed geometry should be tessellated before transmitting it to the viewer. <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  after which we get the correct result <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  How it works?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A non-convex polygon, without the use of a correct tessellation, will not be displayed as we expect, since OpenGL, seeking to optimize performance, will consider it as a simple, convex polygon or simply ignore, which may give completely unexpected results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The class osgUtil :: Tessellator uses algorithms to transform a convex polygon into a series of non-convex - in our case, it transforms the geometry into GL_TRIANGLE_STRIP. </font></font><br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This class can handle hole polygons and self-intersecting polygons. Through the public setWindingType () method, you can define various processing rules, such as GLU_TESS_WINDING_ODD or GLU_TESS_WINDING_NONZERO, which define the inside and outside areas of a complex polygon.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, we got a basic understanding of how the geometry of three-dimensional objects is stored and processed in the OSG engine. </font><font style="vertical-align: inherit;">Do not think that those simple and not very impressive examples that are considered in the article - the limit of the engine. </font><font style="vertical-align: inherit;">Simply, these examples can help the developer to understand the mechanics of OpenSceneGraph, and without this understanding it is difficult to imagine the work of more complex things. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article is based on the translation and processing of the text of the corresponding chapters of the book </font></font><a href="https://www.amazon.com/OpenSceneGraph-3-0-Beginners-Rui-Wang/dp/1849512825"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Beginner's Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All examples are checked by me personally, and their source is </font></font><a href="https://github.com/maisvendoo/OSG-lessons"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">available here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://habr.com/post/430242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To be continued...</font></font></a></i> </div><p>Source: <a href="https://habr.com/ru/post/430212/">https://habr.com/ru/post/430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430202/index.html">Writing a system of pairwise interacting particles in C ++ using DirectX 11</a></li>
<li><a href="../430204/index.html">MIT course "Computer Systems Security". Lecture 18: "Private Internet Browsing", part 1</a></li>
<li><a href="../430206/index.html">MIT course "Computer Systems Security". Lecture 18: "Private Internet Browsing", part 2</a></li>
<li><a href="../430208/index.html">MIT course "Computer Systems Security". Lecture 18: "Private Internet Browsing", part 3</a></li>
<li><a href="../430210/index.html">Puzzle "Test My Patience" by Check Point Security Academy</a></li>
<li><a href="../430216/index.html">As I understood that I eat a lot of sweets, or the classification of goods by checks in the application</a></li>
<li><a href="../430218/index.html">Energy Optimization STM32: A Practical Guide</a></li>
<li><a href="../430220/index.html">How to turn a "hundred" usb hub into a "smart" managed and save at the same time $ 300</a></li>
<li><a href="../430222/index.html">Senior Engineer in search of work. How I passed 20 interviews with HR and what I think about it</a></li>
<li><a href="../430224/index.html">Schizotypal Disorder: An Inside Look</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>