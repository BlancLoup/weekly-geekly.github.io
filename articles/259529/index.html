<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real Associative Arrays in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The use of an object literal as a simple means of storing key-value pairs has long been commonplace in JavaScript. However, the object literal is not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real Associative Arrays in JavaScript</h1><div class="post__text post__text-html js-mediator-article">  The use of an object literal as a simple means of storing key-value pairs has long been commonplace in JavaScript.  However, the object literal is not a true associative array, and therefore, in some situations, its use can lead to unexpected results.  While JS does not provide a native implementation of associative arrays (not in all browsers, at least), there is an excellent alternative to objects with the necessary functionality and without pitfalls. <br><a name="habracut"></a><br><h3>  Problem with objects </h3><br>  The problem lies in the chain of prototypes.  Any new object inherits properties and methods from Object.prototype, which can prevent us from uniquely determining the existence of a key.  Take for example the <code>toString</code> method, checking for the presence of a key with the same name using the <code>in</code> operator will lead to a false positive result: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; <span class="hljs-string"><span class="hljs-string">'toString'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  This happens because the <code>in</code> operator, not finding a property in an object instance, looks further along the chain of prototypes in search of inherited values.  In our case, this is the <code>toString</code> method.  To solve this problem, there is a method <code>hasOwnProperty</code> , which was designed specifically to check the presence of properties only in the current object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; map.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'toString'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre><br>  This technique works fine as long as you don‚Äôt hit the key named hasOwnProperty.  Overwriting this method will result in its subsequent calls leading to unpredictable results or errors, depending on the new value: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; map.hasOwnProperty = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; map.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'hasOwnProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// TypeError</span></span></code> </pre><br>  We quickly fix this problem.  To do this, use another, intact object and call its <code>hasOwnProperty</code> method in the context of our object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; map.hasOwnProperty = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; {}.hasOwnProperty.call(map, <span class="hljs-string"><span class="hljs-string">'hasOwnproperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  Here, this method already works without problems, but still it imposes some restrictions on how we will use it.  For example, every time you want to list the properties of your object with <code>for ... in</code> , you have to filter out all the inherited stuff: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> has = {}.hasOwnProperty; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(has.call(map, key)){ <span class="hljs-comment"><span class="hljs-comment">// do something } }</span></span></code> </pre><br>  After some time, this method will tire you terribly.  Thank God there is a better option. <br><br><h3>  Bare objects </h3><br>  The secret to creating a pure associative array in getting rid of the prototype and all the baggage that he carries with him.  To accomplish this, we use the <code>Object.create</code> method <a href="http://www.ecma-international.org/ecma-262/5.1/">provided in ES5</a> .  The uniqueness of this method is that you can clearly define the prototype of a new object.  For example, create a normal object a little more clearly: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">//   : var obj = Object.create(Object.prototype);</span></span></code> </pre><br>  In addition to the fact that you can choose any prototype, the method also gives you the opportunity not to select the prototype at all, simply by passing <code>null</code> instead: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); map <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>; <span class="hljs-comment"><span class="hljs-comment">// false Object.prototype.isPrototypeOf(map); // false Object.getPrototypeOf(map); // null</span></span></code> </pre><br>  These bare objects (or dictionaries) are ideal for creating associative arrays, since the absence of <code>[[Prototype]]</code> removes the risk of stumbling upon name conflicts.  And even better!  After we have deprived the object of all inherited methods and properties, any attempts to use it for purposes other than its intended purpose (repository) will result in errors: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); map + <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span></span></code> </pre><br>  There is no primitive value or string representation.  Bare objects are only intended to work as a repository of key-value pairs and a period. <br><br>  Keep in mind that the <code>hasOwnProperty</code> method <code>hasOwnProperty</code> also no longer there, and it is not needed, since the <code>in</code> operator now works fine without any checks. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-string"><span class="hljs-string">'toString'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre><br>  Moreover, those tedious <code>for ... in</code> cycles are now much easier.  Finally, we can safely write them the way they should look like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map){ <span class="hljs-comment"><span class="hljs-comment">// do something }</span></span></code> </pre><br>  Despite the changes, we can still do everything we need with objects, such as using dot notation or square brackets, turning them into a string, or using an object as a context for any method from <code>Object.prototype</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(map, { <span class="hljs-string"><span class="hljs-string">'foo'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }); map.foo; <span class="hljs-comment"><span class="hljs-comment">// 1 map['bar']; // 2 JSON.stringify(map); // {"foo":1} {}.hasOwnProperty.call(map, 'foo'); // true {}.propertyIsEnumerable.call(map, 'bar'); // false</span></span></code> </pre><br>  Even the various types of type checking will still work: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> map; <span class="hljs-comment"><span class="hljs-comment">// object {}.toString.call(map); // [object Object] {}.valueOf.call(map); // Object {}</span></span></code> </pre><br>  All this makes it possible to easily replace the usual objects used to create associative arrays with bare objects, both in new and in any previously created applications. <br><br><h3>  Conclusion </h3><br>  If we talk about simple storages of key-value pairs, then bare objects will cope with this task unambiguously better than ordinary objects, saving the developer from all that is superfluous.  For more functional data structures, we will have to wait for ES6 (ES2015), which will provide us with native associative arrays in the form of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set,</a> and other objects.  In the meantime, this rainbow moment has not arrived, bare objects are the best choice. </div><p>Source: <a href="https://habr.com/ru/post/259529/">https://habr.com/ru/post/259529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259517/index.html">How to programmer to make money on the stock market, thinking only about the code: StockSharp and ITinvest competition</a></li>
<li><a href="../259519/index.html">Short note: 2 zabbix servers one client</a></li>
<li><a href="../259521/index.html">WPAD: instruction manual</a></li>
<li><a href="../259523/index.html">Why Doctrine ORM is Bad for PHP</a></li>
<li><a href="../259527/index.html">"Boss, write an application for us." Requires software developer and hardware for DJI drones</a></li>
<li><a href="../259531/index.html">What you need to know when migrating from MySQL to PostgreSQL?</a></li>
<li><a href="../259533/index.html">Automated QA System: a headache pill for testers using the Star Crusade game as an example</a></li>
<li><a href="../259535/index.html">The tale of a single mistake, never got into the release of the Linux kernel</a></li>
<li><a href="../259537/index.html">Equinix NY4 - Wall Street Data Center</a></li>
<li><a href="../259539/index.html">Scrollissimo - plugin for smooth scrolling animation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>