<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SoC: we raise simple DMA on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon! In the last article I described how to ‚Äúraise‚Äù SoC from Altrera from scratch . 
 We stopped at measuring the bandwidth between the CPU...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SoC: we raise simple DMA on FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c97/609/a2a/c97609a2af92412d907c555b8eb45655.jpg"><br><br>  Good afternoon!  In the <a href="http://habrahabr.ru/post/235707/">last article</a> I described how to ‚Äúraise‚Äù <b>SoC</b> from <b>Altrera</b> from <b>scratch</b> . <br>  We stopped at measuring the bandwidth between the <b>CPU</b> and the <b>FPGA</b> when copying is done by the processor. <br><br>  This time we will go a little further and implement a primitive <b>DMA</b> in FPGA. <br>  Who cares - welcome under cat. <br><a name="habracut"></a><br><h3>  Iron used </h3><br>  Last time we used the <b>SoCrates</b> fee from <b>EBV</b> . <br>  This time I will use <a href="http://metrotek.spb.ru/ethond.html">our own development board</a> - it is this one that is represented in the photo. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main difference is in our motherboard 2 <b>Gigabit Ethernet</b> interfaces and they are not installed on the CPU, but on the FPGA. <br>  This allows very flexible traffic handling.  Plus, the connectors displayed a large number of pins. <br><br>  But these differences will become fundamental for us only in the following articles. <br>  In one we will implement <b>NIC</b> in FPGA - for this, of course, we will use gigabit interfaces.  In the other we will write support for the framebuffer for the <b>ILI9341</b> display, again, in the FPGA - this will require an expansion card. <br><br>  And to perform the actions described below, any board with <b>SoC Cyclone V</b> <br><br><h3>  Source </h3><br>  In the course of the article I will give only important pieces of code with explanations. <br>  The whole source code can be viewed on <a href="http://github.com/Des333/soc-fpga2sdram-test">github</a> <br><br><h3>  Detailing </h3><br>  Details of building the kernel, getting the bootloader and other actions described in the <a href="http://habrahabr.ru/post/235707/">last article</a> , I will not give. <br><br>  A note about the kernel - it is better to use a more recent kernel version 3.18 from here: <br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.rocketboards.org/linux-socfpga.git git checkout remotes/origin/socfpga-3.18</code> </pre> <br><h3>  We think about the implementation </h3><br><h4>  Choosing a DMA Controller </h4><br>  So, our goal is to transfer data from the FPGA to the processor and / or back with the maximum bandwidth and minimum CPU load. <br>  The copying option by the processor immediately disappears, you need to use DMA.  But who can fulfill the role of a DMA controller? <br>  For our SoC, there are two options - either FPGA or <b>DMA-330</b> controller built into the <b>HPS</b> . <br><br>  Judging by the discussions on the network, the DMA-330 is not very productive, and the corresponding driver may not even be fully functional. <br>  Maybe someday we will try to revive the DMA-330, but now our choice is FPGA <br><br><h4>  Interface selection </h4><br>  To perform the functions of a DMA controller, the FPGA must be a master.  This is possible to implement on one of two interfaces: <br><ul><li>  FPGA-to-HPS ( <b>fpga2hps</b> ) </li><li>  FPGA-to-HPS SDRAM ( <b>fpga2sdram</b> ) </li></ul><br><br>  Block diagram of the HPS components and the interfaces between them: <br><div class="spoiler">  <b class="spoiler_title">HPS architecture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/32a/ac1/59a/32aac159aff84de6b89ff6005adb909e.png"></div></div><br><br>  Let's see what the advantages and disadvantages of each option. <br><br>  <b>fpga2hps</b> allows wizards in FPGA to access almost all of the slaves in the system.  That is, not only as a memory, but also to a diverse periphery. <br><br>  <b>fpga2sdram</b> allows FPGA to work with DDR-memory, "owned" HPS.  In this case, access is limited to RAM only. <br><br>  <b>fpga2sdram</b> allows you to get more bandwidth. <br><br>  When using <b>fpga2hps</b> exchange occurs through a single interface.  If the FPGA requires multiple masters, then arbitration is required.  So you need to either write your own modules, or use those generated with Qsys, and they are quite resource-intensive. <br>  On the other hand, in <b>fpga2sdram</b> you can create up to 6 independent ports, and all issues with arbitration will be decided by the DDR controller. <br>  <b>Attention: the</b> number 6 is not quite ‚Äúfair‚Äù - 6 command ports are available, 4 ports for writing and 4 ports for reading. <br>  In this case, one 128-bit interface requires the use of the 1st command port, 2 ports for writing and 2 ports for reading. <br><br>  Both fpga2hps and fpga2sdram must be initialized to write to the appropriate registers before use.  Unfortunately, for <b>fpga2sdram</b> this needs to be done after the FPGA firmware, but at the moment when no transactions on the interface occur.  In fact, when using <b>Linux</b> , this means that you need to flash FPGAs in the U-boot.  Details can be read <a href="https://support.criticallink.com/redmine/projects/mityarm-5cs/wiki/Important_Note_about_FPGAHPS_SDRAM_Bridge">here</a> . <br><br>  When working with <b>fpga2hps, the</b> master in FPGA must use the byte address; when working with <b>fpga2sdram</b> , the address of the word. <br><br>  More information can be found in the <a href="https://www.altera.com/products/fpga/cyclone-series/cyclone-v/support.html">Cyclone V Device Handbook Volume 3: Hard Processor System Technical Reference Manual</a> . <br>  Chapters 8 <b>HPS-FPGA Bridges</b> and 11 <b>SDRAM Controller Subsystem</b> . <br><br>  For our task there is no fundamental difference what to use.  Let's select <b>fpga2sdram</b> in the hope of getting more bandwidth. <br><br><h4>  Choice of implementation of the DMA controller </h4><br>  We have decided that we will implement the DMA controller in the FPGA and with what interface it will work. <br>  But how are we going to do the controller itself?  You can use one of the open "crusts", for example <a href="http://www.alterawiki.com/wiki/Modular_SGDMA">, this one</a> , which is also available through Qsys. <br><br>  This is a good DMA controller, which has many useful features.  We will return to it when we implement our <b>NIC</b> . <br>  But now for our task such a controller is an unnecessary functionality and excessive complexity. <br>  For the learning task, it is much better to sketch a couple of counters in the FPGA, in order to realize that the essence of the DMA controller is very simple. <br><br><h4>  Upper level </h4><br>  From the software side, everything is also quite simple - we need a driver that will allocate memory, get the bus address of this memory, configure and run the DMA controller in the FPGA, wait for the transaction to complete, and receive data. <br><br>  And we will write it.  But we will start not with the driver, but with a slightly strange program in the <b>userspace</b> , which will perform the same functions. <br>  This will allow us to work with DMA controllers in FPGAs without having to write something at the kernel level. <br>  For ‚Äúproduction‚Äù, such solutions are usually not used, but for debugging it is sometimes convenient. <br><br>  For simplicity, the firmware in the FPGA will transfer data in the direction of FPGA -&gt; CPU. <br>  Data transmission in the opposite direction is almost completely similar, with the exception of one nuance, which will be discussed below. <br>  With the direction of CPU -&gt; FPGA, we will work when implementing a framebuffer for <b>LCD</b> . <br><br>  So the plan: <br><ul><li>  <b>FPGA</b> Firmware </li><li>  Program in userspace </li><li>  Kernel driver </li></ul><br><h3>  FPGA firmware implementation </h3><br>  Let's start with our beloved Qsys.  We need three IP peels: <br><ul><li>  Processors and Peripherals -&gt; Hard Processor Systems -&gt; Arria V / Cyclone V Hard Processor System </li><li>  Basic Functions -&gt; Bridges and Adapters -&gt; Memory Mapped -&gt; Avalon-MM Pipeline Bridge </li><li>  Basic Functions -&gt; Bridges and Adapters -&gt; Clock -&gt; Clock Bridge </li></ul><br>  For HPS, we leave it almost the same as in the previous article. <br>  On the <b>FPGA Interfaces</b> tab, you need to add the <b>FPGA-to-HPS SDRAM</b> interface. <br>  Choose type <b>Avalon-MM Bidirectional</b> , width - 128 bits. <br><br>  You also need to check the box next to <b>Enable FPGA-to-HPS Interrupts</b> . <br>  This will allow our DMA controller to ‚Äúinform‚Äù the CPU of the completion of a transaction through an interrupt. <br><br>  Also, the width of the <b>HPS-to-FPGA</b> interface must be set to 64 bits.  This is the interface through which the CPU will configure the DMA controller. <br>  Its width can be any, we set 64 bits simply because I had chosen such a width, and the source code, described below, is set to this value. <br><br>  This is what should happen: <br><div class="spoiler">  <b class="spoiler_title">FPGA Interfaces</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/937/4cb/23e/9374cb23e9ae49f382c625953d6db1b8.png"></div></div><br>  Go to <b>Avalon-MM Bridge</b> . <br>  This peel will act as a converter.  We need to export the <b>HPS-to-FPGA</b> from the auto-generated Qsys module to the outside. <br>  But if we just do this, we get the <b>AXI</b> interface, which is much more complicated than <b>Avalon-MM</b> .  And we don‚Äôt want to work with them at all.  After adding this module, Qsys automatically converts AXI to Avalon.  It will take some resources, but it will be much more convenient to work. <br><br>  You need to configure the module as follows: <br><div class="spoiler">  <b class="spoiler_title">Avalon-MM Bridge</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9db/ee1/be8/9dbee1be8ae649368620d05c79143b3a.png"></div></div><br>  Go to the last module.  It is needed so that we can export the shred from the HPS to the outside and synchronize the DMA controller over this shred.  Its setup is primitive - you just need to specify the number of clocks equal to 1. <br><br>  After that you need to connect all our modules (note the names in the <b>Export</b> column): <br><div class="spoiler">  <b class="spoiler_title">Qsys Connections</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/930/af7/4ca/930af74ca05341a5b06b07ecd3414b8c.png"></div></div><br>  It remains to save and generate files. <br><br>  The time has come to implement our primitive DMA controller.  How are we going to customize it? <br>  To configure, we will use the so-called Control and Status Registers (Control and Status Register, <b>CSR</b> ) <br>  These are fixed-size blocks that are read / write (control) or read-only (status) CPUs available. <br><br>  Access to these registers will be via <b>HPS-to-FPGA</b> . <br>  Since the interface is 64 bits wide, you can either make registers of the same width or add a converter. <br>  Making registers 64-bit is very expensive.  Indeed, very often in the whole register only a few bits are used. <br>  It is better to make the registers 16-bit, and if it becomes necessary to have a word of high resolution use 2 or 4 adjacent registers. <br><br>  Theoretically, it was possible to use a converter generated by Qsys, specifying a 16-bit width for the <b>Avalon-MM Bridge</b> peel, but in practice this could not be done - Qsys generated a non-working module.  No problem, we will use our own :) <br><br>  The <a href="">avalon_width_adapter.sv</a> module is used as a converter, and the registers themselves are implemented in the <a href="">regfile_with_be.v</a> module <a href="">.</a> <br><br>  The logic of the register module is extremely simple - depending on the address, we put the contents of the necessary register on the bus read data.  If the recording signal also came, then we save the input data in the register.  The address specifies the register number, not the byte number.  The method of dividing into control and status registers is set by the parameter during assembly ‚Äî either by the high-order bit of the address (the address space in this case is divided equally between the control and status registers) or by the number of registers specified by the parameters. <br><br>  Go directly to the DMA-controller.  For simplicity, it is located in the <a href="">top module</a> . <br><br>  All that our DMA controller will consist of is three counters and a pair of signals. <br><br>  Let me remind you that the data our controller issues on the interface <b>Avalon-MM</b> .  A detailed description can be found <a href="https://www.altera.com/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf">here</a> , but in general it is a fairly simple interface. <br>  In order to record the data, you need to set the following signals: <br><ul><li>  <b>sdram0_address</b> is an address (I remind you that for <b>fpga2sdram</b> this should be the address of a word). </li><li>  <b>sdram0_writedata</b> - data to write. </li><li>  <b>sdram0_byteenable</b> - a signal indicating which bytes from the data to write.  For simplicity, we set it equal to <b>16'hFFFF</b> . </li><li>  <b>sdram0_burstcount</b> - signal to control the burst.  Again, for simplicity, we set it equal to 1. </li><li>  <b>sdram0_write</b> - this signal must be set to 1 to execute a write transaction </li></ul><br><br>  The only caveat to remember is the presence of the <b>sdram0_waitrequest</b> signal.  If it is equal to 1, this means that the slave cannot process the transaction at the moment and the master must leave all its signals unchanged.  Exactly how often the <b>sdram0_waitrequest</b> signal will be set to 1 and will ultimately determine the throughput of our DMA. <br><br>  So, we describe the used counters.  The first is the address counter, <b>addr_cnt</b> .  When a DMA transaction starts, it is set to the address specified by the CPU.  After each successful transaction (when <b>sdram0_waitrequest is</b> not equal to 1), this counter is incremented by 1. <br><br>  The second is a <b>data_cnt</b> counter for data emulation.  You can write to the data whatever you want.  The main condition is that after the completion of a transaction, the software must read out the same data from the memory that was recorded.  Therefore, recording a simple counter is not very correct - there will be a lot of zeros in the data and it will be difficult to check the validity of the record.  It would be ideal to write a pseudo-random sequence, but for simplicity, the counter and its inverted value will suffice. <br><br>  The third counter, the <b>cycle</b> counter, <b>cycle_cnt</b> , will be reset to 0 when the DMA transaction <b>starts</b> and further increases by 1 in each clock cycle. <br>  It is needed so that we can find out how many clocks our DMA transaction took and calculate the bandwidth. <br><br>  So for counters, we get the following code: <br><div class="spoiler">  <b class="spoiler_title">Description of counters</b> <div class="spoiler_text"><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">For</span></span> emulate <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> logic [63:0] data_cnt; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Current</span></span></span><span class="hljs-class"> address on </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SDRAM</span></span></span><span class="hljs-class"> iface logic [31:0] addr_cnt; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Overall</span></span></span><span class="hljs-class"> cycles count. logic [31:0] cycle_cnt; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Form</span></span></span><span class="hljs-class"> pseudo-</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> always_ff @( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">posedge</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk_w</span></span></span><span class="hljs-class"> ) if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_is_running</span></span></span><span class="hljs-class"> ) data_cnt &lt;= '0; else if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sdram0_waitrequest</span></span></span><span class="hljs-class"> ) if( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data_cnt</span></span></span><span class="hljs-class"> != ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dma_data_size</span></span></span><span class="hljs-class"> - 1 ) ) data_cnt &lt;= data_cnt + 1; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Increase</span></span></span><span class="hljs-class"> address if no waitrequest always_ff @( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">posedge</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk_w</span></span></span><span class="hljs-class"> ) if( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_test_stb</span></span></span><span class="hljs-class"> ) addr_cnt &lt;= dma_addr; else if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sdram0_waitrequest</span></span></span><span class="hljs-class"> ) addr_cnt &lt;= addr_cnt + 1; always_ff @( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">posedge</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk_w</span></span></span><span class="hljs-class"> ) if( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_is_running_stb</span></span></span><span class="hljs-class"> ) cycle_cnt &lt;= '0; else if( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_is_running</span></span></span><span class="hljs-class"> ) cycle_cnt &lt;= cycle_cnt + 1;</span></span></code> </pre><br></div></div><br>  Let's go back to the signals.  We only need: <br><ul><li>  <b>test_is_running</b> - a signal indicating whether a DMA transaction is in progress. </li><li>  <b>run_test_stb</b> - strobe signal, active for 1 clock cycle at the moment when the CPU starts the DMA controller </li><li>  <b>test_finished</b> - a signal indicating that the required amount of data has been recorded.  Also start up the interrupt. </li></ul><br>  The formation of these signals is trivial. <br><br>  What do we need to configure the DMA controller (these will be our control registers)? <br><ul><li>  Buffer address where to copy data </li><li>  Record size </li><li>  The signal to start a transaction, from which we then select the front </li></ul><br>  Status registers will be: <br><ul><li>  DMA controller busy signal </li><li>  Counter value <b>cycle_cnt</b> </li></ul><br>  So here‚Äôs our register ad: <br><div class="spoiler">  <b class="spoiler_title">Register declaration</b> <div class="spoiler_text"><pre> <code class="hljs perl">// Control registers <span class="hljs-string"><span class="hljs-string">`define DMA_CTRL_CR 0 `</span></span>define DMA_CTRL_CR_RUN_STB <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">`define DMA_ADDR_CR0 1 `</span></span>define DMA_ADDR_CR1 <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">`define DMA_SIZE_CR0 3 `</span></span>define DMA_SIZE_CR1 <span class="hljs-number"><span class="hljs-number">4</span></span> // Status registers <span class="hljs-string"><span class="hljs-string">`define DMA_STAT_SR 0 `</span></span>define DMA_STAT_SR_BUSY <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">`define DMA_CYCLE_CNT_SR0 1 `</span></span>define DMA_CYCLE_CNT_SR1 <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br></div></div><br>  And here is the purpose of the registers: <br><div class="spoiler">  <b class="spoiler_title">Register Assignment</b> <div class="spoiler_text"><pre> <code class="hljs markdown">// Control from CPU -- bit for start, DMA buffer address and transaction size. assign run<span class="hljs-emphasis"><span class="hljs-emphasis">_test = cregs_</span></span>w[<span class="hljs-string"><span class="hljs-string">`DMA_CTRL_CR</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">`DMA_CTRL_CR_RUN_STB</span></span>]; assign dma<span class="hljs-emphasis"><span class="hljs-emphasis">_addr = { cregs_</span></span>w[<span class="hljs-string"><span class="hljs-string">`DMA_ADDR_CR1</span></span>], cregs<span class="hljs-emphasis"><span class="hljs-emphasis">_w[`DMA_</span></span>ADDR<span class="hljs-emphasis"><span class="hljs-emphasis">_CR0] }; assign dma_</span></span>data<span class="hljs-emphasis"><span class="hljs-emphasis">_size = { cregs_</span></span>w[<span class="hljs-string"><span class="hljs-string">`DMA_SIZE_CR1</span></span>], cregs<span class="hljs-emphasis"><span class="hljs-emphasis">_w[`DMA_</span></span>SIZE<span class="hljs-emphasis"><span class="hljs-emphasis">_CR0] }; // Status for CPU -- current state and overall cycles count. assign sregs_</span></span>w[<span class="hljs-string"><span class="hljs-string">`DMA_STAT_SR</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">`DMA_STAT_SR_BUSY</span></span>] = test<span class="hljs-emphasis"><span class="hljs-emphasis">_is_</span></span>running; assign { sregs<span class="hljs-emphasis"><span class="hljs-emphasis">_w[`DMA_</span></span>CYCLE<span class="hljs-emphasis"><span class="hljs-emphasis">_CNT_</span></span>SR1], sregs<span class="hljs-emphasis"><span class="hljs-emphasis">_w[`DMA_</span></span>CYCLE<span class="hljs-emphasis"><span class="hljs-emphasis">_CNT_</span></span>SR0] } = cycle_cnt;</code> </pre><br></div></div><br>  Everything, it is possible to compile the project.  First, let's do <b>Analysis &amp; Synthesis</b> . <br><br>  After that we will create the <b>SignalTap</b> file - with its help we will be able to watch the values ‚Äã‚Äãof the signals inside the <b>FPGA</b> <br>  To do this, go to <b>File -&gt; New -&gt; SignalTap II Logic Analyzer File</b> and click OK. <br>  In the window that appears, you need to add the necessary signals.  It should turn out something like: <br><div class="spoiler">  <b class="spoiler_title">SignalTap File</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4af/64b/17e/4af64b17e9a14b138a461e6877a4fac4.png"></div></div><br>  Save the file, add it to the project and perform a complete assembly. <br><br>  After the end of the build, we need to get the <b>.rbf</b> file: <br><pre> <code class="bash hljs">quartus_cpf -c etln.sof dma.rbf</code> </pre> <br>  Everything, the firmware is ready.  Go to the software part. <br><br>  <b>Attention:</b> remember that after changing the settings in Qsys (in particular after turning on <b>fpga2sdram</b> ), you need to regenerate and rebuild the <b>Preloader</b> . <br><br>  Also note that in the githaba for FPGA, only files with Verilog-code and a file with Qsys settings are laid out. <br>  Project files (.qpf, .qsf, etc.) are missing due to the fact that they do not carry any really useful information. <br><br><h3>  Implementation of the userspace program </h3><br>  What do we need in order to work with the DMA controller from the software side? <br><br>  First, we need to be able to configure and run a DMA controller.  For this we use the <a href="">mem</a> program from the previous article. <br><br>  Secondly, we need to get a memory area, the address of which we will be able to transfer to the DMA controller. <br><br>  Here you need a small digression.  Usually, all processes in userspace and even the majority in the kernel work with so-called <b>virtual</b> addresses.  But the DMA controller needs to pass the <b>physical</b> address (more precisely, the <b>bus</b> address, but for the platforms we use it is equal to the physical one) <br><br>  In the core for performing such tasks there is a set of special functions that allow you to get a physical (and vice versa) virtual address or allocate a memory area and get two addresses at once that point to it. <br><br>  What to do in <b>userspace</b> ?  We will be helped by a wonderful file <b>/ proc / [PID] / pagemap</b> , which contains information about the mapping of all virtual pages to physical for any process. <br><br>  Information for each page in this file is equal to 8 bytes.  At the same time, the lower 55 bits contain the so-called physical page number - Page Frame Number ( <b>PFN</b> ), and the higher 9 bits contain various flags (page presence, being in a swap, etc.). A detailed description can be found <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt">here</a> or in <b>man proc</b> <br><br>  Thus, knowing the virtual address and page size, it is easy to calculate the virtual page number.  After that, from the file <b>/ proc / [PID] / pagemap</b> you just need to read 8 bytes at the desired offset and in the lower 55 bits will be the number of the physical page.  And it is already easy to translate it into a physical address, which we will write to the DMA controller. <br><br>  If our memory area starts on the page border, then everything becomes a little easier. <br>  Therefore, instead of the <b>malloc ()</b> function, it is better to use the <b>posix_memalign ()</b> function, which allows you to set the desired offset. <br><br>  Also, in order to prevent unloading data from RAM to swap, it is advisable to use the mlock () function <br><br>  The things described above are performed by the <a href="">phys_addr.c</a> program <a href="">.</a> <br><br>  <b>Important note</b> - pages adjacent to a virtual address space will not necessarily be contiguous in RAM. <br>  Therefore, in this method, we cannot write data with a DMA controller that is larger than the page size. <br>  We can get around this limitation when we write the driver. <br><br><h3>  Interim check </h3><br>  So, the firmware and test program are ready, time to test them a bit. <br><br>  Copy the binaries to the SD-card, connect the <b>USB-Blaster</b> and run our board. <br><br>  I wrote above that you need to enable the <b>fpga2sdram</b> interface before booting <b>Linux</b> .  This is true, but not always. <br>  If you turn on the interface already in Linux and try to read data from the FPGA in memory, the system will completely freeze. <br>  But write the data work.  Naturally, this option is clearly not to be used on the combat system and below I will write how to correctly initialize the <b>fpga2sdram</b> interface.  But for intermediate testing, this is fine for us. <br><br>  To get started, flash the FPGA: <br><pre> <code class="bash hljs">cat dma.rbf &gt; /dev/fpga0</code> </pre> <br>  Now enable the <b>HPS-to-FPGA</b> interface: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 &gt; /sys/class/fpga-bridge/hps2fpga/<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span></code> </pre> <br>  If we start <b>SignalTap now</b> , we will see that the <b>sdram0_waitrequest</b> signal constantly hangs at 1. This is due to the fact that the <b>fpga2sdram</b> interface <b>is</b> turned off. <br><br>  Turn it on: <br><pre> <code class="bash hljs">./mem.o 0xFFC25080 0x3fff</code> </pre> <br>  Writing units to the register bits <b>0xFFC25080</b> includes the corresponding ports of the <b>fpga2sdram</b> interface.  A description of which bits for which ports are responsible is given in the above <b>Handbook</b> .  For simplicity, we just need to include all the ports (a total of 14 bits are used in the register). <br><br>  Now in <b>SignalTap, the sdram0_waitrequest</b> signal <b>has</b> become 0. <br><br>  Run the <b>phys_addr</b> utility: <br><pre> <code class="bash hljs">./phys_addr</code> </pre> <br>  It allocates a buffer and displays its physical address.  I have it <b>0x2d593000</b> . <br>  We remember that when using the <b>fpga2sdram</b> interface, <b>you</b> need to be addressed by words. <br>  Since the words are 128-bit, the address of the word is calculated as follows: <br><pre> <code class="bash hljs">0x2d593000 / 16 = 0x2d59300</code> </pre> <br>  We write this address in the FPGA registers: <br><pre> <code class="bash hljs">./mem.o 0xC0000002 0x2d59300</code> </pre> <br>  For the address we use control registers numbered 1 and 2. Each address is 16 bits or 2 bytes.  Since the HPS-to-FPGA begins with the address <b>0xC0000000</b> , the first control register in the first control register will be <b>0xC0000002</b> <br>  Let me remind you that the <b>mem.c</b> utility uses exactly byte addresses. <br><br>  After that, we write the length of the DMA transaction in control register number 3. The length should not exceed the page size, and for us it is 4096 bytes.  Since our <b>fpga2sdram</b> interface is 128 bits wide, and we specify the size of the transaction in words, we have to write the number 256 in the third register: <br><pre> <code class="bash hljs">./mem.o 0xC0000006 256</code> </pre> <br><br>  Next, we configure <b>SignalTap</b> to capture on the negative edge of the <b>test_is_running</b> signal and run the DMA controller. <br>  To do this, write to the zero bit of the zero register first 0 (if it is not there), and then 1. At the same time, remember that the <b>mem.o</b> utility performs transactions of 4 bytes, and these are 2 of our registers.  Therefore, if we are not careful, we wipe the data in the neighboring register. <br><br>  So, we need to first read the data at <b>0xC0000000</b> , and then write them down, but with the zero bit set. <br><br>  We read: <br><pre> <code class="bash hljs">./mem.o 0xC0000000</code> </pre> <br>  I read <b>0x93000000</b> <br><br>  We write down: <br><pre> <code class="bash hljs">./mem.o 0xC0000000 0x93000001</code> </pre> <br>  After that, we should get something like this in <b>SignalTap</b> : <br><div class="spoiler">  <b class="spoiler_title">SignalTap Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f88/6bf/a01/f886bfa01a3646b188eefe94fad3ebec.png"></div></div><br>  As you can see, the value of the <b>cycle_cnt</b> counter at the time of the end of the transaction is 3167. <br>  Let's calculate the bandwidth.  The frequency of the clock signal in my project is 150 MHz (to be able to change the frequency over a wider range, I do not use the clock from HPS, but import it there, I took it with the PLL. These changes are trivial, but they are not in the github). <br>  Width - 128 bits.  For 3167 cycles, 256 words were transmitted.  Total: <br><pre> <code class="bash hljs">128 * 150 / (3167/256) = 1551 /c</code> </pre> <br>  <b>UPDATE: Such a small bandwidth obtained due to a typo, details in the conclusions.</b> <br><br>  It remains to make sure that the data is recorded correctly.  ‚ÄúRemove‚Äù the <b>phys_addr</b> utility from a pause by pressing Enter. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We should see this text: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phys_addr execution result</font></font></b> <div class="spoiler_text"><pre> <code class="bash hljs">0: 0x0 1: 0xffffffffffffffff 2: 0x1 3: 0xfffffffffffffffe ... 507: 0xffffffffffffff02 508: 0xfe 509: 0xffffffffffffff01 510: 0xff 511: 0xffffffffffffff00</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you saw, then everything went well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having experimented with different parameters, I saw that the frequency of the clock signal has almost no effect on throughput. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains approximately the same as for 25 MHz, which is for 150 MHz. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the width of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fpga2sdram</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interface </font><font style="vertical-align: inherit;">, on the contrary, gives an almost linear relationship - tested at 64 and 128 bits. </font><font style="vertical-align: inherit;">For 256 did not check. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, due to the fact that the amount of recorded data is small (only 4096 bytes), the measurement error is quite large. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can increase the size of the DMA transaction by writing our primitive driver.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Driver writing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article came out a little more than I expected, so I‚Äôll tell you about the driver very briefly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especially because with him we still have to work in the following articles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the code is on a </font></font><a href="https://github.com/Des333/soc-fpga2sdram-test/tree/master/drv"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githaba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> who is interested - you can see the details. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic idea is simple - when launching the driver, we set the parameter what size of the transaction we need. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The driver allocates memory and writes the bus address and transaction size to the FPGA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The driver also registers an interrupt handler, which we specified in the FPGA firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After this, the driver creates two char devices:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / etn-ctrl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - to run a DMA transaction</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / etn-data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - to get data</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When reading from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / etn-ctrl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">, a DMA transaction starts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the call is blocked until the arrival of an interrupt from the FPGA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the interrupt arrives, the call ends. </font><font style="vertical-align: inherit;">This means that the data is written and can be read from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / etn-data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the driver to work in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file, add the following lines:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changes to .dts</font></font></b> <div class="spoiler_text"><pre> <code class="bash hljs">fpga { compatible = <span class="hljs-string"><span class="hljs-string">"mtk,etn"</span></span>; interrupts = &lt;0x0 0x28 0x1&gt;; };</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first line specifies a compatible driver, and the second line indicates the number and type of interrupt from the FPGA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using a transaction of 4MB in size, the bandwidth goes to about </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2000 Mbit / s</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20 Gbit / s (see UPFATE in Conclusions).</font></font><br><br><h3>  findings </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primitive DMA controller was written in the FPGA and its throughput was measured. </font></font><br><br> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was about 2 Gbit / s.</font></font></s> <br>  <b>UPDATE:</b> <b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The small bandwidth is due to a typo in the DDR3 settings. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namely, the fact that the PLL clock was set to 125 MHz, and not 25 MHz, as it really is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of this, the multiplier and divider coefficients for the PLL were calculated incorrectly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, DDR3 worked at 66 MHz instead of the 333 MHz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the correct coefficients and interface width of 256 bits, the bandwidth is about 16-17 Gbit / s, which corresponds to the theoretical for the DDR3 interface with a width of 32 bits and a frequency of 333 MHz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will describe in more detail in the next article. </font></font><br></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A further outline of the articles is this, if, of course, they are interesting to someone:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing the framebuffer for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in FPGA</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SGDMA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controller</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing a gigabit 2-port </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NIC</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in FPGA using an SGDMA controller</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thanks to those who got to the end! </font></font> Good luck. </div><p>Source: <a href="https://habr.com/ru/post/248145/">https://habr.com/ru/post/248145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248131/index.html">International isolation made Cuba an island of hackers</a></li>
<li><a href="../248133/index.html">Status + new hell of trolling on the Internet</a></li>
<li><a href="../248135/index.html">High DPI values ‚Äã‚Äãin Windows</a></li>
<li><a href="../248137/index.html">Annotation to "Effective Modern C ++" by Scott Myers</a></li>
<li><a href="../248139/index.html">IO.js or old rake with new sauce</a></li>
<li><a href="../248147/index.html">Tree - killer JSON, XML, YAML and their ilk</a></li>
<li><a href="../248149/index.html">2D lighting system for Unity3D running on a GPU</a></li>
<li><a href="../248153/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 1 of 6</a></li>
<li><a href="../248155/index.html">Sex-inspired startups: pros, cons, pitfalls</a></li>
<li><a href="../248157/index.html">Programming languages. Compositional view</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>