<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Calculate the average temperature at the hospital</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is worth starting with the fact that this article is absolutely not serious. New Year, a holiday, there are no forces to do something serious both ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Calculate the average temperature at the hospital</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/comment_images/caf/f57/dfc/caff57dfca0f0a3a7ad50d486d4b3531.png" alt="Statistics" align="left"><br>  It is worth starting with the fact that this article is absolutely not serious.  New Year, a holiday, there are no forces to do something serious both for writers and readers.  That is why it was decided to write an article about, suddenly, statistics. <br><a name="habracut"></a><br>  This article is indirectly related to one of the discussions in which we participated, regarding the possibility of some regularity in the occurrence of errors in certain places when copying code.  We very often refer to the article ‚Äú <a href="http://www.viva64.com/ru/b/0260/">Last line effect</a> ‚Äù - according to observations, in the same type obtained by copying and pasting lines of code, the error is most often found in the last of them.  The discussion concerned whether it was possible in some way to derive a certain regularity in the appearance of an error in other places of the same type of blocks.  Unfortunately, the examples are structured in such a way that it is rather difficult to collect any statistics regarding the occurrence of such errors.  However, it gave the idea to conduct a small statistical study on our database of examples. <br><br>  Let's say right away that this article will be a comic character, since we could not find any serious patterns.  Many people remember that " <a href="http://www.viva64.com/go.php%3Furl%3D1474">There are three types of lies: lies, blatant lies and statistics,</a> " therefore, they are often suspicious of any statistical research.  And rightly so, because the statistics, focused on the "crowd", is often used to look for patterns where there are none.  One of the most prominent examples is the " <a href="http://www.viva64.com/go.php%3Furl%3D1475">Mars Effect</a> ."  But we are not so.  We initially say that this statistical study does not pretend to be serious.  Any statistical dependencies that will be described here are either fairly obvious in their own right, or have the nature of a ‚Äú <a href="http://www.viva64.com/go.php%3Furl%3D1468">false correlation</a> ‚Äù, or do not exceed the statistical error due to the small sample size. <br><br>  Well, let's get started?  So far, Google collects statistics, which is not popular with people, we will collect statistics, which is not to the analyzer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/6d8/a83/8a2/6d8a838a2720aee573e3b87e7dcc69b6.png" alt="Statistics"><br><br><h2>  Assumption 1. Some words are more common </h2><br>  Come on?  You must be joking? <br><br>  Any person who is familiar with any programming language may say that some words or characters are found in the text of the program more often than others.  Even in <a href="http://www.viva64.com/go.php%3Furl%3D1476">Brainfuck</a> programming, the '+' character occurs more often than the '.' Character.  The only "programming language" in which someone once really wrote and where one can argue with this fact is that programming is not even in assembler, but directly in machine codes.  Connoisseurs in addition to this will surely name counterexamples from esoteric languages ‚Äã‚Äãlike <a href="http://www.viva64.com/go.php%3Furl%3D1477">Malbolge</a> and so on.  What about C ++?  And so it is clear that the keyword int will occur in the source code on average more often than float, public - than protected and class - than struct or, moreover, union.  But still.  What are the most common words in parts of C ++ code containing an error?  The calculation was done by elementary calculation of the number of words in all the examples;  that is, if in one example the word if was encountered twice, then it was counted twice.  Words in the comments were not considered.  So, a list of the most common words (the number before the colon indicates the number of times how many words were encountered in all examples): <br><ul><li>  1323: if </li><li>  798: int </li><li>  699: void </li><li>  686: i </li><li>  658: const </li><li>  620: return </li><li>  465: char </li><li>  374: static </li><li>  317: else </li><li>  292: sizeof </li><li>  258: bool </li><li>  257: NULL </li><li>  239: s </li><li>  223: for </li><li>  194: unsigned </li><li>  187: n </li><li>  150: struct </li><li>  146: define </li><li>  137: x </li><li>  133: std </li><li>  121: c </li><li>  121: new </li><li>  115: typedef </li><li>  113: j </li><li>  107: d </li><li>  105: a </li><li>  102: buf </li><li>  102: case </li></ul><br>  <b>"Output": 'if' begets errors.</b> <br><br>  The following words give hope;  rather, their number in comparison with if and even case: <ul><li>  15: goto </li><li>  13: static_cast </li><li>  6: reinterpret_cast </li></ul><br>  It seems that not everything is so bad with the structure of Open Source applications. <br><br>  But the word auto was not noticed almost anywhere (less than five inclusions), as well as constexpr, and unique_ptr, and so on.  On the one hand, this is logical, since the base of examples started typing examples a long time ago, when the implementation of the C ++ 11 standard was not even thought of.  On the other hand, there is another subtext in this: language extensions are introduced primarily to simplify it and reduce the likelihood of new errors.  We remind you that only examples with errors found by the PVS-Studio analyzer fall into our database. <br><br>  Similar statistics were collected on numbers. <ul><li>  1304: 0 </li><li>  653: 1 </li><li>  211: 2 </li><li>  120: 4 </li><li>  108: 3 </li><li>  70: 8 </li><li>  43: 5 </li><li>  39: 16 </li><li>  36: 64 </li><li>  29: 6 </li><li>  28: 256 </li></ul><br>  <b>It is curious that the number 4 in the examples of the erroneous code is more common than the number 3, and this is not associated with 64-bit diagnostics</b> - in the examples, if there are, then in a very small number (no more than one or two copies of the code).  The vast majority of examples (at least 99%) were collected on general-purpose diagnostics. <br><br>  Most likely, the appearance of the four above the three, albeit with a small margin, is due to the fact that four is a ‚Äúround‚Äù number, and three is a ‚Äúnon-round‚Äù, if you know what I mean.  For the same reason, it seems, the numbers 8, 16, 64 and 256 go to a significant gap. Here is such a strange distribution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/ad5/cff/508ad5cffc3ff623f0ced31f44f7a183.png" alt="Statistics"><br><br>  And then - on the wit and knowledge.  What do you think, where did these numbers come from, 4996 and 2047? <ul><li>  6: 4996 </li><li>  5: 2047 </li></ul><br>  The answer is at the end of the next section. <br><br><h2>  Assumption 2. The most common letter in the code - the letter 'e' </h2><br>  According to <a href="http://www.viva64.com/go.php%3Furl%3D1462">statistics</a> , in literary English the letter 'e' occurs most often.  The ten most common letters in English are e, t, a, o, i, n, s, h, r, d.  And what is the probability to meet one or another symbol in the texts of source code in C ++?  Let's put such an experiment.  The approach to the experiment this time is even more brutal and heartless than the previous one.  We just go through all the examples and just count the number of all characters.  The register was not taken into account, that is, 'K' = 'k'.  So, the results: <ul><li>  82100: </li><li>  28603: e </li><li>  24938: t </li><li>  19256: i </li><li>  18088: r </li><li>  17606: s </li><li>  16700: a </li><li>  16466: </li><li>  16343: n </li><li>  14923: o </li><li>  12438: c </li><li>  11527: l </li></ul><br>  <b>The most common character is a space.</b>  In literary English, the space character is a little ahead of the letter e, but in our case this is far from the case.  The space is very widely used for code alignment, which provides it with a leading position by a wide margin, at least in our examples, because for convenience of formatting, we replace tabs with spaces.  <b>As for the rest of the characters - the characters i (the leader in the market of names for counters since 19XX) came out very strongly, r (according to our assumptions - there are several frequently used names such as run, rand, vector, read, write and especially - error) and s (std :: string s).</b>  However, due to a sufficiently large statistical sample, we can assert that the letters e and t are also the most frequent in the source code of the program, as in the texts in English. <br><br>  About the point.  Of course, the point is not as common in real programs as can be judged from the list above.  The fact is that in our examples the four points very often drop the redundant code that is not required to understand the error.  Therefore, in fact, the point is hardly included in the set of the most frequent characters of the C ++ language. <br><br>  What did anyone say about <a href="http://www.viva64.com/go.php%3Furl%3D1478"><u>entropy coding</u></a> ? <br><br>  And if you look from another angle.  Which symbol is most rare in the examples? <ul><li>  90:? </li><li>  70: ~ </li><li>  24: ^ </li><li>  9: @ </li><li>  1: $ </li></ul><br>  Another very strange result that impressed us.  Look at the number of these characters.  It practically coincides (and in some places even coincides to the last sign!).  Mysticism, and only.  How could this happen? <ul><li>  8167: ( </li><li>  8157 :) </li><li>  3064: { </li><li>  2897:} </li><li>  1457: [ </li><li>  1457:] </li></ul><br>  Oh, yes, the promised answer to the question from the previous section.  2047 = 2048 - 1, and the number 4996 was typed because of the lines in the style <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta"> (disable:4996)</span></span></code> </pre> <br><h2>  Assumption 3. There is a relationship between the occurrences of certain words. </h2><br>  This is a bit like a correlation analysis.  The task was put like this: is there a relationship between the appearance of some two words in the examples? <br><br>  Why only "reminds".  We decided to calculate a relative value that is more similar to a linear correlation coefficient, but is not one, since it varies from 0 to 1 for convenience and measured for each pair of words (a, b) as follows: if the word a was found in Na examples, the word b - in Nb examples, and at the same time they met in Nab examples, then the coefficient Rab = Nab / Na, and Rba = Nab / Nb.  Since it is known that 0 &lt;= Nab &lt;= Na, Nb;  Na, Nb&gt; 0 can obviously be deduced that 0 &lt;= Rab, Rba &lt;= 1. <br><br>  How it works.  Suppose that the word void occurs in 500 examples, the word int - in 2000, and the words void and int at the same time - in 100. Then the coefficient Rvoid, int = 100/500 = 20%, and the coefficient Rint, void = 100/2000 = 5 %  Yes, the coefficient turned out to be asymmetric (Rab is not generally equal to Rba), but this can hardly be considered a hindrance. <br><br>  Probably, we can talk about at least some statistical dependence, when R&gt; = 50%.  Why exactly 50%?  Yes, simply because it wanted.  In fact, the threshold values ‚Äã‚Äãare chosen fairly closely, there are usually no recommendations here.  The value of 95%, in theory, should indicate a strong dependence.  In theory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfb/0e3/b69/bfb0e3b69a6d5bfadf9170dec329041f.png" alt="Statistics"><br><br>  So, using the correlation analysis, we managed to find out the following surprising, unorthodox facts: <ul><li>  <b>In the examples where the else keyword is used, in the overwhelming majority of cases (95.00%) the if! Keyword is also used.</b>  (I wonder where the remaining 5% have gone?) </li><li>  <b>In the examples where the public keyword is used, in the overwhelming majority of cases (95.12%) the keyword class is also used!</b> </li><li>  <b>In the examples where the keyword typename is used, in the overwhelming majority of cases (90.91%) the template keyword is also used!</b> </li></ul><br>  And so on and so forth.  Here are some "obvious" blocks below. <ul><li>  100.00% (18 of 18): argc -&gt; argv </li><li>  100.00% (18 of 18): argc -&gt; int </li><li>  94.44% (17 of 18): argc -&gt; char </li><li>  90.00% (18 of 20): argv -&gt; argc </li><li>  90.00% (18 of 20): argv -&gt; char </li><li>  90.00% (18 of 20): argv -&gt; int </li><li>  75.00% (12 of 16): main -&gt; argv </li><li>  60.00% (12 of 20): argv -&gt; main </li></ul><br>  At least, this example shows that the program at least works, even if it makes senseless operations to identify all dependencies between main, argc and argv. <ul><li>  100.00% (11 out of 11): disable -&gt; pragma </li><li>  100.00% (11 of 11): disable -&gt; default </li><li>  100.00% (11 out of 11): disable -&gt; warning </li><li>  91.67% (11 of 12): warning -&gt; pragma </li><li>  91.67% (11 of 12): warning -&gt; default </li><li>  91.67% (11 of 12): warning -&gt; disable </li><li>  78.57% (11 of 14): pragma -&gt; warning </li><li>  78.57% (11 of 14): pragma -&gt; disable </li><li>  78.57% (11 of 14): pragma -&gt; default </li><li>  57.89% (11 of 19): default -&gt; warning </li><li>  57.89% (11 of 19): default -&gt; disable </li><li>  57.89% (11 of 19): default -&gt; pragma </li></ul><br>  Madness of directives to the compiler.  The analysis revealed all the dependencies between the words disable, pragma, warning and default.  Apparently, all these examples were downloaded from the <a href="http://www.viva64.com/ru/examples/v665/">V665</a> diagnostic <a href="http://www.viva64.com/ru/examples/v665/">database</a> - especially note that there are only eleven examples.  By the way, these dependencies may seem completely obscure to those unfamiliar with the C ++ language, but for the programmer they may seem obvious. <br><br>  And we continue. <ul><li>  100.00% (24 of 24): WPARAM -&gt; LPARAM </li><li>  92.31% (24 of 26): LPARAM -&gt; WPARAM </li><li>  91.30% (21 of 23): wParam -&gt; WPARAM </li><li>  91.30% (21 of 23): lParam -&gt; LPARAM </li><li>  91.30% (21 of 23): wParam -&gt; LPARAM </li><li>  87.50% (21 of 24): WPARAM -&gt; wParam </li><li>  86.96% (20 of 23): wParam -&gt; lParam </li><li>  86.96% (20 of 23): lParam -&gt; wParam </li><li>  86.96% (20 of 23): lParam -&gt; WPARAM </li><li>  83.33% (20 of 24): WPARAM -&gt; lParam </li><li>  80.77% (21 of 26): LPARAM -&gt; wParam </li><li>  80.77% (21 out of 26): LPARAM -&gt; lParam </li></ul><br>  This, I think, does not need comments at all.  <b>A fairly strong relationship between the types of WPARAM, LPARAM, as well as their standard names lParam and wParam.</b>  These words, by the way, are drawn from 16-bit versions of Windows, and, it seems, even from Windows 3.11, which clearly shows us how much work Microsoft is doing in order to be compatible from year to year. <br><br>  There were, however, more interesting results. <ul><li>  100.00% (12 of 12): continue -&gt; if </li><li>  100.00% (13 of 13): goto -&gt; if </li><li>  68.25% (43 out of 63): break -&gt; if </li></ul><br>  The first two examples say that, most likely, in the examples there is no unconditional continue and goto.  The third, in principle, shows nothing, since break can be used not only in the loop, but also in the switch statement, which itself replaces the ‚Äúgarland‚Äù from the if statements.  Or not?  Does the presence of an if statement in the example indicate that break / continue / goto is conditional?  Did someone say something about diagnosing the <a href="http://www.viva64.com/ru/examples/v612/">V612</a> ?  In my defense, I can say, however, that in the examples there is not one that is not unconditional continue and goto, but continue and goto in general!  But with the break the situation is much more sad. <ul><li>  85.00% (17 out of 20): vector -&gt; std </li></ul><br>  Still, the authors of the real code try to avoid constructing "using namespace std;" in the header files, which definitely has favorable consequences for readers, even if it is not quite convenient for programmers (well, five extra characters to type!). <ul><li>  94.87% (74 out of 78): memset -&gt; 0 </li><li>  82.05% (64 of 78): memset -&gt; sizeof </li></ul><br>  <b>Most often, memory is filled with zeros, at least in our examples.</b>  Yes, most likely, the <a href="http://www.viva64.com/ru/examples/v597/">V597</a> diagnostics greatly influenced this statistic.  And also <a href="http://www.viva64.com/ru/examples/v575/">V575</a> , <a href="http://www.viva64.com/ru/examples/v512/">V512</a> and so on.  By the way, memory is filled with zeros more often than sizeof is used, which is at least strange and justified only if an array of bytes of a known size is filled.  Well, or if an error was made, for example, <a href="http://www.viva64.com/ru/examples/v512/">V512</a> , when the third argument of memset simply forgotten sizeof. <ul><li>  76.80% (139 out of 181): for -&gt; 0 </li></ul><br>  <b>In most cases, for loops start from zero.</b>  No, this is not a phrase in contrast to the language of Pascal or there, for example, Mathematica.  Of course, that many cycles are counting from scratch.  It is precisely because of this, probably, that a <a href="http://www.viva64.com/go.php%3Furl%3D1463">foreach loop was</a> introduced in C ++ 11, which quite tolerably "deals" not only with classes with redefined begin (), end (), etc., but also with regular arrays ( but not with pointers to arrays).  In addition, it is much more difficult to make a mistake in the foreach loop than in the for loop. <br><br>  So it goes.  By the way, this analysis took on our eight-core machine one hour and seven minutes in a release build. <br><br><h2>  Assumption 4. There are dangerous names of functions that are more often mistaken. </h2><br>  Actually, the title of the paragraph should speak for itself.  There is a suspicion that in some functions they are mistaken more often.  This suspicion was almost immediately broken about the harsh reality - the functions are called well, very differently, and in several projects the same function can be called ReadData (), readData (), read_data (), ReAdDaTa () and so on .  Therefore, the first idea was to write an additional subroutine that would break the names of the functions into separate words, such as read and data in the first three cases, and the fourth would try to burn out fire. <br><br>  After the breakdown of all the names of the functions in which errors were found, into words, this distribution was obtained. <ul><li>  159: get </li><li>  69: set </li><li>  46: init </li><li>  44: create </li><li>  44: to </li><li>  38: on </li><li>  37: read </li><li>  35: file </li><li>  34: is </li><li>  30: string </li><li>  29: data </li><li>  29: operator </li><li>  26: proc </li><li>  25: add </li><li>  25: parse </li><li>  25: write </li><li>  24: draw </li><li>  24: from </li><li>  23: info </li><li>  22: process </li><li>  22: update </li><li>  20: find </li><li>  20: load </li></ul><br>  <b>Apparently, in functions with the word 'get', errors are allowed in the name more often than in functions with 'set'.</b>  Well, or perhaps our analyzer finds more errors in the get functions than in the set functions.  Perhaps get functions are programmed more often than set functions. <br><br>  On the set of words in the functions, an analysis was carried out, similar to the analysis in the previous paragraph.  This time, the results are still not very large and can be brought here in full.  The names of the functions are not very visible and any dependencies can be traced.  Although I managed to isolate something. <ul><li>  77.78% (14 of 18): dlg -&gt; proc </li><li>  70.59% (12 of 17): name -&gt; get </li><li>  53.85% (14 of 26): proc -&gt; dlg </li><li>  43.48% (10 of 23): info -&gt; get </li></ul><br>  The level of validity of this result is somewhat comparable to this correlation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cb/941/086/9cb941086e0473081b3690252aa4849c.png" alt="Statistics"><br><br><h2>  Assumption 5. Some diagnostics work more often than others. </h2><br>  Again, the assumption is in fairly obvious style.  During the development of the analyzer, no one set himself the task of making the various diagnostics issue with approximately the same frequency.  And even if such a task was posed, some errors can be noticed almost immediately (such as <a href="http://www.viva64.com/ru/d/0230/">V614</a> ) and are intended mainly to speed up development by automatically displaying a message in incremental analysis.  And some, on the contrary, may go unnoticed until the end of the product life cycle (such as <a href="http://www.viva64.com/ru/d/0208/">V597</a> ).  The database also contains errors found by the results of the analysis of Open Source (for the most part) of the projects, and mostly these are the stable versions.  Needless to say, in such cases, where are errors of the second class more often than the first? <br><br>  The method of calculation is quite simple.  Let us consider an example.  The database contains the following entry: <br><pre> <code class="cpp hljs">NetXMS V668 There is no sense in .... calltip.cpp <span class="hljs-number"><span class="hljs-number">260</span></span> PRectangle CallTip::CallTipStart(....) { .... val = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(defn) + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PRectangle(); .... } Identical errors can be found in some other places: V668 There is no sense in .... cellbuffer.cpp <span class="hljs-number"><span class="hljs-number">153</span></span> V668 There is no sense in .... document.cpp <span class="hljs-number"><span class="hljs-number">1377</span></span> V668 There is no sense in .... document.cpp <span class="hljs-number"><span class="hljs-number">1399</span></span> And <span class="hljs-number"><span class="hljs-number">23</span></span> additional diagnostic messages.</code> </pre> <br>  The first line is the short name of the project.  It will be needed later.  The second entry contains information about the error ‚Äî the number of the diagnostics that failed, a description of the diagnosis, the name of the .cpp file in which the error was detected, and the line number.  Next comes the code that is not interesting to us.  Next, there is a record of additional places where the diagnosis was found, also with a diagnostic message, the module name and the line in which the error was found.  This information may well not be.  The last line is also optional and contains only the number of errors omitted for brevity.  As a result, from this example, we get information that in the NetXMS project, the V668 diagnostics detected 1 + 3 + 23 = 27 errors.  You can handle the following. <br><br>  So, the numbers of the most common diagnostics: <ul><li>  1037: <a href="http://www.viva64.com/ru/examples/V668/">668</a> </li><li>  1016: <a href="http://www.viva64.com/ru/examples/V595/">595</a> </li><li>  311: <a href="http://www.viva64.com/ru/examples/V610/">610</a> </li><li>  249: <a href="http://www.viva64.com/ru/examples/V547/">547</a> </li><li>  231: <a href="http://www.viva64.com/ru/examples/V501/">501</a> </li><li>  171: <a href="http://www.viva64.com/ru/examples/V576/">576</a> </li><li>  143: <a href="http://www.viva64.com/ru/examples/V519/">519</a> </li><li>  141: <a href="http://www.viva64.com/ru/examples/V636/">636</a> </li><li>  140: <a href="http://www.viva64.com/ru/examples/V597/">597</a> </li><li>  120: <a href="http://www.viva64.com/ru/examples/V512/">512</a> </li><li>  89: <a href="http://www.viva64.com/ru/examples/V645/">645</a> </li><li>  83: <a href="http://www.viva64.com/ru/examples/V611/">611</a> </li><li>  81: <a href="http://www.viva64.com/ru/examples/V557/">557</a> </li><li>  78: <a href="http://www.viva64.com/ru/examples/V624/">624</a> </li><li>  67: <a href="http://www.viva64.com/ru/examples/V523/">523</a> </li></ul><br>  Two diagnostics associated with working with memory, clearly lead.  It is not surprising, because in C / C ++ languages ‚Äã‚Äãthere is just ‚Äúdangerous‚Äù memory management.  Diagnostics <a href="http://www.viva64.com/ru/examples/V595/"><u>V595</u></a> searches for cases when object dereferencing by null pointer is possible, and <a href="http://www.viva64.com/ru/examples/V668/">V668</a> diagnostics warns that it is meaningless to check the pointer issued by the new operator that it will be zero, because new throws an exception if memory cannot be allocated.  Yes, 9X.XX% programmers make mistakes when working with memory in C / C ++ languages. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/735/bc8/d08735bc828859e21a114bfaac90075d.png" alt="Statistics"><br><br>  And then the idea arose to check in which projects the most errors were found and even what they were.  Well, it is said - done. <ul><li>  640: <a href="http://www.viva64.com/go.php%3Furl%3D1469">Miranda NG</a> : </li><li>  - <a href="http://www.viva64.com/ru/examples/V595/">V595</a> : 165 (25.8%) </li><li>  - <a href="http://www.viva64.com/ru/examples/V645/">V645</a> : 84 (13.1%) </li><li>  - <a href="http://www.viva64.com/ru/examples/V668/">V668</a> : 83 (13%) </li><li>  388: <a href="http://www.viva64.com/go.php%3Furl%3D1470">ReactOS</a> : </li><li>  - <a href="http://www.viva64.com/ru/examples/V595/">V595</a> : 213 (54.9%) </li><li>  - <a href="http://www.viva64.com/ru/examples/V547/">V547</a> : 32 (8.25%) </li><li>  280: <a href="http://www.viva64.com/go.php%3Furl%3D1471">V8</a> : </li><li>  - <a href="http://www.viva64.com/ru/examples/V668/">V668</a> : 237 (84.6%) </li><li>  258: <a href="http://www.viva64.com/go.php%3Furl%3D1473">Geant4</a> : </li><li>  - <a href="http://www.viva64.com/ru/examples/V624/">V624</a> : 71 (27.5%) </li><li>  - <a href="http://www.viva64.com/ru/examples/V668/">V668</a> : 70 (27.1%) </li><li>  - <a href="http://www.viva64.com/ru/examples/V595/">V595</a> : 31 (12%) </li><li>  216: <a href="http://www.viva64.com/go.php%3Furl%3D1472">icu</a> : </li><li>  - <a href="http://www.viva64.com/ru/examples/V668/">V668</a> : 212 (98.1%) </li></ul><br><h2>  Assumption 6. The error density at the beginning of the file is higher than at the end. </h2><br>  The latter assumption also did not differ particularly elegant.  The idea is this: are there any lines or groups of lines (for example, from 67 to 75), where programmers make mistakes most often?  It is pretty obvious that programmers will rarely make mistakes in the first ten lines (well, in those where #pragma once or #include ‚Äúfile.h‚Äù is often written), it was also quite obvious that programmers rarely make mistakes in lines from 30,000 to 30100. At least because such large files in real projects usually simply do not exist. <br><br>  Actually, the calculation method was quite simple.  Each diagnostic error message contains the line number of the error file.  Yes, that's just not all the errors show the line number: from the example above, you can get only four line numbers from the possible twenty-seven, since the remaining twenty-three are not described.  But with the help of this tool you can get a lot of errors from the database.  That's just the total size of the .cpp file for later normalization is not saved anywhere, so there will be no reduction to relative percentages.  In other words, based on the examples it is impossible to just take and test the hypothesis that <a href="http://www.viva64.com/go.php%3Furl%3D1464">80% of errors occur in the last 20% of the file</a> . <br><br>  This time, instead of textual information, we will provide a full-fledged histogram. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/392/8ad/c4c/3928adc4c9040e0557e71a34d8e4b223.png" alt="Figure 1 - The histogram of the density distribution of errors depending on the number of the code line"><br><br>  Figure 1 - The histogram of the density distribution of errors depending on the number of the code line <br><br>  The calculation was carried out as follows (using the first column as an example): we calculated how many errors occurred in lines 11 through 20 and divided this number by the number of lines between the twentieth and eleventh inclusive (that is, 10).  As a result, a little less than one error was made for all projects on lines 11 through 20. This indicator is displayed in the histogram.  I remind you that we did not make normalization - more important were not the exact values, which still are unlikely to reflect the dynamics due to the small sample size, but at least the type of graph. <br><br>  Despite the fact that the histogram shows abrupt deviations from the norm (and this norm is somewhat similar to the <a href="http://www.viva64.com/go.php%3Furl%3D1465">log-normal distribution</a> ), we decided not to delve into the proof that from 81 to 90 lines of the error code are most frequently committed.  Still, drawing a graph is one task, and mathematically rigorously proving something on its basis is another, and much more complicated.  As for the same schedule, it was decided to limit ourselves to a vague phrase.  "Unfortunately, all deviations, it seems, in their magnitude do not exceed the statistical error."  That's all. <br><br><h2>  Conclusion </h2><br>  <b>In this article, it was clearly shown how you can, while engaging in absolute nonsense, write scientific texts and get paid for it.</b> <br><br>  But seriously - the fishing of statistical information on the database of errors has two serious problems.  The first problem is what are we looking for?  It is quite possible to confirm the ‚Äúlast line effect‚Äù manually (and even necessary, since automating the search for similar blocks is a thankless task), and everything else simply stumbles upon a lack of ideas.  The second problem - is the sample size sufficient?  It is possible that sampling is quite sufficient for frequency analysis of symbols, but this cannot be said for the rest of the statistics.  The same can be said about statistical significance.  Moreover, after collecting a database with a large number of experiments, it is not enough just to repeat the same thing.  For a strict confirmation of a certain statistical hypothesis, it is necessary to carry out a lot of complicated mathematical calculations, for example, with the selection of the distribution function and the calculation of <a href="http://www.viva64.com/go.php%3Furl%3D1466">the Pearson approval criterion</a> .  Of course, if the dependency is supposed to be somewhere at the level of the astrologer's predictions, such tests are meaningless in principle. <br><br>  This article was originally intended to search for directions, where exactly to dig in the statistics on the database of errors.  If somewhere there was a sharp deviation from the norm, one could think about it and conduct more detailed experiments.  However, this is nowhere seen, alas, was not. </div><p>Source: <a href="https://habr.com/ru/post/247677/">https://habr.com/ru/post/247677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247665/index.html">A drone based on the Raspberry Pi. Part 1</a></li>
<li><a href="../247667/index.html">Guide to the Car Tutorial (Unity3d) part 1 of 3</a></li>
<li><a href="../247669/index.html">Fast Data Recipe Based on Big Data Solution</a></li>
<li><a href="../247671/index.html">How to create a robotic startup: a textbook for the entrepreneur</a></li>
<li><a href="../247673/index.html">FAT32 media emulation on stm32f4</a></li>
<li><a href="../247679/index.html">Qmpot - programmable sound editor</a></li>
<li><a href="../247681/index.html">Introduction to Distributed Switch Architecture: Network Management Technology as a Single Device</a></li>
<li><a href="../247683/index.html">Functions for solving quadratic comparisons. Implementation in MATLAB</a></li>
<li><a href="../247685/index.html">Online Arbitration or Arbitration Court on the Internet</a></li>
<li><a href="../247687/index.html">A guide to creating habit-forming products. Part one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>