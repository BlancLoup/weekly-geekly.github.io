<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting FreeModbus under STM32. Version from dinar</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, amateurs and programming professionals on microcontrollers. This article is devoted to porting the freemodbus library to STM32F100 (the one ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting FreeModbus under STM32. Version from dinar</h1><div class="post__text post__text-html js-mediator-article">  Good day, amateurs and programming professionals on microcontrollers.  This article is devoted to porting the freemodbus library to STM32F100 (the one in discovery vl).  Yes, habrahabr already has a similar <a href="https://habrahabr.ru/post/279747/">article</a> , but it seems to me not the most successful.  I will use Modbus RTU in slave mode.  To successfully port the freemodbus library to a platform without an operating system, you must perform three steps: <br><br>  <b>1.</b> Register the file port.h <br>  <b>2.</b> set the timer <br>  <b>3.</b> configure usart <br><br>  So, the plan is made - it's time for work. <br><a name="habracut"></a><br>  For convenience, we will generate a project using the STM Cube for IAR.  We will need to enable debugging, adjust the timer, and I also used the quartz that are present on the board. <br><div class="spoiler">  <b class="spoiler_title">STM Cube Screenshots</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/536/2fe/4d95362fe0ce0178e3160db714c8439b.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/ac8/8e6/ca6/ac88e6ca616a4b4cf984a9f53d6fd291.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/a72/576/eaa/a72576eaaa94fc5f8cf1c543c1975a35.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/f32/786/cd2f32786cf42f644f6617f8b8b4a04a.png" alt="image"><br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We generate the project.  Download freemodbus-v1.5.0 sources.  We need a modbus folder.  Place it in the project folder in \ Drivers. <br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/8cf/7df/d3f8cf7df99cc0b0ccb1d5b17f2f9d3f.png" alt="image"><br><br>  There we will place the port folder from freemodbus-v1.5.0 \ demo \ BARE. <br><img src="https://habrastorage.org/getpro/habr/post_images/844/49f/9ff/84449f9ff39cb31064841758af09da26.png" alt="image"><br><br>  Open the project and attach the newly copied sources to it. <br><img src="https://habrastorage.org/getpro/habr/post_images/207/f0a/aa2/207f0aaa2778e50866479dfa4aa8fc51.png" alt="image"><br><br>  Next, you need to register paths to folders in the project options in the Preprocessor tab. <br><img src="https://habrastorage.org/getpro/habr/post_images/086/fa6/b62/086fa6b6251b8b9f96106b6efe84bf93.png" alt="image"><br><br>  STM QUBE for some reason, it specified as a device none.  We fix. <br><img src="https://habrastorage.org/getpro/habr/post_images/2ed/ca8/872/2edca88729119502a0f7762f1057868d.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/64e/1f5/76e/64e1f576e095440ae4e4a6aa63eda719.png" alt="image"><br><br>  At this stage, the project is going, albeit with warnings.  Let's go directly to the porting.  Open port.h.  Let's declare the functions providing atomicity of operations.  Here we will carry out announcements of functions for UART. <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __critical_enter(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __critical_exit(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTER_CRITICAL_SECTION( ) ( __critical_enter( ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXIT_CRITICAL_SECTION( ) ( __critical_exit( ) ) void prvvUARTTxReadyISR( void ); void prvvUARTRxISR( void );</span></span></code> </pre> <br><br>  I wrote the definition in main (). <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> lock_nesting_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __critical_enter(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { __disable_irq(); ++lock_nesting_count; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __critical_exit(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Unlock interrupts only when we are exiting the outermost nested call. */</span></span> --lock_nesting_count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lock_nesting_count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { __enable_irq(); } }</code> </pre> <br>  The lion's part of the timer is configured by Qube.  It remains only to add a little in porttimer.c.  This part is completely written in HAL and does not need extra comments. <br><div class="spoiler">  <b class="spoiler_title">porttimer.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ----------------------- Platform includes --------------------------------*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"port.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f1xx_hal.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Modbus includes ----------------------------------*/</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mb.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbport.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- static functions ---------------------------------*/</span></span></span><span class="hljs-meta"> static void prvvTIMERExpiredISR( void ); extern TIM_HandleTypeDef htim6; uint16_t timeout = 0; volatile uint16_t counter = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Start implementation -----------------------------*/</span></span></span><span class="hljs-meta"> BOOL xMBPortTimersInit( USHORT usTim1Timerout50us ) { timeout = usTim1Timerout50us; return TRUE; } void vMBPortTimersEnable( ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enable the timer with the timeout passed to xMBPortTimersInit( ) */</span></span></span><span class="hljs-meta"> counter=0; HAL_TIM_Base_Start_IT(&amp;htim6); } void vMBPortTimersDisable( ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Disable any pending timers. */</span></span></span><span class="hljs-meta"> HAL_TIM_Base_Stop_IT(&amp;htim6); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Create an ISR which is called whenever the timer has expired. This function * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that * the timer has expired. */</span></span></span><span class="hljs-meta"> static void prvvTIMERExpiredISR( void ) { ( void )pxMBPortCBTimerExpired( ); } void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((++counter)&gt;=timeout) { prvvTIMERExpiredISR(); } }</span></span></code> </pre> <br></div></div><br>  Check that everything goes according to plan.  Check that the timings match the expectations.  I'll check the old-fashioned method, an oscilloscope.  Should get momentum 1ms.  Whether vMBPortTimersDisable works - I will not check =) <br><br>  Temporarily write: <br><img src="https://habrastorage.org/getpro/habr/post_images/d1f/47e/e63/d1f47ee6321c6ff75ff306e8dcd584e2.png" alt="image"><br><br>  And in main (): <br><img src="https://habrastorage.org/getpro/habr/post_images/af8/64c/291/af864c291b0526da5411bd0db059796d.png" alt="image"><br><br>  We look: <br><img src="https://habrastorage.org/getpro/habr/post_images/489/007/d82/489007d825042e296225c185eb25228d.jpg" alt="image"><br><br>  Now the most interesting thing is setting up UART =) We need to start by writing xMBPortSerialInit and vMBPortSerialEnable.  Since GetByte from the library accepts char, I exclude work with 9-bit messages in principle.  To write the vMBPortSerialEnable, refer to the USART interrupt scheme. <br><img src="https://habrastorage.org/getpro/habr/post_images/1e8/063/08e/1e806308ea3b5c1d950450002bda511c.png" alt="image"><br><br>  You can see that to enable an interrupt on reception, you need to enable RXNEIE: RXNE interrupt enable, and the event transmitter is ready - TXEIE: TXE interrupt enable. <br><br>  The received byte is in the huart_m-&gt; Instance-&gt; DR register.  Writing to this register causes a transfer.  It's simple.  For the convenience of working with USART, add stm32f1xx_hal_uart.c to the project and define HAL_UART_MODULE_ENABLED.  I will not write a lot of words, but just show you what's inside. <br><div class="spoiler">  <b class="spoiler_title">portserial.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"port.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f1xx_hal.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Modbus includes ----------------------------------*/</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mb.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbport.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- static functions ---------------------------------*/</span></span></span><span class="hljs-meta"> UART_HandleTypeDef huart_m; HAL_StatusTypeDef USART_Init(UART_HandleTypeDef *huart); void USART_MspInit(UART_HandleTypeDef* huart); static void USART_SetConfig(UART_HandleTypeDef *huart); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------- Start implementation -----------------------------*/</span></span></span><span class="hljs-meta"> void vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* If xRXEnable enable serial receive interrupts. If xTxENable enable * transmitter empty interrupts. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(xRxEnable) { __HAL_UART_ENABLE_IT(&amp;huart_m, UART_IT_RXNE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { __HAL_UART_DISABLE_IT(&amp;huart_m, UART_IT_RXNE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(xTxEnable) { __HAL_UART_ENABLE_IT(&amp;huart_m, UART_IT_TXE); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { __HAL_UART_DISABLE_IT(&amp;huart_m, UART_IT_TXE); } } BOOL xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity ) { switch (ucPORT) { case 0: huart_m.Instance = USART1; break; case 1: huart_m.Instance = USART2; break; case 2: huart_m.Instance = USART3; break; default: return FALSE; } huart_m.Init.BaudRate = ulBaudRate; switch (ucDataBits) { case 8: huart_m.Init.WordLength = UART_WORDLENGTH_8B; break; default: return FALSE; } switch (eParity) { case MB_PAR_NONE: huart_m.Init.Parity = UART_PARITY_NONE; break; case MB_PAR_EVEN: huart_m.Init.Parity = UART_PARITY_EVEN; break; case MB_PAR_ODD: huart_m.Init.Parity = UART_PARITY_ODD; break; default: return FALSE; } huart_m.Init.StopBits = UART_STOPBITS_1; huart_m.Init.Mode = UART_MODE_TX_RX; huart_m.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart_m.Init.OverSampling = UART_OVERSAMPLING_16; return (HAL_OK == USART_Init(&amp;huart_m)); } BOOL xMBPortSerialPutByte( CHAR ucByte ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Put a byte in the UARTs transmit buffer. This function is called * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been * called. */</span></span></span><span class="hljs-meta"> huart_m.Instance-&gt;DR=ucByte; return TRUE; } BOOL xMBPortSerialGetByte( CHAR * pucByte ) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Return the byte in the UARTs receive buffer. This function is called * by the protocol stack after pxMBFrameCBByteReceived( ) has been called. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart_m.Init.Parity == UART_PARITY_NONE) { *pucByte = (uint8_t)(huart_m.Instance-&gt;DR &amp; (uint8_t)0x00FF); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { *pucByte = (uint8_t)(huart_m.Instance-&gt;DR &amp; (uint8_t)0x007F); } return TRUE; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Create an interrupt handler for the transmit buffer empty interrupt * (or an equivalent) for your target processor. This function should then * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that * a new character can be sent. The protocol stack will then call * xMBPortSerialPutByte( ) to send the character. */</span></span></span><span class="hljs-meta"> void prvvUARTTxReadyISR( void ) { pxMBFrameCBTransmitterEmpty( ); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Create an interrupt handler for the receive interrupt for your target * processor. This function should then call pxMBFrameCBByteReceived( ). The * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the * character. */</span></span></span><span class="hljs-meta"> void prvvUARTRxISR( void ) { pxMBFrameCBByteReceived( ); } HAL_StatusTypeDef USART_Init(UART_HandleTypeDef *huart) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Check the UART handle allocation */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart == NULL) { return HAL_ERROR; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Check the parameters */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart-&gt;Init.HwFlowCtl != UART_HWCONTROL_NONE) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The hardware flow control is available only for USART1, USART2, USART3 */</span></span></span><span class="hljs-meta"> assert_param(IS_UART_HWFLOW_INSTANCE(huart-&gt;Instance)); assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart-&gt;Init.HwFlowCtl)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { assert_param(IS_UART_INSTANCE(huart-&gt;Instance)); } assert_param(IS_UART_WORD_LENGTH(huart-&gt;Init.WordLength)); assert_param(IS_UART_OVERSAMPLING(huart-&gt;Init.OverSampling)); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart-&gt;State == HAL_UART_STATE_RESET) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Allocate lock resource and initialize it */</span></span></span><span class="hljs-meta"> huart-&gt;Lock = HAL_UNLOCKED; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Init the low level hardware */</span></span></span><span class="hljs-meta"> USART_MspInit(huart); } huart-&gt;State = HAL_UART_STATE_BUSY; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Disable the peripheral */</span></span></span><span class="hljs-meta"> __HAL_UART_DISABLE(huart); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Set the UART Communication parameters */</span></span></span><span class="hljs-meta"> USART_SetConfig(huart); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* In asynchronous mode, the following bits must be kept cleared: - LINEN and CLKEN bits in the USART_CR2 register, - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/</span></span></span><span class="hljs-meta"> CLEAR_BIT(huart-&gt;Instance-&gt;CR2, (USART_CR2_LINEN | USART_CR2_CLKEN)); CLEAR_BIT(huart-&gt;Instance-&gt;CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Enable the peripheral */</span></span></span><span class="hljs-meta"> __HAL_UART_ENABLE(huart); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Initialize the UART state */</span></span></span><span class="hljs-meta"> huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; huart-&gt;State= HAL_UART_STATE_READY; return HAL_OK; } void USART_MspInit(UART_HandleTypeDef* huart) { GPIO_InitTypeDef GPIO_InitStruct; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart-&gt;Instance==USART1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART1_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral clock enable */</span></span></span><span class="hljs-meta"> __HAL_RCC_USART1_CLK_ENABLE(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */</span></span></span><span class="hljs-meta"> GPIO_InitStruct.Pin = GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral interrupt init */</span></span></span><span class="hljs-meta"> HAL_NVIC_SetPriority(USART1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART1_IRQn); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART1_MspInit 1 */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart-&gt;Instance==USART2) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART2_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART2_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral clock enable */</span></span></span><span class="hljs-meta"> __HAL_RCC_USART2_CLK_ENABLE(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/**USART2 GPIO Configuration PA2 ------&gt; USART2_TX PA3 ------&gt; USART2_RX */</span></span></span><span class="hljs-meta"> GPIO_InitStruct.Pin = GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral interrupt init */</span></span></span><span class="hljs-meta"> HAL_NVIC_SetPriority(USART2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART2_IRQn); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART2_MspInit 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART2_MspInit 1 */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(huart-&gt;Instance==USART3) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART3_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART3_MspInit 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral clock enable */</span></span></span><span class="hljs-meta"> __HAL_RCC_USART3_CLK_ENABLE(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/**USART3 GPIO Configuration PB10 ------&gt; USART3_TX PB11 ------&gt; USART3_RX */</span></span></span><span class="hljs-meta"> GPIO_InitStruct.Pin = GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_11; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Peripheral interrupt init */</span></span></span><span class="hljs-meta"> HAL_NVIC_SetPriority(USART3_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART3_IRQn); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN USART3_MspInit 1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END USART3_MspInit 1 */</span></span></span><span class="hljs-meta"> } } static void USART_SetConfig(UART_HandleTypeDef *huart) { uint32_t tmpreg = 0x00; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Check the parameters */</span></span></span><span class="hljs-meta"> assert_param(IS_UART_BAUDRATE(huart-&gt;Init.BaudRate)); assert_param(IS_UART_STOPBITS(huart-&gt;Init.StopBits)); assert_param(IS_UART_PARITY(huart-&gt;Init.Parity)); assert_param(IS_UART_MODE(huart-&gt;Init.Mode)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*------- UART-associated USART registers setting : CR2 Configuration ------*/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Configure the UART Stop Bits: Set STOP[13:12] bits according * to huart-&gt;Init.StopBits value */</span></span></span><span class="hljs-meta"> MODIFY_REG(huart-&gt;Instance-&gt;CR2, USART_CR2_STOP, huart-&gt;Init.StopBits); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*------- UART-associated USART registers setting : CR1 Configuration ------*/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Configure the UART Word Length, Parity and mode: Set the M bits according to huart-&gt;Init.WordLength value Set PCE and PS bits according to huart-&gt;Init.Parity value Set TE and RE bits according to huart-&gt;Init.Mode value */</span></span></span><span class="hljs-meta"> tmpreg = (uint32_t)huart-&gt;Init.WordLength | huart-&gt;Init.Parity | huart-&gt;Init.Mode ; MODIFY_REG(huart-&gt;Instance-&gt;CR1, (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), tmpreg); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*------- UART-associated USART registers setting : CR3 Configuration ------*/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Configure the UART HFC: Set CTSE and RTSE bits according to huart-&gt;Init.HwFlowCtl value */</span></span></span><span class="hljs-meta"> MODIFY_REG(huart-&gt;Instance-&gt;CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart-&gt;Init.HwFlowCtl); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*------- UART-associated USART registers setting : BRR Configuration ------*/</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((huart-&gt;Instance == USART1)) { huart-&gt;Instance-&gt;BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart-&gt;Init.BaudRate); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { huart-&gt;Instance-&gt;BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart-&gt;Init.BaudRate); } }</span></span></code> </pre> <br>  Now you need to configure interrupts in stm32f1xx_it.c. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DINAR_UART_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UART_HandleTypeDef *huart)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tmp_flag = <span class="hljs-number"><span class="hljs-number">0</span></span>, tmp_it_source = <span class="hljs-number"><span class="hljs-number">0</span></span>; tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE); tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE); <span class="hljs-comment"><span class="hljs-comment">/* UART in mode Receiver ---------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((tmp_flag != RESET) &amp;&amp; (tmp_it_source != RESET)) { prvvUARTRxISR( ); } tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE); tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE); <span class="hljs-comment"><span class="hljs-comment">/* UART in mode Transmitter ------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((tmp_flag != RESET) &amp;&amp; (tmp_it_source != RESET)) { prvvUARTTxReadyISR( ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USART1_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DINAR_UART_IRQHandler(&amp;huart_m); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USART2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DINAR_UART_IRQHandler(&amp;huart_m); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USART3_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DINAR_UART_IRQHandler(&amp;huart_m); }</code> </pre> <br></div></div><br>  As in the case of the timer - you need to make sure that everything goes according to plan.  We are checking.  Temporarily prescribe: <br><img src="https://habrastorage.org/getpro/habr/post_images/831/1d3/c02/8311d3c02b88585e36cffabab907587f.png" alt="image"><br><br>  We put brekpoint and make sure that when receiving a byte, we get an interrupt.  I sent through hercules. <br><img src="https://habrastorage.org/getpro/habr/post_images/5e1/ec1/e77/5e1ec1e77be413abf14ac9fc3d797950.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/051/225/936/051225936ffb8ee8b971583abfc2d47e.png" alt="image"><br><br>  Also check the transmitter.  Temporarily prescribe: <br><img src="https://habrastorage.org/getpro/habr/post_images/245/1c4/660/2451c4660fbf884d01f64d9c28602ad8.png" alt="image"><br><br>  We look: <br><img src="https://habrastorage.org/getpro/habr/post_images/af7/2cf/7ca/af72cf7ca6b30ee158b2102e99cb628d.png" alt="image"><br><br>  Now let's try to interrogate our device with the help of Modbus Poll. <br><div class="spoiler">  <b class="spoiler_title">Take an example from Demo</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b39/079/461/b39079461870df72ed99de3bc454f4b4.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/b64/a64/e0c/b64a64e0cd420f3777c9cc82df374da3.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/e5a/1a5/71ce5a1a52c30c98d9f1ef0e642bf076.png" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Run a poll</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/868/de2/67a/868de267a79261b27c059887dd49227e.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/872/79b/08d/87279b08dd11430c7b9dd532597896b6.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/f3d/6c4/a4a/f3d6c4a4ae749936da47a674e2c16dca.jpg" alt="image"><br></div></div><br>  Works!  I hope this article will help beginners, like me, to implement this simple but at the same time useful protocol. </div><p>Source: <a href="https://habr.com/ru/post/307622/">https://habr.com/ru/post/307622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307612/index.html">PostgreSQL in Russian seriously and for a long time</a></li>
<li><a href="../307614/index.html">UltraCMOS Peregrine Semiconductor: Microwave capabilities of CMOS technology</a></li>
<li><a href="../307616/index.html">A bunch of ways to reuse code in Rust</a></li>
<li><a href="../307618/index.html">History of programming languages: how Haskell became the standard of functional programming</a></li>
<li><a href="../307620/index.html">Errors of questionnaires. 1 error: sample offset. 8 ways to attract the right respondents</a></li>
<li><a href="../307624/index.html">The report on the results of "My Circle" for July 2016, and the most popular vacancies of the month</a></li>
<li><a href="../307626/index.html">Changes in CleverStyle Framework 5</a></li>
<li><a href="../307628/index.html">Tinkoff has compromised data on the balance of its clients' cards</a></li>
<li><a href="../307634/index.html">Top Selling Phones in History</a></li>
<li><a href="../307640/index.html">Recursion testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>