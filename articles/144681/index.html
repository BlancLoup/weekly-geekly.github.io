<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OmniThreadLibrary library - simple multithreading in Delphi environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is very difficult to write an interesting article on a technical topic. We have to balance between not slipping into the technical jungle and not s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OmniThreadLibrary library - simple multithreading in Delphi environment</h1><div class="post__text post__text-html js-mediator-article">  It is very difficult to write an interesting article on a technical topic.  We have to balance between not slipping into the technical jungle and not saying anything at all.  Today I will try in general terms (without details) to talk about how things are going with the development of multi-threaded desktop applications in the not so popular for today, but probably familiar to many Russian developers Delphi environment.  The article is focused on NOT newbies in programming, who are new to the development of multi-threaded applications. <br><a name="habracut"></a><br><br>  The topic covered in the title is very extensive.  Everything that will be written below is not even the tip of the iceberg, it is rather a flight at an altitude of 10,000 meters above the ocean in which these icebergs float.  Why write such an article?  Rather, in order to draw attention to the wide opportunities that have long been available, but which for some reason, many are afraid and shun. <br><br><h4>  Why Delphi? </h4><br>  I have been programming in Delphi for a very long time and I never stop enjoying it.  It is in many ways a wonderful language.  Its uniqueness is that it simultaneously allows you to create code of arbitrarily high level, while remaining ‚Äúclose to hardware‚Äù, since  at the output, we get a native application, not code for a Java or .Net virtual machine.  And at the same time, the Delphi language is very simple and concise, the code on it is pleasant to read and it is easy enough to figure out what I cannot say about the code in C or C ++ (with all my great respect for C developers, although someone will say that this is just a matter of habit). <br>  Currently, Delphi has lost its former popularity.  This was probably due to the fact that in the 2000s this product was practically abandoned by developers for several years, as a result of which it dropped out of the competitive race of development environments for a while.  Indeed, after Delphi 7, released by Borland in 2002, a more or less stable product appeared only in 2007.  It was CodeGear Delphi 2007, released by CodeGear, a subsidiary of Borland.  All versions between Delphi 7 and Delphi 2007 were practically unusable.  In 2008, Borland sold CodeGear to Embarcadero Technologies, which (for which she thanks a lot!) Immediately began to turn what it got into a modern, high-quality development environment.  The current version of Delphi at the time of this writing is Embarcadero Delphi XE2, released in September 2011.  Due to the relatively high quality of the latest versions of Delphi, this development environment gradually regains lost ground. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Why do we need multithreading? </h4><br>  People wanted to perform several tasks on a computer at the same time.  This is called multitasking.  Implements multitasking by means of the operating system.  But if the OS can perform several applications at the same time, why should not one application within itself also perform several tasks at once.  For example, when archiving a large list of files, the archiver can simultaneously read the next file, at this time archive the current read in memory and write the result to the output file on disk.  Those.  Instead of performing ‚Äúread‚Äù -&gt; ‚Äúarchive‚Äù -&gt; ‚Äúwrite result to disk‚Äù on each file in one stream, you can run 3 streams, one of which will read files into memory, the second stream - archive, and the third is to save to disk.  Another example is the execution of a low-priority task in the background ‚Äî for example, background backup of a file opened in a text editor. <br>  If processors continued to increase their clock speed at the same pace as it did in the 90s and early 2000s, one would not bother with multithreading and continue to write the classic single-threaded code.  However, in recent years, processors have ceased to actively increase the speed of a single core, but they have begun to increase the number of these cores themselves.  To use the potential of modern processors for 100% without multithreading just can not do. <br><br><h4>  Why is it difficult to write multi-threaded code? </h4><br>  <b>1) It is easy to make a mistake.</b> <br>  When several applications are running on a computer at the same time, the address space (memory) of each process is reliably isolated from other processes by the operating system and it is quite difficult to get into a foreign address space.  With threads within a single process, the opposite is true - they all work with the common address space of the process and can change it arbitrarily.  Therefore, in a multi-threaded application, you have to independently implement memory protection and thread synchronization, which leads to the need to write relatively complex, but not carrying code payload.  This code is called the "boilerplate" (griddle), because the griddle must first be prepared before you start frying something on it.  It is the need to write a ‚Äúnon-standard‚Äù boilerplate-code that hinders the development of multi-thread computing.  There are many special mechanisms for thread synchronization: interlocked processor commands, operating system synchronization objects (critical sections, mutexes, semaphores, events, etc.), spin locks, etc. <br>  <b>2) The code of a multithreaded application is difficult to analyze.</b> <br>  One of the difficulties of a multi-threaded application is that visually not looking at the code of a multi-threaded application is it clear whether a particular method can be called (or is called) from different threads.  Those.  you have to keep in mind which methods can be called from different threads, and which not.  Since making absolutely all methods thread-safe is not an option, there is always a chance to run into an error by calling a method that is not thread-safe from several threads. <br>  <b>3) A multi-threaded application is difficult to debug.</b> <br>  In a multithreaded application, many errors can occur when a certain state of concurrently executing threads (as a rule, with a sequence of commands executed in different threads).  An interesting example is described here (http://www.thedelphigeek.com/2011/08/multithreading-is-hard.html).  To recreate such a situation artificially is often very difficult, almost unreal.  In addition, there are not very many tools for debugging multi-threaded applications in Delphi, Visual Studio is the clear leader in this regard. <br>  <b>4) In a multithreaded application, it is difficult to handle errors.</b> <br>  If an application has a graphical user interface, only one stream can interact with the user.  Usually, when an error occurs in an application, we either process it inside the application or display a message to the user.  If the error occurs in the additional stream, it cannot say anything to the user "immediately."  Accordingly, it is necessary to save the error that occurred in the additional stream until it is synchronized with the main stream and only then issue it to the user.  This can lead to a relatively complex and confusing code structure. <br><br><h4>  Is there any way to simplify your life a little? </h4><br>  I present to you <a href="http://code.google.com/p/omnithreadlibrary/">OmniThreadLibrary</a> (abbreviated OTL).  OmniThreadLibrary is a library for creating multi-threaded applications in Delphi.  Its author, Primoz Gabrijelcic from Slovenia, is an unsurpassed professional with many years of experience in developing applications in Delphi.  OmniThreadLibrary is an absolutely free open source library.  At the moment the library is already in a rather mature stage and is quite suitable for use in serious projects. <br><br>  <b>Where can I find information on OTL?</b> <br><ul><li>  In <a href="http://otl.17slon.com/">this</a> forum. </li><li>  In the <a href="http://www.thedelphigeek.com/">blog of the</a> author of the library. </li><li>  On <a href="http://code.google.com/p/omnithreadlibrary/">the</a> project <a href="http://code.google.com/p/omnithreadlibrary/">page</a> in GoogleCode. </li></ul>  Also, the author of the library is currently engaged in filling the <a href="http://otl.17slon.com/book/doku.php">wiki-book</a> about OmniThreadLibrary and multithreading, articles about most of the high-level OTL primitives are already ready. <br><br><h4>  What features does OTL provide? </h4><br>  This library contains low-level and high-level classes that allow you to easily manage multithreading, without going into details of the processes of creating / releasing / synchronizing threads at the WinAPI level. <br>  Of particular interest are high-level primitives for simplified multi-threaded control.  They are remarkable in that they are relatively easy to integrate into a single-threaded ready-made application, almost without changing the structure of the source code.  These primitives allow you to create multi-threaded applications, concentrating on the useful application code, and not on the auxiliary code for multithreading control. <br>  The main high-level primitives include <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:future">Future</a> (asynchronous function), <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:pipeline">Pipeline</a> (pipeline), <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:join">Join</a> (parallel call of several methods), <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:forkjoin">ForkJoin</a> (recursion with parallelism), <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:async">Async</a> (asynchronous method), <a href="http://otl.17slon.com/book/doku.php%3Fid%3Dbook:highlevel:foreach">ForEach</a> (parallel loop). <br>  In my opinion, the most interesting and useful primitives are Future and Pipeline, because  for their use, the existing code almost does not need to be rewritten. <br><br><h4>  Future </h4><br>  This primitive allows you to make an asynchronous function call and at the right time wait for the completion of the calculation and get the result of the execution.  With the help of this primitive, the call of any procedure or function can be turned into asynchronous painlessly. <br>  It looks like this: <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> OtlParallel; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFuture</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vFuture: IOmniFuture&lt;integer&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      vFuture := Parallel.Future&lt;integer&gt;( function: integer var i: integer; begin Result := 0; for i := 1 to 100000 do Result := Result + i; end ); //   -     (      (    ,    ,        ) //     ,     ShowMessage(IntToStr(vFuture.Value)); end;</span></span></code> </pre> <br><br>  Pay attention that the reference to vFuture.Value is the moment of synchronization of the main thread with the additional, i.e.  until we turn to Value, we don‚Äôt know anything at all about the state of the other thread.  As soon as we call Value, the main thread is suspended until the completion of the calculation in the additional thread. <br><br>  If required, you can implement nonblocking wait for the result in the main thread: <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vFuture.IsDone <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Application.ProcessMessages;</code> </pre><br>  Thus, the Future primitive allows you to perform some task asynchronously and return the result to the main thread exactly at the moment it is needed there. <br><br><h4>  Pipeline </h4><br>  Pipeline is a much more powerful primitive compared to Future. <br>  Imagine that a certain algorithm is executed in a loop for a set of elements.  For example, some processing of files in the directory is performed.  A single-threaded program will take another file, read it, perform some actions and save the modified file to disk.  Having a pipeline, the original algorithm can be divided into stages (reading, processing, saving) and run these stages in parallel threads.  At the very beginning, only the very first stage will start and read the first file.  As soon as the reading is completed, the second stage will start and will start processing the read file or its portions (if the first stage reads the files not entirely but in portions).  At this time, the first stage will begin to read the second file.  As soon as the second stage processes the first file, the third stage will connect and start saving.  At this moment we will get a state in which all three stages work in parallel. <br>  An example for Pipeline, close to real life, would be too loaded an article, therefore, to illustrate the use of Pipeline, I limit myself to a copy of an absolutely synthetic example from OtlBook (don't mind it!): <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> OtlCommon, OtlCollections, OtlParallel; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sum := Parallel.Pipeline .Stage( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, output: IOmniBlockingCollection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> output.Add(i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) .Stage( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input: TOmniValue; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output: TOmniValue)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-function"> :</span></span>= input.AsInteger * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) .Stage( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, output: IOmniBlockingCollection)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">:</span></span> integer; value: TOmniValue; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sum := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(sum, value); output.Add(sum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) .Run.Output.Next; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In this example, the first stage generates a million numbers, passing them one by one to the next stage.  The second stage multiplies each number by 3 and transfers to the third stage.  The third stage summarizes the results and returns a single number.  Each Stage is executed in its thread.  Moreover, Otl allows you to specify how many threads for each Stage to use (if one is small) due to the simple modifier .NumTasks (N).  OTL's capabilities are really very wide. <br><br>  The base class for supporting data exchange between pipeline stages is the thread-protected queue class - TOmniBlockingCollection.  This class allows multiple threads to simultaneously add and read items.  The high speed of the collection is achieved by tricky memory management and the use of locks based on thread-safe processor instructions instead of locks based on OS synchronization objects.  You can read about the implementation details of the TOmniBlockingCollection class <a href="http://www.thedelphigeek.com/2010/01/three-steps-to-blocking-collection-1.html">here</a> , <a href="http://www.thedelphigeek.com/2010/01/three-steps-to-blocking-collection-2.html">here</a> and <a href="http://www.thedelphigeek.com/2010/02/three-steps-to-blocking-collection-3.html">here</a> . <br><br><h4>  Conclusion </h4><br>  Someone looking at the above examples will say "yes, I've already seen it all."  Indeed, the Task Parallel Library for .Net Framework 4 contains approximately the same classes.  At the same time, there are a number of differences between the way the threads inside the .Net machine are executed and how the threads are executed on the real processor.  Consideration of these differences is beyond the scope of this article.  I just wanted to focus on a great library, and the wide possibilities it provides to Delphi developers.  I want to note that the library is equipped with a large number of examples illustrating the use of both low-level and high-level classes. <br><br>  In order to dispel concerns about the maturity and reliability of this library, I will only say that by using Pipeline in a complex commercial multi-user application (not the web), it was possible to reduce the time to perform operations on a group of files on a client by almost half due to exploding file processing on separate threads on the client and their transfer to the server.  Whether to use a bunch of Delphi + OmniThreadLibrary in your projects is up to you;) </div><p>Source: <a href="https://habr.com/ru/post/144681/">https://habr.com/ru/post/144681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144674/index.html">Roaming Guide 2012: choose fares for travel</a></li>
<li><a href="../144675/index.html">Install and configure OSM-based tile generator in Ubuntu or Debian</a></li>
<li><a href="../144678/index.html">Apple patent application: Safari 3D interface</a></li>
<li><a href="../144679/index.html">Subtleties advancement in FaceBook</a></li>
<li><a href="../144680/index.html">Modern home network and cinema on the couch + Update (about transcoding)</a></li>
<li><a href="../144683/index.html">Programming for everyone: why no</a></li>
<li><a href="../144684/index.html">Virtual machine for e-commerce</a></li>
<li><a href="../144685/index.html">Connecting the lighting sensor from Mac Book Pro to Arduino</a></li>
<li><a href="../144686/index.html">Avionics Software Development</a></li>
<li><a href="../144687/index.html">Overriding permissions in Drupal 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>