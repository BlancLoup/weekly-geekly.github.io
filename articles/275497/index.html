<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Objects in PHP 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, PHP developers are working on a C-level API. In this post, I will mostly talk about PHP's internal development, although if there is something ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Objects in PHP 7</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/021/5c9/bb8/0215c9bb8b9104af6184b089cbac2c89.png" alt="image"><br><br>  Today, PHP developers are working on a C-level API. In this post, I will mostly talk about PHP's internal development, although if there is something interesting from the user level, I will digress and explain . <br><a name="habracut"></a><br><h1>  Changes in objects compared to PHP 5 </h1><br>  In order to fully understand the topic of objects in PHP, I recommend that you first familiarize yourself with the post <a href="https://habrahabr.ru/company/mailru/blog/255237/">detailing objects and classes in PHP</a> . <br><br>  So, what has changed in the seventh version compared to the fifth? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  At the user level, almost nothing has changed.  In other words, in PHP 7, the objects are the same as in PHP 5. No deep changes have been made, nothing that you might notice in your daily work.  Objects behave the same way.  Why was nothing changed?  We believe that our object model is mature, it is very actively used, and we see no need to introduce confusion in new versions of PHP. </li><li>  But there were still some low-level improvements.  The changes are small, however they require patch extensions.  In principle, in PHP 7, internal objects have become much more expressive, clearer and more logical than in PHP 5. The most important innovation is related to the main change in PHP 7: updating zval and managing garbage collection.  But in this post we will not consider the latter, because the subject of the post is objects.  However, it must be remembered that the very nature of the new zval and garbage collection mechanism affects the internal management of objects. </li></ul><br><h1>  Object structure and memory management </h1><br>  First of all, you can say goodbye to <code>zend_object_value</code> , this structure in PHP 7 was abandoned. <br><br>  Let's see an example of the definition of a zend_object object: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* in PHP 5 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object</span></span></span><span class="hljs-class"> {</span></span> zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; } zend_object; <span class="hljs-comment"><span class="hljs-comment">/* in PHP 7 */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object</span></span></span><span class="hljs-class"> {</span></span> zend_refcounted_h gc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> handle; zend_class_entry *ce; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; HashTable *properties; zval properties_table[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* C struct hack */</span></span> };</code> </pre><br>  As you can see, there are some minor differences from PHP 5. <br><br>  First, it contains the header <code>zend_refcounted_h</code> , which is part of the new zval and garbage collection mechanism. <br><br>  Secondly, the object now contains its <code>handle</code> , while in PHP 5 this task was performed by <code>zend_object_store</code> .  And in PHP 7, the object store (object store) has much less responsibilities. <br><br>  Thirdly, to substitute the <code>properties_table</code> of the zval vector, a structural hack is used in the C language; it is useful for creating custom objects. <br><br><h1>  Manage custom objects </h1><br>  An important change was the management of custom objects that we create for our needs.  Now they include <code>zend_object</code> .  This is a very important feature of the Zend Engine object model: extensions can declare their own objects and manage them, developing the capabilities of the standard implementation of objects in Zend without changing the source code of the engine. <br><br>  In PHP 5, we simply create inheritance in the form of a C-structure, including the basic definition of <code>zend_object</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 5 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_own_object</span></span></span><span class="hljs-class"> {</span></span> zend_object zobj; my_custom_type *my_buffer; } my_own_object;</code> </pre><br>  Due to the inheritance of the C-structure, it is enough for us to create a simple construction: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 5 */</span></span> my_own_object *my_obj; zend_object *zobj; my_obj = (my_own_object *)zend_objects_store_get_object(this_zval); zobj = (zend_object *)my_obj;</code> </pre><br>  You may have noticed that when you receive zval in PHP 5, for example, $ this in OO methods, you cannot get access to the object to which it directly points from within this zval.  To do this, you will have to contact the object storage.  Extract the handler from zval (in PHP 5) and use it to ask the repository to return the found object.  This object ‚Äî it can be custom ‚Äî is returned as <code>void*</code> .  If you have not customized anything, you need to represent it as a <code>zend_object*</code> , otherwise - as <code>my_own_object*</code> . <br><br>  In short, to get an object from a method, in PHP 5 you need to perform a search procedure.  And this is not very good for performance. <br><br>  In PHP 7, everything is different.  The object ‚Äî whether it is a custom or a classic <code>zend_object</code> ‚Äî is stored directly in zval.  However, <b>object storage no longer supports retrieval</b> .  That is, you can no longer read the contents of the object store, just write to it or erase it. <br><br>  <b>The placed object is entirely embedded in zval</b> , so if you call zval as a parameter and want to get the memory area of ‚Äã‚Äãthe object it points to, then you will not need to perform any additional searches.  Here‚Äôs how to get an object in PHP 7: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> zend_object *zobj; zobj = Z_OBJ_P(this_zval);</code> </pre><br>  Much easier than PHP 5, isn't it? <br><br>  Otherwise, work with custom placement of objects is now arranged.  From the above code it can be seen that the only way to get a custom object is to manipulate the memory: move the pointer in any desired direction within the required amount of memory.  Pure C programming and high performance: you will most likely stay in the same physical memory page, and therefore the kernel will not load the new page. <br><br>  Declaring a custom object in PHP 7: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_own_object</span></span></span><span class="hljs-class"> {</span></span> my_custom_type *my_buffer; zend_object zobj; } my_own_object;</code> </pre><br>  Pay attention to the permutation of the components of the structure in comparison with PHP 5. What is it done for?  When you read a <code>zend_object</code> from a zval, then to get your <code>my_own_object</code> you have to take the memory in the opposite direction, subtracting the offset (offset) of <code>zend_object</code> 'in the structure.  This is done using <code>OffsetOf()</code> from <a href="https://ru.wikipedia.org/wiki/Stddef.h">stddef.h</a> (if necessary, you can easily emulate).  This is considered the use of an advanced C-structure, but if you know the language you are using well (and it shouldn't be any other way), then you probably already had to do this. <br><br>  To get a custom object in PHP 7, do the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> zend_object *zobj; my_own_object *my_obj; zobj = Z_OBJ_P(this_zval); my_obj = (my_own_object *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)zobj - XoffsetOf(struct my_own_object, zobj));</code> </pre><br>  Here, the use of <code>offsetof()</code> introduces some confusion: <b><code>your_custom_struct</code> should be the last component of <code>zend_object</code></b> .  Obviously, if you declare types after this, then due to the <code>zend_object</code> organization of the placement of <code>zend_object</code> in PHP 7, you will later have difficulty accessing these types. <br><br>  Do not forget that in PHP 7 <code>zend_object</code> now uses a structural hack.  This means that the allocated memory will differ from <code>sizeof(zend_object)</code> .  <code>zend_object</code> placement: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 5 */</span></span> zend_object *zobj; zobj = ecalloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_object)); <span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> zend_object *zobj; zobj = ecalloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_object) + zend_object_properties_size(ce));</code> </pre><br>  Since your class knows everything about the declared attributes, it determines the size of the memory that you must allocate for the components. <br><br><h1>  Object creation </h1><br>  Consider a real example.  Suppose we have a custom object: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_own_object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *my_custom_buffer; zend_object zobj; <span class="hljs-comment"><span class="hljs-comment">/* MUST be the last element */</span></span> } my_own_object;</code> </pre><br>  This is what its <code>create_object()</code> handler might look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> zend_object *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_create_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_class_entry *ce)</span></span></span><span class="hljs-function"> </span></span>{ my_own_object *my_obj; my_obj = ecalloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(my_obj) + zend_object_properties_size(ce)); my_obj-&gt;my_custom_buffer = emalloc(<span class="hljs-number"><span class="hljs-number">512</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ,      512  */</span></span> zend_object_std_init(&amp;my_obj-&gt;zobj, ce); <span class="hljs-comment"><span class="hljs-comment">/*      zend_object! */</span></span> object_properties_init(&amp;my_obj-&gt;zobj, ce); my_obj-&gt;zobj.handlers = &amp;my_class_handlers; <span class="hljs-comment"><span class="hljs-comment">/*     ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;my_obj-&gt;zobj; }</code> </pre><br>  Unlike PHP 5, you should not forget about the amount of memory allocated: remember the structural hack, replacing the properties of <code>zend_object</code> .  In addition, object storage is no longer used here.  In PHP 5, an object creation handler had to register it with the repository, and then pass some function pointers for future destruction and release of the object.  In PHP 7, this no longer needs to be done, the <code>create_object()</code> function works much more clearly. <br><br>  To use this custom handler, <code>create_object()</code> need to declare it in your extension.  Thus, you will declare each handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> zend_class_entry *my_ce; zend_object_handlers my_ce_handlers; PHP_MINIT_FUNCTION(my_extension) { zend_class_entry ce; INIT_CLASS_ENTRY(ce, <span class="hljs-string"><span class="hljs-string">"MyCustomClass"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); my_ce = zend_register_internal_class(&amp;ce); my_ce-&gt;create_object = my_create_object; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;my_ce_handlers, zend_get_std_object_handlers(), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(my_ce_handlers)); my_ce_handlers.free_obj = my_free_object; <span class="hljs-comment"><span class="hljs-comment">/*  free */</span></span> my_ce_handlers.dtor_obj = my_destroy_object; <span class="hljs-comment"><span class="hljs-comment">/*  dtor */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   my_ce_handlers.clone_obj,        */</span></span> my_ce_handlers.offset = XtOffsetOf(my_own_object, zobj); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br>  As you can see, in MINIT we declare <code>free_obj()</code> and <code>dtor_obj()</code> .  In PHP 5, when registering an object in the repository, both of them need to be declared in <code>zend_objects_store_put()</code> , but <b>in PHP 7 this is no longer necessary</b> .  Now <code>zend_object_std_init()</code> will write the object to the storage itself; you do not need to do this manually, so do not forget about this call. <br><br>  So, we have registered our <code>free_obj()</code> and <code>dtor_obj()</code> , as well as the offset component, used when calculating the location of our custom object in memory.  <b>This information is needed by the engine, because now it is he who deals with the release of objects, not you</b> .  In PHP 5, this was done manually, usually with <code>free()</code> .  And since now it makes the engine, then to release the entire pointer, it needs to get not only the <code>zend_object</code> types, but also the <code>offset</code> value for your custom structure.  An example can be found <a href="">here</a> . <br><br><h1>  Destruction of an object </h1><br>  I want to remind you that the destructor is called when an object is destroyed at the PHP user level, just like <code>__destruct()</code> called.  So in case of critical errors, the destructor may not be called at all, and in PHP 7 this situation has not changed.  If you have carefully studied the post that was mentioned at the beginning, or <a href="http://fr.slideshare.net/jpauli/understanding-php-objects">this presentation</a> , then, most likely, remember that the destructor should not leave the object in an unstable state, since the object once destroyed should be available in certain situations.  Therefore, in PHP, handlers for the destruction and release of an object are separated from each other.  The release handler is called when the engine is completely sure that the object is not used anywhere else.  The destructor is called when the refcount of the object reaches 0, but since some custom code ( <code>__destruct()</code> ) can be executed, the current object cannot be reused anywhere as a reference, which means it must remain in an unstable state.  Therefore, be very careful if you release the memory with a destructor.  Usually the destructor stops using resources, but does not free them.  The release handler is already doing this. <br><br>  So let's summarize the work of the destructor: <br><ul><li>  It is either not called at all, <b>or it</b> is called once (most often), but never more than once.  In case of a critical error, the destructor is not called. </li><li>  The destructor does not release resources, because in some rare cases the object <b>can be</b> reused by the engine. </li><li>  If you do not call <code>zend_objects_destroy_object()</code> from your custom destructor, the custom <code>__destruct()</code> will not be initiated. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_destroy_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_object *object)</span></span></span><span class="hljs-function"> </span></span>{ my_own_object *my_obj; my_obj = (my_own_object *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)object - XoffsetOf(my_own_object, zobj)); <span class="hljs-comment"><span class="hljs-comment">/*    -   my_obj-&gt;my_custom_buffer,     ,    ,   -.     . */</span></span> zend_objects_destroy_object(object); <span class="hljs-comment"><span class="hljs-comment">/*  __destruct()    */</span></span> }</code> </pre><br><h1>  Object storage release </h1><br>  The storage release function is initiated by the engine when it is absolutely sure that the object is not used anywhere else.  Just before the object is destroyed, the engine calls the <code>free_obj()</code> handler.  Have you allocated any resources in your custom <code>create_object()</code> handler?  It is time to release them: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP 7 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_free_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_object *object)</span></span></span><span class="hljs-function"> </span></span>{ my_own_object *my_obj; my_obj = (my_own_object *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)object - XoffsetOf(my_own_object, zobj)); efree(my_obj-&gt;my_custom_buffer); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> zend_object_std_dtor(object); <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> }</code> </pre><br>  And that's all.  You no longer need to deal with the release yourself, as in PHP 5. Previously, the handler ended up with something like <code>free(object)</code> ;  Now, a place for your custom object structure is allocated in the <code>create_object()</code> handler, but when you pass the <code>offset</code> value to MINIT, it gets the opportunity to release itself.  For example, like <a href="">here</a> . <br><br>  Of course, in many cases, the <code>free_obj()</code> handler is called immediately after the <code>dtor_obj()</code> handler.  The exception is when a user destructor sends $ this to someone or in the case of a custom extension object that is poorly designed.  If you are interested in the complete code sequence when the object is freed by the engine, read about <a href=""><code>zend_object_store_del()</code></a> . <br><br><h1>  Conclusion </h1><br>  We looked at how work with objects changed in PHP 7.  At the user level, everything remained virtually unchanged, only the object model was optimized: it began to work faster and has a little more features.  But there are no significant innovations. <br><br>  But ‚Äúunder the hood‚Äù of change is much more.  They are also not too large and will not require you many hours of study, but still you will need to make some effort.  Both object models have become incompatible at a low level, so you have to rewrite that part of the source code of your extensions that relates to objects.  In this post I tried to explain the difference.  If in development you switch to PHP 7, you will notice that it has become clearer and more structured compared to PHP 5. The new version has freed itself from a heavy ten-year legacy.  Many things in PHP 7 have been improved and redesigned to eliminate the need for code patches in a number of cases. </div><p>Source: <a href="https://habr.com/ru/post/275497/">https://habr.com/ru/post/275497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275487/index.html">Statistical analysis in PostgreSQL using PL / R</a></li>
<li><a href="../275489/index.html">The story of one progress bar</a></li>
<li><a href="../275491/index.html">VIPER or what everyone is talking about, but no one talks</a></li>
<li><a href="../275493/index.html">Interface design under Microsoft Lync or system visualization from scratch</a></li>
<li><a href="../275495/index.html">3D at school: who, what and how should be taught?</a></li>
<li><a href="../275499/index.html">Five-year postponement for Ukrainian enterprises: the action ends on 12/31/2016</a></li>
<li><a href="../275501/index.html">New lectures, courses, discounts and other updates</a></li>
<li><a href="../275503/index.html">Why is it difficult to program the UI and how does the perfect framework look like?</a></li>
<li><a href="../275505/index.html">Have you thought about the safety of ... a car?</a></li>
<li><a href="../275507/index.html">Search for a variety of regular expressions using the Hyperscan library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>