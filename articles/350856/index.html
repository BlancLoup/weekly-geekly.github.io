<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interface Composition in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most enjoyable Go concepts for me is the ability to compose interfaces. In this article we will discuss a small example of using this featu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interface Composition in Go</h1><div class="post__text post__text-html js-mediator-article">  One of the most enjoyable Go concepts for me is the ability to compose interfaces.  In this article we will discuss a small example of using this feature of the language.  To do this, we present a hypothetical scenario in which two structures process user data and execute http requests. <br><a name="habracut"></a><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//      Sync struct { client HTTPClient } ) //    Sync func NewSync(hc HTTPClient) *Sync { return &amp;Sync{hc} } //        func (s *Sync) Sync(user *User) error { res, err := s.client.Post(syncURL, "application/json", body) //   res  err return err }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//       Store struct { client HTTPClient } ) //    Store func NewStore(hc HTTPClient) *Store { return &amp;Store{hc} } //       func (s *Store) Store(user *User) error { res, err := s.client.Get(userResource) //   res  err res, err = s.client.Post(usersURL, "application/json", body) //   res  err return err }</span></span></code> </pre><br>  The <b>Sync</b> and <b>Store</b> structures are responsible for operations with users in our system.  In order for them to perform http requests, they need to be passed a structure that satisfies the <b>HTTPClient</b> interface.  This is what it is: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//   http    HTTPClient interface { //  POST- Post(url, contentType string, body io.Reader) (*http.Response, error) //  GET- Get(url string) (*http.Response, error) } )</span></span></code> </pre><br>  So, we have two structures, each doing one thing and doing it well, and both of them depend on only one interface argument.  It looks like easy-to-test code, because all we need is to create a stub for the <b>HTTPClient</b> interface.  The unit test for <b>Sync</b> can be implemented as follows: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestUserSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(HTTPClientMock) client.PostFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, contentType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*http.Response, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// check if args are the expected return &amp;http.Response{StatusCode: http.StatusOK}, nil } syncer := NewSync(client) u := NewUser("foo@mail.com", "de") if err := syncer.Sync(u); err != nil { t.Fatalf("failed to sync user: %v", err) } if !client.PostInvoked { t.Fatal("expected client.Post() to be invoked") } } type ( HTTPClientMock struct { PostInvoked bool PostFunc func(url, contentType string, body io.Reader) (*http.Response, error) GetInvoked bool GetFunc func(url string) (*http.Response, error) } ) func (m *HTTPClientMock) Post(url, contentType string, body io.Reader) (*http.Response, error) { m.PostInvoked = true return m.PostFunc(url, contentType, body) } func (m *HTTPClientMock) Get(url string) (*http.Response, error) { return nil, nil}</span></span></code> </pre><br>  Such a test works fine, but you should pay attention to the fact that <b>Sync</b> does not use the <b>Get</b> method from the <b>HTTPClient</b> interface <b>.</b> <br><blockquote>  Clients should not depend on methods that they do not use.  Robert Martin </blockquote>  Also, if you want to add a new method to the <b>HTTPClient</b> , you will also have to add it to the <b>HTTPClientMock</b> stub, which degrades the readability of the code and complicates its testing.  Even if you just change the signature of the <b>Get</b> method, it still affects the test for the <b>Sync</b> structure, despite the fact that this method is not used.  From such dependencies should get rid of. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In our example, we need to implement only two methods for the <b>HTTPClient</b> interface <b>stub</b> .  But imagine that your hypothetical handler should receive messages from the queue and save them to the database: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( AMQPHandler <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { repository Repository } Repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Add(user *User) error FindByID(ID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*User, error) FindByEmail(email <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*User, error) FindByCountry(country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*User, error) FindByEmailAndCountry(country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*User, error) Search(...CriteriaOption) ([]*User, error) Remove(ID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) error <span class="hljs-comment"><span class="hljs-comment">//   //   //   // ... } ) func NewAMQPHandler(r Repository) *AMQPHandler { return &amp;AMQPHandler{r} } func (h *AMQPHandler) Handle(body []byte) error { //   if err := h.repository.Add(user); err != nil { return err } return nil }</span></span></code> </pre><br>  To save user data to the <b>AMQPHandler</b> database, <b>you</b> only need the <b>Add</b> method, but, as you probably guessed, the <b>Repository</b> interface stub for testing will look threatening: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( RepositoryMock <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { AddInvoked <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> } ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { r.AddInvoked = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindByID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindByEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindByCountry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(country </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindByEmailAndCountry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email, country </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...CriteriaOption)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Due to a similar error in the design of the application, we have no other choice how to implement all the methods of the <b>Repository</b> interface every time.  But according to Go philosophy, interfaces, as a rule, should be small, consist of one or two methods.  In this light, the implementation of the <b>Repository</b> looks completely redundant. <br><blockquote>  The larger the interface, the weaker the abstraction.  Rob Pike </blockquote>  Returning to the user management code, both the <b>Post</b> and <b>Get</b> methods are needed only to store data ( <b>Store</b> ), and only the <b>Post</b> method is enough for synchronization.  Let's fix the <b>sync</b> implementation with this fact: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//      Sync struct { client HTTPPoster } ) //    Sync func NewSync(hc HTTPPoster) *Sync { return &amp;Sync{hc} } //        func (s *Sync) Sync(user *User) error { res, err := s.client.Post(syncURL, "application/json", body) //   res  err return err }</span></span></code> </pre><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestUserSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(HTTPPosterMock) client.PostFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, contentType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*http.Response, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// assert the arguments are the expected return &amp;http.Response{StatusCode: http.StatusOK}, nil } syncer := NewSync(client) u := NewUser("foo@mail.com", "de") if err := syncer.Sync(u); err != nil { t.Fatalf("failed to sync user: %v", err) } if !client.PostInvoked { t.Fatal("expected client.Post() to be invoked") } } type ( HTTPPosterMock struct { PostInvoked bool PostFunc func(url, contentType string, body io.Reader) (*http.Response, error) } ) func (m *HTTPPosterMock) Post(url, contentType string, body io.Reader) (*http.Response, error) { m.PostInvoked = true return m.PostFunc(url, contentType, body) }</span></span></code> </pre><br>  Now we do not need to deal with the redundant <b>HTTPClient</b> interface, this approach simplifies testing and avoids unnecessary dependencies.  <b>Also</b> , the purpose of the argument for the <b>NewSync</b> designer <b>has</b> become much clearer. <br><br>  Now let's see what a test for <b>Store</b> can look like, using both methods from the <b>HTTPClient</b> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestUserStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { client := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(HTTPClientMock) client.PostFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, contentType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*http.Response, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// assertion omitted return &amp;http.Response{StatusCode: http.StatusOK}, nil } client.GetFunc = func(url string) (*http.Response, error) { // assertion omitted return &amp;http.Response{StatusCode: http.StatusOK}, nil } storer := NewStore(client) u := NewUser("foo@mail.com", "de") if err := storer.Store(u); err != nil { t.Fatalf("failed to store user: %v", err) } if !client.PostInvoked { t.Fatal("expected client.Post() to be invoked") } if !client.GetInvoked { t.Fatal("expected client.Get() to be invoked") } } type ( HTTPClientMock struct { HTTPPosterMock HTTPGetterMock } HTTPPosterMock struct { PostInvoked bool PostFunc func(url, contentType string, body io.Reader) (*http.Response, error) } HTTPGetterMock struct { GetInvoked bool GetFunc func(url string) (*http.Response, error) } ) func (m *HTTPPosterMock) Post(url, contentType string, body io.Reader) (*http.Response, error) { m.PostInvoked = true return m.PostFunc(url, contentType, body) } func (m *HTTPGetterMock) Get(url string) (*http.Response, error) { m.GetInvoked = true return m.GetFunc(url) }</span></span></code> </pre><br>  Frankly, I did not invent this approach.  This can be seen in the standard Go library, <b>io.ReadWriter</b> well illustrates the principle of interface composition: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ReadWriter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Reader Writer }</code> </pre><br>  This way of organizing interfaces makes dependencies more explicit in code. <br><br>  An astute reader probably caught a hint of TDD in my example.  Indeed, without unit tests, it is difficult to achieve such a design from the first attempt.  It is also worth noting the lack of external dependencies on the tests, this approach I spied from <a href="https://medium.com/%40benbjohnson">Ben Johnson</a> . <br><br>  Are you curious about how the <b>HTTPClient</b> implementation will look like? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//   http- HTTPClient struct { req *Request } //    http- Request struct{} ) //   HTTPClient func New(r *Request) *HTTPClient { return &amp;HTTPClient{r} } //  Get- func (c *HTTPClient) Get(url string) (*http.Response, error) { return c.req.Do(http.MethodGet, url, "application/json", nil) } //  Post- func (c *HTTPClient) Post(url, contentType string, body io.Reader) (*http.Response, error) { return c.req.Do(http.MethodPost, url, contentType, body) } //  http- func (r *Request) Do(method, url, contentType string, body io.Reader) (*http.Response, error) { req, err := http.NewRequest(method, url, body) if err != nil { return nil, fmt.Errorf("failed to create request %v: ", err) } req.Header.Set("Content-Type", contentType) return http.DefaultClient.Do(req) }</span></span></code> </pre><br>  This is easy - just implement the methods for <b>Post</b> and <b>Get</b> .  Note that the constructor does not return an interface and a specific type; this approach is <a href="https://github.com/golang/go/wiki/CodeReviewComments">recommended</a> in Go.  And the interface must be declared in the consumer packet that will use the <b>HTTPClient</b> .  In our case, the <b>user</b> package can be called: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ( <span class="hljs-comment"><span class="hljs-comment">//      User struct { Email string `json:"email"` Country string `json:"country"` } //   HTTPClient interface { HTTPGetter HTTPPoster } //   Post- HTTPPoster interface { Post(url, contentType string, body io.Reader) (*http.Response, error) } //   Get- HTTPGetter interface { Get(url string) (*http.Response, error) } )</span></span></code> </pre><br>  And, finally, <b>let's put it</b> all together in <b>main.go</b> <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { req := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(httpclient.Request) client := httpclient.New(req) _ = user.NewSync(client) _ = user.NewStore(client) <span class="hljs-comment"><span class="hljs-comment">//   Sync  Store }</span></span></code> </pre><br>  I hope this example will help you start using the <a href="https://dave.cheney.net/2016/08/20/solid-go-design">principle of separation of interfaces</a> in order to write a more idiomatic Go code that is easy to test and with explicit dependencies.  In the next article, I will add in the <b>HTTPClient</b> logic for processing failures and re-sending, stay connected. <br><br>  The complete source code for <a href="https://github.com/rafaeljesus/composing-go-example">the example implementation</a> . <br><br>  Special thanks to my friends <a href="https://github.com/bastiankoetsier">Bastian</a> and <a href="https://github.com/FelipeUmpierre">Felipe</a> for reviewing this article. </div><p>Source: <a href="https://habr.com/ru/post/350856/">https://habr.com/ru/post/350856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350846/index.html">Using the render props template outside of the render</a></li>
<li><a href="../350848/index.html">Women in IT, an inside look</a></li>
<li><a href="../350850/index.html">Do you really need Redux?</a></li>
<li><a href="../350852/index.html">Information security of bank non-cash payments. Part 3 - Formation of requirements for the protection system</a></li>
<li><a href="../350854/index.html">FastTrack Training. "Network Basics". "Basics of data centers." Part 1. Eddie Martin. December 2012</a></li>
<li><a href="../350858/index.html">Writing Telegram-bot for Habrahabr</a></li>
<li><a href="../350860/index.html">How big data will change the automotive industry</a></li>
<li><a href="../350862/index.html">Tutorial: Using Thymeleaf</a></li>
<li><a href="../350864/index.html">Thymeleaf Tutorial: Chapter 1. Introduction</a></li>
<li><a href="../350866/index.html">Thymeleaf Tutorial: Chapter 2. A Thymes Good Virtual Grocery Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>