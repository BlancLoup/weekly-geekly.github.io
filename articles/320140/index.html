<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classical labyrinth generation algorithms. Part 1: introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Writing an article led me to the almost complete lack of materials in Russian about labyrinth generation algorithms. On Habr√©, from what is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classical labyrinth generation algorithms. Part 1: introduction</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f95/53e/b6f/f9553eb6f4a3413481f66a89a8759e9d.png"><br><br><h2>  Foreword </h2><br>  Writing an article led me to the almost complete lack of materials in Russian about labyrinth generation algorithms.  On Habr√©, from what is generally on the topic, two articles can be noted: <a href="https://habrahabr.ru/post/176671/">one</a> and <a href="https://habrahabr.ru/post/262345/">two</a> .  The value and benefits of which is only the second.  In the first, just a translation of the formal algorithm and a small explanation of it.  Which, of course, not bad, but very poorly and does not cause the desire to study the topic further. <br><br>  If you like my article, I will continue to write about various algorithms.  We will look at two of the most primitive and simple cases - the generation of a binary tree and Sidewinder, which, in its essence, is just a slightly modified version of a binary tree with one noticeable plus.  <b>CAUTION TRAFFIC</b> . <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will give one piece of advice - do not peek into the code until you write your implementation.  You will get much more pleasure and benefit from fixing bugs and finding errors than if you simply translate from one language to another. <br><br>  Seriously.  Listen to the advice.  You, truly, will spend more time, but it costs.  For example, because of a couple of errors, I had a very funny generator of ‚Äúalien‚Äù texts, which can be used in various Sci-Fi games to create text.  I hope you study the topic for yourself and do not hurry anywhere. <br><br>  <b>PS:</b> <br><br>  I will use the term " <b>bias</b> ", assuming English bias.  Those.  addiction of the algorithm to directivity in any direction.  For example, the right offset - the algorithm generates mazes with long right passes. <br><br>  The coloring of the labyrinths occurs relative to the distance from the extreme left corner of the field to a certain cell.  The farther from the initial coordinate - the darker the color will be. <br><br>  <b>An ideal maze</b> is a maze in which one cell is connected to another by one single path.  In other words, spanning tree. <br><br><div class="spoiler">  <b class="spoiler_title">Pro lua</b> <div class="spoiler_text">  When I first began to dig in the topic of labyrinths, I didn‚Äôt assume that I‚Äôll end up writing an article and chose a language in which I have the opportunity not to spend too much time on rendering and architecture and only do logic.  As a result, between C ++ and Lua, the choice fell on Lua and Love2D. <br><br>  Do not worry if you are unfamiliar with Lua.  Ignorance of the language does not hurt you to understand the implementation, thanks to the simplicity of the syntax.  If you are able to program at least a little, 80% of the code will not cause you problems with understanding.  The remaining 20% ‚Äã‚Äãare language specific, about which I will always write articles at the beginning, explaining their work. <br><br>  The first thing I should say is: <br>  Lua has only one data structure ‚Äî tables ‚Äî an associative array, with which we create the structures we need.  For example, classes, sets, ordinary arrays, stacks, queues, and the like.  We can access them either with the help of small-keys, or with the help of indexes. <br>  Also, the tables do not limit us in storing only one type of data in one object and work like structures in C / C ++.  This code is absolutely correct: <br><br><pre><code class="lua hljs">ourStructure = {} ourStructure[‚ÄúBeautyKey‚Äù] = <span class="hljs-number"><span class="hljs-number">42</span></span> ourStructure[<span class="hljs-number"><span class="hljs-number">42</span></span>] = ‚ÄúUltimateAnswer‚Äù ourStructure[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Assigning nil will remove the field: <br><pre> <code class="lua hljs">ourStructure[<span class="hljs-number"><span class="hljs-number">42</span></span>] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br><br>  Second: <br>  Lua does not have a hidden table copying mechanism.  The code below will not copy and create a new SomeNewArray object, it only copies the link to the SomeArray object into it, and, therefore, will change it just as if you pass the value through a non-constant link or pointer in C / C ++: <br><br><pre> <code class="lua hljs">someArray = {} someArray[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span> someArray[<span class="hljs-number"><span class="hljs-number">2</span></span>] = ‚ÄúReferencesTest‚Äù someNewArray = someArray someNewArray[<span class="hljs-number"><span class="hljs-number">1</span></span>] = ‚Äú<span class="hljs-number"><span class="hljs-number">42</span></span> Is Gone, Now Only the Garbage-String here‚Äù</code> </pre> <br><br>  And third, for those who are well acquainted with Lua: <br>  Yes, I know that in some places the code is redundant.  And the fact that in some places everything could be simplified by metamethods, too.  It should be borne in mind that the code was written primarily to deal with the algorithms, and not for use in a real project.  In addition, the absence of an excess of language-specific functions allows you to lay out the code in the form in which it is, without a pile of comments. <br><br></div></div><br><h2>  <b>Binary tree algorithm</b> </h2><br><img src="https://habrastorage.org/files/1b0/5e0/f47/1b05e0f47a7942389eef48eec6fea19e.png"><br><br><img src="https://habrastorage.org/files/77e/0e3/dcd/77e0e3dcd78748ee86a7969bc104645e.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/35c/76c/92a/35c76c92a18c4d318dc415cde6443dec.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/df9/1e6/2a0/df91e62a01d6467985ece549f8919c90.gif"></div><br>  <b>Description</b> : <br><br>  The very first and easiest algorithm in the understanding, which I will consider.  Its essence lies in paving the way in a random direction from each cell of the field: in my implementation, either upward or to the right (depending on the offset chosen by you).  We process only 1 cell per unit of time, therefore, we can generate mazes of infinite size, keeping only the final result (maze) without the need to store any side information. <br><br>  This generation method has two side effects: <br><br>  1. Labyrinths have a strong diagonal displacement and no dead ends in its direction.  Look at the screenshots above and you will see that each of the corridors tends to the right upper cell, and, as a result, it has exactly one path to it, and there is no dead end anywhere on the path: <br><br>  2. Two empty corridors on the sides of the maze.  When the algorithm ‚Äúdigs through‚Äù to the end of the row / column, it has no choice but to continue the path in one single direction, creating empty ‚Äúborders‚Äù. <br><br>  By the way, the name does not just coincide with the data structure.  The result of his work is a random binary tree, in which from each cell (vertex) there is exactly 1 path towards the root (parent vertex), and, accordingly, exactly 1 path to any other cell.  As a result, any cell has no more than 3 connections with its neighbors. <br><br>  <b>Formal algorithm (for northeast offset):</b> <br><br><ol><li>  Select the starting cell; </li><li>  Choose a random direction for paving the way.  If a neighboring cell in this direction extends beyond the field, dig a cage in the only possible direction; </li><li>  Go to the next cell; </li><li>  Repeat 2-3 until all cells are processed; </li></ol><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  Green - the current cell under consideration, red - the front, the cells into which you can move. <br><br>  We start with the coordinate (0; 0).  We cannot go up in this row, because otherwise we will go beyond the boundaries of the maze.  We go to the right until it stops, on the way tearing down all the walls. <br><br><img src="https://habrastorage.org/files/2ca/dc9/d72/2cadc9d7214045acaeee915e30f7fa23.png"><br><br><img src="https://habrastorage.org/files/6f2/d9b/e11/6f2d9be110f7482d949940c8e5f13e06.png"><br><br>  Everything is a dead end.  Nowhere to go.  Move to the next row and see that now there is an opportunity to go up and to the right. <br><br><img src="https://habrastorage.org/files/63a/67c/2dc/63a67c2dc1f24f7eacdd387bd82cd0e8.png"><br><br>  We throw a coin and choose ... Top.  We remove the wall and proceed to the next cell. <br><img src="https://habrastorage.org/files/5b9/63e/8cd/5b963e8cdb04457e8647e70269103aee.png"><br><br>  Fine.  Case prompts us to go to the right.  Remove the wall and move to the next cell. <br><br><img src="https://habrastorage.org/files/f44/ad9/f98/f44ad9f9855043f49b0cb70a6cb482b7.png"><br><br><img src="https://habrastorage.org/files/880/f69/003/880f69003276475dac6f3c444f388238.png"><br><br><img src="https://habrastorage.org/files/daf/a13/6ac/dafa136acebb41f79ffa9a9f7ba496ee.png"><br><br>  We have no choice, we cannot go to the left, which means we remove the wall from above and go to the next row. <br><br><img src="https://habrastorage.org/files/f17/559/c5a/f17559c5a797438bbd28d39874403e95.png"><br><br><img src="https://habrastorage.org/files/1b0/ce0/82f/1b0ce082f5e0410ab00fab729bd9ea1b.png"><br><br>  The coin convinces us to go to the right.  Well, obey.  We remove the wall and proceed to the next cell. <br><br><img src="https://habrastorage.org/files/c06/086/b41/c06086b41af94896abc16bc13f5e45c7.png"><br><br><img src="https://habrastorage.org/files/596/3dc/b56/5963dcb567344522bbc274d3fce17be6.png"><br><br>  A meter rolled, our unfortunate piece of metal falls and says it's time to go upstairs.  We demolish the wall, step to the next cell, and, since it is extreme in this row, remove the wall from above.  Labyrinth is over. <br><br><img src="https://habrastorage.org/files/322/cbb/810/322cbb810a4142e3acb57dda8bf91603.png"><br><br><img src="https://habrastorage.org/files/263/6f5/ad2/2636f5ad26b14b4bb95f1e2a4ebe6a59.png"><br><br><img src="https://habrastorage.org/files/210/119/4f5/2101194f5abc40d69cd70dcd629cbec7.png"><br></div></div><br>  <b>Pros</b> : <br><ul><li>  Simple implementation; </li><li>  High speed; </li><li>  The ability to generate endless labyrinths; </li></ul><br>  <b>Cons</b> : <br><ul><li>  Low complexity of the pattern; </li><li>  Strong offset diagonally; </li><li>  No deadlocks on the offset; </li><li>  The monotony of the generated mazes; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> aux = {} aux.width = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.height = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sx = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sy = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.createGrid</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, columns)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> MazeGrid = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>, rows <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y] = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, columns <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y][x] = {bottom_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, right_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>} <span class="hljs-comment"><span class="hljs-comment">-- Wall grid end end return MazeGrid end -- Binary Tree North-East variant function mod.createMaze(x1, y1, x2, y2, grid) aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid or aux.createGrid(aux.height, aux.width) aux.binarytree() return aux.grid end function aux.binarytree() for y = aux.sy, aux.height do for x = aux.sx, aux.width do if y ~= aux.sy then if math.random(0, 1) == 0 then if x ~= aux.width then aux.grid[y][x].right_wall = false else aux.grid[y-1][x].bottom_wall = false end else aux.grid[y-1][x].bottom_wall = false end else if x ~= aux.width then aux.grid[y][x].right_wall = false end end end end end return mod</span></span></code> </pre><br></div></div><br><h2>  <b>Algorithm "Sidewinder"</b> </h2><br><img src="https://habrastorage.org/files/2ef/18c/13a/2ef18c13aaaf42e8834a61e827bc6046.png"><br><br><img src="https://habrastorage.org/files/b7d/851/357/b7d851357374412cbb4aeb2d2f035389.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f76/e47/074/f76e4707441c42c7bc85c79554a14d65.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d8b/680/72a/d8b68072a6b6471393d288fa5e6fd38f.gif"></div><br>  <b>Description</b> : <br><br>  The algorithm with the untranslatable name Sidewinder is very similar in its work to the binary tree algorithm, in that there is no characteristic bias along the diagonal, one empty corridor and a cell, we consider not individually, but sets.  Labyrinths are obtained with a predominantly vertical or horizontal displacement (depending on the implementation), with no dead ends in their direction.  Compared with its more primitive fellow, the displacement is not so noticeable and more like a ‚Äúspiral‚Äù that smoothly replaces vertical and horizontal corridors. <br><br>  As for side effects, Sidewinder creates only one empty corridor on one side, instead of two.  Starting the creation of sets from the first row of the field, we do not have the opportunity to dig up the path, since we are in the most extreme vertical position and trying to go higher will result in going beyond the field boundaries.  But even if we organize sets without going vertically, we will create several regions isolated from each other. <br><br>  For example: 9 cells of the first row can be divided into three sets, between which walls are located.  Each set of the second row will dig through the path to one of the three ‚Äúblocks‚Äù above.  The third row will pave the way for the "blocks" of the second.  And so on until the end of the field.  As a result, we will have 3 branched, isolated from each other vertical areas, which is not suitable for a perfect maze, in which from each point of the field there is exactly 1 way to any other. <br><br>  <b>Formal algorithm (for standard offset):</b> <br><br><ol><li>  Select the starting row; </li><li>  Select the starting cell of the row and make it current; </li><li>  Initialize empty set; </li><li>  Add the current cell to the set; </li><li>  Decide whether to pave the right; </li><li>  If laid, then go to the new cell and make it current.  Repeat steps 3-6; </li><li>  If not paved, choose a random cell of the set and pave the way up from there.  Go to the next row and repeat 2-7; </li><li>  Continue until each row has been processed; </li></ol><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  Red cells are members of the set. <br>  We start from the first row and see that above us is going beyond the field.  We demolish all the walls and go immediately to the second row, create an empty set. <br><br><img src="https://habrastorage.org/files/102/2a3/a9e/1022a3a9e3384f01aa161bdbe30fd2c1.png"><br><br><img src="https://habrastorage.org/files/68e/627/bae/68e627bae0ea4d8a85d03fb9392349ee.png"><br><br>  So, and here it is more interesting.  Let's add to the set the first two cells of the row. <br><br><img src="https://habrastorage.org/files/6e7/bf4/5aa/6e7bf45aaf70424c86e24ed85b01d80c.png"><br><br>  Select one of these cells and remove the top wall belonging to it in the first row. <br><br><img src="https://habrastorage.org/files/e43/067/e32/e43067e32c744bb6a3150f4a149063a1.png"><br><br>  Reset the set, add the next cell of the row to it. <br><br><img src="https://habrastorage.org/files/932/2c2/060/9322c206053248d1a39c6c4c12393d40.png"><br><br>  This time we don‚Äôt unite with anyone, we just make our way up from this single cell. <br><br><img src="https://habrastorage.org/files/040/566/9c7/0405669c718c4cfa88b9f771ef0a39a6.png"><br><br>  We repeat our actions.  Reset the set, go to the next cell, add it ... And since it remains the last in a row, we also remove the wall from the top and go to the row below. <br><br><img src="https://habrastorage.org/files/335/4d7/4d3/3354d74d31b54681860ac490874f0574.png"><br><br><img src="https://habrastorage.org/files/867/90f/66c/86790f66c8c1433aae695925843ae65d.png"><br><br>  And now we immediately combine the first three cells into one set. <br><br><img src="https://habrastorage.org/files/85a/332/6ab/85a3326ab79147b19435da9e0f64a641.png"><br><br>  Randomly select a cell, in our case, the second one and remove the wall from the top to the previous row. <br><br><img src="https://habrastorage.org/files/2cd/3d9/2cd/2cd3d92cd8bc4846ab8185275e5e99b6.png"><br><br>  Well, here we again have no choice, remove the wall above and go to the row below. <br><br><img src="https://habrastorage.org/files/660/b8d/a55/660b8da559ba4e3fb9eec20894d8839d.png"><br><br><img src="https://habrastorage.org/files/ae3/348/21f/ae334821ff984b7dbc47404afa5c724c.png"><br><br>  This time, we will make the first cell the only one.  We remove the wall to the previous row and go further into the next cell. <br><br><img src="https://habrastorage.org/files/993/b8e/d5d/993b8ed5d3824143bb8a41400eecfa67.png"><br><br><img src="https://habrastorage.org/files/484/db2/b85/484db2b855d748e8a62d21f888e8a91a.png"><br><br>  Suppose you want at the end to combine the three cells. <br><br><img src="https://habrastorage.org/files/e37/8cc/6ae/e378cc6ae1704d97b5e6d276510460b1.png"><br><br>  And again we liked the middle cell from the set, from which we remove the wall to the top.  Everything, our labyrinth is ready. <br><br><img src="https://habrastorage.org/files/ee5/c1f/8dc/ee5c1f8dcdb8411e9de155bd198f2be2.png"></div></div><br>  <b>Pros</b> : <br><br><ul><li>  The ability to generate endless labyrinths; </li><li>  Only 1 empty corridor; </li><li>  A more complex picture, unlike the binary tree algorithm; </li></ul><br>  <b>Cons</b> : <br><br><ul><li>  More confusing implementation; </li><li>  No deadlocks on the offset; </li><li>  Strong vertical displacement; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> aux = {} aux.width = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.height = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sx = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sy = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.createGrid</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, columns)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> MazeGrid = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>, rows <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y] = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, columns <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y][x] = {bottom_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, right_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MazeGrid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mod.createMaze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x1, y1, x2, y2, grid)</span></span></span></span> aux.height, aux.width, aux.sx, aux.sy = y2, x2, x1, y1 aux.grid = grid <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> aux.createGrid(y2, x2) aux.sidewinder() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aux.grid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.sidewinder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> cx = aux.sx <span class="hljs-comment"><span class="hljs-comment">--[[ cx ‚Äì     x.         ,          ]]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y = aux.sy, aux.height <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = aux.sx, aux.width <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y ~= aux.sy <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x ~= aux.width <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[y][x].right_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> aux.grid[y<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(cx, x)].bottom_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x ~= aux.width <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cx = x+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cx = aux.sx <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x ~= aux.width <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[y][x].right_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre><br></div></div><br><h2>  <b>Epilogue</b> </h2><br>  I hope you liked the article and you learned new knowledge about the primitive procedural generation of labyrinths.  I chose the two most simple ones in the implementation and operation of the algorithm, so that it would be easier for newbies to ‚Äútouch‚Äù the topic and see if they want to study it further.  It is important for me to know whether people like Habrahabr are interested in such articles and whether to continue writing them.  For readers, I still have at least 9 classic algorithms worth considering.  Some of them are random wanderings around the field, such as, for example, the Prima or Wilson algorithm, some require more resources for work, as they work with graphs, for example, Eller and Kruskal, and some maintain a middle ground.  But this is not the end - I have such things in my sleeve as: polar (round) labyrinths, generation of labyrinths on different grids (hexes, triangles, etc.), masking labyrinths in inscriptions and forms, 2.5D labyrinths and 3D, theory labyrinths, statistical comparison of algorithms, combined generation algorithms.  In the end, we still have a huge variety of variations of the types of labyrinths.  For example, now we are considering ideal algorithms, in which from each point there is exactly one path to any other.  But there are also those that allow one cell to have several paths for any other!  For example, Quake, Doom, and other shooters in the emerging genre used such algorithms to generate levels, according to some rumors. <br><br>  Therefore, if you liked the article, the topic, and you want to see them further - then please write about it in the comments.  Also, I will be very happy to any criticism, both technically and in linguistic and stylistic. </div><p>Source: <a href="https://habr.com/ru/post/320140/">https://habr.com/ru/post/320140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320124/index.html">Overview of modern web desktops systems</a></li>
<li><a href="../320128/index.html">Entity Framework 6 extensions that you might not know about</a></li>
<li><a href="../320132/index.html">How to create in a large company a convenient workplace for distributed teams?</a></li>
<li><a href="../320134/index.html">The digest of interesting materials for the mobile # 187 developer (January 16-22)</a></li>
<li><a href="../320136/index.html">Cases: development of specifications and guidelines (web ui kit)</a></li>
<li><a href="../320142/index.html">What if in games to use a video card for physics, not for graphics</a></li>
<li><a href="../320148/index.html">Alcatel Lucent - setting dect-phone</a></li>
<li><a href="../320150/index.html">We break Android. How deep is the rabbit hole?</a></li>
<li><a href="../320152/index.html">Multithreading (concurrency) in Swift 3. GCD and Dispatch Queues</a></li>
<li><a href="../320156/index.html">Logging VPN Connections on the Cisco ASA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>