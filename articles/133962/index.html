<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the history of memcpy implementations and their performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="void * memcpy (void * destination, const void * source, size_t num); 
 It would seem that there is difficult? And about the implementations of this fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the history of memcpy implementations and their performance</h1><div class="post__text post__text-html js-mediator-article">  void * memcpy (void * destination, const void * source, size_t num); <br>  It would seem that there is difficult?  And about the implementations of this function, you can write a whole story. <br><br>  When I look at the window of my favorite desktop tool, the Vtune XE profiler, I often see that he once again discovered that he had spent a lot of time copying the memory.  It is usually written like this: clock ticks spent in libgcc / [g] libc / kernel memcpy - XX%. <br><br>  Perhaps that is why memcpy often corresponded, for example, similar <a href="https://lkml.org/lkml/2011/8/12/267">threads</a> often appear in <a href="https://lkml.org/lkml/2011/8/12/267">lkml</a> .  (More implementations, most likely, have only sorts).  It would seem, unlike sorting, where there are many options and algorithms for copying memory, everything is simple.  In fact, even if we are talking about correctness, not productivity, options are possible.  (In confirmation of this - a <a href="http://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D12518">discussion of the</a> epic bug with Linus Torvalds and Ulrich Drepper). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the time of 8086, that is, thirty-four years ago, the following code was inside the memcpy implementation: <br>  mov [E] SI, src <br>  mov [E] DI, ptr_dst <br>  mov [E] CX, len <br>  rep movsb <br>  (all checks, etc. are omitted hereafter for simplicity) <br><br>  What has changed since then?  Under the cut assembler code and a single image. <br><a name="habracut"></a><br>  In Agner Fogh‚Äôs <a href="http://www.agner.org/optimize/optimizing_assembly.pdf">Optimizing Assembly‚Äôs</a> classic work, there is a good (but not very detailed) explanation of most aspects of memcpy performance. <br><br>  In the mid-90s, programmers discovered that, despite the fact that new instructions do not always speed up the Internet, it is possible to use extended SIMD registers to copy memory faster than REP MOVS does. <br><br>  First, MMx registers were used as intermediate storage, then XMM.  Looking ahead, I will say that YMM has not reached. <br>  movups XMM [0-4], [src] (x4, full cache line) <br>  movups [dst], XMM [0-4] <br><br>  Then various combinations were added from [not] aligned reading, [aligning], and [not] aligned writing to memory, at best (SSE4.1) it turned out something like <br>  mov [nt] dqa XMM2, [src + i * 2] <br>  mov [nt] dqa XMM1, [src + i * 2 + 1] <br>  movdqa XMM1, XMM0 <br>  movdqa XMM0, XMM3 <br>  palignr XMM3, XMM2, shift <br>  palignr XMM2, XMM1, shift <br>  mov [nt] dqa [dst + i * 2], XMM2 <br>  mov [nt] dqa [dst + i * 2 + 1], XMM3 <br>  A minor complication is that the alignment instruction exists only with the immediate last operand (shift), because of this, the code is well blown up (see glibc).  By the way, starting with the Nehalem architecture, the unaligned access to the memory that the above code is fighting against is no longer the most important cause of the brakes, although it is not free. <br><br>  Thus, several memcpy implementations appeared, each of which worked faster on some processors, but more slowly on the others.  After some time, several options and code that chooses which one to invoke have <a href="http://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dtree%3Bf%3Dsysdeps/x86_64/multiarch%3Bhb%3DHEAD">snuck</a> into glibc.  Probably the CLR and JVM environments can also choose an efficient implementation of System.arraycopy on the fly.  In contrast to glibc, such SSE code doesn‚Äôt just vperyurit into the kernel.  It's still more interesting there, SIMD registers need to be saved, and this is not such a quick matter.  What is in Linux, what is in Windows. <br><br>  And recently, suddenly, once, and everything returned to normal.  (Maybe in order not to force rewriting memcpy to AVX?) For the latest processors, the classic implementation of memcpy is again the fastest.  So if someone has slept for 34 years, it's time to pull out the old code, and look victoriously at the colleagues who copied memcpy sequentially on MMX, SSE2, SSE3, SSE4.1. <br><br>  By the way, to make it even more interesting to test copying performance (especially in the context of real software), it can also be affected by non temporal reading and writing, restrictions on the speed of memory access, effects associated with the last-level shared cache, and DTLB misses. <br><br>  Findings. <br>  1. Writing the next implementation is now useless, std :: memcpy will remain effective using rep movs. <br>  2. For a history and performance review on older platforms, see this article and Agner Fog. <br>  3. On Atom, other X86 platforms and old (before Nekhalem) rep mov processors are still slow. <br><br>  Upd: <br>  As repeatedly asked in the comments, I drove a simple microbenchmark with a memcpy kilobyte pair with all the alignment combinations in the loop. <br>  The number is how many times the most advanced SSE4.1 code is faster than std :: memcpy, implemented through rep movs <br>  Bulldozer - 1.22x (thanks to <a href="http://habrahabr.ru/users/stepmex/" class="user_link">stepmex</a> for the data) <br>  Penryn - 1.6x <br>  Nehalem - 1.5x <br>  Sandy Bridge - 1.008x <br>  This benchmark is not particularly accurate, in the real software many other factors play a role, which I enumerated above in brief. </div><p>Source: <a href="https://habr.com/ru/post/133962/">https://habr.com/ru/post/133962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133954/index.html">Review of the book ‚ÄúProgramming the Arduino / Freeduino microcontroller cards‚Äù</a></li>
<li><a href="../133956/index.html">Creating a proxy dll to run DirectDraw games in the window</a></li>
<li><a href="../133957/index.html">Dense code and testing</a></li>
<li><a href="../133960/index.html">US Antimonopoly Committee authorized Google to buy Admeld</a></li>
<li><a href="../133961/index.html">Microdata & the microdata DOM API</a></li>
<li><a href="../133963/index.html">Skype vulnerability allows you to determine the IP address of a particular user.</a></li>
<li><a href="../133964/index.html">Glory 1809 - how a wrist watch is sorted out and what it consists of</a></li>
<li><a href="../133965/index.html">Ebay company announced ql.io programming language</a></li>
<li><a href="../133966/index.html">Privatbank and Visa Internet</a></li>
<li><a href="../133967/index.html">My look at ŒºHabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>