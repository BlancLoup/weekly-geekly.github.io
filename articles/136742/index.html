<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prolog - parse and language problems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grammar analysis is a topic that every programmer should know and orient. Precisely because we apply it every day. Yes, we do not write new languages ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prolog - parse and language problems</h1><div class="post__text post__text-html js-mediator-article">  Grammar analysis is a topic that every programmer should know and orient.  Precisely because we apply it every day.  Yes, we do not write new languages ‚Äã‚Äãor edit grammars every day, but we use regular expressions, think about complexity and computability, think about the number of lines of code that are directly related to grammars. <br><br>  The purpose of this article is to attempt to show connections in various fields of knowledge, such as programming and mathematics, philosophy and logic, as well as to demonstrate in action one of the most successful areas of the Prolog language application - grammatical analysis. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes it seems that in different sciences different terms are used to define the same object.  Then this inescapable feeling arises, somehow to unite everything, to classify what is quite difficult to do in practice.  After all, different scientific disciplines have different objects of study, different goals, methodologies and, most unpleasantly, specific terminology. <br><br>  This article will be considered one of the interdisciplinary objects - <b>language</b> .  In principle, it is clear why so many sciences are engaged in the language, because there would be no language - there would be no knowledge, there would be no reasonable person. <br><br><h3>  History tour </h3><h3><br></h3><h5>  Philosophy </h5><br>  Oddly enough, first you want to mention the philosophy, namely one of its directions of the XX century <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BE%25D1%2584%25D0%25B8%25D1%258F">Analytical philosophy</a> .  I think many programmers, mathematicians, do not take it seriously enough, although it would be worth it.  Many include learning new programming languages ‚Äã‚Äãin self-education, in my opinion, the inclusion of philosophy is to some extent necessary.  No wonder that PHD is a doctor of philosophical sciences. <br><br>  The specificity of analytic philosophy is that philosophers have focused not only on the consistency of statements and conclusions, but also on the expressiveness of truth in principle and the method of its transmission.  Simply put, the object of their study was a formal language.  Then the concepts of predicate logic and proof were introduced.  It is not surprising that such philosophers Russell, Frege, laid the foundation of mathematical logic and are rightly considered mathematicians. <br><br><h5>  Mathematical logic </h5><br>  In general, the need for the intervention of philosophy in mathematics has matured in the late 19th century.  As is well known, Euler proved a large number of theorems and statements, but at the same time he did not suffer from formalism at all.  That is, Euler could easily summarize the divergent rows without even introducing a definition on what basis this could be done.  No, he cited comments, reasoning, even more than Fermat, who left only notes in the margins, but still, such reasoning would not have been taken as evidence.  By the end of the 19th century, a crisis had matured in mathematics: there were such statements as the ‚Äúcontinuum hypothesis‚Äù, the problem of choice.  These statements could not be resolved unequivocally, since they evoked different associations with different people, in other words, some believed in the loyalty of the statements, and some did not.  Then mathematics took a course on formalism, after which basic problems emerged (relating real objects to numbers and other mathematical objects, checking axioms), but this was left to the discretion of philosophers.  From this point on, mathematics could be called the language of science. <br><br>  Mathematical logic immediately chose as its object not numbers or other objects, like other mathematical disciplines, but words and statements of some formal language.  In essence, the definition was given to <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25BE%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE">proof</a> , standard logical conclusions MP (Modus Ponens) and Gen (Generalization) were defined, and formal mathematical theories (numbers, groups) were described.  In general, we got the mathematics that we see now: with formal proofs and a posteriori checks (a priori, only axioms remain). <br><br>  Undoubtedly for mathematics, this immediately gave results.  Many programmers would have been distressed, but now all the evidence must be rewritten into a new language, but the mathematics of ‚Äúrefactoring‚Äù did not get scared and all were slowly rewritten by executing the program of <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582,_%25D0%2594%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25B4">Hilbert</a> .  In general, here we come very close to programming and to the collapse of formal mathematics.  In the 1930s, the 1st mathematician appeared, who began to examine evidence and theorems, not from a position of meaning, but from a position of senseless words and statements, subject to grammatical rules (axioms and rules of inference).  He set the rules and their properties more important than the words themselves, which was not quite usual for mathematics.  And having studied the properties of the rules, he generated a statement for which it was impossible to obtain / deduce proof.  It was <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C">G√∂del</a> . <br><br>  It is important to note here that in mathematical logic the notion of derivability means the same as provability.  Since we all know that proving theorems is very difficult and not subject to a machine, we can assume that the algorithmic task of checking that a word can be derived from a specific grammar is also not solvable.  That is, in general, what the program will bring to the console may not be known :) In the simplest case, it is unknown <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">whether the program will end or not</a> <br><br><h5>  Programming (Computer science) </h5><br>  It is not known why it was <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0_%25D0%25A2%25D1%258C%25D1%258E%25D1%2580%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Turing machines</a> that were chosen by default to assess the complexity of the algorithms.  There are at least 3 identical mathematical models: <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2584%25D0%25BC%25D1%258B_%25D0%259C%25D0%25B0%25D1%2580%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B0">Markov algorithms</a> , G√∂del functions, and <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_(%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8)">Partially recursive functions</a> (more applicable in mathematical logic). <br><br><h5>  Linguistics </h5><br>  Of course, speaking of language, it is impossible not to mention the achievements of linguists in this field.  Oddly enough, programmers use <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25BE%25D0%25BC%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">Chomsky's</a> classification when describing new grammars and understanding complexity.  So regular grammars are described by non-deterministic automata, which can be transformed into deterministic, context-free automata with a stack, and context-sensitive machines may require a full Turing machine.  A useful result in the theory of algorithms is that grammars of type 0 (the most complex) are necessary and sufficient for recognition by the Turing machine. <br><br>  To thoroughly and thoroughly understand all the terms listed above, a ‚Äúdragon book‚Äù will undoubtedly be required, as well as quite good books on discrete mathematics and mathematical logic, which naturally cannot be disclosed in one article.  The article assumes that the reader has an understanding of these concepts. <br><br><h3>  The description of the formal grammar in Prolog </h3><br>  Take the definition of a formal language: <br>  In mathematical logic and computer science, a formal language is a set of finite words (strings, chains) over a finite alphabet [ <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">Wikipedia</a> ]. <br><br>  First of all, we will not be interested in the language itself, but in the way it is assigned, more precisely, the grammar: <br>  A formal grammar, or simply a grammar in the theory of formal languages, is a way of describing a formal language, that is, distinguishing a certain subset from the set of all words of a certain finite alphabet.  Distinguish between generators and recognizers (or analytic) grammar - the first set the rules with which you can build any word of the language, and the second allow you to determine by this word whether it enters the language or not [ <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">Wikipedia</a> ]. <br><br>  Take the standard description of the grammar of the language of palindromes of even length: <br><pre><code class="hljs erlang-repl">S -&gt; a S a. S.</code> </pre> <br>  Small letters describe terminal symbols, and large products.  Surprisingly, how this syntax is initially close to Prolog: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">S</span></span> :- a, S, a. S.</code> </pre><br><br>  Of course, the semantic load is completely different, but there is an absolute similarity in the execution of the program.  This grammar is context-free and if for its analysis to use the LL-analyzer, the analysis execution steps will fully coincide with the steps of the Prolog execution.  That is, the rules will be viewed from left to right, unlike the LR analyzer.  The main difference between the execution of programs on the Prologue is that backtracking is not limited.  One of the advantages of LL-analyzers (Antlr) before LR-analyzers (yacc) is the ease of debugging, since the products can be viewed as functions and interpret their call on the stack, the minus is the smaller number of described languages. <br><br>  Prolog is a domain-oriented language, that is, it allows you to create special notations for each language, and the task of describing grammars is no exception.  The syntax is quite simple: <br><br><pre> <code class="hljs pgsql"> s <span class="hljs-comment"><span class="hljs-comment">--&gt; [a], s, [a]. s --&gt; [].</span></span></code> </pre><br><br>  There are terminal symbols in square brackets (there may be a lot of them), outside the brackets, literals are products.  Such a syntax makes it possible to unambiguously translate only a grammar grammar, but with a slight extension of this syntax, the analyzer can solve problems that require a full Turing machine, that is, languages ‚Äã‚Äãof type 0 grammar are covered. <br><br>  A couple of examples of KS grammar described in the prologue. <br><br><pre> <code class="hljs erlang-repl"> s --&gt; []. s --&gt; [a], s, [b]. sentence --&gt; noun_phrase, verb_phrase. noun_phrase --&gt; det, noun. verb_phrase --&gt; verb, noun_phrase. det --&gt; [the]. det --&gt; [a]. noun --&gt; [cat]. noun --&gt; [bat]. verb --&gt; [eats].</code> </pre><br><br><h3>  Implementation of the analyzer and product of formal languages ‚Äã‚Äãin Prolog </h3><br><br>  The most interesting point is the implementation of the analyzer, because this is one of those tasks that Prolog is implemented quite simply.  The key point (disadvantage) is that Prolog cannot work with reading from a file using pure predicates, so all the content needs to be loaded into the list (this can be a list of tokens or letters). <br><br>  For implementation, ‚Äúdelta lists‚Äù are used - X \ [], the left part is unvisited elements, the right part is scanned.  Now imagine that each rule moves the token from the left side of the differential list to the right.  Under backkreenge, the token is moved back: from right to left.  We write this in the form of the simplest rules of the Prologue: <br><br><pre> <code class="hljs ruby"> s(L, L). s(L, L3) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> L=[a<span class="hljs-params"><span class="hljs-params">|L1], s(L1, L2), L3=[b|</span></span>L2].</code> </pre><br><br>  In order to determine whether the word aabb belongs to the language, it is necessary to run the predicate: -s ([a, a, b, b], []).  And the answer will be yes.  Like any pure program on the prologue, it does not have one input and output, so the same grammar can be used as a <b>generator</b> ! <br>  At the request: -s (X, []) we will receive: [], [a, b], [a, a, b, b], ....  You can even specify <b>queries with lost data</b> ( <b>data</b> recovery task):: -s ([a, X, Y, b], []).  -&gt; X = a, Y = b.  In general, we get all this for free :) <br><br>  Obviously, the process of generating predicates from grammar rules can be automated, and most interpreters / compilers do this.  Although for those Prolog implementations that do not support DCG (Definite Clause Grammar) - this can be done independently.  Especially since this is an excellent task for those who study Prolog. <br><pre> <code class="hljs ruby"> <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> op(<span class="hljs-number"><span class="hljs-number">1200</span></span>, xfx, <span class="hljs-string"><span class="hljs-string">'--&gt;'</span></span>). <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> op(<span class="hljs-number"><span class="hljs-number">200</span></span>, xfx, <span class="hljs-string"><span class="hljs-string">'\\'</span></span>). dcg_nonterminal(X) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> list(X), !, fail. dcg_nonterminal(<span class="hljs-number"><span class="hljs-number">_</span></span>). dcg_terminals(Xs) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> list(Xs). dcg_parse(A, Tokens) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> dcg_nonterminal(A), (A --&gt; B), dcg_parse(B, Tokens). dcg_parse((A, B), Tokens \\ Xs) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> dcg_parse(A, Tokens \\ Tokens1), dcg_parse(B, Tokens1 \\ Xs). dcg_parse(A, Tokens) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> dcg_terminals(A), dcg_connect(A, Tokens). dcg_parse({A}, Xs \\ Xs) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> call(A). dcg_connect([], Xs \\ Xs). dcg_connect([W <span class="hljs-params"><span class="hljs-params">| Ws], [W |</span></span> Xs] \\ Ys) <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> dcg_connect(Ws, Xs \\ Ys). % Example <span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> dcg_parse(s, [a,b] \\ []).</code> </pre><br><br>  I think this code is so complete that it does not need comments, and the first 3 rules are just checks. <br><h3>  Description of complex grammars and the result tree in Prolog </h3><br>  It is clear that no analyzer works only with QC grammars, all analyzers make changes to cover the greatest number of languages.  The easiest way to do this is in the DCG rules in Prolog.  All that is needed is to add context, namely parameters to the rules (I don‚Äôt understand why all LL analyzers don‚Äôt do that).  Take a short grammar (a..ab..bc..c - 3 letters with the same number of repetitions). <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[a]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X+1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[b]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>+1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[c]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>+1). <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:N</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">N</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">N</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>.</code> </pre><br><br>  Extremely clear and visual.  For those who are tormented by the question of efficiency, this grammar will be analyzed by Prolog with the same efficiency as the LA (1) analyzer.  If you cut off after [a] (terminals), then the memory cost will be the same.  Due to the fact that the predicate plus used in the rules is not declarative (in the previous article, an example of a declaring <a href="http://habrahabr.ru/blogs/programming/124820/">plus was</a> cited) this grammar is not generative.  That is, you cannot write a query: -rule (a: 5, b: _, c: _, Res, []). <br><br>  As many have already noticed, in the syntax there are no familiar to us in BNF symbols + and *, which are often used in the description of grammars.  But it is easy to fix with a powerful meta-rule tool in hand. <br><br><pre> <code class="hljs erlang-repl"> <span class="hljs-string"><span class="hljs-string">'*'</span></span>(Rule) --&gt; []. <span class="hljs-string"><span class="hljs-string">'*'</span></span>(Rule) --&gt; Rule, <span class="hljs-string"><span class="hljs-string">'*'</span></span>(Rule). <span class="hljs-string"><span class="hljs-string">'+'</span></span>(Rule) --&gt; Rule, <span class="hljs-string"><span class="hljs-string">'*'</span></span>(Rule). tree -&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span>(branch). forest -&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span>(tree).</code> </pre><br><br>  It looks, of course, not familiar, so this syntax did not take root in the DCG.  Restrictions of the Prolog parser, which only support unary prefix and binary operators, interfere with giving expressions a more or less natural look. <br><br><h3>  Prolog result tree </h3><br>  Recognizing whether a word belongs to a language or not is a rather rare task in programming.  More often we are interested in the grammar parse tree for subsequent interpretation / validation / analysis.  Here is an example of a typical grammatical analysis in Prolog (just like in an English class): <br><pre> <code class="hljs pgsql"> sentence(s(NP,VP)) <span class="hljs-comment"><span class="hljs-comment">--&gt; noun_phrase(NP), verb_phrase(VP). noun_phrase(np(D,N)) --&gt; det(D), noun(N). verb_phrase(vp(V,NP)) --&gt; verb(V), noun_phrase(NP). det(d(the)) --&gt; [the]. det(d(a)) --&gt; [a]. noun(n(bat)) --&gt; [bat]. noun(n(cat)) --&gt; [cat]. verb(v(eats)) --&gt; [eats]. | ?- sentence(Parse_tree, [the,bat,eats,a,cat], []). Parse_tree = s(np(d(the),n(bat)),vp(v(eats),np(d(a),n(cat)))) ? ;</span></span></code> </pre><br><br>  As we can see for the output analysis, the context is used, which is represented by the usual Prolog variables, and the variables in the Prolog are initialized, although they are initialized once, but are well suited for the output parameters of the function. <br>  In order to fully represent the power of the analyzer, I will give an example of a grammar of numerical expressions, the result tree of which is the answer of a numerical expression. <br><br><pre> <code class="hljs erlang-repl"> expr(Res) --&gt; expr(X), [<span class="hljs-string"><span class="hljs-string">'+'</span></span>], summand(Y), {Res is X + Y}. expr(Res) --&gt; expr(X), [<span class="hljs-string"><span class="hljs-string">'-'</span></span>], summand(Y), {Res is X + Y}. summand(Res) --&gt; summand(X), [<span class="hljs-string"><span class="hljs-string">'*'</span></span>], multiplicator(Y), {Res is X / Y}. summand(Res) --&gt; summand(X), [<span class="hljs-string"><span class="hljs-string">'/'</span></span>], multiplicator(Y), {Res is X / Y}. summand(Res) --&gt; multiplicator(Res). multiplicator(X) --&gt; number(X). multiplicator(X) --&gt; [<span class="hljs-string"><span class="hljs-string">'('</span></span>], number(X), [<span class="hljs-string"><span class="hljs-string">')'</span></span>].</code> </pre><br><br>  In principle, using metapredicates and {} to call Prolog's embedded predicates, we get a complete Turing machine.  In the methods of interpreting programs on Prolog, one can draw a parallel with the deterministic Turing Machine and the non-deterministic.  The deterministic Turing Machine will interpret the Prolog program in the classic version, that is, selecting rules from top to bottom in a strict order.  The nondeterministic analogue of the interpretation will look for the best match of the rule and follow this branch (as the NMT chooses an extremely successful next command in order to achieve the final goal of the program completion). <br><br><h3>  The specifics of the analyzer Prolog </h3><br>  Summarizing the analysis of the DCG parser on the Prolog, we give + and - its use: <br>  1. + The expressibility of a large number of languages ‚Äã‚Äã(up to type 0). <br>  2. + Convenience of writing context-dependent languages, building an output tree, meta-rules. <br>  3. + Trace, console output mechanisms are available as standard Prolog predicates and all Prolog tools can be used. <br>  4. - A simple rearrangement of the rules may cause the program to loop.  Example: <br>  expr (Res) -&gt; expr (X), ['+'], expr (Y). <br>  A rule of this kind will be correctly perceived by the analyzer and sometimes produce the expected result, but most often it will loop the program or use a huge amount of resources during backtracking. <br>  5. - Using clipping as a backtracking constraint can unexpectedly affect program logic. <br>  6. - It is quite difficult to limit the use of backtracking and Look Ahead characters. <br>  7. - All the contents of the analyzed text in memory (array of tokens or letters) is required. <br><br><h3>  Bibliography </h3><br>  1. Aho.  Compilers: principles, technologies and tools <br>  2. Chen and Lee.  Automatic proof of theorems. <br>  3. Mendelssohn.  Mathematical logic. <br><br>  PS (Last word): Does anyone know how many articles you need to write about Prologue so that the Prolog blog appears on Habr√© :) </div><p>Source: <a href="https://habr.com/ru/post/136742/">https://habr.com/ru/post/136742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136735/index.html">Competent setting of the mail sending server for PHP scripts, setting up the mail () function</a></li>
<li><a href="../136736/index.html">The principle of domino or XSS on large sites runet</a></li>
<li><a href="../136737/index.html">Promotion experience in the Russian AppStore</a></li>
<li><a href="../136738/index.html">JavaScript application for iPad. Couple of tips</a></li>
<li><a href="../136740/index.html">I slowly remove apache from the server</a></li>
<li><a href="../136743/index.html">Defeating memory leaks and speeding up Firefox</a></li>
<li><a href="../136744/index.html">How to invent a name for a new product or project</a></li>
<li><a href="../136745/index.html">Desurium client published under GPL v3</a></li>
<li><a href="../136746/index.html">Alignment of icons by font baseline</a></li>
<li><a href="../136748/index.html">Google has learned to understand punctuation and symbols</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>