<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using LSM engine from SQLite 4 as a separate NoSQL database using Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To date, two of my favorite topics are SQLite and database key-value. And this time I‚Äôm writing about both at once: this post is dedicated to Python w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using LSM engine from SQLite 4 as a separate NoSQL database using Python</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a68/ddf/3e6/a68ddf3e6b52165cae0448a58f3a6b37.png" alt="image"><br><br>  To date, two of my favorite topics are SQLite and database key-value.  And this time I‚Äôm writing about both at once: this post is dedicated to Python wrapper for <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM-</a> based storage used in SQLite 4 key-value. <br><br>  I didn‚Äôt closely monitor the releases of SQLite, but version 3.8.11 caught my attention, because its description stated a serious performance increase compared to 3.8.0.  In the accompanying information, I came across the mention of a new experimental expansion for full-text search ( <a href="http://charlesleifer.com/blog/building-the-sqlite-fts5-search-extension/">which I once wrote about</a> ), and therefore I wondered what the situation with <a href="">SQLite 4 was</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having studied the available information, I noticed that one of the tasks of the developers was to provide an <a href="">interface for the connected database engines</a> in new versions.  At the time of writing this post in SQLite 4, there were already two built-in backends, one of which is a key-value LSM-based repository.  In the past couple of months, I have been playing <a href="http://cython.org/">around</a> with <a href="http://cython.org/">Cython</a> while I was writing Python wrapper for embedded kv <a href="http://unqlite-python.readthedocs.org/">UnQLite</a> and <a href="http://vedis-python.readthedocs.org/">Vedis repositories</a> .  And I thought it would be nice to use Cython to create an interface to the database engine based on LSM used in SQLite 4. <br><br>  Having dealt with the <a href="http://sqlite.org/src4/tree%3Fci%3Dtrunk">SQLite 4 source code</a> and the <a href="">tiny LSM header file</a> , I wrote <a href="https://github.com/coleifer/python-lsm-db">python-lsm-db</a> ( <a href="http://lsm-db.readthedocs.org/">documentation</a> ). <br><a name="habracut"></a><br><h1>  What is LSM-tree? </h1><br>  As far as I understand the theory, LSM-trees consist of: <br><br><ul><li>  memory tree, working as a buffer, </li><li>  and one or more persistent trees located on the disk. </li></ul><br>  The letter M in the abbreviation LSM means merge: an operation to merge the buffered records with the tree (s) on the disk.  This procedure allows you to greatly reduce the cost of seek by disk, which means one thing - fast writing.  On the other hand, random reads may turn out to be slower, since the system will search through several trees.  An LSM tree may be <b>longer</b> than a B-tree comparable to it.  I suppose that another advantage of LSM trees is less fragmentation of the stored data, which speeds up the reading of key ranges. <br><br>  Once again, this is my understanding of the theory.  I could be mistaken or miss important points. <br><br><h1>  Properties </h1><br>  The implementation of LSM in SQLite 4 has a number of very interesting properties: <br><br><ul><li>  Embedded database used by your application. </li><li>  Setting the order of viewing keys using cursors. </li><li>  Transactional (including nested transactions). </li><li>  Transactional parallelization model based on MVCC with support for the ‚Äúone writes / several read‚Äù mode. </li><li>  Database stored on disk as a single file. </li><li>  Data stability in case of application or power failures. </li><li>  The possibility of flexible settings to fit your needs. </li></ul><br><h1>  Creating a Python Library </h1><br>  So let's get started.  First, let's create virtualenv and use pip to install Cython and lsm-db: <br><br><pre><code class="bash hljs">$ virtualenv test_lsm $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> test_lsm $ <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> bin/activate (test_lsm) $ pip install Cython lsm-db</code> </pre> <br>  To verify the installation, you can run the line: <br><br><pre> <code class="bash hljs">(test_lsm) $ python -c <span class="hljs-string"><span class="hljs-string">"import lsm, tempfile; lsm.LSM(tempfile.mktemp())"</span></span></code> </pre><br>  If everything is installed and working correctly, then the execution of this command will not entail anything.  But keep in mind, I tested it only in Python 2.7 under Linux.  So if you are using Python 3.4 under Windows, you may need to debug this code. <br><br><h1>  Small retreat </h1><br>  Next will be an example of an interactive console session that reflects the main features and capabilities of the lsm-db library.  The <a href="http://lsm-db.readthedocs.org/en/latest/api.html">API documentation</a> contains a complete list of classes, methods and descriptions of parameters and return values. <br><br>  First, start the Python interpreter in a virtual environment and create an instance of the LSM object, specifying the path to the database file: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lsm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LSM &gt;&gt;&gt; db = LSM(<span class="hljs-string"><span class="hljs-string">'test.ldb'</span></span>)</code> </pre><br>  In the LSM class, there are a <a href="http://lsm-db.readthedocs.org/en/latest/api.html">number of parameters</a> besides the filename that you can customize: block size, page size, etc. <br><br><h1>  Key-value features </h1><br>  The SQLMate 4 LSM engine is a key / value store, which makes it somewhat similar to the dict object in Python.  We use the dict-like API. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>db[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> db[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] bar &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): ... db[<span class="hljs-string"><span class="hljs-string">'k%s'</span></span> % i] = str(i) ... &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'k3'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'k4'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> db[<span class="hljs-string"><span class="hljs-string">'k3'</span></span>] &gt;&gt;&gt; db[<span class="hljs-string"><span class="hljs-string">'k3'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"lsm.pyx"</span></span>, line <span class="hljs-number"><span class="hljs-number">973</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsm.LSM.__getitem__ (lsm.c:<span class="hljs-number"><span class="hljs-number">7142</span></span>) File <span class="hljs-string"><span class="hljs-string">"lsm.pyx"</span></span>, line <span class="hljs-number"><span class="hljs-number">777</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsm.LSM.fetch (lsm.c:<span class="hljs-number"><span class="hljs-number">5756</span></span>) File <span class="hljs-string"><span class="hljs-string">"lsm.pyx"</span></span>, line <span class="hljs-number"><span class="hljs-number">778</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsm.LSM.fetch (lsm.c:<span class="hljs-number"><span class="hljs-number">5679</span></span>) File <span class="hljs-string"><span class="hljs-string">"lsm.pyx"</span></span>, line <span class="hljs-number"><span class="hljs-number">1289</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsm.Cursor.seek (lsm.c:<span class="hljs-number"><span class="hljs-number">12122</span></span>) File <span class="hljs-string"><span class="hljs-string">"lsm.pyx"</span></span>, line <span class="hljs-number"><span class="hljs-number">1311</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsm.Cursor.seek (lsm.c:<span class="hljs-number"><span class="hljs-number">12008</span></span>) KeyError: <span class="hljs-string"><span class="hljs-string">'k3'</span></span></code> </pre><br>  Note: when we tried to access the just-deleted key, KeyError immediately popped up.  By default, when we search for a key, the library first looks for a full match.  In SQLite 4, LSM can also search for the closest key lexicographically if the value we are looking for does not exist.  In addition to matching the search, there are two more search methods that return the next closest key: SEEK_LE and SEEK_GE.  If no full match is found, then SEEK_LE returns the uppermost key (the highest key), the value of which is less than the desired one, and SEEK_GE - the lowermost key (the lowest key), whose value is greater than the desired one.  Suppose k1.5 does not exist: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lsm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SEEK_LE, SEEK_GE &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">#    "k1",    ,   k1.5 &gt;&gt;&gt; db['k1.5', SEEK_LE] '1' &gt;&gt;&gt; #    "k2",    ,   k1.5 &gt;&gt;&gt; db['k1.5', SEEK_GE] '2'</span></span></code> </pre><br>  In addition to these, LSM supports a number of other methods: keys (), values ‚Äã‚Äã() and update (). <br><br><h1>  Slices and iterations </h1><br>  In SQLite 4 LSM, you can iterate directly on the data or make a selection on a subset of keys.  An interesting point is that when requesting a range of keys, its beginning and end may not exist.  If there is no key, then the base will use one of the seek methods to find the next close key (next-closest key): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>[item <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db] [(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>)] &gt;&gt;&gt; db[<span class="hljs-string"><span class="hljs-string">'k0'</span></span>:<span class="hljs-string"><span class="hljs-string">'k99'</span></span>] &lt;generator object at <span class="hljs-number"><span class="hljs-number">0x7f2ae93072f8</span></span>&gt; &gt;&gt;&gt; list(db[<span class="hljs-string"><span class="hljs-string">'k0'</span></span>:<span class="hljs-string"><span class="hljs-string">'k99'</span></span>]) [(<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>)]</code> </pre><br>  To return all keys in a given direction, you can use open (ended) slices: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>list(db[<span class="hljs-string"><span class="hljs-string">'k0'</span></span>:]) [(<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>)] &gt;&gt;&gt; list(db[:<span class="hljs-string"><span class="hljs-string">'k1'</span></span>]) [(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>)]</code> </pre><br>  If the upper (upper bound) or lower (lower bound) border is outside the range of keys, then an empty list is returned. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>list(db[:<span class="hljs-string"><span class="hljs-string">'aaa'</span></span>]) [] &gt;&gt;&gt; list(db[<span class="hljs-string"><span class="hljs-string">'z'</span></span>:]) []</code> </pre><br>  To retrieve the keys in the reverse order, it is enough just to specify the top key as the first slice parameter.  If you retrieve an open slice, then you can set True as its step parameter. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>list(db[<span class="hljs-string"><span class="hljs-string">'k1'</span></span>:<span class="hljs-string"><span class="hljs-string">'aaa'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#  'k1' &gt; 'aaa',      : [('k1', '1'), ('k0', '0'), ('foo', 'bar')] &gt;&gt;&gt; list(db['k1'::True]) #    True    step: [('k1', '1'), ('k0', '0'), ('foo', 'bar')]     &lt;b&gt;&lt;/b&gt; ,        : &gt;&gt;&gt; del db['k0':'k99'] &gt;&gt;&gt; list(db) # 'k0'   . [('foo', 'bar'), ('k0', '0')]</span></span></code> </pre><br>  If you are interested in more detailed information about how the seek methods work, consult the <a href="http://lsm-db.readthedocs.org/en/latest/api.html">LSM.fetch_range ()</a> documentation. <br><br><h1>  Cursors </h1><br>  Although in most cases there are enough slices, sometimes a more subtle control over the process of searching and viewing records is needed. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.cursor() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cursor: ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cursor: ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> key, <span class="hljs-string"><span class="hljs-string">'=&gt;'</span></span>, value ... foo =&gt; bar k0 =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; db.update({<span class="hljs-string"><span class="hljs-string">'k1'</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'k2'</span></span>: <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'k3'</span></span>: <span class="hljs-string"><span class="hljs-string">'3'</span></span>}) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.cursor() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cursor: ... cursor.first() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> cursor.key() ... cursor.last() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> cursor.key() ... cursor.previous() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> cursor.key() ... foo k3 k2 &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.cursor() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cursor: ... cursor.seek(<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, SEEK_GE) ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> list(cursor.fetch_until(<span class="hljs-string"><span class="hljs-string">'k99'</span></span>)) ... [(<span class="hljs-string"><span class="hljs-string">'k0'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k1'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k2'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>), (<span class="hljs-string"><span class="hljs-string">'k3'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span>)]</code> </pre><br>  Do not leave them open when using cursors.  At first, you can use the context manager LSM.cursor (), which will help close the cursors. <br><br><h1>  Transactions </h1><br>  LSM-base SQLite 4 supports nested transactions.  The easiest way to use them is with the LSM.transaction () method, which also acts as a context manager or decorator. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.transaction() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> txn: ... db[<span class="hljs-string"><span class="hljs-string">'k1'</span></span>] = <span class="hljs-string"><span class="hljs-string">'1-mod'</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.transaction() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> txn2: ... db[<span class="hljs-string"><span class="hljs-string">'k2'</span></span>] = <span class="hljs-string"><span class="hljs-string">'2-mod'</span></span> ... txn2.rollback() ... <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> db[<span class="hljs-string"><span class="hljs-string">'k1'</span></span>], db[<span class="hljs-string"><span class="hljs-string">'k2'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span>-mod <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  You can partially commit or roll back transactions using wrapped block, and the new transaction will start from the old place: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> db.transaction() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> txn: ... db[<span class="hljs-string"><span class="hljs-string">'k1'</span></span>] = <span class="hljs-string"><span class="hljs-string">'outer txn'</span></span> ... txn.commit() <span class="hljs-comment"><span class="hljs-comment">#  . ... ... db['k1'] = 'outer txn-2' ... with db.transaction() as txn2: ... db['k1'] = 'inner-txn' #    . ... print db['k1'] #  "inner-txn". ... txn.rollback() #   txn2     . ... print db['k1'] ... 1 &lt;- Return value from call to commit(). inner-txn &lt;- Printed after end of txn2. True &lt;- Return value of call to rollback(). outer txn &lt;- Printed after rollback.</span></span></code> </pre><br>  If you want, you can explicitly call LSM.begin (), LSM.commit () and LSM.rollback (). <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>db.begin() &gt;&gt;&gt; db[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] = <span class="hljs-string"><span class="hljs-string">'baze'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> db[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] baze &gt;&gt;&gt; db.rollback() <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> db[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>] bar</code> </pre><br><h1>  Performance </h1><br>  Although I can not tolerate all these benchmarks, I was very interested in what the performance of the LSM-base.  Therefore, I compared SQLite 4 LSM with LevelDB, Berkeley DB and Kyoto Cabinet using a <a href="https://gist.github.com/coleifer/747c4406b3c2363e0716">small benchmark</a> .  In a good way, they could not be compared, since Kyoto Cabinet and Berkeley DB are built-in B-trees, and Kyoto Cabinet and LevelDB do not support multiple process access to the database.  Also, I'm not sure if there is transaction support in LevelDB.  Among other things, the benchmark uses the database libraries not directly, but through the available Python driver.  So some limitations and features of the Python libraries could affect the result. <br><br>  Benchmark results (the smaller the better): <br><br><pre> <code class="bash hljs">Testing with N = 100000 ------------------------------------ BDBBTree ~~~~~~~~ Writes: 0.469 Reads: 0.479 Range (10%): 0.212 Range (20%): 0.192 Range (40%): 0.185 Range (80%): 0.186 KyotoBTree ~~~~~~~~~~ Writes: 0.208 Reads: 0.203 Range (10%): 0.219 Range (20%): 0.188 Range (40%): 0.188 Range (80%): 0.187 LevelDB ~~~~~~~ Writes: 0.227 Reads: 0.225 Range (10%): 0.031 Range (20%): 0.027 Range (40%): 0.028 Range (80%): 0.027 LSM ~~~ Writes: 0.282 Reads: 0.239 Range (10%): 0.059 Range (20%): 0.052 Range (40%): 0.052 Range (80%): 0.052</code> </pre><br>  I interpret this data as follows: the performance of Berkeley DB and Kyoto Cabinet when getting key ranges turned out to be quite expected, that is, about the same as with random reading.  And LevelDB and LSM, on the contrary, turned out to be much faster when reading ranges, and they write quite quickly. <br><br>  LevelDB exceeded SQLite 4 LSM, but the latter reads ranges much faster than B-trees.  It will be necessary to punch out the LSM benchmark, because reading it turned out to be four times slower than writing!  At first, I thought that there were just some problems with reading, but then I realized that the whole thing was in Python-wrapper for each fetch ().  After replacing the Python code with a couple of direct C language API calls, the reading speed has increased dramatically.  If you want to try LSM Python bindings, then make sure that you are using version 0.1.4 or higher, because in previous versions the fetch () implementation is very slow. <br><br><h1>  SQLite 4 Notes </h1><br>  If you want to build SQLite 4 yourself, you can clone an outdated repository and compile it. <br><br><pre> <code class="bash hljs">$ fossil <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://www.sqlite.org/src4/ sqlite4.fossil $ mkdir sqlite4-build $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> sqlite4-build $ fossil open ../sqlite4.fossil $ ln -s Makefile.linux-gcc Makefile $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CFLAGS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$CFLAGS</span></span></span><span class="hljs-string"> -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_COLUMN_METADATA=1 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_SECURE_DELETE $ make</span></span></code> </pre><br>  Upon completion, you will have a binary file sqlite4, libsqlite4.a and sqlite4.h. <br><br>  You can also create your own copies of the original merged file to simplify the embedding process: <br><br><pre> <code class="bash hljs">make sqlite4.c</code> </pre><br>  I should also note that the current status of SQLite 4 ... is unknown.  Dr. Hipp mentioned that he plans to continue supporting SQLite 3. It‚Äôs hard to blame him.  But in place of end users, I would experiment with the fourth version.  Perhaps her future, but not a fact.  And even if it does, it may not be in its current form. <br><br><h1>  Additional materials </h1><br>  If you need dirty details, here is a list of useful links: <br><br><ul><li>  <a href="http://lsm-db.readthedocs.org/">Python LSM-db documentation</a> </li><li>  <a href="">Introduction to SQLite4 LSM</a> </li><li>  <a href="">LSM C-API Description</a> </li><li>  <a href="https://www.quora.com/How-does-the-Log-Structured-Merge-Tree-work">Quora: ‚ÄúHow does the LSM tree work?‚Äù</a> </li><li>  <a href="https://gist.github.com/coleifer/747c4406b3c2363e0716">My benchmark script</a> </li></ul><br>  My other posts that you might like: <br><br><ul><li>  <a href="http://charlesleifer.com/blog/using-the-sqlite-json1-and-fts5-extensions-with-python/">Using the SQLite JSON1 and FTS5 extensions with Python</a> </li><li>  <a href="http://charlesleifer.com/blog/using-sqlite-full-text-search-with-python/">Using SQLite full-text search with Python</a> </li><li>  <a href="http://charlesleifer.com/blog/introduction-to-the-fast-new-unqlite-python-bindings/">Introduction to the fast, new UnQLite bindings</a> </li><li>  <a href="http://charlesleifer.com/blog/my-list-of-python-and-sqlite-resources/">My list of Python and SQLite resources</a> </li></ul><br>  If you are interested in other embedded NoSQL databases, then pay attention to <a href="http://unqlite-python.readthedocs.org/">unqlite-python</a> and <a href="http://vedis-python.readthedocs.org/">vedis-python</a> .  They are very similar to MongoDB and Redis, respectively, use wrappers, lightweight C extensions, and can be embedded in Python projects. </div><p>Source: <a href="https://habr.com/ru/post/274733/">https://habr.com/ru/post/274733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274723/index.html">[Translation] Associative arrays in the D language</a></li>
<li><a href="../274725/index.html">Setting the problem of computer vision</a></li>
<li><a href="../274727/index.html">Critical errors in the design of process control systems and PLC programming</a></li>
<li><a href="../274729/index.html">Calculation of binomial coefficients using Fourier transforms</a></li>
<li><a href="../274731/index.html">Easy setup Asterisk + Fail2Ban</a></li>
<li><a href="../274735/index.html">How much does it cost: Gigabyte traffic in Africa</a></li>
<li><a href="../274739/index.html">Translation: The tragedy of common lisp</a></li>
<li><a href="../274741/index.html">Steam CEG from Valve and what it eats. Introduction</a></li>
<li><a href="../274743/index.html">Understanding the syntax of templates in Angular2</a></li>
<li><a href="../274745/index.html">Quickly create phar files using Box</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>