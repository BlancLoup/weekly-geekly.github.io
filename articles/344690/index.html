<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tutorial on the Unreal Engine. Part 5: How to create a simple game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are new to game development, then it‚Äôs most logical to start by creating a simple game. She will teach you how to implement simple mechanics an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tutorial on the Unreal Engine. Part 5: How to create a simple game</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/cc3/ed4/630cc3ed4a83cb396b7c59a774057fdb.jpg" alt="image"></div><br>  If you are new to game development, then it‚Äôs most logical to start by creating a simple game.  She will teach you how to implement simple mechanics and how objects interact with each other. <br><br>  In this part of the tutorial, we will create a first-person game that lasts forever.  You will learn the following: <br><br><ul><li>  Infinitely move a player forward. </li><li>  Generate obstacles that the player must avoid </li><li>  Randomize obstacles for creating variations </li><li>  Create a restart button that is displayed when a player encounters an obstacle </li></ul><a name="habracut"></a><br>  As a result, we will have this game: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/9e5/548/e7d9e554874c6030b90edb16266f4036.gif"></div></div></div><br>  Please note that in this part we will use Blueprints and UMG.  If you need to refresh your knowledge, then read the parts on <a href="https://habrahabr.ru/post/344446/">Blueprints</a> and <a href="https://habrahabr.ru/post/344600/">UI</a> . <br><br>  <em>Note:</em> This article is one of the eight parts of the Unreal Engine tutorial: <br><br><ul><li>  <a href="https://habrahabr.ru/post/344394/">Part 1: Introduction to the engine</a> </li><li>  <a href="https://habrahabr.ru/post/344446/">Part 2: Blueprints</a> </li><li>  <a href="https://habrahabr.ru/post/344522/">Part 3: Materials</a> </li><li>  <a href="https://habrahabr.ru/post/344600/">Part 4: UI</a> </li><li>  Part 5: How to create a simple game </li><li>  <a href="https://habrahabr.ru/post/344840/">Part 6: Animation</a> </li><li>  <a href="https://habrahabr.ru/post/345018/">Part 7: Sound</a> </li><li>  <a href="https://habrahabr.ru/post/345110/">Part 8: Particle Systems</a> </li><li>  <a href="https://habrahabr.ru/post/346498/">Part 9: Artificial Intelligence</a> </li><li>  <a href="https://habrahabr.ru/post/347036/">Part 10: How to create a simple FPS</a> </li></ul><br><h2>  Getting Started </h2><br>  Download the <a href="">project blank</a> and unpack it.  Navigate to the project folder and open <em>InfiniteMatrix.uproject</em> . <br><br>  <em>Note:</em> if a window opens indicating that the project was created in an earlier version of the Unreal editor, then everything is fine (the engine is often updated).  You can either choose the option to create a copy, or the option to convert the project itself. <br><br>  Click on <em>Play</em> to check the motion control.  <em>Moving the mouse</em> , you can move vertically and horizontally. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/ad4/fee/1b7ad4fee27a1b717902d1ba6c59eebe.gif"></div></div></div><br>  The first thing we need to do is make the player move constantly. <br><br>
<h2>  Player forward movement </h2><br>  Go to the <em>Blueprints</em> folder and open the <em>BP_Player</em> . <br><br>  To move a player forward, you need to add an offset to the player‚Äôs location in each frame. <br><br>  First, we need to create a variable that sets the player‚Äôs forward speed.  Create a <em>Float</em> variable called <em>ForwardSpeed</em> and set the default value to <em>2000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a1/e60/532/0a1e60532835fc43d584febbf9ef226a.jpg"></div><br>  Now go to the Event Graph and find the <em>Event Tick</em> node.  Create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/229/84f/b4c/22984fb4c7ee825e265aacf3ecff4d48.jpg"></div><br>  Multiplying <em>ForwardSpeed</em> by <em>Delta Seconds</em> , we get a result <em>independent of the frame rate</em> . <br><br>  <em>Note:</em> if you don‚Äôt understand what frame rate independence is, then read the part of the <a href="https://habrahabr.ru/post/344446/">Blueprints</a> tutorial.  We analyze it in the section <em>Frame rate independence</em> . <br><br>  Now we need to use this result to move the player along the same axis. <br><br><h3>  Movement along one axis </h3><br>  To move a player, create an <em>AddActorWorldOffset</em> node.  Change the <em>Sweep</em> value to <em>true</em> by clicking the <em>checkbox</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fb/8f4/de6/3fb8f4de649ef6d73f5cd13ffab8dfd3.jpg"></div><br>  If you try to connect the <em>Float</em> result to the <em>Delta Location</em> input, Unreal will automatically convert it to <em>Vector</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/5d4/171/7c15d417183251da74cabfdbacf86844.jpg"></div><br>  However, in this way the Float value will be written to the X, Y, and Z components of the vector.  For our game, forward movement should be performed only along the <em>X</em> axis.  Fortunately, the Vector can be divided into three <em>Float</em> components. <br><br>  Ensure that the <em>Delta Location</em> contact <em>AddActorWorldOffset</em> is not connected to anything.  <em>Right-click</em> the <em>Delta Location</em> contact and select <em>Split Struct Pin</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/c45/9a7/73fc459a7e5f7e1969907809c98e4a60.gif"></div><br>  Finally, connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/3e6/ba4/d7a3e6ba4d092529fcc9d1b8c303e746.jpg"></div><br>  Summarize: <br><br><ol><li>  In each frame, the game will multiply <em>ForwardSpeed</em> and <em>Delta Seconds</em> to get a frame rate-independent result. </li><li>  <em>AddActorWorldOffset</em> will use this result to move the player along the <em>X</em> axis. </li><li>  Since the <em>Sweep is</em> turned on, the player will interrupt forward movement when something is blocking it. </li></ol><br>  Click on <em>Compile</em> and return to the main editor.  If you click <em>Play</em> , then you begin to move through the tunnel. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/599/26d/cdd/59926dcdd2746da047fd57d4b523bb35.gif"></div></div></div><br>  Instead of arranging the tunnels manually, we can create a blueprint that automatically spawns the tunnels. <br><br><h2>  Creating a system of spawn tunnels </h2><br>  Go to the Content Browser and go to the <em>Blueprints</em> folder.  Create a new <em>Blueprint Class</em> with the parent class <em>Actor</em> .  Call it <em>BP_TunnelSpawner</em> and open it. <br><br>  The game will create tunnels all the time, so it would be nice to create a <em>function</em> for spawn.  Go to the My Blueprint panel and create a new <em>SpawnTunnel</em> function.  The function task will be the tunnel spawn at the specified location. <br><br>  To pass a location to a function, the function needs an <em>input parameter</em> .  They will be displayed when the function is called as input contacts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/597/06f/20159706fe73b09132c24e2ac8e5fa3a.jpg"></div><br>  They will also be displayed as output contacts of the node <em>Entry</em> function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/2b7/1aa/33b2b71aa79d82082d934959194fd3a2.jpg"></div><br>  Let's create an input parameter.  Go to the <em>SpawnTunnel</em> function <em>graph</em> .  Select the <em>Entry</em> node and go to the Details panel.  Click the <em>+</em> icon next to the <em>Inputs</em> section. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b4/5ab/d1d/2b45abd1d2cffb4f7b47179c3d884484.jpg"></div><br>  Rename the input parameter to <em>SpawnLocation</em> and change its type to <em>Vector</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/dae/e56/d98daee5661943bc48914efa7d95fa93.jpg"></div><br>  To create a tunnel, add the node <em>Spawn Actor From Class</em> .  Click on the <em>drop-down list</em> to the right of the <em>Class</em> contact and select <em>BP_Tunnel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/4d2/9c1/f6b4d29c193a88e1d5c7e7c20f82e1f9.jpg"></div><br>  To set the location of the spawn, <em>right-click</em> on the <em>Spawn Transform</em> contact and select <em>Split Struct Pin</em> .  Then connect the <em>Spawn Actor From Class</em> node to the <em>Entry</em> node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef0/d5c/806/ef0d5c806dc4e69aa20d45d3ad01f88d.jpg"></div><br>  Now when the <em>SpawnTunnel</em> function is <em>called,</em> it will spool an instance of <em>BP_Tunnel</em> at the location passed to it. <br><br>  Let's check how it works! <br><br><h3>  Checking the system of spawn tunnels </h3><br>  Switch to the Event Graph and find the <em>Event BeginPlay</em> node.  Add a <em>SpawnTunnel</em> node and connect it to the <em>Event BeginPlay node</em> . <br><br>  In the SpawnTunnel <em>node,</em> set the <em>Spawn Location</em> value <em>(2000, 0, 500)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/093/3ac/6b50933ac86f46044bc4005712234581.jpg"></div><br>  Now when you start the game, he will spawn a tunnel on top and in front of the player.  Click on <em>Compile</em> and return to the main editor. <br><br>  First remove the <em>BP_Tunnel</em> from the level.  To do this, <em>click</em> on the <em>BP_Tunnel</em> in the World Outliner.  Then press the <em>Delete</em> key to remove it from the level. <br><br>  Then go to the Content Browser.  <em>Drag</em> <em>BP_TunnelSpawner</em> <em>with the left mouse</em> <em>button</em> into Viewport.  Due to this, its copy will appear on the level. <br><br>  If you click on <em>Play</em> , the game will spawn a tunnel on top and in front of the player. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/f73/2fd/914f732fd4e83cb932d379bb5f40067c.gif"></div></div></div><br>  When finished checking, go back to <em>BP_TunnelSpawner</em> .  Reset the <em>Spawn Location</em> values ‚Äã‚Äãof the <em>SpawnTunnel</em> node to <em>(0, 0, 0)</em> . <br><br>  After that, click on <em>Compile</em> and return to the main editor. <br><br>  In the next section, we will configure <em>BP_Tunnel to</em> work. <br><br><h2>  Tunnel Blueprint Setup </h2><br>  <em>BP_Tunnel</em> will perform two tasks.  First, it will determine when the game should create a new tunnel.  To do this, we will create a trigger zone.  After the trigger triggers, <em>BP_Tunnel</em> will tell <em>BP_TunnelSpawner</em> to create a new tunnel.  Thanks to this, you can create the illusion of an endless tunnel. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/cd1/0e7/04ecd10e72dbf80cee7cfd8137db1483.gif"></div></div></div><br>  Secondly, it will set the spawn point.  After this, <em>BP_TunnelSpawner</em> will use this point as the next spawn location. <br><br>  Let's start by creating a trigger zone. <br><br><h3>  Creating a trigger zone </h3><br>  Open <em>BP_Tunnel</em> and go to the Components panel.  Add the <em>Box Collision</em> component and name it <em>TriggerZone</em> . <br><br>  So far, the collision area is rather small.  Go to the Details panel and find the <em>Shape</em> section.  Set the <em>Box Extent</em> property to <em>(32, 500, 500)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/128/355/3b61283559c3634f68fa93cf1daf0618.jpg"></div><br>  Now set the <em>Location</em> property to <em>(2532, 0, 0)</em> .  This will place the <em>TriggerZone</em> directly at the end of the tunnel mesh.  This means that a new tunnel will only have to be created when the player reaches the <i>end of the</i> tunnel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/8d9/6ad/4c38d96add443f44c49c0d537b18badc.jpg"></div><br>  Now it‚Äôs time to create a spawn point. <br><br><h3>  Creating a spawn point </h3><br>  To set the location of the spawn point, you can use the <em>Scene</em> component.  These components are ideal for setting locations, because they only have a Transform.  They are also visible in Viewport, so you can see where the spawn point is. <br><br>  Go to the Components panel and make sure nothing is selected.  Add the <em>Scene</em> component and rename it to <em>SpawnPoint</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/ef2/dd3/e10ef2dd3356e22924f48f25494d0f30.jpg"></div><br>  Mesh tunnel has a length of <em>2500</em> units along the <em>X</em> axis, so this is where there should be an attachment point.  Go to the Details panel and set the <em>Location</em> property to values <em>(2500, 0, 0)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/265/54b/7d3/26554b7d3e9883df701d9add3aa3a1bd.jpg"></div><br>  The next thing you need to do is create a function that spawns a tunnel in <em>SpawnPoint</em> . <br><br><h2>  Creating tunnels at the point of spawn </h2><br>  Click on <em>Compile</em> and switch to <em>BP_TunnelSpawner</em> . <br><br>  The next <em>BP_Tunnel</em> should spawn in the <em>SpawnPoint of</em> <i>the farthest</i> tunnel.  Because of this, the tunnel will always continue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bd/065/d5b/4bd065d5b72611201a5786217da71997.gif"></div><br>  Since the farthest tunnel will always be the last one created, it is easy for us to get a link to it. <br><br>  Open the <em>SpawnTunnel</em> graph.  <em>Right-click</em> on the <em>Return Value</em> contact of the <em>Spawn Actor From Class</em> node.  Select <em>Promote to Variable</em> and rename the variable to <em>NewestTunnel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c9/b0e/179/9c9b0e179207de210465a211146dbed8.jpg"></div><br>  Now we will always have a link to the farthest tunnel. <br><br>  Next, create a new function and name it <em>SpawnTunnelAtSpawnPoint</em> .  Create the following graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d26/ab2/2b3/d26ab22b30f0997ccd6298b264ce60fa.jpg"></div><br><br>  This scheme will receive the newest tunnel and the location of its <em>SpawnPoint</em> component, then spawn a new tunnel at this location. <br><br>  In order for <em>BP_Tunnel</em> to communicate with <em>BP_TunnelSpawner</em> , it needs a link.  Without data transfer, <em>BP_TunnelSpawner</em> will not know where to spawn the next tunnel. <br><br><h3>  Creating a link to the tunnel spuner </h3><br>  Click on <em>Compile</em> and close the <em>SpawnTunnelAtSpawnPoint</em> graph.  Switch to <em>BP_Tunnel</em> . <br><br>  Add a new variable and name it <em>TunnelSpawner</em> .  For the <em>Variable Type,</em> select the <em>BP_TunnelSpawner \ Object Reference</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e66/011/2e6/e660112e6b6beca492b0ebac6a6d7117.jpg"></div><br>  Click on <em>Compile</em> and switch to <em>BP_TunnelSpawner</em> . <br><br>  Open the <em>SpawnTunnel</em> graph and add the indicated nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/ccf/ae1/4f1ccfae12ae1afcaf07c993135970c0.jpg"></div><br>  Now each tunnel will have a link to <em>BP_TunnelSpawner</em> . <br><br>  Next you need to tell <em>BP_TunnelSpawner</em> about the need to spawn the next tunnel when a player enters <em>TriggerZone</em> . <br><br><h3>  Trigger zone scripting </h3><br>  Click on <em>Compile</em> and switch to <em>BP_Tunnel</em> . <br><br>  Go to the Components panel and <em>right-click</em> on <em>TriggerZone</em> .  Select <em>Add Event \ Add OnComponentBeginOverlap</em> .  This will add the following node to the Event Graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/e8c/cf5/9b5e8ccf51454e3570930c40141498ce.jpg"></div><br>  This node will be executed when the other <em>Actor</em> touches <em>TriggerZone</em> . <br><br>  First we need to check whether <em>Actor</em> , concerning <em>TriggerZone</em> , is a player. <br><br>  <em>Drag the</em> <em>Other Actor</em> contact.  Release the <em>left mouse button</em> in the empty space and select <em>Cast to BP_Player</em> from the menu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/f06/b85/9bbf06b85074ab0d8986f94ea452c55f.jpg"></div><br>  <em>Note: the</em> tunnel will spawn at the <i>end of the</i> other tunnel, so it will trigger the <em>TriggerZone</em> trigger of this tunnel.  <em>Cast to BP_Player</em> prevents all further nodes from being executed if the <em>Other Actor</em> is a tunnel. <br><br>  Now add the indicated nodes after the <em>Cast to BP_Player node</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e05/84a/b41/e0584ab41ccec31138fbc648d129671c.jpg"></div><br>  Let's see what happens step by step here: <br><br><ol><li>  When <em>Actor</em> touches <em>TriggerZone</em> , the <em>On Component Begin Overlap (TriggerZone)</em> node is <em>executed.</em> </li><li>  <em>Cast to BP_Player nod</em> checks if the actor is a player </li><li>  If this is a player, then <em>BP_TunnelSpawner</em> will create a new tunnel.  Its location will be located in the <em>SpawnPoint</em> component of the last tunnel created. </li><li>  Since the old tunnel is no longer needed, the game deletes it with the <em>DestroyActor</em> node <em>.</em> </li></ol><br>  Click on <em>Compile</em> , return to the main editor and click <em>Play</em> .  When you reach the end of the tunnel, the game will create a new one. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/1c8/d89/56e1c8d896195a7df7afbdf8705f67ef.gif"></div></div></div><br>  Although the game creates tunnels endlessly, they do not <i>look</i> endless.  You can fix this by making several tunnels visible.  Later, when we connect them with obstacles, the player will not be able to see how tunnels are created. <br><br><h2>  Creating multiple tunnels </h2><br>  The first thing to do is create a function that creates a certain number of tunnels. <br><br>  Open <em>BP_TunnelSpawner</em> and create a new function called <em>SpawnInitialTunnels</em> . <br><br>  To spool a certain number of tunnels, you can use the <em>ForLoop</em> node.  This node will perform the nodes connected to it the specified number of times.  Add a <em>ForLoop</em> node and connect it to the <em>Entry</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4f/35f/550/e4f35f550f27322d7c40d61544fa126e.jpg"></div><br>  For the <em>ForLoop</em> node to run <i>n</i> times, the <em>Last Index</em> must be set to <i>n - 1</i> . <br><br>  In this tutorial we will spawn <em>three</em> tunnels.  To perform three cycles, set the <em>Last Index</em> value to <em>2</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bf/3af/d09/6bf3afd09a9157a87580e7a50f227089.jpg"></div><br>  <em>Note:</em> if you do not specify the <em>First Index</em> or <em>Last Index</em> fields, then by default they will be equal to <em>0</em> . <br>  When the game starts, the player must always be in the tunnel.  To do this, you can create the first tunnel at the location of the player. <br><br><h3>  Creation of the first tunnel </h3><br>  To determine if the first tunnel was created, we can check if <em>NewestTunnel</em> is set.  If not, this means that the first tunnel has not yet been created, because the <em>NewestTunnel</em> is set only <i>after</i> the game creates a tunnel. <br><br>  To perform this check, add an <em>IsValid</em> node (on which there is a question mark) after the <em>ForLoop</em> node. <br><br>  Then we get a link to <em>NewestTunnel</em> and connect it with the <em>Input Object</em> contact of the <em>IsValid</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e5/7dc/9e0/5e57dc9e0ecca9fa7f5c3b483985da53.jpg"></div><br>  If <em>NewestTunnel is</em> not specified, the <em>Is Not Valid</em> node will be executed, and vice versa. <br><br>  Add the following and connect the nodes to the <em>Is Not Valid</em> contact of the <em>IsValid</em> node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/f9b/b59/cfbf9bb59ea0ee5c7d247cd5ecd4ecb4.jpg"></div><br>  This scheme will create a tunnel at the player's Pawn location. <br><br>  Then we need to create the following tunnels. <br><br><h3>  Creating the following tunnels </h3><br>  Add a <em>SpawnTunnelAtAttachPoint</em> node and connect it to the <em>Is Valid</em> contact of the <em>IsValid</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e8/e09/5bd/8e8e095bd88ee7dac271fbf3bc482ee0.jpg"></div><br>  Here is the finished graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/e98/57e/895e9857ea0ff5245f282e382364f8ed.jpg"></div><br>  Summarize: <br><br><ol><li>  The <em>ForLoop node</em> is executed three times. </li><li>  In the first cycle, he spunits the tunnel at the player‚Äôs location. </li><li>  In subsequent cycles, he spunits the tunnel at the <em>SpawnPoint</em> point of the newest tunnel. </li></ol><br>  Now go to the Event Graph and delete the <em>SpawnTunnel</em> node.  Add the <em>SpawnInitialTunnels</em> node after the <em>Event BeginPlay</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/988/37e/c1c/98837ec1c39cdafcf296d656d74af52f.jpg"></div><br>  Click on <em>Compile</em> , go back to the main editor and click on <em>Play</em> .  Now the tunnel is much longer! <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ba/53f/589/1ba53f5894771253ef31d012fddb4108.gif"></div><br></div></div><br>  The game is not very difficult yet, so let's add some obstacles. <br><br><h2>  Creating obstacles </h2><br>  Here are the meshes that we will use as obstacles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/4dd/f4b/ce14ddf4be40faaf166512d1fc8777b4.jpg"></div><br>  Open <em>BP_Tunnel</em> and go to the Components panel.  Add the <em>Static Mesh</em> component and name it <em>WallMesh</em> . <br><br>  Go to the Details panel and change its <em>Static Mesh</em> property to <em>SM_Hole_01</em> . <br><br>  Then set its <em>Location</em> property value <em>(2470, 0, 0)</em> , thus placing it at the end of the tunnel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9e/5e5/c89/e9e5e5c896ef4ab610c9e3ea8ddba497.jpg"></div><br>  To make the game more interesting, the walls must also rotate.  Add a new variable <em>Float</em> and name it <em>RotateSpeed</em> .  Set the <em>Default Value</em> to <em>30</em> . <br><br>  Switch to Event Graph and find the <em>Event Tick</em> node.  Create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/000/28e/ff000028e27ed359bbf3b94a60c4e249.jpg"></div><br>  This will cause <em>WallMesh to</em> rotate each frame by a specified amount. <br><br>  Click on <em>Compile</em> and return to the main editor.  Click on <em>Play</em> to see the walls turn. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/152/d50/45d/152d5045d90a21ffa8996decbf939e2c.gif"></div></div></div><br>  Let's make the game more interesting by adding variability to the walls. <br><br><h2>  Creating wall variations </h2><br>  Instead of creating a new Blueprint for each variation, we can just randomize <em>WallMesh</em> . <br><br>  Open <em>BP_Tunnel</em> and create a new function called <em>RandomizeWall</em> .  Then create the following graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9f/8ff/1b5/a9f8ff1b5db774b5d53a0a64683f7766.jpg"></div><br>  As the name implies, the <em>Set Static Mesh</em> node will set the transmitted mesh to <em>WallMesh</em> . <br><br>  To create a list of static meshes, you can use the <em>Select</em> node. <br><br>  <em>Drag the</em> contact <em>New Mesh</em> .  Release the <em>left mouse button</em> on the empty space and add the <em>Select</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/625/338/3596253383d1c60feef7243389ebe6ae.jpg"></div><br>  <em>Select node</em> allows you to specify a list of options.  The <em>Index</em> entry determines which option the <em>Select</em> node will display. <br><br>  We have four mesh walls, so we need to create two more <em>Option</em> contacts.  This can be done by <em>right-clicking</em> on the <em>Select</em> node by choosing <em>Add Option Pin</em> .  Repeat this operation until you have <em>four</em> Option pins. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6c/050/285/e6c0502850d7d248ba5b81289b341efc.jpg"></div><br>  Now give each option the following values: <br><br><ul><li>  <em>Option 0:</em> SM_Hole_01 </li><li>  <em>Option 1:</em> SM_Hole_02 </li><li>  <em>Option 2:</em> SM_Hole_03 </li><li>  <em>Option 3:</em> SM_Hole_04 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/2b5/a45/4be2b5a458b544ecf5f1963cf723d28a.jpg"></div><br>  Now we will make it so that a random option is chosen. <br><br><h3>  Wall randomization </h3><br>  To obtain a random number, you can use the node <em>Random Integer in Range</em> .  This node returns the value <i>&gt; = <em>Min</em> and &lt;= <em>Max</em></i> . <br><br>  Add a <em>Random Integer in Range</em> node and connect it to the <em>Index</em> contact of the <em>Select</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/a8c/3e4/be8a8c3e41b621c585b1f2e22f4be129.jpg"></div><br>  Set <em>Max</em> to <em>3</em> .  This will give us four possible numbers: 0, 1, 2 and 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/a28/67c/3e8a2867c8005f5f35825fc0c70ccc12.jpg"></div><br>  To add randomness, let's give <em>WallMesh a</em> random twist.  Add the following after the <em>Set Static Mesh</em> node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eae/f80/0ff/eaef800ff60c2fd8d09f88ed535e09e6.jpg"></div><br>  This will add a random rotation to <em>WallMesh</em> from <em>0</em> to <em>360</em> degrees. <br><br>  Here is the finished graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/322/99e/29732299e7584d27727fd0de5c8248dd.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Select node</em> passes the list of meshes. </li><li>  A random mesh is selected using the <em>Random Integer in Range</em> node. </li><li>  The <em>Set Static Mesh</em> <em>node</em> sets the <em>WallMesh</em> mesh to be selected. </li><li>  The <em>AddLocalRotation node</em> adds an offset to the random rotation of <em>WallMesh</em> </li></ol><br>  Click on <em>Compile</em> and close the <em>RandomizeWall</em> graph. <br><br>  Switch to <em>BP_TunnelSpawner</em> and open the <em>SpawnTunnel</em> graph.  Add selected node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d4/ddc/a93/5d4ddca9344368237208d96be823ada2.jpg"></div><br>  Now, when the tunnel goes down, it will have a random wall mesh. <br><br>  Close the <em>SpawnTunnel</em> graph and click on <em>Compile</em> .  Return to the main editor and click on <em>Play</em> to see the wall variations! <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/af5/400/d23af5400858e451eb7c29e5ea1ce845.gif"></div></div></div><br>  If you run into a wall.  then stop moving forward.  However, if you continue to move and go through the hole, then you will start moving forward again. <br><br>  The next step is to turn off the movement forward after the player collides with the wall. <br><br><h2>  Handling collisions with walls </h2><br>  To enable and disable forward motion, you can use the <em>Boolean</em> variable.  It has only two states: <em>true</em> and <em>false</em> . <br><br>  Open the <em>BP_Player</em> and create a new <em>Boolean</em> variable called <em>IsDead</em> . <br><br>  Go to the <em>Event Tick</em> node and create a <em>Branch</em> node. <br><br>  Now get a link to <em>IsDead</em> and connect it to the <em>Condition</em> contact of the <em>Branch</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/7ec/b08/ecd7ecb08d439d234612c08aee08ae52.jpg"></div><br>  Connect the <em>Event Tick</em> node to the <em>Branch</em> node.  Then connect the <em>False</em> pin of the <em>Branch</em> node to the AddActorWorldOffset <em>node</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/6b7/688/9216b7688f6ebec97f5a080cf1dc6dd6.jpg"></div><br>  Now when <em>IsDead</em> is <em>true</em> , the player will stop. <br><br>  Now we need to set the <em>IsDead</em> variable when the player collides with the wall. <br><h3>  Setting the IsDead variable </h3><br>  Click on <em>Compile</em> and switch to <em>BP_Tunnel</em> .  In the Components panel, <em>right-click</em> on <em>WallMesh</em> and select <em>Add Event \ Add OnComponentHit</em> .  This add the following node to the Event Graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/897/edb/5d2897edbb07f354c543a96999d341a7.jpg"></div><br>  This node will be executed when another <em>Actor</em> <em>collides</em> with <em>WallMesh</em> . <br><br>  First, we need to check if <em>Actor</em> is a player facing <em>WallMesh</em> . <br><br>  <em>Drag the</em> <em>Other Actor</em> contact.  Release the <em>left mouse button</em> on the empty space and select <em>Cast to BP_Player</em> from the menu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/5e9/95e/5625e995ecb37e5523de2cd3069480d6.jpg"></div><br>  <em>Drag a</em> <em>BP_Player</em> contact <em>to the Cast to BP_Player node</em> .  Release the <em>left key</em> on the empty space and add the <em>Set Is Dead</em> node. <br><br>  Set <em>IsDead</em> to <em>true</em> by <em>checking the box</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/e5c/f2e/970e5cf2eea379c10a6b8e0044242528.jpg"></div><br>  Click on <em>Compile</em> and return to the main editor.  Click on <em>Play</em> and try to face the wall.  If you move to the hole, you will not move further through it. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a6/772/77a/1a677277a390d348c1ae3972c98ef05d.gif"></div></div></div><br>  In the next section, we will learn how to display the restart button when a player hits a wall. <br><br><h2>  Display restart button </h2><br>  The widget we will display is called <em>WBP_Restart</em> .  It can be found in the <em>UI</em> folder.  Here is what it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/020/39a/8a302039a700be792e81d1b37e62e3c2.jpg"></div><br>  To display or hide a widget, we need a link to it.  Open <em>BP_Player</em> and create a new <em>RestartWidget</em> variable.  Change the <em>Variable Type</em> to the <em>WBP_Restart \ Object Reference</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b7/092/f36/8b7092f36cb17c73dc74d16c9e9f93c5.jpg"></div><br>  Then go to the Event Graph and find the <em>Event BeginPlay</em> node. <br><br>  Add a <em>Create Widget</em> node and set the <em>Class</em> to <em>WBP_Restart</em> . <br><br>  Now add the <em>Set Restart Widget</em> node and connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/bde/8ca/9e4bde8ca495be3cb18e067a9c2fbd66.jpg"></div><br>  Now, when the player spawns, we will create an instance of <em>WBP_Restart</em> .  The next step is to create a function that displays this instance. <br><br><h3>  Creating a mapping function </h3><br>  Create a new function and name it <em>DisplayRestart</em> .  Having done this, create the following graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/ad0/af2/4b0ad0af2095fe45f0a8d09f2652387e.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Add to Viewport</em> displays <em>RestartWidget</em> on the screen. </li><li>  <em>Set Input Mode UI Only</em> allows the player to interact only with the UI.  We make it so that the player cannot move while he is dead. </li><li>  As the name implies, <em>Set Show Mouse Cursor</em> simply displays the mouse cursor. </li></ol><br>  To display the restart button, we just need to call <em>DisplayRestart</em> after a player collides with a wall. <br><br><h3>  Call display function </h3><br>  Close the <em>DisplayRestart</em> graph and click on <em>Compile</em> . <br><br>  Switch to <em>BP_Tunnel</em> and locate the <em>On Component Hit</em> node <em>(WallMesh)</em> . <br><br>  Add a <em>DisplayRestart</em> node to the end of the node chain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/013/898/7e4/0138987e44e8b0d35cff8ec6567517bc.jpg"></div><br>  Click on <em>Compile</em> and close <em>BP_Tunnel</em> .  Return to the main editor and click on <em>Play</em> .  When a player hits a wall, a restart button is displayed. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cf/580/8ef/7cf5808efcc7119c2f1387e6a5620cc1.gif"></div></div></div><br>  The final step is to restart the game when you click on the button. <br><br><h2>  Restart game </h2><br>  When restarting, the game must perform two actions: <br><br><ol><li>  Reset the player status.  This includes hiding the restart button from the screen. </li><li>  Re-create tunnels.  Thus, the player starts from the beginning of the tunnel. </li></ol><br>  Let's start by resetting the player. <br><br><h3>  Player reset </h3><br>  Open <em>BP_Player</em> and create a new function <em>RestartGame</em> .  Create the following graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/b30/e66/e1ab30e6683d35fef47d295833e8dc35.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Set Is Dead</em> sets <em>IsDead</em> to <em>false</em> .  This again includes the possibility of moving forward. </li><li>  <em>Remove From Parent</em> removes <em>RestartWidget</em> from the screen </li><li>  <em>Set Input Mode Game Only</em> again includes the ability to control the game so that the player can move </li><li>  <em>Set Show Mouse Cursor</em> hides the mouse cursor. </li></ol><br>  Now we need to create the tunnels again. <br><br><h3>  Re-creating tunnels </h3><br>  Click on <em>Compile</em> and close the <em>BP_Player</em> . <br><br>  Open <em>BP_TunnelSpawner</em> and go to the <em>SpawnInitialTunnels</em> graph. <br><br>  First, before creating new tunnels, we need to delete the existing ones. <br><br>  Add a <em>Sequence</em> node after the <em>Entry</em> node.  Connect the <em>Then 1</em> pin to the <em>ForLoop</em> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81e/aea/bc9/81eaeabc93807a6d22c46efbcfbd0ff2.jpg"></div><br>  <em>Note:</em> <em>Sequence</em> node executes its outputs in sequential order.  This is a great way to arrange the graph vertically, especially when the node chains are very long. <br><br>  Then create the following nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74c/386/0ed/74c3860ed6a2f8afca126e7adc60e7ed.jpg"></div><br>  This scheme will receive all existing tunnels and remove them from the game. <br><br>  Finally, connect the <em>Then 0</em> contact of the <em>Sequence</em> node to the <em>Get All Actors of Class</em> node.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to this, the tunnels are deleted before the creation process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the final graph:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/979/089/f71/979089f71313aed4ddddb6b1382907f3.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The last thing to do is to process the click of a button. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing button presses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and close </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP_TunnelSpawner</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go to the Content Browser and locate the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder </font><font style="vertical-align: inherit;">. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Double click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WBP_Restart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to open it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestartButton</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and go to the Details panel. </font><font style="vertical-align: inherit;">Go to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><font style="vertical-align: inherit;">and click on the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">button</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> next to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnClicked</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3db/773/3e8/3db7733e8bcb7656347f66c8616126da.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will create an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Clicked</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node </font><em><font style="vertical-align: inherit;">(RestartButton)</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This node is executed when the player clicks on the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestartButton</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recreate the following pattern:</font></font><br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8b8/608/fcf/8b8608fcf341b483f3edf5f221aaec24.jpg"></a> </div><br>  Summarize: <br><br><ol><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Owning Player Pawn</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns the </font><em><font style="vertical-align: inherit;">pawn that the player</font></em><font style="vertical-align: inherit;"> currently controls.</font></font></li><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast to BP_Player</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> checks if Pawn belongs to the class </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP_Player</font></font></em> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If so, it calls the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestartGame</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This function resets the player and hides the restart button.</font></font></li><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get All Actors of Class</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP_TunnelSpawner</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and calls </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpawnInitialTunnels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This function removes all existing tunnels and spunits new ones.</font></font></li></ol><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You may be wondering why I did not use the reference variable for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP_TunnelSpawner</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The main reason is that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BP_Tunnel is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not associated with </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WBP_Restart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For our simple game, it is easier to implement this method than to figure out where to store the reference variable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and close the Blueprint editor. Click on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Play</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to test the restart button!</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/be6/2e9/8acbe62e918fa8f0b2515c8fc016cf39.gif"></div></div></div><br><h2>  Where to go next? </h2><br>  Download the finished project <a href="">here</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a simple game, we can start creating something else based on it. </font><font style="vertical-align: inherit;">Try adding a point counter, increasing when the player avoids hitting the wall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try also to implement simple classic games like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pong</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetris</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The mechanics of these games are simple, but they can be difficult to implement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to continue exploring, read the </font></font><a href="https://habrahabr.ru/post/344840/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next post in the series</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will show you how to animate game characters using Blueprints.</font></font></div><p>Source: <a href="https://habr.com/ru/post/344690/">https://habr.com/ru/post/344690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344678/index.html">Japanese poetry in the service of learning English: an application for memorizing the pronunciation of words</a></li>
<li><a href="../344680/index.html">5-minute guide to esoteric programming languages: try to classify them</a></li>
<li><a href="../344682/index.html">Error on the site ... What to do?</a></li>
<li><a href="../344684/index.html">We learn the car to understand languages</a></li>
<li><a href="../344686/index.html">Tanchiki in the console, the second article: "It is time to redo everything!"</a></li>
<li><a href="../344692/index.html">The transfer pattern scala.concurrent.Promise to the actor: usage features and alternatives</a></li>
<li><a href="../344694/index.html">Deploy Parallels RAS to Microsoft Azure in half an hour</a></li>
<li><a href="../344696/index.html">Guide to writing secure PHP applications in 2018</a></li>
<li><a href="../344700/index.html">ATOL Online: a look from the data center</a></li>
<li><a href="../344702/index.html">What you need to know to become a system architect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>