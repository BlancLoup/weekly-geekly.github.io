<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visual programming in DRAGON</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual and text programming 


 What is the driving force behind the program? What generates a useful result? Of course, the algorithm. The algorithm ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visual programming in DRAGON</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vizualnoe-i-tekstovoe-programmirovanie">  Visual and text programming </h2><br><p>  What is the driving force behind the program?  What generates a useful result?  Of course, the algorithm.  The algorithm creates the effect for which the program is written.  The algorithm does not work alone.  It works in conjunction with data structures.  But it is the algorithms that make up the largest part of the program. </p><br><p>  Historically, the algorithms in programs are written in the form of source code.  Almost no one questions that the text is the best means of representing algorithms.  The algorithm is encoded inside functions in a programming language, such as C or JavaScript.  For those who want to understand the algorithm from a bird's eye view, pseudocode is provided.  However, there are serious problems with the text.  The fact is that a person is not optimized for a solid text.  The person is optimized for perception of graphics.  The text is a relatively new invention, but organisms have been processing graphic information for millions of years. </p><br><p>  Based on this, it would be logical to make the algorithms in graphical form.  Look at the engineers.  They use drawings everywhere.  What is worse for programmers?  They, too, could make drawings of algorithms.  Some will object: visual programming is supposedly ineffective.  UML is inconvenient, and it is easy to get confused in block diagrams.  It is better to program in the traditional way - the text.  In structured programming, there is at least a structure, and it provides order and uniformity.  And besides, drawing charts is long and difficult.  Typing is faster than drawing. </p><br><p>  So, programmers are doomed all their life to work only with text? <br>  Perhaps not everything is so bad.  There are visual languages ‚Äã‚Äãfor representing algorithms that also have order and structure, for example DRAGON, BPMN and LML Action Diagrams.  Here we look at the dragon visual algorithmic language. </p><br><h2 id="kak-programmirovat-na-yazyke-drakon">  How to program in the language of DRAGON </h2><br><p>  DRAGON is not an independent programming language.  He works in tandem with <a name="habracut"></a>  textual language, for example, with javascript, python or c ++.  Together with the text language, DRAGON forms a hybrid language: DRAGON-JavaScript, DRAGON-Python or DRAGON-C ++. </p><br><p>  Programming in a hybrid language is as follows: </p><br><ol><li>  Draw a dragon diagram. </li><li>  Inside the icons we put small pieces of code in the appropriate programming language. </li><li>  The program-translator converts the DRAGON-scheme into a text file with the source code. </li><li>  This text file is included in the project in the usual way. <br>  The generation of code from diagrams is currently supported by several editors.  The examples in this article are made in the DRAKON Editor. </li></ol><br><h2 id="generaciya-koda-iz-diagrammy">  Code generation from chart </h2><br><p>  In the diagram, DRAGON takes control of the flow of execution.  Therefore, the pieces of the source code in the icons should not contain keywords such as <strong>if</strong> , <strong>else</strong> , <strong>switch</strong> , <strong>case</strong> , <strong>for</strong> , <strong>while</strong> , etc. </p><br><p>  Inside the icons there should be only a simple unambiguous code: arithmetic expressions, assignment of values, function calls, comparisons.  But the branching and cycles are implemented by constructions of the language DRAGON. </p><br><p>  It is also not recommended to use logical expressions: and, or, not.  They are also portrayed by means of DRAGON. </p><br><p>  The code is generated as follows: </p><br><ul><li>  A function is created from each diagram. </li><li>  The name of the chart becomes the name of the function. </li><li>  The function parameters are taken from the ‚ÄúFormal Parameters‚Äù icon, which is located to the right of the diagram name. </li><li>  The function body is generated based on the structure of the diagram and the contents of the icons. </li></ul><br><p>  In fig.  Figure 1 shows an example of a small diagram in the DRAGON-JavaScript hybrid language and the generated JavaScript code: </p><br><p>  The rectangle with the text <strong>console.log (cat, dog)</strong> in fig.  1 is the action icon.  How much code can be put into one ‚ÄúAction‚Äù icon?  You should strive to ensure that one icon contained one thought.  Sometimes this is one line of code, sometimes several. <br>  The generated code is provided with comments, which contain the number of icons.  While in the editor, you can quickly jump to any icon by pressing Ctrl + I. <br></p><br><img src="https://habrastorage.org/webt/fw/_y/lb/fw_ylbkraqm_bgc_xobkv3umcfw.png" alt="image"><br>  <strong>Figure 1.</strong> The diagram on DRAGON-JavaScript and the code generated from it. <br><br><h2 id="ikona-vopros">  Icon "Question" </h2><br><p>  For branching, the Question and Choice icons are applied. </p><br><p>  The Question icon (fig. 2) corresponds to the <strong>if-then-else construction</strong> . </p><br><p>  Note that instead of the words <strong>true</strong> and <strong>false</strong> , the words <strong>Yes</strong> and <strong>No are used</strong> (you can switch to <strong>Yes</strong> and <strong>No</strong> ). </p><br><p>  "Truth" and "false" - it sounds spectacular, as a scientist.  However, the person closer familiar from early childhood, "yes" and "no." </p><br><p>  The inscriptions <strong>Yes</strong> and <strong>No</strong> can be interchanged.  The position of exits from the Question icon remains unchanged.  One exit goes down, and the other - to the right.  A branch in the DRAGON language is always directed to the right, therefore, the exit from the left side of the icon is prohibited.  Such predictability makes it easier to read a diagram, since the reader knows in advance where to look for outputs. </p><br><p>  Another feature of the language DRAGON is that for branching is not used a complete rhombus, and truncated.  This saves space on the chart. <br></p><br><img src="https://habrastorage.org/webt/4c/bg/rm/4cbgrm-qrhuonbnywdpokn9suy0.png" alt="image"><br>  <strong>Figure 2.</strong> Question Icon <br><br><h2 id="vizualnye-logicheskie-formuly">  Visual logical formulas </h2><br><p>  The language DRAGON makes unnecessary the logical operators <strong>AND</strong> , <strong>OR,</strong> and <strong>NOT</strong> , as well as the "not equal" operator.  The logical operations themselves are of course necessary.  But instead of text operators, DRAGON introduces visual logical formulas. </p><br><p>  To get a visual logical formula, you should combine several Question icons (as in Fig. 3). </p><br><p>  Especially nice to get rid of denial.  Denial is not intuitive, it brings errors and inconvenience.  Negation (the logical <strong>NOT</strong> operator) is achieved in the language of DRAGON by permuting the <strong>Yes</strong> and <strong>No</strong> labels. </p><br><p> The textual record of logical expressions is definitely more compact.  However, visual formulas are easier to read.  Each of the possible combinations of operand values ‚Äã‚Äãcan be traced with a finger. <br></p><br><img src="https://habrastorage.org/webt/tb/1w/lv/tb1wlvnhgzelsiuseopaci6utpi.png" alt="image"><br>  <strong>Figure 3.</strong> Visual logical formulas 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2 id="cikl-so-strelkoy">  Loop with arrow </h2><br><p>  To indicate the usual order of execution in the language of the DRAGON arrows are not needed.  The next icon is always below.  An arrow is required only when the thread of execution must jump upwards in the diagram.  Such a jump up means a cycle.  Therefore, the arrow in the language of DRAGON is a sign of the cycle.  With a cursory glance at the DRAGON-scheme, the arrows are immediately noticeable.  So, immediately visible and cycles.  This is a major advantage of DRAGON compared to other graphic languages.  Cycles do not have to seek out. </p><br><p>  So, if you connect the icon "Question" with an arrow, you get a cycle.  This is an analogue of the <strong>while</strong> and <strong>do-while</strong> constructs.  Figure 4 shows several types of cycles with arrows. <br>  The Question icon in a loop with an arrow checks the exit condition of the loop.  Of course, instead of one ‚ÄúQuestion‚Äù icon there can be several.  Then the visual logic formula is responsible for exiting the loop. <br></p><br><img src="https://habrastorage.org/webt/e3/d8/px/e3d8pxefg8ott-t5cngpluzeew8.png" alt="image"><br>  <strong>Figure 4.</strong> Switch cycles <br><br><h2 id="ikona-vybor">  Icon "Choice" </h2><br><p>  The "Question" icon contains a logical expression, that is, it can take two values: <strong>Yes</strong> and <strong>No.</strong>  A typical example is the comparison of two objects.  If you need to compare a certain expression with several values, the ‚ÄúSelect‚Äù icon is used (Fig. 5).  This corresponds to the <strong>witch-case</strong> design. </p><br><p>  The values ‚Äã‚Äãwith which the expression in the ‚ÄúSelect‚Äù icon will be compared are placed in the ‚ÄúOption‚Äù icons.  If there is no text in the rightmost variant, it means ‚Äúall other values‚Äù.  Such an empty variant is similar to the <strong>default</strong> keyword inside a <strong>switch statement</strong> . <br>  The rightmost option may end with an arrow that leads up.  In this case, we again deal with the pointer cycle.  In this cycle, the Choice icon and not the Question will answer for the exit condition. <br></p><br><img src="https://habrastorage.org/webt/g7/kz/hh/g7kzhhq94_owo_l27-2qudtfpaw.png" alt="image"><br>  <strong>Figure 5.</strong> Icon "Choice" and icons "Option" <br><br><h2 id="ikona-cikl-dlya">  Icon "Cycle FOR" </h2><br><p>  Instead of the <strong>for</strong> and <strong>foreach</strong> cycles in DRAGON-JavaScript, the ‚ÄúFOR loop‚Äù icon is used.  The icon "Cycle FOR" (Fig. 6) can be of several types. </p><br><p>  If there is one variable after the <strong>foreach</strong> keyword and before the semicolon, then code is generated for iterating over the array.  The variable will contain the elements of the array (but not their indices). </p><br><p>  If there are two variables after the <strong>foreach</strong> keyword, the DRAKON Editor will understand that it is necessary to iterate over the properties of an object (hash table entries).  Only the own properties of the objects fall into the listing. </p><br><p>  The third variant of the cycle implies the presence of three expressions separated by semicolons.  This is a traditional <strong>for</strong> loop, characteristic of C and Java languages. </p><br><p>  From the cycle under the control of the ‚ÄúCycle FOR‚Äù icon, an early exit is possible with the help of the ‚ÄúQuestion‚Äù or ‚ÄúSelect‚Äù icon.  This output roughly corresponds to the keyword <strong>break</strong> . <br></p><br><img src="https://habrastorage.org/webt/pl/ef/o5/plefo5v3mq7aanzxwcyrngc4qv0.png" alt="image"><br>  <strong>Figure 6.</strong> Different types of the ‚ÄúFOR Cycle‚Äù icon in DRAGON-JavaScript <br><br><h2 id="tolko-odin-vhod-v-cikl">  Only one cycle entry </h2><br><p>  In the language of DRAGON on the cycles imposed restrictions.  Each cycle can have only one input.  The purpose of this restriction is to ensure readability.  This restriction holds DRAGON within the framework of structured programming, as Dijkstra described it. </p><br><p>  Multiple exits from the loop are valid, but there should be only one input.  In fig.  7 shows cycles that have two outputs.  It is allowed.  In fig.  8 shows examples of forbidden cycles.  Prohibited because they can enter in different ways. <br>  However, do not memorize the appearance of these forbidden cycles.  DRAKON Editor will automatically detect such cycles and generate an error. <br></p><br><img src="https://habrastorage.org/webt/n3/i-/rk/n3i-rklwenrjle4x569ff-kgtg4.png" alt="image"><br>  <strong>Figure 7.</strong> Allowed cycles, which have two outputs <br><br><img src="https://habrastorage.org/webt/bg/l5/a_/bgl5a_cxrb_s_8cs5ijww_92pqi.png" alt="image"><br>  <strong>Figure 8.</strong> Forbidden cycles that have two inputs <br><br><h2 id="otlichiya-ot-tekstovogo-strukturnogo-programmirovaniya">  Differences from text structured programming </h2><br><p>  As you can see, the icons and macro-languages ‚Äã‚Äãof the DRAGON language have correspondence with the standard structures of text structured programming.  However, there are differences.  The text, even with indentation, is a one-dimensional object.  And the diagram is two-dimensional.  An additional degree of freedom appears in the diagram, which enhances expressiveness.  Try, for example, in a text programming language without repetitions and <strong>goto to</strong> depict such an algorithm, as in Fig.  9. </p><br><p>  Despite the additional freedom compared to the text, the DRAGON still does not allow anarchy to strike.  Its rules are harsh enough to prevent confusion.  DRAGON provides a reasonable compromise between flexibility and rigor. <br></p><br><img src="https://habrastorage.org/webt/fe/45/am/fe45amuu6xxalzapte_guiyd-mc.png" alt="image"><br>  <strong>Figure 9.</strong> Algorithm that is difficult to portray only with text. <br><br><h2 id="preimuschestva-graficheskogo-yazyka">  Benefits of graphic language </h2><br><p>  The language DRAGON has an interesting fate.  Its basic principles were laid down by Dykstra itself.  The current form of the dragon acquired in the depths of the Russian space industry.  It is noteworthy that the rules of the language DRAGON did not arise by chance.  They were first tested in focus groups, and then honed in real space projects. <br>  So what exactly are the strengths of the DRAGON? </p><br><p>  Let's start with the fact that DRAGON is a graphic language.  And the graphic language has fundamental advantages over the text. </p><br><p>  First, thoughts are not spread out randomly in lines, but enclosed within squares, or icons.  One thought - one square.  Different thoughts do not stick together in one mess. </p><br><p>  Secondly, the path through the algorithm can be traced with a finger (or glance).  After <strong>if you</strong> do not need to look <strong>elsewhere</strong> .  Follow the line and get into the right box.  You do not need to run your eyes on the source code in search of an answer to the question: what happened next? </p><br><p>  And diagrams have one almost magical property.  It happens that a person looks at a diagram, and suddenly some additional understanding comes.  Previously invisible connections become apparent.  With the text it happens rarely. </p><br><h2 id="osobye-ergonomicheskie-pravila">  Special ergonomic rules </h2><br><p>  But DRAGON is not just diagrams, it‚Äôs carefully thought-out diagrams.  DRAGON schemes are perceived more easily than conventional block diagrams.  This is provided by special ergonomic techniques.  Here are some of them. </p><br><ul><li>  Crossing lines is prohibited.  At all.  Intersections cause our visual analyzer to suspect that the lines are touching, which means that they are somehow connected.  These suspicions create additional mental work.  Unnecessary work should be discarded. </li><li>  The beginning contains the name of the algorithm and is always located in the upper left corner of the diagram.  Therefore, even the beginning of the search is not necessary.  It is where it is usually. </li><li>  The diagram has only one end.  Whatever happens along the road (except for exceptions), we will always come to the end. </li><li>  Only straight lines are allowed.  No curves and bends, as well as unnecessary kinks. </li><li>  Only strictly vertical and strictly horizontal lines are allowed.  Slanted lines are prohibited.  Explanation for mathematics lovers: DRAGON-scheme is a flat rectangular graph (Manhattan graph).  The human visual apparatus instantly grasps objects connected by straight orthogonal lines.  But keeping track of where the ‚Äúcurve of the American dream‚Äù will lead, requires additional concentration from the reader. </li><li>  DRAGON-scheme is executed from top to bottom.  This rule avoids the need to frantically scan the chart with your eyes in search of the next icon.  The next icon is always below.  The entrance is from the icon above, and the exit is below.  Since we know where the next icon is, then the arrows are not needed.  Enough simple lines.  The arrows beside each icon are visual noise.  By removing the task of connecting icons from the arrows, you can assign a special mission to them.  In DRAGON, an arrow means a cycle. </li><li>  Branching occurs only to the right.  This is a great help in terms of predictability and uniformity. </li><li>  Icons that are on the same vertical should have the same width.  This gives a feeling of belonging to the icons to a single whole.  When everyone has the same width and no upstart icons, the eye slides freely and easily along the chart. </li></ul><br><p>  The above rules have tremendous practical value.  On the one hand, they are designed to curb the madness of the artist.  Creating an intricate diagram with them is more difficult.  On the other hand, they bring recognition to the charts.  Charts are understandable not only to their authors. </p><br><p>  The diagrams in fig.  10 and 11 demonstrate the ergonomic techniques of the language DRAGON with real examples. <br></p><br><img src="https://habrastorage.org/webt/58/si/8d/58si8dwuuae5jrsoopsjlfcgjf0.png" alt="image"><br>  <strong>Figure 10.</strong> Ergonomic techniques of the language DRAGON using an example <br><br><img src="https://habrastorage.org/webt/41/lh/xr/41lhxrqxsbmv3lovflfetrineto.png" alt="image"><br>  <strong>Figure 11.</strong> Another example of a dragon chart <br>  In addition to ergonomic techniques, the language DRAGON has unique features that are not found anywhere else. <br><h2 id="chem-pravee-tem-huzhe">  The more right, the worse </h2><br><p>  DRAGON has the facility to image the <em>happy path</em> , or <em>royal road</em> .  The royal road is the most successful way through the algorithm.  In some algorithms, the concepts of ‚Äúsuccessful / unsuccessful‚Äù, ‚Äúgood / bad‚Äù are not applicable.  In them, the royal road shows the most expected path.  The royal road runs vertically, located on the left side of the diagram.  This vertical is called skewer.  Less likely and less successful scenarios, as well as error handling, are placed on the right side of the diagram.  And the worse the situation, the more right it should be located.  A good style is to place a code that throws exceptions or returns an error code to the right of the diagram. </p><br><p>  If the reader is not interested in reading the error handling code, all he needs to do is look through the skewer only. </p><br><h2 id="obschaya-sudba">  Common fate </h2><br><p>  Sometimes it happens that on different paths through the algorithm it is necessary to carry out various, but somehow related actions.  For example, put different values ‚Äã‚Äãin one variable.  Common fate is when related actions sit on different vertical lines, but on the same horizontal. </p><br><p>  Fig.  12 shows the skewer with the royal road, as well as the use of the ‚Äúcommon fate‚Äù technique. <br></p><br><img src="https://habrastorage.org/webt/yz/v3/gm/yzv3gmme-glttgy0kxzbikiky5u.png" alt="image"><br>  <strong>Figure 12.</strong> Tsar's road and common destiny <br><br><h2 id="siluet">  Silhouette </h2><br><p>  The silhouette is a real dragon diamond.  Silhouette allows you to break the diagram into logical parts.  In programming, this is usually done using decomposition using subroutines.  Subroutines - effective method.  But sometimes I would like to locate the subroutine visually close to the main program, as well as avoid fussing with passing parameters and returning values.  For these purposes, a great silhouette.  Another use of the silhouette is state machines.  But we'll talk about this in another place. <br>  It happens that the algorithm fails to expand on a plane so that there is no intersection of lines.  In this case, depending on the situation, apply either decomposition using subroutines, or silhouette. </p><br><p>  The silhouette consists of several small diagrams connected in one integral block.  These small diagrams are called silhouette branches.  At the top of each branch there is an icon "Branch Cap", below - an icon "Address".  In the header of the branch put the name of this branch, and in the address indicate the name of the next branch.  The names of the branches are located on the same horizontal line at the top of the diagram.  Due to this, you can grasp the essence of the algorithm by running only on the caps of the branches.  The silhouette answers three royal questions: </p><br><ol><li>  What is the problem called? </li><li>  How many parts does it consist of? </li><li>  What are these parts called? </li></ol><br><p>  Consider the example in fig.  13. Here are the answers to the royal questions: </p><br><ol><li>  What is the problem called?  Sort the linked list. </li><li>  How many parts does it consist of?  Of the four. </li><li>  What are these parts called?  Build a matrix of relationships.  Check for cycles.  Go through the matrix of connections.  To complete. </li></ol><br><p><img src="https://habrastorage.org/webt/fq/ni/iu/fqniiuetgqzdnru_8_ooz0pkxc4.png" alt="image"><br>  <strong>Figure 13.</strong> DRAGON-scheme "silhouette" <br></p><br><h2 id="siluetnyy-cikl">  Silhouette cycle </h2><br><p>  Branches of the silhouette should be ordered from left to right.  In some cases, it is necessary to perform some kind of branch or group of branches several times.  This design is called the silhouette cycle.  If the ‚ÄúAddress‚Äù icon points to its own branch, or to a branch that is located to the left, it should be marked with a special label.  The same label should be put on the corresponding icon ‚ÄúBranch of the branch‚Äù (see fig. 14).  The purpose of the label is to make the silhouette cycle visible. <br></p><br><img src="https://habrastorage.org/webt/uh/ya/qu/uhyaquy8hssk7kp78hlhkfx0zhq.png" alt="image"><br>  <strong>Figure 14.</strong> Silhouette cycle and labels <br><br><h2 id="soedinenie-vetok-silueta-zaprescheno">  The connection of the branches of the silhouette is prohibited </h2><br><p>  Joints of two branches of the silhouette (as in Fig. 15) are prohibited.  Each branch inside the silhouette should be independent. <br></p><br><img src="https://habrastorage.org/webt/ca/dl/tt/cadlttwijosoih7k3ij9mrgahyy.png" alt="image"><br>  <strong>Figure 15. The</strong> connection of the branches of the silhouette is prohibited. <br><br><h2 id="razmer-diagramm">  Chart size </h2><br><p>  During programming in DRAGON, the question arises: how big should the diagrams be?  The answer is: less is better.  The fewer objects in the visual scene, the clearer.  In text programming, there is such a guide: well, if the entire function fits entirely on the screen.  Similar advice can be given for DRAGON-schemes.  Avoid huge charts.  When the entire algorithm is fully visible, it is much easier to understand. <br>  For programming on DRAGON it is better to have a large monitor.  At least 1080 points in height.  Then you will not have to artificially shorten the DRAGON-schemes. </p><br><p>  DRAGON-scheme <em>silhouette</em> should be placed on the screen in height, but not necessarily in width.  <em>Silhouette</em> diagrams can be quite wide, much wider than 2000 pixels.  This is normal.  It is not necessary to see all branches of the silhouette at the same time.  The main thing is that the branch with which you are currently working was fully visible on the screen. </p><br><h2 id="kritika-programmirovaniya-na-drakone">  Criticism of programming on DRAGON </h2><br><p>  Consider the main directions of criticism of programming on DRAGON and try to give an answer to them. </p><br><ul><li>  ‚ÄúDRAGON schemes take up more screen space than text programs.‚Äù That's true.  But we must bear in mind that the task of DRAGON is to show the complexity as it is.  The reader of the program should not unpack complex structures in the head.  They must be shown to him explicitly. </li><li>  "Simple algorithms look better in text form."  Maybe.  Hello world looks elegant in any language.  But in real life, not everything is simple.  As soon as at least one <strong>if</strong> appears, nested in another <strong>if</strong> , DRAGON wins. </li><li>  ‚ÄúDRAGON does not have the means to display exceptions.‚Äù There is such a problem.  Exceptions have recently been added to the DRAGON language, but not all implementations support them.  As long as the implementations have not arrived, you can write try / catch blocks in the appropriate programming language. </li><li>  ‚ÄúDRAGON schemes for a long time to draw.‚Äù In specialized editors it is much easier to draw DRAGON schemes than, for example, in Visio.  And in some of them, drawing was almost as easy as writing. </li><li>  ‚ÄúThere are no tools for diff and merge.‚Äù This, unfortunately, is the case.  When working with a version control system, you have to compare generated source files. </li><li>  ‚ÄúThere are no debugging tools for DRAGON circuits.‚Äù That's true.  But you can debug the generated code.  It has labels that indicate to which place in the diagram this piece of code belongs. </li></ul><br><h2 id="obzor-yazyka-drakon">  Dragon language overview </h2><br><p>  Figure 16 presents an overview of the language DRAGON. <br></p><br><img src="https://habrastorage.org/webt/h9/xz/j_/h9xzj_amde1wcdrq9huid3h9pr8.png" alt="image"><br>  <strong>Figure 16.</strong> Overview of the DRAGON <br><br><h2 id="instrumenty-dlya-raboty-s-yazykom-drakon">  Tools for working with the dragon language </h2><br><p>  The very first implementation of the language DRAGON was the GRAFIT-FLOX system (Fig. 17).  GRAPHITE-FLOX was created in 1986-1996.  specialists of FSUE NPTs AP them.  Pilugin under the direction of V.D.  Parondzhanov.  This environment was intended for the design of control systems for launch vehicles and spacecraft. </p><br><p>  GRAPHITE-FLOX is a closed development, so relatively little is known about it.  The list of spacecraft created using GRAPHITE-FLOX can be found <a href="http://drakon.su/primenenija/start">here</a> . </p><br><p>  In the early 1990s, another dragon editor was created.  The development was carried out at the Institute of Applied Mathematics.  Keldysh under the leadership of L.K.  Aysymont.  Eisymont's editor (fig. 18) can be <a href="http://drakon.su/instrumenty/eysymont">downloaded</a> and launched, but it is no longer supported.  The editor is written under MS DOS, so DOSBox may be required to run on modern computers. </p><br><p>  In 2008, the editor of the IP Dragon from Gennady Tyshov saw the light (Fig. 19).  IP Dragon is actively maintained and developed.  In the Dragon IP, the generation of program code from diagrams is implemented.  One of the interesting features of Dragon IP is the ability to place in one icon a code in a programming language and a description in a natural language.  The absolute dignity of IP Dragon - the so-called "calculus of icons."  Icon calculus is an editing method that helps the user draw a diagram and ensures that the diagram does not violate the rules of the DRAGON language.  Among the drawbacks of the Dragon IP system are a non-standard user interface and some inconveniences when generating code.  IP Dragon is a commercial product. </p><br><p>  DRAKON Editor - another modern dragon editor (Fig. 20).  DRAKON Editor was developed by a group of enthusiasts under the leadership of Stepan Mitkin.  DRAKON Editor does not support the calculation of icons.  This means that DRAGON-schemes are assembled in it manually from primitives, as in vector graphics editors.  But the user interface in the DRAKON Editor is as simple as possible.  It is built on a more familiar pattern than the Dragon IP.  The main advantage of the DRAKON Editor environment is the ease of programming and code generation.  DRAKON Editor supports several programming languages, including C, C ++, C #, Java, Processing, JavaScript, Lua, Erlang, Python, Tcl, Verilog, AutoHotkey, D, and Go.  For some languages, it is possible to generate state machines.  The rules for nools expert system are supported.  Implemented a subset of the language Utopiste E. Tyugu.  DRAKON Editor is open source. </p><br><p>  Oleg Garipov invented an interesting use for the language DRAGON in his project Integrator CodeView.  CodeView allows you to visualize existing code as an interlocking set of DRAGON-schemes.  The feature of Integrator CodeView is that it is not the individual methods that are visualized, but the entire project, including the call graph, stack, etc. The Integrator CodeView is unique in that it clearly shows not only algorithms, but also data.  The data visualization engine in the Integrator system works in conjunction with DRAGON. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRAKON Editor Web is a commercial cloud solution based on the DRAKON language. </font><font style="vertical-align: inherit;">DRAKON Web Editor is designed for technical tasks, business procedures and checklists. </font><font style="vertical-align: inherit;">DRAKON Editor Web is not affiliated with the DRAKON Editor in any way and does not support code generation from diagrams. </font><font style="vertical-align: inherit;">Among the advantages of DRAKON Editor Web should be noted a convenient editor, collaboration and support for mobile devices.</font></font><br></p><br><img src="https://habrastorage.org/webt/it/rf/ha/itrfhavbae1tddvjvrmleev4egg.png" alt="image"><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 17.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRAGON-diagram in the GRAFIT-FLOX system. </font></font><br><br><img src="https://habrastorage.org/webt/mm/8j/cv/mm8jcvktnp6rd-pihqu6qx35fia.png" alt="image"><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 18.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRAGON-editor of Eisymont. </font></font><br><br><img src="https://habrastorage.org/webt/7y/qv/up/7yqvup7lyohuv7kel_bnw-qtxha.png" alt="image"><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 19.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Program with explanations in the Dragon IC. </font></font><br><br><img src="https://habrastorage.org/webt/v7/bf/8c/v7bf8c9x7dta_5czgfms2mnbsda.png" alt="image"><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 20.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DRAKON Editor</font></font><br><br><h2 id="vyvody">  findings </h2><br><p>  Let's sum up.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRAGON is a practical language tempered in space. </font><font style="vertical-align: inherit;">He introduced structure, order and uniformity into the flowcharts. </font><font style="vertical-align: inherit;">Predictability and tidiness of DRAGON-schemes lead to the fact that visual programming </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br><p>    :    .   ,   ,  .   ‚Äî   .   ,    - ,        (     ).      .  ,  ,       . </p><br><p>       . -,    ,    . -,   ,      . </p><br><h2 id="spisok-literatury">  Bibliography </h2><br><div class="spoiler"> <b class="spoiler_title">,  </b> <div class="spoiler_text"><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dahl, OJ Dijkstra, EW Hoare, CAR (1972). </font><font style="vertical-align: inherit;">Structured programming. </font><font style="vertical-align: inherit;">Academic Press Ltd: London.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parondzhanov, V.D. </font><font style="vertical-align: inherit;">Learn to write, read and understand algorithms. </font><font style="vertical-align: inherit;">- Moscow, DMK Press, 2012.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kaufman, V.Sh. </font><font style="vertical-align: inherit;">Programming languages. </font><font style="vertical-align: inherit;">Concepts and principles. </font><font style="vertical-align: inherit;">- Moscow, DMK Press, 2011.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parondzhanov, V.D. </font><font style="vertical-align: inherit;">Why do doctors kill and mutilate patients or why a doctor needs flowcharts of algorithms? .. - Moscow, DMK Press, 2017.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lifecycle Modeling Language (LML) specification. </font><font style="vertical-align: inherit;">2015. </font></font><a href="http://www.lifecyclemodeling.org/specification/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.lifecyclemodeling.org/specification/</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Business Process Model and Notation specification, 2011. </font></font><a href="http://www.omg.org/spec/BPMN/2.0/About-BPMN/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.omg.org/spec/BPMN/2.0/About-BPMN/</font></font></a> </li><li>    . <a href="https://drakon-editor.com/docs/examples">https://drakon-editor.com/docs/examples</a> </li><li> Mitkin, S. DRAKON. The Human Revolution in Understanding Programs, 2011. <a href="https://drakon-editor.com/files/DRAKON.pdf">https://drakon-editor.com/files/DRAKON.pdf</a> </li><li> Mitkin, S. Visual functional programming with DRAKON-Erlang- Erlang User Conference 2015. <a href="https://www.youtube.com/watch%3Fv%3DyZLedcnFA94">https://www.youtube.com/watch?v=yZLedcnFA94</a> </li><li> Mitkin, S. DRAKON-Erlang: Visual Functional Programming, 2012. <a href="http://drakon-editor.sourceforge.net/drakon-erlang/intro.html">http://drakon-editor.sourceforge.net/drakon-erlang/intro.html</a> </li><li> C programming with DRAKON Editor. <a href="http://drakon-editor.sourceforge.net/cpp/c.html">http://drakon-editor.sourceforge.net/cpp/c.html</a> </li><li> Lua programming with DRAKON Editor. <a href="http://drakon-editor.sourceforge.net/lua/lua.html">http://drakon-editor.sourceforge.net/lua/lua.html</a> </li><li>  -. <a href="http://drakon.su/grafit-floks-sistema">http://drakon.su/grafit-floks-sistema</a> </li><li>   - <a href="http://forum.drakon.su/viewtopic.php%3Fp%3D43805">http://forum.drakon.su/viewtopic.php?p=43805#p43805</a> </li><li> - . <a href="http://drakon.su/instrumenty/eysymont">http://drakon.su/instrumenty/eysymont</a> </li><li>    . <a href="http://drakon.su/programma_is_drakon">http://drakon.su/programma_is_drakon</a> </li><li> Integrator CodeView   <a href="http://integratorsoft.com/%3Fmo%3D69503271058%26vi%3D2838242471%26w%3D69503271097">http://integratorsoft.com/?mo=69503271058&amp;vi=2838242471&amp;w=69503271097</a> </li><li> DRAKON Editor   <a href="http://drakon-editor.sourceforge.net/">http://drakon-editor.sourceforge.net/</a> </li><li>     <a href="http://drakon.su/">http://drakon.su/</a> </li><li>    <a href="http://forum.drakon.su/">http://forum.drakon.su/</a> </li></ol><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/345320/">https://habr.com/ru/post/345320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345310/index.html">Predict outflow using neural network</a></li>
<li><a href="../345312/index.html">New Year's post good</a></li>
<li><a href="../345314/index.html">I want to program, let them teach me! Avito educational projects</a></li>
<li><a href="../345316/index.html">Pay attention to people, not technology.</a></li>
<li><a href="../345318/index.html">AI teaches the language: why do you need a hackathon on machine translation</a></li>
<li><a href="../345322/index.html">Karmic incompatibility and other vicissitudes of service engineer</a></li>
<li><a href="../345324/index.html">Pygest # 20. Releases, articles, interesting projects, packages and libraries from the world of Python [December 6, 2017 - December 23, 2017]</a></li>
<li><a href="../345326/index.html">Is there life without standards in javascript?</a></li>
<li><a href="../345328/index.html">Simulation of the simplest statements</a></li>
<li><a href="../345330/index.html">Using Roslyn to edit game content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>