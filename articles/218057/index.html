<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A small toy "Minesweeper" not in 30 lines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 
 Last time I showed how you can easily and quickly write a game "snake" in the FBD programming language, download the program to the controlle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A small toy "Minesweeper" not in 30 lines</h1><div class="post__text post__text-html js-mediator-article"><h4>  Hello. </h4><br>  <a href="http://habrahabr.ru/post/205324/">Last time</a> I showed how you can easily and quickly write a game "snake" in the <a href="http://ru.wikipedia.org/wiki/FBD">FBD</a> programming language, download the program to the controller, and finally make the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25A2%25D0%259A_%25D0%259A%25D0%25B2%25D0%25B8%25D0%25BD%25D1%2582">equipment</a> that controls and automatically regulates the production of electricity and heat for all of us, to do more Something "useful." <br><br>  However, from people who are familiar with the work of the operating personnel at power plants, I received an important remark that the "snake" is absolutely not suitable for the industrial control system for objective reasons.  Firstly, despite the fact that the automated process control system is controlled at the station with all the automation and it is also involved in regulation and protection, the realities of life are such that the operator is also required to monitor the process for operational intervention as needed.  Therefore, the toy should be such that (unlike previously presented) does not fully occupy the operator‚Äôs attention, allow him to switch between applications and do something without affecting the game.  And secondly, the toy ‚Äúsnake‚Äù itself is very dynamic and requires quick (and at high levels in general, instant and jewelry) pressing buttons, which can easily lead to a small error: for example, instead of controlling a toy, you can accidentally control some important technological equipment, which in this mode of operation, it was impossible to touch.  Of course, nothing terrible will happen.  in any case, the protection will work, but shutting down the turbine or shutting down the boiler with protection is things that lead to substantial financial losses and unnecessary work to start them back into operation. <br><br>  All this suggests an obvious idea that you need to implement calm logic toys.  As an option - all kinds of solitaire or the well-known Minesweeper.  Due to the fact that solitaires of all kinds require images of cards that were not immediately found on the Internet (of course, it was easy to find card drawings, but I had special requirements for size and quality as well as the design of cards) it was decided to implement <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B0%25D0%25BF%25D1%2591%25D1%2580_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">the Minesweeper</a> toy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition to this, there is another important reason for the implementation of this particular game.  Namely, the desire to once again demonstrate how easy and fun to program in the FBD language. <br><a name="habracut"></a><br><h4>  A few introductory words </h4><br>  But first, a few introductory words (for those who are not too tired to read). <br><br>  Probably everyone who reads this post to the end, will say (or think): ‚ÄúBullshit!  Yes, I will write the same in C (C ++, Delphi, JS, etc.) in 30 lines of code. ‚Äù  And I agree with that.  But there is one thing.  Before you write something in a high-level language in 30 lines of code you need only <br><div class="spoiler">  <b class="spoiler_title">I could not resist</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/832/cd6/6de/832cd66de30453e61f452f5fa1b5eb04.png"></div></div>  learn this high level language. <br>  And anyone can start writing programs on FBD.  Moreover, the basic programming skills in FBD are taught to children of preschool age. <br><div class="spoiler">  <b class="spoiler_title">I think many will remember how in childhood ...</b> <div class="spoiler_text">  ... under the guise of educational games from cubes with letters collected the words: <br><div class="spoiler">  <b class="spoiler_title">For example from letters ...</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/e00/796/e1b/e00796e1bad0c66b75d006ad2f17a103.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Gathered a word ...</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/e90/788/07a/e9078807a48a062e9d88b631ac90cd3e.png"></div></div><br></div></div><br>  In other words, programming in the FBD language is simple and intuitive. <br><div class="spoiler">  <b class="spoiler_title">Small note</b> <div class="spoiler_text">  Here I am using the old habit of saying FBD, although according to one of the main developers of all this: <br><blockquote>  <b>Deranged</b> , <b>December 20, 2013 at 12:25</b> <br>  This is not FBD.  There is support for data types, including structures.  Also, data is divided into potential (instantaneous value) and commands (buffered values).  There is also built-in support for quality values.  You can conduct feedbacks, they are highlighted by zebra.  In this case, the default values ‚Äã‚Äãof the data type are taken as initial values ‚Äã‚Äã(prescribed in the type itself). <br>  In general, there is a carriage of everything, I also planned to put in there control of the order of execution in the form of connections and support of conditions.  Then there would be a complete Frankenstein from the FBD, SFC and conventional block diagrams. </blockquote><br></div></div><br>  Of course, there are also serious algorithms for this language, the struggle for controller resources, optimization of technical program execution, optimization of memory and speed in general.  Smart people are puzzled over how to create ideal algorithms from the simplest blocks.  But since  this article is purely for informational purposes, then we omit all these subtleties and finally go directly to the programming itself. <br><br>  But before that, a small question on intelligence.  Who would guess - ‚ÄúRespect and Respect,‚Äù for the impatient - the answer in the spoiler below. <br>  So - the game "Snake" and the game "Minesweeper" is one and the same game in terms of programming on FBD.  Why?  And what do they have in common, what makes such a statement? <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Everything is very simple.  And in the game "Snake" and in the game "Minesweeper" there is a field consisting of cells.  Just the cells in this field take on different values ‚Äã‚Äãand are displayed differently.  Ie ... in other words, we can take the program of the game "Snake", its graphical interface, and in half an hour-hour of work we can redo it all into the game "Minesweeper", because in fact we will have to change only one algorithm and redraw one cell of the field .. </div></div><br><h4>  We start to program </h4><br>  So, we start to program our task. <br>  My personal opinion is that 80% of the programming in the FBD language is to clearly imagine what we want to get in the end.  And so only we achieve such an understanding, then 80% of the problem is solved and there is literally a bit of work on sketching the code and combing it.  Now I will try to demonstrate this principle in practice. <br><br>  Suppose that the field for the ‚Äúsapper‚Äù we will have by analogy with the ‚Äúsnake‚Äù 20x20 cells.  Therefore, we need 400 memory cells, in each of which each cell of the field will be processed.  To structure the program - we divide all the cells into rows.  Thus, we need twenty string algorithms, each of which will consist of 20 cell algorithms.  Those.  We have come to understand the basis of the program. <br><br><h4>  Algorithm "String" </h4><br>  Let us consider the string algorithm in more detail.  Or rather, what kind of data we need to have at the input and what - at the output of this algorithm.  I propose to start from the end - i.e.  from the output. <br><br><h5>  Algorithm outputs </h5><br>  - First, we need an output data line that determines the state of each cell to draw it in the human-machine interface (or, more simply, in the operator station). <br>  - Secondly, we need a vector that shows which cells contain bombs and which cells are safe. <br>  - Thirdly, we need a sign that the player ‚Äústepped‚Äù on the field with a bomb and the game is lost, let's call this exit ‚ÄúBig_Bada_Boom‚Äù. <br>  - Fourthly, for convenience, the ‚Äúsapper‚Äù has a feature that, when it hits a cell that does not have a neighborhood with a bomb, all empty cells bordering it automatically open.  Those.  we will need an output that sends the reverse ‚Äúopen cell‚Äù command by the program itself. <br>  - Fifthly, for the algorithm for setting bombs, we will need a way out showing how many bombs are in a given line.  Of course, this value can be obtained directly from the vector described in clause 2, simply add up all the non-zero bits.  But for convenience, we will bring this function inside the macro. <br>  - Sixth, to keep statistics, we need to know how many more closed cells are left in a row. <br>  That's all we need for the full functionality of the game "sapper". <br><br>  Only 6 outputs with data. <br><br>  Now let's think about what we need to have at the entrance in order to be able to form the outputs we need. <br><br><h5>  Algorithm inputs </h5><br>  - It is logical to assume that the main entrance of the algorithm is the team from the player "Open cell".  After all, this is the main point of the game. <br>  - For clarity of programming, we will use another entry - ‚ÄúPut a flag on the cell‚Äù, which marks that there is a bomb and does not accidentally click on this cell and explode. <br>  - To form the status of each cell (and we all remember that if there is no bomb in the cell, then it shows how many bombs are in the cells bordering it) you need to start a vector from the line above and the line below.  Let's make the algorithm universal and add three inputs: an input for a vector with bombs in the line above the current one, an input for a vector with bombs in the current line and an input for a vector with bombs in the line below the current one. <br>  - To start the new game and rewrite the values ‚Äã‚Äãof the cells, add the logical input ‚ÄúNew game‚Äù. <br>  - As mentioned earlier, if the cell is empty and there are no cells with bombs, then the cells next to it should automatically open.  Add for this input "Open program." <br>  - Well, of course, what kind of game is it without a mined field.  So we need the entry "Set bombs". <br><br>  Total got 8 entries. <br><br>  That's all that we need from the main algorithm of the program. <br>  We quickly type a macro with our inputs and outputs, and we get the following algorithm: <br><img src="https://habrastorage.org/getpro/habr/post_images/38e/7e1/207/38e7e120737b18075a45574b8cd14774.png">  or if you reveal it: <img src="https://habrastorage.org/getpro/habr/post_images/406/e6f/84c/406e6f84c9d97ba7ffd3039cc0a75490.png"><br>  Now let's fill our algorithm with meaning.  As I already said, the basis for filling our main algorithm is the ‚ÄúMemory cell‚Äù macro, of which there will be 20 pieces. <br><br><h4>  Algorithm "memory cell" </h4><br>  Let's try to think over what we may need from each cell of the ‚Äúsapper‚Äù field of play, and what we need to do for this to input the macro.  Let's start again from the end, i.e.  from the exits.  And when we formulate all the data that we need, it becomes clear that you need to have at the entrance to get them. <br><br><h5>  Algorithm outputs </h5><br>  - To begin with, the cell must have an output showing the status of this cell.  Have you ever wondered how many states each field cell in a sapper game can take? <br><div class="spoiler">  <b class="spoiler_title">States of the field cells</b> <div class="spoiler_text">  Answer 12. That's exactly the way - 12 states corresponding to 12 different cell mappings. <br>  I coded them like this: <br>  -1 - the cell is closed. <br>  0-8 - the cell is open and shows the number of bombs in the neighboring cells. <br>  9 - the cell is open and there is a bomb in it. <br>  10 - the cell is closed and the flag is set on it. <br></div></div><br>  - Separately, for calculations and other processing, we will render the logical outputs "Cell closed" and "Bomb installed in the cell". <br>  - As already mentioned - if an empty cell is open, then it should automatically open the cells adjacent to it.  accordingly, we still need the logical sign ‚ÄúOpen neighbors‚Äù. <br>  - Well, in the end, if a player made a mistake and ‚Äústepped‚Äù on the field with a bomb, then you need to form a logical sign that the game is lost.  let's call it Bada_Boom. <br>  Total only 5 outputs. <br><br><h5>  Algorithm inputs </h5><br>  Let's try to decide what we need in order to form the required outputs. <br>  - First of all, the algorithm must receive a command from the player "Open field". <br>  - For simplicity, with a separate team, we also start the ‚ÄúPut a Flag‚Äù command here. <br>  - As I said earlier - every cell in the field must know how many bombs are laid in the neighboring cells.  we will get for this a separate entrance "Neighbors". <br>  - In order to randomly set the bombs first you need the logical sign ‚ÄúHere is the bomb‚Äù by which the cell will be mined. <br>  - Well, of course, to start a new game there must be a reset sign, which resets all information in the cells. <br><br>  We fill this macro with the following algorithm: <br><img src="https://habrastorage.org/getpro/habr/post_images/ba0/0ef/28e/ba00ef28ebabe1d212373770a262c363.png"><br>  Now let's program the ‚ÄúMemory cell‚Äù algorithm itself.  It is extremely simple: <br><img src="https://habrastorage.org/getpro/habr/post_images/d04/2e2/98d/d042e298dbf9ba7f02c5d9b046955293.png"><br><div class="spoiler">  <b class="spoiler_title">A brief explanation of the principle of the algorithm</b> <div class="spoiler_text">  - A vector, formed from the state of neighbors, that is unpacked with this algorithm and then the number of units (bombs) in the vector is calculated on the algorithm ‚ÄúBitDeshifr1‚Äù.  The question immediately arises: why is there 9 bits, when the cell has only 8 neighbors maximum.  I answer: for universality.  The fact is that as will be seen later, I wrote another macro to find the neighbors of each cell.  And in order for the macro to be universal for all cases (a cell can have not only 8 neighbors when it is in the center of the field, but only 3 when it stands in the corner, or 5 when it stands on the edge of the field) use nine bits. <br>  - The trigger "RStrig1" serves to set and reset the "flag" on the cell.  The first command retracts the trigger, and the second command resets.  As can be seen from the diagram, the cocked trigger blocks the passage of the ‚ÄúOpen‚Äù command on the I2 algoblock since  the value from the trigger output is input to the ‚ÄúAND‚Äù algorithm input with inversion.  Those.  while the trigger is cocked, the second input of the ‚ÄúAND‚Äù algorithm receives ‚ÄúFalse‚Äù and the output of the ‚ÄúAND‚Äù algorithm is also equal to ‚ÄúFalse‚Äù regardless of the value at the first input.  It turns out that the ‚ÄúOpen‚Äù command cannot reset the ‚ÄúRS2‚Äù trigger and we are insured against the accidental opening of a cell that we don‚Äôt want to open. <br>  - The trigger "RS2" is used to form the status of the cell: it is closed or open.  As can be seen from the diagram, the trigger is cocked by the ‚ÄúReset‚Äù command (the beginning of a new game) and is reset only when the ‚ÄúOpen‚Äù command arrives. <br>  - The trigger "RS1" is used to indicate the presence of a bomb in this cell.  It is cocked upon receipt from the program of the ‚ÄúHere's a Bomb‚Äù team, which sets bombs in a cell and is reset with the start of a new game. <br>  - Algorithm "I3" is one of the most important in this scheme.  On it, the value of the ‚ÄúRS1‚Äù trigger (the bomb is installed here) and the arrival of the ‚Äúopen‚Äù command in this cell are added together.  If both conditions are fulfilled, then ‚ÄúTrue‚Äù is formed at the output, meaning that the player stepped on the field with a bomb.  This value is fed to the ‚ÄúBada_Boom‚Äù output, which are then collected from all the cells at the ‚ÄúBig_Bada_Boom‚Äù output and mean loss. <br>  - Three ‚ÄúChoice‚Äù algorithms, cascaded, form the cell status.  The ‚ÄúVybor1‚Äù algorithm is used to form what to output to the output when a cell opens: the numbers ‚Äú0-8‚Äù corresponding to the number of bombs in the cells in the neighborhood, or the number ‚Äú9‚Äù corresponding to the mined cell.  If the field is still closed (Trigger ‚ÄúRS2‚Äù is set), then the ‚ÄúSelect2‚Äù algorithm is set to ‚Äú-1‚Äù, which, as we agreed earlier, corresponds to the status of the closed cell.  If the field is closed (Trigger ‚ÄúRS2‚Äù is cocked) and at the same time (algorithm ‚ÄúI4‚Äù) the trigger ‚ÄúRS Trig1‚Äù is raised, then on the Algorithm 3 the value is forcibly replaced with ‚Äú10‚Äù corresponding to the set flag. <br>  - The last comparison algorithm is used to automatically open neighboring cells.  If at the exit "Vybor3" we got zero, then the player opened the cage, next to which there are no bombs.  Then the team is sent to open neighboring cells. <br><br>  This primitive algorithm is the basis of the whole game.  there are only a few tidying up the program and finishing the functionality. <br></div></div><br><h5>  We now proceed to the macro "String", consisting of 20 "memory cells." </h5><br><div class="spoiler">  <b class="spoiler_title">The macro itself and the description.</b>  <b class="spoiler_title">The drawing is big.</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/08c/49d/ef908c49d46e7c06f3c8ebc131af800c.png"><br>  The macro itself is extremely simple.  20 memory cell algorithms associated with their inputs and outputs of the common macro.  For cell status, this link goes directly, for the rest, either through BitShifter algorithms for packing logical values ‚Äã‚Äãinto a vector, or through adders to count the number of necessary elements in a row, or through the OR algorithm to form an output command for opening neighboring cells or ending games ("Big_Bada_Boom"). <br>  Separate attention is deserved only by the blocks ‚ÄúOpen‚Äù, ‚ÄúVector Transformation‚Äù and ‚ÄúOpen Neighbors‚Äù. <br>  Consider each such unit separately. <br><div class="spoiler">  <b class="spoiler_title">Let's start with the block: Open</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/a83/ffb/c1a/a83ffbc1a679f045675f1aaaf4aefab0.png"><br>  As it is easy to see, here they simply add up the "OR" commands from the player and from the program when it opens the neighbors of an empty cell. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Consider the block: Vector conversion</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/cc7/c9a/e44/cc7c9ae447343266e1c4a8f9bdf1eca3.png"><br>  The idea is very simple.  Three vectors come to us and we need to calculate how many mines surround each cell in a particular position.  For this, I intended to simply shift the vector to the right by (position - 2) and count the number of units in the first three bits of each vector after the shift.  But then I came across a funny thing.  What to do if the position of the cell first?  then, by analogy with the others, I must shift the vector to a negative value (that is, not to the right, but to the left).  Of course, all the left-shifted bits will be zero, but the general principle of counting will be preserved.  However, the subtleties of the implementation of the algorithm did not allow this, so we had to put a check on the position of the cell and for the first position of the cell to carry out a separate processing.  As a matter of fact, this processing consists only in processing the second bit in the current line and the third bits in all lines.  Remember, I wrote that for the standard macro I needed to form 9 bits of neighbors, and not 8, as the logic requires.  This is due to this situation. <br><br>  The most observant readers have already noticed that there is clearly an unnecessary operation performed here.  I get bits describing the neighbors, pack them into a vector, and then again unpack and summarize.  Those.  unpacking operations are clearly redundant.  But I left this option for debugging and clarity. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Consider the block: Open Neighbors</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ead/d16/cb1/eadd16cb19e92485f1cdf1bcc4e8ce25.png"><br>  It's all very simple here.  If a cell is empty, then it must open not one, but as many as 8 neighboring cells.  To unify and simplify life, let it open up not 8 neighboring cells, but 9 (yes and even itself). In the FBD language, sometimes even the simplest assumption, which does not affect the program‚Äôs work or resources, greatly simplifies life).  Thus, the macro operation algorithm is simple.  We check the position of the cell.  If the cell is in the second and more positions, we create a vector from the first consecutive bits and shift them (remember, by analogy with vector processing, just not to the right, but to the left, because we don‚Äôt bring any part of the vector to the beginning, but on the contrary, the initial vector is shifted to the area we need) by (position -2).  If we have the first cell, then we form the initial vector of two bits and shift it to (position -1) = 0 ie  We are not moving anywhere. <br>  Next, we just have to add up all the prepared vectors for ‚ÄúOR‚Äù and give them to the main exit. <br></div></div><br></div></div><br>  Separately I wanted to mention another macro.  Before the start of the game, we need to randomly place mines in the field.  But what to do if there is no random number generator and the Random command is not available.  Of course, there are many pseudo-random sequence generation algorithms on the Internet.  But they are quite complex and their implementation in itself deserves a separate article.  Therefore, we had to go the usual way and make the macro ‚ÄúRandom generator‚Äù. <br><img src="https://habrastorage.org/getpro/habr/post_images/8a1/a8c/942/8a1a8c9424fb2498cb0c2a2ba5498bc6.png"><br><div class="spoiler">  <b class="spoiler_title">A brief description of the principle of the macro</b> <div class="spoiler_text">  So, we don‚Äôt have a random number generator.  Well.  let's do it yourself! <br>  The idea is primitive and has already been applied by me in the previous program, just here it received some development. <br>  On the integrator, a value that varies very quickly with a saw with a adjustable range is formed (the ‚ÄúUpper threshold‚Äù and ‚ÄúLower threshold‚Äù inputs correspond to the range).  Further, using the ‚ÄúSeconds‚Äù algorithm, we calculate the controller operation time since the start, which also increases continuously.  We divide the controller operation time by our rapidly changing number, while taking the remainder of the division.  Next, we extract from the remainder the digits we need (for greater randomness, I took 4-5 decimal places for the X coordinate, and 6-7 decimal places for the Y coordinate).  Discharges are very simple.  Multiply the remainder of division by 1000000 and divide with the remainder by 100. As a result, the remainder yields the value [0..100).  At the same time, it is necessary to understand that this value can come as close as you like to 100, but will never be equal to it.  The random value required by us lies in the range [1..20], therefore we divide our remainder by 5 (algorithm ‚ÄúDelOst3‚Äù), take the integer part from the division and convert it into an integer using the type converter.  As already mentioned, the dividend will never be equal to 100, which means that our quotient lies in the range of natural numbers [0..19].  We solve the problem simply by adding one to the result.  So our random number is ready.  Due to the fact that it is unknown at what point the player clicks on the ‚ÄúNew game‚Äù button and what value will be on the integrator at this moment, as well as the fact that we take values ‚Äã‚Äãin 4-7 decimal places, it is safe to say that we got a good random number generator. <br></div></div><br><h4>  We combine all the parts together and add beauty </h4><br>  So, all parts of our program are ready.  We connect them together and do the strapping: <br><div class="spoiler">  <b class="spoiler_title">Picture of the main program. Big.</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/042/942/863/042942863b43fe871fcf4da6044721a2.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">A little explanation</b> <div class="spoiler_text">  As can be seen from the figure, the most important current algorithm is ‚ÄúRuchselektor1‚Äù, which outputs a logical unit for one cycle and launches a new game.  The launch of the new game is that the signal is sent to all the ‚ÄúString‚Äù macros to the ‚ÄúNew game‚Äù input and the trigger is set to ‚ÄúSR2‚Äù in the ‚ÄúMemory cell‚Äù macro and the other triggers responsible for the presence of bombs and flags are set. . <br>  At the same time, the same output of the ‚ÄúRuchSelektor1‚Äù algorithm resets the ‚ÄúRS1‚Äù trigger (‚ÄúGame_over‚Äù - this trigger is cocked if the player opens the cell in which the bomb was hidden, and the RS3 (Victory) trigger, which is cocked when the player wins, i.e. detecting all the bombs hidden in the field.At the same time, the same signal is sent to the input of the Memory1 algorithm for recording the number of installed bombs in the current game into the memory (the player can change the number of bombs in the field at any time, but these settings will only get with the beginning of a new game  s). <br>  Then, with a cycle delay (‚ÄúDelay1‚Äù algorithm) (which is needed to reset all of the triggers in the memory cells), the ‚ÄúRS2‚Äù (‚ÄúPut the Bomb‚Äù) trigger is activated, which includes the procedure for installing bombs.  Those.  transferring our random coordinates generated at the ‚ÄúGenerator_Random‚Äù macros to the ‚ÄúColumn‚Äù and ‚ÄúString‚Äù algorithms, sending, by the given coordinates, a command to reset the ‚ÄúRS1‚Äù trigger in the ‚ÄúMemory Cell‚Äù. <br>  Controlling the number of bombs installed is simple.  The total number of bombs installed is calculated, and as soon as it is compared with the number specified on the Memory1 algorithm, the SR2 trigger is reset, thereby stopping the installation of new bombs. <br><br>  Algorithms 36-40 serve to verify the correctness of a given number of bombs by a player.  Here, for debugging, I limited the minimum and maximum number of bombs to 0 and 400 pieces, respectively.  When specifying a number outside this range, it is automatically equated to the nearest boundary. <br><br>  Check for the fulfillment of the conditions of victory is extremely simple.  All closed cells are counted.  As soon as their number becomes equal to the specified number of bombs and the trigger ‚ÄúRS1‚Äù (‚ÄúGame_over‚Äù) is not cocked, the trigger ‚ÄúRS3‚Äù (‚ÄúVictory‚Äù) is activated. <br><br>  It remains for us to consider only 2 algorithms: <br>  The algorithm "OR2".  It logically OR the outputs of all three triggers are collected.  And according to the output of the ‚ÄúOR2‚Äù algorithm (when it is equal to one), a lock is placed on the player‚Äôs actions.  Those.       (..    ,    ,       )      .      ,   . <br>  ¬´1¬ª     ,   .    .        400.         400,  ,        . <br><br>     . <br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We fasten the graphic interface </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done in just a couple of minutes. </font><font style="vertical-align: inherit;">12 pictures for the cell are drawn (I used paint for this) and their display is set depending on the cell status. </font><font style="vertical-align: inherit;">Further, this cell is copied 400 times (there is no need to be intimidated here, since 400 cells are just nine operations Ctrl + c - Ctrl + v) and a minefield is obtained. </font><font style="vertical-align: inherit;">We find on the Internet the first image that matches the meaning of the ‚Äúsapper‚Äù logo. </font><font style="vertical-align: inherit;">We fasten the display of the timer and the "New Game" button. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now the most difficult thing remains - to choose pictures for victory and defeat in the game. </font><font style="vertical-align: inherit;">Then I took the first images that appeared in the search engine for ‚Äúatomic explosion‚Äù and ‚ÄúVictory‚Äù. </font><font style="vertical-align: inherit;">And that's all - the game is ready.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting position:</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/e98/871/154/e988711543517181e361e7211a1c9d5d.png"></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We play:</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/72e/1c5/4c3/72e1c54c3c9ee838588883b2a5322194.png"></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Losing</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/044/5b8/058/0445b8058517dcc241a827bbcfb790d6.png"><br>  : ,    ,     ,    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we win!</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f83/f18/ad0f83f181e1ebca73c93e9d9f414931.png"></div></div><br><h4>  Summing up </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyone who was able to master this post entirely noticed that we wrote a program, albeit simple, but still not at the ‚ÄúHello, World!‚Äù Level, and at the same time we didn‚Äôt need absolutely any reference books, helpers, seating on the programmer‚Äôs forums, smoking manuals, etc. We implemented all that was needed in a couple of hours (and personally, most of the time I spent on a beautiful arrangement of algoblocks for pictures), while using even the schoolchildren‚Äôs algorithms for addition, subtraction, multiplication and logic algorithms ‚ÄúAND‚Äù, ‚ÄúOR‚Äù. Plus involved a few simple RS-triggers. The most complex algorithm used in the program is ‚ÄúIntegrator‚Äù. And you and I used it simply as an adder with feedback and checking boundaries.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in fact, it is possible to replace the integrator with the ‚ÄúAddition‚Äù algorithm and two ‚ÄúComparison‚Äù algorithms. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other words, programming in FBD is simple and fun, and at the initial level no knowledge and skills are required at all except for understanding elementary logic. The main thing is a clear idea of ‚Äã‚Äãthe final result. If it is available, the program itself is its logical conclusion. If we imagine ‚ÄúWhat we want to get in the end‚Äù is not yet possible, then it is probably worth more clearly formulating the task. At once I will make a reservation that all of the above does not apply to all projects implemented on FBD, but to simple little puzzles, like the one shown in our example.</font></font> Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for huge projects with tens of thousands of signals to connect all this in my head probably will not work for anyone. </font><font style="vertical-align: inherit;">But even in this case, the huge project is divided into small subtasks, where our approach is already becoming quite applicable (of course, taking into account the general requirements of the project).</font></font><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the FBD language is universal and we have used the simplest algorithms in the program, which are basic for any implementations, then this program can be reproduced with minimal effort on any controller, both domestic and foreign (for example, Siemens or ABB controllers). </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From what remains unrealized </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three functions of the classic sapper game remained unrealized. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is the ability to set the size of the field in the settings. This is done easily. As a matter of fact, the ‚ÄúMemory cell‚Äù algorithms are simply copied as many times as there are cells in the field. The problem is the same: lack of dynamic memory, i.e. impossibility to add or remove any data on the fly. And from this it follows a simple conclusion - it is very simple to make changing field sizes - you first need to program the task for the maximum field size, and then just put a logical sign on the unused cells, which by this sign will not be displayed in the graphical interface and will not be processed during the game. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is the substitution of the cell during the first click, if it was originally a bomb.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in our program, in contrast to the ‚Äúsapper‚Äù in Windows, there is a chance to lose at the first click. This is also made easy; it is enough to check the incoming signal on the Game_over trigger and the number of closed cells. If we have the number of closed cells 399 and the signal came for the arming of the ‚ÄúGame_over‚Äù trigger, then we need to block this signal, reset the clicked cell and launch the algorithm for randomly installing another mine, while blocking the possibility of placing the mine in the already opened cell </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, as you can see from the description - the statistics collection function is not implemented.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the best result is not remembered, the name of the person who set the record. </font><font style="vertical-align: inherit;">The ratio of victories and defeats, etc. </font><font style="vertical-align: inherit;">But this is all so trivial that it is literally done with a couple of mouse clicks, so I leave this function for implementation to everyone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to everyone who read this post to the end. </font><font style="vertical-align: inherit;">I hope it was interesting.</font></font></div><p>Source: <a href="https://habr.com/ru/post/218057/">https://habr.com/ru/post/218057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218041/index.html">How to start developing games if you can't program?</a></li>
<li><a href="../218043/index.html">Messaging and Internet calls in difficult conditions: how do five mobile messengers digest GPRS / EDGE?</a></li>
<li><a href="../218051/index.html">Google Chrome - we remove the routine using custom search</a></li>
<li><a href="../218053/index.html">Symmetry numbers</a></li>
<li><a href="../218055/index.html">How to celebrate Cosmonautics Day?</a></li>
<li><a href="../218061/index.html">Do not make (in) equality in JavaScript look worse than they are.</a></li>
<li><a href="../218063/index.html">Distributed video encoding</a></li>
<li><a href="../218065/index.html">Ceph: Cloud Storage without compromise</a></li>
<li><a href="../218067/index.html">Build 2014. Hot news for Windows and Windows Phone developers</a></li>
<li><a href="../218073/index.html">The working environment "Deodar" for Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>