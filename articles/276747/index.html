<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perfect UI framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky, and I ... an architect of many frameworks widely known in narrow circles. I have never been satisfied with the nee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perfect UI framework</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, my name is Dmitry Karlovsky, and I ... an architect of many frameworks widely known in narrow circles.  I have never been satisfied with the need to solve the same problems from time to time, so I always try to solve them radically.  But before solving them, you need to find and realize that it is rather difficult to be captured by habits, patterns, stereotypes and ‚Äúready-made‚Äù solutions.  Every time I encounter problems in the implementation of the task, I wonder "what the hell is wrong with this tool?"  and, of course, I am going to saw my tool: function, module, library, framework, programming language, computer architecture ... stop, I have not yet come to the last. </p><br><p>  Today we will talk about JS-frameworks.  No, I will not talk about the next ready-made solution, not the purpose of the post.  I just want to sow in your minds a few simple ideas that you will not find in the documentation to any popular framework.  And at the end we will try to form a vision of an ideal architecture for building a user interface. </p><br><p><img src="https://habrastorage.org/files/c33/9ae/4de/c339ae4de1df4b25b35c518823510a25.jpg" alt="A different angle"></p><a name="habracut"></a><br><h1 id="dlinnyy-cikl-otladki">  Long debug cycle </h1><br><p>  A typical debug loop looks like this: </p><br><ul><li>  Editing the code. </li><li>  Application launch. </li><li>  Check and detect problems. </li><li>  Research their causes. </li></ul><br><p>  And this cycle is repeated for any typo.  The faster the developer understands where and why he made a mistake, the faster he realizes everything.  Therefore, the programmer should receive feedback as quickly as possible, right in the process of writing code.  This is where the development environment tools help, which analyze the dialed code in real time and check if it will all work.  As a result, it is very important that the development environment can get as much specific information as possible from the code.  To achieve this, the language used must be statically typed as much as possible.  JavaScript is typed only dynamically, from which the IDE tries to guess the types by circumstantial signs (typical patterns, JSDocs), but, as practice shows, even in the most advanced development environments, this turns out badly. </p><br><p><img src="https://habrastorage.org/files/2ec/fa3/302/2ecfa330238e438ea0537db812cc33e4.png" alt="WebStorm does not understand JavaScript"></p><br><p>  However, there is a minimalistic JavaScript extension that adds optional static typing to it - TypeScript.  Even a simple text editor like GitHub Atom understands it perfectly. </p><br><p><img src="https://habrastorage.org/files/914/120/0c6/9141200c62be4f61a42ebd98d456b3a3.png" alt="Atom understands typeScript"></p><br><p>  <strong>Currently TypeScript is the best language for developing web applications.</strong>  <strong>AngularJS developers have already understood this.</strong>  <strong>Do not miss the train!</strong> </p><br><p>  The second echelon in the acceleration of the debugging cycle is automated tests that allow you to quickly check the performance and detect the location of the fault.  Unfortunately, many testing frameworks are concentrated only in the first phase (verification), but the second (fault localization) is often not even thought about, although it is no less important.  For example, the popular QUnit test framework wraps all the tests in try-catch, so as not to stop at the very first test fallen, and at the end draw a beautiful report that is rather useless in finding the cause of a malfunction.  All he can give out is the name of the test and the non-clickable boxteam.  But there is a crutch - you can add the <a href="http://jsfiddle.net/XjjEF/1/embedded/%3Fnotrycatch%3Dtrue">parameter? Notrycatch</a> to the link <a href="http://jsfiddle.net/XjjEF/1/embedded/%3Fnotrycatch%3Dtrue">, which does not always work</a> , and then the tests should fall down on the first error, after which, depending on the debugging mode, you will get either to stop the debugger at the point of exception, or clickable one fallen dough in the console.  But the solution without crutches would be ideal: in the stop mode for exceptions, stop at each (and not only at the first), and in the logging mode, log all drops to the console with clickable center path.  This is not as difficult as it may seem - it is enough to run the tests in separate event handlers, and in no case do not wrap them in a try-catch. </p><br><p>  In the light of the above, it is worth emphasizing that try-catch is better not to use not only in the test framework, but also in any other, because by catching an exception you lose the opportunity to stop the debugger at the place of its occurrence.  The only sensible use of try-catch in JavaScript is to ignore expected exceptions, such as making jQuery at startup, checking browser support for some features.  And that is why such a crutch, as a debugger option ‚Äúto stop not only on uncaught exceptions,‚Äù helps badly, because it gives too many false positives that have to be scrolled. </p><br><p>  The last nail in the coffin of try-catch can be hammered by the fact that at least V8 does not optimize the functions containing this construction. </p><br><p>  <strong>You need to write the code so that it can calmly fall at any moment without breaking the entire application.</strong> </p><br><p>  It is for reasons of convenience of debugging that there are no try-catch in the latest implementation of <a href="http://habrahabr.ru/post/235121/">atoms</a> , but there is an error event handling, according to which the synchronization of atoms is resumed taking into account the fallen ones. </p><br><h1 id="gde-chto-lezhit">  Where is what lies? </h1><br><p><img src="https://habrastorage.org/webt/59/dd/94/59dd9474c8db8126752610.png" alt="Detective Investigations"></p><br><p>  How to quickly go to the declaration of the entity?  How to quickly find all places to use an entity?  How to find an entity ad by name?  These detective investigations reduce developer productivity and distract from the problem being solved.  Static typing, as noted above, allows the development environment to understand the semantics of the code: where what type is declared, what type the function returns, what types I can use in the current context.  But it is equally important to locate and name files according to simple and universal rules, because working with files is not only and not so much the means of the development environment.  For example, grouping files makes sense not by type, but by functionality.  Modules with related functions - in larger modules.  A collection of various modules of one author - in the package.  This logic is embedded in the PMS architecture (Package / Module * / Source).  In it, the directory hierarchy exactly repeats the namespace hierarchy in the code.  Because of this, by the name of the entity you can always understand where it should lie.  This property is used by the pms collector to build a tree of module dependencies: it analyzes the sources for use of third-party modules, then serializes the resulting graph so that by the time the dependent module is executed, all its dependencies are also executed.  And this does not require any special ads in the code.  No AMD, LMD, CommonJS.  No import, require, include.  You simply write the code as if the necessary modules were already declared in the same file as yours, and the collector takes care of the rest.  This is a direct analogue of autoloading classes from PHP, but it works with any modules containing source codes in a wide variety of languages. </p><br><p> Due to the fact that dependencies between modules are monitored automatically, it becomes very easy to add new modules and transfer existing ones.  To create a module, it is enough to create a directory.  To add code to it in any language, simply create a file.  But the most important thing is that only those modules that are actually used are used in the release, but not everything.  This allows you to build the code of the framework and libraries not from several large modules, 90% of the functions of which are not used, but from a multitude of microscopic modules, without leading to kilometer-sized footcloths.  For comparison: the JavaScript code of ToDoMVC <a href="http://eigenmethod.github.io/todomvc/examples/angular2/">on Angular2</a> weighs a total of 1.6MB (320KB in compressed form), and <a href="http://eigenmethod.github.io/todomvc/examples/mol/">on $ mol</a> - 140KB (22KB in the same way).  Compare the scale.  Do I need to tell which application will open faster on the mobile phone through EDGE?  And do not say that now 4G is everywhere - in Moscow even EDGE is intermittently caught in many places.  And what does the modern industry offer us?  To connect libraries entirely, and then with <a href="https://github.com/rollup/rollup">cunning magic to</a> cut out all unnecessary?  Pity my CPU! </p><br><p>  <strong>Micromodular architecture allows you to create compact and fast applications.</strong> </p><br><p>  Many now have probably already had their hands on expressing kilobytes of righteous anger and outrage at my unprofessionalism in the comments.  But let me rewind time a few years ago and remind you of one similar situation.  Not so long ago, XML technologies were in the trend, everyone actively wrote on XHTML, fluttered in front of XSLT, and exchanged data exclusively through XML.  If you did not put "/" at the end of the incorporeal tags or, God forbid, did not pass the html-validation, then you were looked upon as unprofitable.  But somehow it hurt a lot of difficulties with this technology stack.  I had to read the kilometer specifications, put up with strict restrictions, insert a bunch of crutches, and the bright future did not come - the browsers did not bring XHTML support to mind.  Developer dissatisfaction grew, enthusiasm faded away, until it suddenly became clear that working with poor JSON (compared to powerful XML) made it easier and faster to work;  that the rigor and redundancy of XML does not give a special profit;  that what thousands of developers believed was not the best idea.  A similar situation was with the vendor prefixes in CSS: first they copy-paste them with their hands, then special utilities appeared that copy-paste them automatically, and now they are methodically removed from them, since they do not solve any problems, introducing only unnecessary complexity.  But back to the "modules".  Let's write a couple of simple modules on, for example, RequireJS: </p><br><pre><code class="hljs lua">// my/worker.js define( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( require )</span></span></span></span> { var $ = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'jQuery'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { $(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>).text( <span class="hljs-string"><span class="hljs-string">'Hello from worker'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } } ) // my/app.js define( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( require )</span></span></span></span> { var jQuery = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'jQuery'</span></span> ) var worker = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'my/worker'</span></span> ) var count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { $(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>).text( <span class="hljs-string"><span class="hljs-string">'Hello from app'</span></span> ) count += worker() count += worker() } } )</code> </pre> <br><p>  What is wrong with this code: </p><br><ol><li>  The same module (which is jQuery) in different files has different local names.  That is, the programmer needs to constantly keep in mind how jQuery is called in each module.  Why do we have the opportunity to name the same entity differently?  To confuse everyone? </li><li>  We do not have easy access to the count variable.  We can't open the console and just type <code>app.count</code> to find out what the value is there now.  To do this, you need to pretty much juggle the debugger. </li><li>  Each time using any entity, you need to check that it is "imported", and ceasing to use it, you must also delete these "imports."  The existence of a special tool for automatic synchronization of the list of imports with code emphasizes their meaninglessness - this is a typical, easily automated infrastructure code, to which the programmer, generally speaking, has no business. </li><li>  A lot of extra code, which is often just generated from the template, because no one likes to write the same thing with their hands. </li></ol><br><p>  How to solve these problems without creating new ones?  And it's very simple, let's use the jam.js format: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ jq/jq</span></span>.js /<span class="hljs-regexp"><span class="hljs-regexp">/ my/worker</span></span>.jam.js var $my_worker = function () { $jq(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>).text( <span class="hljs-string"><span class="hljs-string">'Hello from worker'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/ my/app</span></span>.jam.js var $my_app = function () { $jq(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>).text( <span class="hljs-string"><span class="hljs-string">'Hello from app'</span></span> ) $my_app.count += $my_worker() $my_app.count += $my_worker() } $my_app.count = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  The code turned out to be much smaller and it was all in business, and in order to work with it we no longer need a powerful development environment.  We do not have to wrestle with which module is called jQuery, because it is called the same everywhere - according to the path to it in the file system.  At the same time, we can always copy <code>$my_app.count</code> to the console to view the current status.  That is what we should strive for, and not to isolate everything and everyone. </p><br><p>  <strong>The railing helps not to fall into the abyss, but you should not surround yourself with them.</strong> </p><br><p>  But what is really needed is the namespace, and the directory structure is the best way to guarantee the absence of conflicts in the namespace. </p><br><h1 id="razduvanie-koda">  Bloat code </h1><br><p><img src="https://habrastorage.org/webt/59/dd/95/59dd95e1dff3c903001632.jpeg" alt="Bloat boat"></p><br><p>  If before there were disputes whether it is worthwhile to load jQuery on a hundred kilobytes, now nobody is confused by the connection of the megabyte framework.  Some even take pride in having written millions of lines of code to implement a not too complicated application.  And if the problem was only in the download speed of these elephants, but the speed of their initialization.  But there are much more significant problems arising from this.  The more code, the more errors in it.  Moreover, the more code, the greater the percentage of these errors.  So if you see a huge mature framework, then you can be sure that a lot of man hours have been spent on debugging such amounts of code.  And a lot more to spend, both on existing bugs that have not yet been noticed, and on bugs introduced by new features and refactorings.  And don't be fooled by the ‚Äú100% test coverage‚Äù or ‚Äúa team of highly qualified specialists with a decade of experience‚Äù - there are definitely no bugs in the empty file.  The complexity of maintaining a code grows non-linearly as it grows.  The development of the framework / library / application slows down until it degenerates completely into endless patching of holes, without significant improvements, but requiring a steady increase in staff.  So, if someone offers you to write additional code to transform Camel Ids Directives into directives-with-hyphens identifiers, just because JS traditionally uses one notation, and CSS is different, not compatible with it, then spit it into face and use universal_notation_identifiers, which does not require any additional code or development environment with complex heuristic matching algorithms. </p><br><p>  A large amount of code does not always mean a large number of possibilities.  Often this is a consequence of using too verbose tools, over-sophisticated logic and banal copy-paste (including code generation).  You should not go to extremes, giving all the variables one-letter names, but you should be wary about seeing tens of thousands of lines drawing a simple form on the screen.  You can not pay attention to this, believing that you do not need to understand it, limited to only reading the documentation;  believing that the public API is enough for any women;  believing that the bugs are either not present, or they will be quickly corrected by the maintainers.  But practice shows that sooner or later you will have to climb into this pile of code, if you do not make changes, then at least investigate its work.  And the more code, the harder it is to understand.  But even harder to understand the code, full of abstractions.  A small number of literate abstractions can significantly simplify the code, but we get a sharply opposite effect when we make them indiscriminately.  Factories, proxies, adapters, registries, services, providers, directives, decorators, impurities, types, components, containers, modules, applications, strategies, commands, routers, generators, iterators, monads, controllers, models, displays, display models, presenters , templates, builders, virtual home, dirty checks, binders, events, streams ... Even experienced developers are lost in this variety of abstractions.  And try to explain to a beginner how to make a simple component on such a framework so that you do not cry with bloody tears and look at what he did. </p><br><p>  <strong>The simpler the better.</strong> </p><br><h1 id="slozhnost-razrabotki">  Development difficulty </h1><br><p><img src="https://habrastorage.org/webt/59/dd/95/59dd95f31944d335224302.jpeg" alt="Sisyphean toil"></p><br><p>  As the application grows, it becomes more and more difficult to make changes to it without breaking it.  It is required to take into account an increasing number of states simultaneously, scattered across different parts of the application.  Many implicit internal agreements inevitably begin to contradict each other.  Therefore, it is important that only one place in the code is responsible for one state.  If you change the value of a variable from several different event handlers, then sooner or later you will get the wrong value, which will look like a glitch, and you will have to spend quite a bit of time searching for the cause.  On the contrary, if you express any state as a function of other states, then even if your variable takes the wrong value, you always know where to look for the error - in the function of calculation or the data it receives. </p><br><p>  Continuing to develop the theme, we note that such a function does not simply allow one state to be calculated on the basis of the others, this function is a dependency between states declared in the code, an invariant that must be kept up to date throughout the life of the application.  That is, if the dependency state changes, then all dependent states should be updated automatically, without relying on the attentiveness and hard work of the developer. </p><br><p>  <strong>Reactive architecture greatly simplifies support.</strong> </p><br><p>  Often, when developing frameworks, the main attention is paid to such things as "simplicity", "flexibility" and "speed", but such important quality as "investigability" is almost ignored.  It is assumed that the developer who started working with him has already read all the documentation, understood it correctly and is a very talented person in general.  But the truth of life lies in the fact that the documentation is often incomplete, poorly structured, in a non-native language and requires a lot of time to complete the study, which is always lacking, and the developer often does not have ten years of experience and a thorough knowledge of patterns.  Therefore, the best documentation is examples.  The best examples are tests.  And the best way to understand how it works is to disassemble.  So it is important not to isolate the internal state, but to provide easy and convenient access to it.  Through the console, through a debugger, through logs.  It is necessary to name the same entities equally in different places: the names of variables in different modules, the names of modules in different contexts, the names of classes in scripts, styles and layout, etc.  And also it is necessary to add information about not obvious connections between entities.  For example, look at this code: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-panel"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-button_danger"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  How can you guess that both of these elements were added to the tree by the my-page component?  Add the missing information: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-page_content my-panel"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-page_remove my-button_danger"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Now it became clear where to dig, and who is to blame for the fact that the page delete button is not on that panel.  Another striking example is associated with parsing.  When you use JSON.parse, you lose the information about the location of the data in the source file.  Therefore, when during the subsequent validation you find an error, you cannot tell the user "On such and such a line not a valid e-mail was found," but you have to invent crutches like "Nevalidny e-mail on the way departaments [2] .users [14] .mails [0] ".  On the contrary, when using <a href="https://habrahabr.ru/post/248147/">the tree format,</a> you can always get information about the <a href="">place of its declaration</a> from the node: </p><br><pre> <code class="hljs dos">core.exception.RangeError@./jin/<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>.d(<span class="hljs-number"><span class="hljs-number">271</span></span>): Range violation ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">87</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span> cut-tail ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">87</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> cut-head ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">88</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span> body ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">85</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> jack ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">83</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> test ./examples/test.jack.<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>#<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  <strong>Bread crumbs do not interfere either in the user interface or in the program code.</strong> </p><br><h1 id="komponentnaya-dekompoziciya">  Component decomposition </h1><br><p><img src="https://habrastorage.org/files/64c/c3d/a43/64cc3da432fa4230a3a35f8f2f3493d5.png" alt="Lego"></p><br><p>  The most important aspect of any framework is the implementation of a single interaction protocol.  Actually, in the case of a micromodular framework, the only thing the core does is to organize the interaction of modules, both standard and custom.  In the case of ui framework, its main task is to organize the interaction of components - such mini applications, which themselves can work, but they also support some API for interacting with other components, allowing you to build more complex components from them like legoes; full applications.  Let's take a look at what modern frameworks offer us ... </p><br><h2 id="angularjs">  AngularJS </h2><br><p><img src="https://habrastorage.org/webt/59/dd/96/59dd9614e19fb501342287.jpeg" alt="AngularJS"></p><br><p>  Ad components: </p><br><pre> <code class="hljs coffeescript">angular.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>( <span class="hljs-string"><span class="hljs-string">'my'</span></span> ).component( <span class="hljs-string"><span class="hljs-string">'panel'</span></span> , { transclude : { myPanelHead : <span class="hljs-string"><span class="hljs-string">'?head'</span></span>, myPanelBody : <span class="hljs-string"><span class="hljs-string">'body'</span></span> }, template: `<span class="javascript"><span class="javascript"> &lt;div </span><span class="hljs-class"><span class="hljs-keyword"><span class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span></span><span class="javascript">=</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"my-panel"</span></span></span><span class="javascript">&gt; </span><span class="xml"><span class="hljs-tag"><span class="javascript"><span class="xml"><span class="hljs-tag">&lt;</span></span></span><span class="hljs-name"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">=</span></span></span><span class="hljs-string"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"my-panel-header"</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-transclude</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">=</span></span></span><span class="hljs-string"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"head"</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-tag"><span class="javascript"><span class="xml"><span class="hljs-tag">&lt;/</span></span></span><span class="hljs-name"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></span><span class="javascript"> &lt;div </span><span class="hljs-class"><span class="hljs-keyword"><span class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span></span><span class="javascript">=</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"my-panel-bodier"</span></span></span><span class="javascript"> ng-transclude=</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"body"</span></span></span><span class="javascript">&gt;No data&lt;</span><span class="hljs-regexp"><span class="javascript"><span class="hljs-regexp">/div&gt; &lt;/</span></span></span><span class="javascript">div&gt; </span></span>` } )</code> </pre> <br><p>  To declare the components, we needed to write some scripts, some templates and attach some config describing the API to them.  It turned out quite verbose and confusing.  It is necessary to keep in mind that ng-transclude contains not just text, but the name of the parameter, the value of which will be inserted inside the element.  It is necessary to carefully support the mapping of external parameter names to internal ones.  It is necessary for all elements to arrange classes so that they can be stylized.  And now we will try to use this component: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-app</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel-head</span></span></span><span class="hljs-tag">&gt;</span></span>My tasks<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel-header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel-body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-task-list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">assignee</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"me"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">status</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"todo"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel-body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  As you can see, for each parameter we had to add additional tags.  Since all these tags are in the same namespace, we had to add a prefix to each parameter with the name of the component (these tags will be inserted into the result tree for some reason, as they are).  Yes, in the simplest cases, you can use the attributes, but if there is a chance that you will need to insert an embedded component, and not just a line of text, then you have to use such bulky constructions. </p><br><p>  And now a typical situation: there is a ready-made component and we need to customize it slightly.  For example, add a basement.  The trouble with many such frameworks is that the components implemented on them are too rigid and isolated.  You cannot simply inherit from a component and slightly change its behavior.  Instead, you need to either make changes to the source component itself, complicating it and making you know too much: </p><br><pre> <code class="hljs cs">angular.module( <span class="hljs-string"><span class="hljs-string">'app'</span></span> ).component( <span class="hljs-string"><span class="hljs-string">'myPanelExt'</span></span> , { scope : { myPanelShowFooter : <span class="hljs-string"><span class="hljs-string">'='</span></span> }, transclude : { myPanelHead : <span class="hljs-string"><span class="hljs-string">'?head'</span></span>, myPanelBody : <span class="hljs-string"><span class="hljs-string">'body'</span></span>, myPanelFoot : <span class="hljs-string"><span class="hljs-string">'?foot'</span></span> }, template: ` &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel"</span></span> my-panel-show-footer=<span class="hljs-string"><span class="hljs-string">"true"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"head"</span></span>&gt;&lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-bodier"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"body"</span></span>&gt;No data&lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"foot"</span></span> ng-<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=<span class="hljs-string"><span class="hljs-string">"myPanelShowFooter"</span></span>&gt;&lt;/div&gt; &lt;/div&gt; ` } )</code> </pre> <br><p>  Either copy-paste, creating a new component very similar to the old one, but slightly different: </p><br><pre> <code class="hljs cs">angular.module( <span class="hljs-string"><span class="hljs-string">'app'</span></span> ).component( <span class="hljs-string"><span class="hljs-string">'myPanelExt'</span></span> , { transclude : { myPanelHead : <span class="hljs-string"><span class="hljs-string">'?head'</span></span>, myPanelBody : <span class="hljs-string"><span class="hljs-string">'body'</span></span>, myPanelFoot : <span class="hljs-string"><span class="hljs-string">'?foot'</span></span> }, template: ` &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"head"</span></span>&gt;&lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-bodier"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"body"</span></span>&gt;No data&lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span> ng-transclude=<span class="hljs-string"><span class="hljs-string">"foot"</span></span>&gt;&lt;/div&gt; &lt;/div&gt; ` } )</code> </pre> <br><h2 id="reactjs">  ReactJS </h2><br><p><img src="https://habrastorage.org/webt/59/dd/96/59dd9621bae5b641815424.png" alt="ReactJS"></p><br><p>  Ad components: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.head}&lt;/div&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-bodier"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.body}&lt;/div&gt; &lt;/div&gt; ) } }</code> </pre> <br><p>  Already much better, although there is still an inseparable start on JS.  Why is that bad?  Because not everywhere JS is an optimal programming language.  In the web you have no choice.  But under iOS, Swift or ObjectiveC would be better, under Android - Java, and under desktops the choice of languages ‚Äã‚Äãis generally huge, but the light on the JS has not come together.  We still have the problem of stiffness and isolation of the components, so with customization everything is almost as bad as in AngularJS.  "Almost", because we can break up our pattern into small pieces, which will allow us to further redefine them: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ header() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.head}&lt;/div&gt; } bodier() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-bodier"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.body}&lt;/div&gt; } childs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.header() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bodier() ] } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.childs()}&lt;/div&gt; }</code> </pre> <br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanelExt</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span></span>{ footer() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-footer"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.foot}&lt;/div&gt; } childs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.header() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bodier() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.footer() ] } }</code> </pre> <br><p>  We got a good flexibility, but lost the visibility of the hierarchy of elements.  And the use of XML syntax in this case becomes redundant.  Especially extravagant would be the use of the component without splitting into functions: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;<span class="hljs-type"><span class="hljs-type">MyPanel</span></span> head=<span class="hljs-string"><span class="hljs-string">"My Tasks"</span></span> body={ &lt;<span class="hljs-type"><span class="hljs-type">MyTaskList</span></span> assignee=<span class="hljs-string"><span class="hljs-string">"me"</span></span> status=<span class="hljs-string"><span class="hljs-string">"todo"</span></span> /&gt; } /&gt; ) } }</code> </pre> <br><h2 id="polymer">  Polymer </h2><br><p><img src="https://habrastorage.org/webt/59/dd/96/59dd9669a104a979716809.png" alt="PolymerJS"></p><br><p>  Ad components: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-panel"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"[my-panel-head]"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bodier"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> Polymer({ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">is</span></span></span><span class="actionscript">: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'my-panel'</span></span></span><span class="actionscript"> }) </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Obtaining parameters through selectors is striking, which makes the use of a component not very intuitive: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"import"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"../../my/panel/my-panel.html"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-app"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">my-panel-head</span></span></span><span class="hljs-tag">&gt;</span></span>My tasks<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-task-list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">assignee</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"me"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">status</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"todo"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-panel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> Polymer({ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">is</span></span></span><span class="actionscript">: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'my-app'</span></span></span><span class="actionscript"> }) </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  In general, the description of the component is similar to a hack that takes someone else's tree and modifies it beyond recognition.  In the intricacies of the real and the shadow tree is quite difficult to understand. </p><br><p>  Inheritance is not supported yet, so we use the power of copy-paste: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-panel-ext"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"[my-panel-head]"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bodier"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"footer"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"[my-panel-foot]"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> Polymer({ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">is</span></span></span><span class="actionscript">: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'my-panel-ext'</span></span></span><span class="actionscript"> }) </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dom-module</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Separately, it is worth noting the problem of stylization.  Each component draws with it its own styles, which by default are isolated from all other components.  On the one hand, this allows the use of short class names within one component, on the other hand, it adds problems when it is necessary to customize the visualization of the components in a particular context of use. </p><br><h2 id="sfericheskiy-idealnyy-freymvork">  Spherical perfect framework </h2><br><p><img src="https://habrastorage.org/webt/59/dd/98/59dd98450ceff649327257.png" alt="$ mol"></p><br><p>  Let's try to formulate what is needed to describe a component.  No matter how much you want to reuse ready-made components as they are when building an interface, they always need to be customized.  That is, the component description must support inheritance.  In order for components to be able to assemble arbitrary interfaces, it is required that they can be inserted into each other in an arbitrary manner.  That is, we need polymorphism.  In order for the same components to be used from different languages, their description should be declarative, and the syntax should be as simple and clear as possible.  Well, nobody canceled static typing. </p><br><p>  As shown above, XML does not meet these requirements at all.  In general, all attempts to make an XML template from XML look like a cross between a hedgehog and a snake.  That XML is embedded in JS, then JS is embedded in XML, or even invented its own primitive programming language with XML syntax. </p><br><p>  Let's use the <a href="https://habrahabr.ru/post/248147/">tree syntax</a> to declare a simple component: </p><br><pre> <code class="hljs perl">$my_panel $mol_view</code> </pre> <br><p>  Here we simply say that the component $ my_panel is the successor of $ mol_view.  We do not care how and in what language $ mol_view is implemented, but we argue that $ mol_panel should be implemented in the same way.  For example, the above description may expand into the following DOM tree: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$my_panel.Root(0)"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">my_panel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mol_view</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  As you can see, some attributes were automatically generated for the element.  First of all, this id is the global identifier of the component.  It is not for nothing that it has such a strange appearance, because it can be copied and pasted into the console, thereby obtaining direct access to the component instance for this responsible item.  This greatly simplifies the debugging and investigation of someone else's code.  Next are the attributes intended primarily for styling.  You can define styling for the base component, and then reload it for the heir: </p><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[mol_view]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation </span></span>: mol_view_showing <span class="hljs-number"><span class="hljs-number">1s</span></span> ease; }</code> </pre> <br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_panel]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation </span></span>: none; }</code> </pre> <br><p>  As you can see, we didn‚Äôt even need the css preprocessor to implement CSS inheritance.  That is, for the declaration of inheritance, we have only one place in the code - this is the description of the component.  And you don‚Äôt need to be separately inherited in JS, separately in CSS, separately in HTML.  According to this description, a TypeScript class for this component can also be generated: </p><br><pre> <code class="hljs scala">module $.$$ { export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$my_panel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$mol_view</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><p>  The $ mol_view component can provide a standard sub property for defining a list of child nodes.  So let's add the ability to declare and overload properties: </p><br><pre> <code class="hljs perl">$my_panel $mol_view head / body / \No data Head $mol_view <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-function"> / </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Body</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mol_view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> / </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Head</span></span></span><span class="hljs-function"> - &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Body</span></span></span><span class="hljs-function"> -</span></span></code> </pre> <br><p>  Here we declared the head and body properties, which are the contents of the header and body of the panel.  After the name we specified the default value.  For a component to be self-sufficient, the default values ‚Äã‚Äãmust always be. ,    Head  Body,       $mol_view    sub ‚Äî        . ,          ,      : </p><br><pre> <code class="hljs perl">$my_app $my_panel head / \My tasks body / &lt;= Tasks $my_task_list assignee \me status \todo</code> </pre> <br><p> ,      ReactJS,   .  ,                 : </p><br><pre> <code class="hljs mel">$my_panel $mol_view sub / &lt;= Head $mol_view sub &lt;= head / &lt;= Body $mol_view sub &lt;= body / \No data</code> </pre> <br><p>         .        ,      bem-like : </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$my_panel.Root(0)"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">my_panel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mol_view</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$my_panel.Root(0).Head()"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mol_view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">my_panel_head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$my_panel.Root(0).Body()"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mol_view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">my_panel_body</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>     ,    .     : </p><br><pre> <code class="hljs perl">$my_panel_ext $my_panel <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> / &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Head</span></span></span><span class="hljs-function"> - &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Body</span></span></span><span class="hljs-function"> - &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foot</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mol_view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foot</span></span></span><span class="hljs-function"> /</span></span></code> </pre> <br><p>      ? ,      - .      ,   .   TypeScript,       : </p><br><pre> <code class="hljs scala">namespace $.$$ { export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$my_panel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$my_panel</span></span></span><span class="hljs-class"> </span></span>{ @ $mol_mem foot_showed( next = <span class="hljs-literal"><span class="hljs-literal">false</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next } sub(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-type"><span class="hljs-type">Head</span></span>() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-type"><span class="hljs-type">Body</span></span>() , ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foot_chowed() ? [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-type"><span class="hljs-type">Foot</span></span>() ] : [] , ] } } }</code> </pre> <br><p>  ,      .            ,     ,      : </p><br><pre> <code class="hljs mel">$my_panel_demo $mol_demo_large sub / &lt;= Simple $mol_panel foot_showed false head / \I am simple <span class="hljs-keyword"><span class="hljs-keyword">panel</span></span> &lt;= Footered $mol_panel foot_showed true head / \I am <span class="hljs-keyword"><span class="hljs-keyword">panel</span></span> with footer</code> </pre> <br><p>            typescript ,       .   IDE            view.tree , ,   , ,      ,       . </p><br><h1 id="proizvoditelnost">  Performance </h1><br><p>       ,       ,          .      -  .          ,        .      , , , .              .      ‚Äî ,     ,   .      ,   ,  ,         .    ,       ,    (   ‚Äî  )  ,    .  ,     ,  ,     . </p><br><p>  jQuery   :  ,   HTML    ,   ,  .     ,          .       ,           .    ,    ,        . ,    ,    ,        .     ‚Äî      ,        . </p><br><p> ,   ReactJS ‚Äî        ,       DOM ,     JS ,             DOM.  , ,      :    ,    ,      ,    ,         ,      .    AngularJS    ,         ,   -    ,   ,     ,     .     Polymer  100500    . </p><br><p>    ,       ,       ,  ,    ‚Äî     . </p><br><p>    .     .         ,     .                 ‚Äî <a href="http://todomvc.com/">ToDoMVC</a> .       ‚Äî      ,         .        ToDoMVC ,   ,      <a href="https://github.com/eigenmethod/todomvc/tree/master/benchmark">ToDoMVC Benchmark</a>   <a href="https://habrahabr.ru/post/322162/">      </a> . </p><br><p><img src="https://habrastorage.org/webt/59/dd/9d/59dd9d1d16b96824529437.png" alt="Performance fast web-ui-frameworks"></p><br><p><img src="https://habrastorage.org/webt/59/dd/9d/59dd9d211ab9b986444660.png" alt="  web-ui-"></p><br><p>     2 : </p><br><ol><li>  100     .      setTimeout,         100    .          0  100.         . </li><li>    ,     .    setTimeout    100    .        .         .    ,        ,      ,    . </li></ol><br><p>   ,          ,      - . </p><br><p>            : </p><br><p><img src="https://habrastorage.org/webt/59/dd/9f/59dd9f69c8743899323177.png" alt="  web-ui-    "></p><br><p>          2 .         .      2.5,       3. </p><br><p> <strong>          10 .</strong> </p><br><h1 id="prizyv-k-deystviyu">  Call to action </h1><br><p>  Enough tolerating this!  ,   ,       ,    ,      ,            . </p><br><p>  <strong>Main characteristics</strong> </p><br><ul><li>    . </li><li>  . </li><li>  . </li><li>  . </li><li>  Compact size. </li><li>  . </li><li>   . </li><li>    . </li><li>   /    . </li></ul><br><p>  <a href="https://github.com/eigenmethod/mol"><strong>Documentation</strong></a> </p><br><p> <a href="http://mol.js.org/"><strong> </strong></a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/276747/">https://habr.com/ru/post/276747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276731/index.html">Full-featured REST API for perfectionists in 5 minutes</a></li>
<li><a href="../276737/index.html">The digest of interesting materials for the mobile # 139 developer (February 1-7)</a></li>
<li><a href="../276739/index.html">Why Yandex refused to confirm sites txt file</a></li>
<li><a href="../276741/index.html">‚ÄúDevilish‚Äù ACL - my version of rights verification</a></li>
<li><a href="../276745/index.html">Compare prices in online bookstores using python, pandas and matplotlib</a></li>
<li><a href="../276749/index.html">School of Data "Beeline" for managers</a></li>
<li><a href="../276751/index.html">IBM will strengthen the fight against cyber fraud using IRIS Analytics technology</a></li>
<li><a href="../276753/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 197 (February 1 - 7, 2016)</a></li>
<li><a href="../276755/index.html">Does Google promote me sell kidney meme in Russia?</a></li>
<li><a href="../276757/index.html">Configuring Intel Edison Board for Microsoft Azure IoT suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>