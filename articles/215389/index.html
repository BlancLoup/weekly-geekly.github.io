<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple proxy DLL do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It took me to intercept the calls of GDS32.DLL. I decided to write a proxy dll. 

 We write a research stand 
 The first thing we need is to get a lis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple proxy DLL do it yourself</h1><div class="post__text post__text-html js-mediator-article">  It took me to intercept the calls of GDS32.DLL.  I decided to write a proxy dll. <br><br><h4>  We write a research stand </h4><br>  The first thing we need is to get a list of all exported functions from a real dll. <br>  Let's do this with the following code: <br><br><pre><code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">program</span></span> GetFuncsDll; <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows; <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>. ImageBase: DWORD; <span class="hljs-comment"><span class="hljs-comment">//  dll 6. pNtHeaders: PImageNtHeaders; // PE  dll 7. IED: PImageExportDirectory; //    8. ExportAddr: TImageDataDirectory; //   9. I: DWORD; //    10. NamesCursor: PDWORD; //      11. OrdinalCursor: PWORD; //      12. LIB_NAME:AnsiString; //  dll 13. BEGIN 14. LIB_NAME:='MiniLib.dll'; 15. loadlibraryA(PAnsiChar(LIB_NAME)); 16. ImageBase := GetModuleHandleA(PAnsiChar(LIB_NAME)); 17. pNtHeaders := Pointer(ImageBase + DWORD(PImageDosHeader(ImageBase)^._lfanew)); 18. ExportAddr := pNtHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; 19. IED := PImageExportDirectory(ImageBase+ExportAddr.VirtualAddress); 20. NamesCursor := Pointer(ImageBase + DWORD(IED^.AddressOfNames)); 21. OrdinalCursor := Pointer(ImageBase + DWORD(IED^.AddressOfNameOrdinals)); 22. For I:=0 to Integer(IED^.NumberOfNames-1) do begin 23. WriteLn(output,PAnsiChar(ImageBase + PDWORD(NamesCursor)^),'=',OrdinalCursor^ + IED^.Base); 24. Inc(NamesCursor); 25. Inc(OrdinalCursor); 26. end; 27. Readln; 28. end.  1</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are no difficulties here.  We get sequentially to the export table (line 19) of pointers to an array of names (NamesCursor) and an array of numbers (OrdinalCursor) and read the function by function, names and numbers.  The number of functions is in the NumberOfNames field.  This code was produced on the Internet, then refined and simplified. <br><a name="habracut"></a><br>  Consider our test dll. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Library</span></span> MiniLib; <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b:integer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. result:=a+b; <span class="hljs-number"><span class="hljs-number">5</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mySub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b:integer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>. result:=ab; <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>. myAdd, <span class="hljs-number"><span class="hljs-number">12</span></span>. mySub; <span class="hljs-number"><span class="hljs-number">13</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.  <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  There are no difficulties either.  We export two functions - addition and subtraction. <br>  The list of exported functions and numbers will be as follows: <br><br>  myAdd = 2 <br>  mySub = 1 <br>  Listing 3 <br><br>  Such numbers are assigned by the compiler.  Why precisely such?  I do not know this. <br>  Now focus on the addition function.  Let's look at what code its call was compiled for, for this we will call it and see in the debugger. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">program</span></span> TestCall; <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows; <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>. myAdd: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b:integer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>. Handle:HMODULE; <span class="hljs-number"><span class="hljs-number">7</span></span>. N:Integer; <span class="hljs-number"><span class="hljs-number">8</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>. Handle := loadlibrary(<span class="hljs-string"><span class="hljs-string">'MiniLib.dll'</span></span>); <span class="hljs-number"><span class="hljs-number">10</span></span>. @myAdd := GetProcAddress(Handle, <span class="hljs-string"><span class="hljs-string">'myAdd'</span></span>); <span class="hljs-number"><span class="hljs-number">11</span></span>. <span class="hljs-comment"><span class="hljs-comment">//      12. //@myAdd := GetProcAddress(Handle, PChar(2)); 13. N:=myAdd(1,2); 14. writeLn(N); 15. readln; 16. end.  4</span></span></code> </pre><br><br>  It's simple.  We get the address of the function and call it.  I will only explain that in the second parameter, GetProcAddress is a pointer to the name of the function, but this is if it is greater than $ FFFF, if less than or equal, then it is taken as the function number in the export table.  That is, we can call a function by number or by name. <br><br>  Now let's see how the result of adding to the variable is entered, namely the operation of line 13. <br><br>  1. TestCall.dpr.13: N: = myAdd (1,2); <br>  2. push $ 02 <br>  3. push $ 01 <br>  4. call dword ptr [$ 0040cba4] <br>  5. mov [$ 0040cbac], eax <br>  Listing 5 <br><br>  And then everything is simple, we put the stack, the two (2) and the unit (3), call our function (4), the result of the addition is placed by the compiler in the register eax, and then from the register we copy the result into the variable N (5). <br><br>  Here it is before you a common function call from Dll.  Arguments are pushed onto the stack, a call is made, and results are read from the registers (or stack). <br><br><h4>  Idea </h4><br>  My idea is that when, instead of the present, my fake dll lies, then at first it intercepts the inputs of the function and the name of the function, then calls the real function and as if there was nothing. <br><br>  We write fake Dll. <br><br>  So, we have a list of functions and numbers, but some exported code must correspond to each exported function.  What a.  That's what this is written for.  Those examples that I saw on the Internet, in them the useful code for each intercepted function is cloned, and moreover you need to know the parameters of the export function to call this with the same parameters.  I was too lazy to carry out such hard work (to find the description of all the functions of GDS32 and duplication on Delphi) this time.  Still, cloning a useful code is ‚Äúnot our method.‚Äù  The idea is as follows - we want the application to execute our code after the function is called.  Once the code is the same, well, let's make a separate procedure with a useful code - ProxyProc.  And every fake procedure should just call ProxyProc.  Next, the proxy procedure must somehow find out exactly what procedure caused it.  After deliberation, I came to the conclusion that the ideal option is to push the number of the function onto the stack.  We also need to preserve the state of the registers and flags, because they can affect the execution of the procedure in this DLL.  Total we get for each exported function four lines of code.  And yes, since we interfere with the underlying mechanisms of the work of Windows, in order to be sure of what and where we have messed up, we will write in assembler. <br><br>  1. pushfd // the same for each function <br>  2. pushad // same for each function <br>  3. push 2 // changing the number for each function <br>  4. call ProxyProc // the same for each function <br>  Listing 6 <br><br><h4>  We implement the idea </h4><br>  And here is the code. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Library</span></span> minilib2; <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Uses</span></span> Windows; <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-number"><span class="hljs-number">5</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProxyProc</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assembler</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FakeProc0001</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assembler</span></span>; <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>. pushfd <span class="hljs-number"><span class="hljs-number">12</span></span>. pushad <span class="hljs-number"><span class="hljs-number">13</span></span>. push <span class="hljs-number"><span class="hljs-number">000000001</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>. call ProxyProc <span class="hljs-number"><span class="hljs-number">15</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>. <span class="hljs-number"><span class="hljs-number">17</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FakeProc0002</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assembler</span></span>; <span class="hljs-number"><span class="hljs-number">18</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>. pushfd <span class="hljs-number"><span class="hljs-number">20</span></span>. pushad <span class="hljs-number"><span class="hljs-number">21</span></span>. push <span class="hljs-number"><span class="hljs-number">000000002</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>. call ProxyProc <span class="hljs-number"><span class="hljs-number">23</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-number"><span class="hljs-number">24</span></span>. <span class="hljs-number"><span class="hljs-number">25</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Exports</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span>. FakeProc0001 <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'mySub'</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>. FakeProc0002 <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'myAdd'</span></span>; <span class="hljs-number"><span class="hljs-number">28</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Begin</span></span> <span class="hljs-number"><span class="hljs-number">29</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">End</span></span>.  <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  It's simple.  We export two fake procedures, and give them the names and numbers the same as in this dll. <br>  The next trickiest part is the proxy procedure itself.  What it should consist of. <br><br>  1. Perform some useful operations with the number of the function and input parameters. <br>  2. Find out the address of this function <br>  3. Return all registers to their original state. <br>  4. Transfer control to the address of this procedure, as if nothing had happened. <br><br>  Accordingly, its code may be as follows. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LibName:pAnsiChar = <span class="hljs-string"><span class="hljs-string">'MiniLib_.DLL'</span></span><span class="hljs-string"><span class="hljs-string">#0</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeveloperProc</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-comment"><span class="hljs-comment">//   4. begin 5. end; 6. Procedure ProxyProc; assembler; 7. asm 8. call DeveloperProc; //  ,      //  ,     9. add esp,4 //       10. push LibName //     dll 11. call LoadLibraryA //  dll  ,   12. push eax //      13. call GetProcAddress //      .    14. mov [esp-4], eax //     , //         15. popad //   16. popfd //   17. jmp [esp-40] //    , //        //     18. end;  8</span></span></code> </pre><br><br>  Now when we compile this code, we get ‚Äúminilib2.dll '.  Rename it to "minilib.dll" and substitute, and "minilib.dll" rename accordingly to "minilib_.dll" <br><br><h4>  Now let's see how it works. </h4><br>  TestCall.dpr.13: N: = myAdd (1,2); <br>  1. push $ 02 <br>  2. push $ 01 <br>  3. call dword ptr [$ 0040cba4] // call myAdd, but get into fake <br>  4. mov [$ 0040cbac], eax <br>  Listing 9 <br>  In Listing 9, the part of the already seen code that calls the function from the Dll and in the table below the state of the stack and the registers after getting into the fake procedure, that is, after entering the call on line 3 <br><table><tbody><tr><td>  EAX 00364434 <br>  EBX 7FFDA000 <br>  ECX 00000000 <br>  EDX 00000003 <br>  ESI 16A1F224 <br>  EDI 13D84260 <br>  EBP 0012FFC0 <br>  ESP 0012FFA4 <br>  EIP 00364434 <br>  EFL 00000246 <br>  Listing 10 <br></td><td>  0012FFAC 00000002 // second argument <br>  0012FFA8 00000001 // first argument <br>  -&gt; 0012FFA4 0040811A // return address in the executable <br>  Listing 11 <br></td></tr></tbody></table><br><br>  Further we see on the left the code of our four-line fake procedure and on the right the state of the stack after getting into proxyproc, that is, after entering the call on line 4 <br><br><table><tbody><tr><td>  minilib2.myAdd: // it is also fakeProc0002 <br>  1. pushfd <br>  2. pushad <br>  3. push $ 02 <br>  4. call $ 00364408 // call proxyProc <br>  Listing 12 <br></td><td>  0012FFAC 00000002 // second argument <br>  0012FFA8 00000001 // first argument <br>  0012FFA4 0040811A // return address in the executable <br>  0012FFAO 00000346 // flag register <br>  0012FF9C 00364434 // register EAX <br>  0012FF98 00000000 // ESC register <br>  0012FF94 00000003 // EDX register <br>  0012FF90 7FFDA000 // EBX register <br>  0012FF8C 0012FFAO // ESP register <br>  0012FF88 0012FFC0 // EBP register <br>  0012FF84 16A1F224 // ESI register <br>  0012FF80 13D84260 // EDI register <br>  0012FF7C 00000002 // function number (02) <br>  -&gt; 0012FF78 0036443D // fakeProc0002 fake procedure return address <br>  Listing 13 <br></td></tr></tbody></table><br><br>  Then we see the proxy procedure code on the left and the state of the stack after receiving the true procedure address after executing line 6 on the right. <br><br><table><tbody><tr><td>  minilib2.ProxyProc: <br>  1. add esp, $ 04 <br>  2. push dword ptr [$ 0036782c] <br>  3. call $ 00364394 // this is LoadLibrary <br>  4. push eax <br>  5. call $ 00364384 // this is GetProcAdress <br>  6. mov [esp- $ 04], eax <br>  7. popad <br>  8. popfd <br>  9. jmp dword ptr [esp- $ 28] <br>  Listing 14 <br></td><td>  0012FFAC 00000002 // second argument <br>  0012FFA8 00000001 // first argument <br>  0012FFA4 0040811A // return address in the executable <br>  0012FFAO 00000346 // flag register <br>  0012FF9C 00364434 // register EAX <br>  0012FF98 00000000 // ESC register <br>  0012FF94 00000003 // EDX register <br>  0012FF90 7FFDA000 // EBX register <br>  0012FF8C 0012FFAO // ESP register <br>  0012FF88 0012FFC0 // EBP register <br>  0012FF84 16A1F224 // ESI register <br>  -&gt; 0012FF80 13D84260 // EDI register <br>  0012FF7C 0037437C // the address of this procedure in this dll <br>  Listing 15 <br></td></tr></tbody></table><br><br>  Then we see in the table on the left the state of the registers and on the right the state of the stack before jmp for the true procedure, that is, before executing line 9 of Listing 14. As you can see the state of the stack and registers is identical to the state immediately after entering the fake procedure (Listings 10 and 11) hope the true dll procedure doesn‚Äôt feel the difference.  (28 in hexadecimal is 40 in decimal, that is, 10 times 4 bytes is exactly the place on the stack where we have the address of the true procedure (Listing 17)). <br><br><table><tbody><tr><td>  EAX 00364434 <br>  EBX 7FFDA000 <br>  ECX 00000000 <br>  EDX 00000003 <br>  ESI 16A1F224 <br>  EDI 13D84260 <br>  EBP 0012FFC0 <br>  ESP 0012FFA4 <br>  EIP 00364422 <br>  EFL 00000246 <br>  Listing 16 <br></td><td>  0012FFAC 00000002 // second argument <br>  0012FFA8 00000001 // first argument <br>  -&gt; 0012FFA4 0040811A // return address in the executable <br>  1. 0012FFAO 00000346 // flag register <br>  2. 0012FF9C 00364434 // register EAX <br>  3. 0012FF98 00000000 // ESC register <br>  4. 0012FF94 00000003 // register EDX <br>  5. 0012FF90 7FFDA000 // EBX register <br>  6. 0012FF8C 0012FFAO // ESP register <br>  7. 0012FF88 0012FFC0 // EBP register <br>  8. 0012FF84 16A1F224 // ESI register <br>  9. 0012FF80 13D84260 // EDI register <br>  10. 0012FF7C 0037437C // address of this procedure in this dll <br>  Listing 17 <br></td></tr></tbody></table><br><br>  Finally, the developer procedure. <br><br>  In this procedure, it is not necessary to write in assembly language.  Here we actually can do the interception, without harming the contents of the registers and the stack. <br><br>  For example, a simple code to display in the file all the numbers of called functions can be like this. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeveloperProc</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. F:text; <span class="hljs-number"><span class="hljs-number">4</span></span>. _ebp:PAnsiChar; <span class="hljs-comment"><span class="hljs-comment">//   5.begin 6. asm 7. mov _ebp,ebp; 8. end; 9. assignfile(F,'G:\Projects\dllproxy\logdll.txt'); 10. append(F); 11. writeln(F,DateTimeToStr(now),': ',PDWORD(_ebp+3*4)^); 12. closefile(F); 13.end;  18</span></span></code> </pre><br><br>  On line 7 in the variable _ebp brought the pointer base <br>  on line 9 linked variable F to the file <br>  on line 10 opened the file to add <br>  On line 11 recorded the current date and time, and the number of the function called <br>  We must add 4 bytes three times to the base pointer, because there are three pointers on the stack after the function number: 1. Pointer to return to the fake procedure, 2. Pointer to return to the proxy procedure, and 3. Pointer to the stack placed by the compiler ( push ebp).  The pointer type PAnsiChar was chosen because addition and subtraction operations with numbers are allowed. <br>  On line 12, they closed the file. <br><br>  Examples download <a href="http://rghost.ru/52942559">here</a> . <br><br>  PS Proxy-GDS32.Dll was successfully compiled, the program using it did not issue any errors in its work, all calls were intercepted into the log file, failed sql queries were caught and optimized. <br>  PPS The author of this article is not responsible for the use of information and material in this article.  All information is given solely for educational purposes. </div><p>Source: <a href="https://habr.com/ru/post/215389/">https://habr.com/ru/post/215389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215375/index.html">StarCraft disassembled and launched on ARM</a></li>
<li><a href="../215381/index.html">How to take back music and video from VC using Chrome browser using its extension</a></li>
<li><a href="../215383/index.html">My implementation of the automatic inclusion of light in the toilet (and without Arduino)</a></li>
<li><a href="../215385/index.html">The prosecutor's office of Surgut is preparing materials to convict a person for 4 years for the purchase of smart watches</a></li>
<li><a href="../215387/index.html">Timekeeping on Mars</a></li>
<li><a href="../215391/index.html">OpenFOAM in practice</a></li>
<li><a href="../215395/index.html">Accounting expiration dates in warehouses. Variants of implementations</a></li>
<li><a href="../215397/index.html">Pi Day</a></li>
<li><a href="../215399/index.html">Installing Mono 3 on the SoC of the Allwinner A10 / A20 family, using the example of Cubieboard2</a></li>
<li><a href="../215401/index.html">Cubieboard A10 as a router and WiFi hotspot point</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>