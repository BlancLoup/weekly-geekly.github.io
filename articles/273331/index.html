<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparative analysis of C # and C ++ languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's take a closer look at these two languages. What is important for a diligent programmer? So that its code is readable, so that at any time, after...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparative analysis of C # and C ++ languages</h1><div class="post__text post__text-html js-mediator-article">  Let's take a closer look at these two languages.  What is important for a diligent programmer?  So that its code is readable, so that at any time, after any time, you can change this code. <br><br><h2>  C ++ </h2><br>  What does C ++ teach us, what does it tell us, what paradigms does it erect? <br><br>  1. What can be called types, methods and variables in small letters 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; L; L.push_back(<span class="hljs-number"><span class="hljs-number">50</span></span>); L.push_front(<span class="hljs-number"><span class="hljs-number">-50</span></span>);</code> </pre> <br>  You ask what is wrong with naming the elements in small letters? <br><br>  And the fact that, firstly, C ++ does not distinguish between the type context and the context of a variable and a function!  And you can‚Äôt take and declare a field, say, size or point point!  Therefore, it makes sense to call functions and variables in small letters, but only if the type is named in C # style, and naming the type in small letters spoils the whole point of such an action!  And the point is that it is impossible to intersect the type name and its members! <br><br>  Well, and secondly, naming as C #, looks more solid, more beautiful. <br><br>  Although, of course, you can name it exactly as it is now proposed, but not the fact that others will follow this rule. <br><a name="habracut"></a><br>  2. What can be reduced in such a way that it will be incomprehensible to those who use your code, but ‚Äúprint quickly‚Äù.  Or abbreviate, but still understandable. <br><br>  Here are some of the methods from the standard library: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; s.rfind(); s.c_str(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fstream fs; fs.copyfmt(); fs.rdbuf();</code> </pre><br>  Do you understand anything?  What is ‚Äúrfind‚Äù and why not ‚Äúfind‚Äù, what is this r for?  What is "c_str"?  It is necessary to look at the documentation in order to understand that this transformation of a string into a ‚Äústring as in C‚Äù is an array-pointer to characters ... <br><br>  3. That you can use macros as a universal means of solving problems.  In this case, it is intentionally forgotten, or is silent, that these macros can be easily replaced, and that they are global, not included in any namespace. <br><br>  For example: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> foreach(x,c) for(auto x = c.begin(); x != c.end(); x++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> min(x,y) ((x)&lt;(y) ? (x) : (y)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true false #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NULL 1</span></span></code> </pre><br>  Please also note that if the parameters of a parameterized macro are not enclosed in parentheses, then all calculations with this macro will easily deteriorate!  But the fact is that the parameters of the macro being opened are perceived as text (!), And if you do not put brackets, we will get something like this: <br><br><pre> <code class="cpp hljs"> a = b * min(x,y); <span class="hljs-comment"><span class="hljs-comment">//==&gt; a = b*x &lt; y ? x : y; a = min(5,3*k)*100; //==&gt; a = 5 &lt; 3*k ? 5 : 3*k*100;</span></span></code> </pre><br>  Agree, this is not what we expected!  And only those who have learned this trick of macros with parameters on their own bitter experience, long ordeal and exclamations: ‚ÄúGod, what I did not do that!‚Äù (Or those who read the documentation for the language) write these macros correctly (and you need to be very careful!) . <br><br>  4. What are you yourselves!  - should do many things that in C ++ were too lazy to do. <br><br><ul><li>  Not implemented normal stack operation.  I still do not understand how it works!  And where to get the usual hash (dictionary / card)? </li><li>  Memory allocation (new / malloc) is terribly slow!  You yourself, yourself!  should do the memory manager (wow task!), or be content with slow work </li><li>  Elementary classes are not implemented - the class ‚ÄúArray‚Äù, the class ‚ÄúTwo-dimensional array‚Äù and the class ‚ÄúThree-dimensional array‚Äù. </li><li>  No base type conversions have been created: string and numeric (including logical), they must be done by oneself (although there are possibilities for this) </li></ul><br>  And there are many more such things.  Of course, you can find ready-made solutions.  But it is not known what quality they will be, whether you will find them at all;  besides, they will need to adjust to your style. <br><br>  5. That you can mess around with pointers and even with constant pointers, you just need to correctly convert types.  Take a look: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* x)</span></span></span><span class="hljs-function"> </span></span>{ ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)x)[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">500</span></span>; Func(&amp;m); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; m &lt;&lt;<span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  And what will appear with us?  five!  The constant parameter has changed its value!  So any constant pointers can be changed, even string or numeric (although their change causes a memory handling error).  Or here: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M,N; T(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { M = m; N = n; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T t = T{<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; ((T*)(&amp;t))[<span class="hljs-number"><span class="hljs-number">0</span></span>] = T(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; tM &lt;&lt;<span class="hljs-string"><span class="hljs-string">" "</span></span>&lt;&lt; tN &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Here the static constant of structural type changes!  That is, the one in whose immutability we are 100% sure!  ‚ÄúBut no!‚Äù Says C ++.  And it is the modified value of the constant that is output. <br><br>  6. That it is possible to dump the contents of listings into the general context!  Moreover, without the inclusion of the standard C ++ 11, we can not do otherwise. <br><br>  It's horrible!  Take a look at this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Month { JANUARY,FEBRUARY, MARCH,APRIL,MAY, JUNE,JULY,AUGUST, SEPTEMBER,NOVEMBER, DECEMBER }; ... Month m = JANUARY; ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JANUARY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FEBRUARY: }</code> </pre><br>  And if the elements intersect, are they present in one and in another enumeration (for example, such completely recurring ‚ÄúNORMAL‚Äù, ‚ÄúDEFAULT‚Äù)?  What then? .. C ++ allows the call to enums in this way!  The lazy loose C ++ programmers will say: ‚ÄúAnd what is also spelled faster, it is also possible!‚Äù, They didn‚Äôt know that this is licentiousness, as was unheard of for those who go to modern Russian comedies (‚ÄúAnd what‚Äôs funny, like in life!‚Äù) ! <br><br>  Even if you want to call correctly (suppose you are a decent C ++ programmer using someone‚Äôs code), it turns out to be ugly and ugly - you get a combination of a constant style (element) and a C # style (enum name), and you have to write without a name listing, so it was at least beautiful. <br><br>  Although, of course, you can be decent and call the enumeration elements correctly (as enums themselves (here, in general, it is unlikely that the type name and its element will intersect, so the style can be the same, which is preferable, because it's more beautiful)) and not throw out elements in context, even forbidding it by adding the word ‚Äúclass‚Äù after ‚Äùenum" (standard C ++ 11). But it is not a fact here that the others will be as decent and follow the rules! <br><br>  Correctly do so: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Month</span></span></span><span class="hljs-class"> {</span></span> January, February, March,April,May, June,July,August, September,October,November, December };</code> </pre><br>  7. That such things as are not at all a mistake: <br><br><ul><li>  not a function return value, or not all conditional branches return </li><li>  use not defined variable </li></ul><br>  But at least there are warnings about this, but sometimes they forget to read them, and they are formed only after compilation, until we read them, an error can occur, because we usually compile with a further launch. <br><br>  And, the most terrible thing is that in order to substitute a variable for the reference parameter when calling, no additional words are needed.  This is terrible, as it leads to the fact that the call can be perceived as a call without any changes in parameters.  Take a look: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; y)</span></span></span></span>; . . . F(x,y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; FF(x,y);</code> </pre><br>  What do we see?  We see that IF A REFERENCE SIGN IS REFERRED, THEN THE CHALLENGE WILL NOT CHANGE.  We may not know where the reference parameter is, where the parameter value is!  Only by the meaning of the function or by activating the hint in the IDE can we determine this! <br><br><h4>  Let's sum up </h4><br>  With ++ it tells us: I do not have some important things, you have to get it or write them yourself, and there are no clear rules in our "democratic" language, live as you wish! <br><br>  C ++ teaches us: write ugly, depraved, using macros, double-triple-quadruple underscores, shortening names to obscure, but fast-typing, throwing enumeration elements into the general context, freely referring to pointers, even changing the contents of constants, and indeed to we will not swear at some things interrupting the compilation, but only warn you ... As if to say: no one forbids you to do this, all restrictions are decided! <br><br>  Meanwhile, such teachings and paradigms only spoil the diligent programmers, moreover, forcing them to create / search for some basic, necessary, solutions, have a bad effect on the outlook and nerves of the programmer and leading to a deterioration in the readability of the code ... <br><br><h2>  C # </h2><br>  But take a look at C #!  What does he tell us, what paradigms does he erect, what does he teach? <br><br>  1. That words in type names, functions, variables begin with a capital letter and are connected without separators (thanks to large letters, words are visible).  This is called the C # style (another name is Pascal style), a representative of the camel style group.  That the first word of the name of each closed variable begins with a small one, so as not to be confused with the open - the Java style, the second representative of the camel's style group. <br><br>  The context of type names is different from the context of the names of functions, variables and constants.  You can declare a Size Size or Point Point field, and it will compile and you can even use it correctly (even combine the field name and type name without using this!)! <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Rect { Point Point; Size Size; <span class="hljs-comment"><span class="hljs-comment">// ... Rect(int x,int y,int w,int h) { Size = new Size(w,h); Point = new Point(x,y); } ... } Rect r = new Rect(new Point(5,5), new Size(300,200));</span></span></code> </pre><br>  2. With no abbreviations outside the context of the function!  Its naming style in std.  C # libraries show an example to the rest - how to correctly name the elements of the code, this style is beautiful and inspiring for feats.  No abbreviations, camel style with a capital letter, no underscores, you will not find them at all!  Each word is complete, or is an abbreviation (which, of course, is allowed), also starting with a large one, and then with small ones. <br><br><pre> <code class="cs hljs"> XmlDocument document = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlDocument(); Rectangle rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>);</code> </pre><br>  3. The possibilities of macros are cut to the limit.  You can only declare and check whether there is such-and-such a macro, and some macros are declared through the compiler settings.  Everything! <br><br><pre> <code class="cs hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> M ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> M double M = 53; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Moreover, the name of the macro and the name of the element (type / function / variable / constant) are parallel, not connected in any way, you can call the same name as a macro and a variable (or another element). <br><br>  Here are some safe macros. <br><br>  4. That many, many things are already well done in C #, and the normal, solid style makes them self-documenting and understandable, especially after reading the documentation. <br><br>  There are plenty of classes and namespaces in the main assemblies that you have not yet learned.  And this is just the main assembly, and there are many others! <br><br>  In the main assemblies made: <br><ul><li>  all basic conversions between string, numeric and logical types, conversions are in the class Convert (System) </li><li>  Sane collections (System.Collections *) </li><li>  Xml Classes (System.Xml *) </li><li>  Network Classes (System.Net *) </li><li>  Multithreading (System.Threading *) </li><li>  Classes on working with processes, performance diagnostics, debugging (System.Diagnostics *) </li><li>  and even the CodeDom compiler for .NET languages!  (System.CodeDom) </li><li>  and much more </li></ul><br>  And there are many more additional ones, among them there are 2 main ones used in window applications: System.Windows.Forms * (for working with GUI) and System.Drawing * (for working with graphics) <br><br>  Also, there are some useful built-in things in the language that are not found in C ++: <br><ul><li>  built-in foreach clause - enumeration of collection elements </li><li>  automatic garbage collector, we don‚Äôt need to manually free the memory, but it is allocated very quickly and don‚Äôt have to do our own memory management </li><li>  properties - instead of writing access methods, you can write properties that combine the two access methods and do not have parameters, all more concisely, especially affecting the beauty of the class interface </li><li>  everything inherits from the object and can be turned into a string by the overridden method ToString () </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Example</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Object{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>==<span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>;} } } ... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(String arg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args) { Console.WriteLine( arg ); } ...</code> </pre><br><br>  5. What you can not just take and indulge pointers.  To do this, you need to enable unsafe code in the compilation settings and mark the class as unsafe by adding ‚Äúunsafe‚Äù to the list of its modifiers.  And only after that it will be possible to work with them. <br>  Besides, impossible, impossible!  - get the address of a constant or read-only variable, which makes it impossible to change it!  - and we can sleep peacefully with a sweet dream, knowing that C # will not allow constants and unchangeable variables <s>to offend every sadist, oh, that is,</s> change! <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* n = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)(<span class="hljs-number"><span class="hljs-number">5</span></span>); n = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)(n+<span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre><br>  6. That the elements of enums remain in the context of enumerations and do not fall out into the global context.  And they are written (by convention) in the same style - the C # style - as the name of the enumeration containing them. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DayOfWeek { Monday = <span class="hljs-number"><span class="hljs-number">1</span></span>, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday }</code> </pre><br>  In C #, no function / variable / constant can be outside the class. <br><br>  7. That many errors that a programmer negligently misses, to identify which algorithms can be identified, C # detects and says that this is an error, interrupting the compilation if this error affects the work, and some remain as a warning if they do not.  That is, inadvertent errors. <br><br>  Among the errors: <br><br><ul><li>  not returning value in all conditional branches, or no value returning </li><li>  use not defined variable </li><li>  implicit conversion of a larger number in RAM to a number smaller in size in RAM - double ==&gt; float / long ==&gt; int ==&gt; short ==&gt; byte, etc., as well as signed and unsigned into each other: int &lt;=&gt; uint, short &lt;=&gt; ushort, etc .;  as well as bool &lt;=&gt; number </li><li>  implicit conversion bool &lt;=&gt; number </li><li>  jumping from one case label to another, if this is not closed by the break interrupt command, with something containing or the last. </li></ul><br>  Among the warnings are: <br><br><ul><li>  unused variable, function, event (private or local) </li><li>  unreachable code means it has a transition command (return / goto / break / continue) </li></ul><br><br>  In addition, function parameters can have one of two modifiers: <br>  1. ref - link transfer, in the declaration and transfer of a link variable, you must explicitly indicate this word in front. <br>  2. out - the same, but the variable may not yet be declared. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">O</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span>{ ... } ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; F(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x,<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j,k; O(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> j,<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> k);</code> </pre><br>  And when we call a function, we can see where we are passing the link, and where is the value.  This is great, this is a good language rule. <br><br>  There are other useful limitations: <br><br><ul><li>  order with operator functions - they all have to be static </li><li>  You cannot create a function / variable / constant outside a class (because you can find a class for any actions or data) </li></ul><br><h4>  Let's sum up </h4><br>  C # tells us: program in pleasure, I have everything for this: wonderful language rules, naming rules, as well as various useful libraries. <br><br>  C # teaches us: use the correct naming style, forget about any underscores, they are unnecessary;  Forget free global variables and functions, everything is in classes;  Do not consider restrictions to be far-fetched, but consider them to be correct and ordering your thinking, write according to the rules and you will acquire nirvana! <br><br>  Very useful and necessary for a decent programmer teachings and paradigms that have a great effect on the mood and worldview and lead to order in the head and the code. <br><br><h2>  Conclusion </h2><br>  If you want to become a supporter of the corrupting democracy C ++, then there you and the road, you have the right to make this choice.  But if you are ready to comprehend nirvana in programming, to preserve your nerves, health and sanity, then your choice is C #. </div><p>Source: <a href="https://habr.com/ru/post/273331/">https://habr.com/ru/post/273331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273319/index.html">Star Wars Universe Social Network</a></li>
<li><a href="../273323/index.html">Vivaldi Beta 2 browser release</a></li>
<li><a href="../273325/index.html">Santa Claus asks a question. Contest for Intel Blog Readers</a></li>
<li><a href="../273327/index.html">"War and Peace" - the test of time</a></li>
<li><a href="../273329/index.html">5 brightest scams with WhatsApp in 2015</a></li>
<li><a href="../273333/index.html">As I have been rewriting my cryptocurrency with PHP for Go for 8 months. Part 2</a></li>
<li><a href="../273335/index.html">Lectures Technopark. Master class "20 mistakes in creating an IT-company"</a></li>
<li><a href="../273337/index.html">Detection of insider trading: Algorithms for identifying and patterns of illegal transactions</a></li>
<li><a href="../273339/index.html">Windows 10 Digest. November-December 2015</a></li>
<li><a href="../273341/index.html">How to choose a programming language?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>