<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Telegram-bot for Redmine. How to simplify the life of yourself and people</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In any company that uses a project and task management system, sooner or later there is a desire to combine it with some popular messenger to simplify...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Telegram-bot for Redmine. How to simplify the life of yourself and people</h1><div class="post__text post__text-html js-mediator-article">  In any company that uses a project and task management system, sooner or later there is a desire to combine it with some popular messenger to simplify communications.  Especially if through this system there is interaction with customers. <br><br>  The article will discuss how to make friends with Redmine Telegram and not break the existing business processes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/7u/m_/hd7um_l8lkdap9v0fl9cy_ppjog.png"></div><br><a name="habracut"></a><br>  A small background, how the idea of ‚Äã‚Äãa subject was born. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our company is engaged in the administration of servers and sites 24/7, the development of infrastructure for large and developing Internet projects, the design of fault-tolerant systems and the automation of DevOps. <br><br>  To interact with customers, we use Redmine, which we zatyunili under our processes and hung on it a number of pleasant things that make our lives easier. <br><br>  When we started, it was in 2011, we decided that we would communicate with customers only through our task tracker.  This is due to the fact that in addition to supporting the servers and responding to incidents, most of our work consists of infrastructure development tasks.  It is important for us at any moment to understand well the current state of the infrastructure, the vector of project development, properly assess needs and bottlenecks, propose solutions, coordinate them and implement.  The matter is complicated by the fact that there are a lot of projects, not one person works at each, but a team of administrators.  At the same time, administrators work in shifts, some of them may not always intersect with each other in the office, and tasks need to be done.  Therefore, the issue of synchronization of knowledge and actions within the team and between shifts is extremely important for us. <br><br>  Considering all these factors, we decided that the only possible way to keep the situation under control is to ensure that all communications and all work take place in one place - in the system of tasks.  Naturally, we run project wiki and do much more to solve the problem of synchronization of actions and context, but the key point has always been a single point of interaction with customers.  If you add another channel to the communications, for example, instant messengers, say, for a quick discussion of some issues, 100% customers will begin to abuse this, we will quickly drown in the abyss of endless comments, and important information will start to get lost.  And the prospect of chaotic communication with clients in 5 different windows against the Redmine tasks, which were decomposed into clear business processes, did not appeal to administrators. <br><br>  In the end, we lived for about 5 years. During this time, many customers have come to love our Redmine, its simplicity and functionality.  Someone, having worked with him with us, decided to implement it in his company.  Only occasionally isolated clients were interested in whether it was possible to set tasks for us not only through the system of tasks, but also through some instant messenger, because it would be more convenient. <br><br>  But over the past 2 years the number of such requests has increased significantly.  So much so that it was impossible not to take them into account.  And we once again thought about what to do with it.  Sales managers, as usual, tried to push the idea in some miraculous way to embed communication with clients via Skype, WhatsApp or Telegram into our work processes.  Administrators absolutely did not want this. <br><br>  After violent disputes and discussions, we had the idea to develop a Telegram bot that would allow all customer messages to be laid out according to existing tasks in Redmine or create new ones where administrators will work with them in their familiar environment. <br><br>  Squared a small plan - first the minimum functionality, then the pleasant little things.  After some time, we received a prototype of the future bot, who successfully delivered a message written to him from Telegram to Redmine, and vice versa!  This gave confidence that the idea is viable.  And we have made every effort to bring it to the end and run. <br><br>  In order to better explain how it all works - the article is divided into two blocks.  The first block contains a general description of the bot and examples of its work.  In the second - the device and technical aspects of the bot. <br><br>  At the end of the article are links where to download and how to set up our bot. <br><br>  So, what have we got? <br><br><h2>  User Authorization </h2><br>  First, in order for the user to work with the bot, it must be authorized. <br>  To do this, the user must have an active Redmine account. <br><br>  He needs to invent a <i>username</i> and register it in the settings of his Telegram account: <br><br><img src="https://habrastorage.org/webt/eq/rh/so/eqrhso8vxqti2qbdvvtsmm9tn1w.png"><br><br>  The same username must be entered in the settings of the Redmine-account in a special additional field ‚ÄúTelegram‚Äù: <br><br><img src="https://habrastorage.org/webt/ru/8g/4v/ru8g4vvmyezczvsczsywn6lcyj0.png"><br><br>  Next, the user finds a bot in the Telegram and presses Start.  The bot authorizes it and welcomes: <br><br><img src="https://habrastorage.org/webt/bb/ee/op/bbeeopyznw97kvqun-asv6g31zm.png"><br><br><h2>  Setting goals </h2><br>  In order to set a new task or add a comment to an existing task, it is enough just to write text to bot, and he will suggest options.  In this case, you can attach files to the message: <br><br><img src="https://habrastorage.org/webt/zr/rc/uz/zrrcuzrkykjfbgi6qms1mkkhhdq.png"><br><br>  A written comment can be added to the last active task, select a task from the list, create a new task based on it or do nothing and terminate the dialog. <br><br>  If you select the ‚ÄúAdd to the last task‚Äù item, the user's comment will be added to the task that was last answered.  Bot shows it above. <br><br>  If you select the ‚ÄúCreate a new task‚Äù item, the bot will switch to the new task creation mode: <br><br><img src="https://habrastorage.org/webt/3m/vm/uk/3mvmuk4oqq2y3lmuqpljw6knth0.png"><br><br>  And will offer the user: <br><br><ul><li>  Select a project (optional, if you are not satisfied with the default): </li></ul><br><br><img src="https://habrastorage.org/webt/3q/m7/hj/3qm7hj6fgmjzl36xzkwyjluyey8.png"><br><br><ul><li>  Specify the priority of the task (optional, if not satisfied with the default): </li></ul><br><img src="https://habrastorage.org/webt/1k/e2/ti/1ke2ti0nq8gvwb6qs20c4vd9g3q.png"><br><br>  The user can skip these steps, if he is satisfied with the default values, and immediately click "Create a task", you only need to specify the title for it: <br><br><img src="https://habrastorage.org/webt/vx/cz/-h/vxcz-hmaihjlogzfpzwmwkrj8_i.png"><br><br>  After this, the bot will notify the client about the creation of the task (the link to the task is clickable and, if necessary, you can immediately go to the ticket if necessary): <br><br><img src="https://habrastorage.org/webt/jm/tw/a0/jmtwa01eqtsnglxtlauoveerop0.png"><br><br>  Which in Redmine will look like this: <br><br><img src="https://habrastorage.org/webt/9e/xs/hj/9exshjeymwrrnkkq06b7fy0hm7c.png"><br><br>  If the user clicked on "Select task" - the bot will offer a list of currently open tasks to which you can send a written comment: <br><br><img src="https://habrastorage.org/webt/jp/g0/a0/jpg0a0pdtizrgvsjto8zenklsgc.png"><br><br>  At the same time, the user sees only those projects and tasks to which he is connected to Redmine.  This applies to all actions in the bot. <br><br><h2>  Correspondence on tasks </h2><br>  Bot supports the delivery of notifications of changes in tasks.  For example, our administrator completed the task and asks the client to check the result: <br><br><img src="https://habrastorage.org/webt/o7/b_/au/o7b_auxxakbgx_zvngi4z8ndcfi.png"><br><br>  Here is what the customer will get: <br><br><img src="https://habrastorage.org/webt/tt/cy/_e/ttcy_eifhh4kpkyrt2mpgs3iazy.png"><br><br>  You can respond to tasks through the Reply to the corresponding message in the Telegram.  This is especially convenient when work is being done on several tasks at once (the answer will fall right into the right ticket without additional questions): <br><br><img src="https://habrastorage.org/webt/tn/a2/rc/tna2rcwfmtyjm3sfsydgwt4ma54.png"><br><br>  Total.  The client created the task, communicated on it, and did all this through the Telegram.  He never had to go to the Redmine for this.  The employee received and processed the task in his usual form in Redmine, as part of standard business processes, he did not have to switch to the instant messenger, and then take care of transferring the correspondence to the task system. <br><br><h2>  Attachment support </h2><br>  In the bot, we implemented support attachments.  And it works in both directions.  You can attach anything: photos, documents, video and audio.  You can even attach stickers, though they look so-so in the browser, and it‚Äôs a pity, sometimes a well-chosen sticker extends the life of our entire office. <br><br>  Suppose a monitoring system reported a problem to us on one of the servers.  The administrator through Redmine created the task and attached a monitoring system schedule to it.  The client will receive the following message: <br><br><img src="https://habrastorage.org/webt/dl/mw/r9/dlmwr9xpq-mvacvktwtkvixnhm8.png"><br><br>  To which he can reply with a voice message: <br><br><img src="https://habrastorage.org/webt/ux/0y/gr/ux0ygrqh9jz8iq8lsqjkub6tkuc.png"><br><br>  The voice message will be delivered to the task and listened by the administrator. <br><br><h2>  Restrictions </h2><br>  Of course they are.  We encountered the following: <br><br><ol><li>  Long messages.  Telegram has a limit on the length of one message - 4096 characters.  Initially, long comments from Redmine were simply cut off.  I had to write a handler who broke long comments into parts.  And so that it was pleasing to the eye, that is, so that the commentary did not break strictly on the 4096 character in the middle of the word, and the splitting took place neatly, at the junction of the phrases.  For customers, the inconvenience is that in this case several messages will arrive. </li><li>  Formatting  Formatting in Redmine and Telegram are two different universes.  But it is understandable, and their purpose is somewhat different.  Redmine formatting is displayed in Telegram as service characters, and sometimes it is not very convenient to read.  So far we have not figured out how to display them in a normal form, but do not give up hope to eliminate this trouble.  From Telegram to Redmine, too, not everything is transferred.  For example, if the text contains certain emoticons, then having received such a message Redmine will simply cut it off.  These are features of the Redmine database structure.  We have some ideas for solving this problem and they work correctly on a test bench, but for now we are afraid to use them on a combat base. </li><li>  Names of images.  If in Telegram you make an attachment of an image (namely images), then the bot will receive a file with the name in the format file_xyz.jpg.  Accordingly, in Redmine it will fall with the same name.  Here we can not do anything yet, because the bot itself receives files with such names. </li><li>  The interface and all the bot messages are only in Russian, but in one of the upcoming versions we plan to add support for other languages. </li></ol><br><h2>  Usage statistics </h2><br>  A little more than two months have passed since launch.  First observations: <br><br><ol><li>  Currently, about 3.5% of tasks are created and updated by clients through a bot. </li><li>  As already mentioned above, the bot found application not only among clients, but also actively used by ourselves.  It is very convenient to receive notifications on tasks (arrive faster than in the mail) and immediately respond to them.  Feels like, with the launch of the bot, we have increased the speed of communication on internal tasks. </li></ol><br><h3>  Briefly about how our bot works </h3><br><ul><li> It is written in C. More precisely on our framework, which is written in C </li><li>  Uses two types of databases: Redis and MySQL </li><li>  We needed to write a plugin for Redmine, which would activate the hooks mechanism when creating tasks and comments </li><li>  Easy to replicate and scale. </li></ul><br>  So let's get started ... <br><br>  The basic scheme of the bot is as follows: <br><br><img src="https://habrastorage.org/webt/zu/cb/wl/zucbwlxsbmkyoxszhr_d24kmcz8.png"><br><br>  It seems to be nothing complicated - all changes to Redmine using hooks are delivered to the bot, he looks at the type of event, in which project it happened, determines the Telegram accounts of the recipients of this message and delivers them.  From the Telegram side, everything happens in a similar way - the type of the message is determined, to which task it belongs and is delivered to Redmine. <br><br>  Now let's add some action and get acquainted with some features of message delivery in Telegram! <br><br>  Telegram breaks large messages into smaller ones.  These messages come with some delay.  All attachments are delivered as separate messages and sometimes with a long delay (as they are downloaded by the user).  Those.  it‚Äôs just not possible to take and forward all received messages, otherwise we will spam users and spoil our karma. <br><br>  And what to do?  We decided to create a message queue for this and use Redis to store them.  Each incoming message our bot puts in a queue and updates the delay time for its processing.  When this delay has expired, we consider that the message has been completely formed and now you can choose a task and send it to Redmine. <br><br>  Next, the question arises: how to choose the desired task in Redmine?  After all, in order for the bot to understand what to do with the data received, he needs to ask the user about it, and this, anyway, is another message (even if it is a button click) and it must somehow be linked to the user's previous actions.  This session will help us. <br><br>  The first incoming message from the user's Telegram account generates a session that contains: <br><br><ul><li>  User ID with which the session is associated </li><li>  Session type (i.e., its state) </li><li>  Data you need to do something with </li></ul><br>  Each subsequent message from Telegram may either supplement the session with data, change its state (for example, start the process of further processing and delivery of data), or destroy the session (for example, if the user changed his mind to write his comment), or cause an error (for example the type of incoming data does not correspond to the current state of the session). <br><br>  Another important component of the bot is caching.  Our Redmine consists of a fairly large number of projects, users and some other data.  The bot often needs to access this data and if he goes to Redmine every time, this will lead to noticeable delays in processing requests. <br>  The bot has a separate process, which only deals with the fact that it periodically receives data from Redmine, which is required for other processes, and stores it in Redis. <br><br>  What about MySQL? <br><br>  It was noted above that, in addition to Redis, the bot also uses MySQL.  Of course, all data could be stored in Redis, but despite the presence of periodic dumps - the data is still stored in the memory and an unexpected system failure can lead to their loss, and among them there is very important information that needs to be treated especially reverently.  To better understand what is being said, let us recall the first part of the article.  It was said that the user can not only choose from the dialogue with the bot how to proceed with his message (create a new task or select an existing one), but also make an answer to the message.  And the bot must understand what task to add it to. <br><br>  In Telegram messages have identifiers that are not related to the task identifiers in Redmine.  In order to make friends with them, you need to establish some correspondence and decide how to store this data.  But before that, let's try to understand how this data is formed, what will happen if this data is lost, and based on this - understand their importance. <br><br>  Suppose a user writes his first message in a Telegram bot.  The bot opens the session and asks the user what task to add a comment to.  After the answer is received - the bot sends the data to Redmine and at the same time maintains this correspondence in itself. <br><br>  Further, when the user makes a reply to this message in the Telegram, the bot will receive the number of the ‚Äúparent‚Äù message and determine the number of the Redmine task to which the comment should be sent.  The described correspondence will also be established for this new message, i.e.  reply then you can do it.  The same is true for events coming from Redmine.  Our clients believe that this is a very convenient mechanism and, judging by the statistics, they use it very actively. <br><br>  Now let's imagine that all these matches we have lost.  Those.  The client habitually clicks the reply on the message that came to him from the administrator, writes his comment and sends it to the bot.  But since  the bot according to the described algorithm is no longer able to understand what task to send a comment, it will give an error message and ask additional questions in order to find out what to do next. <br><br>  Other important data types that cannot be lost (moreover, they cannot be lost even more than the first ones) are the Redmine and Telegram user IDs.  If this happens, users will simply stop receiving information about events occurring in Redmine until something is written to the bot.  And since  according to the polls, the bot is almost more often used as a notification agent (to replace the mail), then we can get even more trouble. <br><br>  In order not to upset users - put this data in a less fast, but more reliable MySQL. <br><br>  In fairness it should be noted that our team is still debating whether to abandon MySQL and transfer this data to Redis.  Therefore, it is possible that in the future we can fully switch to working with Redis, and maybe in general to some other data storage system.  Fortunately, the architecture of our application allows making such replacements relatively simple. <br><br><h4>  Scaling and failover </h4><br>  Now I would like to talk about how to ensure the scaling and resiliency of the bot ... <br><br>  With the advent of the bot, our Redmine in some cases turned into a chat and the intensity of messaging is constantly growing.  Some of our clients also want to integrate it in their infrastructure.  And considering that our development is completely open source - it‚Äôs not known what kind of company or administrative / developer team will want to use it and it‚Äôs not known what kind of bot will face.  Therefore, we are still at the stage of elaboration of the project laid in him the possibility of scaling. <br><br>  In our project, scaling can be divided into two classes: <br><br><ul><li>  Database Scaling <br>  Everything is fairly well known: <br><br><ul><li>  For MySQL, you can use Percona Cluster or analogues </li><li>  For Redis - Redis Cluster </li></ul></li><li>  Scaling the bot itself </li></ul><br>  To understand how to scale the bot - let's take a closer look at the process of receiving and processing messages. <br><br>  The concept is as follows: <br><br><img src="https://habrastorage.org/webt/0s/dp/4l/0sdp4lprsvm5dtrcwbb77_e1iii.png"><br><br>  The only task of the ‚ÄúRest API‚Äù process is to put a message received from a Redmine or Telegram into a queue (ra-queue) and expect the following.  This queue is constantly monitored by the processes of ‚ÄúQueue-workers‚Äù and when data appears in it, they are read. <br><br>  Messages from Redmine are immediately processed and sent to the desired users in the Telegram.  With events from Telegram all is more difficult.  Since  they cannot be immediately sent to the Redmine (the reasons are described above), then they are shifted to another queue already divided by users.  The type of message determines the time during which we are waiting for other messages.  Sooner or later, all these messages are read, undergo preliminary training, in one way or another they change the state of the session and can be sent to Redmine with all attached files that are downloaded from the Telegram at the same step. <br><br>  It is important to note here that, thanks to this approach and the existing locking mechanism, processing always takes place on one particular node.  This is what allows you to create as many bot instances and with as many ‚ÄúQueue-workers‚Äù processes as necessary within the existing load. <br><br>  When Redmine receives a message, the hook is triggered and the same message is sent back to the bot, after which it is delivered to the rest of the Telegram accounts subscribed to the task. <br><br>  Thus, the bot infrastructure in a distributed version can be represented as follows: <br><br><img src="https://habrastorage.org/webt/jn/hd/go/jnhdgoyzzcll_mn4oh_2xxy_kgk.png"><br><br>  But everything described in no way limits the ability to use the bot in the usual standalone version with one MySQL server and the usual non-cluster Redis option. <br><br><h3>  How to try the bot? </h3><br>  To demonstrate the work of the bot, we made a demo-version available at <a href="https://demo.nxs-chat.nixys.ru/">demo.nxs-chat.nixys.ru</a> . <br><br>  To try it in action - you must perform a few preliminary steps: <br><br><ul><li>  In <a href="https://demo.nxs-chat.nixys.ru/account/register">demo.nxs-chat.nixys.ru/account/register</a> register at least 2 accounts (to be able to correspond between them) and fill in the <i>Telegram</i> field for at least one of them </li><li>  Activate created accounts </li><li>  Find the <a href="https://t.me/nixys_demo_chat_bot">@nixys_demo_chat_bot</a> bot for each Telegram account specified during registration, and click the <b>Start</b> button. <br>  Make sure that the same usernames are set in the settings of the Telegram accounts as in the account settings in <a href="https://demo.nxs-chat.nixys.ru/">demo.nxs-chat.nixys.ru</a> </li><li>  Create a project in <a href="https://demo.nxs-chat.nixys.ru/projects/new">Redmine</a> and add to it created accounts in the role of "Project member" </li><li>  In the created project, add a task and start communication! </li></ul><br><br>  Important note!  The bot will send messages to Telegram in the following cases: <br><ul><li>  An account that is the author of the problem (provided that it is not the author of a specific comment) </li><li>  An account that is the executor of the task (provided that it is not the author of a specific comment) </li><li>  Accounts in the list of observers in the problem (provided that it is not the author of a specific comment) </li></ul><br><h3>  How to get a bot? </h3><br>  The bot is completely open and can be received both as source codes and as a package (packages are currently available only for Debian 8, but will soon appear for Debian 9 and CentOS 7). <br><br>  Link to the <a href="https://github.com/nixys/nxs-chat-srv">Github repository with bot source codes</a> .  There is also an instruction for installing a bot from packages and setting it up. <br><br><h3>  Conclusion </h3><br>  In the near future we plan to add the following functionality: <br><br><ul><li>  Simplify task creation </li><li>  Configure Notifications </li><li>  Multilingual interface </li><li>  Subscription to the tasks and unsubscribe from them through the bot (now it can be done only through Redmine) </li><li>  In the future, we plan to add voice recognition to the text, which will be very useful for the tasks that customers create with a voice </li><li>  And much more </li></ul></div><p>Source: <a href="https://habr.com/ru/post/347526/">https://habr.com/ru/post/347526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347516/index.html">Dynamic code analysis with Iroh.js</a></li>
<li><a href="../347518/index.html">Death of microservice madness in 2018</a></li>
<li><a href="../347520/index.html">The book "Programming for children. Learning to create websites, applications and games. HTML, CSS and JavaScript ¬ª</a></li>
<li><a href="../347522/index.html">Dependencies between SQL objects: use regular expressions and small algorithmic focus</a></li>
<li><a href="../347524/index.html">Major advances in natural language processing in 2017</a></li>
<li><a href="../347528/index.html">NLog extension for error monitoring</a></li>
<li><a href="../347530/index.html">Can a JavaScript construct (a == 1 && a == 2 && a == 3) be true?</a></li>
<li><a href="../347534/index.html">All the pain of p2p development</a></li>
<li><a href="../347536/index.html">Chromium: the sixth project check and 250 bugs</a></li>
<li><a href="../347538/index.html">MODx Revo workflow. Workflow organization, version control and deployment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>