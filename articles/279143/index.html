<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: setting normal maps in a tangent space</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We got the hands to write another addition to my brief course on computer graphics. So, the topic for the next conversation is the use of normal maps ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: setting normal maps in a tangent space</h1><div class="post__text post__text-html js-mediator-article">  We got the hands to write another addition to <a href="https://habrahabr.ru/post/249139/">my brief course on computer graphics.</a>  So, the topic for the next conversation is the use <a href="https://en.wikipedia.org/wiki/Normal_mapping">of normal maps</a> .  What is the main difference between using normal maps and Phong shading?  The main difference in the density of the job information.  To shade Phong, we used normal vectors defined at each vertex of our polygonal mesh, interpolating the normals inside the triangles.  Using the same normal maps allows you to specify normals for each point on our surface, and not only occasionally, which simply dramatically affects the image detail. <br><br>  In principle, in the <a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-6:-Shaders-for-the-software-renderer">lecture about shaders,</a> we have already used the normal map, but only the one specified in the global coordinate system.  Now the conversation will go about the <a href="https://en.wikipedia.org/wiki/Darboux_frame">tangent space</a> .  So, here are two textures, the left one is set in the global space (RGB directly turns into the XYZ vector), and the right one - in the tangent. <br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/nm_textures.jpg"><br><a name="habracut"></a><br>  To use the normal specified in the tangent space, for the pixel to be drawn, we calculate the tangent reper (Darperbou).  In this frame, one vector (z) is orthogonal to the surface, and the other two define a tangent plane to the surface.  Then we read the normal vector from the texture, and convert its coordinates from the newly calculated reference frame to the global one.  Since the normal map most often specifies only a small perturbation of the normal, the dominant color of the texture is blue. <br><br>  It would seem, why such difficulties?  Why not use a simple global rapper as before?  Imagine that we want to animate our model.  For example, I took our old friend Negro and opened his mouth to him.  Obviously, the modified surface must have other normals! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/global_vs_tangent.jpg"><br><br>  Here on the left is a model in which the mouth is open and the normal (global) map has not been changed.  Look at the mucous membrane of the lower lip.  The light beats right in the face, the model with the mouth closed mucous, of course, was not covered in any way.  The mouth opened, but it is still not illuminated ... The right-hand picture is calculated using the normal map given in the tangent space. <br><br>  So, if we have an animated model, then to set the normal map in the global space, we need one texture for each frame of the animation.  And since the tangent space naturally follows the surface, such a texture is enough for us alone! <br><br>  Here is a second example: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/global_vs_tangent_diablo.jpg"><br><br>  This is the texture for the Diablo model.  Note that only one hand is visible on the texture.  And only one half tail.  The artist used the same texture for the left and right hands, and the same texture for the left and right side of the tail.  (By the way, this is what prevented us from counting <a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-8:-Ambient-occlusion">ambient occlusion</a> .) And this means that in the global coordinate system I can specify normal vectors for either the left hand or the right hand.  But not for two at once! <br><br>  So, we end up with motivation and go directly to the calculations. <br><br><h1>  Phong shading starting point </h1><br>  So let's look at the <a href="https://github.com/ssloy/tinyrenderer/tree/e30ff353121460557e29dced5708652171dbc7d2">starting point</a> .  The shader is very simple, this is Phong shading. <br><br><pre><code class="hljs pgsql">struct Shader : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_uv; // triangle uv coordinates, written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the vertex shader, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the fragment shader mat&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_nrm; // normal per vertex <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be interpolated <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> FS virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert)); varying_nrm.set_col(nthvert, proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;((Projection*ModelView).invert_transpose()*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;normal(iface, nthvert), <span class="hljs-number"><span class="hljs-number">0.</span></span>f))); Vec4f gl_Vertex = Projection*ModelView*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); varying_tri.set_col(nthvert, gl_Vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gl_Vertex; } virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> fragment(Vec3f bar, TGAColor &amp;color) { Vec3f bn = (varying_nrm*bar).normalize(); Vec2f uv = varying_uv*bar; <span class="hljs-type"><span class="hljs-type">float</span></span> diff = std::max(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, bn*light_dir); color = model-&gt;diffuse(uv)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } };</code> </pre> <br>  Here is the result of the shader: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/starting_point_a.jpg"><br><br>  For ease of learning and debugging, I will remove the skin texture and apply the simplest <a href="">regular mesh</a> with horizontal red and vertical blue lines: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/starting_point_b.jpg"><br><br>  Let's take a look at how our Phong shader works using this image as an example: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/grid_texture.png"><br><br>  So, for each vertex of the triangle we have given its coordinates p, its textural coordinates uv and normal vectors to the vertices n.  To draw each pixel, the rasterizer gives us the barycentric pixel coordinates (alpha, beta, gamma).  This means that the current pixel has spatial coordinates p = alpha p0 + beta p1 + gamma p2.  We interpolate the texture coordinates in exactly the same way, then interpolate the normal vector: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f00.png"><br><br>  Notice that the red and blue lines are the isolines of u and v, respectively.  So, for each point of our surface, we have a Darboux bench mark, whose x axis is parallel to the red lines, the y axis is parallel to the blue, and z is orthogonal to the surface.  It is in this frame that the normal vectors are defined. <br><br><h1>  Calculate the linear function of its three points </h1><br>  So, our task is for each pixel to be drawn to count the top three vectors that define the Darboux frame.  Let us first distract and imagine that in our space a linear function f is defined, which assigns a real number f (x, y, z) = Ax + By + Cz + D to each point (x, y, z). The only thing we We do not know the numbers (A, B, C, D), but we know the value of the function at the vertices of a certain triangle (p0, p1, p2): <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f01.png"><br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/gradient_a.png"><br><br>  One can imagine that f is simply the height of a certain inclined plane.  We fix three different points on the plane and know the values ‚Äã‚Äãof the heights at these points.  The red lines on the triangle show the isolines of height: the isoline for height f0, for height f0 + 1 meter, f0 + 2 meters, etc.  For a linear function, all these isolines are obviously parallel lines. <br><br>  What we are interested in is not so much the direction of the isolines as the direction, orthogonal to them.  If we move along some contour line, then the height does not change (thanks, captain), if we deviate a little bit from the contour line, then the height begins to change, and the biggest change per unit height will be when we move in the direction orthogonal isolines. <br><br>  We recall that the direction of the fastest lifting for some function is nothing but its gradient.  For a linear function f (x, y, z) = Ax + By + Cz + D, its gradient is a constant vector (A, B, C).  It is logical that it is constant, since any point of the plane is tilted equally.  I remind you that we do not know the numbers (A, B, C).  We only know the value of our function at three different points.  Can we recover A, B and C?  Of course. <br><br>  So, we have three points p0, p1, p2 and three values ‚Äã‚Äãof the function f0, f1, f2.  We are interested in finding a vector (A, B, C) that gives the direction of the fastest growth of the function f.  Let's consider, for convenience, the function g (p), which is given by g (p) = f (p) - f (p0): <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/gradient_b.png"><br><br>  Obviously, we simply moved our inclined plane, without changing its inclination, so the direction of the fastest growth for g will coincide with the direction of the fastest growth of f. <br><br>  Let's rewrite the definition of g: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f02.png"><br><br>  Notice that the superscript p ^ x is the x coordinate of the point p, not a power.  That is, the function g is only the scalar product of the vector connecting the current point p with the point p0 and the vector (A, B, C).  But we still do not know (A, B, C)!  Not scary, now we find them. <br><br>  So what do we know?  We know that if from the point p0 we go to p2, then the function g will be equal to f2-f0.  In other words, the scalar product between the vectors p2-p0 and ABC is f2-f0.  The same for dot (p1-p0, ABC) = f1-f0.  That is, we are looking for a vector (ABC), which is simultaneously orthogonal to the normal to the triangle and has these two restrictions on scalar products: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f03.png"><br><br>  We write the same in matrix form: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f04.png"><br><br>  That is, we have obtained the matrix equation Ax = b, which is easily solved: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f05.png"><br><br>  Notice that I used letter A in two ways, the meaning should be clear from the context.  That is, our 3x3 matrix A multiplied by the unknown vector x = (A, B, C) gives the vector b = (f1-f0, f2-f0, 0).  The unknown vector is found by multiplying the inverse of A by the vector b. <br><br>  Note that there is nothing in the matrix A that depends on the function f!  It contains only information about the geometry of the triangle. <br><br><h1>  We calculate the Darboux frame and apply the normal map (perturbations) </h1><br>  Total, Darboux frame is a triplet of vectors (i, j, n), where n is the normal vector, and i and j can be calculated as follows: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/f06.png"><br><br>  <a href="https://github.com/ssloy/tinyrenderer/tree/907bb561c38e7bd86db8d99678c0108f2e53d54d">Here is the final code</a> that uses normal maps defined in the tangent space, and <a href="https://github.com/ssloy/tinyrenderer/commit/907bb561c38e7bd86db8d99678c0108f2e53d54d">here</a> you can find changes in the code compared to Phong tinting. <br><br>  Everything is pretty straightforward, I calculate the matrix A: <br><br><pre> <code class="hljs objectivec"> mat&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; A; A[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ndc_tri.col(<span class="hljs-number"><span class="hljs-number">1</span></span>) - ndc_tri.col(<span class="hljs-number"><span class="hljs-number">0</span></span>); A[<span class="hljs-number"><span class="hljs-number">1</span></span>] = ndc_tri.col(<span class="hljs-number"><span class="hljs-number">2</span></span>) - ndc_tri.col(<span class="hljs-number"><span class="hljs-number">0</span></span>); A[<span class="hljs-number"><span class="hljs-number">2</span></span>] = bn;</code> </pre> <br>  Then I compute Darboux vector: <br><br><pre> <code class="hljs markdown"> mat<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">3,3,float</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> AI = A.invert(); Vec3f i = AI <span class="hljs-bullet"><span class="hljs-bullet">* Vec3f(varying_uv[0][1] - varying_uv[0][0], varying_uv[0][2] - varying_uv[0][0], 0); Vec3f j = AI *</span></span> Vec3f(varying<span class="hljs-emphasis"><span class="hljs-emphasis">_uv[1][1] - varying_</span></span>uv[<span class="hljs-string"><span class="hljs-string">1</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0</span></span>], varying<span class="hljs-emphasis"><span class="hljs-emphasis">_uv[1][2] - varying_</span></span>uv[<span class="hljs-string"><span class="hljs-string">1</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0</span></span>], 0);</code> </pre> <br>  Well, once I have calculated them, I read the normal from the texture, and do the simplest transformation of coordinates from the Darboux reference point into the global reference. <br>  If that, then <a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-5:-Moving-the-camera">I already described</a> transformations of coordinates. <br><br>  Here is the final render, compare the details with <a href="">Phong's tint</a> : <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06b-tangent-space/normalmapping.jpg"><br><br><h1>  Debugging advice </h1><br>  It's time to remember <a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%25E2%2580%2599s-Line-Drawing-Algorithm">how the lines are drawn</a> .  Overlay the model with a regular red-blue grid and for all vertices draw the resulting vectors (i, j), they should match well with the direction of the red-blue texture lines. <br><br>  Happy coding! <br><br><div class="spoiler">  <b class="spoiler_title">How attentive were you?</b> <div class="spoiler_text">  Did you notice that in general the (flat) triangle has a normal vector constant, and I used the interpolated normal in the last row of the matrix A?  Why did I do that? <br><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/279143/">https://habr.com/ru/post/279143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279125/index.html">Dagger 2. Part One. Basics, creating a dependency graph, Scopes</a></li>
<li><a href="../279127/index.html">Nutanix Big Update: NutanixOS 4.6</a></li>
<li><a href="../279129/index.html">On the issue of errors</a></li>
<li><a href="../279133/index.html">The digest of interesting materials for the mobile developer # 144 (on March 9-13)</a></li>
<li><a href="../279139/index.html">We invite everyone to the first hackathon in the history of the Stavropol Territory</a></li>
<li><a href="../279145/index.html">VKontakte launches the third VK Cup championship</a></li>
<li><a href="../279147/index.html">1.4 SFML and Xcode (Mac OS X)</a></li>
<li><a href="../279149/index.html">C ++ exception handling under the hood. Part 3</a></li>
<li><a href="../279151/index.html">C ++ exception handling under the hood. Part 2</a></li>
<li><a href="../279155/index.html">MySQL JSON data type decoding</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>