<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 5.7 - HDR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing to the framebuffer, the brightness values ‚Äã‚Äãof the colors are reduced to the interval from 0.0 to 1.0. Because of this, at first glance i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 5.7 - HDR</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/20f/e6a/5f3/20fe6a5f38cfacad9ea8355ca097e8f4.png" width="200" align="left"><br><p>  When writing to the framebuffer, the brightness values ‚Äã‚Äãof the colors are reduced to the interval from 0.0 to 1.0.  Because of this, at first glance innocuous, features, we always have to choose such values ‚Äã‚Äãfor lighting and colors so that they fit into this restriction.  This approach works and gives decent results, but what happens if we find a particularly bright area with a large number of bright light sources, and the total brightness exceeds 1.0?  As a result, all values ‚Äã‚Äãgreater than 1.0 will be reduced to 1.0, which does not look very nice: </p><br><p><img src="https://habrastorage.org/webt/cd/0m/ir/cd0mir8t9qcbakfwldnjibj3ay0.png"></p><br><p>  Since for a large number of fragments the color values ‚Äã‚Äãare reduced to 1.0, large image areas are obtained, filled with the same white color, a significant amount of image detail is lost, and the image itself begins to look unnatural. </p><br><p>  The solution to this problem may be to reduce the brightness of the light sources so that there are no fragments brighter than 1.0 on the stage: this is not the best solution forcing the use of unrealistic lighting values.  The best approach is to allow brightness values ‚Äã‚Äãto temporarily exceed 1.0 brightness and at the final step change colors so that brightness returns to the range from 0.0 to 1.0, but without losing image details. </p><br><p>  The computer display is able to show colors with a brightness in the range from 0.0 to 1.0, but we have no such limitation when calculating the lighting.  By allowing the fragment colors to be brighter than one, we get a much higher brightness range for work - HDR <em>(high dynamic range)</em> .  With hdr, bright things look bright, dark things can be really dark, and at the same time we'll see the details. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><p>  Part 1. Start <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2. Basic lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br><p>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br><p>  Part 4. OpenGL advanced features <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br><p>  Part 5. Advanced Lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li><li>  <a href="https://habr.com/post/415579/">Normal mapping</a> </li><li>  <a href="https://habr.com/post/416163/">Parallax mapping</a> </li><li>  Hdr </li></ol></div></div><br><p>  Initially, high dynamic range was used in photography: the photographer made several identical photographs of the scene with different exposures, capturing colors of almost any brightness.  The combination of these photographs forms an hdr image in which most of the details become visible due to the mixing of images with different exposure levels.  For example, below in the left image you can see well-lit parts of the image (look at the window), but these details disappear when using high exposure.  However, high exposure makes the details visible in dark areas of the image that were not visible before. </p><br><p><img src="https://habrastorage.org/webt/hh/-0/0h/hh-00hpoeday-yolbntasroul14.png"></p><br><p>  This is similar to how the human eye works.  With a lack of light, the eye adapts, so that dark details become well distinguishable, and likewise for bright areas.  We can say that the human eye has an automatic exposure setting, depending on the brightness of the scene. </p><br><p>  HDR rendering works much the same.  When rendering, we allow a large range of brightness values ‚Äã‚Äãto collect information about bright and dark details of the scene, and at the end we convert the values ‚Äã‚Äãfrom the HDR range back to LDR (low dynamic range, range from 0 to 1).  This transformation is called <em>tone mapping</em> , there are a large number of algorithms aimed at preserving most of the image details when converting to LDR.  These algorithms often have an exposure parameter that allows you to better show bright or dark areas of the image. </p><br><p>  Using HDR when rendering will allow us not only to exceed the LDR range from 0 to 1 and to keep more image details, but also makes it possible to indicate the actual brightness of the light sources.  For example, the sun has a much greater brightness of the light than something like a flashlight, so why not adjust the sun like this (for example, assign it a brightness of 10.0)?  This will allow us to better adjust the scene lighting with more realistic brightness settings, which would be impossible with LDR rendering and a brightness range from 0 to 1. </p><br><p>  Since the display only shows brightness from 0 to 1, we are forced to convert the used HDR value range back to the monitor range.  Simply scaling the range will not be a good solution, as bright areas will begin to dominate the image.  However, we can use different equations or curves to convert HDR values ‚Äã‚Äãto LDR, which will give us full control over the brightness of the scene.  This transformation is called <em>tone mapping</em> and is the final step in HDR rendering. </p><br><h3 id="freymbufery-s-plavayuschey-tochkoy">  Floating point framebuffers </h3><br><p>  To implement HDR rendering, we need a way to prevent the conversion of values ‚Äã‚Äãto the range from 0 to 1 of the results of the fragment shader.  If the framebuffer uses the normalized fixed-point format (GL_RGB) for color buffers, OpenGL automatically limits the values ‚Äã‚Äãbefore saving to the framebuffer.  This restriction applies to most framebuffer formats other than floating point formats. </p><br><p> To store values ‚Äã‚Äãoutside the [0.0..1.0] range, we can use a color buffer with the following formats: <code>GL_RGB16F, GL_RGBA16F, GL_RGB32F or GL_RGBA32F</code> .  This is great for hdr rendering.  Such a buffer will be called a floating point framebuffer. </p><br><p>  Creating a floating point buffer differs from a regular buffer only in that it uses a different internal format: </p><br><pre> <code class="hljs lisp">glBindTexture(<span class="hljs-name"><span class="hljs-name">GL_TEXTURE_2D</span></span>, colorBuffer)<span class="hljs-comment"><span class="hljs-comment">; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);</span></span></code> </pre> <br><p>  OpenGL framebuffer by default uses only 8 bits to store each color.  In floating point framebuffer with <code>GL_RGB32F</code> or <code>GL_RGBA32F</code> formats, 32 bits are used to store each color - 4 times more.  If very high accuracy is not required, the <code>GL_RGBA16F</code> format will be <code>GL_RGBA16F</code> . </p><br><p>  If a floating point buffer for color is attached to the framebuffer, we can render the scene into it taking into account that the color values ‚Äã‚Äãwill not be limited to the range from 0 to 1. In the code for this article, we first render the scene at floating point framebuffer and then output the contents color buffer to half-screen rectangle.  It looks like this: </p><br><pre> <code class="hljs lisp">glBindFramebuffer(<span class="hljs-name"><span class="hljs-name">GL_FRAMEBUFFER</span></span>, hdrFBO)<span class="hljs-comment"><span class="hljs-comment">; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // [...]    hdr glBindFramebuffer(GL_FRAMEBUFFER, 0); //  hdr    2     hdrShader.use(); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, hdrColorBufferTexture); RenderQuad();</span></span></code> </pre> <br><p>  Here, the color values ‚Äã‚Äãcontained in the color buffer may be greater than 1. For this article, a scene was created with a large elongated cube that looks like a tunnel with four point light sources, one of which is located at the end of the tunnel and has an enormous brightness. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">std</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vector</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vec3</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightColors</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightColors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.push_back</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vec3(200.0f</span></span>, 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>, 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightColors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.push_back</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vec3(0.1f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightColors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.push_back</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vec3(0.0f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.2f</span></span>)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightColors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.push_back</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::vec3(0.0f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.1f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>));</code> </pre> <br><p>  Rendering to a floating point buffer is exactly the same as if we were rendering the scene in a regular framebuffer.  New is only a fragmentary hdr shader, which is engaged in a simple fill of a full-screen rectangle with values ‚Äã‚Äãfrom the texture, which is a floating-point color buffer.  To begin with, we will write a simple shader that sends input data unchanged: </p><br><pre> <code class="hljs vbscript">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 FragColor; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 TexCoords; uniform sampler2D hdrBuffer; void main() { vec3 hdrColor = texture(hdrBuffer, TexCoords).<span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>; FragColor = vec4(hdrColor, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  We take the input data from the floating point color buffer and use it as the output shader values.  However, since the 2D rectangle is rendered into the default framebuffer, the output values ‚Äã‚Äãof the shader will be limited to an interval from 0 to 1, despite the fact that in some places the values ‚Äã‚Äãare greater than 1. </p><br><p><img src="https://habrastorage.org/webt/rw/mb/ds/rwmbdsi_qc8fjdssulhqwwzk3rg.png"></p><br><p>  It becomes obvious that too large color values ‚Äã‚Äãat the end of the tunnel are limited to one, since much of the image is completely white, and we lose image details that are brighter than one.  Since we use HDR values ‚Äã‚Äãdirectly as LDR, this is equivalent to the absence of HDR.  To fix this, we need to display different color values ‚Äã‚Äãback into the range from 0 to 1 without losing any image detail.  For this, apply tonal compression. </p><br><h3 id="tonalnaya-kompressiya">  Tonal compression </h3><br><p>  Tonal compression - converting color values ‚Äã‚Äãto fit in the range from 0 to 1 without losing image detail, often in combination with giving the image the desired white balance. </p><br><p>  The simplest tone compression algorithm is known as the <em>Reinhard tone mapping</em> algorithm.  It displays any HDR values ‚Äã‚Äãin the LDR range.  Add this algorithm to the previous fragment shader, as well as apply gamma correction (and using SRGB textures). </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gamma = <span class="hljs-number"><span class="hljs-number">2.2</span></span>; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; <span class="hljs-comment"><span class="hljs-comment">//   vec3 mapped = hdrColor / (hdrColor + vec3(1.0)); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</span></span></code> </pre> <br><blockquote>  Note  per.  - for small values ‚Äã‚Äãof x, the function x / (1 + x) behaves approximately as x, for large x it tends to unity.  Function graph: </blockquote><p><img src="https://habrastorage.org/webt/sz/oq/ao/szoqaojobtfzh5_m5htgu_nh2_y.png"></p><br><p>  With Reinhard tonal compression, we no longer lose detail in bright areas of the image.  The algorithm favors bright areas, making dark areas less distinct. </p><br><p><img src="https://habrastorage.org/webt/jm/um/3c/jmum3cplqvaaqwhh96nzrrlhuc4.png"></p><br><p>  Here you can again see such details at the end of the image, like wood texture.  With this relatively simple algorithm, we can clearly see any colors from the HDR range and can control the lighting of the scene without losing image detail. </p><br><blockquote>  It is worth noting that we can use tonal compression directly at the end of our shader to calculate the lighting, and then we will not need a floating point framebuffer at all.  However, on more complex scenes, you will often encounter the need to store intermediate HDR values ‚Äã‚Äãin floating point buffers, so this will be useful to you. </blockquote><p>  Another interesting feature of tone compression is the use of the exposure parameter.  You may remember that in the images at the beginning of the article different details were visible at different exposure values.  If we have a scene where day and night take turns, it makes sense to use low exposure by day and high at night, which is similar to the adaptation of the human eye.  With this exposure parameter, we will be able to adjust the lighting parameters that will work both day and night under different lighting conditions. </p><br><p>  A relatively simple algorithm of tone compression with exposure looks like this: </p><br><pre> <code class="hljs cs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> exposure; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gamma = <span class="hljs-number"><span class="hljs-number">2.2</span></span>; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; <span class="hljs-comment"><span class="hljs-comment">//     vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</span></span></code> </pre> <br><blockquote>  Note  lane: add a graph for this function with exposure 1 and 2: </blockquote><p><img src="https://habrastorage.org/webt/3j/fj/zi/3jfjzibpldumgonxyhin6ydi-ao.png"></p><br><p>  Here we defined a variable for the exposure, which is equal to 1 by default and allows us to more precisely choose the balance between the display quality of dark and bright areas of the image.  For example, with a large exposure, we see significantly more details on dark areas of the image.  Conversely, a small exposure makes the dark areas indistinguishable, but allows you to better see the bright areas of the image.  Below are images of a tunnel with different exposure levels. </p><br><p><img src="https://habrastorage.org/webt/ae/kx/vf/aekxvfxdggv34kzeqcoxy9tjdps.png"></p><br><p>  These images clearly show the advantages of hdr rendering.  When the exposure level changes, we see more scene details that would have been lost during normal rendering.  Take for example the end of the tunnel - with normal exposure, the texture of the tree is barely visible, but at low exposure the texture is perfectly visible.  Similarly, with high exposure, details are clearly visible in dark areas. </p><br><p>  The source code for the demo is <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/6.hdr/hdr.cpp">here.</a> </p><br><h3 id="bolshe-hdr">  More HDR </h3><br><p>  The two tone compression algorithms that have been shown are only a small part among a large number of more advanced algorithms, each of which has its own strengths and weaknesses.  Some algorithms better emphasize certain colors / brightness, some algorithms show both dark and bright areas, producing more colorful and detailed images.  There are also many ways, known as <em>automatic exposure adjustment (automatic exposure adjustment)</em> or eye adaptation <em>(eye adaptation)</em> .  They determine the brightness of the scene in the previous frame and (slowly) change the exposure parameter, so that the dark scene slowly becomes brighter and bright - darker: similar to the addiction of the human eye. </p><br><p>  The real advantages of HDR are best seen on large and complex scenes with serious lighting algorithms.  For the purposes of teaching, this article used the simplest scene possible, since creating a large scene can be difficult.  Despite the simplicity of the scene, some of the advantages of hdr rendering are visible: in dark and light areas of the image, details are not lost, as they are preserved by tonal compression, adding multiple light sources does not result in white areas, and the values ‚Äã‚Äãdo not have to fit in LDR range. </p><br><p>  Moreover, HDR rendering also makes some interesting effects more believable and realistic.  One such effect is bloom, which we will discuss in the next <a href="https://learnopengl.com/Advanced-Lighting/Bloom">article</a> . </p><br><h3 id="dopolnitelnye-resursy">  Additional resources: </h3><br><ul><li>  A stackexchange question with an excellent long answer, which describes some of the benefits of HDR rendering: <a href="http://gamedev.stackexchange.com/questions/62836/does-hdr-rendering-have-any-benefits-if-bloom-wont-be-applied">does bloom not be applied?</a> </li><li>  Another interesting answer with good images as examples of tone mapping.  <a href="http://photo.stackexchange.com/questions/7630/what-is-tone-mapping-how-does-it-relate-to-hdr">What is tone mapping?</a>  <a href="http://photo.stackexchange.com/questions/7630/what-is-tone-mapping-how-does-it-relate-to-hdr">How does it relate to HDR?</a> </li></ul><br><p>  <strong>PS</strong> We have a <a href="https://t.me/joinchat/Cpb05A46UPpMWdNVVCb4Vg">telegram-konf</a> to coordinate transfers.  If there is a serious desire to help with the translation, then you are welcome! </p></div><p>Source: <a href="https://habr.com/ru/post/420409/">https://habr.com/ru/post/420409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420393/index.html">PHP, YII2 and the formation of large excel-files</a></li>
<li><a href="../420395/index.html">‚ÄúFree‚Äù plates for prisoners are not free</a></li>
<li><a href="../420397/index.html">Scientists have found a way to reverse cell aging</a></li>
<li><a href="../420405/index.html">Research IT-sales process</a></li>
<li><a href="../420407/index.html">C is not a low-level language.</a></li>
<li><a href="../420413/index.html">SQLite and NW.js - step by step instructions for creating a strong friendship</a></li>
<li><a href="../420415/index.html">Everything you wanted to know about testing Wi-Fi adapters, but were afraid to ask</a></li>
<li><a href="../420419/index.html">Runners for those who love humiliation or how we changed and modified PixJam</a></li>
<li><a href="../420423/index.html">Ground transition interface problems</a></li>
<li><a href="../420425/index.html">Theory and practice of using HBase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>