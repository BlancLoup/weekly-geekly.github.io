<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the VIPER architecture using the example of a small iOS application on Swift 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Everyone has their own VIPER." author unknown  In this article I would like to look at the VIPER architecture with a small concrete example, which at...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the VIPER architecture using the example of a small iOS application on Swift 4</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  "Everyone has their own VIPER."  <i>author unknown</i> </blockquote>  In this article I would like to look at the VIPER architecture with a small concrete example, which at the same time showed the full power of this architecture and was written in the latest <i>Swift 4</i> .  For those who want to immediately look at the code without reading the entire article, the link to the rep is at the bottom. <br><br><img src="https://habrastorage.org/webt/s6/pq/m1/s6pqm1b7m1cus4abpufcmjphlz0.jpeg"><br><a name="habracut"></a><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habr.com/ru/post/358412/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/358412/">Chapter 0. VIPER Architecture Diagram</a> </li><li>  <a href="https://habr.com/ru/post/358412/">Chapter 1. An example of a very simple module.</a> </li><li>  <a href="https://habr.com/ru/post/358412/">Chapter 2. An example of a more complex module</a> </li><li>  <a href="https://habr.com/ru/post/358412/">Conclusion</a> </li><li>  <a href="https://habr.com/ru/post/358412/">Repository link</a> </li></ul><br><a name="intro"></a><br><h2>  Introduction </h2><br>  About <a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework">VIPER</a> architecture has already been written quite a <a href="https://www.objc.io/issues/13-architecture/viper/">lot</a> , including on the habr ( <a href="https://habr.com/post/273061/">1</a> , <a href="https://habr.com/post/321590/">2</a> ).  <s>Therefore, I decided to keep up with others and write another ‚Äúuseful‚Äù manual.</s>  It all started with the fact that Apple <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html">MVC</a> architecture was not very successful, as described in more detail in <a href="https://habr.com/company/badoo/blog/281162/">this article</a> .  In short, the <i>MVC</i> turned into a <b>Massive View Controller</b> , i.e.  a huge view controller in which he was allowed a lot.  It had a lot of <i>UI</i> and business logic, and, as a result, such code was almost impossible to test, debug, and maintain. <br><br>  Therefore, developers needed a different architecture that would be more or less flexible, consistent with the <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID</a> principles (especially the ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D1%2582%25D0%25B2%25D0%25B5%25D1%2582%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Only Responsibility Principle</a> ‚Äù) and <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">pure architecture</a> ( <a href="https://habr.com/company/mobileup/blog/335382/">review in Russian</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://rambler-co.ru/">Rambler</a> picked up this topic and devoted an entire <a href="https://www.youtube.com/watch%3Fv%3Dzjw6Md1mMjQ%26list%3DPL7JJcdGH5aCGwJqbxaXERUHnfVkRLcIiN">conference to it</a> and even wrote a <a href="https://github.com/strongself/The-Book-of-VIPER">book</a> .  By the way, if you are not familiar with VIPER, I would recommend reading this particular book as familiarity with architecture.  It is well described and chewed, what this VIPER is for and how it appeared.  The book also addresses the problems of the classic VIPER, and that the Rambler developers have changed a bit in it.  Unfortunately, the book was written in 2016 and there are examples in it on <i>Objective-C</i> , like their open source <a href="https://github.com/rambler-digital-solutions/rambler-it-ios">project</a> , which at the time of this writing was not compiled and seemed to be too complicated for the first study.  The project is hung with many additional pieces, excessive abstraction and too many classes.  What at first glance may seem too complicated and repulsive. <br><br>  Therefore, I wrote a small application " <b>Currency Converter</b> " on VIPER architecture to show what needs to be written in each layer and what rules are set for each layer.  Immediately it should be said that I used not so-called.  classic VIPER, and its slightly modified version, inspired by the experience of Rambler and by their example. <br><br>  I will ask you not to find fault with much if you could write something more elegantly on <i>Swift</i> .  All the same article about the architecture, and not about the beauty of the <i>Swift</i> .  Also, I intentionally did not use third-party libraries and dependencies.  The entire example is written using only native <i>iOS</i> libraries. <br><a name="chapter0"></a><br><br><h2>  Chapter 0. VIPER Architecture Diagram </h2><br>  Let's run through the principles of VIPER.  One screen or more precisely one view controller should correspond to one module in the VIPER.  If in general, then VIPER is designed to split the multi-track view controller into multiple layers, where everyone will fulfill their role.  The connection inside the module is schematically shown in the figure below. <br><br><img src="https://habrastorage.org/webt/hq/zy/cf/hqzycfexvow0y3tvihtwgqllz-u.jpeg"><br><br>  You probably saw other schemes. <br><br><div class="spoiler">  <b class="spoiler_title">This, for example:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/66d/c26/871/66dc2687102a4df1aff7296d9321b476.png"></div></div><br>  Each letter from the VIPER abbreviation on it indicates something: <b>V</b> iew ‚Äì <b>I</b> nteractor ‚Äì <b>P</b> resenter ‚Äì <b>E</b> ntity ‚Äì <b>R</b> outer.  But the reality is that the module includes not only these components, but Entity in general may not include the concept of a module, since  is a self-sufficient class that can be used in any module or service.  On complex screens, the module can be divided into submodules, where everyone will have their own presenters and interacators. <br><br>  Unlike the classic VIPER, there is no <i>Wireframe</i> in mine, because it performed 2 roles: it assembled the module and made the transition to another screen (module).  The diagram shows that the <i>Configurator</i> will be responsible for assembling the module and Routers for the transitions.  I adopted this logic from Rambler, with the only difference that instead of the <i>Configurator,</i> they have an <i>Assembly</i> .  But the essence is the same. <br><br>  <i>The configurator is</i> aware of all dependencies within the module.  It establishes that the <i>ViewController</i> has a <i>Presenter</i> , the <i>Presenter</i> has an <i>Interactor,</i> and so on.  More will be discussed further in the example. <br><br>  Also in the classic VIPER abandoned <i>Segue</i> , so you can not use storyboards to navigate between screens.  In our case, as with Rambler, the <i>Segue</i> transitions work and are recommended for use, as Apple wanted. <br><br>  It so happens that a 100% passive <i>View</i> from the view controller will not work.  Apple itself laid a certain role for it with its life cycle and the methods it <i>calls</i> ( <i>viewDidLoad</i> , <i>viewDidAppear</i> , etc.), so we have to take this into account and build our architecture based on this.  Module assembly is launched from <b>viewDidLoad</b> , when the view controller has already loaded, and not just initialized.  It also gives us the opportunity to set the <b>Initial View Controller</b> from a storyboard, and not in <i>AppDelegate</i> , as it is done in the classic version.  This is much more convenient, because there is no tight binding to a particular entry point, and it can be easily changed. <br><br>  After the module is assembled, the further behavior of the module is rather classic.  <i>View / ViewController is</i> not responsible for the logic of clicking on buttons, entering text or any other interaction with the <i>UI</i> .  All this is immediately transferred to the <i>Presenter</i> .  <i>View</i> can be as part of a module, or be a general <i>View</i> , and used in different modules. <br><br>  <i>Presenter</i> decides whether to redirect the action - to <i>Router</i> or <i>Interactor</i> .  <i>Router</i> will either close the current screen or open a new one.  The concrete implementation of the transition is carried out in it.  <i>Interactor</i> decides what to do next with the received events and what service to call.  It contains the module logic. <br><br>  But the more important <i>Presenter</i> function is the preparation and transmission of visual data for the <i>View / ViewController</i> , which will be visible to the user.  <i>Presenter</i> is the heart of our module, it knows what data will be displayed and in what form.  Even in different schemes, it is always in the middle.  (And <i>Interactor</i> , probably, brains) <br><br>  <i>Interactor</i> is a <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D1%2581%25D0%25B0%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">facade</a> for other services.  <i>Interactor</i> can also contain logic itself.  In <i>MVC,</i> it can be compared to a controller, but which knows nothing about how the data will be displayed. <br><br>  The service in our interpretation refers to various helpers and other classes that can be accessed from different modules and parts of the application (authorization logic, work with the database, work with the server, encryption, etc.).  Services can interact with each other and with <i>Entity</i> .  <i>Entity</i> is just passive entities (user, book, word).  As mentioned earlier, <i>Entity is</i> not a component of the VIPER module.  In general, the architecture was originally called <b>VIP</b> . <br><br>  If you do not understand, it does not matter.  Further on, everything will become clear, it was only a superficial description. <br><a name="chapter1"></a><br><br><h2>  Chapter 1. An example of a very simple module. </h2><br><img src="https://habrastorage.org/webt/g5/fk/9b/g5fk9bjhypd3jssfxsvot3pxhzg.jpeg" align="right">  Strangely enough, I‚Äôll start to look at the architecture not from the first more complex screen, but from the <i>‚ÄúAbout Application‚Äù</i> screen, which is very simple.  The screen itself has a couple of labels, a <i>‚ÄúClose‚Äù</i> button and a button with a link to the site.  Clicking on <i>‚ÄúClose‚Äù</i> will close the current screen and the previous main screen will be shown, and when you click on the link, it will open in Safari.  The labels are passive and do not change. <br><br>  Such screens in the application do not show all the power and necessity of VIPER, because everything could be placed in the <i>ViewController</i> , as some might think.  But the ideology of pure architecture contradicts this principle; therefore, even the simplest screen and even the simplest application can and should be written on the VIPER architecture.  You must adhere to the rules always. <br><br>  Module names should preferably be short, because within the module for classes additional words will be added to this name.  For example, the <i>‚ÄúAbout Application‚Äù</i> module is called <b>About</b> .  The view controller will be called <i>AboutViewController</i> .  The remaining classes are <i>AboutPresenter</i> , <i>AboutInteractor</i> , <i>AboutConfigurator</i> , etc. <br><br>  If module initialization begins with a view controller, then the module should be considered starting from it.  Create the <i>AboutViewController</i> and <i>AboutConfigurator classes</i> .  The <i>AboutConfigurator</i> class must comply with the <i>AboutConfiguratorProtocol</i> protocol and will have only one method: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutConfiguratorProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with viewController: AboutViewController)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutConfigurator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutConfiguratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with viewController: AboutViewController)</span></span></span></span> { } }</code> </pre> <br>  In the future, inside this method, I will configure the module.  <i>AboutViewController</i> will have a <i>configurator</i> property, which will be configured in <b>viewDidLoad</b> , and a <i>presenter</i> property, which will comply with the <i>AboutPresenterProtocol</i> protocol. <br><br>  <b>Important rule!</b>  <b>All components communicate with each other only through protocols, and not directly!</b>  This is necessary to write unit tests in the future and to keep the code clean as a whole. <br><br>  <i>AboutPresenterProtocol</i> must contain the <b>configureView ()</b> method, which will initialize and configure the initial data for the visual elements in the view controller.  At this stage, <i>AboutViewController</i> will look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">AboutPresenterProtocol!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configurator: <span class="hljs-type"><span class="hljs-type">AboutConfiguratorProtocol</span></span> = <span class="hljs-type"><span class="hljs-type">AboutConfigurator</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() configurator.configure(with: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) presenter.configureView() } }</code> </pre> <br>  <i>Presenter</i> will also have a <i>router</i> and methods that will be called when you click on the <i>"Close"</i> button and a button with a link to the site.  <i>AboutPresenterProtocol</i> will look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutPresenterProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> router: <span class="hljs-type"><span class="hljs-type">AboutRouterProtocol!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String?)</span></span></span></span> }</code> </pre> <br>  This module is very simple, so the entire configuration of the view controller will be that the label for the button with the <i>URL</i> will be installed from the code, and not from the visual editor.  For <i>AboutViewController</i> such a protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutViewProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUrlButtonTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with title: String)</span></span></span></span> }</code> </pre> <br>  Inside the <i>AboutPresenter we</i> implement the method: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { view.setUrlButtonTitle(with: interactor.urlRatesSource) }</code> </pre> <br>  Now the turn came and interaktora.  Logic and data storage / retrieval should always be transferred there.  In our case, the interactor will have a property that will store the <i>URL of the</i> site and the method that will open this <i>URL</i> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutInteractorProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlRatesSource: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String)</span></span></span></span> }</code> </pre> <br>  But what about handling the event of clicking on the <i>"Close"</i> button, you might think?  Here the presenter decides that this event is connected with the transition between the screens, so the processing will be transmitted to the router.  For this module, the router can only close the current view controller. <br><br>  His protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutRouterProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeCurrentViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br>  A protocol presenter will look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutPresenterProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> router: <span class="hljs-type"><span class="hljs-type">AboutRouterProtocol!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String?)</span></span></span></span> }</code> </pre> <br>  Now that we have all the described protocols for the components of the VIPER module, we proceed to the implementation of these methods.  Do not forget to add that the view controller complies with the <i>AboutViewProtocol</i> protocol.  I will not describe how to associate a button with a storyboard with the property of the view controller and link the events of clicking on them, so I will immediately write the methods of the view controller: <br><br><pre> <code class="hljs swift"><span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlButton: <span class="hljs-type"><span class="hljs-type">UIButton!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender: UIBarButtonItem)</span></span></span></span> { presenter.closeButtonClicked() } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender: UIButton)</span></span></span></span> { presenter.urlButtonClicked(with: sender.currentTitle) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUrlButtonTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with title: String)</span></span></span></span> { urlButton.setTitle(title, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: .normal) }</code> </pre> <br>  The view controller has no idea what to do after pressing the buttons, but he knows exactly what to do when the <b>setUrlButtonTitle</b> method <b>(with title: String) is</b> called.  The view controller only updates, moves, repaints, hides <i>UI</i> elements based on the data with which the presenter called this method.  At the same time, the presenter does not know exactly how all this data is located in the <i>View / ViewController</i> . <br><br>  The full class of presenter looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">AboutViewProtocol!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">AboutInteractorProtocol!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> router: <span class="hljs-type"><span class="hljs-type">AboutRouterProtocol!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(view: <span class="hljs-type"><span class="hljs-type">AboutViewProtocol</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view = view } <span class="hljs-comment"><span class="hljs-comment">// MARK: - AboutPresenterProtocol methods func configureView() { view.setUrlButtonTitle(with: interactor.urlRatesSource) } func closeButtonClicked() { router.closeCurrentViewController() } func urlButtonClicked(with urlString: String?) { if let url = urlString { interactor.openUrl(with: url) } } }</span></span></code> </pre> <br>  We completely forgot about our configurator.  After all, without it, nothing will work.  Its code is: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutConfigurator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutConfiguratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with viewController: AboutViewController)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">AboutPresenter</span></span>(view: viewController) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">AboutInteractor</span></span>(presenter: presenter) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">AboutRouter</span></span>(viewController: viewController) viewController.presenter = presenter presenter.interactor = interactor presenter.router = router } }</code> </pre> <br>  Understandably, not to get the <a href="https://cocoacasts.com/what-are-strong-reference-cycles">Reference cycle</a> , the presenter at the view controller is indicated as <i>strong</i> , and the view controller at the presenter as <i>weak</i> , the interpreter at the presenter is indicated as <i>weak</i> , and so on.  The <i>ViewController</i> remains the most important one in this chain.  Therefore, to talk about the passive <i>View</i> is inappropriate here.  When you close the <i>ViewController,</i> all other elements are also destroyed, because no one can have a <i>strong</i> link to the <i>ViewController</i> .  Otherwise, we would get a <i>memory leak</i> . <br><br>  The class of interactor looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutInteractorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">AboutPresenterProtocol!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serverService: <span class="hljs-type"><span class="hljs-type">ServerServiceProtocol</span></span> = <span class="hljs-type"><span class="hljs-type">ServerService</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(presenter: <span class="hljs-type"><span class="hljs-type">AboutPresenterProtocol</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter = presenter } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlRatesSource: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serverService.urlRatesSource } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String)</span></span></span></span> { serverService.openUrl(with: urlString) } }</code> </pre> <br>  The code is pretty simple, so no comments are needed.  It is worth paying attention to the <i>ServerService</i> .  This is the service that will give the <i>URL</i> for our button on the view controller and open the link in Safari (or in some other way).  The <i>ServerService</i> code and its protocol looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerServiceProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlRatesSource: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerService</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerServiceProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlRatesSource: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"https://free.currencyconverterapi.com"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with urlString: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: urlString) { <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(url, options: [:]) } } }</code> </pre> <br>  Here, too, everything is simple.  Only the router remains: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewController: <span class="hljs-type"><span class="hljs-type">AboutViewController!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(viewController: <span class="hljs-type"><span class="hljs-type">AboutViewController</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewController = viewController } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeCurrentViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { viewController.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre> <br>  Once again, all the source code is in the repository.  Link at the end of the article. <br><a name="chapter2"></a><br><br><h2>  Chapter 2. An example of a more complex module </h2><br>  It is time to consider the architecture in a more complex example and summarize the rules for each layer. <br><br><img src="https://habrastorage.org/webt/c0/oc/xr/c0ocxr-rlt5midm_tmmmprtkfya.png"><br><br>  Storyboard with all the screens looks like this.  The main screen allows you to choose the currency from which we convert and in which we convert.  You can also enter the amount from which you need to convert to another currency.  The amount converted to another currency is displayed under the input field.  And at the very bottom of the conversion rate and the button to go to the screen " <i>About the application</i> ." <br><br>  Data on all currencies and their rates are requested from the free website <a href="https://free.currencyconverterapi.com/">https://free.currencyconverterapi.com</a> .  For simplicity, the data will be stored in <i>UserDefaults</i> , but you can easily redo only one class to store it in <i>Core Data</i> or in any other way. <br><br><img src="https://habrastorage.org/webt/8b/cz/k1/8bczk19czhvwhenaehm63vf_66k.png" align="right">  Now that we know what the VIPER module framework looks like, we can easily do the same for the main screen.  The right shows the files of the module <i>Main</i> (main screen).  A minor inconvenience of the architecture is that for each module you need to create a lot of files, and manually it takes a lot of time.  Therefore, Rambler invented the <a href="https://github.com/rambler-digital-solutions/Generamba">Generamba</a> code <a href="https://github.com/rambler-digital-solutions/Generamba">generator</a> , which performs routine work for us.  If you dig, it can be customized.  Or you can use templates for <i>Xcode</i> , there are plenty of examples on the web.  For example, <a href="https://github.com/Juanpe/Swift-VIPER-Module">https://github.com/Juanpe/Swift-VIPER-Module</a> or <a href="https://github.com/infinum/iOS-VIPER-Xcode-Templates">https://github.com/infinum/iOS-VIPER-Xcode-Templates</a> .  In more detail, these topics will not be considered, because  this is beyond the scope of the article. <br><br>  It is striking that for the protocols I created a separate file in each module.  If you do not like this approach, then you can describe the protocols directly in the file of the classes themselves.  Personally, it is more convenient for me when all the protocols of the module are collected in one place.  A matter of taste. <br><br>  By tradition, we will also begin to consider the module with a view controller.  <b>An important rule for the <i>View / ViewController</i> is that they do not directly transfer the <i>Entity</i> .</b>  For this, additional layers / services should be created. <br><br>  The <b>viewDidLoad</b> method will be identical to the implementation from the <i>About</i> module.  Configuring the module will be called up and instructed the <i>operator</i> to configure the <i>View</i> ( <i>ViewController</i> in our case). <br><br><img src="https://habrastorage.org/webt/ed/so/tg/edsotgna3ddkipyv5vco0dw0aze.png" align="left">  Configuring the module is almost the same as in the <i>‚ÄúAbout‚Äù</i> module.  But on the main screen, you need an additional <i>View-</i> component of <i>CurrencyPickerView</i> , it is created as a separate class and can be reused in other places or even applications.  In the storyboard, an ordinary <i>UIView is</i> added on the main screen and the <i>CurrencyPickerView</i> class is set for it. <br><br>  All <i>CurrencyPickerView</i> code will not be considered.  Although the <i>IBOutlet</i> for it is in the view controller, its logic will be processed in the presenter.  Therefore, the link to it is written in the configurator.  <i>CurrencyPickerView</i> also has a delegate, and they will not be a view controller, but a presenter.  In the configurator we add the following calls: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainConfigurator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainConfiguratorProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with viewController: MainViewController)</span></span></span></span> { ... presenter.currencyPickerView = viewController.currencyPickerView viewController.currencyPickerView.delegate = presenter } }</code> </pre> <br>  On a more complex example, it becomes clear that the view controller is unloaded, and the logic is transferred from the presenter to the interactor and further to the services.  Configuring the <i>View</i> in this module is more complex and includes setting the saved values ‚Äã‚Äãthat were used the last time before closing the application.  The code is: <br><br><pre> <code class="hljs pgsql">func configureView() { <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>?.setInputValue(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: inputValue) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>?.setOutputValue(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: outputValue) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>?.setInputCurrencyShortName(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: inputCurrencyShortName) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>?.setOutputCurrencyShortName(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: outputCurrencyShortName) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>?.addDoneOnInputCurrencyKeyboard() updateRateText() interactor.getAllCurrencies() }</code> </pre> <br>  In addition to setting the initial values ‚Äã‚Äãfor the UI components, a request is sent to the interactor about getting a list of all currencies.  The presenter does not know where this data will come from, but he knows that he needs it.  Also, the <b>inputValue</b> , <b>outputValue</b> , <b>inputCurrencyShortName</b> and <b>outputCurrencyShortName values ‚Äã‚Äãare</b> requested from the <b>interpreter</b> , since  Only he knows where to get this saved data: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputValue: String? { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = newValue { interactor.inputValue = Double(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) ?? <span class="hljs-number"><span class="hljs-number">0.0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = String(interactor.inputValue) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.hasSuffix(<span class="hljs-string"><span class="hljs-string">".0"</span></span>) { input.removeLast(<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputValue: String? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> formatter = NumberFormatter() formatter.numberStyle = .<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> formatter.maximumFractionDigits = <span class="hljs-number"><span class="hljs-number">2</span></span> formatter.roundingMode = .down formatter.usesGroupingSeparator = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number = NSNumber(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: interactor.outputValue) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = formatter.<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: number)! <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.hasSuffix(<span class="hljs-string"><span class="hljs-string">".00"</span></span>) { output.removeLast(<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputCurrencyShortName: String { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interactor.inputCurrencyShortName } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputCurrencyShortName: String { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interactor.outputCurrencyShortName } }</code> </pre> <br>  In the comments to the VIPER, I met the opinion that the presenter does nothing much and just sends the data from the view controller to the interactor and back.  From the code above, it becomes clear that the presenter does not just request data from the interactor and give it "as is", but also prepares and formats the data in the required form.  Remember that the presenter is responsible for exactly what data and in what form will be transferred to the view controller.  The view controller no longer cares about formatting them; it only assigns them to the required UI components. <br><br>  <b>Presenter knows nothing about <i>UIKit</i> , he does not know about <i>UIButton</i> , <i>UILabel</i> and no other visual components.</b>  It is very important.  All work with <i>UIKit</i> takes place in view controllers and other View components.  Also, when you press a button, you cannot pass the parameter <i>UIButton</i> , the presenter should not know about it.  Therefore, pressing the buttons and entering text in the input field are processed in the view controller in the following way: <br><br><pre> <code class="hljs swift"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputCurrencyButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender: UIButton)</span></span></span></span> { presenter.inputCurrencyButtonClicked() } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outputCurrencyButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender: UIButton)</span></span></span></span> { presenter.outputCurrencyButtonClicked() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldDidBeginEditing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> textField: UITextField)</span></span></span></span> { presenter.textFieldDidBeginEditing() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> textField == inputTextField { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> textField.availableAdding(string: string) { textField.addString(string) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.inputValueChanged(to: textField.text ?? <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldShouldClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> textField: UITextField)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> textField == inputTextField { textField.clear() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.inputValueCleared() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Suppose you need to write a custom UI element or add an <i>extension</i> for the finished one.  Consider, for example, a <i>UITextField</i> from the main module.  A component may contain its own internal logic relating only to it.  For example, the input field for the currency amount can be fractional, but you cannot enter 2 zero consecutively at the beginning <i>(‚Äú00‚Äù)</i> or enter several points <i>(‚Äú0.11.2‚Äù)</i> , the comma is converted into a point, you can enter only numbers, an additional button is added to keyboard, etc.  In this case, it is allowed to bring this logic into the element itself.  After all, this logic does not affect the logic of other components of the application, but refers only to it itself.  For example, like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITextField</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">availableAdding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> string { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text != <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span>...<span class="hljs-string"><span class="hljs-string">"9"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text != <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text!.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text!.range(of: <span class="hljs-string"><span class="hljs-string">"."</span></span>) == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text!.range(of: <span class="hljs-string"><span class="hljs-string">","</span></span>) == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> string: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newValue: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text ?? <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addingString = string <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addingString == <span class="hljs-string"><span class="hljs-string">""</span></span>, newValue.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { newValue.removeLast() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addingString != <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addingString == <span class="hljs-string"><span class="hljs-string">","</span></span> { addingString = <span class="hljs-string"><span class="hljs-string">"."</span></span> } newValue.append(addingString) } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text = newValue } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.text = <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDoneOnKeyboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardToolbar = <span class="hljs-type"><span class="hljs-type">UIToolbar</span></span>() keyboardToolbar.sizeToFit() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flexBarButton = <span class="hljs-type"><span class="hljs-type">UIBarButtonItem</span></span>(barButtonSystemItem: .flexibleSpace, target: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, action: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doneBarButton = <span class="hljs-type"><span class="hljs-type">UIBarButtonItem</span></span>(barButtonSystemItem: .done, target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: #selector(dismissKeyboard)) keyboardToolbar.items = [flexBarButton, doneBarButton] <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.inputAccessoryView = keyboardToolbar } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dismissKeyboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.resignFirstResponder() } }</code> </pre> <br>  Another thing is when such logic can affect external data, for example, the availability of a login for a user during registration, since  there will be a request to the server or database.  Or repeat the password, because it will affect another component.  In general, you can add logic to a UI component that only applies to itself.  Although for some it may seem a controversial point. <br><br>  Consider how data is obtained about currencies from the server.  In the presenter there was a call to the <b>getAllCurrencies ()</b> method and that's it.  What should happen next, the presenter does not know.  Further logic is written in interactor and, if necessary, commands are sent to the presenter, what should be done.  The implementation is as follows: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllCurrencies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { presenter.showHUD() serverService.getAllCurrencies { (dict, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.hideHUD() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.showLoadCurrenciesButton() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.showAlertView(with: error.localizedDescription) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dictResponse = dict { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currencyService.saveAllCurrencies(with: dictResponse, completion: { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.hideHUD() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenter.showAlertView(with: error.localizedDesc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currencyService.sortAndUpdateCurrentCurrencies() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.getOutputCurrencyRatio(newCurrency: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }) } } }</code> </pre> <br>  Two services are already involved in this <i>integrator</i> : <i>CurrencyService</i> , which is responsible for working with currencies, and the previously known <i>ServerService</i> , which is responsible for working with the server.  Of course, the <i>ServerService</i> would be better divided into several service classes in order to reuse the methods of working not with a specific server, but with any.  But I limited myself to one class here, in order to simplify and not to create a million classes for everything, because it does not hurt for the architecture of the VIPER modules. <br><br>  For services, it is also very desirable to create protocols in order to work through them and not be tied to specific classes, according to one of the <i>SOLID</i> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B8%25D0%25BD%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9">principles of dependency inversion</a> . <br><br>  <i>CurrencyService</i> will help you work with a data structure such as <i>Currency</i> .  He will give all the available currencies, the current value entered for the currency, the types of currencies, as well as the ability to save, sort and receive the rate relative to two currencies.  His protocol looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurrencyServiceProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencies: [<span class="hljs-type"><span class="hljs-type">Currency</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencyNames: [<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputValue: <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputValue: <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputCurrency: <span class="hljs-type"><span class="hljs-type">Currency</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputCurrency: <span class="hljs-type"><span class="hljs-type">Currency</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAllCurrencies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with dict: [String: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">], completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(CurrencyError?)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Swift</span></span>.<span class="hljs-type"><span class="hljs-type">Void</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortAndUpdateCurrentCurrencies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveOutputCurrencyRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with dict: [String: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">], completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(CurrencyError?)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Swift</span></span>.<span class="hljs-type"><span class="hljs-type">Void</span></span>) }</code> </pre> <br>  <i>CurrencyService</i> requests data from another <i>StorageService</i> , which stores the data in <i>UserDefaults</i> , and the <i>editor</i> does not even suspect that the data is stored at all, let alone how it is stored.  The integrator does not even know that the <i>StorageService</i> service exists, because the <i>CurrencyService</i> service helper does all the work itself and only gives the data to the interactor. <br><br>  The main module integrator mainly consists of abstractions and calls to the methods of the service protocols, so for such layers it is very easy to write unit tests, since  create moki and stubs for them will not be easy.  No binding to specific classes. <br><br>  I will not further examine in detail each method and each line of the remaining classes.  The overall essence of the architecture and the role of each layer should already be clear.  The last thing I would like to say is to switch to another screen via <i>Segue</i> . <br><br>  Apple laid this functionality for the view controller, so we need to proceed from this approach, and not go through the <b>navigationController? .PushViewController (vc, animated: true)</b> .  After clicking on the <i>"Info"</i> button, the <i>"About application"</i> screen should open.  Therefore, the event of pressing the button is presented by the presenter to the router, and it calls the following method: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAboutScene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { viewController.performSegue(withIdentifier: viewController.selfToAboutSegueName, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  The view controller calls system <b>prepare (for segue ...)</b> , and it directly sends this event to the router: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { presenter.router.prepare(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue, sender: sender) }</code> </pre> <br>  It turned out that the presenter is passed in this case.  If someone does not like such a violation, then you must either skip the method through the presenter, passing the UI element as a parameter, which will also be a violation.  Or come up with something else.  I myself have not yet found a better option.  If you could set a delegate for <b>prepare (for: segue, sender: sender)</b> , then, of course, it would be a router. <br><a name="conclusion"></a><br><br><h2>  Conclusion </h2><br>  The specified architecture option is not ideal.  It was not for nothing that at the beginning of the article I gave a saying that everyone has their own VIPER.  How many people, so many opinions.  I met options when several modules were grouped within one user-story and wrote one router for several modules.  Or in another embodiment, one interactor into several modules.  Many use the classic version with <i>Wireframe</i> , others come up with something else.  Someone passes to the <i>Entity</i> view controller.  The latter, of course, is wrong. <br><br>  Even if you have a written application as horrible, VIPER allows you to rewrite everything gradually.  View controller for view controller.  This is also the presentation layer and each module is independent of the architecture and implementation of the other.  Start transferring logic to services gradually.  Unload the view controller.  And in the further support of the code, such a division by layers will pay you back many times. <br><br>  In the article, I did not touch on <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Dependency Injection</a> in modules for iOS, for example, <a href="https://github.com/appsquickly/Typhoon">Typhoon</a> .  And there are many more <s>whistlers of</s> additional and useful things that facilitate development.  The general behavior for modules could be brought into abstract classes and protocols, and then inherited from them.  In general, any project and code can be improved to infinity and it will not be perfect anyway. <br><br>  Whatever your VIPER, it is important to follow a clear division of responsibility between the layers and work with abstractions (protocols).  Writing tests for VIPER-modules will no longer be considered, but for such code it will be much easier to write them. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probably, the article turned out a bit messy and voluminous, but for that I provided all the source code so that you could figure it out for yourself. </font><font style="vertical-align: inherit;">Constructive criticism and discussion is welcome. </font><font style="vertical-align: inherit;">Maybe I wrote something wrong. </font><font style="vertical-align: inherit;">Write in the comments.</font></font><br><a name="ref"></a><br><br>  <a href="https://github.com/IbrahimKZ/iOS-CurrencyConverter-VIPER">Link to the repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/358412/">https://habr.com/ru/post/358412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358400/index.html">Marvin Minsky "The Emotion Machine": Chapter 3 "Freud, Mood Control and Character"</a></li>
<li><a href="../358402/index.html">Marvin Minsky "The Emotion Machine": Chapter 3 "How to use emotions"</a></li>
<li><a href="../358404/index.html">Writing your data source for Grafana</a></li>
<li><a href="../358406/index.html">Writing an open source messenger</a></li>
<li><a href="../358410/index.html">Administration 1C for the smallest. Part One - Divide and Conquer</a></li>
<li><a href="../358414/index.html">Navigation with architectural components from Google. Part 1. Introduction</a></li>
<li><a href="../358416/index.html">Battle of Net Neutrality: New Hope</a></li>
<li><a href="../358418/index.html">10 years of life and experience of the company "Flant" in one post</a></li>
<li><a href="../358422/index.html">Making the Marketplace integrated into the online cash desk cloud</a></li>
<li><a href="../358426/index.html">Receiving user data (voluntary)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>