<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thanks to WebAssembly, you can write Frontend on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Original article. 

 In February 2017, a member of the go team Brad Fitzpatrick offered to make support for WebAssembly in the language. Four months l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thanks to WebAssembly, you can write Frontend on Go</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://medium.zenika.com/go-1-11-webassembly-for-the-gophers-ae4bb8b1ee03">Original</a> article. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/az/mf/wwazmfemkd6qhegdxrzeabctnxk.jpeg"></div><br>  In February 2017, a member of the go team Brad Fitzpatrick <a href="https://github.com/golang/go/issues/18892">offered</a> to make support for WebAssembly in the language.  Four months later, in November 2017, the author <a href="https://github.com/gopherjs/gopherjs">GopherJS</a> Richard Muziol began to implement the idea.  And, finally, the full implementation was in the master.  Developers will receive wasm around August 2018, with version <a href="">1.11 go</a> .  As a result, the standard library takes on almost all the technical difficulties with importing and exporting functions familiar to you, if you have already tried compiling C in wasm.  It sounds promising.  Let's see what can be done with the first version. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/415/41d/de141541d13f83b05f9e3412d1961868.png"></div><br><br>  All examples in this article can be run from docker containers that are <a href="https://hub.docker.com/r/nlepage/golang_wasm/">in the author‚Äôs repository</a> : <br><br><pre><code class="bash hljs">Ôªødocker container run -dP nlepage/golang_wasm:examples <span class="hljs-comment"><span class="hljs-comment"># Find out which host port is used docker container ls</span></span></code> </pre> <br>  Then go to <a href="http://localhost/">localhost</a> : 32XXX /, and go from one link to another. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Hi, wasm! </h3><br>  Creating a basic ‚Äúhello world‚Äù and concepts is already fairly <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">well documented</a> (even <a href="https://developer.mozilla.org/ru/docs/WebAssembly">in Russian</a> ), so let's just move on to more subtle things more quickly. <br><br>  The most necessary is a freshly compiled version of Go that supports wasm.  I will not <a href="https://golang.org/doc/install/source">describe the installation step by step</a> , just know what is needed already in the master. <br><br>  If you don‚Äôt want to worry about it, <a href="https://github.com/nlepage/golang-wasm/blob/master/golang/Dockerfile">Dockerfile c go</a> is available in <a href="https://github.com/nlepage/golang-wasm">the golub-wasm repository on github</a> , or even faster you can take an image from <a href="https://hub.docker.com/r/nlepage/golang_wasm/">nlepage / golang_wasm</a> . <br><br>  Now you can write the traditional <code>helloworld.go</code> and compile it with the following command: <br><br><pre> <code class="bash hljs">ÔªøGOOS=js GOARCH=wasm go build -o test.wasm helioworld.go</code> </pre><br>  The environment variables GOOS and <a href="https://hub.docker.com/r/nlepage/golang_wasm/">GOARCH are</a> already set in the <a href="https://hub.docker.com/r/nlepage/golang_wasm/">nlepage / golang_wasm</a> image, so you can use a <code>Dockerfile</code> file like this to compile: <br><br><pre> <code class="hljs go">FROM nlepage/golang_wasm COPY helloworld.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/hello/ RUN <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build -o test.wasm hello</code> </pre><br>  The final step is to use the <code>wasm_exec.html</code> and <code>wasm_exec.js</code> files available in the go repository in the <a href="https://github.com/golang/go/tree/master/misc/wasm"><code> misc/wasm</code></a> or in the docker <a href="https://hub.docker.com/r/nlepage/golang_wasm/">nlepage / golang_wasm image</a> in the <code>/usr/local/go/misc/wasm/</code> to run <code>test.wasm</code> in browser (wasm_exec.js expects binary <code>test.wasm</code> , so we use this name). <br>  You just need to give 3 static files using nginx, for example, then wasm_exec.html will display the ‚Äúrun‚Äù button (it will <code>test.wasm</code> on only if <code>test.wasm</code> loaded correctly). <br><br>  It is noteworthy that <code>test.wasm</code> must be serviced with the MIME type <code>application/wasm</code> , otherwise the browser will refuse to execute it.  (for example, nginx needs an <a href="https://github.com/nlepage/golang-wasm/blob/3fea94bfe6332703eef071f7ea8f22c8b0812683/nginx/mime.types">updated mime.types file</a> ). <br><br>  You can use the nginx image from <a href="https://hub.docker.com/r/nlepage/golang_wasm/tags/">nlepage / golang_wasm</a> , which already includes the fixed MIME type, <code>wasm_exec.html</code> and <code>wasm_exec.js</code> in the code&gt; / usr / share / nginx / html / directory. <br><br>  Now click the ‚Äúrun‚Äù button, then open the console of your browser, and you will see the console.log greeting (‚ÄúHello Wasm!‚Äù). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/3fe/587/cb13fe587331b2426368ea541f22c61b.png"></div><br>  A full example is available <a href="https://github.com/nlepage/golang-wasm/tree/master/examples/hello">here</a> . <br><br><h3>  Call JS from Go </h3><br>  Now that we have successfully launched the first WebAssembly binary file compiled from Go, let's take a closer look at the possibilities provided. <br><br>  The new syscall / js package is included in the standard library, consider the main file - <code><a href="">js.go</a></code> <br>  A new <code>js.Value</code> type is <code>js.Value</code> , which represents the JavaScript value. <br><br>  It offers a simple API for managing JavaScript variables: <br><br><ul><li>  <code>js.Value.Get()</code> and <code>js.Value.Set()</code> return and set the values ‚Äã‚Äãof the object's fields. </li><li>  <code>js.Value.Index()</code> and <code>js.Value.SetIndex()</code> refer to the object by index for read and write. </li><li>  <code>js.Value.Call()</code> calls an object's method as a function. </li><li>  <code>js.Value.Invoke()</code> calls the object itself as a function. </li><li>  <code>js.Value.New()</code> calls the new operator and uses its own knowledge as a constructor. </li><li>  A few more methods to get the javascript value in the appropriate type Go, for example <code>js.Value.Int()</code> or <code>js.Value.Bool()</code> . </li></ul><br>  And additional interesting methods: <br><br><ul><li>  <code>js.Undefined()</code> will give js.Value the corresponding <code>undefined</code> . </li><li>  <code>js.Null()</code> will give <code>js.Value</code> corresponding <code>null</code> . </li><li>  <code>js.Global()</code> returns <code>js.Value</code> giving access to the global scope. </li><li>  <code>js.ValueOf()</code> accepts primitive Go types and returns the correct <code>js.Value</code> </li></ul><br>  Instead of displaying the message in os.StdOut, let's display it in the alert window using <code>window.alert()</code> . <br><br>  Since we are in the browser, the global scope is a window, so you first need to get alert () from the global scope: <br><br><pre> <code class="go hljs">alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>)</code> </pre><br>  Now we have an <code>alert</code> variable, in the form of <code>js.Value</code> , which is a reference to <code>window.alert</code> JS, and you can use the function call via <code>js.Value.Invoke()</code> : <br><br><pre> <code class="go hljs">alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello wasm!"</span></span>)</code> </pre><br>  As you can see, there is no need to call js.ValueOf () before passing Invoke arguments, it accepts an arbitrary number of <code>interface{}</code> and passes values ‚Äã‚Äãthrough ValueOf itself. <br><br>  Now our new program should look like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>) alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello Wasm!"</span></span>) }</code> </pre><br>  As in the first example, you just need to create a file named <code>test.wasm</code> , and leave <code>wasm_exec.html</code> and <code>wasm_exec.js</code> as it was. <br>  Now, when we press the ‚ÄúRun‚Äù button, an alert window appears with our message. <br><br>  A working example is in the <a href="https://github.com/nlepage/golang-wasm/tree/master/examples/js-call"><code>examples/js-call</code></a> folder. <br><br><h3>  Call Go from JS. </h3><br>  Calling JS from Go is quite simple, let's take a closer look at the <code>syscall/js</code> package, the second file to view is <a href=""><code>callback.go</code></a> . <br><br><ul><li>  <code>js.Callback</code> type wrapper for the Go function, for use in JS. </li><li>  <code>js.NewCallback()</code> function that accepts a function (accepting a <code>js.Value</code> slice and returns nothing), and returns <code>js.Callback</code> . </li><li>  Some mechanics to manage active callbacks and <code>js.Callback.Release()</code> , which must be called to destroy the callback. </li><li>  <code>js.NewEventCallback()</code> similar to <code>js.NewCallback()</code> , but the wrapped function takes only 1 argument - the event. </li></ul><br>  Let's try to do something simple: run Go <code>fmt.Println()</code> from the side of JS. <br><br>  We'll make some changes to <code>wasm_exec.html</code> to be able to get a callback from Go to call it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> go.run(inst); inst = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiate(mod, go.ImportObject); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  This launches the wasm binary and waits for it to complete, then reinitializes it for the next run. <br><br>  Let's add a new function that will receive and save the Go callback and change the <code>Promise</code> state to completion: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage <span class="hljs-comment"><span class="hljs-comment">// Our reference to the Go callback let printMessageReceived // Our promise let resolvePrintMessageReceived // Our promise resolver function setPrintMessage(callback) { printMessage = callback resolvePrintMessageReceived() }</span></span></code> </pre><br>  Now let's adapt the <code>run()</code> function to use the callback: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear() <span class="hljs-comment"><span class="hljs-comment">// Create the Promise and store its resolve function printMessageReceived = new Promise(resolve =&gt; { resolvePrintMessageReceived = resolve }) const run = go.run(inst) // Start the wasm binary await printMessageReceived // Wait for the callback reception printMessage('Hello Wasm!') // Invoke the callback await run // Wait for the binary to terminate inst = await WebAssembly.instantiate(mod, go.importObject) // reset instance }</span></span></code> </pre><br>  And this is on the JS side! <br><br>  Now in the Go part you need to create a callback, send it to the JS side and wait for the function to be needed. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  Then we need to write the real <code>printMessage()</code> function: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.Println(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} <span class="hljs-comment"><span class="hljs-comment">// Notify printMessage has been called }</span></span></code> </pre><br>  The arguments are passed through the <code>[]js.Value</code> , so you need to call <code>js.Value.String()</code> in the first slice element to get the message in the Go string. <br>  Now we can wrap this function in a callback: <br><br><pre> <code class="go hljs">callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() <span class="hljs-comment"><span class="hljs-comment">// to defer the callback releasing is a good practice</span></span></code> </pre><br>  Then call the JS <code>setPrintMessage()</code> function, just like when you call <code>window.alert()</code> : <br><br><pre> <code class="go hljs">setPrintMessage := js.Global.Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrintMessage.Invoke(callback)</code> </pre><br>  The last thing to do is wait for the callback call in main: <br><br><pre> <code class="go hljs">&lt;-done</code> </pre><br>  This last part is important because the callbacks are executed in a dedicated goroutine, and the main goroutine must wait for a callback, otherwise the wasm binary will be stopped prematurely. <br><br>  The resulting Go program should look like this: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(prtntMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) &lt;-done } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.PrintIn(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  As in the previous examples, create a file named <code>test.wasm</code> .  You also need to replace <code>wasm_exec.html</code> with our version, and <code>wasm_exec.js</code> can be reused. <br><br>  Now, when you press the ‚Äúrun‚Äù button, as in our first example, the message is printed in the browser console, but this time it is much better!  (And harder.) <br><br>  The working example in the docker file bidet is available in the <a href="https://github.com/nlepage/golang-wasm/tree/master/examples/go-call"><code>examples/go-call</code></a> folder. <br><br><h3>  Long job </h3><br>  The Go from JS call is a bit more cumbersome than the Go JS call, especially on the JS side. <br><br>  This is mainly due to the fact that you need to wait for the result of the Go callback to be sent to the JS side. <br><br>  Let's try something else: why not organize a wasm binary file that will not be completed immediately after a callback call, but will continue to work and receive other calls. <br>  This time let's start from Go, and like in our previous example, we need to create a callback and send it to the JS side. <br><br>  Add a call counter to track how many times the function has been called. <br><br>  Our new <code>printMessage()</code> function will print the received message and the value of the counter: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) }</code> </pre><br>  Creating a callback and sending it to the JS side is the same as in the previous example: <br><br><pre> <code class="go hljs">Ôªøcallback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback)</code> </pre><br>  But this time we have no <code>done</code> channel to notify us of the termination of the main gorutin.  One way can be to permanently block the main goroutin with an empty <code>select{}</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span>{}</code> </pre><br>  This is not satisfactory, our binary wasm will just hang in memory until the browser tab closes. <br><br>  You can listen to the <a href="https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload"><code>beforeunload</code></a> event on the page, you will need a second callback to receive the event and notify the main gorutina via the channel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  This time, the new <code>beforeUnload()</code> function will only accept an event, in the form of a single <code>js.Value</code> argument: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Then we wrap it up in a callback using <code>js.NewEventCallback()</code> and register it on the JS side: <br><br><pre> <code class="go hljs">beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb)</code> </pre><br>  Finally, replace the empty blocking <code>select</code> for reading from the <code>beforeUnloadCh</code> channel: <br><br><pre> <code class="go hljs">&lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>)</code> </pre><br>  The final program looks like this: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb) &lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Prtntf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Previously, on the JS side, loading the wasm binary file looked like this: <br><br><pre> <code class="javascript hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mod, inst WebAssembly .instantiateStreaming(fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { mod = result.module inst = result.Instance <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"runButton"</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> })</code> </pre><br>  Let's adapt it to run a binary file immediately after downloading: <br><br><pre> <code class="javascript hljs">Ôªø(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { instance } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiateStreaming( fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject ) go.run(instance) })()</code> </pre><br>  And replace the ‚ÄúRun‚Äù button with the message field and the button to call <code>printMessage()</code> : <br><br><pre> <code class="xml hljs">Ôªø<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messageInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Hello Wasm!"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"printMessage(document.querySelector('#messagelnput').value);"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"prtntMessageButton"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">&gt;</span></span> Print message <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Finally, the <code>setPrintMessage()</code> function, which accepts and stores a callback, should be simpler: <br><br><pre> <code class="javascript hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPrintMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ printMessage = callback; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#printMessageButton'</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Now, when we press the ‚ÄúPrint message‚Äù button, we should see a message of our choice and a call counter printed in the browser console. <br>  If we check the box ‚ÄúPreserve log‚Äù of the browser console and refresh the page, we will see the message ‚ÄúBye Wasm!‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c3/676/63d/6c367663d28d90535ccaafd1c10b5f50.png"></div><br><br>  Sources are available in the <a href="https://github.com/nlepage/golang-wasm/tree/master/examples/long-running"><code>examples/long-running</code></a> folder on github. <br><br><h3>  So what is next? </h3><br>  As you can see, the studied <code>syscall/js</code> API does its job and allows you to write complex things with a small amount of code.  You can write to the <a href="https://twitter.com/njblepage">author</a> , if you know the easier way. <br>  At the moment, it is not possible to return a value to JS directly from the Go callback. <br>  It should be borne in mind that all callbacks are executed in the same goroutin, so if you do some blocking operations in the callback, do not forget to create a new goroutin, otherwise you will block all other callbacks. <br>  All the basic functions of the language are already available, including concurrency.  For now, all goroutins will work in the same thread, but this <a href="https://github.com/WebAssembly/design/issues/1073">will change in the future</a> . <br>  In our examples, we used only the fmt package from the standard library, but everything is available that is not trying to escape from the sandbox. <br><br>  It seems that the file system is supported through Node.js. <br><br>  Finally, how about performance?  It would be interesting to run some tests to see how Go wasm compares with equivalent pure JS code.  Someone <a href="https://github.com/hajimehoshi/wasm-bench">hajimehoshi</a> made measurements, how different environments work with integers, but the technique is not very clear. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae0/e5b/ab5/ae0e5bab565640331a956284e94f4859.jpg"></div><br><br>  Do not forget that Go 1.11 has not even been officially released yet.  In my opinion, very good for experimental technology.  Those who are interested in performance tests <a href="https://takahirox.github.io/WebAssembly-benchmark/">may torment their browser</a> . <br>  The main niche, as the author notes, is the transfer of already existing go code from the server to the client.  But with new standards, you can do <a href="http://htmlbook.ru/html/html/manifest">completely offline applications</a> , and the wasm code is saved in compiled form.  It is possible to transfer many utilities to web, agree, it is convenient? </div><p>Source: <a href="https://habr.com/ru/post/417563/">https://habr.com/ru/post/417563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417553/index.html">Open webinar "CSS preprocessors"</a></li>
<li><a href="../417555/index.html">Announcement of the Cargo Cult seminar in Moscow: Marketing strikes back</a></li>
<li><a href="../417557/index.html">Overview of Laser CNC LaserSolid machines</a></li>
<li><a href="../417559/index.html">How China made Apple store iCloud user encryption keys on Chinese government servers</a></li>
<li><a href="../417561/index.html">Call of Dates, or How did the second hackathon Mail.Ru Mail</a></li>
<li><a href="../417565/index.html">Google to lay private cable across the Atlantic</a></li>
<li><a href="../417569/index.html">Unit testing database scripts</a></li>
<li><a href="../417571/index.html">Multi-armed bandits in the recommendations</a></li>
<li><a href="../417573/index.html">Worldwide known AI developers have agreed not to create smart weapons.</a></li>
<li><a href="../417575/index.html">Some Tesla buyers from Germany will have to return 4,000 euros to the state</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>