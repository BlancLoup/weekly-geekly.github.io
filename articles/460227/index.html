<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Custom refactoring tool: Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Any engineer seeks to make their work process as optimized as possible. We, as iOS mobile developers, very often have to work with uniform language st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Custom refactoring tool: Swift</h1><div class="post__text post__text-html js-mediator-article">  Any engineer seeks to make their work process as optimized as possible.  We, as iOS mobile developers, very often have to work with uniform language structures.  Apple is improving the tools of developers, making a lot of effort to make it convenient for us to program: highlighting the language, autocompleting methods, and many other IDE features allow our fingers to keep up with the ideas in their head. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b6/69d/e24/4b669de249e57f8f8d7ad2da21df22a3.png"><br><br>  What does an engineer do when the required tool is missing?  True, he will do everything himself!  Earlier we already <a href="https://habr.com/ru/company/sberbank/blog/447594/">talked</a> about creating custom tools, now let's talk about how to modify Xcode and make it work according to your rules. <br><a name="habracut"></a><br>  We took a tuska from <a href="https://bugs.swift.org/browse/SR-5744">JIRA Swift</a> 'and made a tool that transforms <b>if let</b> into an equivalent <b>guard let</b> construction. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/d68/6b7/ad5/d686b7ad5d24b87b61df2bb6d87299eb.gif"><br><br>  With version 9, Xcode provides a new refactoring mechanism that can translate code locally, within the same Swift source file, or globally, when you rename a method or property that occurs in several files, even if they are in different languages. <br><br>  Local refactoring is fully implemented in the SourceKit compiler and framework, the feature is in Swift's open source repository and written in C ++.  The global refactoring modification is currently inaccessible to the public, because the Xcode codebase is closed.  Therefore, we dwell on the local history and tell you how to repeat our experience. <br><br>  What you need to create your tool for local refactoring: <br><br><ol><li>  Understanding C ++ <br></li><li>  Basic compiler knowledge <br></li><li>  Understanding what AST is and how to work with it <br></li><li>  <a href="https://github.com/apple/swift">Swift</a> source code <br></li><li>  Hyde <a href="">swift / docs / refactoring / SwiftLocalRefactoring.md</a> <br></li><li>  A lot of patience <br></li></ol><br><h2>  Little about AST </h2><br>  Some theoretical basics before diving into practice.  Let's take a look at the work of the Swift compiler architecture.  The compiler is primarily responsible for transforming the code into executable machine code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00b/9e7/f23/00b9e7f23d9d1c1b3e02d14905179ef2.png"><br><br>  Of the transformation stages presented, the most interesting for us is the generation of an abstract syntax tree (AST) - a graph in which the vertices are operators, and the leaves are their operands. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/269/29f/35026929fee03914b2689ee5b20fa6f8.png"><br><br>  Syntax trees are used in the parser.  AST is used as an internal representation in the compiler / interpreter of a computer program for optimizing and generating code. <br><br>  After generating the AST, a parsing is performed to create an AST with a type check, which has been translated into the Swift Intermediate Language.  SIL is converted, optimized, reduced to LLVM IR, which is ultimately compiled into native code. <br><br>  To create a refactoring tool, we need to understand AST and be able to work with it.  So the tool will be able to correctly operate with parts of the code that we want to process. <br><br>  To generate an AST of a file, run the command: swiftc -dump-ast <i>MyFile.swift</i> <i><br><br></i>  <i>Below is the <a href="https://bugs.swift.org/browse/SR-5744">output to the</a> AST <a href="https://bugs.swift.org/browse/SR-5744">console of</a> the <b>if let</b> function, which was mentioned earlier.</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/901/276/7b6/9012767b6955ddd58dfc221181e8a70b.png"></i> <br><br>  There are three basic node types in Swift AST: <br><br><ul><li>  declarations (Decl subclasses), <br></li><li>  expressions (subclasses of type Expr), <br></li><li>  operators (subclasses of type Stmt). <br></li></ul><br>  They correspond to three entities that are used in the Swift language itself.  Names of functions, structures, parameters are declarations.  Expressions are entities that return a value;  for example, calling functions.  Operators are parts of the language that define the control flow of code execution, but do not return a value (for example, if or do-catch). <br><br>  This is a sufficient minimum that you need to know about AST for the upcoming work. <br><br><h2>  How the theory refactoring tool works </h2><br>  To implement refactoring, you will need specific information about the area of ‚Äã‚Äãcode that you are going to change.  Developers are provided with auxiliary entities that accumulate data.  The first, ResolvedCursorInfo (cursor-based refactoring), will tell you whether we are at the beginning of an expression.  If so, then the corresponding compiler object of this expression is returned.  The second entity, RangeInfo (range-based refactoring), encapsulates data about the source range (for example, how many entry and exit points it has). <br><br>  Cursor-based refactoring is initiated by placing the cursor in the source file.  Refactoring actions implement the methods that the refactoring mechanism uses to display the available actions in the IDE and to perform transformations.  Examples of cursor-based actions: Jump to definition, quick help, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fce/30f/c9d/fce30fc9de1ab5b473ff9ac14795c462.png"><br><br>  Consider the usual actions from the technical side: <br><br><ol><li>  When you select a location from the Xcode editor, a request is made to the <a href="https://github.com/apple/swift/tree/master/tools/SourceKit/tools/sourcekitd">sourcekitd</a> (the framework responsible for highlighting, code completion, etc.) to display the available refactoring actions. <br></li><li>  Each available action is requested by a ResolvedCursorInfo object to check if this action is applicable to the selected code. <br></li><li>  A list of applicable actions is returned as a response from sourcekitd and displayed in Xcode. <br></li><li>  Xcode then applies the refactoring tool changes. <br></li></ol><br>  Range-based refactoring is initiated by selecting a continuous code range in the source file. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/670/987/f65/670987f65cedaec71b072c3d2c721315.png"><br><br>  In this case, the refactoring tool will go through the same described call chain.  The difference is that when implemented, the input is RangeInfo instead of ResolvedCursorInfo.  Interested readers can refer to <a href="">Refactoring.cpp</a> for more details on Apple‚Äôs tool implementation examples. <br><br>  And now to the practice of creating a tool. <br><br><h2>  Training </h2><br>  The first step is to download and compile the Swift compiler.  Detailed instructions are in the official repository ( <a href="">readme.md</a> ).  Here are the key commands for cloning a code: <br><br><pre><code class="swift hljs">mkdir swift-source cd swift-source git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/apple/swift.git ./swift/utils/update-checkout --clone</span></span></code> </pre> <br>  To describe the structure and dependencies of the project is used <a href="https://cmake.org/overview/">cmake</a> .  With it, you can generate a project for Xcode (more convenient) or under ninja (faster) by one of the commands: <br><br><pre> <code class="swift hljs">./utils/build-script --debug --xcode</code> </pre> <br>  or <br><pre> <code class="swift hljs">swift/utils/build-script --debug-debuginfo</code> </pre> <br>  Successful compilation requires the latest version of Xcode beta (10.2.1 at the time of this writing) - available on the <a href="https://developer.apple.com/download/more/">official Apple website</a> .  To use a new Xcode to build a project, you need to set the path using the xcode-select utility: <br><br><pre> <code class="bash hljs">sudo xcode-select -s /Users/username/Xcode.app</code> </pre> <br>  If we used the --xcode flag to build the project under Xcode, then after several hours of compilation (we had a little more than two) in the build folder, we will find the Swift.xcodeproj file.  Having opened the project, we will see the usual Xcode with indexing, breakpoints. <br><br>  To create a new tool, we need to add the code with the tool logic to the file: lib / IDE / Refactoring.cpp and define two methods isApplicable and performChange.  In the first method, we decide whether to display the refactoring option for the selected code.  And in the second - how to convert the selected code to apply refactoring. <br><br>  After the done preparation, it remains to implement the following steps: <br><br><ol><li>  Develop tool logic (development can be conducted in several ways - through the toolchain, through Ninja, through Xcode; all options will be described below) <br></li><li>  Implement two methods: isApplicable and performChange (they are responsible for accessing the tool and its work) <br></li><li>  Diagnose and test the finished tool before sending PR to Swift's official repository. <br></li></ol><br><h2>  Check tool operation through toolchain </h2><br>  This method of development will take a lot of time from you due to the long assembly of components, but the result is immediately visible in Xcode - the manual check path. <br><br>  To begin with, we will assemble the toolchain Swift with the command: <br><br><pre> <code class="plaintext hljs">./utils/build-toolchain some_bundle_id</code> </pre> <br>  Compiling the toolchain will take even more time than compiling the compiler and dependencies.  At the output we get the file swift-LOCAL-yyyy-mm-dd.xctoolchain in the swift-nightly-install folder, which needs to be transferred to Xcode: / Library / Developer / Toolchains /.  Next, in the IDE settings, select the new toolchain, restart Xcode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b67/402/ead/b67402ead1fd1e4470886c8a8ad2f3c2.png"><br><br>  Select the piece of code that should process the tool, and look for the tool in the context menu. <br><br><h2>  Development through tests with Ninja </h2><br>  If the project was compiled under Ninja and you chose the TDD path, then developing through tests with Ninja is one of the options that suits you.  Cons - you can not set breakpoints, as in the development through Xcode. <br><br>  So, we need to check that the new tool is displayed in Xcode when the user selects the guard construction in the source code.  We write the test in the existing file test / refactoring / RefactoringKind / basic.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testConvertToGuardExpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(idxOpt: Int?)</span></span></span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> idx = idxOpt {        <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(idx)    } } <span class="hljs-comment"><span class="hljs-comment">//     . // RUN: %refactor -source-filename %s -pos=266:3 -end-pos=268:4 | %FileCheck %s -check-prefix=CHECK-CONVERT-TO-GUARD-EXPRESSION // CHECK-CONVERT-TO-GUARD-EXPRESSION: Convert To Guard Expression</span></span></code> </pre> <br><br>  We indicate that when selecting a code between 266 row 3 columns and 268 row 4 columns, we expect the menu item to appear with a new tool. <br><br>  Using the <a href="https://github.com/apple/swift/blob/6fc4cef671947d1d2482951853f7f82854473d91/test/swift_test.py">lit.py</a> script can provide faster feedback to your development cycle.  You can specify the test suit.  In our case, this suite will be RefactoringKind: <br><br> <code>./llvm/utils/lit/lit.py -sv ./build/Ninja-RelWithDebInfoAssert/swift-macosx-x86_64/test-macosx-x86_64/refactoring/RefactoringKind/</code> <br>  As a result, only tests of this file will be launched.  Their implementation will take a couple of tens of seconds.  More about lit.py will be discussed below in the Diagnostics and Testing block. <br>  The test fails, which is normal for the TDD paradigm.  After all, so far we have not written a single line of code with the logic of the tool. <br><br><h2>  Debugging and Xcode Development </h2><br>  And finally, the last development method when the project was compiled under Xcode.  The main advantage is the ability to set breakpoints and control debugging. <br><br>  When building a project under Xcode, the file Swift.xcodeproj is created in the build / Xcode-DebugAssert / swift-macosx-x86_64 / folder.  When you first open this file, it is better to choose the creation of schemas manually in order to generate ALL_BUILD and swift-refactor yourself: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7d/7cb/458/f7d7cb4587c345d03bc77fc62cd615a9.png"><br><br>  Next, we build the project with ALL_BUILD once, after that we use the swift-refactor scheme. <br><br>  Refactoring tool is compiled into a separate executable file - swift-refactor.  Help about this file can be displayed using the ‚Äìhelp flag.  The most interesting parameters for us are: <br><br><pre> <code class="swift hljs">-source-filename=&lt;string&gt; <span class="hljs-comment"><span class="hljs-comment">//   -pos=&lt;string&gt; //   -end-pos=&lt;string&gt; //   -kind //  </span></span></code> </pre> <br>  They can be set in the schema as arguments.  Now you can set breakpoints to stop in places of interest when you start the tool.  In a familiar way, using the <i>p</i> and <i>po</i> commands in the Xcode console will display the values ‚Äã‚Äãof the corresponding variables. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/329/254/23c/32925423cba91d5951178b9be63a70d5.png"><br><br><h2>  Implementation isApplicable </h2><br>  The isApplicable method takes as input ResolvedRangeInfo with information about the AST nodes of the selected code fragment.  At the output of the method, it is decided whether or not to show the tool in the Xcode context menu.  The full ResolvedRangeInfo interface can be found in the <a href="">include / swift / IDE / Utils.h file</a> . <br><br>  Consider the most useful in our case, the fields of the class ResolvedRangeInfo: <br><br><ul><li>  RangeKind - the first step is to check the type of the selected area.  If the region is invalid (Invalid), you can return false.  If the type suits us, for example, SingleStatement or MultiStatement, then go ahead; <br></li></ul><br><ul><li>  ContainedNodes - an array of AST elements that belong to the selected range.  We want to make sure that the user selects the range that includes the if let construct.  To do this, take the first element of the array and check that this element corresponds to IfStmt (the class that defines the AST node of the statement of the if subtype).  Next, look at the condition.  To simplify the implementation, we will display the tool only for expressions with one condition.  Based on the type of the condition (CK_PatternBinding), we determine that this is let. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ba1/e70/e7fba1e70c05ada9602ba90164c67db8.png"><br><br>  To test isApplicable, add sample code to the file <a href="https://github.com/apple/swift/blob/master/test/refactoring/RefactoringKind/basic.swift">test / refactoring / RefactoringKind / basic.swift</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/663/046/0a1663046435877088f58d14329123f5.png"><br><br>  In order for the test to simulate a call to our tool, you need to add a line in the <a href="">tools / swift-refactor / swift-refactor.cpp</a> file. <a href="">&nbsp;</a><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a38/3a9/b3d/a383a9b3d80613dda377d5cd7f43411c.png"><br><br><h2>  Implement performChange </h2><br>  This method is called when selecting a refactoring tool in the context menu.  The method has access to ResolvedRangeInfo, as in isApplicable.  Use ResolvedRangeInfo and write the logic of the code conversion tool. <br><br>  When generating code for static tokens (regulated by the syntax of the language), entities from the namespace tok can be used.  For example, for the guard keyword, we use tok :: kw_guard.  For dynamic tokens (modified by the developer, for example, the name of the function) you need to select them from the array of AST elements. <br><br>  To determine where the inserted code is inserted, we use the full selected range using the RangeInfo.ContentRange construction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/893/d2b/c31/893d2bc311ceba6313fad5d474f6ea2e.png"><br><br><h2>  Diagnostics and Testing </h2><br>  Before you finish work on the tool, you need to check the correctness of his work again.  This will help us again tests.  Tests can be run one at a time or with all available options.  The easiest way to run the entire Swift test suite is with the --test command on utils / build-script, which will run the main test suite.  Using utils / build-script rebuilds all the target, which can significantly increase the debug cycle time. <br><br>  Be sure to run the utils / build-script --validation-test verification tests before making major changes to the compiler or API. <br><br>  There is another way to run all compiler unit tests through ninja, ninja check-swift from build / preset / swift-macosx-x86_64.  It will take about 15 minutes. <br><br>  And finally, an option when you need to run the tests separately.  To directly invoke the lit.py script from LLVM, it must be configured to use the local build directory.  For example: <br><br><pre> <code class="swift hljs">% $ {<span class="hljs-type"><span class="hljs-type">LLVM_SOURCE_ROOT</span></span>} /utils/lit/lit.py -sv $ {<span class="hljs-type"><span class="hljs-type">SWIFT_BUILD_DIR</span></span>} / test-macosx-x86_64 / <span class="hljs-type"><span class="hljs-type">Parse</span></span> /</code> </pre> <br>  This will run the tests in the 'test / Parse /' directory for 64-bit macOS.  The -sv option provides a test execution indicator and shows the results of only unsuccessful tests. <br><br>  Lit.py has several other useful features, such as timing tests and latency testing.  See these and other features with lit.py -h.  The most useful can be found <a href="">here</a> . <br><br>  To run one test we will prescribe: <br><br><pre> <code class="swift hljs"> ./llvm/utils/lit/lit.py -sv ./build/<span class="hljs-type"><span class="hljs-type">Ninja</span></span>-<span class="hljs-type"><span class="hljs-type">RelWithDebInfoAssert</span></span>/swift-macosx-x86_64/test-macosx-x86_64/refactoring/<span class="hljs-type"><span class="hljs-type">RefactoringKind</span></span>/basic.swift</code> </pre> <br>  If we need to tighten up the latest changes to the compiler, then we need to update all the dependencies and rebase.  To upgrade, run ./utils/update-checkout. <br><br><h2>  findings </h2><br>  We managed to achieve our goal - to make a tool that was not previously in the IDE to optimize work.  If you also have ideas on how to improve Apple products and make life easier for the entire iOS community, feel free to tackle the content-feeding, because it‚Äôs simpler than it seems at first glance! <br><br>  In 2015, Apple posted the open source Swift source codes, which made it possible to dive into the implementation details of its compiler.  In addition, local refactoring tools can be added with Xcode 9.  Basic C ++ knowledge and compiler devices are enough to make your favorite IDE a little more convenient. <br><br>  The described experience was useful for us - in addition to creating a tool that simplifies the development process, we got a really hardcore knowledge of the language.  Pandora's open box with low-level processes allows you to look at daily tasks from a new angle. <br><br>  We hope that the knowledge gained will also enrich your understanding of the development! <br><br>  The material was prepared in collaboration with <a href="https://habr.com/ru/users/victoriaqb/">@victoriaqb</a> - Victoria Kashlina, iOS developer. <br><br><h2>  Sources </h2><br><ol><li>  <a href="https://habr.com/ru/company/e-Legion/blog/438664/">Swift compiler device.</a>  <a href="https://habr.com/ru/company/e-Legion/blog/438664/">Part 2</a> <br></li><li>  <a href="https://www.polidea.com/blog/how-to-build-swift-compiler-based-tool-the-step-by-step-guide">How to Build Swift Compiler-Based Tool?</a>  <a href="https://www.polidea.com/blog/how-to-build-swift-compiler-based-tool-the-step-by-step-guide">The step-by-step guide</a> <br></li><li>  <a href="https://blog.digitalrickshaw-dev.com/2016/03/04/dumping-the-swift-ast-for-an-ios-project.html">Dumping the Swift AST for an iOS Project</a> <br></li><li>  <a href="https://swift.org/blog/sourcekitd-stress-tester/">Introducing the sourcekitd Stress Tester</a> <br></li><li>  <a href="">Testing swift</a> <br></li><li>  <a href="https://github.com/apple/swift/pull/24566/files">[SR-5744] If you‚Äôre guarding, let‚Äôs guard-let and vice versa # 24566</a> <br></li></ol></div><p>Source: <a href="https://habr.com/ru/post/460227/">https://habr.com/ru/post/460227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460213/index.html">How to buy a ticket as cheap as possible or strike monitoring on dynamic pricing</a></li>
<li><a href="../460215/index.html">Informatics specialists expand the boundaries of knowledge to be tested</a></li>
<li><a href="../460221/index.html">How to ask questions correctly if you are an aspiring beginner</a></li>
<li><a href="../460223/index.html">From the web and banks to iOS development: the personal experience of the Apiqa programmer</a></li>
<li><a href="../460225/index.html">About the standing table, spinal health and personal effectiveness</a></li>
<li><a href="../46023/index.html">Setting up Bluetooth PAN on Ubuntu 8.10</a></li>
<li><a href="../460231/index.html">OpenGear - reducing business downtime using console server with Out-of-Band control</a></li>
<li><a href="../460233/index.html">Game Cities: Skylines was Turing-complete: create a 4-bit adder</a></li>
<li><a href="../460237/index.html">Scammers on eBay (the story of one deception)</a></li>
<li><a href="../460239/index.html">How to get NextGen Firewall to your home absolutely free</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>