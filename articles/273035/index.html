<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate your application. PERFMATTERS !.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My rules 
 Every time I have a performance problem, I follow these rules: 


- Always measure - eye optimization is a bad idea. When you have watched ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate your application. PERFMATTERS !.</h1><div class="post__text post__text-html js-mediator-article"><h1>  My rules </h1><br>  Every time I have a performance problem, I follow these rules: <br><ul><li>  <b>Always measure</b> - eye optimization is a bad idea.  When you have watched the same animation several times, it seems to you that it runs faster.  The numbers do not lie.  Use the tools I‚Äôll talk about and measure the behavior of your application several times before and after making changes. </li><li>  <b>Use slow devices</b> - If you want to find all the weak points, slow devices will help you more.  New and productive devices will not show your potential performance problems and not all of your users have top devices. </li><li>  <b>Tradeoffs</b> - Performance Optimization entirely consists of tradeoffs.  You optimize one in exchange for another.  In many cases, this other trade-off can be time spent finding and correcting performance, it can also be the quality of your bitmap images or the amount of data you need to store in a particular data structure.  Get ready to sacrifice something. </li></ul><br><a name="habracut"></a><br><br><h1>  System Tracing (Systrace) </h1><br>  System tracing is one of the best tools that you may not use.  Because developers are not sure what to do with the data that it provides. <br><br>  System tracing shows an overview of what is happening on the phone.  This tool reminds us that the phone that we are holding in our hands is a powerful computer that can do many things at once.  In the latest SDK tool updates, this tool has been improved by generating hints from data, helping us to find problems.  Let's see what the trace file looks like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e02/990/60a/e0299060a73e4282a321acedb1af255c.png"><br><br>  You can generate a trace file using the Android Device Monitor tool.  For android Studio Tools&gt; Android&gt; Android Device Monitor. For Eclipse Window&gt; Perspectives&gt; DDMS, click the System Trace (Systrace) button on the panel.  Set the options and click OK.  More detail <a href="http://developer.android.com/tools/help/systrace.html">here</a> . <br><br>  Interesting Warnings (Alerts) and Frames (Frames), showing tips generated from the collected data.  Let's take a look at my tracing and select one of the warnings above: <br><br><img src="https://habrastorage.org/files/1fc/241/1cf/1fc2411cf8ff47e2bed0fba6e05f0ad6.png"><br><br>  The warning says that there was a long call to View # draw ().  We provide a description, links to documentation and even video links on relevant issues. <br><br>  Looking at the Frames column, we see below the designation of each rendered frame, which is colored green, yellow and red to indicate performance problems during the rendering of this frame.  Let's select one of the red frames. <br><br><img src="https://habrastorage.org/files/7d1/b76/7cb/7d1b767cb4ca40fdb578157caff2c6c2.png"><br><br>  Below we see all the warnings for this frame.  They were 3 and one of them we saw earlier.  Let's zoom in on this frame and expand the warning below: Filling in during the recycling ListView (‚ÄúInflation during ListView recycling‚Äù). <br><br><img src="https://habrastorage.org/files/95a/353/b50/95a353b50b6744dbaa012142359f513f.png"><br><br>  We see that this part was 32 milliseconds, and this is beyond the boundary of 16 milliseconds, the requirement for achieving 60 frames per second.  There is more time information for each item in the ListView in this frame ‚Äî about 6 milliseconds spent on each of the 5 items.  The description helps us understand the problem and even provides a solution.  On the graph above, we see the entire visualization and we can even increase a piece of the layout filling to view the views that took a lot of time when filling the layout. <br><br>  Another example of a slowly rendered frame: <br><br><img src="https://habrastorage.org/files/dfb/fe6/9ea/dfbfe69ea01c4758a1abce83a3b29a6b.png"><br><br>  After selecting a frame, we can press the m key to highlight it and see how long this part took.  Looking up, we see that the rendering of this frame took 19 milliseconds.  Expanding the warning, we will see that there was a delay of the schedule (‚ÄúScheduling delay‚Äù). <br><br>  Schedule latency means that the thread processing this part did not go to the processor queue for a long time.  Consequently, it took more time to complete the work of this thread.  Choosing a longer segment in this frame shows more specific information: <br><br><img src="https://habrastorage.org/files/846/7ed/7c5/8467ed7c59884fd5941bf6081f3d38e0.png"><br><br>  <b>Wall time (Wall duration)</b> is the time elapsed from the beginning to the end of this part of the frame.  It is so called because it is like looking at a wall clock from the beginning of the flow. <br><br>  <b>The processor</b> time is the time spent by the processor on processing this part. <br><br>  There is a big difference between wall time and processor time.  The first took 18 milliseconds, and the second 4 milliseconds.  Which is a bit strange, so now is the right time to see what the processor has been doing all this time: <br><br><img src="https://habrastorage.org/files/e73/f59/daf/e73f59dafde74781b5376bff321bc99e.png"><br><br>  All four cores were pretty busy.  Selecting one of the streams shows that the reason is the com.udinic.keepbusyapp application.  In this case, another application loaded the processor, refusing to allocate time to our application.  This scenario is usually temporary, as other applications in the background do not often take away the work of the processor, these threads can be a different process in your application or even your main thread.  Since the System Tracing (Systrace) survey tool is a limit to how far we can go.  To find the cause of what loads the processor in our application, we will use another Trace Viewer tool. <br><br><h1>  View Trace (Traceview) </h1><br>  View Trace analysis tool, showing the running time of each method.  Let's see what the trace file looks like: <br><br><img src="https://habrastorage.org/files/284/80d/873/28480d8737114cf689e804d49c7832e0.png"><br><br>  The tool can be run from Android Device Monitor or from code.  More details here.  <a href="http://developer.android.com/tools/debugging/debugging-tracing.html">developer.android.com/tools/debugging/debugging-tracing.html</a> <br><br>  Let's look at the various columns: <br><br>  <b>Name (Name)</b> - the name and color of the method on the chart. <br>  <b>Inclusive CPU Time (Inclusive CPU Time)</b> - the time the processor processes this method and its children (all the methods it calls) <br>  <b>Exclusive CPU Time</b> - The processor's time for processing this method, excluding the methods called inside it. <br>  <b>Inclusive / exceptional real time (Inclusive / Exclusive Real Time)</b> - time from the beginning to the end of the method operation.  Same as wall time in System Trace (Systrace). <br>  <b>Calls + Recursion (Calls + Recursion)</b> - the number of times the method was called and also the number of recursive calls. <br>  <b>Processor / Real time per Call (CPU / Real time Per Call)</b> - average Processor / Real time spent on the method call.  Other fields over time show the total time of all method calls. <br>  I opened the application in which the scrolling did not work smoothly and for a long time.  I started the tracing, scrolled a little and stopped the tracing.  I found the getView () method and opened it, this is what I saw: <br><br><img src="https://habrastorage.org/files/63d/be2/6c6/63dbe26c6bf34c108d203ed201e4a578.png"><br><br>  This method was called 12 times, the processor spent about 3ms for each call, but the actual time to complete each call was 162ms!  Of course this is a problem ... <br><br>  Looking at the children of this method, we see the distribution of time between different methods.  Thread.join () took 98% of the inclusive time.  We use this method when we need to wait for the completion of another thread.  One of the other children is Thread.start (), which suggests that the getView () method starts a thread and waits for it to end. <br><br>  But where is the flow? <br>  We cannot see what this thread did as a child of getView (), since getView () does not do this work directly.  To find this, I was looking for a method called Thread.run (), which is called when a new thread starts.  I followed on until I found the culprit: <br><br><img src="https://habrastorage.org/files/915/644/3de/9156443def8e43a8bd7413d901b64a82.png"><br><br>  I found out that the time to call the BgService.doWork () method took ~ 14ms, and we have 40 of them!  There is a chance that each getView () calls BgService.doWork () more than once and explains why each getView () call takes a long time.  This method loads the processor for a long time.  Looking at the exceptional processor time, we see that it used 80% of the total time in the trace.  Sorting by exceptional processor time is also a good way to find loaded methods in a trace.  They may be involved in your performance problem. <br><br>  The following critical methods, such as getView (), View # onDraw (), and others, help us find the reasons why our application is slow.  But sometimes, something else loads the processor, taking away valuable processor cycles, which could be spent on a smoother drawing of our interface.  The garbage collector runs arbitrarily, clearing unused objects and usually does not affect the application running in the foreground.  If the garbage collector starts up too often, it can cause brakes in the application and maybe this is our fault. <br><br><h1>  Memory Analysis (Memory Profiling) </h1><br>  Android Studio has been greatly improved lately with a large number of tools to help find performance problems.  The Memory tab in the Android window shows the amount of memory allocated in the heap over time.  Here's what she looks like: <br><br><img src="https://habrastorage.org/files/74b/d34/c0d/74bd34c0db194cfb94abae2fa432b6b1.png"><br><br>  When we see small drops in the graph, garbage collection occurs, removing unused objects and freeing up space on the heap. <br><br>  On the left side of the chart, there are two tools available: Heap Dump and Memory Allocation Tracker. <br><br><h1>  Heap dump </h1><br>  In order to consider what is now in the heap, we can use the heap dump button.  As a result, a snapshot of what is now in the heap is made, and it will show it in a special report screen in Android Studio: <br><br><img src="https://habrastorage.org/files/e6a/177/bef/e6a177bef51347aaaa6128166ba18f4c.png"><br><br>  On the left, we see a histogram of instances on the heap, grouped by class name.  For each instance, there is the number of objects in memory, the size of these instances (Shallow size) and the size of these objects stored in memory.  The latter tells us how much memory can be freed if these instances are released.  This view shows the amount of memory in our application, helping us identify large data structures and object associations.  This information can help us create more efficient data structures, freeing object connections to reduce allocated memory, and ultimately, reducing memory as much as possible. <br><br>  Looking at the histogram, we see that MemoryActivity has 39 instances, which is strange for activity.  Selecting one of the instances on the right, we will see all the links to this instance in the Link Tree below. <br><br><img src="https://habrastorage.org/files/01d/0ff/e53/01d0ffe531374d9f960e42b8e789b20c.png"><br><br>  One of these is part of an array of the ListenersManager object.  Looking at other instances of activity, we see that all of them are held by this object.  This explains why a single object of this class takes up so much memory. <br><br><img src="https://habrastorage.org/files/345/657/d51/345657d5117c4bbca4af27b61330f668.png"><br><br>  Such situations are commonly called Memory Leaks, since the activities were cleanly destroyed and this unused memory cannot be removed by the garbage collector due to this link.  We can avoid such situations by making sure that our objects are not referenced by other objects that exist longer.  In this situation, the ListenersManager should not keep this link after the activity has been destroyed.  The solution will be to remove this link before the activity is destroyed, in the onDestory () callback method. <br><br>  Memory leaks and other large objects take up a lot of space on the heap, reducing the available memory; as a result, the garbage collector will trigger a lot of events to attempt to free memory.  These garbage collector events take up the processor, which causes performance degradation in your application.  If the amount of available memory is not enough for the application and the heap can no longer grow, there will be a more dramatic result - OutOfMemoryException, which causes your application to crash. <br><br>  More advanced Eclipse Memory Analyzer Tool (Eclipse Memory Analyzer Tool): <br><br><img src="https://habrastorage.org/files/aeb/66c/988/aeb66c988d524233b2ece15665b1e41a.png"><br><br>  This tool can do the same as Android Studio, as well as identify potential memory leaks and provide an improved instance search, such as searching for all Raster images of more than 2Mb in size, or all <a href="http://kohlerm.blogspot.com/2009/04/analyzing-memory-usage-off-your-android.html">empty Rect objects</a> . <br><br>  Another great tool is the <a href="https://corner.squareup.com/2015/05/leak-canary.html">LeakCanary</a> library, which ensures that your objects do not have leaks.  You will receive a reminder of what happened and where. <br><br><img src="https://habrastorage.org/files/6a8/689/0fd/6a86890fd7864ab4a1123495748b1d8f.png"><br><br><br><h1>  Memory Allocation Tracker </h1><br>  The memory allocation tracker is started / stopped using other buttons to the left of the memory graph.  It will generate a report of all instances located in memory during this time interval, grouped by class. <br><br><img src="https://habrastorage.org/files/671/f37/040/671f370400b448e898adc72264c156de.png"><br><br>  or by the method: <br><br><img src="https://habrastorage.org/files/fce/fea/d4b/fcefead4befd4b66878cd16f6a4420cc.png"><br><br>  There is also a good visualization showing the largest instances in memory.  Using this information, we can find time-critical methods for which too much memory is allocated and they can trigger many garbage collector events.  We can also find many instances of a single class with a short lifespan, where we can decide to use a <a href="https://en.wikipedia.org/wiki/Object_pool_pattern">queue of objects</a> to reduce the total number of memory allocations. <br><br><h1>  General memory tips </h1><br>  Here are some quick tips / tutorials that I use when writing code: <br><br>  <b>Enums</b> are a hot topic for performance discussions.  There is a <a href="https://youtu.be/Hzs6OBcvNQE">Video</a> about it, showing the size of the enumeration, and a <a href="https://plus.google.com/%2BJakeWharton/posts/bTtjuFia5wm">discussion of</a> this video and some information in it that is misleading.  Do enumerations take up more memory than regular constants?  Of course.  This is bad?  Not necessary.  If you are writing a library and you need strict type safety, this may justify the use of enumerations instead of other solutions, such as <a href="https://developer.android.com/reference/android/support/annotation/IntDef.html">@IntDef</a> .  If you just have a bunch of constants that can be grouped together, then it may not be wise to use for this enumeration.  As always, there is a trade-off that needs to be taken into account when you make a decision. <br><br>  <b>Auto-boxing</b> - auto-packaging is an automatic conversion from primitive types to their object representation (for example, int -&gt; Integer).  Every time a primitive type is ‚Äúpacked‚Äù into an object representation, a new object is created (shock, I know).  If we have a lot of them, the garbage collector runs more often.  It is easy to skip the number of auto-packages that occur, because for us this happens automatically when an object of a primitive type is assigned.  The solution is to be consistent with these types.  If you use primitive types everywhere in your application, try to avoid their unreasonable autopacking.  You can use memory analysis tools to find many objects representing primitive types.  You can also use Trace Browsing and search for Integer.valueOf (), Long.valueOf (), etc. <br><br>  <b>HashMap vs. ArrayMap / Sparse * Array</b> - as well as the problem of autopacking, using HashMap requires us to use objects as keys.  If we use the primitive type ‚Äúint‚Äù in the application and it auto-package in Integer when interacting with HashMap, maybe we can just use SparseIntArray.  In case we still need keys in the form of objects, we can use the ArrayMap class.  It is similar to HashMap, but <a href="https://www.youtube.com/watch%3Fv%3DORgucLTtTDI">it works differently inside</a> , using memory more efficiently, but reducing its speed.  These two options have less memory than HashMap, but it takes more time to get items or allocate memory than HashMap.  If you have less than 1000 items, the difference is not noticeable when the program is executed, which makes them not a bad option for your use of key / value pairs. <br>  <b>Context Awareness</b> - as shown earlier, it is easy to create a memory leak in activities.  You may not be surprised that the activity is the most common case of leaks to Android (!).  Also, these leaks are very expensive, as they contain the entire hierarchy of the user interface, which in itself can take up a lot of space.  Many operations on the platform require a Context object, and you usually send an Activity.  Make sure you understand what is happening with this Activity.  If the link to it is cached, and this object lives longer than the Activity itself, without removing this link, then you have a memory leak. <br><br>  <b>Avoid non-static inner classes</b> ; their initialization creates an implicit reference not an outer class.  If an instance of an inner class object needs more time than an outer one, then the outer class will remain in memory, even if it is no longer needed.  For example, creating a non-static class in the Activity class that is inherited from AsyncTask, then launch AsyncTask, and during its operation kill activity.  This AsyncTask will keep this activity until it finishes its work.  Decision- do not do so, declare a static inner class if necessary. <br><br><h1>  Graphic Processor Analysis (GPU Profiling) </h1><br>  A new addition to Android Studio 1.4, a tool for analyzing graphics processor rendering. <br><br>  In the Android window, go to the GPU tab, and you will see a graph showing the time each frame is drawn on your screen: <br><br><img src="https://habrastorage.org/files/23f/d3b/42c/23fd3b42c1434a149a3ca8003d9e9b3c.png"><br><br>  Each bar on the graph represents one rendered frame, and the colors represent different phases in the drawing process: <br><br>  <b>Drawing (blue)</b> - represents the View # onDraw () method.  This part creates / updates DisplayList objects (In Wikipedia, the display list (or display file) is a sequence of graphic commands that define the output image that is later converted to OpenGL commands that the graphics processor understands. Large values ‚Äã‚Äãmay be due to complex views that require more time to create their display lists, or if many views are canceled in a short amount of time. <br><br>  UI Thread Prep The UI <b>Prepare (purple)</b> - In Lollipop  Preparation (purple) - another stream has been added to Lollipop to help the interface flow draw the interface faster.  This thread is called RenderThread.  He is responsible for converting display lists to OpenGL commands and sending them to a graphics processor.  At this time, the UI thread can continue processing the next frame.  In this step, the time is shown for which the UI thread transfers all resources to the RenderThread stream.  If we have a lot of resources to transfer, for example, many display lists or they are large, this step may take longer. <br><br>  <b>Process (red)</b> ‚Äîexecute display lists to create OpenGL commands.  This step may take longer if there are a lot of display lists or display lists that are complex, due to the need to redraw many views.  A view can be redrawn due to a cancellation, or it appears when the imposed view shifts. <br><br>  <b>Execution (yellow)</b> - sending OpenGL commands to the graphics processor.  This part is a blocking call, since the processor sends a buffer with these commands to the graphics processor, expecting to get a clean buffer for the next frame.  The number of buffers is limited, and if the graphics processor is too busy, the processor will wait for the graphics processor to become free.  Therefore, if at this step we see large values, perhaps this means that the graphics processor was too busy drawing our interface, which is probably too difficult to draw in a short time. <br><br>  In Marshmallow, more colors have been added to indicate new steps, such as Measurement / Layout, input processing, and others: <br><br><img src="https://habrastorage.org/files/711/785/9b3/7117859b3376483caa15c4463fe75f37.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before using this feature, you must enable graphics processor drawing from developer options: </font></font><br><br><img src="https://habrastorage.org/files/5a2/bd9/aa1/5a2bd9aa1e394d5592293106b6629cda.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will allow the tool to use ADB commands to get the necessary information, so we use: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can get all of this data and ourselves make a schedule. The command shows other useful information, such as the number of views in the hierarchy, the size of all display lists, and more. In Marshmallow, we can see even more statistics.</font></font><br><br><img src="https://habrastorage.org/files/87b/407/e02/87b407e022934942b8e85c7521a20c39.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have an automatic interface testing, we can make our build server run this command after certain interactions (list scrolling, heavy animations, etc.) and see if there are changes in values ‚Äã‚Äãover time, such as redundant frames. This can help identify performance problems after pushing some commits, giving us time to identify the problem before the application goes into production. We can even get more accurate rendering information using the ‚Äúframestats‚Äù keyword, as </font><font style="vertical-align: inherit;">explained </font></font><a href="https://developer.android.com/preview/testing/performance.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is not the only way to see this chart!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you saw in the developer options in the ‚ÄúProfile GPU Rendering‚Äù section, there is an option to view the graph as ‚ÄúStripes on the screen‚Äù. Turning it on will show a graph for each window on our screen, along with a green bar to determine the threshold of 16 ms. </font></font><br><br><img src="https://habrastorage.org/files/a03/bfe/1fd/a03bfe1fdec64b518e8382cd6fcfed97.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example to the right, we see some frames crossed the green line, which means that it took more than 16ms to draw them. So on these strips the blue color prevails, we understand that either there were many views for drawing or they were complex or both. In this scenario, I scrolled through a list of news feeds that support various types of views. Some views have been canceled, and some are harder to draw than others. A possible reason for some frames to cross this threshold is that there is a complex view to render at the moment.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hierarchy Viewer </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I love this tool, and it saddens me that many do not use it at all! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the Hierarchy Browser, we can get performance statistics, see the full view hierarchy on the screen, and have access to all view properties. </font><font style="vertical-align: inherit;">You can also get a dump of the theme data, see all the values ‚Äã‚Äãused for each style attribute, but this is only available when you launch the Hierarchy Browser as a separate application, not from the Android Monitor. </font><font style="vertical-align: inherit;">I use this tool when designing my layouts and when I want to optimize them.</font></font><br><br><img src="https://habrastorage.org/files/09c/e2d/27a/09ce2d27a27644ba9bd23d073cf30a97.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the center we see a tree representing the hierarchy of views. The view hierarchy may be broad, but if it is too deep (about 10 levels), the cost may be costly layout / metering phases. Whenever a view is measured, in View # onMeasure () or when it has all child views, in View # onLayout (), these commands apply to child views that repeat the same actions. Some layouts repeat each step twice, for example, RelativeLayout and some LinearLayout configurations, and if they are nested, the number of passes increases exponentially. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below on the right we see the ‚Äúdrawing‚Äù of our layout, marking the location of each view. We can select a view here or in a tree and see all its properties on the left.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I create a layout, sometimes I'm not sure why a particular view ended where it is now. Using this tool, I can track it in the tree, select it and see where it is in the preview window. Looking at the final measurements of the views on the screen, I can create interesting animations and use this information to move things neatly. I can find lost views that other views have inadvertently overlapped with, and much more.</font></font><br><br><img src="https://habrastorage.org/files/831/039/2d9/8310392d99bb453186f79e9e4333fc63.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each view, we have the time of its measurement / layout / rendering and all its child views. </font><font style="vertical-align: inherit;">The colors indicate how this view is presented compared to other views in the tree; this is a good way to find the weakest link. </font><font style="vertical-align: inherit;">Since we also see a preview of this view, we can walk around the tree in steps to create it, finding redundant steps that we can remove. </font><font style="vertical-align: inherit;">One of the things that have a big impact on performance is called Overdraw.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overdraw </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you saw in the Graphical Processor Analysis GPU (Profiling) section - phase The execution represented in yellow on the graph may take longer to complete if the graphics processor needs to draw a lot of objects on the screen, increasing the rendering time of each frame. Overlays occur when we draw one on top of another, for example a yellow button on a red background. The graphics processor must first draw a red background and then a yellow button on top, making overlaying inevitable. If we have many layers of overlay, this causes the graphics processor to work more and be farther from the target of 16 ms.</font></font><br><br><img src="https://habrastorage.org/files/628/939/a01/628939a01754407db1d5a48bab8cd1b0.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the item ‚ÄúDebugging GPU Overlays‚Äù in the Developer options, all overlays will be colored to indicate the complexity of the overlay in this area. Overlaying 1x / 2x is normal, even some light red areas are fine, but if we see too much red on the screen, this can be a problem. Let's look at a few examples: </font></font><br><br><img src="https://habrastorage.org/files/54f/d8f/4ce/54fd8f4ce04747a8b5a5d2278ced1d63.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example on the left, the list is drawn in green, which is usually good, but there is an overlay on top that makes it red and this is a problem. In the example on the right, the entire list is in red. In both cases, there is an opaque list with a 2x / 3x overlay. These overlays can be in case there is a full-screen background color in the window containing your Activity / Fragment, list and and each list item. This problem can be solved by setting the background color for only one of them.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: The default theme declares a full-screen background color for your window. </font><font style="vertical-align: inherit;">If your activity has an opaque layout that occupies the entire screen, you can remove the background of the window to remove a single overlay layer. </font><font style="vertical-align: inherit;">You can do this in a thread or in code by calling getWindow (). SetBackgroundDrawable (null) in onCreate (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the Hierarchy Browser, you can export all layers of the hierarchy to a PSD file and open it in Photoshop. </font><font style="vertical-align: inherit;">Examining the different layers in Photoshop will reveal all the overlays in the layout. </font><font style="vertical-align: inherit;">Use this information to remove redundant overlays, and do not be content with green, seek blue!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alpha </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of transparency can affect performance in order to understand why, let's see what happens when the alpha view is set. </font><font style="vertical-align: inherit;">Consider the following layout: </font></font><br><br><img src="https://habrastorage.org/files/2da/147/4dc/2da1474dceeb4f29af97ecfa71087d5e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We see a layout containing 3 ImageViews superimposed on each other. </font><font style="vertical-align: inherit;">In the direct / simple implementation, setting the alpha using the setAlpha () command is passed to all child views, ImageViews in this case. </font><font style="vertical-align: inherit;">Then, these ImageViews will be drawn with this alpha value in the frame buffer.</font></font> Result: <br><br><img src="https://habrastorage.org/files/fe8/b62/f0e/fe8b62f0e5cf4fd8aa85213e7f852709.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not want to see it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the ImageView is rendered with the alpha value, all the overlay images are mixed together. </font><font style="vertical-align: inherit;">Fortunately, the operating system has a solution to this problem. </font><font style="vertical-align: inherit;">The layout will be copied to an off-screen buffer, alpha will be applied to the entire buffer and the result will be copied to the frame buffer.</font></font> Result: <br><br><img src="https://habrastorage.org/files/c06/776/0f5/c067760f50924dfa891e6b3630b5f466.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we paid the price for it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drawing a view in an off-screen buffer, before drawing it in the frame buffer, is the virtual addition of another undefined overlay layer. </font><font style="vertical-align: inherit;">The operating system does not know exactly when to apply this approach or the direct approach shown earlier, thus making the default more complex. </font><font style="vertical-align: inherit;">But there are still ways to set the alpha and avoid the complexity added by the screen buffer:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TextViews - Use setTextColor () instead of setAlpha (). </font><font style="vertical-align: inherit;">Using the alpha channel for the text color leads to a direct drawing of the text using this channel.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageView - Use setImageAlpha () instead of setAlpha (). </font><font style="vertical-align: inherit;">Same reason as for TextView.</font></font></li><li>   ‚Äî       ,       .       ,     .   hasOverlappingRendering()  false,       /    .         ,   onSetAlpha()  true. </li></ul><br><br><h1>  (Hardware Acceleration) </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the hardware acceleration was introduced in Honeycomb, we had a </font></font><a href="http://developer.android.com/guide/topics/graphics/hardware-accel.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new drawing model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for drawing our application on the screen. It introduced DisplayList structures that write view drawing commands for fast rendering. But there is another super feature that developers sometimes miss or do not use correctly - the View layers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the view layer, we can draw the view in an off-screen buffer (as you saw earlier using the Alpha channel) and process as needed. This feature is mainly good for animations, since we can animate complex views faster. Without animation layers, the view cancels it after changing the animated property (for example, x coordinates, scale, alpha value, etc.). For complex views, this cancellation is sent to all child views, and they will then redraw themselves by performing an expensive operation. I use the layer of the view provided by the Hardware, the texture for our view is created in the graphics processor. There are several operations that we can apply to this texture without canceling it, such as x / y position, rotation, alpha, and others. It all meansthat we can animate a complex view without even canceling it during the animation! This makes the animation smoother. Here is an example of how to do this:</font></font><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Object animator view.setLayerType(View.LAYER_TYPE_HARDWARE, null); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 20f); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { view.setLayerType(View.LAYER_TYPE_NONE, null); } }); objectAnimator.start(); //   (Property animator) view.animate().translationX(20f).withLayer().start();</span></span></code> </pre> <br>  Really simple? <br><br>  Yes, but you need to remember a few things when using hardware layers: <br><br><ul><li>  <b>Clean</b> up your view - hardware layers consume space on your graphics processor, a component with limited memory.  Try and use them only when they are needed, for example, in animation, and then clean them.  In the ObjectAnimator example above, I applied a listener to remove the layer after the animation ends.  In the example of the animator Properties, I used the withLayers () method, which automatically creates a layer at the beginning and deletes it at the end of the animation. </li><li>  If you <b>change your view</b> after applying a hardware layer, it will invalidate the hardware layer and re-draw the entire view into the external screen buffer.  This will happen after changing a property that is not optimized for hardware layers (the following are now optimized: rotation, scaling, x / y, movement, rotation point and alpha. For example, if you animate a view with support for the application layer, changing the background color during its movement along screen, will lead to constant updates of the hardware layer. Updating the hardware layer has overhead costs, from which you probably should not use it. </li></ul><br><br>  For the second problem, there is a way to display these hardware layer updates.  Using Developer options, we can enable "Show updates to the hardware layer." <br><br><img src="https://habrastorage.org/files/cfa/3fd/d84/cfa3fdd849d347bd9e1f0ad486e39a57.png"><br><br>  When it is turned on, the View view glows green when the hardware layer is updated.  I used it once when my ViewPager didn't scroll as smoothly as I expected.  After enabling this developer option, I went ahead and ran the ViewPager, and this is what I saw: <br><br><img src="https://habrastorage.org/files/7c1/0cb/d19/7c10cbd1951943bca07871ad035e80a1.gif"><br><br>  During the entire scroll, both pages were green! <br><br>  This means that a hardware layer was created for them, and the pages were canceled while scrolling through the ViewPager.  I updated the scrolling of pages using the parallax effect on the background and gradually animated objects on the page.  However, I did not create a hardware layer for the ViewPager pages.  After reading the ViewPager source code, I found that after the user started scrolling, a hardware layer is created for both pages and is deleted after the scrolling stops. <br><br>  While it makes sense to create a hardware layer for the pages while scrolling, for me it was bad.  Usually, these pages do not change when the ViewPager scrolls, and since they can be quite complex, the hardware layers help draw them quickly enough.  It was not a case for my application, and I had to remove this hardware level using the <a href="http://blog.udinic.com/2013/09/16/viewpager-and-hardware-acceleration">small hack I wrote</a> . <br><br>  The hardware layers are not silver bullet.  It is important to understand how they work and how to use them correctly, or you may experience a more significant problem. <br><br><h1>  DIY (DIY) </h1><br>  While preparing for all these examples, I wrote a lot of code to simulate these situations.  You can find weight in this <a href="https://github.com/Udinic/PerformanceDemo">Github repository</a> and also on <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.udinic.perfdemo">Google Play</a> .  I divided different scenarios into different activities, and documented as far as possible to understand what types of problems you can find using this Activity.  Read the Activities javadoc, open the tools and play with the application. <br><br><h1>  Additional Information </h1><br>  With the development of the Android OS, ways are being developed to optimize your applications.  New tools are presented with the Android SDK and new features added to the OS (such as hardware layers).  It is important to stay abreast of the latest changes and consider trade-offs before changing something. <br><br>  YouTube has a super <a href="https://www.youtube.com/playlist%3Flist%3DPLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Android</a> Playlist <a href="https://www.youtube.com/playlist%3Flist%3DPLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Patterns (Android Performance Templates)</a> , with a large number of short videos from Google‚Äôs engineers, explaining various topics related to performance.  You can find a comparison of various data structures (HashMap vs ArrayMap), optimization of bitmap images and even optimization of network requests.  I highly recommend viewing them all. <br><br>  Join the <a href="https://plus.google.com/communities/116342551728637785407">Google+ Android Performance Patterns community</a> and talk about performance with others, including Google‚Äôs engineers, share ideas, articles and questions. <br><br>  More interesting links: <br><br><ul><li>  Learn how <a href="http://source.android.com/devices/graphics/architecture.html">Architecture Graphics</a> works <a href="http://source.android.com/devices/graphics/architecture.html">on Android</a> .  it has everything about how Android draws your interface, explaining various system components, such as SurfaceFlinger, and how they communicate with each other.  It's a long read, but worth it. </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DQ8m9sHdyXnE">A conversation with Google IO 2012</a> , showing how the drawing model works and how the brakes occur when our interface is rendered. </li><li>  Talk Android Performance Workshop with Devoxx 2013, showing some of the optimizations made in Android 4.4 for the drawing model, and showing various tools to optimize performance (System tracing, Overlay, etc.) </li><li>  Excellent article on <a href="https://medium.com/google-developers/the-truth-about-preventative-optimizations-ccebadfd3eb5">Preventative Optimizations</a> , and how they differ from immature (Premature) optimizations.  Many developers do not optimize parts of their code, as they think the changes will be minor.  One thing to keep in mind is that if everything is folded up, a <a href="https://plus.google.com/105051985738280261832/posts/YDykw2hstUu">big problem</a> can arise.  If you have the opportunity to optimize a small part that seems insignificant, do not neglect it. </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D_CruQY55HOk">Memory management in Android</a> is an old video from Google IO 2011, which is still relevant.  It shows how Android manages the memory of your applications, and how to use tools like Eclipse MAT to find problems. </li><li>  <a href="http://www.curious-creature.com/docs/android-performance-case-study-1.html">Case study of</a> popular twitter client optimization done by Google engineer Romain Guy.  In this case study, Romain shows how to find performance problems in an application, and what he recommends doing to solve them.  There is a <a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/">subsequent post</a> showing the problems of the same application after its alteration. </li></ul><br><br>  I hope you now have enough information and confidence to start optimizing your applications today! <br><br>  Just start by running a trace, or turn on some of the relevant developer options. <br><br><img src="https://habrastorage.org/files/6a9/6af/b58/6a96afb58cf6459ca6d50976217c3e26.png"><br><br>  <b>Posted by Udi Cohen.</b> <br>  Original <a href="http://blog.udinic.com/2015/09/15/speed-up-your-app">blog.udinic.com/2015/09/15/speed-up-your-app</a> <br></div><p>Source: <a href="https://habr.com/ru/post/273035/">https://habr.com/ru/post/273035/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273019/index.html">Separate medical data storage and regional information systems</a></li>
<li><a href="../273021/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ189 (December 6 - 13, 2015)</a></li>
<li><a href="../273023/index.html">Full translation of Unix-koans into Russian</a></li>
<li><a href="../273025/index.html">What is BPMS</a></li>
<li><a href="../273027/index.html">Browser extension from Yandex</a></li>
<li><a href="../273037/index.html">Interactive C #</a></li>
<li><a href="../273039/index.html">Evolution in the cloud: the experience of the service to work with social networks</a></li>
<li><a href="../273043/index.html">On the effectiveness of Rutreker's ‚Äúteachings‚Äù</a></li>
<li><a href="../273045/index.html">Python internal list</a></li>
<li><a href="../273047/index.html">How to squeeze a flat cat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>