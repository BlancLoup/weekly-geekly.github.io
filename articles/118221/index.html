<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Speeding Stackoverflow.com</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Approximately, 3 weeks ago I read in habre in this topic about Dapper - ORM from one of the leading developers of the popular site Stackoverflow . The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Speeding Stackoverflow.com</h1><div class="post__text post__text-html js-mediator-article">  Approximately, 3 weeks ago I read in habre in this <a href="http://habrahabr.ru/blogs/net/116862/">topic</a> about <a href="http://code.google.com/p/dapper-dot-net/">Dapper</a> - <a href="http://ru.wikipedia.org/wiki/ORM">ORM</a> from one of the leading developers of the popular site <a href="http://stackoverflow.com/">Stackoverflow</a> .  The name of this superhero is <a href="http://samsaffron.com/">Sam Saffron</a> (hereinafter <a href="http://samsaffron.com/">referred</a> to simply as Sam).  In addition, before this topic appeared on Stackoverflow, it was known that it used <a href="http://msdn.microsoft.com/ru-ru/library/bb386976.aspx">Linq-to-Sql</a> .  This is the main reason why I, like other developers, began to study the source code of Dapper.  As it turned out, it is a little, or rather just one file.  Carefully reviewing it, I wondered if it could be done even faster.  It was not easy to accelerate Sam‚Äôs code, it was written too qualitatively.  Next, I will describe my micro-optimizations in the form of advice to other developers.  But first I want to warn some developers.  This optimization accelerated Dapper by 5% and this is significant for a project like Stackoverflow, but it may not be significant for your project.  Therefore, <b>always consider the option of macro-optimization (examples at the end of the topic) according to the results of profiling</b> and resort to micro-optimization only in special cases. <br><br><a name="habracut"></a><br><h5>  Always use the minimum contract. </h5><br>  Strictly speaking, this only makes the code more qualitative and resistant to changes, but does not speed up its execution.  Sometimes the desired contract is easy to determine, and sometimes not.  For example, if there is no point in returning IList, if the rest of the code performs a simple iteration over the collection.  Just return an IEnumerable.  The choice in favor of this interface allowed Sam to use the return <a href="http://msdn.microsoft.com/ru-ru/library/9k7k7cf0.aspx">yield</a> construct in the next version: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;T&gt; ExecuteMapperQuery&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IDbConnection con, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sql, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> param = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, SqlTransaction transaction = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = GetReader(con, transaction, sql, GetParamInfo(param))) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> identity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Identity(sql, con.ConnectionString, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deserializer = GetDeserializer&lt;T&gt;(identity, reader); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.Read()) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reader</span></span></span><span class="hljs-function">)</span></span>; } } }</code> </pre> <br>  As an unobvious choice, we note the <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idatareader.aspx">IDataReader</a> interface.  Sam often uses the <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idatarecord.fieldcount.aspx">FieldCount</a> property for objects that support this interface.  Although, if you carefully examine the full hierarchy of interfaces, you can see that the FieldCount actually belongs to the <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idatarecord.aspx">IDataRecord</a> interface. <br><br><h5>  Consider deleting a contract. </h5><br>  This advice is a consequence of the previous one, so we will not dwell on it in detail.  Sometimes the contract is so minimal that it can be safely removed.  In the example below, instead of <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idbconnection.aspx">IDbConnection,</a> you could just pass a string: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Identity</span></span> : <span class="hljs-title"><span class="hljs-title">IEquatable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Identity</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> connectionString; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Identity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sql, IDbConnection cnn, Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... this.connectionString = cnn.ConnectionString; // ... } }</span></span></code> </pre><br><h5>  Learn to predict </h5><br>  Sounds a little weird, doesn't it?  However, I am talking here about the definition of the logical behavior of the algorithm.  Predictions are accurate and inaccurate.  Consider inaccurate first  Here you can not say with certainty how and what will be.  For example, in Dapper the dictionary of the well-known types is filled.  We know that when a certain amount is reached, the dictionary will need time to increase its size in case the user adds new elements.  What prediction can we make in this case?  Simple - recalculate all types and tell the dictionary how much memory we need right away.  I got 35: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlMapper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;Type, DbType&gt; typeMap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SqlMapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... TypeMap = new Dictionary&lt;Type, DbType&gt;(35); TypeMap[typeof(byte)] = DbType.Byte; // ... } }</span></span></code> </pre><br>  And what is the inaccuracy?  The fact that this number is highly dependent on changes and when adding a new type, it will be invalid.  Of course, nothing terrible will happen, but the code becomes more unreliable, and the prediction is wrong. <br>  Accurate predictions are very good and you need to use them wherever possible.  A vivid example of such a prediction is to replace the list with an array, when the number of elements is precisely known.  The main reason is the same as for the dictionary.  Namely, the redistribution of memory.  Another significant reason is that the indexing operation in an array works much faster than calling the Add method on a list.  This is clearly seen in the code generation example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, List&lt;ParamInfo&gt;&gt; CreateParamInfoGenerator(Type type) { DynamicMethod dm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod(<span class="hljs-string"><span class="hljs-string">"ParamInfo"</span></span> + Guid.NewGuid().ToString(), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(List&lt;ParamInfo&gt;), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) }, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dm.GetILGenerator(); <span class="hljs-comment"><span class="hljs-comment">// ... il.Emit(OpCodes.Newobj, typeof(List&lt;ParamInfo&gt;).GetConstructor(Type.EmptyTypes)); //   foreach (var prop in type.GetProperties().OrderBy(p =&gt; p.Name)) { // ... il.Emit(OpCodes.Callvirt, typeof(List&lt;ParamInfo&gt;).GetMethod("Add", BindingFlags.Public | BindingFlags.Instance)); //   Add } // ... }</span></span></code> </pre><br>  And for the array: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, IEnumerable&lt;ParamInfo&gt;&gt; CreateParamInfoGenerator(Type type) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod(<span class="hljs-string"><span class="hljs-string">"ParamInfo"</span></span> + Guid.NewGuid(), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IEnumerable&lt;ParamInfo&gt;), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) }, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dm.GetILGenerator(); <span class="hljs-comment"><span class="hljs-comment">// ... var properties = type.GetProperties(); il.Emit(OpCodes.Ldc_I4_S, properties.Length); il.Emit(OpCodes.Newarr, typeof(ParamInfo)); //   PropertyInfo prop; for (var i = 0; i &lt; properties.Length; i++) { prop = properties[i]; // ... EmitInt32(il, i); //      // ... il.Emit(OpCodes.Stelem_Ref); //     } // ... }</span></span></code> </pre><br><h5>  Reduce the use of reflection </h5><br>  The advice is obvious and everyone knows that reflection is an extremely slow mechanism.  Sam is also known and he uses code generation to speed up work with the methods and properties of objects (in this case, I am against manual generation and I consider expression trees to be a worthy substitute).  There is also the second generally accepted way of dealing with the costs of reflection - caching.  In Dapper, a deserializer is created for each class.  In the creation code you can find the line: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getItem = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDataRecord).GetProperties(BindingFlags.Instance | BindingFlags.Public) .Where(p =&gt; p.GetIndexParameters().Any() &amp;&amp; p.GetIndexParameters()[<span class="hljs-number"><span class="hljs-number">0</span></span>].ParameterType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) .Select(p =&gt; p.GetGetMethod()).First();</code> </pre><br>  Obviously, this information can be cached.  Move getItem to the class level and initialize in a static constructor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Double check circuit </h5><br>  Most often, programmers create closures (for those who have never met with them in C #, I recommend following this <a href="">link</a> ) not consciously, and they pay them with unexpected errors (Sam also got caught!).  However, closures can be used to accelerate.  Example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDynamicDeserializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDataReader reader</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; colNames = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reader.FieldCount; i++) { colNames.Add(reader.GetName(i)); } Func&lt;IDataReader, ExpandoObject&gt; rval = r =&gt; { IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; row = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandoObject(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> colNames) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = r.GetValue(i); row[colName] = tmp == DBNull.Value ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : tmp; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ExpandoObject)row; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rval; }</code> </pre><br>  As you can see in the lambda expression, a closure to the local variable colNames is created to speed up the getting of the column names.  Theoretically, this can give a performance boost.  After all, the name of the columns does not change when we iterate through all the entries in the IDataReader.  Unfortunately, for example, the developers of <a href="http://msdn.microsoft.com/ru-ru/library/system.data.sqlclient.sqldatareader.aspx">SqlDataReader</a> also thought about it and stored the name of the columns in a similar array inside the class, so the following code will be similar to the previous one, but without the closure: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Func&lt;IDataRecord, ExpandoObject&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDynamicDeserializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r =&gt; { IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; row = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandoObject(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; r.FieldCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = r.GetValue(i); row[r.GetName(i)] = tmp == DBNull.Value ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : tmp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ExpandoObject)row; }; }</code> </pre><br><h5>  Avoid multiple concatenation operations for strings. </h5><br>  Yes, I'm aware that every .Net developer knows that you need to use a <a href="http://msdn.microsoft.com/ru-ru/library/system.text.stringbuilder.aspx">StringBuilder</a> to build a string from several strings.  But a few lines is how much?  For two or three strings, creating a StringBuilder can be wasteful.  Example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IDbCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDbConnection cnn, IDbTransaction tranaction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sql, List&lt;ParamInfo&gt; paramInfo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... cmd.CommandText = cmd.CommandText.Replace("@" + info.Name, "(" + string.Join( ",", Enumerable.Range(1, count).Select(i =&gt; "@" + info.Name + i) ) + ")"); // ... }</span></span></code> </pre><br>  We are interested in a string that is formed as "@" + info. Name + i.  This is the <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idbcommand.aspx">IDbCommand</a> parameter <a href="http://msdn.microsoft.com/ru-ru/library/system.data.idbcommand.aspx">name</a> .  And for each such name three lines are created in memory.  If the parameter we called text, the lines would look like this: <br><pre> <code class="cs hljs">@ @text @text1</code> </pre><br>  In principle, a little, but for 5 parameters we will have 15 lines.  Time for StringBuilder?  No, probably not.  After analyzing the rest of the code, you can see that the "@" + info.Name construction is used very often, so we replace it with the variable infoName.  So we will save on lines and additionally on reversing the property.  As a result, for 5 parameters there are only 6 lines (one for infoName and one for each concatenation operation). <br><br>  I could go on and talk about such trivial things as defining variables as close as possible to the place of their use or, on the contrary, moving them out of cycles, discarding unnecessary branches in an if-else statement, embedding short methods at the place of their use.  But I'd rather talk about macro-optimizations.  Sam is now working to speed up the addition of parameters to the IDbCommand.  As an outside observer, I can advise you to pay attention to the reuse of commands and their preparation (this works fine for the <a href="http://msdn.microsoft.com/ru-ru/library/system.data.sqlclient.sqlcommand.aspx">SqlCommand</a> and <a href="http://msdn.microsoft.com/ru-ru/library/system.data.sqlclient.sqlcommand.prepare.aspx">Prepare</a> method). <br><br>  Perhaps, when Dapper moves to from a working state to a release, I will make another review, but for now I will closely monitor this project and wish good luck to Sam. <br><br>  PS: The author tried to fulfill his civic duty and sent a Pull Request to <a href="https://github.com/">GitHub</a> , but, unfortunately, while the author was writing a topic for Habr, Sam developed Dapper and the request became irrelevant.  However, the author wrote to Sam and he promised to take into account all the wishes in the release of Dapper. </div><p>Source: <a href="https://habr.com/ru/post/118221/">https://habr.com/ru/post/118221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118214/index.html">Your video on Yandex. Video</a></li>
<li><a href="../118216/index.html">SETI stops a large radio telescope complex due to lack of funds</a></li>
<li><a href="../118218/index.html">Commentary of the day: As Oracle predicted</a></li>
<li><a href="../118219/index.html">Content farm site traffic has dropped significantly since the introduction of the new Google search algorithm.</a></li>
<li><a href="../118220/index.html">DropBox will provide decrypted copies of your files to the government upon request.</a></li>
<li><a href="../118222/index.html">VKontakte launched video ads</a></li>
<li><a href="../118226/index.html">Dingoo A320 vs Gemei A330 - unboxing</a></li>
<li><a href="../118229/index.html">DEVCONF 2011 - more than 44 reports have been announced, the registration of ‚Äúearly birds‚Äù ends in April</a></li>
<li><a href="../118230/index.html">"Thanks, Eva! will help you earn on YouTube</a></li>
<li><a href="../118232/index.html">Spring Update "Tutumba"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>