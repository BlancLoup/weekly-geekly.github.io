<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is there with JEP-303 or invent invokedynamic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloggers and authors who are trying to be at the forefront have already written a lot about the Amber project in Java 10. These articles always mentio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is there with JEP-303 or invent invokedynamic</h1><div class="post__text post__text-html js-mediator-article"><p>  Bloggers and authors who are trying to be at the forefront have already <a href="https://www.sitepoint.com/project-amber-will-revolutionize-java/">written a</a> <a href="https://www.javacodegeeks.com/2017/05/project-amber-future-java-exposed.html">lot</a> about the Amber project in Java 10. These articles always mention the <a href="http://openjdk.java.net/jeps/286">output of local variable types</a> , <a href="http://openjdk.java.net/jeps/301">enum</a> and <a href="http://openjdk.java.net/jeps/302">lambda improvements</a> , sometimes they write about pattern matching and data classes.  But at the same time, it is unfairly bypassed by <a href="http://openjdk.java.net/jeps/303">JEP 303</a> : Intrinsics for the LDC and INVOKEDYNAMIC Instructions.  Perhaps because few people understand what this is all about.  Although it is curious that the guys from <a href="https://habrahabr.ru/users/nix_solutions/" class="user_link">NIX_Solutions</a> fantasized about this feature <a href="https://habrahabr.ru/company/nixsolutions/blog/281513/">on Habr√© a</a> year ago. </p><br><p>  It is widely known that in the Java virtual machine, starting from version 7, there is an interesting instruction invokedynamic (it is indy).  Many have heard about it, but few know what it actually does.  Someone knows that it is used when compiling lambda expressions and references to methods in Java 8. Some have heard that it is used to concatenate strings in Java 9. But although these are useful uses of indy, the original goal is still slightly different: to do dynamic a call where you can call different code in the same place.  This feature is not used in lambdas or in string concatenation: there the behavior is always generated on the first call and remains constant until the end of the program (always used by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/ConstantCallSite.html">ConstantCallSite</a> ).  Let's see what else you can do. </p><a name="habracut"></a><br><p> Suppose we want to write a method that multiplies two <code>long</code> numbers and returns <code>BigInteger</code> .  It would seem, what is the difficulty?  One line: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplyNaive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(l1).multiply(BigInteger.valueOf(l2)); }</code> </pre> <br><p>  We tagged and saw that it worked, say, 40 nanoseconds.  Here we notice that there seems to be a lot of overhead.  Very often the product of two longs in practice also holds in a long.  And in such cases, why do we need to create two honest BigInteger and multiply, when we could multiply first, and then wrap the result into one BigInteger?  Something like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplyIncorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(l1 * l2); }</code> </pre> <br><p>  This version works about twice as fast, about 20 nanoseconds.  But what if she is wrong?  If the overflow does occur, then all, write is gone.  How to check if there is an overflow or not?  It turns out you can.  There is a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html">multiplyExact</a> method that multiplies, but throws an exception when overflowed.  Its Java implementation is not very trivial, but you should not look at it.  In fact, this is a JVM intrinsic: the JIT compiler can turn its call into a sequence of assembler instructions.  On x86, this is <code>imul</code> (multiply) and <code>jo</code> (jump in case of overflow), and there you already have to watch how we handle the exception.  But the point is that if there is no overflow, then it costs us almost nothing.  Let's write like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplyOverflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(Math.multiplyExact(l1, l2)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArithmeticException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(l1).multiply(BigInteger.valueOf(l2)); } }</code> </pre> <br><p>  If we feed only small numbers here, we get the cherished 20 nanoseconds, great.  But if we serve big ones, then it costs not more than 20 or even 40, but about 20 thousand nanoseconds.  For the exception has to pay a big price. </p><br><p>  Well, let's start with a quick implementation, and if suddenly an overflow has occurred at least once, then we switch to the slow one: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> fast = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplySwitch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fast) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(Math.multiplyExact(a, b)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArithmeticException ex) { fast = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(a).multiply(BigInteger.valueOf(b)); }</code> </pre> <br><p>  Fine, it gives us 20 nanoseconds with small numbers and 40 nanoseconds with large ones.  Here are just benchmarks - this is not a real application.  In a real application, you multiply in a bunch of different places.  Most likely in most of them overflow never happens, and it happens only in some places.  For example, you have the following code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiplySwitch(bigNum, bigNum).add(multiplySwitch(smallNum, smallNum));</code> </pre> <br><p>  According to the logic of the program, in the second case there are always small numbers, and in the first case they are often large.  However, our multiplier will switch to a slow implementation in both places, which is not very pleasant. </p><br><p>  Let's make our checkbox non-static by wrapping a multiplier in an object: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicMultiplier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> fast = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-function">BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fast) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(Math.multiplyExact(a, b)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArithmeticException ex) { fast = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(a).multiply(BigInteger.valueOf(b)); } }</code> </pre> <br><p>  Then we can create a static field for each multiplication in the code, and it will track if there are any overflows in this particular place: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DynamicMultiplier DYNAMIC1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMultiplier(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DynamicMultiplier DYNAMIC2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMultiplier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DYNAMIC1.multiply(bigNum, bigNum).add(DYNAMIC2.multiply(smallNum, smallNum));</code> </pre> <br><p>  We are already close to the goal.  In this implementation there are inconveniences: it is necessary to create a separate static field for each multiplication call.  In addition, I would not want to initialize them before actual use.  Suddenly, we never perform the method with multiplications?  Then we will need a lazy initialization of each of these fields (it would also be good thread-safe).  This is about us and does invokedynamic: he himself connects a hidden static field with each call and is responsible for ensuring that it is initialized lazily and thread-safe.  This field has a special type - ‚Äúcall point‚Äù ( <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html">CallSite</a> ).  By and large, this is simply a link to the target executable code pointed to by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html">MethodHandle</a> .  But if the call point is changeable, then it can replace this MethodHandle whenever it wants.  You can create a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MutableCallSite.html">mutable callpoint</a> using the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MutableCallSite.html">MutableCallSite</a> class (or <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/VolatileCallSite.html">VolatileCallSite</a> , if you need guarantees of visibility of changes in other threads).  It is convenient to extend one of these classes to provide the necessary behavior.  Let's write your call point to solve our problem.  This is somewhat verbose, but try: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiplyCallSite</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableCallSite</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :   long',  BigInteger static final MethodType TYPE = MethodType.methodType(BigInteger.class, long.class, long.class); private static final MethodHandle FAST; private static final MethodHandle SLOW; static { try { FAST = MethodHandles.lookup().findVirtual(MultiplyCallSite.class, "fast", TYPE); SLOW = MethodHandles.lookup().findStatic(MultiplyCallSite.class, "slow", TYPE); } catch (NoSuchMethodException | IllegalAccessException e) { throw new InternalError(e); //   ! } } MultiplyCallSite(MethodType type) { super(type); //    FAST  this setTarget(FAST.bindTo(this).asType(type)); } BigInteger fast(long a, long b) { try { return BigInteger.valueOf(Math.multiplyExact(a, b)); } catch (ArithmeticException ex) { //    : SLOW   ,      setTarget(SLOW.asType(type())); return slow(a, b); } } static BigInteger slow(long a, long b) { return BigInteger.valueOf(a).multiply(BigInteger.valueOf(b)); } }</span></span></code> </pre> <br><p>  The asType () transformations are useful if at the call point the type of the expression does not exactly match our type (for example, parameters of type <code>int</code> are passed instead of <code>long</code> ).  Further, in principle, we can use it without indy in the same way as we did above: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandle MULTIPLIER1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MultiplyCallSite(TYPE).dynamicInvoker(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandle MULTIPLIER2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MultiplyCallSite(TYPE).dynamicInvoker(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BigInteger) MULTIPLIER1.invokeExact(bigNum, bigNum)) .add((BigInteger) MULTIPLIER2.invokeExact(smallNum, smallNum)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable throwable) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InternalError(throwable); <span class="hljs-comment"><span class="hljs-comment">// ! ! }</span></span></code> </pre> <br><p>  Here <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html">dynamicInvoker</a> is a dynamic MethodHandle that pulls the current target from the call point.  Despite the verbosity, this all works as fast as the previous example with DynamicMultiplier, because the JIT compiler knows a lot about all these MethodHandle and knows how to inline very well through them. </p><br><p>  But where is our indy?  Here's the whole hitch that even in Java 9 you cannot write a Java program that would create an arbitrary indy instruction in bytecode.  Indy is used in very specific places that we have already mentioned: lambdas, references to methods, string concatenation.  Our MultiplyCallSite can be used, but only if we generate bytecode by some library like ASM.  And just write Java code will not work. </p><br><p>  This is what JEP 303 is aimed at: letting people use indy anywhere and in any way, and also to load MethodH objects like MethodHandle with one ldc bytecode instruction.  For this, the <a href="">Intrinsics</a> class has been created, which is interpreted in a special way by the javac compiler.  This is the bytecode intrinsic (the method call is replaced with a specific bytecode instruction).  Do not confuse them with JIT compiler intrinsics (where the method call is replaced with assembly instructions).  Auxiliary classes have also been created that implement the <a href="">Constable</a> interface: in order to collapse into one bytecode instruction, the values ‚Äã‚Äãof all the corresponding arguments must be combined from these Constables and be known at the compilation stage. </p><br><p>  Using ldc, by the way, will simplify our <code>MultiplyCallSite</code> us: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiplyCallSite</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableCallSite</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :  MethodTypeConstant (J = long) private static final MethodTypeConstant TYPE = MethodTypeConstant.of( ClassConstant.of("Ljava/math/BigInteger;"), ClassConstant.of("J"), ClassConstant.of("J")); //  ,        MultiplyCallSite.class private static final ClassConstant ME = ClassConstant.of("LIndyTest$MultiplyCallSite;"); //  ! private static final MethodHandle FAST = Intrinsics.ldc(MethodHandleConstant.ofVirtual( ME, "fast", TYPE)); private static final MethodHandle SLOW = Intrinsics.ldc(MethodHandleConstant.ofStatic( ME, "slow", TYPE)); ... }</span></span></code> </pre> <br><p>  Since some MethodHandle objects can be referenced directly from the class-file pool of constants, <code>Intrinsics.ldc</code> just generates such a constant and loads it using the <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">ldc</a> instruction.  We still need a bootstrap method that constructs our cue point: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplyFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHandles.Lookup lookup, String name, MethodType type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MultiplyCallSite(type); }</code> </pre> <br><p>  And it is convenient to create a <a href="">BootstrapSpecifier</a> constant that will indicate it: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BootstrapSpecifier MULT = BootstrapSpecifier.of(MethodHandleConstant.ofStatic( ClassConstant.of(<span class="hljs-string"><span class="hljs-string">"LIndyTest;"</span></span>), <span class="hljs-string"><span class="hljs-string">"multiplyFactory"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    , . MethodTypeConstant.of("(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;")));</span></span></code> </pre> <br><p>  In essence, this MULT constant is all you need to know about library code.  The rest is implementation details that do not bother you.  Now the main thing is to finally generate the indy-instruction! </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  "foo"     -    return ((BigInteger) Intrinsics.invokedynamic(MULT, "foo", bigNum, bigNum)) .add((BigInteger) Intrinsics.invokedynamic(MULT, "foo", smallNum, smallNum)); } catch (Throwable throwable) { throw new InternalError(throwable); //      ! }</span></span></code> </pre> <br><p>  And it really works!  The patched compiler replaces the call with an indy instruction, and we get the same result, but without additional explicit static fields. </p><br><p>  It looks, of course, while not very beautiful.  But if the custom code is once compiled with indy, you can replace the library implementation as much as you like.  For example, you can make an intermediate implementation that defines overflow without exception (slower if there is no overflow, but much faster if there is).  Then you can read the statistics and switch to it, if in this place often come both small and large numbers.  You can also optimize for the call point signature.  Say, if a method in some place is actually called with arguments (int, int), you know that there will definitely not be a <code>long</code> overflow.  For such a signature, you can return <code>ConstantCallSite</code> , which simply multiplies two ints without any overflow checks.  These changes can be made after the publication of the library code and everything that was compiled earlier, will work faster. </p><br><p>  To experiment with this API, you will have to dump the <a href="http://hg.openjdk.java.net/amber/">Amber</a> hg-forest yourself, switch to the constant-folding branch and build OpenJDK via configure and make (the assembly instructions are <a href="http://hg.openjdk.java.net/jdk8/jdk8/raw-file/tip/README-builds.html">here</a> ).  After you build, run javac with the <code>-XDdoConstantFold</code> option. </p><br><p>  Perhaps this API is interesting to you, but it seems like a waste of time to experiment with it now.  It can be seen that the API is raw, you need to write a bunch of boilerplate and obviously still change ten times.  Maybe it's better to wait until everything is settled down?  No, this approach is wrong.  If the API is interesting, you need to experiment now, because right now you can influence exactly how it will change ten times.  Try it now and if you have any ideas or comments, write to <a href="http://mail.openjdk.java.net/mailman/listinfo/amber-dev">amber-dev</a> .  If you come in a couple of years, no one wants to change anything. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/328240/">https://habr.com/ru/post/328240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328230/index.html">Tables in responsive design - 2</a></li>
<li><a href="../328232/index.html">CVE-2017-5689 - Intel AMT Vulnerability in Detail</a></li>
<li><a href="../328234/index.html">Variable properties of classes in python: benefits for business and disorderly conduct</a></li>
<li><a href="../328236/index.html">No anything</a></li>
<li><a href="../328238/index.html">Multi-agent smart home</a></li>
<li><a href="../328242/index.html">Getting rid of Auto Layout</a></li>
<li><a href="../328244/index.html">Magic constants in algorithms</a></li>
<li><a href="../328246/index.html">Ethereum smart contracts: we structure tokens as stocks</a></li>
<li><a href="../328248/index.html">We write a script to synchronize folders with Google Drive, plus learn to use the Google Drive API</a></li>
<li><a href="../328250/index.html">5 of the "hottest" non-fiction novelties for March-April 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>