<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What else do we check with Selenium, besides the interface logic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 My name is Vitaliy Kotov, I work in the testing department of Badoo. Most of the time I work with Selenium. We use this wonderful tool fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What else do we check with Selenium, besides the interface logic</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  My name is Vitaliy Kotov, I work in the testing department of Badoo.  Most of the time I work with Selenium.  We use this wonderful tool for solving various tasks: from functional testing to simplifying work with error logs and testing interaction with API. <br><br>  About what tasks Selenium helps us to solve, and will be discussed in this article.  Go!  :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img width="550" src="https://habrastorage.org/webt/ls/yb/mo/lsybmo70r0jz5fa6k4yv8lhr3nc.png"></div><br><a name="habracut"></a><br><h2>  A bit about Selenium </h2><br>  The first thing Google will tell us about ‚ÄúSelenium‚Äù: <br><br><blockquote>  <b>Selenium</b> is a tool to automate web browser actions.  In most cases, it is used to test Web applications, but is not limited to this. </blockquote><br>  Selenium allows you to do almost the same thing that we could do with our hands: open the pages and interact with them.  However, he does it faster and more reliably, since he cannot ‚Äúblush‚Äù his eye and he cannot click wrongly by mistake. <br><br>  In test automation, the first thing Selenium uses is to check the functionality of the site. <br><br><h2>  Functional check </h2><br>  What do users usually do on the site?  They open it, click here and there, see some results of their clicks: redirects, pop-ups, highlighting of elements, and so on.  This process is desirable (and necessary) to test.  It is necessary to make sure that the user sees exactly the response to his action, which is incorporated in our business logic. <br><br>  For this, scripts are created that describe the actions of users.  For example: <br><br><ol><li>  View site. </li><li>  Click on the authorization button. </li><li>  Wait for the login form to load. </li><li>  Enter username and password. </li><li>  Click on the submission button. </li><li>  Wait for the redirect to the authorized page. </li></ol><br>  If the authorization is broken on the site (for example, the programmer got it wrong - and the getUser method now always returns false), Selenium fails to go through step 6. The test will drop and let us know.  In fact, somewhere in the code, Exception will be thrown, and the process will end with the corresponding error code. <br><br>  This sequence of actions is called functional testing.  This is perhaps the most common use of Selenium.  But there are more interesting. <br><br><h2>  Collecting js errors </h2><br>  Normal user JS-error does not see.  This is right - he has no reason.  But it is important for developers to understand whether their code does not ‚Äúfire‚Äù in some cases.  JS-errors I would divide in this context into two types: visible to the user and those that do not interfere with the user. <br><br>  With the first kind of errors, everything is clear.  If the site does not respond to the user's action due to a JS error, the Selenium test will notice it. <br><br>  With the second kind of errors, everything is more complicated.  If they do not interfere with the use of the application, is it worth it to fix them?  In Badoo, we try to correct such errors along with the errors of the first type.  First, any error somehow signals some kind of problem.  Secondly, if it does not interfere with the user in one case, this does not mean that it does not interfere with him in another. <br><br>  Badoo developers use a self-written solution to collect JS errors.  When an error occurs on the client, the code collects all possible data and sends it to a special repository.  It stores information about the time of the error, user data and the trace.  But even this information is sometimes not enough to reproduce the error.  This is where Selenium helps us. <br><br>  Our Selenium tests check all the most popular actions that users perform on the site.  If there is an error, it will certainly occur during the passage of these tests.  It is enough just to teach Selenium to pay attention to such errors. <br><br>  I solved this problem as follows: I added a template that was connected only for test servers.  In this template there was a piece of JS code that collected JS errors into a specific object.  Something like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorObj = { <span class="hljs-attr"><span class="hljs-attr">_errors</span></span> : [], <span class="hljs-attr"><span class="hljs-attr">addError</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, source, lineno</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._errors.push( <span class="hljs-string"><span class="hljs-string">"Message: "</span></span> + message + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"Source: "</span></span> + source + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"Line: "</span></span> + lineno ); }, <span class="hljs-attr"><span class="hljs-attr">getErrors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._errors; } } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, source, line_no</span></span></span><span class="hljs-function">) </span></span>{ errorObj.addError(message, source, line_no); }</code> </pre> <br>  The same could be done in the Selenium test itself using the <a href="https://www.w3.org/TR/webdriver/">execute</a> command.  It allows you to execute the JS code on the page as if the user opened the browser console and executed the code in it.  But then we could miss some of the mistakes. <br><br>  The fact is that it is possible to execute this code in the Selenium test only after the page is fully loaded.  Consequently, all errors that appear during the download itself will go unnoticed.  There is no such problem with the template, since the code in it is executed before the main JS code. <br><br>  After adding the template, all errors began to be collected into an errorObj object that is available globally.  And now you could use the execute command.  I added to our Selenium framework a method that executed errorObj.getErrors (), that is, I received all the errors that got into errorObj, and saved them on the side of the Selenium test itself. <br><br>  Let me remind you that we write Selenium tests in PHP.  The error collection code was like this: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collectJsErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $return_errorObj = <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@lang</span></span></span><span class="hljs-comment"> JavaScript */</span></span> <span class="hljs-string"><span class="hljs-string">'if (typeof errorObj !== "undefined") {return errorObj.getErrors();} else {return null;}'</span></span>; $js_result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;execute($return_errorObj)-&gt;sync(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($js_result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $result) { $current_stacktrace = $result; <span class="hljs-comment"><span class="hljs-comment">//check if an error is known foreach (self::$known_js_errors as $known_error) { if (strpos($current_stacktrace, $known_error) !== false) { continue 2; } } //check if the error already caught foreach ($this-&gt;getJsErrors() as $error) { $existed_stacktrace = $error['error']; if ($current_stacktrace == $existed_stacktrace) { continue 2; } } //collect an error $this-&gt;addJsError([ 'error' =&gt; $result, 'location' =&gt; $this-&gt;getLocation(), ]); } }</span></span></code> </pre><br>  We get errors from the errorObj JS object and process each one. <br><br>  Some errors are already known to us.  We know that they are on the project and are either already in the process of correction, or are being reproduced only in ‚Äúlaboratory‚Äù conditions.  For example, errors that appear only for test users and that are related to the way we prepared them for the test.  We ignore such errors in the test. <br><br>  If the same error occurs during the test for the second time, we also ignore it - we are only interested in unique ones. <br><br>  For each new error we add the URL and save all the information in an array. <br><br>  We call the collectJsErrors () method after each action on the site: opening the page, waiting and clicking on an item, entering some data, and so on.  No matter how we interact with the interface, we are sure to make sure that this action was not the cause of the error. <br><br>  We check the array with collected errors only at the end of the test in tearDown ().  After all, if the error somehow affects the user, the test will fall.  And if it does not, then dropping the test immediately is bad, you first need to check the script to the end.  Suddenly, behind this error there are more serious problems. <br><br>  Thus, we managed to teach Selenium tests to catch client errors.  And it became easier to reproduce the errors themselves, knowing what kind of test catches them. <br><br><h2>  Typesetting </h2><br>  By themselves, Selenium tests are not intended to test layout.  Of course, if an element that you have to interact with is invisible or hidden by another element, the test will ‚Äútell‚Äù us about it.  Such Selenium can do ‚Äúout of the box‚Äù.  But if the button has gone somewhere down and it looks bad, then already the Selenium test as a whole is just the same - its task is to click on it ... <br><br>  Nevertheless, it is a long time to check the layout manually before each release (and for the Desktop Web, for example, we have two of them per day).  And the human factor can intervene again: the eye is ‚Äúwashed out‚Äù, something can be forgotten ... It is necessary to automate this process somehow. <br><br>  First, we created a simple storage for images.  By a POST request, it was possible to send a screenshot to it, specifying an additional release version, and by a GET request with an indication of the release version - to receive all the screenshots related to this release. <br><br>  Next, we wrote Selenium tests, which raised all browsers of interest to us, which opened all pages of interest to us, pop-ups, overlays, and so on.  In each place they took a <a href="https://www.w3.org/TR/webdriver/">screenshot of the</a> page and sent it to this repository. <br><br>  The storage interface allowed you to quickly scroll through all the screenshots manually and make sure that all pages look decent on all browsers.  Of course, it is difficult to catch a minor bug in this way.  But if the layout broke significantly, it immediately caught my eye.  And in any case, scrolling through screenshots is faster and easier than clicking the site in all browsers with your hands. <br><br>  At first we had not so many screenshots and it was possible to live with it.  However, after some time we wanted to test letters, the variants of which are much more than the pages on the site. <br><br>  To get screenshots of letters I had to resort to some tricks.  The fact is that it is much easier to get the generated HTML in the test than to go to the real mail service (and we are still talking about Selenium tests), find the right letter there, open it and take a screenshot.  Just because you can get HTML letters on our side using ‚Äúbackdoor‚Äù (we have the QaAPI tool that allows us to retrieve data about a particular user in a test environment for test users using a simple cURL query).  But for a third-party service, you would have to write, stabilize and maintain Page Objects: locators, methods, and so on. <br><br>  It is clear that almost all email clients display a letter a little differently than we will see in the ‚Äúbare‚Äù HTML.  But some serious mistakes in the layout, breaking the appearance of the letter, even out of context, are thus successfully caught. <br><br>  But what to do with the resulting HTML?  How to make sure that it is displayed correctly in all browsers?  It turned out pretty simple.  There is an empty page on our collector, where the Selenium test can go and perform a simple execute: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawMailHTML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $html)</span></span></span><span class="hljs-function"> </span></span>{ $js = <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@lang</span></span></span><span class="hljs-comment"> JavaScript */</span></span> <span class="hljs-string"><span class="hljs-string">'document.write("{HTML}")'</span></span>; $js = str_replace(<span class="hljs-string"><span class="hljs-string">'{HTML}'</span></span>, $html, $js); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;execute($js)-&gt;sync(); }</code> </pre><br>  If you do this on the right browser, you can see how the HTML will look in it.  It remains only to take a screenshot and send it to the same collector. <br><br>  After this was done, there were a lot of screenshots.  And checking them by hand twice a day was really difficult. <br><br>  To solve this problem, you can resort to a simple comparison of pictures by pixels.  In this case, you will have to take into account all the variables that are on your project.  In the example with the letter, for example, it can be the name of the user and his picture.  In this case, before you take a screenshot, you will have to tweak HTML a bit, replacing the pictures and names with default ones.  Or generate letters for users with the same name and photo.  :) <br><br>  For less permanent content, such manipulations can be much more. <br><br>  Then you can get the number of mismatched pixels and make a conclusion about how critical the changes are.  You can build diff by marking on the image to be checked those zones that do not coincide with the reference ones. <br><br>  In PHP, the <a href="http://php.net/manual/ru/book.imagick.php">ImageMagick</a> library is great for this purpose.  Also, similar tests are written by JavaScript developers, they use <a href="https://www.npmjs.com/package/resemblejs">Resemble.js</a> . <br><br>  As an example, consider the Badoo authorization page: <br><br><img src="https://habrastorage.org/webt/mn/zk/3w/mnzk3wmrwftc5m4hucplejtujoa.png"><br><br>  Suppose, for some reason, the ‚Äúremember me‚Äù checkbox is lost.  Because of this, the submission button was slightly higher.  Then the diff will look like this: <br><br><img src="https://habrastorage.org/webt/ss/8q/y7/ss8qy7yty_tjrbr-kfyaccpn-aa.png"><br><br>  In the picture, the purple shows the discrepancies between the reference screenshot and the one on which the element is missing.  We immediately see what is wrong. <br><br>  The comparison system can be set to a critical number of pixels, and if no screenshot exceeds this number, you can send a notification that all is well.  If any screenshots began to differ significantly - to ring the alarm ... <br><br>  Thus, you can forget about checking screenshots manually, looking only at what really deserves attention. <br><br><h2>  Test client interaction with API </h2><br>  In Badoo, all clients (Desktop Web, Mobile Web, Android and iOS applications) communicate with the server using a specific HTTP-based API.  This approach has several advantages.  For example, it is much easier to develop clients and server in parallel. <br><br>  However, there is a place for mistakes.  It may happen that the client accesses the server more often than it should, because of a bug or because of a generally improperly designed architecture.  In this case, an extra load will be created, not to mention the fact that maybe something will work incorrectly. <br><br>  To monitor such things at the development and testing stage, we also use Selenium tests.  At the beginning of these tests, we generate a cookie, which we call ‚Äúdevice id‚Äù.  We transfer its value to the server, which for this ‚Äúdevice id‚Äù starts recording all API requests that come to it. <br><br>  After that, the tests themselves are run that perform certain scenarios: open pages, write to each other, like, and so on.  All this time the server considers requests. <br><br>  At the end of the tests, we send a signal to the server to stop recording.  The server generates a special log by which you can understand how many requests of which types were made.  If this number deviates from the benchmark by more than N percent, the auto tester receives a special notification, and we begin to understand the situation.  Sometimes this behavior is expected (for example, when a new request appears that is associated with a new functionality on the site) - then we adjust the reference values.  And sometimes it turns out that the client by mistake creates unnecessary requests, and this needs to be fixed. <br><br>  We run such tests on pricing before the new version of the client is obtained by the user.  Visually comparing the number of requests from release to release looks like this: <br><br><img src="https://habrastorage.org/webt/_u/tm/cq/_utmcqoy_jzlocolntthktwsp7o.png"><br><br>  Each color represents a specific type of request.  If some query will be repeated more often, it will be visually noticeable.  We also have a special notification for this case, so no need to go in and see the statistics before each release. <br><br><h2>  Server logs </h2><br>  We resort to similar tricks in order to quickly deal with errors in the server logs.  When a new error appears on pricing, it is not always clear how to reproduce it and because of what ticket it appeared. <br><br>  At the very beginning of any Selenium test, a special cookie ‚Äútestname‚Äù is created, into which we pass the name of the current test.  Accordingly, if an error on the server was generated during the AutoTest, it is easier to reproduce it in most cases, since we know the playback scenario.  To find the task from which the error came to release, you can run the Selenium test on all released tasks and see their logs. <br><br>  We have this process automated, I wrote about this in a <a href="https://habrahabr.ru/company/badoo/blog/344030/">previous article</a> . <br><br>  In general, this approach allows much faster to deal with server errors in the release and localize them. <br><br><h2>  Automatic pizza order on Friday night </h2><br>  And why, actually, no?  :) <br><br><img src="https://habrastorage.org/webt/0b/pm/ku/0bpmku_s_ffiagtfcaoqibjuapk.jpeg"><br><br><h2>  Results </h2><br>  Selenium is a tool that allows you to manipulate the browser.  And how exactly and why, it is already up to those who use this tool.  By showing ingenuity, you can significantly ease your life. <br><br>  Needless to say, for some types of checks there are some more appropriate tools.  For example, Selenium will not be able to fully replace vulnerability scanners or fast parsers, written, for example, on cURL libraries.  It is also rather strange to use it for load testing - in this case, it will be possible to test the fault tolerance of the Selenium farm rather than the combat application.  :) <br><br>  However, there is a set of tasks for which Selenium is great.  I talked about how he helps us.  I will be glad to hear about interesting ways to use Selenium in your companies. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/351444/">https://habr.com/ru/post/351444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351432/index.html">Comparison of Material Design CSS frameworks</a></li>
<li><a href="../351434/index.html">Solving big problems with a small semantic analyzer</a></li>
<li><a href="../351436/index.html">Analysis of trends in the cryptocurrency market (for example, Bitcoin)</a></li>
<li><a href="../351438/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ306 (March 12 - 18, 2018)</a></li>
<li><a href="../351440/index.html">How to create a 3D analytics application for iPhone?</a></li>
<li><a href="../351448/index.html">Evolution of testing strategies - stop being a monkey</a></li>
<li><a href="../351450/index.html">Classification of topics for contact center calls</a></li>
<li><a href="../351452/index.html">Why Photo Scarlett Johansson made PostgresSQL Mine Monero</a></li>
<li><a href="../351454/index.html">How to write a random number generator and is it possible to predict Math.random?</a></li>
<li><a href="../351456/index.html">Why let the characters down</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>