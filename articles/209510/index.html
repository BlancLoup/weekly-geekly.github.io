<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monads in Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, there are many articles on monads with examples for Haskell ( http://habrahabr.ru/post/183150 , http://habrahabr.ru/post/127556 ), but not m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monads in Scala</h1><div class="post__text post__text-html js-mediator-article">  On Habr√©, there are many articles on monads with examples for Haskell ( <a href="http://habrahabr.ru/post/183150">http://habrahabr.ru/post/183150</a> , <a href="http://habrahabr.ru/post/127556">http://habrahabr.ru/post/127556</a> ), but not many articles that describe what monads are with examples on Scala.  Since the majority of Scala developers came from the world of object-oriented programming, then, for them, at first, it is difficult to understand what monads are and what they are for, this article is for such developers.  In this article I want to show what it is and bring examples of using the Option monad, in the next articles the Try and Future monads will be described. <br><a name="habracut"></a><br>  So, a monad is a parametric data type that necessarily implements two operations: the creation of a monad (in the literature the function unit) - and the function flatMap () (in the literature it is sometimes called bind) and obeys some rules.  They are used to implement the strategy of linking calculations.  Let's give an example of the simplest monad: <br><br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">U</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Monad</span></span>[<span class="hljs-type"><span class="hljs-type">U</span></span>]): <span class="hljs-type"><span class="hljs-type">Monad</span></span>[<span class="hljs-type"><span class="hljs-type">U</span></span>] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](x: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Monad</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]</code> </pre> <br><br>  The <code>flatMap</code> function accepts a function for input, which accepts data that is placed in a monad (the monad is a container) and returns a new monad.  It is worth noting that a function can return a monad of another type (U instead of T), as will be shown later - this is a very useful thing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As for the function <code>unit</code> , it is responsible for creating the monad and for each monad it is different.  For example, the function unit. <br><br> <code>  Option  Some(x)</code> <br> <code>  List  List(x)</code> <br> <code>  Try  Success(x)</code> <br> <br>  For each monad, you can define a <code>map</code> function and express it through the combination <code>flatMap</code> and <code>unit</code> .  For example: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapExample</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monad: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) assert(monad.map(squareFunction) == monad.flatMap(x =&gt; <span class="hljs-type"><span class="hljs-type">Some</span></span>(squareFunction(x)))) }</code> </pre><br>  Also, each monad must obey 3 laws, and they must ensure that the monadic composition works in a predictable way.  We will check these laws on the monad Option. <br><br>  To begin with, we will define two simple functions that we will use in for checking, these are squares and increments, they return Option, this is done to be able to transfer them to the flatMap and for further composition. <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squareFunction</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(x * x) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementFunction</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  The first law is called <code>Left unit law</code> and it looks like this: <br><br> <code>unit(x) flatMap f == f(x)</code> <br> <br>  And he says that if you use the flatMap function for a type with a positive value (for Option is Some) and pass some function there, the result will be the same as simply applying this function to a variable.  This is better demonstrated by the code below: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leftUnitLaw</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monad: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = monad.flatMap(squareFunction) == squareFunction(x) println(result) }</code> </pre><br><br>  As expected, the result will be <code>true</code> . <br><br>  The second law is called <code>Right unit law</code> and looks like this: <br><br> <code>monad flatMap unit == monad</code> <br> <br>  And he says that if we pass a function to the flatMap that creates a monad from the data (those that are in the monad), then at the output we get the same monad. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rightUnitLaw</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monad: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = monad.flatMap(x =&gt; <span class="hljs-type"><span class="hljs-type">Some</span></span>(x)) == monad println(result) }</code> </pre><br><br>  The flatMap function opens monad and gets <code>x</code> and passes it to the function <code>x =&gt; Some(x)</code> which constructs the new monad.  If the <code>monad</code> variable <code>monad</code> assigned the value <code>None</code> , the result will still be <code>true</code> , because <code>flatMap</code> will simply return <code>None</code> and will not call the function passed to it. <br><br>  The third law is called <code>Associativity law</code> : <br><br> <code>(monad flatMap f) flatMap g == monad flatMap(x =&gt; f(x) flatMap g)</code> <br> <br>  If you write it on Scala: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">associativityLaw</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monad: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> left = monad flatMap squareFunction flatMap incrementFunction <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = monad flatMap (x =&gt; squareFunction(x) flatMap incrementFunction) assert(left == right) }</code> </pre><br><br>  And this observance of this law gives us the right to use <code>for comprehension</code> in its usual form, that is, instead of: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (square &lt;- <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x &lt;- monad; sq &lt;- squareFunction(x)) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sq; result &lt;- incrementFunction(square)) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> result</code> </pre><br>  We can write: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x &lt;- monad; square &lt;- squareFunction(x); result &lt;- incrementFunction(square)) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> result</code> </pre><br><br>  And so, all these laws give us the fact that we can encapsulate the logic of a chain of computations, which is what we need monads for if we believe <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B0_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">Wikipedia</a> .  This is very clearly seen when applying the monad of <code>Future</code> and actors, but this is the topic of a separate article.  To demonstrate the chain of calculations, we will create two simple functions for calculating the port and server host and write them to return a positive result <code>Some</code> .  And the creation of an <code>InetSocketAddress</code> depending on the results of the work of these functions. <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPort</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">22</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findHost</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"my.host.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> address: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { host &lt;- findHost() port &lt;- findPort() } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span>(host, port) println(address)</code> </pre><br><br>  The result of the execution of this code will be something like: <code>Some(my.host.com/82.98.86.171:22)</code> .  Note that <code>yield</code> also returns <code>Option</code> to use it for further calculations.  In order to get the address itself, use the <code>map</code> function and display the result, if any of the functions in the chains of calculations returns <code>None</code> then the total result will also be <code>None</code> . <br><br><pre> <code class="scala hljs">address.map(add =&gt; println(<span class="hljs-string"><span class="hljs-string">"Address : "</span></span> + add)).getOrElse(println(<span class="hljs-string"><span class="hljs-string">"Error"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// Address : my.host.com/82.98.86.171:22</span></span></code> </pre><br><br>  For practical use of monads, you should first of all remember that <code>flatMap</code> and <code>map</code> will never be executed with negative input data (for <code>Option</code> this is <code>None</code> ).  The use of these functions greatly simplifies the fight against errors. </div><p>Source: <a href="https://habr.com/ru/post/209510/">https://habr.com/ru/post/209510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209498/index.html">Experience of using MNP in Russia or how I transferred the number from operator to operator</a></li>
<li><a href="../209500/index.html">Cloud.Mail.Ru + EncFS for backing up your home photo archive</a></li>
<li><a href="../209504/index.html">Problems of forecasting financial markets</a></li>
<li><a href="../209506/index.html">Fast graphics output in Matlab</a></li>
<li><a href="../209508/index.html">Attempt to drain the client databases of BillManager users</a></li>
<li><a href="../209512/index.html">Kepler equation: reboot</a></li>
<li><a href="../209514/index.html">Porting C # LINQ to PHP</a></li>
<li><a href="../209516/index.html">Netavis Observer is a Linux based IP video surveillance software. Installation, configuration and small hacking</a></li>
<li><a href="../209520/index.html">dSort - put everything on the shelves</a></li>
<li><a href="../209524/index.html">Network programming for game developers. Part 2: receiving and transmitting data packets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>