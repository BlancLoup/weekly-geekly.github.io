<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Meet the Windows pseudo console (ConPTY)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article published August 2, 2018 

 This is the second article about the Windows command line, where we will discuss the new Windows pseudo-console in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Meet the Windows pseudo console (ConPTY)</h1><div class="post__text post__text-html js-mediator-article">  <font color="gray">Article <a href="https://blogs.msdn.microsoft.com/commandline/2018/08/02/windows-command-line-introducing-the-windows-pseudo-console-conpty/">published</a> August 2, 2018</font> <br><br>  This is the second article about the Windows command line, where we will discuss the new Windows pseudo-console interface and software interfaces, that is, Windows Pseudo Console (ConPTY): why we developed it, what it is for, how it works, how to use it, and much more. <br><br>  In the last article <a href="https://habr.com/post/417679/">‚ÄúThe heavy legacy of the past.</a>  <a href="https://habr.com/post/417679/">Windows command line problems ‚Äù</a> we talked about the prerequisites for the emergence of the terminal and the evolution of the command line in Windows, and also began to study the internal structure of the Windows Console and the Windows Command-Line infrastructure.  We also discussed the many advantages and major disadvantages of the Windows console. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the drawbacks is that Windows tries to be ‚Äúuseful‚Äù, but it prevents developers of alternative and third-party consoles, developers of services, etc.  When creating a console or service, developers need to have access to communication channels through which their terminal / service communicates with command-line applications, or provide access to them.  In the * NIX world, this is not a problem, because * NIX provides a ‚Äúpseudo-terminal‚Äù (PTY) infrastructure that makes it easy to create communication channels for a console or service.  But in Windows this was not ... <br><br>  <i><b>‚Ä¶ until now!</b></i> <br><a name="habracut"></a><br><h1>  From TTY to PTY </h1><br>  Before discussing our development in detail, let's briefly return to the development of terminals. <br><br><h2>  TTY was first </h2><br>  As discussed in the <a href="https://habr.com/post/417679/">previous article</a> , in the early days of computing, users controlled computers using electromechanical teletypes (TTY) connected to a computer through some kind of serial communication channel (usually through <a href="https://en.wikipedia.org/wiki/Digital_current_loop_interface">a 20 mA current loop</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson and Dennis Richie (standing) work on DEC PDP-11 by teletype (messages without an electronic display)</i></font> <br><br><h3>  Terminal distribution </h3><br>  Teletypes were replaced by computerized terminals with electronic displays (usually CRT screens).  As a rule, terminals are very simple devices (hence the term ‚Äústupid terminal‚Äù), containing only electronics and computing power necessary for the following tasks: <br><br><ol><li>  Receive text input from the keyboard. </li><li>  Buffering of the entered text on one line (including local editing before sending). </li><li>  Sending / receiving text over a serial channel (usually via the once-wide <a href="https://en.wikipedia.org/wiki/RS-232">RS-232 interface</a> ). </li><li>  Display of the received text on the terminal display. </li></ol><br>  Despite the simplicity (or perhaps because of it), terminals quickly became the main tool for managing minicomputers, mainframes and servers: most data entry operators, computer operators, system administrators, scientists, researchers, software developers and industry luminaries worked on DEC terminals, IBM, Wyse and many others. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">Admiral Grace Hopper in his office with a DEC VT220 terminal on the table</font></i> <br><br><h3>  Distribution of software terminals </h3><br>  Since the mid-1980s, instead of specialized terminals, general-purpose computers began to be used, which became more accessible, popular, and powerful.  Many early PCs and other computers of the 1980s had terminal applications that opened a connection over an RS-232 port on a PC and communicated with anyone at the other end of the connection. <br><br>  As general-purpose computers became more sophisticated, a graphical user interface (GUI) and a whole new world of simultaneously running applications, including terminal applications, appeared. <br><br>  But the problem arose: how can a terminal application interact with another command line application running on the same machine?  And how to physically connect a serial cable between two applications running on the same computer? <br><br><h2>  The emergence of a pseudo terminal (PTY) </h2><br>  In the world of * NIX, the problem was solved by introducing a <a href="https://en.wikipedia.org/wiki/Pseudoterminal">pseudo-terminal (PTY)</a> . <br><br>  PTY emulates serial telecommunications equipment in a computer by exposing the master and slave pseudo-devices (‚Äúmaster‚Äù and ‚Äúslave‚Äù): terminal applications connect to the master pseudo-device, and command-line applications (for example, shells like cmd, PowerShell, and bash) to the slave pseudo-device.  When a terminal client transmits text and / or control commands (encoded as text) to the master pseudo-device, the text is translated to the associated slave.  The text from the application is sent to the slave pseudo-device, then back to the master and, thus, to the terminal.  Data is always sent / received asynchronously. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Pseudo-terminal application / shell</font></i> <br><br>  It is important to note that the ‚Äúslave‚Äù pseudo-device emulates the behavior of a physical terminal and converts the command characters into POSIX signals.  For example, if the user enters <a href="https://en.wikipedia.org/wiki/Control-C">CTRL + C</a> into the terminal, then the ASCII value for CTRL + C (0x03) is sent through the master device.  When received at the slave pseudo-device, the value 0x03 is removed from the input stream and a <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">SIGINT signal is</a> generated. <br><br>  Such a PTY infrastructure is widely used by * NIX terminal applications, text panel managers (for example, screen, tmux), etc.  Application data calls <code>openpty()</code> , which returns a pair of file descriptors (fd) for the PTY master and slave devices.  The application can then fork / run a child command line application (for example, bash), which uses its slave fd to listen and return text to the connected terminal. <br><br>  This mechanism allows terminal applications to "talk" directly with command-line applications running locally, as the terminal would talk to a remote computer via a serial / network connection. <br><br><h2>  What, there is no pseudo-console Windows? </h2><br>  As we discussed in the previous article, while the Windows console is conceptually similar to the traditional * NIX terminal, it differs in several key ways, especially at the lowest levels that can cause problems for developers of Windows command line applications, third-party terminals / consoles, and server applications: <br><br><ol><li>  <b>There is no PTY infrastructure in Windows</b> : when a user starts a command line application (for example, Cmd, PowerShell, wsl, ipconfig, etc.), Windows itself ‚Äúconnects‚Äù a new or existing console instance to the application. </li><li>  <b>Windows interferes with third-party consoles and server applications</b> : Windows (for the time being) does not give terminals a way to provide communication channels through which they want to interact with a command line application.  Third-party terminals have to create a console off-screen, send user-entered data and scrap the output, redrawing it on the third-party console's own display! </li><li>  <b>Only in Windows is the Console API</b> : Windows command line applications rely on the Win32 Consol API, which reduces code portability, since all other platforms support the text / VT, and not the API. </li><li>  <b>Non-standard remote access</b> : dependence of command line applications on Consol API significantly complicates interaction and remote access scripts. </li></ol><br><h2>  What to do? </h2><br>  Many, <b>many</b> developers have often requested a PTY-like mechanism under Windows, especially those who work with ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker and OpenSSH tools. <br><br>  Even Peter Bright, the technology editor of Ars Technica, asked to implement the PTY mechanism a few days later, as I began working on the Console team: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  And recently again: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Well, we finally did it: <b>we created a pseudo console for Windows</b> : <br><br><h1>  Welcome to the Windows pseudo console (ConPTY) </h1><br>  Since the formation of the Console Team about four years ago, the group has been engaged in a major overhaul of the Windows console and internal mechanisms of the command line.  In doing so, we regularly and thoroughly considered the issues described above and many other related issues and problems.  But the infrastructure and code were not ready to make the release of the pseudo-consoli possible ... until now! <br><br>  New Windows pseudo-console infrastructure (ConPTY), API and some other relevant changes will eliminate / facilitate a whole class of problems ... <b>without breaking backward compatibility with existing command line applications</b> ! <br><br><blockquote>  The new Win32 ConPTY API (official documentation will be published soon) are now available in the latest Windows 10 Insider builds and the corresponding <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">Windows 10 Insider Preview SDK</a> .  They will appear in the next major release of Windows 10 (somewhere in autumn / winter 2018). </blockquote><br><h2>  ConHost Console Architecture </h2><br>  To understand ConPTY, you need to study the architecture of the Windows console, or rather ... ConHost! <br><br>  It is important to understand that although ConHost implements everything you see and know as a Windows Console application, but ConHost also contains and implements most of the Windows command line infrastructure!  From now on, <b>ConHost becomes a real ‚Äúconsole node‚Äù</b> , supporting all command line applications and / or GUI applications that interact with command line applications! <br><br>  <b>How?</b>  <b>Why?</b>  <b>What?</b>  Let's take a closer look. <br><br>  Here is a high-level view of the internal console / ConHost architecture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Compared to the architecture from the <a href="https://habr.com/post/417679/">previous article</a> , ConHost now contains several additional modules for processing VT and a new module ConPTY that implements open APIs: <br><br><ul><li>  <b>ConPTY API</b> : The new Win32 ConPTY APIs provide a mechanism similar to the POSIX PTY model, but refracted from Windows. </li><li>  <b>VT Interactivity</b> : Receives incoming text in UTF-8 encoding, converts each displayed text character to the corresponding <code>INPUT_RECORD</code> entry and stores in the input buffer.  It also processes control sequences, such as 0x03 (CTRL + C), converting them into <code>KEY_EVENT_RECORDS</code> , which produce the appropriate control action. </li><li>  <b>VT Renderer</b> : generates VT sequences needed to move the cursor and render text and style in the output buffer areas that have changed from the previous frame. </li></ul><br>  Ok, but what does that really mean? <br><br><h2>  How do Windows command line applications work? </h2><br>  To better understand the impact of the new ConPTY infrastructure, let's look at how Windows console and command-line applications have worked so far. <br><br>  Whenever a user starts a command-line application, such as Cmd, PowerShell, or ssh, Windows creates a new Win32 process into which it loads the executable binary of the application and any dependencies (resources or libraries). <br><br>  The newly created process usually inherits the stdin and stdout descriptors from its parent.  If the parent process was a Windows GUI process, then the stdin and stdout descriptors are missing, so Windows will deploy and attach the new application to the new console instance.  Communication between command line applications and their console is transmitted via ConDrv. <br><br>  For example, when starting from a PowerShell instance without elevated rights, a new application process will inherit the parent stdin / stdout descriptors and, therefore, receive input data and output the output data to the same console as the parent. <br><br><blockquote>  We need to make a little reservation here, because in some cases command-line applications are launched attached to a <i>new</i> console instance, especially for security reasons, but the description above is usually correct. </blockquote><br>  Ultimately, when a command-line / shell application is launched, Windows connects it to the console instance (ConHost.exe) via ConDrv: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  How does ConHost work? </h2><br>  Whenever a command line application is executed, Windows connects the application to a new or existing instance of ConHost.  An application and its console instance are connected through the kernel-mode console driver (ConDrv), which sends / receives IOCTL messages containing serialized API call requests and / or text data. <br><br>  Historically, as stated in the previous article, the work of ConHost is relatively simple today: <br><br><ul><li>  The user generates input from the keyboard / mouse / pen / touchpad, which is converted to <code>KEY_EVENT_RECORD</code> or <code>MOUSE_EVENT_RECORD</code> and stored in the input buffer. </li><li>  The input buffer empties one record at a time, performing the requested input actions, such as displaying text on the screen, moving the cursor, copying / pasting text, etc.  Many of these actions change the contents of the output buffer.  These modified areas are recorded by the ConHost state engine. </li><li>  In each frame, the console displays the modified areas of the output buffer. </li></ul><br>  When a command line application calls the Windows Console API, API calls are serialized into IOCTL messages and sent via the ConDrv driver.  It then delivers the IOCTL messages to the attached console, which decodes and makes the requested API call.  Returned / output values ‚Äã‚Äãare serialized back to the IOCTL message and sent back to the application via ConDrv. <br><br><h2>  ConHost: a contribution to the past for the sake of the future </h2><br>  Microsoft tries to maintain backward compatibility with existing applications and tools whenever possible.  Especially for the command line.  In fact, 32-bit versions of Windows 10 can still run many / most 16-bit Win16 applications and executables! <br><br>  As mentioned above, one of the key roles of ConHost is to provide services to its command-line applications, especially legacy applications that call and rely on the Win32 console API.  ConHost now also offers new services: <br><br><ul><li>  Seamless PTY-like infrastructure for communicating with modern consoles and terminals </li><li>  Upgrade legacy / traditional command line applications <br><ul><li>  Receiving and converting UTF-8 text / VT to input records (as if entered by the user) </li><li>  Calls to the console API for a hosted application, updating its output buffer accordingly. </li><li>  Display of modified output buffer areas in UTF-8 encoding, text / VT </li></ul></li></ul><br>  Below is an example of how a modern console application communicates with a command line application via ConPTY ConHost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  In this new model: <br><br><ol><li>  Console: <br><ol><li>  Creates own communication channels </li><li>  Calls the ConPTY API to create a ConPTY, forcing Windows to start an instance of ConHost connected to the other end of the channels. </li><li>  Creates an instance of a command line application (for example, PowerShell) connected to ConHost, as usual </li></ol></li><li>  ConHost: <br><ol><li>  Reads UTF-8 text / VT at the input and converts it to <code>INPUT_RECORD</code> entries that are sent to the command line application. </li><li>  Performs API calls from a command line application that can modify the contents of the output buffer. </li><li>  Displays changes in the output buffer encoded in UTF-8 (text / VT) and sends the resulting text to its console. </li></ol></li><li>  Command line application: <br><ol><li>  It works as usual, reads input data and calls the Console API, having no idea what its ConPTY ConHost translates input and output from / to UTF-8! </li></ol></li></ol><br>  The last moment is important!  When an old command-line application uses calls to the Console API like <code>WriteConsoleOutput(...)</code> , the specified text is written to the corresponding ConHost output buffer.  Periodically, ConHost displays the modified output buffer areas as text / VT, which is sent back to the console via stdout. <br><br>  In the end, even traditional command-line applications from the outside ‚Äúspeak‚Äù with the text / VT <b>without any changes</b> ! <br><br>  Using the new ConPTY infrastructure, third-party consoles can now directly interact with modern and traditional command-line applications and exchange data with all of them in the text / VT. <br><br><h2>  Remote interaction with Windows command line applications </h2><br>  The mechanism described above works fine on a single computer, but also helps in interacting, for example, with a PowerShell instance on a remote Windows computer or in a container. <br><br>  When you run the command line application remotely (that is, on remote computers, servers, or in containers), there is a problem.  The point is that command-line applications on remote machines communicate with the local ConHost instance, because IOCTL messages are not intended to be transmitted over the network.  How to transfer input from the local console to a remote machine and how to get output from the application running there?  Moreover, what to do with Mac and Linux machines, where there are terminals, but no Windows-compatible consoles? <br><br>  Thus, in order to remotely control a Windows machine, we need some kind of communication broker that can transparently serialize data across the network, control the lifetime of the application instance, etc. <br><br>  Maybe something like <a href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a> ? <br><br>  Fortunately, <a href="https://www.openssh.com/">OpenSSH</a> recently <a href="https://github.com/PowerShell/Win32-OpenSSH">ported to Windows</a> and added <a href="https://blogs.msdn.microsoft.com/commandline/2018/01/22/openssh-in-windows-10/">Windows 10</a> as <a href="https://blogs.msdn.microsoft.com/commandline/2018/01/22/openssh-in-windows-10/">an additional option</a> .  PowerShell Core also uses ssh as one of the supported protocols for remote interaction <a href="https://docs.microsoft.com/en-us/powershell/scripting/core-powershell/running-remote-commands">PowerShell Core Remoting</a> .  And for those who worked in Windows PowerShell, remote interaction <a href="https://docs.microsoft.com/en-us/powershell/scripting/core-powershell/running-remote-commands%3Fview%3Dpowershell-6">Windows PowerShell Remoting</a> is still an acceptable option. <br><br>  Let's take a look at how <a href="https://github.com/PowerShell/Win32-OpenSSH">OpenSSH for Windows now</a> allows you to remotely control <a href="https://github.com/PowerShell/Win32-OpenSSH">Windows</a> shells and Windows command line applications: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  Currently, OpenSSH includes some undesirable complications: <br><br><ol><li>  User: <br><ol><li>  Starts the ssh client, and Windows connects the console instance as usual. </li><li>  Enters text into the console that sends keystrokes to the ssh client </li></ol></li><li>  ssh client: <br><ol><li>  Reads input as bytes of text data. </li><li>  Sends text data over the network to the sshd listening service. </li></ol></li><li>  The sshd service goes through several stages: <br><ol><li>  Runs a default shell (for example, Cmd) that causes Windows to create and mount a new console instance. </li><li>  Finds and connects to the Cmd instance console. </li><li>  Moves the console off-screen (and / or hides it) </li><li>  Sends input from an ssh client to an off-screen console as input. </li></ol></li><li>  The cmd instance works as always: <br><ol><li>  Collects input from sshd service </li><li>  Performs work </li><li>  Causes the Console API to output / style text, move the cursor, etc. </li></ol></li><li>  Attached [offscreen] console: <br><ol><li>  Performs API calls, updating the output buffer </li></ol></li><li>  Sshd service: <br><ol><li>  Squires off-screen console output buffer, finds differences, encodes them into text / VT and sends back ... </li></ol></li><li>  The ssh client that sends the text ... </li><li>  The console that displays text </li></ol><br>  <b>Fun, right?</b>  <b>Not at all!</b>  In such a situation, much can go awry, especially in the process of simulating and sending user input and clearing the output buffer of the offscreen console.  This leads to instability, malfunctions, data corruption, excessive energy consumption, etc.  In addition, not all applications do the job of removing not only the text itself, but also its properties, due to which formatting and color are lost! <br><br><h3>  Remote operation using modern ConHost and ConPTY </h3><br>  <b>Surely we can improve the situation?</b>  Yes, of course, we can - let's make a few architectural changes and apply our new ConPTY: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  The diagram shows that the scheme has changed as follows: <br><br><ol><li>  User: <br><ol><li>  Starts the ssh client, and Windows connects the console instance as usual. </li><li>  Enters text into the console that sends keystrokes to the ssh client </li></ol></li><li>  ssh client: <br><ol><li>  Reads input as bytes of text data. </li><li>  Sends text data over the network to the sshd listening service. </li></ol></li><li>  Sshd service: <br><ol><li>  Creates stdin / stdout channels </li><li>  Calls the ConPTY API to initiate ConPTY </li><li>  Runs a Cmd instance connected to the other end of the ConPTY.  Windows initiates and connects a new instance of ConHost </li></ol></li><li>  The cmd instance works as always: <br><ol><li>  Collects input from sshd service </li><li>  Performs work </li><li>  Causes the Console API to output / style text, move the cursor, etc. </li></ol></li><li>  ConPTY ConHost instance: <br><ol><li>  Performs API calls, updating the output buffer </li><li>  Displays the modified output buffer regions as text / VT in UTF-8 encoding, which is sent back to the console / terminal via ssh </li></ol></li></ol><br>  This approach with ConPTY is clearly cleaner and easier for the sshd service.  Windows Console API calls are made entirely in the ConHost instance of the command line application, which converts all visible changes to text / VT.  Whoever connects to ConHost does not need to know that the application is calling the Console API there, and does not generate text / VT! <br><br>  Agree that this new mechanism of remote interaction ConPTY leads to an elegant, consistent and simple architecture.  Combined with the powerful features built into ConHost, support for older applications, and the display of changes from applications that invoke the console Console API as text / VT, the new ConHost and ConPTY infrastructure helps us move the past into the future. <br><br><h1>  ConPTY API and how to use it </h1><br><blockquote>  The ConPTY API is available in the current version of the <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">Windows 10 Insider Preview SDK</a> . </blockquote><br>  By now, I‚Äôm sure that you‚Äôre looking forward to seeing some code;) <br><br>  Take a look at the API declarations: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  The above API ConPTY essentially exposes three new functions for use: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Creates a pty of dimension in the <code>w</code> columns and <code>h</code> rows using channels created by the caller: <br><ul><li>  <code>size</code> : width and height (in characters) of the ConPTY buffer </li><li>  <code>hInput</code> : for writing input data to the PTY as text / VT sequences in UTF-8 </li><li>  <code>hOutput</code> : for reading output from PTY as text / VT sequences in UTF-8 </li><li>  <code>dwFlags</code> : Possible values: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : the created ConPTY will attempt to inherit the cursor position of the terminal's parent application </li></ul></li><li>  <code>phPC</code> : console handle for the created ConPty </li></ul></li><li>  <b>Returns</b> : success / failure.  If successful, phPC contains a handle to the new ConPty. </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Resizes the internal ConPTY buffer to display a specific width and height. </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://github.com/microsoft/console">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   ‚Äî   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API ‚Äî ,       ,     Windows   ‚Ä¶   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://twitter.com/ConEmuMaximus5">@ConEmuMaximus5</a> ‚Äî    <a href="https://conemu.github.io/">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    ‚Äî  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  ¬´  VT¬ª     ,      Console API (, <a href="https://blogs.msdn.microsoft.com/commandline/2016/09/22/24-bit-color-in-the-windows-console/"> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://github.com/Microsoft/vscode/issues/45693">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    ‚Ä¶   !  ,       , <b></b> !  : D <br><br>       ,   , <i></i>    ,   <i></i>  .   ‚Äî            ,          Windows  ,   . <br><br>     <a href="https://insider.windows.com/en-us/how-to-feedback/">  </a> .       <a href="https://github.com/microsoft/console"> Windows Console  GitHub</a> .    , <a href="https://twitter.com/richturn_ms">    </a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/420853/">https://habr.com/ru/post/420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420837/index.html">Testing software RAIDs for NVMe devices using the SNIA technique</a></li>
<li><a href="../420841/index.html">Pre-hospital hotfix or ‚ÄúHey, Swagger! Where are my mistakes? ‚Äù</a></li>
<li><a href="../420843/index.html">September 7, Ekaterinburg - mitap for .NET developers</a></li>
<li><a href="../420845/index.html">Taming of the Shrew with the use of a crutch: WF2190 Wi-Fi Hole (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../420847/index.html">An introduction to programming shaders for web designers</a></li>
<li><a href="../420857/index.html">Seamless Wi-Fi roaming: theory in practice</a></li>
<li><a href="../420859/index.html">On the issue of virt and chains</a></li>
<li><a href="../420861/index.html">Preparing for C ++ 20. Coroutines TS on a real example</a></li>
<li><a href="../420863/index.html">As we did the first Russian smartphone, continued</a></li>
<li><a href="../420865/index.html">The principle of least action. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>