<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief and vigorous overview of the architecture of compilers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most compilers have the following architecture: 



 In this article I am going to dissect this architecture in detail, element by element. 
 We can s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief and vigorous overview of the architecture of compilers</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  Most compilers have the following architecture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  In this article I am going to dissect this architecture in detail, element by element. <br>  We can say that this article is an addition to the huge amount of existing resources on the topic of compilers.  It is an autonomous source that will allow you to understand the basics of the design and implementation of programming languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The target audience of the article is people whose understanding of the work of compilers is extremely limited (the maximum is that they are engaged in compiling).  However, I expect the reader to understand the structures and algorithms of the data. <br><br>  The article is by no means devoted to modern production compilers with millions of lines of code - no, this is a short course ‚Äúcompilers for dummies‚Äù that helps to figure out what a compiler is. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  I'm currently working on the <a href="https://krug-lang.org/">Krug</a> system language, inspired by Rust and Go.  In the article I will refer to Krug as an example to illustrate my thoughts.  Krug is under development, but is already available at <a href="https://github.com/krug-lang">https://github.com/krug-lang</a> in the <a href="https://github.com/krug-lang/caasper">caasper</a> and <a href="https://github.com/krug-lang/krug">krug</a> repositories.  The language is not quite typical compared to the usual compiler architecture, which partly inspired me to write an article - but more on that later. <br><br>  I hasten to inform you that I am by no means a compiler expert!  I do not have a doctoral degree, and I did not go through any formal training ‚Äî I studied everything described in the article myself in my free time.  I must also say that I do not describe the actual, the only correct approach to creating a compiler, but rather, I present basic methods suitable for creating a small "toy" compiler. <br><br><h2>  Frontend </h2><br>  Let's return to the diagram above: the arrows on the left that are directed to the frontend field are known and favorite languages ‚Äã‚Äãlike C. The frontend looks like this: lexical analysis -&gt; parser. <br><br><h2>  Lexical analysis </h2><br>  When I started learning compilers and language design, I was told that lexical analysis is the same as tokenization.  We will use this description.  The analyzer takes input data in the form of strings or a stream of characters and recognizes patterns in it, which it cuts into tokens. <br><br>  In the case of a compiler, it receives a written program as an input.  It is read into a string from the file, and the analyzer tokenizes its source code. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  In this fragment, written in a C-shaped language, you can see the structure containing the aforementioned lexeme, as well as TokenType, which serves to recognize this lexeme. <br><br>  Note: the article is not an instruction for creating a language with examples - but for a better understanding I will insert code fragments from time to time. <br><br>  Usually analyzers are the simplest components of a compiler.  The whole frontend is, in fact, fairly simple compared to the rest of the puzzle pieces.  Although it depends a lot on your work. <br><br>  Take the following piece of C code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Having read it from file to line and having performed a linear scan, you may be able to slice tokens.  We identify tokens in a natural way - seeing that int is a ‚Äúword‚Äù, and 0 in a return statement is a ‚Äúnumber‚Äù.  The lexical analyzer does the same procedure as we do ‚Äî later we will look into this process in more detail.  For example, analyze the numbers: <br><br><pre> <code class="plaintext hljs">0xdeadbeef ‚Äî HexNumber ( ) 1231234234 ‚Äî WholeNumber ( ) 3.1412 ‚Äî FloatingNumber (   ) 55.5555 ‚Äî FloatingNumber (   ) 0b0001 ‚Äî BinaryNumber ( )</code> </pre> <br>  Definition of words can be difficult.  Most languages ‚Äã‚Äãdefine a word as a sequence of letters and numbers, and an identifier, as a rule, must begin with a letter or underscore.  For example: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  In Go, this code will not be considered correct and will be parsed into the following tokens: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  The most common identifiers look like this: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Analyzers will have to solve other problems associated with, for example, spaces, multiline and single-line comments, identifiers, numbers, number systems and number formatting (for example, 1_000_000) and encodings (for example, support for UTF8 instead of ASCII). <br><br>  And if you think that you can resort to regular expressions - it‚Äôs better not to.  It is much easier to write an analyzer from scratch, but I highly recommend reading <a href="https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html">this article</a> from our king and god Rob Pike.  The reasons why Regex does not suit us are described in many other articles, so I‚Äôll omit this point.  Besides, writing an analyzer is much more interesting than suffering over long wordy expressions uploaded to regex101.com at 5:24 am.  In my first language, I used the tokenization function <code>split(str)</code> - and far from it. <br><br><h2>  Parsing </h2><br>  Parsing is somewhat more complicated than lexical analysis.  There are many parsers and parsers-generators - here the game starts on a large scale. <br><br>  Parsers in compilers usually accept input in the form of tokens and build a specific tree ‚Äî an abstract syntax tree or a parsing tree.  They are similar in nature, but have some differences. <br><br>  These stages can be represented as functions: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  Typically, compilers are built from a variety of small components that take input data, change it, or convert it into various output data.  This is one of the reasons why functional languages ‚Äã‚Äãare well suited for building compilers.  Other reasons are an excellent benchmarking and fairly extensive standard libraries.  Cool fact: the first implementation of the <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a> compiler was on Ocaml. <br><br>  I advise you to keep these components as simple and autonomous as possible - modularity will greatly facilitate the process.  In my opinion, the same can be said about many other aspects of software development. <br><br><h2>  Trees </h2><br><h4>  Parsing tree </h4><br>  What the fuck is that?  Also known as a parse tree, this thick tree is used to visualize a source program.  They contain all the information (or most of it) about the input program, usually the same as what is described in the grammar of your language.  Each tree node will be leaf or non-leaf, for example, NumberConstant or StringConstant. <br><br><h4>  Abstract syntax tree </h4><br>  As the name implies, ASD is an <i>abstract</i> syntax tree.  The parsing tree contains a lot of (often redundant) information about your program, and in the case of an ASD it is not required.  ASD does not need useless information about structure and grammar, which does not affect the semantics of the program. <br><br>  Suppose you have an expression of the type ((5 + 5) -3) +2 in your tree.  In the parsing tree, you would store it completely, along with parentheses, operators, and values ‚Äã‚Äã5, 5, 3, and 2. But you can simply make associations with ASD ‚Äî we only need to know the values, the operators, and their order. <br><br>  The picture below shows a tree for the expression a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD can be represented as follows: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  This presentation is quite limited, but I hope you can see how your nodes will be structured.  For parsing you can resort to the following procedure: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  I hope that you have grasped the essence of how the other nodes will be step-by-step parsing, starting with high-level language constructs.  How exactly the parser is implemented with a recursive descent, you need to study yourself. <br><br><h2>  Grammar </h2><br>  The parsing in the ASD from a set of tokens can be difficult.  Usually you should start with the grammar of your language.  In essence, grammar defines the structure of your language.  There are several languages ‚Äã‚Äãfor defining languages ‚Äã‚Äãthat can describe (or parse) themselves. <br><br>  An example of a language for defining languages ‚Äã‚Äãis the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2588%25D0%25B8%25D1%2580%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0_%25D0%2591%25D1%258D%25D0%25BA%25D1%2583%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259D%25D0%25B0%25D1%2583%25D1%2580%25D0%25B0">extended Backus-Naur form</a> (RBNF).  It is a variation of the <a href="https://dlang.org/spec/grammar.html">BNF</a> with a smaller number of angle brackets.  Here is an example of the RBNF from a Wikipedia article: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  The production rules are defined: they indicate which terminal template constitutes a ‚Äúnon-terminal‚Äù.  Terminals are part of the alphabet, for example, the token if or 0 and 1 in the example above are terminals.  The non-terminals are their opposite, they are in the left part of the production rules, and they can be considered variables or ‚Äúnamed pointers‚Äù to groups of terminals and non-terminals. <br><br>  Many languages ‚Äã‚Äãhave specifications that contain grammar.  For example, for <a href="https://golang.org/ref/spec">Go</a> , <a href="https://doc.rust-lang.org/reference/">Rust</a> and <a href="https://dlang.org/spec/grammar.html">D.</a> <br><br><h2>  Recursive Descent Analyzers </h2><br>  Recursive descent is the simplest of many approaches to parsing. <br><br>  Recursive descent analyzers are downstream based on recursive procedures.  It is much easier to write a parser, because in your grammar there is no <a href="https://en.wikipedia.org/wiki/Left_recursion">left recursion</a> .  In most "toy" languages, this technique is sufficient for parsing.  GCC uses a hand-written descending parser, although YACC was used before. <br><br>  However, problems with parsing of these languages ‚Äã‚Äãcan arise.  In particular C, where <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  can be interpreted as <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  or how <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  The Clang implementation also uses a recursive descent analyzer: <br><br>  <i>Since this is the usual code for C ++, recursive descent allows beginners to easily understand it.</i>  <i>It supports specially created rules and other strange things required by C / C ++ and helps you easily implement diagnostics and error correction.</i> <br><br>  Also pay attention to other approaches: <br><br><ul><li>  descending LL, recursive descent </li><li>  ascending lr, shift, ascending descent </li></ul><br><h2>  Parser Generators </h2><br>  Another good way.  Of course, there are also disadvantages - but this can be said about any other choice programmers make when creating software. <br><br>  Parser-generators work very briskly.  Using them is easier than writing your own analyzer and getting a quality result ‚Äî although they are not very user friendly and do not always display error messages.  In addition, you will have to learn how to use a parser generator, and during the promotion of the compiler, you will probably have to unwind a parser generator. <br><br>  An example of a generator of parsers is <a href="https://www.antlr.org/">ANTLR</a> , there are many others. <br><br>  I think that this tool is suitable for those who do not want to waste time writing the frontend, and who would prefer to write the middle and backend of the compiler / interpreter and analyze whatever it is. <br><br><h2>  Application parsing </h2><br>  If you have not understood yourself.  Even the front-end compiler (lex / parse) can also be used to solve other problems: <br><br><ul><li>  syntax highlighting </li><li>  HTML / CSS parsing for rendering engine </li><li>  Transporters: TypeScript, CoffeeScript </li><li>  linkers </li><li>  REGEX </li><li>  interface data analysis </li><li>  parsing url </li><li>  formatting tools like <i>gofmt</i> </li><li>  SQL parsing and more. </li></ul><br><h2>  The middle </h2><br>  Semantic analysis!  Analysis of the semantics of the language is one of the most difficult tasks when creating a compiler. <br><br>  You need to make sure that all input programs work correctly.  The aspects related to semantic analysis have not yet been included in my Krug language, and without it, the programmer will always have to write the correct code.  In reality, this is impossible - and we always write, compile, sometimes run, fix errors.  This spiral is infinite. <br><br>  In addition, compiling programs is impossible without analyzing the correctness of the semantics at the appropriate stage of compilation. <br><br>  I once came across a chart devoted to the percentage ratio of the frontend, midland and backend.  Then it looked like <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Today it represents something like <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  The frontend is mainly engaged in the generator, and in contextless languages ‚Äã‚Äãthat do not have the duality of grammar, they can be done quite quickly - here recursive descent will help. <br><br>  With LLVM technology, most optimization work can be loaded into a framework, which presents a number of ready-made optimizations. <br><br>  The next step is semantic analysis, the most important part of the compilation phase. <br><br>  For example, in Rust, with its memory management model, the compiler acts as a big, powerful machine that performs various types of static analysis on introductory forms.  In part, this task is to convert the input data into a form more convenient for analysis. <br><br>  For this reason, semantic analysis plays an important role in the compiler architecture, and grueling preparatory work such as optimizing the generated assembly or reading the input data in the ASD is done for you. <br><br><h2>  Semantic passages </h2><br>  In the course of semantic analysis, most compilers spend a large number of ‚Äúsemantic passes‚Äù through an ASD or other abstract form of code expression.  <a href="https://blogs.msdn.microsoft.com/ericlippert/2010/02/04/how-many-passes/">This article</a> contains details on most of the passes produced by the .NET C # compiler. <br><br>  I will not consider each passage, especially since they differ depending on the language, but below are described a few steps in Krug. <br><br><h2>  Top level ad </h2><br>  The compiler will go through all the "highest level" ads in the modules and be aware of their existence.  He will not go deeper into blocks - he will simply declare which structures, functions, etc.  are available in this or that module. <br><br><h2>  Name / Symbol Resolution </h2><br>  The compiler runs through all blocks of code in functions, etc.  and resolves them ‚Äî that is, finds the characters requiring permission.  This is a common pass, and it is from here that, as a rule, the error <i>No such symbol XYZ</i> comes from when compiling the Go code. <br><br>  Running this pass can be very difficult, especially if there are cyclic dependencies in your dependency diagram.  Some languages ‚Äã‚Äãdo not allow them, for example, Go will give an error if one of your packages forms a loop, like my Krug language.  Cyclic dependencies can be considered a side effect of bad architecture. <br><br>  Cycles can be defined by modifying DFS in a dependency diagram, or using <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25A2%25D0%25B0%25D1%2580%25D1%258C%25D1%258F%25D0%25BD%25D0%25B0">the Tarjan algorithm</a> (as done in Krug) to define (multiple) cycles. <br><br><h2>  Type Inference </h2><br>  The compiler goes through all the variables and displays their types.  Type inference in Krug is very weak, it simply displays variables based on their values.  This is in no way a fancy system, such as those found in functional languages ‚Äã‚Äãlike Haskell. <br><br>  You can infer types using the process of ‚Äúunification‚Äù or ‚Äúunification of types‚Äù.  For simpler type systems, you can use a very simple implementation. <br><br>  Types are implemented in Krug as follows: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  You can also have a simple type inference in which you will assign a type to expression nodes, for example, <code>IntegerConstantNode</code> can be of type IntegerType (64).  And then you may have a function <code>unify(t1, t2)</code> , which will choose the widest type that can be used to deduce the type of more complex expressions, say, binary ones.  So it's a matter of assigning a variable to the left of the values ‚Äã‚Äãof the above types to the right. <br><br>  I once wrote a simple <a href="https://github.com/felixangell/type-inference">type casting</a> on Go, which became the prototype implementation for Krug. <br><br><h2>  Mutability Pass </h2><br>  Krug (like Rust) defaults to immutable language, that is, variables remain unchanged, unless otherwise specified: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  The compiler runs through all blocks and functions and checks that their ‚Äúvariables are correct‚Äù, that is, we do not change what does not follow, and that all variables passed to certain functions are constant or changeable where required. <br><br>  This is done using symbolic information that has been collected in previous passes.  A symbol table constructed from the results of a semantic passage contains the names of tokens and signs of variable variables.  It may contain other data, for example, in C ++, the table can store information about whether the symbol is external or static. <br><br><h2>  Character tables </h2><br>  A symbol table, or ‚Äústab‚Äù, is a table for searching for characters that are used in your program.  For each scope, a single table is created, and all of them contain information about the symbols present in a specific scope. <br><br>  This information includes such properties as the name of the symbol, type, sign of variability, the presence of external communication, location in static memory, and so on. <br><br><h3>  Area of ‚Äã‚Äãvisibility </h3><br>  This is an important concept in programming languages.  Of course, your language is not obliged to give the ability to create nested scopes, everything can be placed in one common namespace! <br><br>  Although the representation of the scope is an interesting task for the compiler architecture, in most C-like languages, the scope appears to be (or is) like a stack data structure. <br><br>  Usually we create and destroy scopes, and they are usually used to manage names, that is, they allow us to hide (shadowing) variables: <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  It can be presented differently: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Small offtopic, but I recommend reading about the <a href="https://en.wikipedia.org/wiki/Parent_pointer_tree">spaghetti stack</a> .  This is a data structure that is used to store scopes in ASD nodes of opposite blocks. <br><br><h2>  Type systems </h2><br>  Many of the following sections can be developed into separate articles, but it seems to me that this headline deserves this most.  Today, a lot of information is available about type systems, as well as the varieties of the systems themselves, around which many copies break.  I will not be deeply immersed in this topic, just leave a link to the <a href="https://blog.steveklabnik.com/posts/2010-07-17-what-to-know-before-debating-type-systems">excellent article by Steve Klabnik</a> . <br><br>  The type system is what is provided and semantically defined in the compiler using compiler representations and analyzing these representations. <br><br><h2>  Possession </h2><br>  This concept is used in programming more and more.  The principles of semantics of ownership and movement are embedded in the language of <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a> , and I hope they will appear in other languages.  Rust performs many different types of static analysis, which checks whether the input data satisfies a set of rules regarding memory: who owns what memory, when memory is destroyed and how many references (or borrowings) exist to these values ‚Äã‚Äãor memory. <br><br>  The beauty of Rust is that all of this is done during compilation, inside the compiler, so the programmer does not have to do garbage collection or reference counting.  All these semantics are related to the type system and can be provided even before the program is presented in the form of a complete binary file. <br><br>  I can not say how it all works under the hood, but all this is the result of static analysis and a wonderful study of the Mozilla team and the participants of the <a href="https://en.wikipedia.org/wiki/Cyclone_(programming_language)">Cyclone</a> project. <br><br><h2>  Control Flow Graphs </h2><br>  To represent program flows, we use control flow graphs (CFG), which contain all the ways in which the program can run.  This is used in semantic analysis to exclude non-working sections of code, that is, blocks, functions, and even modules that will never be achieved during program execution.  Also, graphs can be used to identify cycles that cannot be interrupted.  Or to search for inaccessible code, for example, when you call a panic (call a panic), or return in a loop, and the code outside the loop is not executed.  <a href="https://en.wikipedia.org/wiki/Data-flow_analysis">Data flow analysis</a> plays an important role during the semantic phase of the compiler, so I recommend reading about the types of analysis you can perform, how they work, and what optimizations you can do. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>The final part of our architecture diagram.</i> <br><br>  We have done most of the work on generating executable binaries.  This can be done in various ways, which we will discuss below. <br><br>        - ,   . ,     ,    ¬´¬ª. <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ ‚Äî Cfront ‚Äî     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    ¬´¬ª ,     ,             ,       ,    ¬´  ¬ª  .        ‚Äî   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    ¬´ ¬ª,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      ‚Äî     , ‚Äî     ,      . <br><br> Go ‚Äî    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  ¬´¬ª       fprintf   .   <a href="https://github.com/rui314/8cc">8cc</a> . <br><br><h2>   </h2><br>             .   ‚Äî Java:  , <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://godbolt.org/">Godbolt</a> ‚Äî  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://news.ycombinator.com/item%3Fid%3D19756087"></a>        rwmj ,    8  ,   80 %     .        1971-!    <a href="http://venge.net/graydon/talks/CompilerTalk-2019.pdf"></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  ¬´¬ª,       IR   . , SSA ‚Äî Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   ‚Äî             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) ‚Äî   (NP- ).      ,     (liveness ranges) . <br></li><li>   ‚Äî       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://en.wikipedia.org/wiki/Name_mangling">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://en.wikipedia.org/wiki/Libffi">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   ‚Äî  .     ,      (  .s/.asm)?       ? ,    <a href="https://www.youtube.com/watch%3Fv%3DTH9VCN6UkyQ">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://github.com/rust-lang/rls">RLS</a> . <br><br>    Krug ‚Äî        ‚Äî   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://github.com/krug-lang/caasper/"></a> .   <a href="http://github.com/felixangell/krug/"></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://www.youtube.com/watch%3Fv%3DDT6l4T7yzKs"></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  useful links </h2><br><ul><li> <a href="https://compilers.iecc.com/crenshaw/">Jack Crenshaw</a> ‚Äî        . <br></li><li> <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> <br></li><li> <a href="https://blog.felixangell.com/an-introduction-to-llvm-in-go">  LLVM ( Go)</a> ‚Äî ! <br></li><li> <a href="https://en.wikipedia.org/wiki/PL/0">PL/0</a> <br></li><li> The Dragon Book ‚Äî  ,    . <br></li><li> <a href="https://github.com/rui314/8cc">8cc</a> <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/451894/">https://habr.com/ru/post/451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45188/index.html">Oddities with Yandex</a></li>
<li><a href="../451880/index.html">DevPRO'19: View from Wrike's booth</a></li>
<li><a href="../451884/index.html">Seven years of working as a developer: what lessons have I learned</a></li>
<li><a href="../451886/index.html">Use of discrete mathematics in testing</a></li>
<li><a href="../451890/index.html">Delegating the reverse zone subnet less than / 24 in BIND. How it works</a></li>
<li><a href="../451896/index.html">The ‚Äúunbreakable‚Äù eyeDisk is protected by an iris scan, but transmits the password in clear text</a></li>
<li><a href="../451898/index.html">Innovations in Russian</a></li>
<li><a href="../4519/index.html">"Fat" investment hinders a good startup</a></li>
<li><a href="../451900/index.html">The first contribution to the browser API from Facebook</a></li>
<li><a href="../451902/index.html">Microsoft Azure Developer Camp Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>