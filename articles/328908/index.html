<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quick start iOS-applications on the example of iOS Mail Mail.Ru</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolay Morev ( Mail.Ru ) 
 Today I will talk about our experience in speeding up the launch time of the application, and what it taught us. 

 Here w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quick start iOS-applications on the example of iOS Mail Mail.Ru</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/80e/26d/62e/80e26d62ee7187075e62b57e654a8729.jpg"><br><br><h2>  Nikolay Morev ( <a href="https://habrahabr.ru/company/mailru/">Mail.Ru</a> ) </h2><br>  Today I will talk about our experience in speeding up the launch time of the application, and what it taught us. <br><br>  Here we see that for most users the launch time was about 4 seconds, even a little more.  Therefore, recently we decided to pay more attention to the quality of the product, and not to the new functionality.  We started to increase test coverage, started working on reducing the size of the application, on optimizing the launch speed, on optimizing the use of network resources.  And this is what we have learned. <br><a name="habracut"></a><br>  Our application is an e-mail client that allows you to work with any mailboxes, not only those that are on mail.ru.  And we exist in the Store since 2012, although the application development history is a little longer and goes back to the Agent Mail.Ru application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Practically all this time, we are in the 30th position in the ranking of the most popular free applications in the Russian Store and in the 1-2nd position in the performance section.  Today we will also talk about performance, but not quite about that one.  For an international audience, we are doing the same application, with a slightly different design called MyMail.  And our users sometimes notice this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/deb/4a3/0cc/deb4a30cc0b5fdc0c91f1354f14dd972.png"><br><br>  Today I will talk about our experience in speeding up the launch time of the application, and what it taught us. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-k-fOdaaN4o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Our users, in principle, constantly point us to some problems with applications and talk about what is really important for them.  Here are some examples of reviews in the AppStore: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c21/b31/340/c21b313407bd5efcd333ca0d0b7d4311.png"><br><br>  In addition, data analysts that we collect also confirmed the presence of a problem with the launch time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7a/90e/26c/d7a90e26cddb0c6a5055afa92ca4807b.png"><br><br>  Here we see that for most users the launch time was about 4 seconds, even a little more.  Therefore, recently we decided to pay more attention to the quality of the product, and not to the new functionality.  We started to increase test coverage, started working on reducing the size of the application, on optimizing the launch speed, on optimizing the use of network resources. <br><br>  First, let's see how we came to the relevance of this problem?  As it so happened, the problem with the launch speed began to worry us.  Perhaps you can compare these factors with your application and understand, and, in general, is it worth doing this? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75d/b7b/bb8/75db7bbb83dbe057d0f170c7b048db60.png"><br><br>  The first thing is that our application has such a usage scenario, that users launch it many times during the day.  And of course, at the same time, if the application starts up slowly, it irritates everyone. <br><br>  The second reason is the obvious answer to a lot of questions in the development: ‚ÄúThis has historically been the case.‚Äù  I would attribute the problem with productivity to problems that are called technical debt.  These problems accumulate gradually, as new functionality is added, imperceptibly for everyone, and it also happens that even intentionally, to speed up development time.  I think everyone knows such situations.  For this reason, it hardly makes sense to optimize the launch speed if you do not run your application as often. <br><br>  And another reason - the lack of continuous monitoring of performance.  The process of accumulating technical debt, as we all know, is natural, and a new code is constantly added to the application that can affect the launch speed.  Part of this code really needs to be done during the start process, these are things like setting up a logging library, starting a crash catching library, etc.  And the part, it turns out, is added to the startup process by chance, i.e.  by mistake.  For example, we are in our application at the start, so historically, that we customize the appearance for all the application screens, even if they are not shown right at the very beginning. <br><br>  All this is complicated by the fact that each time the start time is increased by a very small amount.  And this deterioration is impossible to notice with manual testing, and even if we use special tools such as profiler, we may not notice this deterioration, because the error in the change in the profiler will be greater than the degradations made. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8b/a39/a44a8ba390258aac57c49a9122baa060.png"><br><br>  Here is a graph of the launch speed we have built over the past few months.  It just shows this problem, how gradually, by a little bit, the launch speed increases and increases with each new commit.  This graph was one of the results of the work we did to improve the launch speed, and then I will tell you how you can also build such a graph for your application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fb/cd4/c54/6fbcd4c5445a1d5e170c5576fc912413.png"><br><br>  But first, let's talk about how to build the process itself to improve the launch speed. <br><br>  Everyone knows that the main rule of optimization: premature optimization is the root of all evil.  Therefore, before you start, you need to decide on the main issues - what exactly we are optimizing, how users will feel the effect of our optimization, how you will understand, whether the change led to the goal or not and, generally, it would be nice to make sure first, and, in principle, whether optimization is possible, and what is the maximum value that we can improve the launch speed, because the speed may depend not only on your code, but also on some external factors that you cannot influence.  Let's start to answer these questions. <br><br>  What have we optimized?  We have chosen to optimize the main startup script, the most frequent.  This is when the application is unloaded from memory, the user has already logged in to his account, and when it starts up, it enters the list of letters in the Inbox folder.  It looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/009/9c8/a2f/0099c8a2f7e7882400a37fd30dede7ef.png"><br><br>  Further.  The effect that users should feel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bee/a55/5d1/beea555d1a4ac048101be0816aac0129.png"><br><br>  As a result of all the optimizations, the user should have lost the feeling of brakes at the start.  To achieve this, we go from two sides - we are trying to reduce the time itself, but, besides this, we are trying to improve the subjective perception of the start time. <br><br>  Here I will talk only about the technical part - how we improved the time, but in my article, a link to which I will give later, you can find several techniques for improving subjective perception. <br><br>  Further.  How to measure that optimization has given effect? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/719/6d8/5ae/7196d85aeff90bf99c2dcfdc86b4f789.png"><br><br>  In the process of working on optimization, in the process when we tried to find places that could be optimized, we used Time Profiler.  To assess the overall effect of the change, we used the logs embedded in the application.  Why we did not use Time Profiler?  Because if you cut out some small part in an application, optimized it, removed some code, it‚Äôs far from a fact that it will affect the total start time.  And, naturally, to make the measurements as useful as possible, we make all measurements on the slowest device that we have, and in no case on the simulator. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/756/aae/8a0/756aae8a0cc264f4922122ce32ebed85.png"><br><br>  And the answer to the last question ‚Äî what, in principle, the optimization limit is possible ‚Äî we received as follows.  We created a simple test application with minimal functionality, which is, literally, the Xcode Single View Application template, and added screens with a header, a list of letters and several cells that mimic the list of letters.  And on this application, we measured the time below which we, in principle, can not optimize.  And we realized that, in theory, we have about two seconds of optimization possibilities. <br><br>  We proceed to the optimization directly.  Let's start with the first stage of launch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/1b0/c58/5871b0c58cdaadccc34ac44cf5702419.png"><br><br>  The first stage is the time that passes from clicking on the application icon to transferring control to our own code.  In fact, at this stage a lot of things are happening, and it may well take a considerable amount of time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/848/7c4/413/8487c441309d2c61158da29141929aee.png"><br><br>  The bad news is that in the first stage you will not be able to see almost any data in the profiler, but the good news is that there are still some opportunities to influence this time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e31/612/9c2/e316129c25e3e5df49a8f4ee736463f2.png"><br><br>  At WWDC this year there was an excellent report about the first stage, it was discussed in detail what exactly is happening here, and recommendations were given on what we can do with it. <br><br>  What's going on here?  iOS loads the executable application code into memory, performs the necessary manipulations on them, a shift of indicators that is in our application;  binds pointers to external libraries, checks the signatures of all executable files, and then the load methods and static constructors are executed.  This is the very first code, which is our code, and not the code of the operating system.  For example, I gave a diagram of how it looks in our application, what a breakdown by various stages.  For your application, you can get the same data using the DYLD_PRINT_STATISTICS environment variable in Xcode.  Accordingly, in order to speed up the first stage, the main recommendation is to reduce these stages.  How to do it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/f6a/6a7/42bf6a6a715daf13bc25f8f29c4a72d1.png"><br><br>  This I cut out a slide from the report at WWDC, which summarizes all the recommendations in short - in order for the application to work faster, you just need to do fewer things in the application. <br><br>  What other recommendations? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d24/31b/008/d2431b0089bcfffd7be3336d3cee3877.png"><br><br>  We reduce the number of dynamic frameworks that you have in the application.  Why?  Because they load much slower than system frameworks, the loading of system dynamic frameworks is already pre-optimized in the operating system, and the number of 5 is given as the optimal number of its own dynamic frameworks. <br><br>  In our application we have only one dynamic framework and, mainly, we added it in order to share the code between different actions and to reduce the size of the application so that this code is not duplicated.  But, in principle, if we only thought about launch speed, we could abandon dynamic frameworks. <br><br>  By the way, if you use swift, then it adds several own dynamic frameworks at once, which are also considered in this limit.  Those.  it turns out that using swift adds a certain overhead at the start. <br><br>  The steps that are marked here as rebase fixups, binding fixups are affected by the number of Objective-C characters in your application, so the main recommendation that was given in the report is to write large classes and write large methods.  Or switch to swift, where all addresses are set statically and you do not need to do these steps, or at least they are shortened. <br><br>  Naturally, for an existing large application, this is not a very useful recommendation, because you have to do a lot of refactoring, retesting a bunch of code, and, in general, the readability of the code naturally decreases.  Therefore, even for new applications, I would not recommend this method of optimization. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ce/dbe/b86/8cedbeb864eb318e9f5be2832be4b7b9.png"><br><br>  The second stage, when we already got control from the operating system.  Here we have more room for action, because we can change our code somehow and, naturally, we began to use Time Profiler for research here.  I will not explain what Time Profiler is. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/18a/f59/ff918af59a43ed7d3c797c362361a41a.png"><br><br>  Time Profiler is a very cool and powerful tool, it helped us a lot, but here I will list a few problems or shortcomings that he could not solve for us. <br><br><blockquote>  <font color="gray">By the way, we posted in open access the video of the last five years of the conference of developers of high-loaded systems <a href="http://www.highload.ru/">HighLoad ++</a> .</font>  <font color="gray">Watch, learn, share and subscribe to <a href="https://www.youtube.com/user/profyclub">the YouTube channel</a> .</font> </blockquote><br>  First, we didn‚Äôt find any obvious bottlenecks in the appendix, which could have just been cut out, and everything would have improved right away.  This is a well-known development problem called ‚Äúuniformly slow code‚Äù and it is a consequence of the correct approach to development, when we first try to make working and readable code, and then we think about optimization.  Another reason for this problem may be the features of the platform used.  For example, here we see that the overhead of calling Objective-C methods is quite tangible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf4/b7d/dd3/bf4b7ddd374268c46a186c287e30ef13.png"><br><br>  The second problem is Time Profiler.  In some cases, we can see such heavy parts of the call tree in Time Profiler, but the problem is that it is not always possible to understand from them which particular view a particular call belongs to, which part of the application it is.  And this is mainly observed when we analyze the layout or the loading of views from XIBs.  In XIBs, there can also be a rather complex hierarchy, and it is not always clear which view is loading slowly there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/97a/ce6/4a997ace65409a0aed0e16d7dc600fd1.png"><br><br>  The next problem is the dips on the CPU usage graph.  Ideally, of course, for everything to work very quickly, the main thread should be constantly loaded at 100%, something should always be done there.  But on the chart we always see failures, they may be smaller or larger, and Time Profiler tells us practically nothing about what they are caused by, what leads to them.  But there are two main reasons for this: <br><br><ul><li>  Firstly, the launch sequence itself can be built in such a way that waiting for the completion of an action that delays the rest of the launch steps occurs, but, in principle, it is not necessary for everything.  For example, we are trying to open a database and only then proceed with the remaining actions, despite the fact that some of these actions may not depend on the database. </li><li>  Another problem that can lead to this, i.e.  Dips are synchronous I / O operations.  As obvious, when we work with files, or when third-party libraries work with files, so less obvious.  So some system calls in the SDK communicate with system processes on the XPC, and at these moments such failures can also occur.  Examples of such calls are working with the Key Chain, with Touch ID, checking permits for photo access or geolocation. </li></ul><br><br>  Another Time Profiler problem I mentioned earlier about is that it‚Äôs difficult to understand the overall effect of optimization due to the fact that the spread of measurements can be quite large.  That's what I did measurements on the same application without any changes, and we see that from start to start the time varies greatly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f65/160/7c1/f651607c13ea7541a304cbff2e2fa87d.png"><br><br>  What else can you look for when searching for places to optimize? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/935/bdd/f84/935bddf84e6ceb968d3a5b9b727901e6.png"><br><br>  Profiler gives us a lot of useful information, but our psychology is designed so that it is very easy to get on the wrong track.  During the analysis, we tend to pay more attention not to the places that really take a lot of time and can give a big win, but to those that are very easily visible and understandable and which we are interested in doing. <br><br>  For example, in the process of finding places for optimization, I found a place where calls to the baseboard at the launch stage took as much as 20 ms.  I begin to think: ‚ÄúAnd how can I get rid of all this?  Maybe replace the baseboard with something else? ".  But, in an amicable way, you need to look at the problem to a higher level and understand, and why we, in principle, do it.  In our case, this was done in the process of sending statistics on the launch of the application, and, in principle, we can simply transfer this statistics to a slightly later stage, and functionally, this will not change much. <br><br>  Naturally, we first of all want to reduce the amount of work on the main thread.  And first of all we pay attention to it, but we should not forget about the background threads either, because the hardware parallelization possibilities are not limitless.  In particular, we are faced with a situation where one of the libraries we use and initialize at the start immediately went into the background thread and did some work there.  At first, we didn‚Äôt even see what she was doing there, but then we decided to just turn it off and see what would happen.  And it gave quite a significant effect. <br><br>  Even in the Time Profiler catches the eye in the first place, that most of the time is spent on drawing UI and layout.  But from the traces it is not always clear what exactly this time is spent on in the UI, because there are some strange system calls that are incomprehensible, CA, render, something.  And these calls can relate to anything, to any drawing on the screen.  But practice shows that the most voracious in the UI is drawing labels because it is relatively difficult to calculate their size and draw, and any pictures, because they need to be read from disk and decoded. <br><br>  From the above, the conclusion follows: if you want to reduce the launch time, do all the operations as lazily as possible.  What does it mean?  Do not create or set up any screens and views if they are not shown immediately after the start.  In general, perhaps, this is the most effective way to speed up the existing large application, where there are no obvious bottlenecks. <br><br>  For example, what have we done lazy in our application?  We made a lazy loading of pictures in the process of setting the appearance for the secondary screens.  We removed the intermediate launch screen, we removed the creation of the background screens, which are in the sidebar, and much more.  In principle, this rule applies not only to the UI, but also to any logic, any code, if some manager or action needs to be initialized at the start of the application.  Consider whether it can be postponed until the main user interface appears.  Perhaps in terms of functionality there will be no difference. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/27b/14f/d8a27b14f2ea87c44b9f5d39f5bdfe33.png"><br><br>  And a few words about such a controversial topic as creating a UI in an interface builder or in code.  Strangely enough, XIBs are usually not a problem, the creation of a similar UI in the code is performed very slightly faster, and there are <br>  cases where even slower.  Here is a <a href="http://bit.ly/2fnk0xF">link</a> to a rather old blog entry where this comparison was made.  If you wish, you can download the test project, although it will take some effort to drag it to the latest version of Xcode, because it was written in 2010.  And you can see for yourself what is slower and what is faster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e5/106/366/0e51063662ecc2545b3dcfe2f183540d.png"><br><br>  Input Output.  In principle, reading and writing to flash memory on modern devices happens very quickly, it is a few or tens of milliseconds, so it‚Äôs not always worth bothering about it, but it happens that your or third-party code misuses it and opens too many files at launch.  For example, we discovered such a problem with the Flurry analytics framework and with our own code where we load pictures to customize the look of the application.  Time Profiler will not show you such places.  In Time Profiler, at best, you will see small dips in the CPU graph.  Instead, you can use another tool, the I / O Activity, which lists all I / O operations and the names of the corresponding files.  By name it is then quite easy to determine which part of the application this file reads. <br><br>  Similar information can be obtained not only by the I / O Activity tool, but also by a simple breakpoint for the open function.  In the case of system frameworks and XPC, which I mentioned earlier, you can track, paying attention to the dips on the graphics CPU.  In Profiler, you open the Call Samples view, where the list of all stack traces is, and see which calls preceded the failure.  So you can understand which call leads to this delay. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7fe/e5a/827/7fee5a82767ddcce3af78446cbf85088.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Time Profiler does not provide enough information ... I used to give an example with layout, and in such cases you can get more detailed information using the swizzling of layoutSubviews methods in all classes. What is swizzling will not explain. And Objective-C allows us to do this easily. In the swizzling layoutSubviews methods, we simply insert logging - how long it took this call, and we also output to the console a pointer to the object on which this layout was made. After that, we copy all this, paste it into a tablet, into Google Sheets, and we can analyze it. If, after such a log, we do not terminate the application, but exit to the debugger, pause, we can roughly understand what the views take the longest layout.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae6/3ef/09e/ae63ef09ec0ff67a1214eb83c91a91fc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The optimization search methods that I described above have a big disadvantage - they do not allow you to confidently answer the question whether a small change resulted in an overall improvement, because the launch sequence in a large application can be quite complex. This is the interweaving of different callbacks on different threads, etc. And the fact that you have removed something somewhere in one place can either be transferred to a later stage of loading, or will not give any improvement at all, because this moment will be replaced by the expectation of performing some actions. And this problem is especially brightly manifested when corrections, improvements give a fairly small gain. Therefore, we come to the need to automate the launch of the start time measurement and perform a large number of measurements, so that for some median time it is more accurate to saylevel measurement error.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, using Time Profiler for this is not an option, because it is difficult to automate it, and such a large amount of information that it provides is not needed for this task. Therefore, in the application itself, we added debug logs, which enter the time of various launch phases into the console and in a separate file. Something like this logs look like:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ca/734/e2d/4ca734e2ddb49628213cea89fb512446.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have selected some key points of the critical launch path of the application. At these points we enter the absolute time from the start of the launch and the time from the previous stage. We used such logs not only later to automate measurements, but also during the search for places to optimize in addition to the Time Profiler. Because sometimes it is useful to simply get an idea of ‚Äã‚Äãhow much time the larger stages of an application take. So we can understand which stage you need to spend more time in Time Profailer. And for such logs you can even build such beautiful diagrams in Google Sheets, which clearly show everything: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d85/1a8/b32/d851a8b323483540d89e0cabb09b9154.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, this diagram shows how the time of various stages was redistributed after one change was made.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/57d/b1e/a06/57db1ea067505e46170b1b4614491610.png"><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without such measurements, you might think that you made some improvement, but in fact it turned out that time was simply redistributed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or here are such diagrams that show the sequence of different stages of the application: You </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b20/9c1/e52/b209c1e5297a6175ba809c7d01844eb0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can think about them, which places we can parallelize, where we have an unnecessary relationship between the stages of launch, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's talk about optimization.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5b/71f/564/e5b71f5645665ddd42ce3b299fcfbfb9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a lot of talk in the developer community about Continuous Integration, TDD and other useful practices of continuous monitoring of the quality of the application, but for some reason there is very little information on how to monitor performance. We tried to fill this gap. And we consider one of the main achievements of the work done to be a system that allows us to continuously monitor the launch time during development. Having such a system, we solve the main problem, which led to the need to deal with it ... With the help of such a schedule, we can now clearly see how this or that change affected the launch speed, and we can take the necessary measures by seeing these signals. Now the time of feedback is reduced very much. If earlier we received feedback from users that something is slow,now we see it very clearly.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, when using such a system, as well as many other useful practices in the development, the benefits of such an approach can only be seen as the application evolves. At the very beginning you may not understand why this is necessary. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'll tell you briefly how it is technically implemented. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/988/83c/224/98883c2240acbc1a47c7a593a9877f47.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each commit, a task is launched on Jenkins. It assembles the application in a release configuration with the profiling logs turned on and the application automatically terminating at the final stage, when we consider that the application has fully started. This assembly is launched 270 times on a device specifically allocated for this task. At the moment we have this Iphone 5S, on iOS 9.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And you probably have questions, where did this number 270 come from? Obviously, to reduce the error, this number should tend to infinity, but then each run will take infinite time. Therefore, we made 10 thousand measurements and calculated the required number of launches using the formula for determining the sample size for a normal distribution with an error of about 10 ms. Because of this, in our chart everything is jumping a little from side to side. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, if we return to the schedule, we can see the moment when we switched from 10 measurements to 270 measurements. The bottom line shows the minimum start time from all starts, respectively, when we increased the number, the minimum was less.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And further, when we made these 270 launches, we process data on all launches, calculate their statistical characteristics and then save them to InfluxDB, and then we plot them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specific examples of scripts, how it is done, you can see later in my article. There is really nothing complicated, there bash-scripts are literally from 10 lines. Here I will tell only the main points, what tools we used for this.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ded/e83/cba/dede83cba183606e6897ddbb09564eec.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you all know, iOS is a closed system, so there are two options for automating tasks such as automatic installation, autorun, and getting results from the device. We can either work with an undocumented USB protocol that Apple itself uses in its applications, or we can just put up Jailbreak and, like white people, walk to the device via ssh and run the application by executing one command. We, of course, settled on the latter, because it is much simpler, more reliable and more flexible. We do not need to tie the test phone to a specific slave, connect via USB. The phone just lies on the desk of one of the developers, and from any of the Jenkins slaves we can run measurements on it. Or, if the developer needs to run something, he simply takes and launches.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pitfalls of this approach, which emerged after some time of operation: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dff/71a/495/dff71a4955aab36abdd6221fdce0d9b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, now we can see that at some development stage, the launch speed increased, but, unfortunately, the jump moment does not always coincide exactly with the commit where the deterioration occurred. This is due to the measurement error and due to various external factors ‚Äî some system process or something else that we do not know yet could have been performed on the device at this moment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if we have identified the commit in which the degradation occurred, in order to fix it, it is not so easy, you still have to do some research work in Profiler, conduct comparison experiments and analyze the code. Of course, I would like to have some kind of methodology that allows me to see where exactly the behavior at run time changed when I entered a commit, something like a hybrid Time Profiler and div, but unfortunately we don‚Äôt know such a tool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And it also happens that the performance deteriorates due to the update of some third-party library, and here we can do little. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will list the main conclusions to which we came from the results of all the work done, and which I tried to convey in my report.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4e/2b6/550/f4e2b6550505de1cb292d5b4d795b814.png"><br><br><ul><li>     ,  ,    . </li><li>     ,      ,      ,      ,  ,   - ,       . </li><li> Time Profiler ‚Äî   ,           ,   Apple',     swizzling' layoutSubviews. </li><li>  , ,         Continuous Integration. </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I will talk about the results of the work done from the product point of view, and not from the point of view of the developer. Here is the launch of the application before and after the changes ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video demonstration</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/172/4bd/b2c/1724bdb2cb0ca14b9b1003a9284cc831.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video slow 2 times for clarity. And we see what has become better. Although insignificant, but better. It is difficult to calculate the digital acceleration, which we achieved on the basis of all the work, because the work lasted for a long time, in parallel, other non-related tasks were added. In addition, the measurement method was developed as we did all of this, so there are no initial figures, but an approximate comparison ‚Äúbefore and after‚Äù shows that we managed to reduce the launch time by about 30%.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/198/79f/ef3/19879fef38dee052942af10b4dfd3489.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also such a beautiful statistics from our analysts, which shows that the number of users whose launch occurred in less than 2 seconds increased 10 times during this time. It may not seem quite obvious, how did it increase 10 times if it was only a third improved? But if we calculate the weighted average for all user groups, then we also get about an improvement of 40%, which coincides with the data of the Time Profiler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the most important indicators for mobile developers - retension and user satisfaction - also improved slightly. Here are the indicators of retention: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/66a/058/dea/66a058dea860c626a0969ee33e57150e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the negative reviews in the story. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/427/65c/72c42765ca951e5ade2853cdd0b1990a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although it is difficult to draw conclusions from such minor fluctuations, it seems to us that the work on acceleration also contributed to this.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All that I didn‚Äôt have time to talk about in today's report can be found in my article on this topic. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record time: how we increased the speed of launching the Mail.Ru Mail application on iOS </font></font><br> <a href="http://bit.ly/2fgCzi5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit.ly/2fgCzi5</font></font></a> </li><li>  Medium <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.Ru's email app for iOS </font></font><br> <a href="http://bit.ly/2f9OnGu"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit.ly/2f9OnGu</font></font></a> </li></ul><br><h3>  Contacts </h3><br>  ‚Üí <a href="https://github.com/kolyuchiy">github</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://twitter.com/kolyuchiy"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitter</font></font></a> <br><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This report is a transcript of one of the best speeches at a professional conference of developers of </font></font><a href="http://www.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dquick.start"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> systems </font><a href="http://www.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dquick.start"><font style="vertical-align: inherit;">Highload ++</font></a><font style="vertical-align: inherit;"> , specifically, the section ‚ÄúMobile application performance‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a couple of weeks we will have an entire conference dedicated to mobile development - </font></font><br> <a href="http://appsconf.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dquick.start"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppsConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Here </font></font><a href="http://appsconf.ru/2017/abstracts/2605%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dquick.start"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Yandex will already tell you</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about the optimization of loading time </font><font style="vertical-align: inherit;">using the example of Yandex.Maps. </font><font style="vertical-align: inherit;">And the Mail.ru team will reveal the theme of </font></font><a href="http://appsconf.ru/2017/abstracts/2571%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dquick.start"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimizing the size of an iOS application</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this time using the example of ICQ.</font></font></font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/328908/">https://habr.com/ru/post/328908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328896/index.html">Dive into the blockchain technology: What is ICO and how to conduct it</a></li>
<li><a href="../328898/index.html">How an engineering data management system saves files from being destroyed by crypto viruses</a></li>
<li><a href="../328902/index.html">10 steps to improved user adaptation</a></li>
<li><a href="../328904/index.html">Guide React Native - create an application for iOS. Part 1.4 - 1.5</a></li>
<li><a href="../328906/index.html">Lua in Moscow for the first time at DevConf 2017</a></li>
<li><a href="../328910/index.html">The blackmailer WannaCrypt attacks un-upgraded systems</a></li>
<li><a href="../328912/index.html">All educational projects Mail.Ru Group</a></li>
<li><a href="../328914/index.html">Get information about the user's workplace</a></li>
<li><a href="../328916/index.html">We are testing cloud platforms from Top-3</a></li>
<li><a href="../328918/index.html">Top 10 conference reports Heisenbag 2016 Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>