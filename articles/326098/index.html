<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A step-by-step guide to the CSS Grid auto-placement algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We bring to your attention a translation of an article about a technique that will be useful to developers using CSS in their work. 

 In this guide, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A step-by-step guide to the CSS Grid auto-placement algorithm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/39d/ac9/30c/39dac930c2aa462c925aed3ea0faaad8.png"><br><br>  <i>We bring to your attention a translation of an article about a <a href="https://www.sitepoint.com/a-step-by-step-guide-to-the-auto-placement-algorithm-in-css-grid/">technique</a> that will be useful to developers using CSS in their work.</i> <br><br>  In this guide, we will cover all the steps of the algorithm for automatically placing elements from the CSS Grid Layout module.  Each stage is controlled by the <code>grid-auto-flow</code> property.  In his other articles, ‚Äú <a href="https://www.sitepoint.com/introducing-the-css-grid-layout/">Introducing the CSS Grid Layout</a> ‚Äù and ‚Äú <a href="https://www.sitepoint.com/seven-ways-you-can-place-elements-using-css-grid-layout/">Seven Ways You Can Place Your Elements Using the CSS Grid Layout,</a> ‚Äù the author reviewed the CSS Grid specification and analyzed how using the Grid to position elements on a web page.  However, in these materials, the position of a single element was explicitly specified in the grid.  The remaining elements were placed using a certain algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will analyze this algorithm.  And the next time you find that the item was not where you need it, you won‚Äôt have to scratch your head and wonder how it happened. <br><a name="habracut"></a><br><h2>  Basic principles </h2><br>  Before delving into the details, consider some basic principles. <br><br><ul><li>  <b>Anonymous grid items</b> .  If you put the text directly into the grid container, without wrapping it in any tag, it will turn into an anonymous grid element.  Styles cannot be applied to such elements, but they also inherit style rules from parent containers.  Note that the white space inside the grid container does not create an anonymous item. <br><br></li><li>  <b>The value of the grid interval (Value of grid spans)</b> .  Unlike positioning in the grid, the algorithm does not contain separate rules for determining the value of the interval in the grid.  If the value is not specified, then by default it is equal to 1 (the element occupies only its own cell). <br><br></li><li>  <b>Implicit grid</b> .  A grid built on the basis of the values ‚Äã‚Äãof the <code>grid-template-rows</code> , <code>grid-template-columns</code> and <code>grid-template-areas</code> properties is called <b>an explicit grid</b> .  If we now determine the position of the element so that it is outside the bounds of the explicit grid, the browser will generate additional grid lines that will capture this element.  These lines, together with an explicit grid, form an implicit grid.  You can read more about this in ‚Äú <a href="https://www.sitepoint.com/where-things-are-at-in-the-css-grid-layout-working-draft/">Where's the CSS Grid Layout Working Draft</a> ‚Äù.  The auto-arrange algorithm can also cause additional columns or rows to appear in the implicit grid. </li></ul><br>  Now you need to note this.  The default value of the <code>grid-auto-flow</code> property, with which we manage the algorithm, is <code>row</code> .  The same value will be used in the subsequent explanation of the algorithm.  If you explicitly set the <code>column</code> value for the property, do not forget in this explanation to replace all instances of the row row with the column.  For example, ‚Äú <i>Placing elements using the row-position setting, not column</i> ‚Äù will turn into ‚Äú <i>Placing elements using the column-position setting, not row</i> ‚Äù. <br><br>  Now activate in your favorite modern browser the <a href="http://caniuse.com/">possibility of using experimental functions</a> , and consider the details of the algorithm when building the layout. <br><br><h2>  Stage # 1: Generating Anonymous Grid Elements </h2><br>  The first thing the algorithm does when it tries to put all the elements in the grid is that it creates anonymous elements.  As mentioned above, you cannot apply styles to such elements, because there is simply nothing to apply them to. <br><br>  The following code generates an anonymous mesh element from inter-element text: <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">container</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">nonan</span></span>"&gt;1&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Anonymous</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Item</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">nonan</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">floating</span></span>"&gt;2&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">nonan</span></span>"&gt;3&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">nonan</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">floating</span></span>"&gt;4&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">nonan</span></span>"&gt;5&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt;</code> </pre> <br>  In this example, it should be noted that the algorithm ignores CSS floats applied to div 2 and div 4. <br><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/ygXeBr/">CodePen Demo</a> <br><br><h2>  Stage # 2: Placing items in clearly indicated positions </h2><br>  For this and the next few steps, we will use a grid of nine different elements. <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">container</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">B</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">d</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">E</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">F</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">G</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">H</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>"&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">I</span></span>&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>&gt;</code> </pre> <br>  The first elements in the grid will be placed for which <b>positions are explicitly indicated</b> .  In our case, let it be elements A and B. For now, ignore all the others.  Set the positions for A and B: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/293/5f6/a0c/2935f6a0cecd479f8afbfd05377a140b.png"></div><br>  The algorithm places A and B according to their values ‚Äã‚Äãof the <code>grid-area</code> property: <br><br><ul><li>  Based on the first and second values, the <code>grid-area</code> sets the position of the upper left corner for both elements. </li><li>  Based on the third and fourth values, the <code>grid-area</code> sets the position of the lower right corner for both elements. </li></ul><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/KaqVVY/">CodePen Demo</a> <br><br><h2>  Stage # 3: Placing elements using row-position settings, not column </h2><br>  Now the algorithm places an element with <b>explicitly specified row-positions</b> in the <code>grid-row-start</code> and <code>grid-row-end</code> properties. <br><br>  Set the value of grid-row for C and D elements: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row-start</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row-end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.d</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row-start</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row-end</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  To determine the column position, which is not explicitly specified, the algorithm operates in one of two scenarios in accordance with the <b>packing mode</b> : <br><br><ul><li>  Sparse packing (default). </li><li>  Dense packing. </li></ul><br><h2>  Sparse placement on stage # 3 </h2><br>  This is the default behavior.  The initial row of the column (column-start line) of our item will receive the minimum possible line index (line index).  This way we avoid overlapping space for the current element and cells already occupied by other elements. <br><br>  The initial row of the column should also go after the element already placed in the same row <b>at this stage</b> .  We emphasize: <b>at</b> this stage, and <b>not up to</b> this stage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ccc/2b3/85b/ccc2b385b20b4a78a397cfb66af46d02.png"></div><br>  Consider an example: the element D did not move to the left of A, even though it could fit there without any overlaps.  The fact is that the elements with an <b>explicitly given row-position, and not column-</b> , the algorithm does not place <b>in front of another, similarly positioned element in this row</b> (in our example - C).  If element C is to remove grid-row values, then D moves to the left of A. <br><br>  In other words, the element D, which is explicitly given a row-position, and not column, can be placed before A, but only if it does not interfere with C. And in this case it interferes, because C, like in D, a row position is defined, not a column, and it is in the same row as D. <br><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/BpZLNV/">CodePen Demo</a> <br><br><h2>  Tight Stage # 3 </h2><br>  If you need to fill D with an empty space before A, then you will have to assign <code>row dense</code> to the <code>grid-auto-flow</code> property. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-auto-flow</span></span>: row dense; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/567/b74/ca9/567b74ca9fb3494bb77c3a77ea4cb2db.png"></div><br>  In this case, the initial row of the column will again get the minimum possible index so that there are no overlaps with other elements.  But if there is an empty space in the row where our element can fit without overlaps, then it will be placed there without taking into account the previous element from the same row and with the same positioning values ‚Äã‚Äã(in our example, C). <br><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/LxLbBM/">CodePen Demo</a> <br><br><h2>  Step # 4: Determine the number of columns in the implicit grid </h2><br>  Next, the algorithm tries to determine the number of columns in the implicit grid.  It happens like this: <br><br><ul><li>  The algorithm takes the number of columns in the explicit grid. </li><li>  Then it goes through all elements with a given column position and adds columns to the beginning and end of the explicit grid to cover all elements. </li><li>  Then the algorithm goes through all elements without a given column position.  If the largest value of the interval (span) of one of them is greater than the width of the implicit grid, then the algorithm adds columns at the end to cover this interval. </li></ul><br><h2>  Stage # 5: Placing Remaining Items </h2><br>  By this time, the algorithm has already placed all the elements whose positions are clearly defined, as well as elements with known row positions.  Now it starts placing the remaining elements in the grid. <br><br>  But before considering this process, we introduce a new term: the <b>auto-placement cursor</b> .  This is the current insertion point in the grid, determined by the intersection of a pair of coordinates - a row and a column.  Initially, the cursor is placed at the intersection point of the initial row and column of the implicit grid. <br><br>  Recall that the positioning of the elements depends on the mode of placement (packing mode), specified by the property <code>grid-auto-flow</code> . <br><br><h2>  Sparse placement on stage # 5 </h2><br>  By default, the remaining items are placed in a <b>sparse mode</b> .  This is how it happens. <br><br>  If the element does not have a position on any axis: <br><br><ul><li>  The algorithm increments the column position of the cursor until: <br>  a) until there is an overlay between the current element and the previously placed ones, <br>  b) either until the sum ‚Äúvalue of column-position of cursor + value of column-interval of the element‚Äù exceeds the number of columns of the implicit grid. <br><br></li><li>  If the algorithm finds a position without overlaps, then assigns the cursor positions to the <code>row-start</code> and <code>column-start</code> values ‚Äã‚Äãof the inserted element.  Otherwise, the algorithm increases the <code>row-</code> by 1, <code>column-start</code> assigns the value of the initial row in the implicit grid, and repeats the previous step. </li></ul><br>  If element is set to column position: <br><br><ul><li>  The column value of the cursor position is assigned to the value of the <code>column-start</code> element of the element.  If the value of the new position is less than the previous column, the position of the cursor, the row-position is increased by 1. <br><br></li><li>  Next, the row position increases by 1 until a value is reached at which the element does not overlap any of the already occupied cells.  If necessary, additional rows can be added to the implicit grid.  Now the value of the initial row of the row of the element is assigned to the row-position of the cursor, and the end row of the row of the element is set in accordance with its interval. </li></ul><br>  To make it clearer, consider an example. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4aa/fd2/7cc/4aafd27cce21433891242974682e76ad.png"></div><br><h2>  Placing elements E and F when no positions are specified on any axis </h2><br>  When processing the element E, for which <b>neither column- nor row-position is</b> specified, the values ‚Äã‚Äãof row 1 and column 1 are set for the cursor. Element E occupies only one cell, it can fit in the upper left corner without overlays.  That is, the algorithm simply places the <b>element E at the position of row 1 / column 1</b> . <br><br>  The next element without specified positions on both axes is F. The value of the column position of the cursor increases to 2. But the position of row 1 / column 2 is already occupied by element A. The algorithm has to increase the value of the column position again until it reaches 4. There are no more columns , and then the row position of the cursor is increased by 1, and the column position is reset to 1: row 2 / column 1. The algorithm starts increasing the column position again by 1 until it reaches 4. Place with coordinates <b>row 2 / column 4 while which is free and can be occupied by the element F.</b>  The algorithm places it and proceeds to the next element. <br><br><h2>  Placing the elements G and H when the column position is set </h2><br>  Let's start with G. The column position of the cursor is determined by the same as the <code>grid-column-start</code> property of element G - 3. Since they are smaller than the previous value of column (4), the row-position increases by 1. That is, it becomes row 3 / column 3. The space with such coordinates is currently free, and G can be placed there without overlaps, which the algorithm does.  Then everything is the same for element H. <br><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/bgREMJ/">CodePen Demo</a> <br><br><h2>  Tight placement on stage # 5 </h2><br>  When the <code>row dense</code> assigned to the <code>grid-auto-flow</code> property, a different procedure is performed.  If the inserted element does not have a specific position, then the current position of the cursor is determined in accordance with the line at the intersection of the initial row and column of the implicit grid, <b>before the</b> position of the element is determined. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/14b/845/320/14b845320a93478c907e0bac1df4bd9e.png"></div><br>  Element I is placed to the left of H, because the cursor position is <b>reset to the line located at the intersection of the initial row and column of the implicit grid</b> , instead of starting from the last placed element.  The algorithm searches for a suitable position without overlaps, finds a place to the left of H and places an element there. <br><br>  ‚Üí <a href="http://codepen.io/SitePoint/pen/NdgxeQ/">CodePen Demo</a> <br><br><h2>  Conclusion </h2><br>  In this article, we walked through all the stages of the automatic placement algorithm from the CSS Grid Layout module.  This algorithm is controlled by the <code>grid-auto-flow</code> property. <br><br>  Try yourself to calculate the last position of different elements from different layouts in order to better understand the operation of the algorithm. </div><p>Source: <a href="https://habr.com/ru/post/326098/">https://habr.com/ru/post/326098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326086/index.html">Cisco CSR 1000v: Features Overview. Part 1</a></li>
<li><a href="../326088/index.html">Message based integration. Advantages and differences from other approaches</a></li>
<li><a href="../326090/index.html">Creating npm package of React components based on create-react-app</a></li>
<li><a href="../326094/index.html">Introduction to the Storage Performance Development Kit (SPDK)</a></li>
<li><a href="../326096/index.html">PostgreSQL indexes - 1</a></li>
<li><a href="../326102/index.html">Online cash vs blockchain: you did not know this, but thought about it?</a></li>
<li><a href="../326104/index.html">Not soon the fence is built, especially a beautiful data center. How we build the data center "Avantage". Part 1</a></li>
<li><a href="../326106/index.html">PostgreSQL indexes - 2</a></li>
<li><a href="../326108/index.html">A little about the lines in C, or several options to optimize non-optimizable</a></li>
<li><a href="../326110/index.html">It's very simple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>