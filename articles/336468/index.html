<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 7: Language Expansion: Variable Variables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents: 

 Part 1: Introduction and Lexical Analysis 
 Part 2: Implementing Parser and AST 
 Part 3: LLVM IR Code Generation 
 Part 4: Addi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 7: Language Expansion: Variable Variables</h1><div class="post__text post__text-html js-mediator-article">  Table of contents: <br><br>  <a href="https://habrahabr.ru/post/119850/">Part 1: Introduction and Lexical Analysis</a> <br>  <a href="https://habrahabr.ru/post/120005/">Part 2: Implementing Parser and AST</a> <br>  <a href="https://habrahabr.ru/post/120424/">Part 3: LLVM IR Code Generation</a> <br>  <a href="https://habrahabr.ru/post/120516/">Part 4: Adding JIT and Optimizer Support</a> <br>  <a href="https://habrahabr.ru/post/120881/">Part 5: Language Expansion: Control Flow</a> <br>  <a href="https://habrahabr.ru/post/336080/">Part 6: Language Extension: User Defined Operators</a> <br>  <b>Part 7: Language Expansion: Variable Variables</b> <br>  <a href="https://habrahabr.ru/post/336876/">Part 8: Compile to Object Code</a> <br>  <a href="https://habrahabr.ru/post/336980/">Part 9: Adding Debugging</a> Information <br>  <a href="https://habrahabr.ru/post/337240/">Part 10: Conclusion and other goodies LLVM</a> <br><br><img src="https://habrastorage.org/web/6e5/879/803/6e58798030874db09d00f2c502b3b104.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  7.1.  Introduction </h3><br>  Welcome to chapter 7 of the guide ‚ÄúCreating a programming language using LLVM‚Äù.  In chapters 1-6, we built a complete, albeit simple, functional programming language.  On this path, we learned some parsing techniques, learned how to build and how to represent AST, how to build LLVM IR, and how to optimize the resulting code, and how JIT compiles it. <br><a name="habracut"></a><br>  Although the Kaleidoscope is interesting as a functional language, the fact that it is functional makes it too easy to generate LLVM IR for it.  In particular, the language functionality makes it very simple to build an LLVM IR directly in the SSA form.  Since LLVM requires the input code to be in SSA form, this is a very good feature, and for beginners it is often unclear how to generate code for imperative languages ‚Äã‚Äãwith variable variables. <br><br>  A short (and happy) summary of this chapter is that you don't need to build an SSA form in your front end: LLVM provides well-tuned and well-tested support for this, although the way it is done will be unexpected for someone. <br><br><h3>  7.2.  Why is this a difficult task? </h3><br>  To understand why mutable variables cause difficulties with building SSA, consider an extremely simple C example: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> G, H; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">_Bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Condition) X = G; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> X = H; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X; }</code> </pre> <br>  In this example, there is a variable "X", the value of which depends on the program execution path.  Since there are two possible values ‚Äã‚Äãfor X before the return command, a PHI node is inserted that combines both values.  The LLVM IR for this example will look something like this: <br><br><pre> <code class="cpp hljs">@G = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> ; type of @G is i32* @H = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> ; type of @H is i32* define i32 @test(i1 %Condition) { entry: br i1 %Condition, label %cond_true, label %cond_false cond_true: %X<span class="hljs-number"><span class="hljs-number">.0</span></span> = load i32* @G br label %cond_next cond_false: %X<span class="hljs-number"><span class="hljs-number">.1</span></span> = load i32* @H br label %cond_next cond_next: %X<span class="hljs-number"><span class="hljs-number">.2</span></span> = phi i32 [ %X<span class="hljs-number"><span class="hljs-number">.1</span></span>, %cond_false ], [ %X<span class="hljs-number"><span class="hljs-number">.0</span></span>, %cond_true ] ret i32 %X<span class="hljs-number"><span class="hljs-number">.2</span></span> }</code> </pre> <br>  In this example, loading from global variables G and H in LLVM IR is explicit, and they are alive in the then / else branches of the if operator (cond_true / cond_false).  To combine input values, the X.2 phi node in the cond_next block chooses the correct value depending on where the control flow came from: if from a cond_false block, then X.2 gets the value X.1. <br>  If the control flow came from cond_true, the variable gets the value X.0.  In this chapter, we will not explain the details of the SSA form.  For more information, contact one of the many online directories. <br><br>  The question of this chapter is who propagates the phi nodes while descending assignment to a variable variable.  The problem is that LLVM requires that IR be in SSA form: there is no ‚Äúwithout SSA‚Äù mode.  However, designing SSA requires nontrivial algorithms and data structures, and it would be inconvenient and costly to reproduce this logic in each fontend. <br><br><h3>  7.3.  Memory in LLVM </h3><br>  The trick is that, although LLVM requires that all register values ‚Äã‚Äãare in SSA form, it does not require (and does not allow) memory objects to be in SSA form.  In the example above, note that the download commands from G and H have direct access to G and H: they are not renamed and not numbered.  This is different from some other compiler systems that try to assign version numbers to objects in memory.  In LLVM, instead of analyzing the flow of memory data in LLVM IR, this happens in analytic passes that run on demand. <br><br>  The basic idea is that we can make stack variables (which live in memory, because it is a stack) for each variable object in the function.  In order to appreciate the advantage of this approach, we need to talk about how stack variables are represented in LLVM. <br><br>  In LLVM, all memory access operations occur explicitly using load / store commands, and are carefully designed so that there is no need for an address taking operator.  Note that TP of the global variables @ G / @ H is actually ‚Äúi32 *‚Äù, despite the fact that the variables themselves are declared as ‚Äúi32‚Äù.  This means that @G determines the location for i32 in the global data area, but the name of this variable actually refers to the address of this space.  Stack variables work the same way, but, unlike global variables, they are declared with the alloca command: <br><br><pre> <code class="cpp hljs">define i32 @example() { entry: %X = alloca i32 ;  %X - i32*. ... %tmp = load i32* %X ;    %X  . %tmp2 = add i32 %tmp, <span class="hljs-number"><span class="hljs-number">1</span></span> ;  store i32 %tmp2, i32* %X ;  ...</code> </pre><br>  This code shows an example of how you can declare and manipulate stack variables in LLVM IR.  The stack memory allocated by the alloca command is completely generalized: you can pass the address of the stack slot to a function, save it in another variable, etc.  In the example above, we can rewrite this example to use the alloca technique and avoid using PHI nodes. <br><br><pre> <code class="cpp hljs">@G = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> ; type of @G is i32* @H = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> ; type of @H is i32* define i32 @test(i1 %Condition) { entry: %X = alloca i32 ; type of %X is i32*. br i1 %Condition, label %cond_true, label %cond_false cond_true: %X<span class="hljs-number"><span class="hljs-number">.0</span></span> = load i32* @G store i32 %X<span class="hljs-number"><span class="hljs-number">.0</span></span>, i32* %X ;  X br label %cond_next cond_false: %X<span class="hljs-number"><span class="hljs-number">.1</span></span> = load i32* @H store i32 %X<span class="hljs-number"><span class="hljs-number">.1</span></span>, i32* %X ;  X br label %cond_next cond_next: %X<span class="hljs-number"><span class="hljs-number">.2</span></span> = load i32* %X ;  X ret i32 %X<span class="hljs-number"><span class="hljs-number">.2</span></span> }</code> </pre> <br>  So, we‚Äôve discovered a way to handle arbitrary mutable variables without having to create PHI nodes: <br><br>  Each variable being changed becomes a stack area. <br>  Each variable reading becomes a load from the stack. <br>  Each entry in a variable becomes a saving to the stack. <br>  Taking the address of a variable is just a direct use of the value of the address on the stack. <br><br>  Although we solved our problem, another one appeared: now we are having an intensive exchange with the stack for very simple and common operations, which degrades performance.  Fortunately for us, the LLVM optimizer has a well-tuned optimization pass called ‚Äúmem2reg‚Äù that handles such cases, converts the alloca commands into SSA registers and inserts Phi nodes where necessary.  If you pass the code from the example above through this pass, you will get: <br><br><pre> <code class="cpp hljs">$ llvm-as &lt; example.ll | opt -mem2reg | llvm-dis @G = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> @H = weak global i32 <span class="hljs-number"><span class="hljs-number">0</span></span> define i32 @test(i1 %Condition) { entry: br i1 %Condition, label %cond_true, label %cond_false cond_true: %X<span class="hljs-number"><span class="hljs-number">.0</span></span> = load i32* @G br label %cond_next cond_false: %X<span class="hljs-number"><span class="hljs-number">.1</span></span> = load i32* @H br label %cond_next cond_next: %X<span class="hljs-number"><span class="hljs-number">.01</span></span> = phi i32 [ %X<span class="hljs-number"><span class="hljs-number">.1</span></span>, %cond_false ], [ %X<span class="hljs-number"><span class="hljs-number">.0</span></span>, %cond_true ] ret i32 %X<span class="hljs-number"><span class="hljs-number">.01</span></span> }</code> </pre> <br>  The mem2reg pass implements the standard ‚Äúiterated dominance frontier‚Äù algorithm for constructing an SSA form and has a number of optimizations that accelerate (very general) degenerate cases.  The optimization of mem2reg is the answer to the question of what to do with variable variables, and we highly recommend relying on it.  Note that mem2reg works with variables only under certain conditions: <br><br><ul><li>  mem2reg is focused on alloca commands (allocating memory on the stack): it searches for alloca commands and, if it can process them, does so.  It does not work with global variables and heap allocation. </li><li>  mem2reg searches for alloca commands only in the input block of the function.  Placing in the input block ensures that alloca is executed only once, which simplifies the analysis. </li><li>  mem2reg converts only those alloca commands that are used in direct load and store commands.  If the address of the stack variable is passed to a function, or some funny pointer arithmetic is used, the alloca command will not be converted. </li><li>  mem2reg works only with alloca commands for first-class values ‚Äã‚Äã(such as pointers, scalar and vector values), and only if the size of the array for allocating memory is 1 (or is missing in the .ll file).  mem2reg is not able to convert a structure or array into registers.  Note that the sroa pass is more powerful and can transform structures, unions, and arrays in many cases. </li></ul><br>  All these properties are easily achievable in most imperative languages, and we will illustrate them below using the example of a Kaleidoscope.  The last question you can ask is: should I worry about all this in my front end?  Wouldn't it have been better if I had designed the SSA form directly, avoiding the use of the mem2reg optimizing pass?  In short, we strongly recommend that you use this technique to build an SSA form, unless there are very good reasons for not doing this. <br><br>  This technique: <br><br>  <b>Proven and well tested:</b> clang uses this technique for local mutable variables.  Also, in most common LLVM clients, this technique is used for their variables.  You can be sure that bugs are fast and fixed in the early stages. <br><br>  <b>It works very fast:</b> mem2reg optimizes both special cases and general ones by doing it quickly.  For example, there are separate fast optimizations for variables used only in one block, for variables that have a single assignment point, good heuristics to avoid inserting extra phi nodes, etc. <br><br>  <b>Generates debug information: The</b> debug information in LLVM is based on the addresses of the variables to which it is attached.  This technique is very naturally tailored to this style of debug information. <br><br>  Finally, it is easy to integrate into your frontend and work, and easy to implement.  Let us now expand the Kaleidoscope to work with variable variables! <br><br><h3>  7.4.  Changeable in Kaleidoscope </h3><br>  Now we know the essence of the problem we want to solve.  Let's see what it looks like in the context of our little language Kaleidoscope.  We need to add two possibilities: <br><br>  The ability to change a variable using the operator "=". <br>  Ability to define new variables. <br><br>  The first point is what we all said, we have variables as input arguments of the function, and as intermediate variables, and redefine them.  Also, the ability to define new variables is useful regardless of whether we can change them.  Here is a motivating example showing how we can use them: <br><br><pre> <code class="cpp hljs">#  <span class="hljs-string"><span class="hljs-string">':'</span></span>  :   ,   #    RHS. def binary : <span class="hljs-number"><span class="hljs-number">1</span></span> (xy) y; #   fib,     <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> then 1 </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; #   fib. <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> var a </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>, c in (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>, i &lt; x in c = a + b : a = b : b = c) : b; #  . fibi(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br>  In order to change a variable, we must use a trick with ‚Äúalloca‚Äù for existing variables.  When we complete this, we will add our new operator, and expand the Kaleidoscope to support the definition of new variables. <br><br><h3>  7.5.  We convert existing variables into a changeable form¬∂ </h3><br>  The table of characters in the Kaleidoscope during code generation is represented by a table (map) "NamedValues".  The table contains pointers to LLVM ‚ÄúValue *‚Äù values, which contain double precision values ‚Äã‚Äãfor named variables.  In order to maintain variable variability, we need to change them a bit, so that the NamedValues ‚Äã‚Äãtable contains variable memory locations.  This change is refactoring: it changes the structure of the code, but (by itself) does not change the behavior of the compiler.  All these changes are isolated in the Kaleidoscope code generator. <br><br>  At this stage in the development of the Kaleidoscope, it maintains variables for only two cases: the input arguments of the function, and the loop variable ‚Äúfor‚Äù.  For consistency, we allow changes to these variables as well as user-defined variables.  This means that they also need addresses in memory. <br><br>  To begin reworking the Kaleidoscope, we will modify the NamedValues ‚Äã‚Äãtable so that it contains AllocaInst * instead of Value *.  When we do this, the C ++ compiler will tell us which parts of the code we need to change: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, AllocaInst*&gt; NamedValues;</code> </pre> <br>  Also, since we will need to create alloca commands, we use an auxiliary function that creates alloca commands in the input block of the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// CreateEntryBlockAlloca -   alloca    /// .       .. static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, const std::string &amp;VarName) { IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(), TheFunction-&gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), 0, VarName.c_str()); }</span></span></code> </pre><br>  This fun-looking code creates an IRBuilder object that points to the first command (.begin ()) of the input block.  It creates an alloca statement with the desired name and returns it.  Since all values ‚Äã‚Äãin the Cadeidoscope are real numbers with double precision, we do not need to pass a type to use this instruction. <br><br>  When this is done, the first functional change we want to make refers to variable references.  According to our new scheme, variables are alive on the stack, and the code that generates references to them should actually generate a load instruction from the stack slot: <br><br><pre> <code class="cpp hljs">Value *VariableExprAST::codegen() { <span class="hljs-comment"><span class="hljs-comment">//     Value *V = NamedValues[Name]; if (!V) return LogErrorV("Unknown variable name"); //   return Builder.CreateLoad(V, Name.c_str()); }</span></span></code> </pre> <br>  As you can see, everything is absolutely straightforward.  Now we need to update the code points that define the variable to insert the alloca instruction.  Let's start with ForExprAST :: codegen () (see full code listing for the full version): <br><br><pre> <code class="cpp hljs">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); <span class="hljs-comment"><span class="hljs-comment">//   alloca      AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); //    ,  . Value *StartVal = Start-&gt;codegen(); if (!StartVal) return nullptr; //    alloca. Builder.CreateStore(StartVal, Alloca); ... //    Value *EndCond = End-&gt;codegen(); if (!EndCond) return nullptr; // , ,   alloca.    //      . Value *CurVar = Builder.CreateLoad(Alloca); Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, "nextvar"); Builder.CreateStore(NextVar, Alloca); ...</span></span></code> </pre> <br>  This code is actually identical to the code given earlier, in which we allow mutable variables.  The big difference is that we no longer have to construct a PHI node, and we use load / store to access the variable when we need it. <br><br>  In order to support variable function arguments, we also need to make alloca instructions for them.  The code for this is very simple: <br><br><pre> <code class="cpp hljs">Function *FunctionAST::codegen() { ... Builder.SetInsertPoint(BB); <span class="hljs-comment"><span class="hljs-comment">//      NamedValues. NamedValues.clear(); for (auto &amp;Arg : TheFunction-&gt;args()) { //  alloca    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); //      alloca. Builder.CreateStore(&amp;Arg, Alloca); //     . NamedValues[Arg.getName()] = Alloca; } if (Value *RetVal = Body-&gt;codegen()) { ...</span></span></code> </pre> <br>  For each argument, we create an alloca instruction, write the input value to alloca, and register alloca as the memory location for the argument.  This method is called FunctionAST :: codegen () immediately after generating the input block of the function. <br><br>  The last part of the mission is to add the mem2reg pass, which allows us to generate good code again: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   alloca  . TheFPM-&gt;add(createPromoteMemoryToRegisterPass()); //   peephole-    . TheFPM-&gt;add(createInstructionCombiningPass()); //   TheFPM-&gt;add(createReassociatePass()); ...</span></span></code> </pre><br>  It is interesting to see how the code looks before and after the optimization of mem2reg.  For example, here is the code for our recursive function, fib, before and after optimization.  Before optimization: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x) { entry: %x1 = alloca <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* %x1 %x2 = load <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* %x1 %cmptmp = fcmp ult <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x2, <span class="hljs-number"><span class="hljs-number">3.000000e+00</span></span> %booltmp = uitofp i1 %cmptmp to <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %ifcond = fcmp one <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %booltmp, <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> br i1 %ifcond, label %then, label %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> then: ; preds = %entry br label %ifcont <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: ; preds = %entry %x3 = load <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* %x1 %subtmp = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x3, <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span> %calltmp = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp) %x4 = load <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* %x1 %subtmp5 = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x4, <span class="hljs-number"><span class="hljs-number">2.000000e+00</span></span> %calltmp6 = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp5) %addtmp = fadd <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %calltmp, %calltmp6 br label %ifcont ifcont: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, %then %iftmp = phi <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> [ <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span>, %then ], [ %addtmp, %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ] ret <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %iftmp }</code> </pre> <br>  There is only one variable (x, input argument), but you can still see the simple code generation strategy that we use.  In the input block, alloca is created, and the initial input value is stored there.  Each variable reference causes a read from the stack.  Also note that we do not modify the if / then / else expression, and it still inserts PHI nodes.  Although we can make alloca in this case, it‚Äôs actually easier to create a PHI node, so we‚Äôll just do it. <br><br>  Here is the code after passing mem2reg: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x) { entry: %cmptmp = fcmp ult <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">3.000000e+00</span></span> %booltmp = uitofp i1 %cmptmp to <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %ifcond = fcmp one <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %booltmp, <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> br i1 %ifcond, label %then, label %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> then: br label %ifcont <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: %subtmp = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span> %calltmp = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp) %subtmp5 = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">2.000000e+00</span></span> %calltmp6 = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp5) %addtmp = fadd <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %calltmp, %calltmp6 br label %ifcont ifcont: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, %then %iftmp = phi <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> [ <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span>, %then ], [ %addtmp, %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ] ret <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %iftmp }</code> </pre> <br>  This is a trivial case for mem2reg, since there are no variable declarations.  The purpose with which we show this is to protect you from the desire to make the code ineffective.  After the rest of the optimization is done, we get: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x) { entry: %cmptmp = fcmp ult <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">3.000000e+00</span></span> %booltmp = uitofp i1 %cmptmp to <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %ifcond = fcmp ueq <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %booltmp, <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> br i1 %ifcond, label %<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, label %ifcont <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: %subtmp = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span> %calltmp = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp) %subtmp5 = fsub <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %x, <span class="hljs-number"><span class="hljs-number">2.000000e+00</span></span> %calltmp6 = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @fib(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %subtmp5) %addtmp = fadd <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %calltmp, %calltmp6 ret <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %addtmp ifcont: ret <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span> }</code> </pre> <br>  Here we see that the simplifying passage decided to clone the instruction to return to the end of the ‚Äúelse‚Äù block.  This allowed to remove some branches and PHI-node. <br><br>  Now, when the symbol table is updated and contains stack variables, we add an assignment operator. <br><br><h3>  7.6.  New assignment operator </h3><br>  In our framework, adding a new assignment operator is very simple.  Parsing it like any other binary operator, but processing it yourself (instead of letting the user do it).  First of all, assign priority to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     // 1 -    BinopPrecedence['='] = 2; BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20;</span></span></code> </pre> <br>  Now, when the parser knows the priority of the binary operator, it will take care of parsing and generating the AST.  We need to implement code generation for the assignment operator.  It looks like this: <br><br><pre> <code class="cpp hljs">Value *BinaryExprAST::codegen() { <span class="hljs-comment"><span class="hljs-comment">// '=' -  , ..       LHS if (Op == '=') { //  ,  LHS  . VariableExprAST *LHSE = dynamic_cast&lt;VariableExprAST*&gt;(LHS.get()); if (!LHSE) return LogErrorV("destination of '=' must be a variable");</span></span></code> </pre> <br>  Unlike other binary operators, our assignment operator should not be a model ‚Äúgenerate LHS, generate RHS, perform calculations‚Äù.  It is treated as a special case before other binary operators are processed.  Another weird thing is that the LHS must be a variable.  It would be incorrect to write "(x + 1) = expr" - only expressions of the type "x = expr" are allowed. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    RHS. Value *Val = RHS-&gt;codegen(); if (!Val) return nullptr; //   Value *Variable = NamedValues[LHSE-&gt;getName()]; if (!Variable) return LogErrorV("Unknown variable name"); Builder.CreateStore(Val, Variable); return Val; } ...</span></span></code> </pre> <br>  When we have a variable, generating the code for the assignment is very simple: we generate the RHS for the assignment, create the store instruction, and return the calculated value.  The return value allows you to make chains of assignments, for example, "X = (Y = Z)". <br><br>  We now have an assignment operator, and we can change the loop variable and arguments.  For example, we can write this code: <br><br><pre> <code class="cpp hljs"># Function to print a <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span>; # Define <span class="hljs-string"><span class="hljs-string">':'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sequencing: as a low-precedence <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> that ignores operands <span class="hljs-meta"><span class="hljs-meta"># and just returns the RHS. def binary : 1 (xy) y; def test(x) printd(x) : x = 4 : printd(x); test(123);</span></span></code> </pre><br>  At startup, this example will print ‚Äú123‚Äù, then ‚Äú4‚Äù, showing that we actually changed the value of the variable!  Well, now we have reached the goal to make it work, in general, we need to construct an SSA form.  However, it would be really useful if we could enter our own local variables, let's do it! <br><br><h3>  7.7.  User-Defined Local Variables </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding ‚Äúvar‚Äù and ‚Äúin‚Äù is similar to any other extensions we made in the Kaleidoscope: we expand the lexical analyzer, the parser, the AST, and the code generator. </font><font style="vertical-align: inherit;">The first step to add our var / in construct is to expand the lexical analyzer. </font><font style="vertical-align: inherit;">As before, this is trivial, the code will look like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Token { ... <span class="hljs-comment"><span class="hljs-comment">//  var tok_var = -13 ... } ... static int gettok() { ... if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; if (IdentifierStr == "var") return tok_var; return tok_identifier; ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to define the AST node that we are constructing. </font><font style="vertical-align: inherit;">For var / in, it looks like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// VarExprAST -    var/in class VarExprAST : public ExprAST { std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; std::unique_ptr&lt;ExprAST&gt; Body; public: VarExprAST(std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames, std::unique_ptr&lt;ExprAST&gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Var / in" allows you to define a list of names at once, and each name can optionally have an initial value. </font><font style="vertical-align: inherit;">We save information in the vector VarNames. </font><font style="vertical-align: inherit;">Also, var / in has has a body, the body can have access to variables defined in var / in. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When this is done, we can define parts of the parser. </font><font style="vertical-align: inherit;">The first thing we do is add a primary expression:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() { switch (CurTok) { default: return LogError("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we define ParseVarExpr: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() { getNextToken(); //  var. std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; //       if (CurTok != tok_identifier) return LogError("expected identifier after var");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first part of this code parses the list of identifier / expression pairs in the local VarNames vector. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = IdentifierStr; getNextToken(); <span class="hljs-comment"><span class="hljs-comment">//   //    std::unique_ptr&lt;ExprAST&gt; Init; if (CurTok == '=') { getNextToken(); //  '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); //   ,    if (CurTok != ',') break; getNextToken(); //  ','. if (CurTok != tok_identifier) return LogError("expected identifier list after var"); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When all variables are parsed, parse the body and create an AST node. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      'in'. if (CurTok != tok_in) return LogError("expected 'in' keyword after 'var'"); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body)); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can parse and submit the code, and we need to support the generation of LLVM IR code for it. </font><font style="vertical-align: inherit;">This is the beginning of the code:</font></font><br><br><pre> <code class="cpp hljs">Value *VarExprAST::codegen() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;AllocaInst *&gt; OldBindings; Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); <span class="hljs-comment"><span class="hljs-comment">//       for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string &amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In essence, the code loops around all the variables and processes them one at a time. </font><font style="vertical-align: inherit;">For each variable placed in the symbol table, we memorize the previous value, which we replace with OldBindings.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//        ,   //      , //     : // var a = 1 in // var a = a in ... #     'a'. Value *InitVal; if (Init) { InitVal = Init-&gt;codegen(); if (!InitVal) return nullptr; } else { //   ,  0.0. InitVal = ConstantFP::get(TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder.CreateStore(InitVal, Alloca); //    ,    //    OldBindings.push_back(NamedValues[VarName]); //   NamedValues[VarName] = Alloca; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code has more comments. </font><font style="vertical-align: inherit;">The basic idea is that we generate an initializer, create the alloca command, then update the character in the table to point to the alloca. </font><font style="vertical-align: inherit;">When all variables are written to the symbol table, we calculate the body of the var / in expression:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,       Value *BodyVal = Body-&gt;codegen(); if (!BodyVal) return nullptr;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, before returning, we restore the previous bunch of variables: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//       for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; //    return BodyVal; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The end result of all this is that we got the variables correctly placed in the scope, and we even (in a trivial way) allowed them to be modified. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have finished what we wanted to do. </font><font style="vertical-align: inherit;">Our sample iteration function, fib, from the intro is compiled and works great. </font><font style="vertical-align: inherit;">The mem2reg optimization pass optimizes all our stack variables in SSA registers, inserting PHI nodes where necessary, and our frontend remains simple: there are no complicated algorithms and calculations.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.8. </font></font> Full listing </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a complete listing of the source code for our working example, expanded by variable variables and var / in support. </font><font style="vertical-align: inherit;">To build an example, use the commands:</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy #  ./toy</span></span></code> </pre> <br>  Source: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/APFloat.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/STLExtras.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/BasicBlock.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Constants.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Function.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Instructions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetMachine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar/GVN.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../include/KaleidoscopeJIT.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;cassert&gt; #include &lt;cctype&gt; #include &lt;cstdint&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;map&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;utility&gt; #include &lt;vector&gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// //     [0-255]    ,    //  enum Token { tok_eof = -1, //  tok_def = -2, tok_extern = -3, //   tok_identifier = -4, tok_number = -5, //  tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, //  tok_binary = -11, tok_unary = -12, //   tok_var = -13 }; static std::string IdentifierStr; //   tok_identifier static double NumVal; //   tok_number /// gettok -       static int gettok() { static int LastChar = ' '; //   while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; if (IdentifierStr == "if") return tok_if; if (IdentifierStr == "then") return tok_then; if (IdentifierStr == "else") return tok_else; if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; if (IdentifierStr == "var") return tok_var; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   .   EOF. if (LastChar == EOF) return tok_eof; // ,     ascii-. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// //    ( ) //===----------------------------------------------------------------------===// namespace { /// ExprAST -    . class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST -      "1.0". class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST -   , , "a". class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;Name) : Name(Name) {} Value *codegen() override; const std::string &amp;getName() const { return Name; } }; /// UnaryExprAST -      class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr&lt;ExprAST&gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST -      class BinaryExprAST : public ExprAST { char Op; std::unique_ptr&lt;ExprAST&gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST -      class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; public: CallExprAST(const std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST -    if/then/else. class IfExprAST : public ExprAST { std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then, std::unique_ptr&lt;ExprAST&gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST -    for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body; public: ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start, std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step, std::unique_ptr&lt;ExprAST&gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// VarExprAST -    var/in class VarExprAST : public ExprAST { std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; std::unique_ptr&lt;ExprAST&gt; Body; public: VarExprAST( std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames, std::unique_ptr&lt;ExprAST&gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST -    "" , ///    ,    (, ,  /// ,  ),   . class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string &amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST -      class FunctionAST { std::unique_ptr&lt;PrototypeAST&gt; Proto; std::unique_ptr&lt;ExprAST&gt; Body; public: FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } //     //===----------------------------------------------------------------------===// //  //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -  /// ,    . getNextToken     ///     CurTok  . static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -     , ///   static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -       . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -     . std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) { fprintf(stderr, "Error: %s\n", Str); return nullptr; } std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr&lt;ExprAST&gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() { auto Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal); getNextToken(); //   return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() { getNextToken(); //  (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError("expected ')'"); getNextToken(); //  ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //   return llvm::make_unique&lt;VariableExprAST&gt;(IdName); // Call. getNextToken(); //  ( std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return llvm::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() { getNextToken(); // eat the if. //  auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError("expected then"); getNextToken(); //  then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError("expected else"); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return llvm::make_unique&lt;IfExprAST&gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //   if (CurTok != '=') return LogError("expected '=' after for"); getNextToken(); //  '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError("expected ',' after for start value"); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; //    std::unique_ptr&lt;ExprAST&gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError("expected 'in' after for"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() { getNextToken(); //  var. std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; //      if (CurTok != tok_identifier) return LogError("expected identifier after var"); while (true) { std::string Name = IdentifierStr; getNextToken(); //   // Read the optional initializer. std::unique_ptr&lt;ExprAST&gt; Init = nullptr; if (CurTok == '=') { getNextToken(); //  '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); // End of var list, exit loop. if (CurTok != ',') break; getNextToken(); //  ','. if (CurTok != tok_identifier) return LogError("expected identifier list after var"); } // At this point, we have to have 'in'. if (CurTok != tok_in) return LogError("expected 'in' keyword after 'var'"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() { switch (CurTok) { default: return LogError("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr&lt;ExprAST&gt; ParseUnary() { //      ,     . if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); //    ,   int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return llvm::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS) { //    ,    while (true) { int TokPrec = GetTokPrecedence(); //   ,    //  ,   if (TokPrec &lt; ExprPrec) return LHS; //   ,     int BinOp = CurTok; getNextToken(); // eat binop //       auto RHS = ParseUnary(); if (!RHS) return nullptr; //  BinOp    RHS,    RHS,  //    RHS   LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } //  LHS/RHS. LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr&lt;ExprAST&gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = , 1 = , 2 = . unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected unary operator"); FnName = "unary"; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected binary operator"); FnName = "binary"; FnName += (char)CurTok; Kind = 2; getNextToken(); //  ,    if (CurTok == tok_number) { if (NumVal &lt; 1 || NumVal &gt; 100) return LogErrorP("Invalid precedence: must be 1..100"); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP("Expected ')' in prototype"); // . getNextToken(); // eat ')'. // ,     if (Kind &amp;&amp; ArgNames.size() != Kind) return LogErrorP("Invalid number of operands for operator"); return llvm::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() { getNextToken(); //  def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { //    auto Proto = llvm::make_unique&lt;PrototypeAST&gt;("__anon_expr", std::vector&lt;std::string&gt;()); return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// static LLVMContext TheContext; static IRBuilder&lt;&gt; Builder(TheContext); static std::unique_ptr&lt;Module&gt; TheModule; static std::map&lt;std::string, AllocaInst *&gt; NamedValues; static std::unique_ptr&lt;legacy::FunctionPassManager&gt; TheFPM; static std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT; static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { //  ,       . if (auto *F = TheModule-&gt;getFunction(Name)) return F; //  ,         // . auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-&gt;second-&gt;codegen(); //    ,  null. return nullptr; } /// CreateEntryBlockAlloca -   alloca    /// .     . static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, const std::string &amp;VarName) { IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(), TheFunction-&gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), nullptr, VarName); } Value *NumberExprAST::codegen() { return ConstantFP::get(TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // ,       Value *V = NamedValues[Name]; if (!V) return LogErrorV("Unknown variable name"); //   return Builder.CreateLoad(V, Name.c_str()); } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-&gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string("unary") + Opcode); if (!F) return LogErrorV("Unknown unary operator"); return Builder.CreateCall(F, OperandV, "unop"); } Value *BinaryExprAST::codegen() { //    '=', ..     LHS   if (Op == '=') { //  ,  LHS   // ,     RTTI, .. LLVM   //  .    LLVM  RTTI     // dynamic_cast    . VariableExprAST *LHSE = static_cast&lt;VariableExprAST *&gt;(LHS.get()); if (!LHSE) return LogErrorV("destination of '=' must be a variable"); //   RHS. Value *Val = RHS-&gt;codegen(); if (!Val) return nullptr; //   Value *Variable = NamedValues[LHSE-&gt;getName()]; if (!Variable) return LogErrorV("Unknown variable name"); Builder.CreateStore(Val, Variable); return Val; } Value *L = LHS-&gt;codegen(); Value *R = RHS-&gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //  bool 0/1  double 0.0 or 1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp"); default: break; } //      ,     .  //    . Function *F = getFunction(std::string("binary") + Op); assert(F &amp;&amp; "binary operator not found!"); Value *Ops[] = {L, R}; return Builder.CreateCall(F, Ops, "binop"); } Value *CallExprAST::codegen() { //       Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV("Unknown function referenced"); // ,    . if (CalleeF-&gt;arg_size() != Args.size()) return LogErrorV("Incorrect # arguments passed"); std::vector&lt;Value *&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder.CreateCall(CalleeF, ArgsV, "calltmp"); } Value *IfExprAST::codegen() { Value *CondV = Cond-&gt;codegen(); if (!CondV) return nullptr; //          0.0. CondV = Builder.CreateFCmpONE( CondV, ConstantFP::get(TheContext, APFloat(0.0)), "ifcond"); Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //    then  else.   'then'  //   BasicBlock *ThenBB = BasicBlock::Create(TheContext, "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(TheContext, "else"); BasicBlock *MergeBB = BasicBlock::Create(TheContext, "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB); //  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;codegen(); if (!ThenV) return nullptr; Builder.CreateBr(MergeBB); //    'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock(); //   "else" TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;codegen(); if (!ElseV) return nullptr; Builder.CreateBr(MergeBB); //    'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock(); //    TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; } //  for-loop : // var = alloca double // ... // start = startexpr // store start -&gt; var // goto loop // loop: // ... // bodyexpr // ... // loopend: // step = stepexpr // endcond = endexpr // // curvar = load var // nextvar = curvar + step // store nextvar -&gt; var // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //   alloca      AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); //    ,  'variable'    Value *StartVal = Start-&gt;codegen(); if (!StartVal) return nullptr; //    alloca. Builder.CreateStore(StartVal, Alloca); //       ,     // . BasicBlock *LoopBB = BasicBlock::Create(TheContext, "loop", TheFunction); //        LoopBB. Builder.CreateBr(LoopBB); //    LoopBB. Builder.SetInsertPoint(LoopBB); //  ,    PHI-.   //   ,    ,   . AllocaInst *OldVal = NamedValues[VarName]; NamedValues[VarName] = Alloca; //   . ,    ,   //  BB. ,    ,   ,   //  . if (!Body-&gt;codegen()) return nullptr; //    Value *StepVal = nullptr; if (Step) { StepVal = Step-&gt;codegen(); if (!StepVal) return nullptr; } else { //   ,  1.0. StepVal = ConstantFP::get(TheContext, APFloat(1.0)); } //    Value *EndCond = End-&gt;codegen(); if (!EndCond) return nullptr; // , ,   alloca.   //        Value *CurVar = Builder.CreateLoad(Alloca, VarName.c_str()); Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, "nextvar"); Builder.CreateStore(NextVar, Alloca); //          0.0. EndCond = Builder.CreateFCmpONE( EndCond, ConstantFP::get(TheContext, APFloat(0.0)), "loopcond"); //   " "    BasicBlock *AfterBB = BasicBlock::Create(TheContext, "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB); //    . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //    0.0. return Constant::getNullValue(Type::getDoubleTy(TheContext)); } Value *VarExprAST::codegen() { std::vector&lt;AllocaInst *&gt; OldBindings; Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //       for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string &amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get(); //     ,   //      ,   // l  : // var a = 1 in // var a = a in ... #    'a'. Value *InitVal; if (Init) { InitVal = Init-&gt;codegen(); if (!InitVal) return nullptr; } else { // If not specified, use 0.0. InitVal = ConstantFP::get(TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder.CreateStore(InitVal, Alloca); //    OldBindings.push_back(NamedValues[VarName]); //   NamedValues[VarName] = Alloca; } //       Value *BodyVal = Body-&gt;codegen(); if (!BodyVal) return nullptr; //    for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; //     return BodyVal; } Function *PrototypeAST::codegen() { //   : double(double,double) etc. std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); //    unsigned Idx = 0; for (auto &amp;Arg : F-&gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { //      FunctionProtos,   //    . auto &amp;P = *Proto; FunctionProtos[Proto-&gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; //   ,   if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); //        BasicBlock *BB = BasicBlock::Create(TheContext, "entry", TheFunction); Builder.SetInsertPoint(BB); //      NamedValues. NamedValues.clear(); for (auto &amp;Arg : TheFunction-&gt;args()) { //   alloca   AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); //     alloca. Builder.CreateStore(&amp;Arg, Alloca); //      NamedValues[Arg.getName()] = Alloca; } if (Value *RetVal = Body-&gt;codegen()) { // Finish off the function. Builder.CreateRet(RetVal); //    verifyFunction(*TheFunction); //     TheFPM-&gt;run(*TheFunction); return TheFunction; } //    ,   TheFunction-&gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// //     JIT //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { //    TheModule = llvm::make_unique&lt;Module&gt;("my cool jit", TheContext); TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout()); //       TheFPM = llvm::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get()); //   alloca   TheFPM-&gt;add(createPromoteMemoryToRegisterPass()); //   "peephole"-. TheFPM-&gt;add(createInstructionCombiningPass()); //   TheFPM-&gt;add(createReassociatePass()); //    TheFPM-&gt;add(createGVNPass()); //    (    ..). TheFPM-&gt;add(createCFGSimplificationPass()); TheFPM-&gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-&gt;codegen()) { fprintf(stderr, "Read function definition:"); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); TheJIT-&gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); } } else { //       getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-&gt;codegen()) { fprintf(stderr, "Read extern: "); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST); } } else { //       getNextToken(); } } static void HandleTopLevelExpression() { //       if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-&gt;codegen()) { // JIT  ,    //    auto H = TheJIT-&gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); //  JIT   __anon_expr auto ExprSymbol = TheJIT-&gt;findSymbol("__anon_expr"); assert(ExprSymbol &amp;&amp; "Function not found"); //         (  // ,  double)      . double (*FP)() = (double (*)())(intptr_t)cantFail(ExprSymbol.getAddress()); fprintf(stderr, "Evaluated to %f\n", FP()); //     JIT. TheJIT-&gt;removeModule(H); } } else { //       getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': //       getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,        //===----------------------------------------------------------------------===// #ifdef LLVM_ON_WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar,  double,  0. extern "C" DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf,  double   "%f\n",  0. extern "C" DLLEXPORT double printd(double X) { fprintf(stderr, "%f\n", X); return 0; } //===----------------------------------------------------------------------===// //  main //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); //     // 1 -    BinopPrecedence['='] = 2; BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . //    fprintf(stderr, "ready&gt; "); getNextToken(); TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;(); InitializeModuleAndPassManager(); //    MainLoop(); return 0; }</span></span></span></span></code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/336468/">https://habr.com/ru/post/336468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336458/index.html">Ideas about new features of ordinary / parallel programming (extension C ++)</a></li>
<li><a href="../336460/index.html">Talk about Virtual Reality. Conversation number 1. Really about Virtuality</a></li>
<li><a href="../336462/index.html">Dagger 2.11 & Android. Part 2</a></li>
<li><a href="../336464/index.html">Dealing with complexity in an application layer network protocol</a></li>
<li><a href="../336466/index.html">We check the browser for support of certain CSS properties</a></li>
<li><a href="../336470/index.html">Why GitHub can't host the Linux kernel</a></li>
<li><a href="../336474/index.html">Work and life in Bulgaria</a></li>
<li><a href="../336476/index.html">Desktop GUI tests in Python. Lecture in Yandex</a></li>
<li><a href="../336478/index.html">We sharpen a tool on PyQt</a></li>
<li><a href="../336480/index.html">Solving the direct and dual problems of linear programming with Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>