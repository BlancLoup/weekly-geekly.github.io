<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Category theory on javascript. Part 1. Category of sets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abstraction is one of the main techniques in IT. Any programming or modeling language, any programming paradigm (procedural, functional, OOP, ...) giv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Category theory on javascript. Part 1. Category of sets</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0d2/7f2/6da/0d27f26da1724b63b8bb0573b10ba39e.jpg"><br><br>  Abstraction is one of the main techniques in IT.  Any programming or modeling language, any programming paradigm (procedural, functional, OOP, ...) give an answer to the question of how and from what to abstract.  Moreover, the adherents of each approach offer some kind of abstraction of their own. <br><br>  If you want to see a true, universal abstraction, then <s>join our ...</s> study category theory.  The article on the example of the category of sets with pictures and JavaScript-code explains the most basic concepts of category theory: limits, universal property.  The computational aspect of category theory is considered. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Also it says a little about classes, impurities and mixes in JavaScript. <br><br>  Examples from the article can be found <a href="https://aresekb.github.io/categoricaljs/Set.html">here</a> . <br><a name="habracut"></a><br><h3>  <font color="#902213">Introduction</font> </h3><br>  I think everyone heard about category theory.  We heard that this is a cool silver-bullet theory, with which you can consistently describe very different things.  We heard that it is actively used in functional programming languages.  Some may have even heard of <a href="https://en.wikipedia.org/wiki/Charity_(programming_language)">programming languages</a> or <a href="http://axiom-developer.org/">computer algebra systems</a> , largely based on category theory. <br><br>  There are many books and articles on this subject on the Internet.  But usually they are focused either on mathematicians or on IT scientists who are engaged in science and strange things like Haskell, ML (irony - I don‚Äôt need to put a minus in karma, as is usually the case after mentioning Saint Haskell in vain). <br><br>  And for simple hard workers who earn their living on a piece of bread every day using JavaScript on JavaScript, the benefits of category theory are not very clear.  I do not promise that after reading this series of articles it will become clearer.  But if everything works out, then maybe we even have an application that will do something useful. <br><br>  Immediately I warn you that I have an engineering, not a mathematical, education.  Therefore, if you expect to see in the article strict definitions, proofs of theorems, etc., then you will not see.  Rather, on the contrary, everything will be described "on the fingers."  If you see any inaccuracies, please write, I can be wrong about something. <br><br><h3>  <font color="#902213">What is a category?</font> </h3><br>  A category is anything that is defined for: <br><br><ul><li>  feature class </li><li>  a class of morphisms (arrows) between objects (and, for each object, there is an identical morphism), </li><li>  operation of morphism, <br><ul><li>  which is associative: <br>  (h ‚àò g) ‚àò f = h (g ‚àò f) </li><li> for which identical morphisms are neutral elements: <br>  f ‚àò id <sub>A</sub> = id <sub>B</sub> ‚àò f = f </li></ul><br></li></ul>  The ‚àò symbol is sometimes omitted: (h g) f = h (g f) <br><br>  Also, instead of the composition, the concatenation of morphisms is sometimes used, so that in the formula they go in the same order as in the diagram: (f; g);  h = f;  (g; h) But such a recording is not as convenient as it seems, therefore it is rarely found.  If we consider the elements in the following articles, you will be convinced of this. <br><br>  To construct a category of something, you must <br><br><ul><li>  think up what objects and morphisms will be in this category, </li><li>  do not forget about identical morphisms, </li><li>  think up what is the operation of the composition of morphisms, </li><li>  prove that the composition has the necessary properties </li><li>  ... </li><li>  profit. </li></ul><br>  Morphisms must have exactly one source and one target object.  They can not connect 3 or more objects, can not "hang in the air."  (We do not consider <a href="https://en.wikipedia.org/wiki/Higher_category_theory">categories of higher orders</a> .) <br><br>  The operation of the composition can be applied only to compatible morphisms.  Let there be morphisms f: A ‚Üí B, g: B ‚Üí C, and h: C ‚Üí D. The composition g ‚àò f (or f; g) is admissible.  The following compositions are not allowed: h ‚àò f, f ‚àò f, f ‚àò g. <br><br>  Now consider an example category.  Imagine an elementary topos, it is a category.  If presented, it is unlikely that you will find in this article for yourself something new.  It is better to read something more fundamental. <br><br><h3>  <font color="#902213">Example of free category generated by a graph</font> </h3><br>  If you still continue to read, then try to construct a more understandable category.  Submit your VKontakte page, as well as the pages of your friends, subscribers, and those you are following ‚Äî everyone you are directly connected to.  This will be the feature <b>class</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dcc/eb8/381/dcceb8381123437cba16327a834ff5cb.png"></div><br>  For everyone you subscribe to, draw an arrow from your page to that person‚Äôs page.  For everyone who is following you, draw an arrow from their pages to yours.  And for all your friends, draw arrows in both directions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ba8/b5c/85d/ba8b5c85dc754439b3481518810ba022.png"></div><br>  Now do the same for the rest of the pages: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/39b/ea5/146/39bea5146429464fb7de78910e670fb0.png"></div><br>  We assume that if one person is subscribed to another, then the first one knows the second.  If two people are signed on each other (they are friends), then they know each other.  Those.  <b>morphism</b> in our category - this relationship "knows". <br><br>  We assume that everyone knows themselves and draw <b>identical morphisms</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/014/9c4/a77/0149c4a7728e4a489d2b3b575d1185b1.png"></div><br>  We define the <b>operation of the composition of morphisms</b> as follows. <br><br>  Let f be a morphism denoting that A knows B, and g is a morphism denoting that B knows C. Then g ‚àò f is a morphism that means that A indirectly knows C. <br><br>  <b>Thus, the class of morphisms in our category includes not only the relation ‚Äúknows‚Äù, but also ‚Äúindirectly knows‚Äù.</b> <br><br>  <b>The associativity of the operation of the composition</b> is obvious.  If A knows B, who knows C, who knows D, then how not to group morphisms here, anyway A indirectly knows D. <br><br>  The fact that identical morphisms are <b>neutral elements of the composition is</b> also obvious.  If A knows B, then the fact that they know themselves does not change anything. <br><br>  We built a <a href="https://en.wikipedia.org/wiki/Free_category">free category generated by a graph</a> .  On the one hand, this example shows how a category can be built from anything.  On the other hand, it shows that categories are built according to certain rules. <br><br><h3>  <font color="#902213">Preorder example</font> </h3><br>  In the previous example, the objects and morphisms are relatively simple, we believe that they have no internal structure. <br><br>  Now imagine that all the pages (yours and the people with whom you are associated) are one object.  The set of pages related to another person is another object, and so on: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/78c/0a4/310/78c0a4310d32423e8a167ba06eafffb0.png"></div><br>  What morphisms can be in this category? <br><br>  For example, the "subset" relationship.  If every friend, subscriber, etc.  person A is also another subscriber, etc.  of a person B, then draw a morphism from A to B. In this case we get a <a href="https://en.wikipedia.org/wiki/Preorder">preorder</a> , which is a category: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9b7/d4d/654/9b7d4d654ea04faeb24003647b622c72.png"></div><br>  Or, for example, as morphisms, we can use functions that take pages as arguments and return some other pages for them.  In this case, we get the category of sets.  More precisely, its subcategory, because the category of sets contains all the sets, and not just the set of pages in VKontakte. <br><br><h3>  <font color="#902213">Commutative diagrams</font> </h3><br>  In the examples reviewed, I identified diagrams with categories.  But, in general, these are different things.  Strictly speaking, a <a href="https://en.wikipedia.org/wiki/Diagram_(category_theory)">diagram</a> is a functor.  What is a functor for us is not important. <br><br>  In one of the previous <a href="https://habrahabr.ru/company/cit/blog/267335/">articles,</a> we have already noted that a model and its presentation in some notation (a diagram, a textual representation or some other) are two different things.  Similarly with categories. <br><br>  For now, we will assume that a diagram is a kind of visual representation of a category fragment in which objects are depicted as nodes, and morphisms as arrows between nodes.  However, the diagram can sometimes depict the entire category as a whole, and not just its fragment.  There are categories containing only one or several objects and morphisms. <br><br>  Diagrams can be commutative or noncommutative. <br><br>  A commutative diagram is a diagram in which for any pair of objects the result of the composition of morphisms does not depend on the choice of a directed path between these objects. <br><br>  Personally, I did not immediately understand how a diagram can be non-commutative.  Look at the examples of the free category generated by the graph and the preorder above.  If there are several paths between two objects, then obviously all these paths are equivalent - they begin with one object and end with one object.  How can these paths be nonequivalent? <br><br>  The fact is that in the preorder from a certain object A to a certain object B there can be at most one morphism.  In a free category between a pair of objects there can be more than one morphism (see the discussion in the comments), but in this example it is intuitively clear that these morphisms are equivalent: they always reflect the fact that person A directly or indirectly knows person B. But, for example, in the category of sets between the same pair of objects there can be several completely different morphisms.  Consider as an example a very simple diagram with two objects and two parallel morphisms.  Is it commutative? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f50/637/581/f50637581d484d00ae3e0ee6a35c5b39.png"></div><br>  It will be commutative if and only if the equality f = g holds.  In general, in category theory, commutative diagrams are often used as an alternative to writing systems of equations.  You can write "the following equalities hold" and list them.  Or you can write ‚Äúthe following diagram is commutative‚Äù and draw a diagram corresponding to the system of equations. <br><br>  The commutativity of this diagram depends on what sets and functions are behind the drawn objects and morphisms.  Let object A be a set of numbers, object B is a set of geometric figures, morphism f is a function that for some number returns a circle with a radius equal to that number, morphism g is a function that for some number returns a square with side length equal to this number.  Obviously, these two functions are not equal, which means that the diagram is noncommutative: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0d7/23d/a09/0d723da0958b4bffb72a61ac694ed70e.png"></div><br>  Do not be confused by the fact that in one category there are mixed sets of numbers and sets of figures.  In the same category there can be sets of VKontakte pages, sets of sets, graphs, cats and anything else - all this is one category of sets.  Let's look at it in more detail, but first, a little general information about the source code. <br><br><h3>  <font color="#902213">General Source Code Information</font> </h3><br>  Source codes are available <a href="https://github.com/AresEkb/categoricaljs">here</a> , and examples from the article <a href="https://aresekb.github.io/categoricaljs/Set.html">here</a> . <br><br>  Immediately I warn you that I wrote most of the code 3 years ago, when there was no ES6 yet, and there were no normal collections in the standard library.  I then had to implement my Set.  And, in general, the code is probably not very well organized.  I honestly tried to decompose everything in modules, read the <a href="https://habrahabr.ru/post/312022/">article</a> and realized that category theory looks much simpler than all this tin. <br><br>  In the Helpers.js file, along with other auxiliary functions, the extend and combine functions are defined.  The extend function has long been invented, it allows you to inherit one class from another and is described in detail <a href="http://javascript.ru/tutorial/object/inheritance">here</a> .  The only thing my implementation can add to the class of impurities.  I highly recommend reading this <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">article about impurities</a> , where they are treated as factories of subclasses, described as they can be compactly described on ES6.  <b>In general, a look at impurities as a more general case of inheritance, in which the superclass is unknown in advance, is quite interesting.</b> <br><br>  Personally, I do not want to bother with Babel, etc., so the source code is written in ES5 and I needed these two functions.  Impurities cannot be inherited as classes using extend; they can only be mixed using the combine method. <br><br>  The category.js file defines an abstract category ‚Äúcategory‚Äù from which specific categories must inherit.  It also defines the impurities ‚Äúfull category‚Äù and ‚Äúfull category‚Äù and their mixture ‚Äúbipolar category‚Äù.  The category of sets, which we will consider below, is once again a bipolar category and some universal algorithms ‚Äúmix in‚Äù with it, which can be used in any bipolar category.  They are implemented precisely as impurities, because JavaScript does not support multiple inheritance.  Further, all this is explained in more detail. <br><br>  The file Set.js defines 1) the category of sets, 2) the sets themselves, 3) functions, and 4) some limits of the category of sets.  Theoretically, the Set class can be replaced by Set from ES6.  Functions are implemented in the form of so-called <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">graphs</a> , i.e.  they explicitly store: <br><br><ul><li>  admissible set of input elements - domain (domain of definition); </li><li>  the admissible result set is the code domain (range of values); </li><li>  set of pairs: input element and the corresponding result element. </li></ul><br>  The domain and code domain are stored explicitly so that you can check whether the composition of two functions is valid.  It is valid only if the domain of the 1st function coincides with the code domain of the 2nd.  Also, a domain is used when checking whether a function is indeed complete or it is a <a href="https://en.wikipedia.org/wiki/Partial_function">partially defined function</a> .  If you look at the code, there are a lot of similar checks (assert calls). <br><br>  Probably, it is possible to store functions in the form of functions, rather than their graphs, but this is not important at all. <br><br>  In the SetCategoryView.js file there is a d3 chart plotter for sets of categories.  Almost all the illustrations in the article are drawn with its help.  By the way, in the 4th version of d3 improved the Force Layout, now there you can independently determine arbitrary forces.  Improved drag'n'drop, if I'm not mistaken, then before it worked only for svg, and now it is easily supported for canvas.  Theoretically you can find something interesting in this drawing, but it requires full refactoring. <br><br>  In the file Set.html all the examples from this article. <br><br><h3>  <font color="#902213">The implementation of the category of sets</font> </h3><br>  Further I will describe various constructions from the category of sets and how they are implemented in the code.  It itself is implemented in the form of the following factory: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCategory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } extend(SetCategory, Category, BicompleteCategory); SetCategory.prototype.object = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elements</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(elements); }; SetCategory.prototype.morphism = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A, B, mapping</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalFunction(A, B, mapping); }; SetCategory.prototype.id = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.morphism(A, A).initId(); }; SetCategory.prototype.compose = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g, f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g.compose(f); };</code> </pre> <br>  The category of sets is inherited from an abstract category and the behavior of the bipolar category is mixed with it. <br><br>  This factory allows you to create <br><br><ul><li>  objects (which are sets); </li><li>  morphisms (which are functions that map the elements of some set A to the elements of some set B); </li><li>  identical morphisms (which are the identity mappings of some set A onto itself); </li><li>  compositions of two morphisms. </li></ul><br>  Frankly, I did not immediately realize why categories should be factories.  For example, sets, lists, stacks, trees, graphs, and other structures usually explicitly store all their elements.  Categories are like similar mathematical structures, but why are they implemented differently?  Why is it impossible to implement a category as a repository of its objects and morphisms?  Because in the general case a category contains an infinite number of objects and morphisms.  Moreover, of them we need only a few.  And they need not so much to store as to construct on their basis new objects and morphisms. <br><br>  Create several objects and morphisms: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> setCat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetCategory(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj123 = setCat.object([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objAB = setCat.object([<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objABCD = setCat.object([<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = setCat.morphism(obj123, objABCD, {<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = setCat.morphism(objABCD, objAB, {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-string"><span class="hljs-string">'b'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> h = setCat.morphism(objAB, obj123, {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); showSetCategoryView(<span class="hljs-string"><span class="hljs-string">'diagram1'</span></span>, setCat, {<span class="hljs-string"><span class="hljs-string">'A'</span></span>: obj123, <span class="hljs-string"><span class="hljs-string">'B'</span></span>: objABCD, <span class="hljs-string"><span class="hljs-string">'C'</span></span>: objAB}, {<span class="hljs-string"><span class="hljs-string">'f'</span></span>: {<span class="hljs-attr"><span class="hljs-attr">dom</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">codom</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-attr"><span class="hljs-attr">morphism</span></span>: f}, <span class="hljs-string"><span class="hljs-string">'g'</span></span>: {<span class="hljs-attr"><span class="hljs-attr">dom</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-attr"><span class="hljs-attr">codom</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-attr"><span class="hljs-attr">morphism</span></span>: g}, <span class="hljs-string"><span class="hljs-string">'h'</span></span>: {<span class="hljs-attr"><span class="hljs-attr">dom</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-attr"><span class="hljs-attr">codom</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">morphism</span></span>: h}});</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/894/d72/635/894d72635d0c4bf9b0b51b93f69622fb.png"></div><br>  It is a pity that you can not insert into the article executable JavaScript code.  Therefore, it is necessary to insert pictures, but I repeat that you can move all this <a href="https://aresekb.github.io/categoricaljs/Set.html">here</a> . <br><br><h3>  <font color="#902213">Epimorphism, monomorphism, isomorphism</font> </h3><br>  Ok, we can create objects, morphisms and draw them beautifully.  What's next? <br><br>  Objects and morphisms may have different properties, and a significant part of category theory is devoted to the description and study of these properties.  Our implementation of category theory should be able to verify these properties and should be able to construct objects and morphisms with certain properties.  Let's start with the simplest properties. <br><br>  Let me remind you that morphisms in the category of sets are functions.  From school, you probably remember that functions can be surjections, injections, bijections.  I promised that there will be no strict definitions and everything will be explained on the fingers, so get: <br><br>  A surjection is a function that takes all the values ‚Äã‚Äãfrom its range of values.  Say, the squaring function defined on a set of integers is not a surjection because it does not take the value 2, 3, 5, ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/095/e75/797/095e75797c5e4c7dbf3fa6b9146f0beb.png"></div><br>  An injection is a function that maps different elements of the original set to different elements of the result set.  In this case, the range of the function may contain some additional elements that do not have a pre-image in the definition area. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5c0/861/8ed/5c08618ed2184e109a8457b0584298cf.png"></div><br>  Bijection is a one-to-one mapping.  A function is a bijection if and only if it is simultaneously a surjection and an injection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6bb/e1c/fd1/6bbe1cfd16f94ce18f1eb442fedbb6b1.png"></div><br>  For other mathematical objects (for example, graphs) there are some analogs of surjections, injections and bijections.  Therefore, in the theory of categories, since this theory is about everything, they decided to generalize these concepts and introduced epimorphisms, monomorphisms and isomorphisms, respectively. <br><br>  <b>What is this generalization?</b>  <b>In that in the theory of categories we completely abstract away from the internal structure of objects and morphisms.</b>  <b>Instead of defining these types of morphisms through circles and arrows, as is done in the figures above, they are defined in terms of relationships with other morphisms.</b> <br><br>  An epimorphism is a morphism e: A ‚Üí B, such that f ‚àò e = g ‚àò e follows from any equality f = g (in other words, e can be shortened to the right). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9c9/05b/ab7/9c905bab7520495e8c01de3713ce6236.png"></div><br>  To make it clear what is being said, I will give an example of NOT epimorphism: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/072/899/644/07289964402d45969103ed2b618bfedb.png"></div><br>  The diagram above is commutative (f ‚àò h = g ‚àò h).  To make sure of this, you can follow the arrows from each element of the set A and, regardless of the chosen path, you always come to the same element of the set C. Ie  functions f ‚àò h and g ‚àò h for identical arguments return identical results.  But (!) This does not imply the equality of the functions f and g.  For the element "1" they return different values: "a" and "b".  But, if the function h were an epimorphism, then the commutativity of the diagram would imply the equality f and g. <br><br>  Further, I will not describe in detail ‚Äúthe transitions by arrows through circles‚Äù, just keep in mind that when in the category of sets we are talking about commutative diagrams, you can always check this commutativity in this way. <br><br>  <b>I note once again that we have described surjective functions only through correlation with other functions, completely abstracting from the details of their internal structure.</b>  <b>This is the essence of category theory.</b> <br><br>  A monomorphism is a morphism m: A ‚Üí B, such that from every equality m m f = m  g it follows f = g (in other words, m can be abbreviated to the left). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/56b/5f6/94e/56b5f694e50242cbaf06352b8a4b3191.png"></div><br>  An isomorphism is a morphism f: A ‚Üí B for which the inverse exists, that is,  there exists a morphism g: B ‚Üí A such that f ‚àò g = id <sub>B</sub> and g ‚àò f = id <sub>A.</sub> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6a2/bb3/286/6a2bb32868fb45d1ba281f11ecc76dac.png"></div><br>  Here, here is a little surprise.  Not in all categories from the fact that the morphism is an epimorphism and a monomorphism it follows that it is also an isomorphism.  This demonstrates that the category of sets is certainly good for visualizing some concepts, but can lead to false analogies. <br><br><h3>  <font color="#902213">End, Start, and Zero Object</font> </h3><br>  The final object is an object T such that for any object X there exists a unique morphism u: X ‚Üí T. <br><br>  In the category of sets, the final object is a singleton, and a unique morphism is a function that maps any element of the original set to a single element of a singleton.  There are an infinite number of terminal objects in the category of sets; however, they are all isomorphic to each other.  This means that from the point of view of category theory it does not matter which particular singlet is being spoken of, everything that is true for one up to isomorphism will be true for any other singleton. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/41e/0ea/be6/41e0eabe61634fc89eed7ebd076bc3bb.png"></div><br>  The initial object is the object I, such that for any object X there exists a unique morphism u: I ‚Üí X. <br><br>  In the category of sets, the initial object is an empty set, and a unique morphzyme defined on an empty set is an empty function.  Moreover, there is a unique empty set, respectively, in the category of sets a single initial object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/795/692/155/79569215579d4f4a9238beac41b23c98.png"></div><br>  A null object is an object that is both the initial and the final object. <br><br>  There are no zero objects in the category of sets, since  the set cannot be simultaneously empty and singleton. <br><br>  We note several important points. <br><br>  <b>The initial and final objects are dual concepts, they are equivalent up to the inversion of the direction of morphisms.</b>  <b>The initial object will be the final object in the dual category (categories with the same objects and the operation of composition, but with morphisms directed in the opposite direction).</b>  <b>The idea of ‚Äã‚Äãduality or duality is very important in category theory.</b>  <b>Further you will see some more examples of dual concepts.</b> <br><br>  By the way, the end objects can be called konachalnymi, and the initial - kokonechnye, but here we already fall into the domain of one <a href="https://github.com/Ky6uk/PETOOH">fundamentally new programming language</a> .  If we add or remove the prefix "ko-" from the concept, we get a dual concept.  I did not meet cocooned objects, although a category theory specialist must understand that we are talking about initial objects. <br><br>  In the definitions above, nothing is said about morphisms directed from the final object.  And they exist.  For example, a certain morphism f: {1} ‚Üí {1,2,3,4} with the graph {(1,1)} or the morphism g with the same signature, but the graph {(1,2)}.  Those.  they not only exist, but are not yet unique, and, looking ahead, play quite an important role.  Therefore, the idea of ‚Äã‚Äãfinal objects as objects whose morphisms are directed only to them is not true. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea0/3f7/264/ea03f72644a8477c86e4360dc31fe1ca.png"></div><br>  As for the morphisms directed to the initial objects, I cannot say anything.  I assume that in the category of sets they are either not present or they are empty unique functions.  In principle, why should they not be.  But then, each set will be isomorphic to the empty set.  If someone could clarify this point, it would be great. <br><br><h3>  <font color="#902213">Universal property and the most important point</font> </h3><br>  Pay attention to the phrase "... there is a single morphism ..." in the definitions above.  It is commonly found in works on category theory.  This is called the " <a href="https://en.wikipedia.org/wiki/Universal_property">universal property</a> ." <br><br>  <b>Universal property allows you to define the concept, abstracting from the details.</b>  <b>You see that the initial and final objects are defined without mentioning empty sets, singletones, yes, and, in general, any structures.</b>  <b>Here, this is a real abstraction!</b>  I think that in the category theory guides for developers, you need to talk first of all about such things, and not about <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">Cartesian closed categories</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25B7%25D0%25B0_%25D0%259C%25D0%25B8%25D1%2580%25D0%25B0">monads</a> . <br><br>  In other words, in the theory of categories you define objects, focusing not on the description of their internal implementation, but on the description of their external behavior, how they can ‚Äúinteract‚Äù with other objects, in fact, you describe their interface.  True, a little differently than it is usually done in programming languages, but this theory of categories is also interesting. <br><br>  Due to abstraction from details, the universal property defines an object up to isomorphism.  We have already noted above that in the category of sets, all finite objects (singletons) are isomorphic.  But this is true for any objects defined through the universal property.  In principle, this is quite logical: if two objects outwardly "behave" in the same way (one universal property holds for them), then they are isomorphic. <br><br>  <b>And, probably, the most important point that underlies this entire series of articles.</b>  <b>Behind universal properties there is usually some optimization problem, which consists in finding the best in some sense objects or morphisms.</b>  <b>We will return to this in the section about equalizers.</b> <br><br><h3>  <font color="#902213">Implementing end and start objects</font> </h3><br><div class="spoiler">  <b class="spoiler_title">Too much theory, let's see how the final and initial objects are implemented in the code.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.terminal = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetTerminalObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerminalObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetTerminalObject.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>([<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } SetTerminalObject.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; A.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ mapping[el] = <span class="hljs-number"><span class="hljs-number">1</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(A, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, mapping); } SetCategory.prototype.initial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetInitialObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInitialObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetInitialObject.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } SetInitialObject.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, A, {}); }</code> </pre></div></div><br>  You may have a question: why so much code to implement a singleton and NULL set ??? <br><br>  The final and initial objects are not just some sets.  For them, the universal property must also be satisfied, which is not of some theoretical nature, but it is actively used in calculations.  For example, when calculating an addition to a codecard square, a universal morphism is calculated for the sum of the objects.  We will come back to this later. <br><br>  In our implementation, constructions with a universal property will have methods: <br><br><ul><li>  calculate - creates some universal construction or assembles it from other constructions, </li><li>  complement - creates a universal structure from not very typical components, </li><li>  univ - calculates universal morphisms for this construction. </li></ul><br><h3>  <font color="#902213">Composition</font> </h3><br>  We continue the loose definitions on the fingers and consider slightly more complex objects. <br><br>  The product of objects X <sub>j</sub> is an object X and morphisms œÄ <sub>j</sub> : X ‚Üí X <sub>j</sub> , called canonical projections, such that for any object Y and morphisms f <sub>j</sub> : Y ‚Üí X <sub>j</sub> there exists a unique morphism u: Y ‚Üí X, such that œÄ <sub>j</sub> ‚àò u = f <sub>j</sub> . <br><br>  In category theory, instead of writing equations of the form œÄ <sub>j</sub> ‚àò u = f <sub>j,</sub> you can draw a similar diagram and say that it is commutative (an example for two objects, but in the general case there may be more): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/91e/3c0/cc0/91e3c0cc0f3b4e879ef64f4462a24272.png"></div><br>  In the category of sets, the product of objects is the Cartesian product of sets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fac/c90/e0c/facc90e0cc95482ab301b553ca8f756b.png"></div><br>  In the picture, the product is designated as AxB, and its elements as pairs of elements from the original sets.  But this is done for clarity and not necessarily!  The work can be called as you like, and its elements can be <br><br><ul><li>  1, 2, 3, ... </li><li>  square, circle, triangle, ... </li><li>  or whatever. </li></ul><br>  <b>The product is defined not as a set of pairs of values, but through relations between morphisms.</b>  <b>Compare the definitions of the Cartesian product of sets and the product of objects in category theory ‚Äî they have nothing in common.</b>  <b>You again see an example of abstraction from details in category theory.</b> <br><br><div class="spoiler">  <b class="spoiler_title">In the code, the work is implemented as follows.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.product = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A, B</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetProduct(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(A, B); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetProduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetProduct.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A, B</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping2 = {}; A.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ B.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = [x, y].toString(); obj.add(z); mapping1[z] = x; mapping2[z] = y; }); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = obj; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, A, mapping1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, B, mapping2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; SetProduct.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, n</span></span></span><span class="hljs-function">) </span></span>{ assertEqualDom(m, n); assertEqualCodom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f, m); assertEqualCodom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g, n); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = m.dom(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; obj.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f.preimage(m.image(x)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g.preimage(n.image(x)); mapping[x] = s1.intersection(s2).representative(); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(obj, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, mapping); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f.compose(u), m); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g.compose(u), n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br>  Note that in the calculate function, not only the Cartesian product of sets is calculated, but also two morphisms ‚Äî canonical projections of the product onto the original objects.  In most calculations, they play the main role and, roughly speaking, they are much more important than the set. <br><br>  The univ function calculates a universal morphism (u is in the diagram above) for some object and a pair of morphisms.  Let's see how a universal morphism of a work can be useful. <br><br>  In the following diagram, you see objects A and B, their product AxB, and also some arbitrary object C with morphisms f <sub>1</sub> and f <sub>2</sub> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a34/5a9/e0a/a345a9e0aa344537857db4046a091179.png"></div><br>  You can see that the element ‚Äú1‚Äù of the set C is mapped to the element ‚Äú1‚Äù of the set A and to the element ‚Äúa‚Äù of the set B. Just like the element ‚Äú1, a‚Äù of the set AxB.  When calculating a universal morphism, we set this fact and construct a universal morphism so that it maps the element ‚Äú1‚Äù of the set C to the element ‚Äú1, a‚Äù of the set AxB. <br><br>  The elements ‚Äú4‚Äù and ‚Äú5‚Äù of the set C are mapped by f <sub>1</sub> and f <sub>2</sub> morphisms onto the same elements.  Therefore, the universal morphism maps them to one element ‚Äú2, b‚Äù of the set AxB. <br><br>  For clarity, imagine that C is the set of monkeys.  f <sub>1</sub> each monkey belongs to one of the categories: beautiful or ugly, and f <sub>2</sub> to one of the categories: smart or stupid.  Then the universal morphism u refers each monkey to one of four categories: beautiful and intelligent, beautiful and stupid, ugly and intelligent, ugly and stupid. <br><br>  In fact, the universal morphism for a work is a product of morphisms. <br><br>  The work in different forms is implemented in various programming languages.  These are structures, tuples, and all sorts of joines in SQL, LINQ, etc.  Read about the <a href="https://en.wikipedia.org/wiki/Product_type">types of works</a> . <br><br>  In JavaScript, canonical projections of a work can be viewed as destructors or accessors: <br><br><pre> <code class="javascript hljs">monkeyKind.a monkeyKind.b</code> </pre><br>  and universal morphisms as constructors: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">a</span></span> : isBeautiful(x), <span class="hljs-attr"><span class="hljs-attr">b</span></span> : isSmart(x) }; }</code> </pre><br>  In the theory of categories, accessors are often called destructors, because they make it possible to disassemble a complex object into its component parts, they are dual to designers.  When you call such a destructor object does not necessarily have to be destroyed. <br><br><h3>  <font color="#902213">Amount</font> </h3><br>  The sum of objects X <sub>j</sub> is an object X and morphisms i <sub>j</sub> : X <sub>j</sub> ‚Üí X, called canonical embeddings, such that for any object Y and morphisms f <sub>j</sub> : X <sub>j</sub> ‚Üí Y there exists a unique morphism u: X ‚Üí Y, such that u ‚àò i <sub>j</sub> = f <sub>j</sub> . <br><br>  An example of a commutative diagram for two objects: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a61/cfc/9a6/a61cfc9a69ef416093e383a793002892.png"></div><br>  In the category of sets, the sum of objects is the disjunctive union of sets.  Those.  if there are coinciding objects in the merged sets, then these objects will not merge, but, roughly speaking, will be marked in some way so that you can understand from which set each object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/981/b5e/8d4/981b5e8d40034596b247e65632784180.png"></div><br>  In set theory, elements of a disjunctive union are usually tagged with some tags or indices, for example, 1 <sub>A</sub> , 2 <sub>A</sub> , 3 <sub>A</sub> , a <sub>B</sub> , b <sub>B.</sub>  But in our example, the elements of the sum are simply numbers from 1 to 5, which are associated with the elements of the original set by the morphisms f and g.  And it is these morphisms that "tag" the elements of the sum.  As for the work, the set itself without morphisms does not play a special role. <br><br>  Obviously, the product and the sum are dual concepts.  They are formulated in a similar way up to inversion of morphisms. <br><br>  But this generalization does not end there.  The product and the sum are very similar to the final and initial objects, respectively.  For products and finite objects, it is possible <i>to</i> construct a universal morphism <i>from each</i> category object satisfying certain conditions ‚Äî such constructions are called <i>limits</i> .  For the sum and the initial object, it is possible <i>to</i> construct a universal morphism <i>for each</i> category object that satisfies certain conditions ‚Äî such constructions are called <i>constraints</i> .  Further you will see some more examples of limits and values. <br><br>  In the general case, (ko) limits are (ko) cones defined for some diagram.  As I said before, a diagram is a functor from some index category to the current category.  If roughly, then the index category determines the ‚Äúform‚Äù, ‚Äútype‚Äù of the diagram and ultimately determines what (co) limit we will get (the final object, the product, ...).  If we further develop this thought, then we risk calling a cacdemoon. <br><br><img src="https://habrastorage.org/files/3fc/eff/34f/3fceff34f3ed446dba788215653f1a91.jpg"><br><br>  In short, the idea is that even such general concepts as we discussed above can be generalized even more. <br><br>  ,     ,    ,      ()   ¬´¬ª .           . <br><br><div class="spoiler"> <b class="spoiler_title">      ().</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.coproduct = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A, B</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetCoproduct(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(A, B); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCoproduct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetCoproduct.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A, B</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInjection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set, obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; set.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ obj.add(elementCount); mapping[x] = elementCount; elementCount++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapping; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(A, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, createInjection(A, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(B, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, createInjection(B, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; SetCoproduct.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, n</span></span></span><span class="hljs-function">) </span></span>{ assertEqualCodom(m, n); assertEqualDom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f, m); assertEqualDom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g, n); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = m.codom(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMappings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, h</span></span></span><span class="hljs-function">) </span></span>{ h.dom().forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ mapping[f.image(x)] = h.image(x); }); } addMappings(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f, m); addMappings(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g, n); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, obj, mapping); assertCommutes(u.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f), m); assertCommutes(u.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g), n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br>  ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ac8/f43/d78/ac8f43d783604911974db603bb7fef99.png"></div><br> ,          ,    ‚Äì  .  ‚Äì   . <br><br> ,        ,    ‚Äì  .   <a href="https://en.wikipedia.org/wiki/Sum_type">-</a> .            .  ,     <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">  </a>  <a href="https://en.wikipedia.org/wiki/Pattern_matching">  </a> .   JavaScript  ,     . <br><br>        ‚Äì    ‚Äì   : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chimpanzee</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Gorilla</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }</code> </pre><br>         p,    ‚Äì q,       ‚Äì    C. , C ‚Äì  : , , .  p  ,        ,   q    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Chimpanzee) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p(x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Gorilla) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> q(x); } }</code> </pre><br><h3> <font color="#902213"> (  )</font> </h3><br>   -    ,        - .    , ,      ?   , ,        coproduct complement.           . ,  ,   . <br><br>     A+B,     A      i <sub>1</sub> .     i <sub>1</sub> ,    A,   ‚Äì A+B.       i <sub>2</sub> ,        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/59a/d47/d02/59ad47d02f9a4b3e83ceee63bdf14a1b.png"></div><br><div class="spoiler"> <b class="spoiler_title">   .</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.coproductComplement = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetCoproduct(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).complement(f); }; SetCoproduct.prototype.complement = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = f.codom(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(f.codom().diff(f.image()), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj).initId(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; };</code> </pre></div></div><br>        N-,    .        .            . <br><br><h3> <font color="#902213"></font> </h3><br>     ()    (   )     (  ).   ()    , ..      . <br><br>    f, g : X ‚Üí Y ‚Äì   E   eq : E ‚Üí X,   f ‚àò eq = g ‚àò eq     O   m : O ‚Üí X  f ‚àò m = g ‚àò m,     u : O ‚Üí E,   eq ‚àò u = m, ..   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/be9/b38/6fe/be9b386fe63943be8ab78f42c26cc70a.png"></div><br> ‚Ä¶          .  -          .     . -,           ,    ,       .  ,         ,     .   ,      . -,             ,     .  -           .        . <br><br>     f ‚àò eq = g ‚àò eq.     X   eq ,   f  g     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/221/b96/b39/221b96b39fb04104b23283b879f78bb3.png"></div><br>  f  g   ¬´1¬ª  X   ¬´a¬ª  Y. ,   eq     ¬´1¬ª  E   ¬´1¬ª  X,     f(eq(1)) = g(eq(1)) = a.   ,  ,    ¬´1¬ª   E,         Y. <br><br>  f   ¬´2¬ª   ¬´a¬ª,   g   ¬´2¬ª   ¬´b¬ª. ,     eq,     ¬´2¬ª   X  .  Those.        f(eq(?)) = a     g(eq(?)) = b,    ¬´a¬ª   ¬´b¬ª. <br><br>        X  Y      E  eq.   ¬´1¬ª  ¬´3¬ª   f  g . <br><br>     ,   E  eq    -   f  g.      O   m  u?   ,   E   eq,   ,  .    O  m,     f ‚àò m = g ‚àò m. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/722/c5f/182/722c5f18213e4e9bba66887ab94f4688.png"></div><br> <b>,  m  f  g  ,  eq.   eq  m?       . ,  E  eq ,  O  m  , , .        ,        ,  ,    ,         .  -       ,     ,       .</b> <br><br> ,       ?     .   E   O     h,     m ‚àò h = eq,  {(1,1),(3,3)}  {(1,2),(3,3)}. , , O  m   ,        . <br><br> , ,  E  eq   - .       O  m   u = {(1,1),(2,1),(3,3)}.   O  m,    f ‚àò m = g ‚àò m,    ,    . <br><br>    O  m       E  eq?    ?  ,         . <br><br>   ,       ,   JavaScript! ,     ,   ,          (). <br><br><div class="spoiler"> <b class="spoiler_title">       (),  .</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.equalizer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetEqualizer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(f, g); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEqualizer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetEqualizer.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ assertParallel(f, g); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> codom = f.dom(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(dom, codom); f.dom().forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f.image(x) == g.image(x)) { dom.add(x); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.push(x, x); } }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.dom(); assertCommutes(f.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q), g.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } SetEqualizer.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function">) </span></span>{ assertEqualCodom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q, m); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f().compose(m), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g().compose(m)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; m.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ mapping[x] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.preimage(y).representative(); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(m.dom(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj, mapping); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.compose(u), m); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br>    .      ,    ‚Äì  .    ,   f ‚àò eq = g ‚àò eq       f ‚àò m = g ‚àò m ‚Ä¶ . ,  ,   ?          . <br><br>              f = g. , ,     ,   f    g.  , ,  ,    .    ,       .  f  g  ,   eq    (   ). <br><br> ,      ?     .       O   E  .   , ,      ‚Äì   (   ),    ,     . <br><br>      ?    ,   ¬´¬ª        ,     (, )    .    ,    ,      . <br><br><h3> <font color="#902213"></font> </h3><br>    f, g : X ‚Üí Y ‚Äì   Q   q : Y ‚Üí Q,   q ‚àò f = q ‚àò g     O   m : Y ‚Üí O  m ‚àò f = m ‚àò g,     u : Q ‚Üí O,   u ‚àò q = m, ..   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b7e/7f9/e8c/b7e7f9e8c7a64ce195514b83fa6e062d.png"></div><br>  ,    ,      . ,   ,   ,      ,      . <br><br>        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c3e/ce6/c68/c3ece6c68cf54fce9b1a4e61e5bfe488.png"></div><br>   f  g,     ,   ¬´1¬ª  X   ¬´a¬ª  Y.    q(f(1)) = q(g(1)), ,   q    ¬´a¬ª    ¬´a¬ª  Q. <br><br>  f   ¬´2¬ª   ¬´b¬ª,   g   ¬´2¬ª   ¬´c¬ª.    q(f(2)) = q(g(2)),  q    ¬´b¬ª  ¬´c¬ª    ¬´b¬ª  Q.  ,    ¬´b¬ª  ¬´c¬ª     ¬´b¬ª. <br><br>  f   ¬´3¬ª   ¬´c¬ª,   g   ¬´3¬ª   ¬´d¬ª.   ,  ,  ¬´c¬ª  ¬´d¬ª      .  ¬´c¬ª    ¬´b¬ª,      ,     ¬´d¬ª   ¬´b¬ª. <br><br>     ¬´e¬ª   ¬´e¬ª  ¬´f¬ª.     Q   q. <br><br> ,   ,      O   m,           m ‚àò f = m ‚àò g. , O  m   ,  Q  q. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ee7/d5f/5c8/ee7d5f5c8da440ac90ab14cbbf4c6f6d.png"></div><br>  O  m    ,        ,       ,  Q  q.  ,    ,     ¬´a¬ª  ¬´b¬ª,     ¬´1¬ª. <br><br> <b>   ,              .     ‚Äì      . ,          ()     .</b> <br><br><div class="spoiler"> <b class="spoiler_title">,     .</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SetCategory.prototype.coequalizer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetCoequalizer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(f, g); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCoequalizer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } SetCoequalizer.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ assertParallel(f, g); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dom = f.codom(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> codom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eq = {}; f.dom().forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fx = f.image(x); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gx = g.image(x); eq[fx] = eq[gx] = has(eq, fx) ? eq[fx] : has(eq, gx) ? eq[gx] : fx; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(dom, codom); dom.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = eq[s] || s; codom.add(t); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.push(s, t); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.codom(); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.compose(f), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.compose(g)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } SetCoequalizer.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function">) </span></span>{ assertEqualDom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q, m); assertCommutes(m.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f()), m.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g())); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapping = {}; m.dom().forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ mapping[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.image(x)] = m.image(x); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().morphism(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.codom(), m.codom(), mapping); assertCommutes(u.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q), m); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br> <b> ‚Äì        .      :     ,      ,  .          .       .</b> <br><br><h3> <font color="#902213">  ( )</font> </h3><br>      .  ,      ,     ?       ‚Äì  . <br><br>    f : X ‚Üí Z  g : Y ‚Üí Z ‚Äì   P   p : P ‚Üí X  q : P ‚Üí Y,   f ‚àò p = g ‚àò q     Q   m : Q ‚Üí X  n : Q ‚Üí Y,  f ‚àò m = g ‚àò n,     u : Q ‚Üí P,   p ‚àò u = m  q ‚àò u = n, ..   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/596/a1f/d0f/596a1fd0f7a9490db87ffb55b1a82f2f.png"></div><br>  ,      -  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5ee/527/d7e/5ee527d7e42945249798fa2839a96eef.png"></div><br>   ,   P      X  Y,    ,      ,   ,     f  g         Z. <br><br>             ,   ,        ,     . <br><br><div class="spoiler"> <b class="spoiler_title">       .</b> <div class="spoiler_text"><pre> <code class="javascript hljs">CompleteCategory.prototype.pullback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pullback(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(f, g); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pullback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } Pullback.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ assertEqualCodom(f, g); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = g; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prod = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().product(f.dom(), g.dom()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prod; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eq = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().equalizer(f.compose(prod.f), g.compose(prod.g)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.equalizer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eq; }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p = prod.f.compose(eq.q); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q = prod.g.compose(eq.q); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = eq.obj; assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } Pullback.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, n</span></span></span><span class="hljs-function">) </span></span>{ assertEqualDom(m, n); assertEqualCodom(m, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p); assertEqualCodom(n, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.equalizer().univ(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product().univ(m, n)); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p.compose(u), m); assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.compose(u), n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br>     .     X  Y,         f ‚àò œÄ <sub>1</sub>  g ‚àò œÄ <sub>2</sub> .   ‚Äì     P  .  p   œÄ <sub>1</sub> ‚àò eq,  q ‚Äì  œÄ <sub>2</sub> ‚àò eq.            . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bbc/a8c/bd3/bbca8cbd33944612b657d95e41c8dce1.png"></div><br> <b>,       :   , ,   ..    ,      ,   ,           .   ,         .  ,                ,    .</b> <br><br><h3> <font color="#902213">  ( )</font> </h3><br>    f : Z ‚Üí X  g : Z ‚Üí Y ‚Äì   P   p : X ‚Üí P  q : Y ‚Üí P,   p ‚àò f = q ‚àò g     Q   m : X ‚Üí Q  n : Y ‚Üí Q,  m ‚àò f = n ‚àò g,     u : P ‚Üí Q,   u ‚àò p = m  u ‚àò q = n, ..   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8a2/134/05c/8a213405ce634cf3b9a08203565b40ed.png"></div><br>                 i <sub>1</sub> ‚àò f  i <sub>2</sub> ‚àò g,  i <sub>1</sub>  i <sub>2</sub> ‚Äì      X  Y.  p  q   h ‚àò i <sub>1</sub>  h ‚àò i <sub>2</sub> ,  h ‚Äì  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5f6/925/422/5f692542227f4bf38572efbc942f5787.png"></div><br>  ,  P ‚Äì     X  Y,   ,       Z, : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d7f/563/889/d7f5638893a543e1832c54b9859aea98.png"></div><br>        .    ,   ¬´a¬ª  ¬´b¬ª   X  Y     P   ¬´1¬ª  ¬´2¬ª .  ¬´c¬ª   X     ¬´d¬ª   Y.   ¬´c¬ª   Y      . <br><br>          .    g  q.     f  p,     X   P ,    Y.       .          . <br><br>       ,     (, ,    )    ,          : <br><br><div class="spoiler"> <b class="spoiler_title">       .</b> <div class="spoiler_text"><pre> <code class="javascript hljs">CocompleteCategory.prototype.pushout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pushout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).calculate(f, g); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pushout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cat, f, g</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cat; }; } Pushout.prototype.calculate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) </span></span>{ assertEqualDom(f, g); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g = g; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().coproduct(f.codom(), g.codom()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coproduct = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cp; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ceq = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cat().coequalizer(cp.f.compose(f), cp.g.compose(g)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coequalizer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ceq; }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p = ceq.q.compose(cp.f); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q = ceq.q.compose(cp.g); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obj = ceq.obj; assertCommutes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.g)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } Pushout.prototype.univ = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, n</span></span></span><span class="hljs-function">) </span></span>{ assertEqualCodom(m, n); assertEqualDom(m, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p); assertEqualDom(n, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coequalizer().univ(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coproduct().univ(m, n)); assertCommutes(u.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p), m); assertCommutes(u.compose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q), n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u; };</code> </pre></div></div><br><h3> <font color="#902213"> </font> </h3><br> ,        , ,  JavaScript   ML: <br> ¬ª <a href="http://www.cs.man.ac.uk/~david/categories/">DE Rydeheard, RM Burstall. Computational Category Theory, 1988</a> <br><br>      ,       : <br> ¬ª <a href="https://www2.informatik.uni-erlangen.de/staff/schneider/gtbook/index.html">Hans J√ºrgen Schneider. Graph Transformations. An Introduction to the Categorical Approach, 2011</a> <br><br>   ,  , , ,     ,   : <br> ¬ª <a href="http://www.logicmatters.net/categories/">Peter Smith, Category Theory. A Gentle Introduction, 2016</a> <br><br>    ,      : <br> ¬ª <a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Maarten M. Fokkinga. A Gentle Introduction to Category Theory ‚Äî the calculational approach, 1994</a> <br><br>        ,     : <br> ¬ª <a href="http://www.cs.unibo.it/~asperti/PAPERS/book.pdf">Andrea Asperti, Giuseppe Longo. Categories, Types and Structures. Category Theory for the working computer scientist, 1991</a> <br> ¬ª <a href="https://www.google.ru/search%3Fq%3DMichael%2BBarr%252C%2BCharles%2BWells.%2BCategory%2BTheory%2Bfor%2BComputing%2BScience">Michael Barr, Charles Wells. Category Theory for Computing Science, 1998</a> <br><br> ,     <a href="https://habrahabr.ru/post/305018/">¬´   ¬ª</a> ( <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/"> ‚Äî Bartosz Milewski</a> ), ,   ,     ,   .     ,     . <br><br>         . , ,       .   ,       .         ‚Äî .  ,       ,      .      , ,   ,  1-    : <br> ¬ª <a href="http://www.math.mcgill.ca/barr/papers/tttall.pdf">Michael Barr, Charles Wells. Toposes, Triples and Theories, 1985</a> <br><br> ,    ,       <a href="http://math.mit.edu/~dspivak/">David I. Spivak</a> .    ,    . <br><br>         : <br> ¬ª <a href="https://www.google.ru/search%3Fq%3DMichael%2BJ.%2BHealy.%2BCategory%2BTheory%2BApplied%2Bto%2BNeural%2BModeling%2Band%2BGraphical%2BRepresentations">Michael J. Healy. Category Theory Applied to Neural Modeling and Graphical Representations, 2000</a> <br><br><h3>  <font color="#902213">Conclusion</font> </h3><br>        . ,    ,   <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">  </a>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25B7%25D0%25B0_%25D0%259C%25D0%25B8%25D1%2580%25D0%25B0"></a>            ,     . <b>        ,    .</b> <br><br>      ,    .   <a href="https://habrahabr.ru/post/305018/"></a>          . ,  Haskell    Hask.      .      ,      ,      .            . <b>         .</b>     -       . <br><br>             . , ,        ,     . <b>         .</b>    ,  ,   ,     . <br><br>      ,  <b>  ‚Äì ,  ,        </b> . <br><br>        . <br><br> <b>-,     ,     .</b> ,          calcCartesianProduct(),    -   multiplyFunctions().      ,               ,    ‚Äî    .  Those.       . <br><br> <b>-,      </b> ,    ,       . <br><br> <b>-,     ,    .</b>  ,          ( assert      ). ,    -    ,    ! <br><br> , ,          .       ,     ,       , ,      .   ,       .     ¬´¬ª,    . <br><br> ,   -       JavaScript. <br><br>  <a href="https://habrahabr.ru/company/cit/blog/273449/"> </a>          .             ,           . <br><br> ¬ª <a href="https://github.com/AresEkb/categoricaljs"> </a>  <a href="https://aresekb.github.io/categoricaljs/Set.html">  </a> . </div><p>Source: <a href="https://habr.com/ru/post/313254/">https://habr.com/ru/post/313254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313242/index.html">Why do we need Delegate in iOS and WatchOS?</a></li>
<li><a href="../313246/index.html">Servers in the Netherlands in premium-data center become cheaper low-cost when entering into a contract with ua-hosting.company</a></li>
<li><a href="../313248/index.html">Mikrotik: VLAN using a switching chip</a></li>
<li><a href="../313250/index.html">Validation in HTML5</a></li>
<li><a href="../313252/index.html">Comparing Postgres schemas and related issues with views</a></li>
<li><a href="../313256/index.html">YML (Yandex Market Language) - Generation of a product file for Yandex Webmaster</a></li>
<li><a href="../313258/index.html">Divide & Conquer over the Strassen algorithm</a></li>
<li><a href="../313260/index.html">According to the players of the IT market, the bill on the regulation of online cinemas will slow down their development</a></li>
<li><a href="../313262/index.html">7 rules of working with Linkedin that will help you get the desired result and save your nerves to counterparties</a></li>
<li><a href="../313264/index.html">How to find out the attendance of 3.8 million sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>