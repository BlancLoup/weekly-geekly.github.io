<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic build javascript / coffeescript project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing at least some large javascript project, you immediately understand that you cannot write all the code in a single file. After that, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic build javascript / coffeescript project</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/12d/0d6/1f7/12d0d61f7553bea839ca83cca17fb84a.jpg" align="left">  When developing at least some large javascript project, you immediately understand that you cannot write all the code in a single file.  After that, the code is spread across several files and directories and a simple script is written so that all these files can be easily merged into one large production file.  After some time, you begin to notice that the farther you go, the harder it becomes to keep track of the dependencies between files, and the whole mechanism developed looks more like a crutch.  And here comes the insight that it would be nice to see what are the solutions to this problem. <br><br>  The following requirements are put forward to the project assembly management system: <br><ol><li>  Compilation of coffescript to javascript.  If the coffeescript file contains an error, the file name and error message should be displayed in the console. </li><li>  Building a project into one javascript file should be based on dependencies. </li><li>  The ability to collect the entire application in one file in several forms (with comments, minimized).  In this case, the application itself may consist of several modules. </li><li>  Building test files and executing them in the console (yes, we are developing for the web, without touching the mouse and not getting out of our favorite vim at all). </li><li>  Of course, all this should be convenient to use. </li></ol><br>  In this article, I will not touch on the issue of testing, but I will consider a version of the project's javascript / coffescript build management system (and the project structure itself) using rake and Rake :: Pipeline ( <a href="https://github.com/livingsocial/rake-pipeline">git</a> ). <br><a name="habracut"></a><br>  Rake :: Pipeline is a file processing system.  She is able to read files from a directory according to a given pattern, change files according to a given rule, and write the result. <br><br>  As it is not difficult to guess, Rake :: Pipeline uses rake, therefore ruby ‚Äã‚Äãis necessary for its work.  All pipeline settings are usually stored in the ‚ÄúAssetfile‚Äù file.  This file is a ruby ‚Äã‚Äãscript.  It may have, for example, the following form: <br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile #        input "app/assets/javascripts" #         output "public/javascripts" #         , #  input.          #*.js,      "app/assets/javascripts" match "*.js" do #ConcatFilter - ,      . #    *.js    app/assets/javascripts #   application.js,      #public/javascripts. filter Rake::Pipeline::ConcatFilter, "application.js" end</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider, for example, a project called ‚Äúapplication‚Äù.  This project will consist of 3 coffeescript files: ‚Äúfile1.coffee‚Äù, ‚Äúfile2.coffee‚Äù, ‚Äúfile3.coffee‚Äù.  Thus we get the following directory structure: <br><br>  -application <br>  --src <br>  ---file1.coffee <br>  ---file2.coffee <br>  ---file3.coffee <br><br>  Suppose that we have the following dependencies: <br>  2nd depends on 1st and 3rd <br>  3rd depends on 1st <br>  Thus in the assembled version of the files should be in the following order: 1-3-2. <br>  For convenience, we will create the main file ‚Äúmain.coffee‚Äù.  It will contain a list of files used in the project.  Now you can start filling in the files: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># main.coffee (     ): require("file1") require("file2") require("file3") # file1.coffee (    ): # ...  ... file1 = true #   # file2.coffee (  1-  3-): require("file1") require("file3") # ...  ... file2 = true #   # file3.coffee (  1-): require("file1") # ...  ... file3 = true #  </span></span></code> </pre><br><br>  In this case, require (‚Äúfile1‚Äù) is a pseudo-function.  More precisely, it is a template, a pointer to the fact that the first file is required for work.  You can configure it so that instead of require ("file1") you need to write: <br><pre> <code class="ruby hljs"> ! , , file1.   , .</code> </pre><br>  That is, the file connection syntax can be done in any way.  For example, you can specify dependencies in the comments.  This allows you to use the pipeline, for example, to process css files. <br><br>  In our case, since the second file depends on the first and third, then only one line could be entered in the main.coffee file: require (‚Äúfile2‚Äù).  The remaining files should connect automatically. <br><br>  With the structure figured out, it remains to collect all this.  To do this, in the root of the project we create a Gemfile with the following content: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Gemfile source "http://rubygems.org" gem "rake-pipeline", :git =&gt; "https://github.com/livingsocial/rake-pipeline.git" gem "rake-pipeline-web-filters", :git =&gt; "https://github.com/wycats/rake-pipeline-web-filters.git" gem "uglifier", :git =&gt; "https://github.com/lautis/uglifier.git" group :development do gem "rack" gem "github_downloads" gem "coffee-script" end</span></span></code> </pre><br>  Here rake-pipeline-web-filters is a helper library that contains, in particular, a class for processing coffe-scripts.  uglifier is a library for minimizing javascript. <br><br>  Now create a rakefile: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Rakefile abort "Please use Ruby 1.9 to build application!" if RUBY_VERSION !~ /^1\.9/ require "bundler/setup" def pipeline require 'rake-pipeline' Rake::Pipeline::Project.new("Assetfile") end task :dist do puts "build application" pipeline.invoke puts "done" end task :default =&gt; :dist</span></span></code> </pre><br><br>  Here Rake :: Pipeline :: Project.new (‚ÄúAssetfile‚Äù) - a new object is created, ‚ÄúAssetfile‚Äù is a file with assembly settings, which we do not already have, but now we will create it. <br><br>  Immediately you can register the root directory for compiled files.  The path will be ‚Äútarget‚Äù: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile output "target"</span></span></code> </pre><br><br>  We will build the project in 2 stages.  First, we will compile all coffescript files into javascript, and then we will compile the project itself. <br><br><h4>  Javascript compilation </h4><br>  Compilation will be carried out in the directory "target / src".  In addition, each file ".coffe" will correspond to its own file ".js" (that is, at this stage we will not merge the files).  To do this, add the following lines to the "Assetfile" <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile #      "src" input "src" do #    *.coffee (   "src") match "**/*.coffee" do require "rake-pipeline-web-filters" #       javascript filter Rake::Pipeline::Web::Filters::CoffeeScriptFilter do |filename| # ,       ( ) #  js . #         "src"  "target" #       '.coffee'  '.js' File.join("src/", filename.gsub('.coffee', '.js')) end end end</span></span></code> </pre><br><br>  Now, if you run the rake command, a project version compiled into javascript will be created in the ‚Äútarget / src / lib‚Äù directory.  If any of the files fail to compile, an error message will be displayed. <br><br><h4>  Build javascript project </h4><br>  This time we will read the already compiled js files from the 'src / lib' directory: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile #   ,      name="application" #     "target/src" input "target/src" do #  main.js  match "main.js" do #   NeuterFilter. #      ,  #       . neuter( # ,   . :additional_dependencies =&gt; proc { |input| #       ,   main Dir.glob(File.join(File.dirname(input.fullpath),'**','*.js')) }, #     :path_transform =&gt; proc { |path, input| #    require("file1")   #   .    . #  require("file1")   require("file1.js") "#{path}.js" }, # ,         js- :closure_wrap =&gt; false ) do |filename| "#{name}.js" end end end</span></span></code> </pre><br><br>  Now, if you run the rake command, the file 'application.js' will appear in the 'src' directory with the following contents: <br><pre> <code class="javascript hljs">#  application.js (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file1; file1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file3; file3 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"file2"</span></span>); }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre><br><br>  But wait!  What is the line doing here? <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"file2"</span></span>);</code> </pre><br>  ?  After all, she had to disappear.  This seems to be a neuter filter error.  Let's look at the source code of this filter ( <a href="">code</a> ).  We are interested in the line here: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  neuter_filter.rb regexp = </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@config</span></span></span><span class="hljs-comment">[:require_regexp] || %r{^\s*require\(['"]([^'"]*)['"]\);?\s*}</span></span></code> </pre><br>  As you can see, if the parameters do not specify their own rule for identifying text with the name of the required file, the regular expression is used by default <br><pre> <code class="ruby hljs">%r{^\s*<span class="hljs-keyword"><span class="hljs-keyword">require</span></span>\([<span class="hljs-string"><span class="hljs-string">'"]([^'</span></span><span class="hljs-string"><span class="hljs-string">"]*)['"</span></span>]\);<span class="hljs-string"><span class="hljs-string">?\s</span></span>*}</code> </pre><br>  Unfortunately, I could not understand why such a regular expression processes only the first require, and the second one does not notice.  I would be very grateful if you explain what is the matter.  I solved this problem as follows: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile input "target/src" do match "main.js" do neuter( .... :closure_wrap =&gt; false, :require_regexp =&gt; %r{^\s*require\(['"]([^'"]*)['"]\);?\s*$} ...</span></span></code> </pre><br>  Pay attention to the appeared "$" sign.  That is, we have limited the regular expression to the end of the line.  After that, the compiled file looks like it should: <br><pre> <code class="javascript hljs">#  application.js (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file1; file1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file3; file3 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file2; file2 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre><br><br>  Elegant (note the order of the files).  If you want to wrap the whole thing in one more javascript function (I don‚Äôt know why, but you never know), you can do the following.  Create your own filter: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile class ClosureFilter &lt; Rake::Pipeline::Filter def generate_output(inputs, output) inputs.each do |input| # output.write "(function() {\n#{input.read}\n})()" end end end</span></span></code> </pre><br>  And now this filter remains to be specified after applying the neuter filter. <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile input "target/src" do match "main.js" do neuter( ............. ) do |filename| "#{name}.js" end filter ClosureFilter end end</span></span></code> </pre><br><br>  Now everything is in order.  It remains only to make a minimized version of our application.  To do this, you need to write only 5 lines: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile input "target" do match "#{name}.js" do # uglify -    uglify{ "#{name}.min.js" } end end</span></span></code> </pre><br>  Now, when compiling, in addition to ‚Äúapplication.js‚Äù, the file ‚Äúapplication.min.js‚Äù will be created with the contents: <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e;e=!<span class="hljs-number"><span class="hljs-number">0</span></span>}).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>),<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e;e=!<span class="hljs-number"><span class="hljs-number">0</span></span>}.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>),<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e;e=!<span class="hljs-number"><span class="hljs-number">0</span></span>}.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>),<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)})();</code> </pre><br><br>  Final version of my assetfile <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  Assetfile require "json" require "rake-pipeline-web-filters" name="application" output "target" input "src" do match "**/*.coffee" do filter Rake::Pipeline::Web::Filters::CoffeeScriptFilter do |filename| File.join("src/", filename.gsub('.coffee', '.js')) end end end class ClosureFilter &lt; Rake::Pipeline::Filter def generate_output(inputs, output) inputs.each do |input| output.write "(function() {\n#{input.read}\n})()" end end end input "target/src" do match "main.js" do neuter( :additional_dependencies =&gt; proc { |input| Dir.glob(File.join(File.dirname(input.fullpath),'**','*.js')) }, :path_transform =&gt; proc { |path, input| "#{path}.js" }, :closure_wrap =&gt; false, :require_regexp =&gt; %r{^\s*require\(['"]([^'"]*)['"]\);?\s*$} ) do |filename| "#{name}.js" end filter ClosureFilter end end input "target" do match "#{name}.js" do uglify{ "#{name}.min.js" } end end # vim: filetype=ruby</span></span></code> </pre><br><br>  It remains only to note that the project structure may contain nested directories.  If you need to connect a file from a subdirectory, you need to specify <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"dir_name/file_name"</span></span>)</code> </pre><br>  You can also write your own filters, which, for example, will substitute the license text, version number, date and time of the last commit, temperature and humidity in your city at the time of assembly, etc. into the file. <br><br>  If you're interested, in the next article I can show you how to organize javascript testing using phantom.js (testing from the console itself) and connecting template files at the build stage. </div><p>Source: <a href="https://habr.com/ru/post/148167/">https://habr.com/ru/post/148167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148160/index.html">Work with the new version of Google Analytics v2 on the example of Android applications</a></li>
<li><a href="../148162/index.html">Little secrets of big graphs</a></li>
<li><a href="../148163/index.html">Console comfort</a></li>
<li><a href="../148164/index.html">I, the user!</a></li>
<li><a href="../148166/index.html">PowerShell: rendering HTML views</a></li>
<li><a href="../148168/index.html">Workle classified customers of its users.</a></li>
<li><a href="../148169/index.html">An Arduino Alternative from Texas Instruments for $ 4.30</a></li>
<li><a href="../148171/index.html">Convert flac to mp3 in one motion</a></li>
<li><a href="../148173/index.html">Portable Components, cross-platform library for C ++</a></li>
<li><a href="../148175/index.html">Google buys Sparrow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>