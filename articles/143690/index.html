<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>F # Tail recursion. Underwater rake. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Winnie the Pooh: Oh, what happened to your tail? 
 Ia: And what could have happened to him? 
 Winnie the Pooh: He is not. 
 Ia: You were not mistaken?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>F # Tail recursion. Underwater rake. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/26f/1f4/f2f/26f1f4f2f90ff9365f7449e0bb51b353.jpg" align="right"><br>  <em>Winnie the Pooh: Oh, what happened to your tail?</em> <em><br></em>  <em>Ia: And what could have happened to him?</em> <em><br></em>  <em>Winnie the Pooh: He is not.</em> <em><br></em>  <em>Ia: You were not mistaken?</em> <em><br></em>  <em>Winnie the Pooh: Tail or there is or not at all!</em>  <em>There can not be wrong.</em> <em><br></em>  <em>Ia: And what then is there?</em> <em><br></em>  <em>Winnie the Pooh: Nothing!</em> <br><br>  In our project, in one of the server components, after the next refactoring, memory began to flow.  It would seem. NET, F #, managed code, garbage collection, all things, but the memory flowed somewhere.  At the cost of sleepless nights and damaged nerves, the source of the leak was found.  It turned out that the problem was caused by a piece of code that was copied almost from one to one from the F # tutorial. <br><br>  The whole thing was in tail recursion, or rather, as it turned out in its absence in unexpected places. <br><a name="habracut"></a><br><h2>  Tail recursion </h2><br>  Recursion, this is probably one of the most important tools in the arsenal of functional programming.  And since recursive calls use a stack, which, as is known, is not unlimited, it may seem that the use of recursion is limited and the depth of recursion is finite. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, everything is not so gloomy, almost all compilers of functional languages ‚Äã‚Äãhave such useful stuff as tail recursion optimization, with which you can use recursion without using the stack, which in turn removes the restriction on recursion nesting. <br><br>  <i>Tail recursion is a special case of recursion when the recursive call can be replaced by iteration.</i>  On the one hand, it is up to the programmer‚Äôs conscience to write logic in the ‚Äútail‚Äù style, on the other hand, the compiler must also ‚Äúfind‚Äù tail recursion and unleash recursion in iteration. <br><br>  Usually the beginner ‚Äúfunctionalist‚Äù quickly fills the eye and hand and uses tail recursion everywhere.  <b>But there are several special cases where the function, which, it would seem, is the iron ‚Äútail‚Äù is not really such.</b>  These special cases can lead to very unpleasant consequences, and can kill a lot of time and nerves. <br><br>  Let's consider the first such case and formulate a rule by which you can avoid ‚Äútrouble‚Äù. <br><br>  Let's start with a simple function that adds up all the numbers from one to N: <br><pre><code class="hljs matlab">let rec sum <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>L then <span class="hljs-number"><span class="hljs-number">0</span></span>L <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + sum (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>L) &gt; sum <span class="hljs-number"><span class="hljs-number">10</span></span>L;; val it : int64 = <span class="hljs-number"><span class="hljs-number">55</span></span>L</code> </pre> <br>  All is well, except for one moment.  If we try to calculate the amount for at least 100,000, we get a StackOverflowException in the forehead.  Those.  we simply did not have enough stack for calculations: <br><pre> <code class="hljs vhdl">&gt; sum <span class="hljs-number"><span class="hljs-number">100000</span></span>L;; <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> terminated due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> StackOverflowException.</code> </pre><br>  The answer to this problem, the use of the battery, as an argument of the recursive function: <br><pre> <code class="hljs matlab">let sumTailRec <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = let rec loop acc <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>L then acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> loop (acc + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>L) loop <span class="hljs-number"><span class="hljs-number">0</span></span>L <span class="hljs-built_in"><span class="hljs-built_in">i</span></span></code> </pre><br>  We rewrote our function in such a way that it doesn‚Äôt need a stack, instead of going back to summing up, we forward the accumulator as an argument. <br><br>  To illustrate the order of calculation (for argument 5), you can.  Without tail recursion: <br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> + (<span class="hljs-number"><span class="hljs-number">4</span></span> + (<span class="hljs-number"><span class="hljs-number">3</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">0</span></span>))))) ‚Äì       ,  ,      .         .</code> </pre><br>  Tail recursion: <br><pre> <code class="hljs 1c">sumTailRec: (((<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>) ‚Äì ,      ,       ,      <span class="hljs-keyword"><span class="hljs-keyword"></span></span> .</code> </pre><br>  A new function can already digest an arbitrarily large number (as long as int64 is enough). <br><pre> <code class="hljs scala">&gt; sumTailRec <span class="hljs-number"><span class="hljs-number">10000000</span></span>L;; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> it : int64 = <span class="hljs-number"><span class="hljs-number">50000005000000</span></span>L</code> </pre><br>  Now, let's write a little more generalized function, which summarizes not the numbers themselves, but the result of some given function of the current number. <br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sumFTailRec fi = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> acc i = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>L <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> (acc + fi) (i - <span class="hljs-number"><span class="hljs-number">1</span></span>L) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>L i</code> </pre><br>  In the new version, we have another parameter - a function, the result of whose calculation needs to be summed up.  Here is an option that sums up the numbers themselves: <br><pre> <code class="hljs kotlin">&gt; sumFTailRec (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> i -&gt; i) 10000000L </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">val</span></span></span><span class="hljs-function"> it : int64 = 50000005000000L</span></span></code> </pre><br>  And here, which summarizes the squares: <br><pre> <code class="hljs kotlin">&gt; sumFTailRec (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> i -&gt; i*i) 10000000L </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">val</span></span></span><span class="hljs-function"> it : int64 = 1291990006563070912L</span></span></code> </pre><br>  So far so good.  But there is a small nuance, the function that is passed, can ‚Äúthrow‚Äù an exception.  Here is an example: <br><pre> <code class="hljs pgsql">&gt; let someProblemFun i = i/((i+<span class="hljs-number"><span class="hljs-number">1</span></span>L) % <span class="hljs-number"><span class="hljs-number">1000</span></span>L) &gt; sumFTailRec someProblemFun <span class="hljs-number"><span class="hljs-number">10000000</span></span>L <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.DivideByZeroException: Attempted <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> divide <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> zero. Stopped due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> error</code> </pre><br><h2>  Problem </h2><br>  When the value i = 999, we have a division by zero.  Suppose that we want an exception, not to crash the calculation, but simply to ignore the problem element.  We will need exception handling.  A logical and expected solution suggests itself: <br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sumFTailRecWithTry fi = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> acc i = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>L <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> (acc + fi) (i - <span class="hljs-number"><span class="hljs-number">1</span></span>L) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> exc -&gt; printfn <span class="hljs-string"><span class="hljs-string">"exn raised:%s"</span></span> exc.Message <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> acc (i - <span class="hljs-number"><span class="hljs-number">1</span></span>L) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>L i</code> </pre><br>  So try: <br><pre> <code class="hljs kotlin">&gt; sumFTailRecWithTry someProblemFun <span class="hljs-number"><span class="hljs-number">10000L</span></span> exn raised:Attempted to divide <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> zero. ... exn raised:Attempted to divide <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> zero. <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> it : int64 = <span class="hljs-number"><span class="hljs-number">351405L</span></span></code> </pre><br>  The result was received, exceptions were caught, everything seems to be fine.  Now we try to feed a more serious number: <br><pre> <code class="hljs vhdl">&gt; sumFTailRecWithTry someProblemFun <span class="hljs-number"><span class="hljs-number">10000000</span></span>L exn raised:Attempted <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> divide by zero. ... exn raised:Attempted <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> divide by zero. <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> terminated due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> StackOverflowException.</code> </pre><br>  Oops ... What's the matter?  At first glance, we have a function with tail recursion, why did the stack suddenly end? <br><br>  As you might guess, the problem is in the try ... with design.  The fact is that if a recursive call is executed in a try block, then the tail recursion falls off the tail, and it becomes an ordinary recursion.  Why?  Because in any of the subsequent recursive calls loop, theoretically, an exception can fall out, but since  if we need to process it, then we need to memorize in the stack the place where we need to return when the exception is ‚Äúdropped‚Äù. <br><br><h2>  Decision </h2><br>  Which of such unpleasant situation is the way out?  Very simple, you <i>do not need to wrap the recursive call with a try ... with block</i> , because we expect an exception only when you call the "external" function f, then you only need to wrap this call: <br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> sumFReallyTailRecWithTry <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> rec loop acc i = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt;= 0L <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> fRes = try <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> with exc -&gt; //printfn <span class="hljs-string"><span class="hljs-string">"exn raised:%s"</span></span> exc.Message 0L loop (acc + fRes) (i - 1L) loop 0L i</code> </pre><br>  We try: <br><pre> <code class="hljs scala">&gt; sumFReallyTailRecWithTry someProblemFun <span class="hljs-number"><span class="hljs-number">10000000</span></span>L <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> it : int64 = <span class="hljs-number"><span class="hljs-number">374200932236</span></span>L</code> </pre><br>  Voila!  Stack this time was enough, or rather he was left untouched. <br><br>  <b>So the rule is: never put a tail call on a try ... with block.</b> <br><br>  <i>In the second series there will be shocking revelations concerning tail recursion for async {...} and MailboxProcessor.</i> </div><p>Source: <a href="https://habr.com/ru/post/143690/">https://habr.com/ru/post/143690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143683/index.html">LinkedIn is considering buying a portal Monster.com</a></li>
<li><a href="../143684/index.html">Skype for Linux. It's too early to bury me</a></li>
<li><a href="../143685/index.html">Weekly Digest # 3: Simple-Science - Simple Experiments</a></li>
<li><a href="../143687/index.html">User experience design: how to build a website for customers, not for yourself</a></li>
<li><a href="../143688/index.html">Indicate a mobile phone or tablet in the Firefox User-Agent header</a></li>
<li><a href="../143691/index.html">Hard links for repository cloning in mercurial</a></li>
<li><a href="../143692/index.html">Facebook smartphone will be on Windows Phone?</a></li>
<li><a href="../143694/index.html">XEN: A simple script to quickly open VNC consoles</a></li>
<li><a href="../143695/index.html">Domen.RF: just statistics and a little bit of freebies in the bargain</a></li>
<li><a href="../143698/index.html">Mobiscroll - custom select for mobile sites and not only</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>