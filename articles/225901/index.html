<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unsigned arithmetic in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, there are no unsigned types in Java. If in C you could write unsigned int ( char , long ), then in Java it would not work. However, it is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unsigned arithmetic in Java</h1><div class="post__text post__text-html js-mediator-article"> As you know, there are no unsigned types in Java.  If in C you could write <code>unsigned int</code> ( <code>char</code> , <code>long</code> ), then in Java it would not work.  However, it is often necessary to perform arithmetic operations with numbers without a sign.  At first glance, it seems that unsigned types are not really necessary in principle (think, <code>MaxInt</code> for numbers with a sign less than twice, if you need numbers more, I just take a <code>long</code> and then <code>BigInteger</code> ).  But the main difference is not really in how many different non-negative numbers can be put in a signed or unsigned int, but in how arithmetic operations and comparisons are performed on them.  If you are working with binary protocols or with binary arithmetic, where every bit used is important, you need to be able to perform all the basic operations in unsigned mode.  Consider these operations in order: <br><br><h4>  Convert byte to short (int, long) </h4><br>  Regular caste <code>(int) myByte</code> will perform an extension to 32 bits with a sign - this means that if the high bit of a byte was set to 1, then the result will be the same negative number, but written in 32-bit format: <br><br> <code>0xff -&gt; 0xffffffff (-1)</code> <br> <br>  Often this is not what we would like.  In order to expand to 32 bits unsigned and get <code>0x000000ff</code> , in Java you can write: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myInt = myByte &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> myShort = myByte &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>;</code> </pre><br><h4>  Comparison without sign </h4><br>  For unsigned comparison, there is a concise formula: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareUnsigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.compare( a ^ <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>, b ^ <span class="hljs-number"><span class="hljs-number">0x80000000</span></span> ); }</code> </pre><br>  For byte, short and long, respectively, the constants will be <code>0x80</code> , <code>0x8000</code> and <code>0x8000000000000000L</code> . <br><a name="habracut"></a><br><h4>  Addition, Subtraction and Multiplication </h4><br>  And here is a pleasant surprise - these operations are performed correctly in any case.  But in expressions it is necessary to carefully ensure that operations are performed with numbers of the same type, since any implicit conversions are performed with an extension of the sign, and can lead to results that are different from those expected.  The insidiousness of such bugs is that an erroneous scenario can be executed very rarely. <br><br><h4>  Division </h4><br>  Dividing -256 by 256 will give us -1.  And we would like for <code>0xffffff00 / 0x100</code> give <code>0x00ffffff</code> , not <code>0xffffffff (-1)</code> .  For <code>byte</code> , <code>short</code> and <code>int</code> solution is to switch to numbers of higher bit depth: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0xffffff00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((a &amp; <span class="hljs-number"><span class="hljs-number">0xffffffffL</span></span>) / b); <span class="hljs-comment"><span class="hljs-comment">// convert a to long before division</span></span></code> </pre><br>  But what to do with <code>long</code> ?  Switching to <code>BigInteger</code> in such cases is usually not an option - too slow.  It remains only to take everything into their own hands and implement the division manually.  Fortunately, everything has been stolen before us - in <a href="https://code.google.com/p/guava-libraries/">Google Guava</a> there is an implementation of unsigned division for <code>long</code> , and quite smart.  If you do not use this library, the easiest way is to tear out a piece of code directly from the <a href="">UnsignedLongs.java</a> file: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Returns dividend / divisor, where the dividend and divisor are treated as unsigned 64-bit * quantities. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> dividend the dividend (numerator) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> divisor the divisor (denominator) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> ArithmeticException if divisor is 0 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ie, divisor &gt;= 2^63: if (compare(dividend, divisor) &lt; 0) { return 0; // dividend &lt; divisor } else { return 1; // dividend &gt;= divisor } } // Optimization - use signed division if dividend &lt; 2^63 if (dividend &gt;= 0) { return dividend / divisor; } /* * Otherwise, approximate the quotient, check, and correct if necessary. Our approximation is * guaranteed to be either exact or one less than the correct value. This follows from fact * that floor(floor(x)/i) == floor(x/i) for any real x and integer i != 0. The proof is not * quite trivial. */ long quotient = ((dividend &gt;&gt;&gt; 1) / divisor) &lt;&lt; 1; long rem = dividend - quotient * divisor; return quotient + (compare(rem, divisor) &gt;= 0 ? 1 : 0); }</span></span></code> </pre><br>  In order for the code to compile, you will also have to borrow the implementation of <code>compare(long, long)</code> : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Compares the two specified {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} values, treating them as unsigned values between * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> 0} and {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> 2^64 - 1} inclusive. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> a the first unsigned {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} to compare * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> b the second unsigned {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} to compare * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> a negative value if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> a} is less than {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> b}; a positive value if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> a} is * greater than {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> b}; or zero if they are equal */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Longs.compare(flip(a), flip(b)); }</code> </pre><br>  and <code>Longs.compare(long, long)</code> + <code>flip(long)</code> : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * A (self-inverse) bijection which converts the ordering on unsigned longs to the ordering on * longs, that is, {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> a &lt;= b} as unsigned longs if and only if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> flip(a) &lt;= flip(b)} * as signed longs. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a ^ Long.MIN_VALUE; } <span class="hljs-comment"><span class="hljs-comment">/** * Compares the two specified {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} values. The sign of the value * returned is the same as that of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> ((Long) a).compareTo(b)}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> a the first {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} to compare * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> b the second {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> long} to compare * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> a negative value if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> a} is less than {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> b}; a positive * value if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> a} is greater than {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> b}; or zero if they are equal */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &lt; b) ? -<span class="hljs-number"><span class="hljs-number">1</span></span> : ((a &gt; b) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><h4>  Bitwise shifts </h4><br>  To finally cover the topic of bit operations, we also recall the shifts.  In the x86 assembler, there is a whole bunch of various commands that make bitwise shifts - SHL, SHR, SAL, SAR, ROR, ROL, RCR, RCL.  The last 4 perform cyclic shifts, their equivalents in Java are not.  But the logical and arithmetic shifts are present.  The logical shift (does not take into account the signs) - SHL (shift left) and SHR (shift right) - is implemented in Java by the operators <code>&lt;&lt;</code> and <code>&gt;&gt;&gt;</code> respectively.  With the help of logical shifts, you can quickly perform integer multiplication and division by numbers of powers of two.  The arithmetic shift (takes into account the sign) to the right - SAR - is implemented by the <code>&gt;&gt;</code> operator.  An arithmetic left shift is equivalent to a logical one, and therefore there is no special operator for it.  It may seem strange that the assembler has a special opcode for this operation, but in fact it does the same, that is, SAL completely repeats the behavior of SHL, and this is clearly indicated by the documentation from Intel: <br><blockquote>  The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation;  they shift the bits in the destination operand to the left (toward more significant bit locations).  The bit is cleared (see Figure 7-7 in the Intel¬Æ 64 and IA-32 Architects Software Developer‚Äôs Manual, Volume 1). ). </blockquote><br>  That is, SAL was added just for symmetry, given that there is a division into logical and arithmetic to shift to the right.  Well, Gosling decided not to bother (and, I think, did the right thing). <br><br>  So, we have the following: <br><br><pre> <code class="java hljs">a &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,    2 a &gt;&gt; 1; //      (   2) a &gt;&gt;&gt; 1; //      (    2)</span></span></code> </pre><br><h4>  Final Recommendations </h4><br><ul><li>  When performing arithmetic operations that may lead to overflow in the selected bit grid, it is always necessary to accurately understand what range of acceptable values ‚Äã‚Äãthe variables may have, and to track these invariants by placing assertions.  For example, it is obvious that when multiplying two arbitrary 32-bit unsigned numbers, the result may not fit in 32 bits, and if you need to avoid overflow, you must either make sure that there will never be a situation in which there is no fit in 32 bits or it is necessary to convert both operands into long (by performing <code>a &amp; 0xffffffffL</code> ).  Here, by the way, you can easily make a mistake by converting only one of the operands.  No, you need to convert both to long, because  if the second operand is negative, it will be implicitly converted to long with an extension of the sign, and the result of the multiplication will be incorrect. </li><li>  Generously place brackets in expressions that use bitwise operations.  The fact is that the priority of bitwise operators in Java is somewhat strange, and often behaves in an unobvious way.  It is better to add a pair of parentheses than a few hours later to look for subtle mistakes. </li><li>  If you need a constant of type <code>long</code> , do not forget to add the suffix <code>L</code> to the end of the literal constant.  If we do not do this, it will be not <code>long</code> , but an <code>int</code> , and with an implicit coercion to <code>long</code> , an unpleasant signed extension will occur again. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/225901/">https://habr.com/ru/post/225901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225891/index.html">AngularJS - Are you sure you know how ng-if works?</a></li>
<li><a href="../225893/index.html">EBay chief says Bitcoin integration is inevitable in PayPal</a></li>
<li><a href="../225895/index.html">Chronicle of space super heavyweight. Part 2. "Park" reusable period</a></li>
<li><a href="../225897/index.html">System for watering plants. How to get to Kickstarter. Step-by-step process</a></li>
<li><a href="../225899/index.html">Pro release zombodavilki on iOS and thoughts about the publishers</a></li>
<li><a href="../225903/index.html">Microsoft and Adobe released a set of updates, June 2014</a></li>
<li><a href="../225907/index.html">Is Go the language of OOP?</a></li>
<li><a href="../225909/index.html">Social networks - what's next?</a></li>
<li><a href="../225911/index.html">We solve the problem of literacy on the Internet using Yandex.Speler</a></li>
<li><a href="../225913/index.html">License plate recognition in detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>