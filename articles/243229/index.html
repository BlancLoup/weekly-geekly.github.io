<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analyze friendships VK using Python. Continuation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we built a graph on the basis of mutual friends on VKontakte, and today we will talk about how to get a list of friends, frie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analyze friendships VK using Python. Continuation</h1><div class="post__text post__text-html js-mediator-article">  In the previous <a href="http://habrahabr.ru/post/221251/">article,</a> we built a graph on the basis of mutual friends on VKontakte, and today we will talk about how to get a list of friends, friends of friends, and so on.  It is assumed that you have already read the previous <a href="http://habrahabr.ru/post/221251/">article</a> , and I will not describe everything anew.  Habrakat large pictures and a lot of text. <br><a name="habracut"></a><br>  To begin with, simply downloading all user id's is easy enough; a list of valid id can be found in <a href="https://vk.com/catalog.php">the Vkontakte User Catalog</a> .  Our task is to get a list of friends of our chosen user id, their friends, and recursively as much as desired, depending on the specified depth. <br><br>  The code published in the article will change over time, so a more recent version can be found in the same project on <a href="https://github.com/stleon/vk_friends">Github</a> . <br><br>  How we will implement: <br><ul><li>  We set the depth we need </li><li>  We send the source data or the id, which must be investigated at a given depth </li><li>  We get the answer </li></ul><br>  What we will use: <br><ul><li>  Python 3.4 </li><li>  VKontakte stored procedures </li></ul><br><h4>  We set the depth we need </h4><br>  What we need at the beginning is to indicate the depth ( <b>deep</b> ) with which we want to work.  This can be done immediately in <b>settings.py</b> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs">deep = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#     </span></span></code> </pre> <br>  <b>deep</b> equal to 1 is our friends, 2 is friends of our friends and so on.  As a result, we get a dictionary, the keys of which are the users' id, and the values ‚Äã‚Äãare their list of friends. <br><br>  Do not rush to set a large depth.  With 14 of my original friends and a depth of 2, the number of keys in the dictionary was 2427, and with a depth of 3, I didn‚Äôt have the patience to wait for the script to finish, at that time the dictionary had 223,908 keys.  For this reason, we will not visualize such a huge graph, because the vertices are the keys, and the edges are the values. <br><br><h4>  Sending data </h4><br>  The already known <a href="">friends.get</a> method, which will be located in a stored procedure that has the following form, will help us achieve the result we need: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targets = Args.targets; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all_friends = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parametr = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        while(start&lt;=targets.length){ if (targets.substr(start, 1) != "," &amp;&amp; start != targets.length){ parametr = parametr + targets.substr(start, 1); } else { //   ,    id req = API.friends.get({"user_id":parametr}); if (req) { all_friends = all_friends + [req]; } else { all_friends = all_friends + [0]; } parametr = ""; } start = start + 1; } return all_friends;</span></span></code> </pre><br>  I remind you that you can create a stored procedure in <a href="https://vk.com/editapp%3Fid%3DID%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%26section%3Dfunctions">the application settings</a> , it is written in <b>VkScript</b> , as well as <b>execute</b> , the documentation can be read <a href="https://vk.com/dev/execute">here</a> and <a href="https://vk.com/pages.php%3Fo%3D-1%26p%3Dexecute">here</a> . <br><br>  Now how it works.  We accept a string of 25 id, separated by commas, take out one id, make a request to <b>friends.get</b> , and the information we need will come in the dictionary, where the keys are id, and the values ‚Äã‚Äãare a list of friends of this id. <br><br>  When you first start, we will send to the stored procedure a list of friends of the current user whose id is specified in the settings.  The list will be divided into several parts (N / 25 - this is also the number of requests), this is due to the limitation of the number of calls to the VKontakte API. <br><br><h4>  Getting an answer </h4><br>  We store all received information in a dictionary, for example: <br><br><pre> <code class="python hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>:(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">3</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)}</code> </pre><br>  The keys 1, 2 and 3 were obtained with a depth equal to 1. Suppose that these were all the friends of the specified user (0). <br><br>  If the depth is greater than 1, then we use the difference of sets, the first of which is the dictionary values, and the second is its keys.  Thus, we get those id (in this case, 0 and 4), which are not in the keys, divide them again into 25 parts and send to the stored procedure. <br><br>  Then in our dictionary there will be 2 new keys: <br><br><pre> <code class="python hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>:(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">3</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-number"><span class="hljs-number">4</span></span>:(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ‚Ä¶.)}</code> </pre><br>  The very method <b>deep_friends ()</b> looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deep_friends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, deep)</span></span></span><span class="hljs-function">:</span></span> result = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill_result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(friends)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VkFriends.parts(friends): r = requests.get(self.request_url(<span class="hljs-string"><span class="hljs-string">'execute.deepFriends'</span></span>, <span class="hljs-string"><span class="hljs-string">'targets=%s'</span></span> % VkFriends.make_targets(i))).json()[<span class="hljs-string"><span class="hljs-string">'response'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(i): result[id] = tuple(r[x][<span class="hljs-string"><span class="hljs-string">"items"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r[x] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(deep): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result: <span class="hljs-comment"><span class="hljs-comment">#  ,     +   id:None fill_result(list(set([item for sublist in result.values() if sublist for item in sublist]) - set(result.keys()))) else: fill_result(requests.get(self.request_url('friends.get', 'user_id=%s' % self.my_id)).json()['response']["items"]) return result</span></span></code> </pre><br>  Of course, this is faster than throwing one id at <b>friends.get</b> without using a stored procedure, but it still takes a lot of time. <br><br>  If <b>friends.get</b> were similar to <b>users.get</b> , namely, it could take <b>user_ids</b> as a parameter, that is, id listed by comma, for which you need to return a list of friends, rather than one id, then the code would be much simpler, and The number of requests was several times less. <br><br><h4>  Too slow </h4><br>  Returning to the beginning of the article, I can repeat it again - very slowly.  Stored procedures do not save, the <a href="https://github.com/alxpy">alxpy</a> solution with multithreading (thanks to him for his contribution and participation <s>at least someone was interested, except for me</s> ) accelerated the program for a few seconds, but wanted more. <br><br>  Wise advice received from <a href="http://habrahabr.ru/users/igrishaev/" class="user_link">igrishaev</a> - we need some kind of map. <br><br>  The fact is that VKontakte resolves 25 requests to the API through <b>execute</b> , it follows from this that if we make requests from different clients, we can increase the number of valid requests.  5 wheelbarrows - this is 125 requests per second.  But this is far from the case.  Looking ahead, I will say that it is possible and even faster, it will look something like this (on each machine): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: r = requests.get(request_url(<span class="hljs-string"><span class="hljs-string">'execute.getMutual'</span></span>,<span class="hljs-string"><span class="hljs-string">'source=%s&amp;targets=%s'</span></span> % (my_id, make_targets(lst)),access_token=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)).json() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'response'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r: r = r[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: time.sleep(delay)</code> </pre><br>  If we receive an error message, we make a request again, after a specified number of seconds.  This technique works for some time, but then VKontakte starts to send <b>None</b> in all answers, so after each request we honestly wait for 1 second.  For now. <br><br>  Next, we need to choose new tools or write our own to realize our plans.  As a result, we should have a horizontally scalable system, the principle of operation seems to me as follows: <br><br><ul><li>  The main server receives from the client its VK id and operation code: either pull out all mutual friends, or walk recursively through the list of friends with the specified depth. </li><li>  Further, in both cases, the server makes a request to the VK API - we need a list of all the user's friends. </li><li>  Since everything is done so that we use the maximum capabilities of the stored procedures - here it will be necessary to divide the list of friends into parts, 25 contacts each.  In fact, 75. More on this below. </li><li>  We will have many parts, using the message broker, we will deliver each part to a specific recipient (producer-consumer). </li><li>  Recipients will accept contacts, immediately make requests, return the result to the supplier.  Yes, you thought correctly about RPC. </li></ul><br>  And if you saw this picture, then you understand what message broker I am hinting at. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/b2c/b20/261/b2cb20261294456295d25ba7b2f4713c.png"></div><br>  Once all the answers are accepted, we merge them into one.  Further, the result can be displayed on the screen or even saved, more on that later. <br><br>  Here it is worth noting that the code will change, and if it was enough for you to use the previous version of the project, then it remained unchanged.  All the code below will be for the new release. <br><br>  As a message broker, we will use <b>RabbitMQ</b> , an asynchronous distributed job queue - <b>Celery</b> . <br><br>  For those who have never come across them, here are some useful links to materials that I advise you to read: <br><br><div class="spoiler">  <b class="spoiler_title">RabbitMQ</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/149694/">Part 1</a> <br>  <a href="http://habrahabr.ru/post/150134/">Part 2</a> <br>  <a href="http://habrahabr.ru/post/200870/">Part 3</a> <br>  <a href="http://habrahabr.ru/post/201096/">Part 4</a> <br>  <a href="http://habrahabr.ru/post/201178/">Part 5</a> <br>  <a href="http://habrahabr.ru/post/236221/">Part 6</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Celery</b> <div class="spoiler_text">  <a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">First steps with Celery</a> <br></div></div><br>  Do not be afraid to understand, although they say that you can specifically turn your head when you start to ‚Äúthink not with one computer, but with several‚Äù, but this is not at all the case. <br><br>  If you have a Mac, like the author, then <b>RabbitMQ is</b> smartly installed via <b>Homebrew</b> : <br><br><pre> <code class="bash hljs">brew update brew install rabbitmq</code> </pre><br>  <b>Celery</b> is put even easier, we use the third branch of <b>Python</b> : <br><br><pre> <code class="bash hljs">pip3 install Celery</code> </pre><br>  I have <b>Celery</b> installed on Linux Mint, and <b>RabbitMQ</b> on Mac.  With Windows, as usual, the problems are <s>hard to find, it is easy to lose</s> , for some reason, she didn‚Äôt always want to return the response to my Mac. <br><br>  Next, create a <b>virtual host</b> , user, and give him the right: <br><br><pre> <code class="bash hljs">rabbitmqctl add_vhost vk_friends rabbitmqctl add_user user password rabbitmqctl set_permissions -p vk_friends user <span class="hljs-string"><span class="hljs-string">".*"</span></span> <span class="hljs-string"><span class="hljs-string">".*"</span></span> <span class="hljs-string"><span class="hljs-string">".*"</span></span></code> </pre><br>  In the <b>RabbitMQ</b> configuration, you must specify the ip of the host on which it is installed: <br><br><pre> <code class="bash hljs">vim /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/etc/rabbitmq/rabbitmq-env.conf NODE_IP_ADDRESS=192.168.1.14 //   </code> </pre><br>  Here are some possible configurations, which one to choose is up to you. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/19d/7aa/ddd/19d7aaddddcc4c78b67345a49df262d4.png"></div><br><br>  If you have a router or something else, it will be useful to know that <b>RabbitMQ</b> uses port 5672, well, and make redirection in the settings of your device.  Most likely, if you test, you scatter the workers on different machines, and they will need to use a broker, and if you don‚Äôt correctly set up the network, <b>Celery will not</b> reach <b>RabbitMQ</b> . <br><br>  Very good news is that VKontakte allows you to do 3 requests per second from one id.  Multiply these requests by the number of possible calls to the VKontakte API (25), we get the maximum number of contacts processed per second (75). <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/dab/ce0/6de/dabce06dec4f4406aa43796ba021043b.png"></div><br>  If we have a lot of workers, then the moment will come when we begin to go beyond the allowed limit.  Therefore, the <b>token</b> variable (in <b>settings.py</b> ) will now be a tuple containing several tokens from different id.  At each request to the VK API, the script will choose one of them in a random way: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_url</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method_name, parameters, access_token=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""read https://vk.com/dev/api_requests"""</span></span> req_url = <span class="hljs-string"><span class="hljs-string">'https://api.vk.com/method/{method_name}?{parameters}&amp;v={api_v}'</span></span>.format( method_name=method_name, api_v=api_v, parameters=parameters) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> access_token: req_url = <span class="hljs-string"><span class="hljs-string">'{}&amp;access_token={token}'</span></span>.format(req_url, token=random.choice(token)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req_url</code> </pre><br>  In this regard, you should have no difficulties if there are several accounts on VKontakte (you can strain friends, relatives), I did not have problems with 4 tokens and 3 workers. <br><br>  No, no one bothers you to use <b>time.sleep ()</b> , or the example above with while, but then get ready to receive error messages (empty answers are possible at all - id: None), or wait a little longer. <br><br>  The most interesting from the file <b>call.py</b> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMutual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> all_friends = friends(my_id) c_friends = group(mutual_friends.s(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parts(list(all_friends[<span class="hljs-number"><span class="hljs-number">0</span></span>].keys()), <span class="hljs-number"><span class="hljs-number">75</span></span>))().get() result = {k: v <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c_friends <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> d.items()} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cleaner(result) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> result = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(deep): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result: <span class="hljs-comment"><span class="hljs-comment">#  ,     +   id:None lst = list(set([item for sublist in result.values() if sublist for item in sublist]) - set(result.keys())) d_friends = group(deep_friends.s(i) for i in parts(list(lst), 75))().get() result = {k: v for d in d_friends for k, v in d.items()} result.update(result) else: all_friends = friends(my_id) d_friends = group(deep_friends.s(i) for i in parts(list(all_friends[0].keys()), 75) )().get() result = {k: v for d in d_friends for k, v in d.items()} result.update(result) return cleaner(result)</span></span></code> </pre><br>  As you can see, in 2 functions we use <a href="http://celery.readthedocs.org/en/latest/userguide/canvas.html">groups ()</a> , which runs several tasks in parallel, after which we ‚Äúglue‚Äù the answer.  Remember how <b>deep_friends ()</b> looked at the beginning (there‚Äôs a very old example - even without multithreading)?  The meaning remains the same - we use the set difference. <br><br>  And finally, <b>tasks.py</b> .  Someday these great features will merge into one: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.task def mutual_friends(lst): """ read https://vk.com/dev/friends.getMutual and read https://vk.com/dev/execute """ result = {} for i in list(parts(lst, 25)): r = requests.get(request_url('execute.getMutual', 'source=%s&amp;targets=%s' % (my_id, make_targets(i)), access_token=True)).json()['response'] for x, vk_id in enumerate(i): result[vk_id] = tuple(i for i in r[x]) if r[x] else None return result @app.task def deep_friends(friends): result = {} for i in list(parts(friends, 25)): r = requests.get(request_url('execute.deepFriends', 'targets=%s' % make_targets(i), access_token=True)).json()["response"] for x, vk_id in enumerate(i): result[vk_id] = tuple(r[x]["items"]) if r[x] else None return result</span></span></code> </pre><br>  When everything is set up, run <b>RabbitMQ with the</b> command: <br><br><pre> <code class="bash hljs">rabbitmq-server</code> </pre><br>  Then go to the project folder and activate the worker: <br><br><pre> <code class="bash hljs">celery -A tasks worker --loglevel=info</code> </pre><br>  Now, to get and save a list of common or "deep" friends, just command in the console: <br><br><pre> <code class="bash hljs">python3 call.py</code> </pre><br><h4>  About measurement results </h4><br>  Let me remind you that the author of the <a href="http://habrahabr.ru/post/216831/">article</a> , which inspired me to the <a href="http://habrahabr.ru/post/221251/">first part</a> , had <b>343 friends</b> (a request for mutual friends) ‚Äúprocessed‚Äù in <b>119 seconds</b> . <br><br>  My version of the <a href="http://habrahabr.ru/post/221251/">previous article</a> did the same thing in <b>9 seconds</b> . <br><br>  Now that author has a different number of friends - 308. Well, you have to make one extra request for the last eight id, spend a precious second on it, although you can process 75 id in that second. <br><br>  With one worker, the script took <b>4.2 seconds</b> , and with two workers, <b>2.2 seconds</b> . <br><br>  If 119 is round to 120, and 2.2 to 2, then my version works <b>60 times faster</b> . <br><br>  As for the ‚Äúdeep friends‚Äù (friends of my friends and so on + we test on another id to wait less) - with a depth equal to 2, the number of keys in the dictionary was 1,251. <br><br>  The execution time of the code given at the very beginning of the article is <b>17.9 seconds</b> . <br><br>  With one worker, the script execution time is <b>15.1 seconds</b> , with two workers, <b>8.2 seconds</b> . <br><br>  Thus, <b>deep_friends () has</b> become about <b>2.18 times</b> faster. <br><br>  Yes, the result is not always so bright, sometimes you have to wait 10 or 20 seconds for a response to one VKontakte (although the frequent execution time of one task is <b>1.2 - 1.6 seconds</b> ), most likely, this is due to the load on the service, because we not alone in the universe. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/74b/3d9/722/74b3d9722972459e9a85bfb97508c9dc.png"></div><br>  As a result, the more workers do, the faster the result will be processed.  Do not forget about the power of your hardware, additional tokens, the network (for example, the author dramatically increased the script execution time when he used his iPhone as an access point) and other factors. <br><br><h4>  Saving result </h4><br>  Yes, there are a lot of graph-oriented databases.  If in the future (and it will be so), we want to analyze the results obtained, then all the same they will need to be stored somewhere until the analysis itself, then the same results should be uploaded to the memory and some actions should be taken with them.  I see no reason to use any subd, if the project would be commercial and we were interested in, for example, what happens to the graph of a particular user over time - then yes, then the graph-oriented database is obligatory, but since we will be engaged in the analysis at home ‚Äú <a href="https://docs.python.org/3.4/library/pickle.html">Pickle</a> is enough for us. <br><br>  Before saving dictionaries, it will be logical to delete from them keys whose values ‚Äã‚Äãare <b>None</b> .  These are blocked or deleted accounts.  Simply put, these id will be in the column, because they have someone as friends, well, we will save on the number of keys in the dictionary: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleaner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dct)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {k:v <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dct.items() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_or_load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myfile, sv, smth=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sv <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> smth: pickle.dump(smth, open(myfile, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pickle.load(open(myfile, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>))</code> </pre><br>  As you can see, if we save the result somewhere, then we need to load it somewhere in order not to collect the id again. <br><br><h4>  Graph analysis </h4><br>  In order not to write your bike, <b>let's</b> use a fairly well-known <b>networkx</b> , which will do all the <s>dirty</s> work for us.  You can learn more about <b>networkx</b> from this <a href="http://habrahabr.ru/post/125898/">article</a> . <br><br><pre> <code class="bash hljs">pip3 install networkx</code> </pre><br>  Before we begin to analyze the graph, draw it.  <b>networkx</b> for this you need <b>matplotlib</b> : <br><br><pre> <code class="bash hljs">pip3 install matplotlib</code> </pre><br>  Next we need to create the graph itself.  In general, there are 2 ways. <br><br>  The first will eat a lot of RAM and your time: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph.nodes(): self.graph.add_node(node) self.graph = nx.Graph() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.dct.items(): self.adder(k) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v: self.adder(i) self.graph.add_edge(k, i)</code> </pre><br>  And this is not the author has survived the mind, no.  A similar example is given on <a href="https://www.clear.rice.edu/comp200/resources/howto/networkx.shtml">the</a> Rice University <a href="https://www.clear.rice.edu/comp200/resources/howto/networkx.shtml">page</a> , under the heading <i>Convert Dictionary Graph Representation into networkx Graph Representation</i> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dict2nx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aDictGraph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Converts the given dictionary representation of a graph, aDictGraph, into a networkx DiGraph (directed graph) representation. aDictGraph is a dictionary that maps nodes to its neighbors (successors): {node:[nodes]} A DiGraph object is returned. """</span></span> g = nx.DiGraph() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node, neighbors <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> aDictGraph.items(): g.add_node(node) <span class="hljs-comment"><span class="hljs-comment"># in case there are nodes with no edges for neighbor in neighbors: g.add_edge(node, neighbor) return g</span></span></code> </pre><br>  You can take my word for it, the count was being built the whole evening, when there were already more than 300,000 peaks in it, my patience snapped.  <s>If you completed a <a href="https://www.coursera.org/course/interactivepython">course</a> on oursera on Python from this university, then you know what I mean.</s>  <s>And I told everyone on the course that people do not teach this, but oh well.</s> <br><br>  Yes, an example is given for a directed graph, but the essence remains the same - first we add keys, making them vertices, then making vertices of the values, and then if they are not already in the graph, and then we connect them with edges (in my version). <br><br>  And the second method will do everything in seconds: <br><br><pre> <code class="python hljs">self.graph = nx.from_dict_of_lists(self.dct)</code> </pre><br>  The code lies in the <b>graph.py</b> file, to draw a graph of mutual friends, just run this script or create an instance of the <b>VkGraph ()</b> class <b>somewhere</b> and then call its <b>draw_graph ()</b> method. <br><img src="//habrastorage.org/files/d3a/f5b/c31/d3af5bc314db469da4010b85fefff3af.png"><br>  This is a graph of mutual friends, with a total of 306 vertices and 2096 edges.  Unfortunately, I have never been a designer (almost all the settings are standard), but you can always stylize the graph ‚Äúfor yourself‚Äù.  Here are a couple of links: <br><br><ul><li>  <a href="http://matplotlib.org/api/figure_api.html">Figure API</a> </li><li>  <a href="http://networkx.github.io/documentation/latest/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html">Draw networkx</a> </li></ul><br>  And the method itself looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_graph</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">19</span></span>,<span class="hljs-number"><span class="hljs-number">19</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">450</span></span>,) nx.draw(self.graph, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, cmap=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) plt.savefig(<span class="hljs-string"><span class="hljs-string">"%s graph.png"</span></span> % datetime.now().strftime(<span class="hljs-string"><span class="hljs-string">'%H:%M:%S %d-%m-%Y'</span></span>))</code> </pre><br>  As a result, you get a picture of the <b>date graph.png</b> in the project folder.  I do not recommend drawing a graph for deep friends.  With <b>308</b> friends and a depth of 2, there are more than <b>145,000</b> keys in the dictionary.  And there are after all also values ‚Äã‚Äã- tuples with id, which are unlikely to be small. <br><br>  For a long time I was looking for the most poor friends on VKontakte profile, although it‚Äôs more important - friends and friends.  There are 10 initial friends (1 of them is locked and will be automatically deleted), with our standard depth (2), in the dictionary there were <b>1234</b> keys and <b>517 174</b> id (from values).  Approximately <b>419</b> friends for one id.  Yes, there are common friends, when we build a graph, we will understand this: <br><br><pre> <code class="python hljs">deep_friends = VkGraph(d_friends_dct) print(<span class="hljs-string"><span class="hljs-string">' :'</span></span>, deep_friends.graph.number_of_nodes()) print(<span class="hljs-string"><span class="hljs-string">' :'</span></span>, deep_friends.graph.number_of_edges())</code> </pre><br>  Will return: <br><br><pre> <code class="bash hljs"> : 370341  : 512949</code> </pre><br>  With such big data it would be nice to play around.  <b>Networkx has a</b> very large <a href="https://networkx.github.io/documentation/networkx-1.9/reference/algorithms.html">list of algorithms</a> that can be applied to graphs.  Let us examine <b>some</b> of them. <br><br><h5>  Connected graph </h5><br>  First, let's determine if the graph is connected: <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">' ?'</span></span>, nx.is_connected(deep_friends.graph))</code> </pre><br>  A connected graph is a graph in which any pair of vertices is connected by a route. <br><br>  By the way, at the same id with a depth equal to 1, this is such a beautiful graph containing 1268 vertices and 1329 edges: <br><img src="//habrastorage.org/files/883/49f/429/88349f42920f4f378d79b895bfe4c767.png"><br>  A question for connoisseurs.  Once we have a graph of friends of friends, it should be connected anyway.  There can not be such that from nowhere a vertex appears that is not connected with any of the existing ones.  However, we see on the right one vertex that is not connected to any one.  Why?  I urge you to think first, it will be more interesting to learn the truth. <br><br><div class="spoiler">  <b class="spoiler_title">Correct answer</b> <div class="spoiler_text">  Let's see.  First, a list of friends is taken, and it turns out that we have id X. Because of which the graph is incoherent.  Next, we make a request to the friends of this X (in depth because).  So if X has all the friends hidden, then there will be an entry in the dictionary: <br><br><pre> <code class="python hljs">{X:(), ...}</code> </pre><br>  When the graph is built, we honestly add the vertex X, but it will not have any edges.  Yes, theoretically, the vertex X should have an edge with a vertex whose id is specified in <b>settings.py</b> , but you read it carefully - we add only what is in the dictionary.  Therefore, with a depth equal to 2, we will get the id specified in the settings in the dictionary.  And then edges will appear at vertex X. <br></div></div><br>  We assume that you will not have such a situation, that is, most likely you will see <b>True</b> . <br><br><h5>  Diameter, center and radius </h5><br>  Recall that the <b>diameter of a graph</b> is the maximum distance between its two vertices. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">' :'</span></span>, nx.diameter(deep_friends.graph))</code> </pre><br>  <b>The center of a graph</b> is any vertex, such that the distance from it to the most distant vertex is minimal.  The center of the graph can be one vertex or several vertices.  Or easier.  The center of the graph is a vertex, eccentricity (the distance from this vertex to the farthest from it) is equal to the radius. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">' :'</span></span>, nx.center(deep_friends.graph))</code> </pre><br>  Returns a list of vertices that are the center of the graph.  Do not be surprised if the center is the id specified in <b>settings.py</b> . <br><br>  <b>The radius of the graph</b> is the smallest eccentricity of all vertices. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">' :'</span></span>, nx.radius(deep_friends.graph))</code> </pre><br><h5>  Authority or page rank </h5><br>  This is the same <b>Page Rank</b> , which you thought.  As a rule, the algorithm is used for web pages or other documents linked by links.  The more links to a page, the more important it is.  But nobody forbids using this algorithm for graphs.  We will borrow a more precise and suitable definition from this <a href="http://geektimes.ru/post/81225/">article</a> : <br><blockquote>  Authority in the social graph can be analyzed in various ways.  The easiest one is to sort the participants by the number of incoming edges.  Who has more - the more authoritative.  This method is suitable for small graphs.  Searching on the Internet, Google uses PageRank as one of the criteria for authoritative pages.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is calculated using a random walk along the graph, where the nodes are the pages and the edge between the nodes is if one page refers to another. </font><font style="vertical-align: inherit;">The random walker moves along the graph and from time to time moves to a random node and starts the walk again. </font><font style="vertical-align: inherit;">PageRank is equal to the proportion of stay on a node for the entire time of wandering. </font><font style="vertical-align: inherit;">The more it is, the more authoritative the node.</font></font></blockquote><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> operator print(<span class="hljs-string"><span class="hljs-string">'Page Rank:'</span></span>, sorted(nx.pagerank(deep_friends.graph).items(), key=operator.itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>), reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>))</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clustering coefficient </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quoting Wikipedia: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The clustering factor is the degree of probability that two different users associated with a particular individual are also connected. </font></font></blockquote><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">' '</span></span>, nx.average_clustering(deep_friends.graph))</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there is nothing complicated, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">networkx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offers many more </font></font><a href="https://networkx.github.io/documentation/networkx-1.9/reference/algorithms.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the author counted 148) that can be applied to graphs. You just have to choose the algorithm you need and call the appropriate method in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graph.py</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">.</font></font><br><br><h4>  Total </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We made a distributed system that allows you to collect and build a graph of common friends on VKontakte, which works 60 times faster (depending on the number of workers) than the proposed </font></font><a href="http://habrahabr.ru/post/216831/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font></font><a href="http://habrahabr.ru/users/himura/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Himura</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , also implemented a new function - a request from all "deep friends", added the ability to analyze constructed graphs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you do not want to install additional software and you need to build a beautiful graph of mutual friends from the previous </font></font><a href="http://habrahabr.ru/post/221251/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">old release is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at your service. In it, you will also find the old version of retrieving the list of friends of the user recursively as deeply as you like. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is not the limit at all, work will continue to increase the speed of the program.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Still waiting for you delicious pull requests, especially if you are engaged in data visualization. </font></font> Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/243229/">https://habr.com/ru/post/243229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243217/index.html">InterSystems iKnow. Part one. iKnow and beach holidays</a></li>
<li><a href="../243219/index.html">RFM analysis on the knee (Excel)</a></li>
<li><a href="../243221/index.html">Meeting of mobile game developers, November 27, Moscow</a></li>
<li><a href="../243225/index.html">What is silent technical task?</a></li>
<li><a href="../243227/index.html">Setting up automatic restart of Windows services in Nagios XI</a></li>
<li><a href="../243231/index.html">VexorCI under the hood</a></li>
<li><a href="../243233/index.html">Calling a non-predefined method in a category after overriding it</a></li>
<li><a href="../243235/index.html">Fight for the buyer or how to buy loyalty?</a></li>
<li><a href="../243237/index.html">Localization of the button "Build"</a></li>
<li><a href="../243241/index.html">From the life of the usability lab Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>