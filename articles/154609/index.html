<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple OS Scheduler Model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago I tried to find here some information about the Windows scheduler and to my surprise I did not find anything concrete about the schedu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple OS Scheduler Model</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago I tried to find here some information about the Windows scheduler and to my surprise I did not find anything concrete about the schedulers in general, so I decided to post this example of the scheduler, I hope someone will find it useful.  The code is written in Turbo Pascal with 8086 assembly language inserts. <br><br><h5>  What does the planner actually plan? </h5><br>  The scheduler is the part of the operating system that is responsible for (pseudo) parallel execution of tasks, threads, processes.  The scheduler allocates processor time, memory, stack, and other resources to threads.  The scheduler can forcibly take control of the thread (for example, by timer or when a stream with a higher priority appears), or simply wait until the thread itself explicitly (by calling a certain system procedure) or implicitly (upon completion) gives control to the scheduler. <br>  The first variant of the scheduler is called real or preemptive, the second, respectively, non-preemptive. <br><a name="habracut"></a><br><h5>  Planning algorithms </h5><br>  There are several algorithms for both preemptive and non-preemptive schedulers.  First, let's figure out which mechanism is better?  At first glance it seems obvious that preemptive multitasking is always better than non-preemptive.  But it is not so.  Non-preemptive multitasking gives a big handicap preempting where it is necessary for the processor to be constantly busy with the solution of tasks, and not with their switching, preparation, waiting.  An example is batch processing systems.  And in modern user OS it‚Äôs hard to imagine without preemptive multitasking (although before the release of Windows NT, everything was completely without it). <br>  So consider the main algorithms for non-preemptive layout: <br><ul><li>  FIFO </li><li>  The shortest - forward! </li><li>  The most fulfilled forward! </li></ul><br>  As for the first, I think everything is so clear: the first one came - the first one left.  The simplest but, unfortunately, is not the most efficient algorithm, because due to the solution of someone's kilometer integral with one stream, the other will wait an hour for the queue to add two numbers. <br><img src="https://habrastorage.org/storage2/e40/739/252/e4073925294f4c17d50b6008bbf5b68a.png"><br>  An obvious way to increase efficiency is to skip short threads forward in a queue.  So, first all the flows that need to be calculated 2 * 2 are executed, and only then that kilometer integral will begin to be calculated.  The truth here, too, has its drawbacks: for example, a long thread interrupted by I / O will again be placed at the end of the queue. <br>  The third algorithm eliminates this situation: threads that currently need the least amount of time are placed at the head of the queue. <br>  In batch processing systems, three scheduling levels are usually used: at the beginning, a job queue is formed in disk memory (memory scheduling), from there the streams enter the main memory, where one of the above algorithms is also lined up.  There may be a situation where there are too many processes, then some processes are returned back to disk (access scheduler).  Actually, the third scheduler, the process scheduler, deals with the organization of access of threads to the processor control. <br>  What is obvious - non-preemptive multitasking is not suitable for operating systems that require an instant response to any user actions.  In addition, such a mechanism requires the programmer to understand the internal structure of the system, and places the responsibility not only on the work of the program, but also on the work of the entire system as a whole.  After all, no one wants to use your product if it hangs the system for a week, right? <br>  Consider several preemptive scheduling algorithms: <br><ul><li>  Cyclic </li><li>  Timed </li><li>  Prioritized by appointment </li></ul><br>  The first algorithm is a direct analogue of the queue, or rather this is the queue: the first one arrived - the first one got its time quantum, again stood at the end of the queue.  Only one obvious, but very offensive minus is that a stream that uses 1/10 of a time slice will eat as much CPU time as a stream using a whole quantum. <br>  The second algorithm solves this problem: each thread is assigned a priority inversely proportional to the quantum fraction used.  Thread with higher priority is queued up earlier. <br>  The third algorithm is characteristic of interactive (server) operating systems, in which the processing of user requests is at the forefront.  Priority to threads is assigned depending on the task they perform.  Here, for example, the highest priority will be the processing of http requests, a little less processing of operator commands, etc. When using such an algorithm, it is possible to compensate for the infrequent transfer of control to the stream, by allocating a larger time slice to it.  So the thread that has lower priority and potentially the longest waiting in the queue will receive the most CPU time. <br>  Preemptive multitasking does not require the programmer to understand the subtleties of the work of the scheduler, but also has pitfalls. <br><br><h5>  Critical sections </h5><br>  With processor time or a stack everything seems to be simple, but what if a thread needs, for example, to print a kitten on a printer?  And what if there are two such streams?  With non-preemptive multitasking, everything will go like clockwork: one thread will stamp the kitten, end and give control to the scheduler, which will allow the second stream to be printed.  But if the multitasking is repressive, the scheduler can switch threads at the moment when they have not yet completed printing and something like this will turn out: <br><img src="https://habrastorage.org/storage2/3cb/c54/279/3cbc54279f8c82d3a8ed86b447e79264.jpg"><br>  To prevent this from happening, the mechanism of critical sections is introduced.  The flow that a certain inseparable resource wants to occupy informs the scheduler about this.  If the resource is not yet occupied by another thread - the scheduler allows the thread to continue to work, and he marks the resource as busy.  If the resource is busy, the thread is placed in the queue, where it waits for it to be released.  Upon completion of work with such a resource, the thread should inform the scheduler that the resource can now use other threads.  These two actions: an attempt to capture a resource and a termination message with it are called critical brackets.  By the way, with their inept placement, a situation of mutual blocking of threads may arise, which is not always well and quickly diagnosed and can cause a non-illusion bather at the developer and the user after the product is released. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Interlock </h5><br>  Suppose we have the indivisible resources A and B and the flows X, Y, which want to use these resources.  If a certain <s>Krivoruki is</s> not a competent programmer, he <s>places</s> critical brackets like this: <br>  ... <br>  Stream x <br>  Borrow Resource (A) <br>  Borrow Resource (B) <br>  ... <br>  Give Resource (A) <br>  Give Resource (B) <br>  Thread y <br>  Borrow Resource (B) <br>  Borrow Resource (A) <br>  ... <br>  Give Resource (B) <br>  Give Resource (A) <br><br>  after a while this situation will arise: <br><img src="https://habrastorage.org/storage2/d34/8d9/f90/d348d9f90374ed1ad90a58806440018a.png"><br><br><h5>  Sweetie </h5><br>  Well, actually for the sake of what it was all written.  As already mentioned, the code of our scheduler will be executed in the language Turbo Pascal. <br>  The mechanism of critical sections is implemented in the procedures EnterCritical (), LeaveCritical ().  Recall once again: to enter the critical section, you need to check if it is busy, and by result, either take it and allow the thread to use it, or put the flow in a queue and transfer control to someone else. <br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterCritical</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num:TCriticalNum)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{   }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> cli <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num&lt;=maxCritical <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> criticalTable[num]&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> inc(criticalTableWait[num]); <span class="hljs-comment"><span class="hljs-comment">{    }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> criticalTable[num]&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{   -}</span></span> <span class="hljs-comment"><span class="hljs-comment">{       }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> sti <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SwitchThreads; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> cli <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(criticalTableWait[num]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; criticalTable[num]:=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> sti <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  With LeaveCritical (), everything seems to be clear: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeaveCritical</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num:TCriticalNum)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{  }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> cli <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num&lt;=maxCritical <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> criticalTable[num]:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> sti <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> criticalTableWait[num]&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">{ -  }</span></span> switchThreads; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The procedure for switching threads is written using assembler inserts, so you can see the moment of switching threads from one to another up to machine instructions: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimerHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags,cs,ip,ax,bx,cx,dx,si,di,ds,es,bp:word)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interrupt</span></span>; <span class="hljs-comment"><span class="hljs-comment">{         ,            }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ThreadNumber:byte=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NumPrev:byte=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tsoffset:word=<span class="hljs-number"><span class="hljs-number">0</span></span>; mainSP:word=<span class="hljs-number"><span class="hljs-number">0</span></span>; mainSS:word=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> DisableHardwareEvents <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> pushf <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; oldvec8; <span class="hljs-comment"><span class="hljs-comment">{     .    .}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> preemptiveSwitch <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DisableHardwareEvents <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ThreadsRegistered&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (parallelStart) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{   }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> cli <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParallelStart <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{     }</span></span> StepCount:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov ParallelFinished,false <span class="hljs-comment"><span class="hljs-comment">{  }</span></span> mov mainsp,bp <span class="hljs-comment"><span class="hljs-comment">{      }</span></span> mov mainss,ss <span class="hljs-comment"><span class="hljs-comment">{  }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(StepCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-comment"><span class="hljs-comment">{ts[ThreadNumber].active and}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ParallelStart <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{   () .      ParallelStart, .. ,        }</span></span> <span class="hljs-comment"><span class="hljs-comment">{      }</span></span> tsoffset:=ThreadNumber*sizeof(TThreadStateWord); <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> push ds <span class="hljs-comment"><span class="hljs-comment">{ ,    DS     !}</span></span> mov ax,seg ts mov es,ax mov di,offset ts add di,tsoffset mov ax,ss mov ds,ax mov si,bp <span class="hljs-comment"><span class="hljs-comment">{ds:si   ,   }</span></span> cld mov cx,<span class="hljs-number"><span class="hljs-number">12</span></span> rep movsw <span class="hljs-comment"><span class="hljs-comment">{    ( )}</span></span> pop ds <span class="hljs-comment"><span class="hljs-comment">{es:di   24          }</span></span> mov ax,bp <span class="hljs-comment"><span class="hljs-comment">{BP     12  }</span></span> add ax,<span class="hljs-number"><span class="hljs-number">12</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span> stosw <span class="hljs-comment"><span class="hljs-comment">{SP }</span></span> mov ax,ss stosw <span class="hljs-comment"><span class="hljs-comment">{SS }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{   }</span></span> NumPrev:=ThreadNumber; <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> ThreadNumber:=(ThreadNumber+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> ThreadsRegistered; <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> (ThreadNumber=NumPrev) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> TS[ThreadNumber].active; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ts[ThreadNumber].active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((ThreadNumber&lt;&gt;NumPrev) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> parallelStart) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{  ,     .     ParallelStart,       , ..  ,          0}</span></span> tsOffset:=(ThreadNumber+<span class="hljs-number"><span class="hljs-number">1</span></span>)*sizeof(TThreadStateWord) - <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov dx,ds mov ax,seg TS mov ds,ax mov si,offset TS add si,tsOffset <span class="hljs-comment"><span class="hljs-comment">{ds:si     }</span></span> std lodsw mov ss,ax lodsw mov sp,ax mov bp,ax <span class="hljs-comment"><span class="hljs-comment">{    }</span></span> sub bp,<span class="hljs-number"><span class="hljs-number">12</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">{       .          ,         }</span></span> mov cx,<span class="hljs-number"><span class="hljs-number">12</span></span> @m1: lodsw push ax loop @m1 cld mov ds,dx <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ts[Threadnumber].active) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Threadnumber=NumPrev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{  }</span></span> setintvec($<span class="hljs-number"><span class="hljs-number">8</span></span>,@oldvec8); <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov parallelfinished,true mov ax,mainss mov ss,ax mov bp,mainsp mov sp,bp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; parallelstart:=false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; DisableHardwareEvents:=false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The procedure itself is compiled with the interrupt directive, that is, it is an interrupt handler.  Which can be triggered by both hardware and software by calling int 08h, like this: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwitchThreads</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> parallelFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> cli mov DisableHardwareEvents,<span class="hljs-number"><span class="hljs-number">1</span></span> int <span class="hljs-number"><span class="hljs-number">08</span></span>h sti <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  It is also necessary to describe the procedures for registering, starting and stopping threads.  If someone is interested, you can see in the source code of the RegistrThread, RunThread, StopThread procedure. <br>  That's all!  Our planner is ready. <br>  The sources together with an example of a multi-threaded program written for this planner and the dos turbik can be downloaded <a href="http://rghost.ru/40911869">here</a> .  You can play around and see how the threads will be executed differently with preemptive and non-preemptive multitasking (ExecuteRegisterThreads (true / false) procedure), simulate a deadlock situation and make sure that it is not always diagnosable (I once waited a minute for a deadlock to occur). <br>  I recommend to run Win98 systems from DOSbox under new systems. </div><p>Source: <a href="https://habr.com/ru/post/154609/">https://habr.com/ru/post/154609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154597/index.html">Vulnerability in Oracle 11g Authentication Protocol</a></li>
<li><a href="../154599/index.html">Google Nexus 7 tablet video review</a></li>
<li><a href="../154601/index.html">s02.e06. Robots</a></li>
<li><a href="../154603/index.html">Algorithmization of creativity: the creation of interesting advertising without creativity</a></li>
<li><a href="../154607/index.html">Embarcadero: we are not interested in small developers (following the results of the ‚Äúworld tour‚Äù)</a></li>
<li><a href="../154611/index.html">RailsClub'Moscow 2012. Materials</a></li>
<li><a href="../154613/index.html">What a Perl novice developer should know about pearl barley infrastructure</a></li>
<li><a href="../154615/index.html">A patent that allows to ban 3d printers from copying illegal content</a></li>
<li><a href="../154617/index.html">Experience creating a navigation system on Ajax</a></li>
<li><a href="../154619/index.html">Need feedback, with us - prizes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>