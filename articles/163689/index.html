<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minicomputer from a router with OpenWRT: we are developing a USB video card</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. In this series of articles, we will go through a rather long but very interesting way of turning an ordinary router ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minicomputer from a router with OpenWRT: we are developing a USB video card</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/74a/e2d/b33/74ae2db338f17b30178cc53af42025d6.jpg"><br>  Good afternoon, dear habrovchane.  In this series of articles, we will go through a rather long but very interesting way of turning an ordinary router into a mini-computer with an LCD display.  To do this, we will first develop a USB video card based on the STM32F103 microcontroller, then a test driver, which will allow us to display graphics on it, and finally - a full-fledged framebuffer driver, through which you can run real graphical applications, such as x-server.  At the same time, we will learn to include our code in the OpenWRT source tree, finish its kernel and do other useful things. <br>  Well, at the very end we will get the result, which I hope will cause a nostalgic tear in many readers.  I will try to present the material in such a way that at the end of each stage we will get a tangible result that does not let the enthusiasm die away.  So, let's begin. <br><a name="habracut"></a><br><h4>  Iron </h4><br>  Traditionally, let's see what we need of iron.  Those who do not like to solder, I can immediately reassure - all that we will do is purely furvarnoe and software, so we don‚Äôt have to solder.  But on the other hand, you will need debugging on the STM32F103VE controller and QVGA display, which I already mentioned in my <a href="http://habrahabr.ru/post/139601/">article</a> . <br>  We also need, in fact, the router, which I also mentioned in <a href="http://habrahabr.ru/post/158127/">another article</a> , but we will return to it later.  Now let's focus on the development of the USB video card itself based on our debug board. <br><br>  The STM32F103 has two blocks, which will be very useful to us.  The first of them is, of course, a hardware USB controller that is perfect for organizing the connection between our video card and the host.  The second - FSMC - Flexible Static Memory Controller.  It is a static memory controller that can be configured for use with SRAM chips, NAND / NOR FLASH and similar devices, and the bus width and timings in it are configurable.  In this case, the chips are mapped to the address space and, when addressed to the appropriate address, the FSMC itself generates the necessary signals on the control lines and address and data buses, so that for the programmer this process is completely transparent. <br><br>  In the case of the display, this will help us a lot, since displays of this kind are equipped with an interface that almost completely coincides with the interface of a NOR flash drive and SRAM: a 16-bit data bus, CS, ~ WR, ~ RD gates.  With these signals, everything is simple - CS activates the display, it begins the cycle of data exchange.  ~ WR or ~ RD are activated when they are read or written, respectively. <br>  Unfortunately, the display does not provide us with its own bus address and data for access directly to the video memory, instead, we have a single 16-bit bus and an additional RS signal, Register Select, available to us.  When the RS signal is active, the value set for this bus is taken as the register address (RAM cell) of the display controller to be addressed, and the subsequent reading or writing with an inactive RS is the display RAM operation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It should be noted that the RAM in this case is not the video memory, it is the memory of the display controller, which is accessible from the outside through the mechanism described above.  Video memory also appears in the documentation as GRAM, Graphics RAM, and its contents are accessible through the ‚Äúwindow‚Äù in the form of one of the registers.  In this case, the logic of the display controller itself increments / decrements the internal address of the video memory when sequentially reading from the same register (CTR_WRITE_DATA, CTR_READ_DATA) <br>  FSMC does not have a specialized RS signal, so one trick is used for this: one of the available FSMC address bus signals is connected to the RS signal. <br>  Suppose we connect the signal A0 to the RS.  Then, when accessing the memory address 0x00000000 to write (relative to the base address to which the FSMC bank is mapped), the RS signal will be inactive and the display will take this as setting the register address. <br>  When accessing 0x00000001, the address line A0 will be active, and reading or writing will be performed for the RAM cell, that is, for the register whose address was specified when accessing the zero address. <br>  You can read more about this in the <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/APPLICATION_NOTE/CD00201397.pdf">apnote</a> from the STM on this issue. <br>  The description of the registers of the display controller is available to its <a href="http://www.adafruit.com/datasheets/ILI9325.pdf">datasheet</a> . <br><br>  By the way, you should be careful with the datasheets and carefully look at its version, because the Chinese comrades adore first copying the microchip itself (not completely, but how it will turn out), and then copying the datasheet from this microchip.  Therefore, in the process of reading a datasheet, you can surprisingly find registers and functions that this controller has never supported and which are already wiped off in the next version of the datasheet. <br>  For example, early versions of the datasheet on this controller report that the display can do hardware bitwise operations, including a hardware mask to implement transparency, however, if you dig deeper, it turns out that this line got into the datasheet on ILI9325 from the datasheet of another Japanese controller display, which the Chinese safely copied and called them compatible. <br><br>  Since the display is already connected to the Mini-STM32, all we need is to find out which of the chip select signals it is connected to and which address line is used as the RS signal. <br>  According to the scheme, FSMC_NE1 is used as the CS signal, and FSMC_A16 is used as the RS. <br>  The display also has a Reset signal output to PE1 and a backlight control signal connected to the PD13. <br>  At the same time, let's see which of the signals is used to connect a USB pull-up, which we'll talk about later - in this scheme it is PC13. <br><br>  So go to the code. <br><br><h4>  Soft </h4><br><h6>  LCD operation </h6><br>  Let's start with the development of a small library to work with the display.  We will work in CooCox IDE.  We put in the header file all the addresses of the registers from the datasheet: <br><br><div class="spoiler">  <b class="spoiler_title">LCD Register Announcement</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_OSC_START 0x0000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DRV_OUTPUT1 0x0001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DRV_WAVE 0x0002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_ENTRY_MODE 0x0003 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_RESIZE 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DISPLAY1 0x0007 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DISPLAY2 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DISPLAY3 0x0009 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DISPLAY4 0x000A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_RGB_INTERFACE1 0x000C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_FRM_MARKER 0x000D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_RGB_INTERFACE2 0x000F #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_POWER1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_POWER2 0x0011 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_POWER3 0x0012 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_POWER4 0x0013 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_HORZ_ADDRESS 0x0020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_VERT_ADDRESS 0x0021 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_WRITE_DATA 0x0022 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_READ_DATA 0x0022 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_POWER7 0x0029 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_FRM_COLOR 0x002B #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA1 0x0030 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA2 0x0031 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA3 0x0032 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA4 0x0035 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA5 0x0036 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA6 0x0037 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA7 0x0038 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA8 0x0039 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA9 0x003C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_GAMMA10 0x003D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_HORZ_START 0x0050 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_HORZ_END 0x0051 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_VERT_START 0x0052 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_VERT_END 0x0053 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_DRV_OUTPUT2 0x0060 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_BASE_IMAGE 0x0061 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_VERT_SCROLL 0x006A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG1_POS 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG1_START 0x0081 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG1_END 0x0082 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG2_POS 0x0083 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG2_START 0x0084 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PIMG2_END 0x0085 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PANEL_INTERFACE1 0x0090 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PANEL_INTERFACE2 0x0092 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_PANEL_INTERFACE4 0x0095 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_OTP_VCMPROGRAM 0x00A1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_OTP_VCMSTATUS 0x00A2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTR_OTP_IDKEY 0x00A5</span></span></code> </pre> <br></div></div><br>  We remember that from the point of view of the code, accessing the FSMC will be a simple write / read from memory, so we need to determine by which addresses to access.  We look in the reference manual on STM32, section FSMC, and we see that for NOR / SRAM, addresses starting with 0x60000000 are highlighted. <br>  By banks in a broad sense, the manual refers to large regions allocated for devices of different types, for example, bank # 1 is NOR / SRAM, banks # 2 and # 3 are NAND, bank # 4 is a PC Card. <br>  In turn, bank # 1 can be used to access as many as 4 memory chips, each of which can independently of the others be NOR or SRAM.  Since the display is connected as NE1, we are interested in the bank announced as FSMC_Bank1_NORSRAM1.  Based on the base address, you can immediately write the definition <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCDRegister (*((volatile uint16_t*) 0x60000000))</span></span></code> </pre><br>  The address that activates the RS will be the address where the A16 line is active, that is, for example, 0x60000000 + (2 &lt;&lt; 16), that is, 0x60020000, so we write <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCDMemory (*((volatile uint16_t*) 0x60020000))</span></span></code> </pre><br>  And immediately define the corresponding macros for writing values ‚Äã‚Äãto the display registers and to its memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_WRITE_REGISTER(REG, DATA) LCDRegister=REG;LCDMemory=DATA; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_BEGIN_RAM_WRITE LCDRegister=CTR_WRITE_DATA; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_WRITE_RAM(DATA) LCDMemory=DATA</span></span></code> </pre><br>  At the same time, we will define the names of the pins and their ports, responsible for resetting the display and turning on the backlight: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BacklightPin GPIO_Pin_13 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BacklightPort GPIOD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ResetPin GPIO_Pin_1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ResetPort GPIOE</span></span></code> </pre><br>  Now we will write the initialization code for the FSMC and associated peripherals: <br><br><div class="spoiler">  <b class="spoiler_title">FSMC Initialization Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDInitHardware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SysTick_Config(SystemCoreClock/<span class="hljs-number"><span class="hljs-number">1000</span></span>); GPIO_InitTypeDef GPIO_InitStructure; FSMC_NORSRAMInitTypeDef FSMC_InitStructure; FSMC_NORSRAMTimingInitTypeDef FSMC_Timing; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10| GPIO_Pin_11| GPIO_Pin_14| GPIO_Pin_15; <span class="hljs-comment"><span class="hljs-comment">//Interface GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11| GPIO_Pin_12| GPIO_Pin_13| GPIO_Pin_14 | GPIO_Pin_15; //Interface GPIO_Init(GPIOE, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = BacklightPin; //Backlight GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(BacklightPort, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = ResetPin; //Reset GPIO_Init(ResetPort, &amp;GPIO_InitStructure); GPIO_SetBits(ResetPort,ResetPin); FSMC_Timing.FSMC_AddressSetupTime = 1; FSMC_Timing.FSMC_AddressHoldTime = 0; FSMC_Timing.FSMC_DataSetupTime = 5; FSMC_Timing.FSMC_BusTurnAroundDuration = 0; FSMC_Timing.FSMC_CLKDivision = 0; FSMC_Timing.FSMC_DataLatency = 0; FSMC_Timing.FSMC_AccessMode = FSMC_AccessMode_B; FSMC_InitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM1; FSMC_InitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; FSMC_InitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM; FSMC_InitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b; FSMC_InitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable; FSMC_InitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low; FSMC_InitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable; FSMC_InitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState; FSMC_InitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable; FSMC_InitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable; FSMC_InitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable; FSMC_InitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable; FSMC_InitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; FSMC_InitStructure.FSMC_ReadWriteTimingStruct = &amp;FSMC_Timing; FSMC_InitStructure.FSMC_WriteTimingStruct = &amp;FSMC_Timing; FSMC_NORSRAMInit(&amp;FSMC_InitStructure); FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE); }</span></span></code> </pre><br></div></div><br>  Everything is quite simple here - we set the system timer to one millisecond interval (which will be necessary to organize delays in the initialization process of the display controller), then we set up all the signals that the FSMC owns as controlled by ‚Äúalternative functions‚Äù, set the Reset and Backlight pins as Output Push-pull, then go to the settings FSMC. <br>  Timing settings you can try to calculate yourself, I took the recommended from the apnute from the STM and they came up perfectly.  We set the memory type as SRAM, 16-bit bus width, disabling all additional features, the description of which takes more than one page of datasheet. <br>  Let's declare an auxiliary function that allows us to make a fairly accurate delay: <br><br><div class="spoiler">  <b class="spoiler_title">Delay function on SysTick-timer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Tick = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Tick&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) Tick--; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTickDelay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msDelay)</span></span></span><span class="hljs-function"> </span></span>{ Tick=msDelay; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Tick); }</code> </pre><br></div></div><br>  Next, write the initialization function directly display: <br><br><div class="spoiler">  <b class="spoiler_title">LCD Initialization</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LCDHardwareReset(); LCD_WRITE_REGISTER(CTR_OSC_START, <span class="hljs-number"><span class="hljs-number">0x0001</span></span>); LCD_WRITE_REGISTER(CTR_DRV_OUTPUT1, <span class="hljs-number"><span class="hljs-number">0x0100</span></span>); LCD_WRITE_REGISTER(CTR_DRV_WAVE, <span class="hljs-number"><span class="hljs-number">0x0700</span></span>); LCD_WRITE_REGISTER(CTR_ENTRY_MODE, <span class="hljs-number"><span class="hljs-number">0x1038</span></span>); LCD_WRITE_REGISTER(CTR_RESIZE, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_DISPLAY2, <span class="hljs-number"><span class="hljs-number">0x0202</span></span>); LCD_WRITE_REGISTER(CTR_DISPLAY3, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_DISPLAY4, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_RGB_INTERFACE1, <span class="hljs-number"><span class="hljs-number">0x0001</span></span>); LCD_WRITE_REGISTER(CTR_FRM_MARKER, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_RGB_INTERFACE2, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_POWER1, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_POWER2, <span class="hljs-number"><span class="hljs-number">0x0007</span></span>); LCD_WRITE_REGISTER(CTR_POWER3, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_POWER4, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); SysTickDelay(<span class="hljs-number"><span class="hljs-number">200</span></span>); LCD_WRITE_REGISTER(CTR_POWER1, <span class="hljs-number"><span class="hljs-number">0x1590</span></span>); LCD_WRITE_REGISTER(CTR_POWER2, <span class="hljs-number"><span class="hljs-number">0x0227</span></span>); SysTickDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>); LCD_WRITE_REGISTER(CTR_POWER3, <span class="hljs-number"><span class="hljs-number">0x009C</span></span>); SysTickDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>); LCD_WRITE_REGISTER(CTR_POWER4, <span class="hljs-number"><span class="hljs-number">0x1900</span></span>); LCD_WRITE_REGISTER(CTR_POWER7, <span class="hljs-number"><span class="hljs-number">0x1900</span></span>); LCD_WRITE_REGISTER(CTR_FRM_COLOR, <span class="hljs-number"><span class="hljs-number">0x000E</span></span>); SysTickDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>); LCD_WRITE_REGISTER(CTR_HORZ_ADDRESS, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_VERT_ADDRESS, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_HORZ_START, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_HORZ_END, <span class="hljs-number"><span class="hljs-number">239</span></span>); LCD_WRITE_REGISTER(CTR_VERT_START, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); LCD_WRITE_REGISTER(CTR_VERT_END, <span class="hljs-number"><span class="hljs-number">319</span></span>); LCD_WRITE_REGISTER(CTR_DRV_OUTPUT2, <span class="hljs-number"><span class="hljs-number">0x2700</span></span>); LCD_WRITE_REGISTER(CTR_BASE_IMAGE, <span class="hljs-number"><span class="hljs-number">0x0001</span></span>); LCD_WRITE_REGISTER(CTR_VERT_SCROLL, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>); GPIO_SetBits(BacklightPort,BacklightPin); }</code> </pre><br></div></div><br>  The sequence is taken from the datasheet to the display controller, all that needs to be done is simply to initialize certain registers in the right order, turning on its oscillator and power, as well as withstand the recommended delays, allowing the display schematics to settle.  Also in this code, the display modes are set, such as the behavior of the address counter when writing to GRAM ‚Äî you can force the display to increase or decrease the counter, move the indicators down or up ‚Äî that is, set the direction in which pixels will be painted when they are output. . <br>  In this code, the LCDHardwareReset function is a small block of code that exposes the active level on the Reset line, waiting for some time and resetting it to the inactive state: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDHardwareReset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIO_ResetBits(ResetPort,ResetPin); SysTickDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>); GPIO_SetBits(ResetPort,ResetPin); SysTickDelay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  We introduce a couple of control functions responsible for turning the display on and off at the level of its controller: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LCD_WRITE_REGISTER(CTR_DISPLAY1, <span class="hljs-number"><span class="hljs-number">0x0133</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDOff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LCD_WRITE_REGISTER(CTR_DISPLAY1, <span class="hljs-number"><span class="hljs-number">0x0131</span></span>); }</code> </pre><br>  It remains quite a bit - we declare a very important function for us, which sets a rectangle within which the graph will be displayed.  At the same time, work with the output address lies on the shoulders of the display controller, all we need is to set the boundaries of this area: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDSetBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> top, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bottom)</span></span></span><span class="hljs-function"> </span></span>{ LCD_WRITE_REGISTER(CTR_VERT_START, left); LCD_WRITE_REGISTER(CTR_VERT_END, right); LCD_WRITE_REGISTER(CTR_HORZ_START, top); LCD_WRITE_REGISTER(CTR_HORZ_END, bottom); LCD_WRITE_REGISTER(CTR_HORZ_ADDRESS, top); LCD_WRITE_REGISTER(CTR_VERT_ADDRESS, left); }</code> </pre><br>  From the name of the registers it is immediately clear that the function sets the left, right, upper and lower bounds, and then sets the pointer to the position corresponding to the upper left pixel. <br>  Since these pointers refer to the vertical position of the display, and we will use it horizontally, we should swap the left and top places, recording the left value in the registers related to VERTICAL, and top to the HORIZONTAL. <br>  And finally, the function with which we can immediately verify the correct operation of the display is the cleaning function.  It is a simple sequential recording of the same color value in the GRAM display: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color)</span></span></span><span class="hljs-function"> </span></span>{ LCDSetBounds(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">320</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">240</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>); LCD_BEGIN_RAM_WRITE; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">240</span></span>;i++) LCD_WRITE_RAM(color); }</code> </pre><br>  All we need to do to turn on our display is to run <br><br><pre> <code class="cpp hljs">LCDInitHardware(); LCDInit(); LCDOn(); LCDClear(<span class="hljs-number"><span class="hljs-number">0x0000</span></span>);</code> </pre><br>  If done correctly, the display will turn on and paint over black.  When replacing the function argument LCDClear and restarting the program, the display should turn to the selected color. <br>  We now turn to the more difficult part - USB. <br><br><h6>  Work with USB </h6><br>  Working with USB is a very extensive and multifaceted topic, for which one article is clearly not enough. <br>  Therefore, I recommend that you start by reading a very useful document called USB In A Nutshell ( <a href="http://www.beyondlogic.org/usbnutshell/usb1.shtml">English version</a> , <a href="http://microsin.ru/content/view/1107/44/">Russian version</a> ) before continuing. <br>  To sum up briefly, one of the basic concepts in the USB interface is Endpoint, which with some stretch can be called an analogue of a socket. <br>  Just as a socket can be opened for UDP or for TCP connections, endpoints are also divided into types. <br><br><ol><li>  Control Endpoints are used for asynchronous transfer of small control messages, up to 64 bytes in the case of Full Speed ‚Äã‚ÄãUSB.  Zero endpoint must be in any USB device and it must be Control.  Through it, the host requests initial information and initializes the device.  Package delivery through endpoints of this type is guaranteed, in case of an error, the host automatically tries to resend the data.  Control Endpoint is the only bidirectional type of endpoint, all others work either to receive or only to transfer data. </li><li>  Interrupt Endpoints - endpoints for which polling by a host is important at a given frequency (we remember that USB devices cannot initiate a transfer themselves, they are waiting for a request from the host).  Usually this type of points is used in HID-devices such as keyboard and mouse.  The packet size can also be up to 64 bytes in FS USB.  Delivery is guaranteed. </li><li>  Isochronous Endpoint - endpoint, used mainly for transferring audio and video information, where packet loss is not terrible - in this type of endpoint only data integrity is checked, no re-sending in case of an error.  Package size up to 1024 bytes in FS USB. </li><li>  Bulk Enpoints - the main type of endpoints used in storage devices. <br>  It involves sending data packets with guaranteed delivery and a packet size of up to 64 bytes for FS USB (for High Speed, the packet size can be up to 1023 bytes).  In the USB controller of our STM32 it is possible to organize hardware double buffering for packets of this type, increasing throughput. All available bandwidth remaining after Interrupt, Control and Isochronous is divided between Bulk endpoints - so you should pay attention to which other transmissions are running in parallel with Bulk. </li></ol><br>  The type of endpoint that is most suitable for our case is Bulk, we will send blocks of graphic information that will be displayed on the display, and in consequence it will be possible to arrange double buffering.  At the same time, we do not need any periodicity in the premises and the "streaming" essence of Isochronous endpoints, since  graphics data will go in an uncompressed format to arbitrary display positions and lose packets to us absolutely to anything. <br>  In order for the host to understand what device we have, what endpoint it has and what features it has, the host requests several descriptors via Control Endpoint # 0. <br>  The structure described by them is perfectly shown in the figure from the article mentioned above: <br><img src="http://www.beyondlogic.org/usbnutshell/desctree.gif" alt="image"><br>  Let's return to them a bit later, and now let's move on to considering what needs to be added to our firmware in order to make the device work with USB.  We will work consistently and point by point. <br><ol><li>  To begin, download the <a href="">library from STM to work with USB</a> from the official site and place the folder STM32_USB-FS-Device_Driver from the depths of the downloaded archive (located in the Libraries folder) in the folder with our project.  Add it to the project by selecting <b>File - Add Linked Folder</b> .  We add a new folder to our project, calling it somehow like usb_user, in which we create the files hw_config.h and usb_conf.h - these files are required by the library from STM. <br>  Immediately write to hw_config.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span></span></code> </pre><br>  otherwise there will be a lot of errors from unresolved types (uint8_t, uint16_t, uint32_t, ...) <br>  Do not forget to specify the folder with the library and our usb_user in the project properties as additional paths for searching for inclusions. <br></li><li>  Add a new header file to usb_user, which will contain the declarations necessary for the descriptors, let's call it, say, usb_desc.h, putting the following code there: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usb_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_DEVICE_DESC 0x12 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_CONFIG_DESC 0x19 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_STRING_LANGID 0x04 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_STRING_VENDOR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_STRING_PRODUCT 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZ_STRING_SERIAL 0x12 extern const uint8_t USB_ConfigDescriptor[SIZ_CONFIG_DESC]; extern ONE_DESCRIPTOR Device_Descriptor; extern ONE_DESCRIPTOR Config_Descriptor; extern ONE_DESCRIPTOR String_Descriptor[4];</span></span></code> </pre><br>  Here defajny, beginning on " <b>SIZ_</b> " contain the sizes of future descriptors.  In the design process, these dimensions are determined after the descriptors have been written, but since  I have already designed the device, you can simply copy it. <br>  <b>extern const uint8_t USB_ConfigDescriptor</b> we <b>bring</b> to the header just because we need access to this structure from the main module.  The rest of the descriptors are not required, for the reason that we will not give the descriptors in the form of arrays uint_8 to the library, but special structures called <b>ONE_DESCRIPTOR</b> , which, for this occasion, are declared below.  There is nothing wrong with them, they are simply two-member structures, the first of which is a pointer to the same descriptor in the form of <b>uint8_t *</b> , the second is the sixteen-bit length of this descriptor. <br>  Now let's move on to the descriptors, by adding a new usb_desc.c file and connecting our header there. <br>  We start with the descriptor of the device itself.  All the necessary information about the fields is in the USB In A Nutshell article, I will only note that all descriptors begin with the byte length of the descriptor (therefore we took them to the define), followed by the byte - the type of descriptor. <br>  This is how the device handle looks: <br><br><div class="spoiler">  <b class="spoiler_title">Device handle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_DeviceDescriptor[SIZ_DEVICE_DESC] = { <span class="hljs-number"><span class="hljs-number">0x12</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bcdUSB = 2.00 */</span></span> <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDeviceClass: Vendor Specific */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDeviceSubClass */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDeviceProtocol */</span></span> <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bMaxPacketSize0 */</span></span> <span class="hljs-number"><span class="hljs-number">0xAD</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* idVendor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x0D</span></span>, <span class="hljs-number"><span class="hljs-number">0xF0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* idProduct*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bcdDevice = 2.00 */</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Index of string descriptor describing manufacturer */</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Index of string descriptor describing product */</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Index of string descriptor describing the device's serial number */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span> <span class="hljs-comment"><span class="hljs-comment">/* bNumConfigurations */</span></span> };</code> </pre><br></div></div><br><br>  We create a ‚Äúvendor-specific‚Äù device (not belonging to any specific predefined class like HID), with VID = 0xDEAD and PID = 0xF00D, with a single configuration and a maximum packet size of 64 bytes. <br>  Next, we declare a configuration descriptor that includes interface descriptors and endpoints: <br><br><div class="spoiler">  <b class="spoiler_title">Configuration descriptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_ConfigDescriptor[SIZ_CONFIG_DESC] = { <span class="hljs-comment"><span class="hljs-comment">/*Configuration Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Configuration Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Configuration */</span></span> SIZ_CONFIG_DESC, <span class="hljs-comment"><span class="hljs-comment">/* wTotalLength:no of returned bytes */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumInterfaces: 1 interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bConfigurationValue: Configuration value */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iConfiguration: Index of string descriptor describing the configuration */</span></span> <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: bus powered */</span></span> <span class="hljs-number"><span class="hljs-number">0x32</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* MaxPower 100 mA */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Interface Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Interface Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceNumber: Number of Interface */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bAlternateSetting: Alternate setting */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bNumEndpoints: One endpoints used */</span></span> <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceClass: Vendor Specific*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceSubClass*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bInterfaceProtocol*/</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* iInterface: */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*Endpoint 1 Descriptor*/</span></span> <span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bLength: Endpoint Descriptor size */</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType: Endpoint */</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bEndpointAddress: (OUT1) */</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bmAttributes: Bulk */</span></span> <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* wMaxPacketSize: */</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">/* bInterval: */</span></span> };</code> </pre><br></div></div><br>  Here you have to be careful - the first byte is the size only, in fact, the config-descriptor, which is always 0x09 bytes.  Next comes the type of this descriptor, and then comes the two-byte length of the entire array, including the config descriptor, interface descriptors and endpoints.  In this case, it fits into one byte, so the second is left zero. <br>  Then we write that we have one interface, one configuration (located at index 0), that the device is bus-powered and consumes no more than 100 mA. <br>  Further, in the same array, there is an interface descriptor, the same 0x09 bytes in size, two indices, both zeros, on which the host accesses this particular interface, the number of endpoints not counting zero - we will have one, the device class, again ‚ÄúVendor Specific‚Äù , no subclasses, no protocols, no string interface descriptors (zeroes in all corresponding bytes). <br>  Finally, the last is the descriptor of our only endpoint.  Endpoint 0 does not need one, so we immediately describe Bulk Endpoin 1. The address byte sets not only the endpoint number but also the direction of transmission with its high-order bit.  Set the type - Bulk, the maximum packet size (attention, two bytes are allocated for it!) And leave the last byte equal to zero, since  It does not play a role for Bulk-endpoints. <br>  Further we declare string descriptors: <br><br><div class="spoiler">  <b class="spoiler_title">String Descriptors</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USB String Descriptors */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_StringLangID[SIZ_STRING_LANGID] = { SIZ_STRING_LANGID, <span class="hljs-comment"><span class="hljs-comment">/* bLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* String descriptor */</span></span> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span> <span class="hljs-comment"><span class="hljs-comment">/* LangID = 0x0409: US English */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_StringVendor[SIZ_STRING_VENDOR] = { SIZ_STRING_VENDOR, <span class="hljs-comment"><span class="hljs-comment">/* Size of Vendor string */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Manufacturer: "Amon-Ra" */</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'m'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'n'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'R'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_StringProduct[SIZ_STRING_PRODUCT] = { SIZ_STRING_PRODUCT, <span class="hljs-comment"><span class="hljs-comment">/* bLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Product name: "USB LCD" */</span></span> <span class="hljs-string"><span class="hljs-string">'U'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> USB_StringSerial[SIZ_STRING_SERIAL] = { SIZ_STRING_SERIAL, <span class="hljs-comment"><span class="hljs-comment">/* bLength */</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* bDescriptorType */</span></span> <span class="hljs-string"><span class="hljs-string">'U'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre><br></div></div><br>  Unicode strings are written and can be changed as desired. <br>  Finally, fill in the structures that are required by the library: <br><br><div class="spoiler">  <b class="spoiler_title">Library Structures</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ONE_DESCRIPTOR Device_Descriptor = { (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_DeviceDescriptor, SIZ_DEVICE_DESC }; ONE_DESCRIPTOR Config_Descriptor = { (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_ConfigDescriptor, SIZ_CONFIG_DESC }; ONE_DESCRIPTOR String_Descriptor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { {(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_StringLangID, SIZ_STRING_LANGID}, {(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_StringVendor, SIZ_STRING_VENDOR}, {(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_StringProduct, SIZ_STRING_PRODUCT}, {(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)USB_StringSerial, SIZ_STRING_SERIAL} };</code> </pre><br></div></div><br></li><li>  Fill in some descriptive code in usb_conf.h: <br><br><div class="spoiler">  <b class="spoiler_title">Usb_conf.h code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EP_NUM 0x02 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BTABLE_ADDRESS (0x00) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* EP0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* rx/tx buffer base address */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENDP0_RXADDR (0x40) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENDP0_TXADDR (0x80) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* EP1 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* tx buffer base address */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENDP1_RXADDR (0xC0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* IMR_MSK */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* mask defining which events has to be handled */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* by the device application software */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IMR_MSK (CNTR_CTRM | CNTR_RESETM)</span></span></code> </pre><br></div></div><br>  Almost all of the above is not required by the library and is only needed to improve the readability of the code in our main module.  The exception is <b>IMR_MSK</b> , a mask indicating which USB interrupts are used.  We set it to the required minimum - interrupt Correct Transfer and Reset. <br>  Endpoint addresses are set in the address space of the so-called PMA, Packet Memory Area, taking into account the length of the packets.  Since for both endpoints the maximum packet size is set to 64 bytes, we place them with the appropriate step, not forgetting the table of these same endpoint addresses, which is stored in the same place and also takes up space. <br></li><li>  Now we need to determine the callbacks that the library requires.  These callbacks are combined into the <b>DEVICE_PROP</b> and <b>USER_STANDARD_REQUESTS structures</b> , while the library will look for their instances under the names <b>Device_Property</b> and <b>User_Standard_Requests</b> . <br>  We start with the callback called at the very beginning, when the USB controller is initialized, whose function is to reset the USB-clock, call the library initialization functions and activate the USB pull-up, which causes the host to see us on the bus. <br><br><div class="spoiler">  <b class="spoiler_title">void Device_init ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Device_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DEVICE_INFO *pInfo = &amp;Device_Info; pInfo-&gt;Current_Configuration = <span class="hljs-number"><span class="hljs-number">0</span></span>; _SetCNTR(CNTR_FRES); <span class="hljs-comment"><span class="hljs-comment">//Reset USB block _SetCNTR(0); //Deassert reset signal _SetISTR(0); //Clear pending interrupts USB_SIL_Init(); GPIO_ResetBits(GPIOC, GPIO_Pin_13); //Enable pull-up }</span></span></code> </pre><br></div></div><br>  The following callback will be called when the host requests a reset of our device: <br><br><div class="spoiler">  <b class="spoiler_title">void Device_Reset ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Device_Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Set device as not configured pInformation-&gt;Current_Configuration = 0; pInformation-&gt;Current_Interface = 0; //the default Interface /* Current Feature initialization */ pInformation-&gt;Current_Feature = USB_ConfigDescriptor[7]; SetBTABLE(BTABLE_ADDRESS); /* Initialize Endpoint 0 */ SetEPType(ENDP0, EP_CONTROL); SetEPTxStatus(ENDP0, EP_TX_STALL); SetEPRxAddr(ENDP0, ENDP0_RXADDR); SetEPTxAddr(ENDP0, ENDP0_TXADDR); Clear_Status_Out(ENDP0); SetEPRxCount(ENDP0, Device_Property.MaxPacketSize); SetEPRxValid(ENDP0); SetEPType(ENDP1, EP_BULK); SetEPRxAddr(ENDP1, ENDP1_RXADDR); SetEPRxCount(ENDP1, 0x40); SetEPRxStatus(ENDP1, EP_RX_VALID); SetEPTxStatus(ENDP1, EP_TX_DIS); /* Set this device to response on default address */ SetDeviceAddress(0); }</span></span></code> </pre><br></div></div><br>           ,      0,         . <br>    ,       <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_Status_In NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_Status_Out NOP_Process</span></span></code> </pre><br>  ,     ,   , ,      ,  . <br>      ,     -   Control Endpoint 0,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Device_Data_Setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RequestNo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USB_UNSUPPORT; } <span class="hljs-function"><span class="hljs-function">RESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Device_NoData_Setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RequestNo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USB_UNSUPPORT; }</code> </pre><br>      , ,    ,  ,     .       -   ,    . <br>   ,  ,     .       ,  <b>USB_UNSUPPORT</b>       . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Device_Get_Interface_Setting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Interface, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AlternateSetting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AlternateSetting &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USB_UNSUPPORT; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Interface &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USB_UNSUPPORT; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> USB_SUCCESS; }</code> </pre><br>               STM ,    : <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *Device_GetDeviceDescriptor(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Standard_GetDescriptorData(Length, &amp;Device_Descriptor); } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *Device_GetConfigDescriptor(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Standard_GetDescriptorData(Length, &amp;Config_Descriptor); } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *Device_GetStringDescriptor(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Length) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> wValue0 = pInformation-&gt;USBwValue0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wValue0 &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Standard_GetDescriptorData(Length, &amp;String_Descriptor[wValue0]); } }</code> </pre><br></div></div><br>   ,    : <br><br><pre> <code class="cpp hljs">DEVICE_PROP Device_Property = { Device_init, Device_Reset, Device_Status_In, Device_Status_Out, Device_Data_Setup, Device_NoData_Setup, Device_Get_Interface_Setting, Device_GetDeviceDescriptor, Device_GetConfigDescriptor, Device_GetStringDescriptor, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span> <span class="hljs-comment"><span class="hljs-comment">/*MAX PACKET SIZE*/</span></span> };</code> </pre><br></li><li>     , <b>User_Standard_Requests</b> . <br>    ‚Äî ..    HID   - ,        ,        <b>NOP_Process</b> .     ,    <b>User_SetDeviceAddress</b>     ‚Äì           ,    . <br><br><div class="spoiler"> <b class="spoiler_title"> User_Standard_Requests</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_GetConfiguration NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_SetConfiguration NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_GetInterface NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_SetInterface NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_GetStatus NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_ClearFeature NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_SetEndPointFeature NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_SetDeviceFeature NOP_Process #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Device_SetDeviceAddress NOP_Process USER_STANDARD_REQUESTS User_Standard_Requests = { Device_GetConfiguration, Device_SetConfiguration, Device_GetInterface, Device_SetInterface, Device_GetStatus, Device_ClearFeature, Device_SetEndPointFeature, Device_SetDeviceFeature, Device_SetDeviceAddress };</span></span></code> </pre><br></div></div><br></li><li>     ,  : <br><pre> <code class="cpp hljs">__IO <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> wIstr; DEVICE Device_Table = { EP_NUM, <span class="hljs-number"><span class="hljs-number">1</span></span> };</code> </pre><br>       ,       ( )    . <br></li><li>      ‚Äì    ,      : <br><br><div class="spoiler"> <b class="spoiler_title">void USB_Interrupts_Config(void)  void Set_USBClock()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USB_Interrupts_Config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">1</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">1</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN1_TX_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">1</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set_USBClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Select USBCLK source */</span></span> RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5); <span class="hljs-comment"><span class="hljs-comment">/* Enable the USB clock */</span></span> RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE); }</code> </pre><br></div></div><br>     . <br> Low-Priority     ( ,   ),       . <br>       Isochronous  Bulk    ,      (   ).        ,    . <br>       USB  1.5   (48 )     USB. <br></li><li>        ,           ,          . <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USB_HP_CAN1_TX_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CTR_HP(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USB_LP_CAN1_RX0_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ wIstr = _GetISTR(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IMR_MSK &amp; ISTR_CTR) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (wIstr &amp; ISTR_CTR &amp; wInterrupt_Mask) { CTR_LP(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IMR_MSK &amp; ISTR_RESET) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (wIstr &amp; ISTR_RESET &amp; wInterrupt_Mask) { _SetISTR((uint16_t)CLR_RESET); Device_Property.Reset(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br></div></div><br> ,       ‚Äì    USB  ,     USB     LCD,      .         ,     Bulk Endpoint 1 ,     . <br></li><li>    ‚Äì     , <b>NOT_ADDRESSED</b>  <b>TRANSFER_IN_PROGRESS</b> .    ,       8    ,     X  Y ( 16- )    ,   ,    .              (   )     ,     ,    . , ,  ,    -      ,              .   ,           .           ,         . <br> ,      ‚Äì     ,   <b>PMAToUserBufferCopy</b> ,           .            ,      - ? <br>    <b>PMAToUserBufferCopy</b>  ,   <b>PMAToLCDBufferCopy</b> ,                 : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PMAToLCDBufferCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wPMABufAddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset ,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wNBytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> n = (wNBytes + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *pdwVal; pdwVal = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)(wPMABufAddr * <span class="hljs-number"><span class="hljs-number">2</span></span> + PMAAddr+offset); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = n; i != <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) LCD_WRITE_RAM(*pdwVal++); }</code> </pre><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EP1_OUT_Callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> dataLen = GetEPRxCount(EP1_OUT &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GraphicsState==NOT_ADDRESSED) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dataLen&lt;=<span class="hljs-number"><span class="hljs-number">8</span></span>) { SetEPRxStatus(ENDP1, EP_RX_VALID); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } PMAToUserBufferCopy(buffer, GetEPRxAddr(EP1_OUT &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> horz = *((<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>*)(buffer)); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> vert = *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>*)(buffer+<span class="hljs-number"><span class="hljs-number">2</span></span>); dataTotal = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(buffer+<span class="hljs-number"><span class="hljs-number">4</span></span>); LCD_WRITE_REGISTER(CTR_HORZ_ADDRESS,vert); <span class="hljs-comment"><span class="hljs-comment">//  LCD_WRITE_REGISTER(CTR_VERT_ADDRESS,horz); offset=16; dataTransfered=0x00; GraphicsState=TRANSFER_IN_PROGRESS; dataLen-=8; } LCD_BEGIN_RAM_WRITE; PMAToLCDBufferCopy(GetEPRxAddr(EP1_OUT &amp; 0x7F), offset, dataLen); dataTransfered+=(dataLen)&gt;&gt;1; if(dataTransfered&gt;=dataTotal) GraphicsState=NOT_ADDRESSED; SetEPRxStatus(ENDP1, EP_RX_VALID); }</span></span></code> </pre><br><br> ,      ,   ,      (   )  <b>NOP_Process</b> : <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*pEpInt_IN[<span class="hljs-number"><span class="hljs-number">7</span></span>])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = { NOP_Process, NOP_Process, NOP_Process, NOP_Process, NOP_Process, NOP_Process, NOP_Process, }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*pEpInt_OUT[<span class="hljs-number"><span class="hljs-number">7</span></span>])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = { EP1_OUT_Callback, NOP_Process, NOP_Process, NOP_Process, NOP_Process, NOP_Process, NOP_Process, };</code> </pre><br></div></div><br></li></ol><br><h6>  Check </h6><br>       ‚Äì    . <br>    - windows (  -    ),     LibUSB. <br>        C#, LibUSB.Net,    <a href="http://sourceforge.net/projects/libusbdotnet/"></a> <br>      ‚Äì   ,   ,   ,    ,          . <br>  ,     .    ,      InfWizard.          inf-,        libusb. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run the bundled Test_bulk, select our device, click Open, and enter more than 8 characters in the line. After we press "Write", they should come to our callback and be interpreted as a header and graphic data, and then appear on the display in the form of several colored dots. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this is not very impressive, so we open the source of this Test_Bulk itself, go to the Write button handler and, instead of sending data from the string, do the download from the binary file.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesToWrite = File.ReadAllBytes(<span class="hljs-string"><span class="hljs-string">"D:\\myfile.raw"</span></span>);</code> </pre><br>      ,   .     320240,    : <br><img src="http://habrastorage.org/storage2/997/324/08a/99732408a96cee7a90cf214f965f2323.jpg"><br>   ,  ,    BMP   ,     ,      .    16- RGB565. <br>   040  ()    - -,  ‚Äì  ,     .     USB- ‚Äì   (0000, 0000)      (320240) ‚Äî 002C0100 <br> ,     ,    Test_bulk,   ,  Write   <br><img src="http://habrastorage.org/storage2/3d1/98b/21b/3d198b21b6e58b05357ee74cc34b3d34.jpg"><br>     .   ,        ,       . ,          ,       ‚Äì         ,      - OpenWRT. <br>   ! </div><p>Source: <a href="https://habr.com/ru/post/163689/">https://habr.com/ru/post/163689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163679/index.html">Weak links in various programming languages</a></li>
<li><a href="../163681/index.html">Game Theory: An Introduction</a></li>
<li><a href="../163683/index.html">Designer developer Arduino named entrepreneur of the year in the US</a></li>
<li><a href="../163685/index.html">Christmas sale on Google Play! Discounts up to 86%!</a></li>
<li><a href="../163687/index.html">What else can you type?</a></li>
<li><a href="../163691/index.html">Bash scripting techniques. # 2</a></li>
<li><a href="../163693/index.html">EU is going to reform copyright</a></li>
<li><a href="../163695/index.html">"Do not tell me where to go" - your user</a></li>
<li><a href="../163699/index.html">The history of one mBaaS (cloud backend) service on the example of QuickBlox</a></li>
<li><a href="../163703/index.html">The story of one habraspor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>