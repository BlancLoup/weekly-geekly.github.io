<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing Code Action with Roslyn</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Roslyn Services API makes it easy to implement extensions that find and fix problems in the code right in Visual Studio. Roslyn Services API is availa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing Code Action with Roslyn</h1><div class="post__text post__text-html js-mediator-article">  Roslyn Services API makes it easy to implement extensions that find and fix problems in the code right in Visual Studio.  Roslyn Services API is available as part of <a href="http://www.microsoft.com/download/en/details.aspx%3Fid%3D27746">Roslyn CTP</a> . <br><br>  In this post, we will implement an extension for Visual Studio that detects calls to the Enumerable method of Count (), after which the result is checked for equality greater than zero, for example, someSequence.Count ()&gt; 0. The problem with the code is that Count () must go through the entire sequence before returning the result.  The more correct approach in this case is to call the Enumerable.Any () method. <br><br>  To fix this, we will implement CodeIssueProvider, which detects the problem, and CodeAction, which replaces the condition with the call to Enumerable.Any (), as required.  Those.  our CodeAction will change something like someSequence.Count ()&gt; 0 to someSequence.Any (). <br><a name="habracut"></a><br>  There are a couple more additional conditions that I would also like to perform: first of all, the expression can be reversed and written as 0 &lt;someSequence.Count ().  The following case is an entry of type&gt; = 1 instead of&gt; 0, which is logically the same as before.  We need the extension to work in both cases. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Obviously, we would not want to change not all calls with the Count () signature, but only if they refer to the extension method from IEnumerable defined in Enumerable. <br><br><h5>  Beginning of work </h5><br>  Roslyn CTP comes with a set of templates to make it easy to get started with your API.  To begin with, we will create a new project of the Code Issue type from Roslyn templates.  Let's name the project as ReplaceCountWithAny. <br><br><img src="https://habrastorage.org/storage2/ae4/9b7/d83/ae49b7d8358a37a7c26f22d4d732ab08.png"><br><br>  The template generates a simple working provider that highlights words containing the letter ‚Äúa‚Äù.  To see an example in action, build and run the project created by the template.  This launches a new instance of Visual Studio with the extension included.  From the Visual Studio just launched, create a console application and see it as the keywords namespace, class, etc.  underlined by our extension. <br><br><img src="https://habrastorage.org/storage2/0c4/7e7/aa6/0c47e7aa6bf128d9ca90e5b9b33393a8.png"><br><br>  Although the example is not as useful as an extension for Visual Studio, it prepares everything you need to start implementing your own extension.  We only have to replace the contents of the generated method GetIssue.  Note that there are three overloads for getIssues.  We will work with overload, where one of the parameters is of type CommonSyntaxNode.  The remaining two overloads can be left in our case. <br><br>  The generated CodeIssueProvider class implements the ICodeIssueProvider interface and is decorated with the ExportSyntaxNodeCodeIssueProvide attribute.  This allows Visual Studio to import this type as an extension containing the contract provided by the ICodeIssueProvide interface. <br><br><h5>  Implement GetIssues </h5><br>  Our GetIssues method will be called for each syntax, so the first thing we need to do is sift out nodes that are not interesting to us.  Since we need constructions of type someSequence.Count ()&gt; 0, we need only nodes of type BinaryExpressionSyntax.  We can tell Visual Studio to use our provider only for specific nodes, providing a list of types through the ExportSyntaxNodeCodeIssueProvide attribute.  So, update the attribute as shown below: <br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExportSyntaxNodeCodeIssueProvider(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ReplaceCountWithAny"</span></span></span><span class="hljs-meta">, LanguageNames.CSharp, typeof(BinaryExpressionSyntax))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CodeIssueProvider</span></span> : <span class="hljs-title"><span class="hljs-title">ICodeIssueProvider</span></span> ...</code> </pre> <br>  This allows you to safely cast the CommonSyntaxNode node to the BinaryExpressionSyntax type in the GetIssues method. <br><br>  To select the cases that we want to handle, it is necessary to check a part of the expression for the presence of a call to Enumerable.Count (), and another for the comparison itself.  We will allocate these checks to helper methods, so our implementation of GetIssues will look like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;CodeIssue&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIssues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, CommonSyntaxNode node, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> binaryExpression = (BinaryExpressionSyntax)node; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> left = binaryExpression.Left; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> right = binaryExpression.Right; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind = binaryExpression.Kind; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCallToEnumerableCount(document, left, cancellationToken) &amp;&amp; IsRelevantRightSideComparison(document, right, kind, cancellationToken) || IsCallToEnumerableCount(document, right, cancellationToken) &amp;&amp; IsRelevantLeftSideComparison(document, left, kind, cancellationToken)) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CodeIssue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeIssue.Severity.Info, binaryExpression.Span, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">.Format(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Change {0} to use Any() instead of Count() to avoid "</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"possible enumeration of entire sequence."</span></span></span></span><span class="hljs-function"><span class="hljs-params">, binaryExpression</span></span></span><span class="hljs-function">))</span></span>; } }</code> </pre> <br><br>  The instance of the CodeIssue class that we return indicates the level of the problem, which may be Error, Warning or Info, the description used to highlight a piece of code, and the text that describes the problem to the user. <br><br><h5>  Auxiliary methods </h5><br>  Now let's move our attention to the helper methods used in GetIssues.  The IsCallToEnumerableCount method returns true if the part of the expression we are considering is a call to the Count () method on some sequence.  Let me remind you once again: we start first with filtering unnecessary expressions. <br><br>  First of all, the expression must be a method call.  In this case, we get the necessary call from the property of the expression.  So, if the construction looks like someSequence.Count ()&gt; 0, then we will have a part with Count ();  but how to check it belongs to the type Enumerable? <br><br>  To answer such questions, you need to request a semantic model.  Fortunately, one of the parameters of the GetIssues method is an IDocument, which is a document in the project and solution.  We can get a semantic model through it, and already from it the SymbolInfo itself that we need. <br>  Using SymbolInfo, you can check if our method call belongs to the desired [Enumerable.Count ()].  Since Count () is an extension method, working with it will be slightly different.  Recall that C # allows extension methods to be invoked as part of a type.  The semantic model provides this information through the ConstructedFrom property of the MethodSymbol class with reference to the original type.  The ability to make it a little easier is there, so watch out for the API names. <br><br>  All we have to do is specify the type of extension method.  If it matches Enumerable, then we have found the call to Enumerable.Count (). <br><br>  The implementation looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCallToEnumerableCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, ExpressionSyntax expression, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invocation = expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> InvocationExpressionSyntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (invocation == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> call = invocation.Expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberAccessExpressionSyntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (call == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = document.GetSemanticModel(cancellationToken); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodSymbol = semanticModel.GetSemanticInfo(call, cancellationToken).Symbol <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MethodSymbol; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodSymbol == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || methodSymbol.Name != <span class="hljs-string"><span class="hljs-string">"Count"</span></span> || methodSymbol.ConstructedFrom == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumerable = semanticModel.Compilation.GetTypeByMetadataName( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Enumerable).FullName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enumerable == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !methodSymbol.ConstructedFrom.ContainingType.Equals(enumerable)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Before moving forward, it is also necessary to check the expression for correctness of the comparison in another part of the binary expression;  and this is the work for the helper methods IsRelevantRightSideComparison and IsRelevantLeftSideComparison. <br><br>  Below are their implementations: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsRelevantRightSideComparison</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, ExpressionSyntax expression, SyntaxKind kind, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticInfo = document.GetSemanticModel(cancellationToken). GetSemanticInfo(expression); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!semanticInfo.IsCompileTimeConstant || (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = semanticInfo.ConstantValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>?) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kind == SyntaxKind.GreaterThanExpression &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> || kind == SyntaxKind.GreaterThanOrEqualExpression &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsRelevantLeftSideComparison</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, ExpressionSyntax expression, SyntaxKind kind, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticInfo = document.GetSemanticModel(cancellationToken). GetSemanticInfo(expression); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!semanticInfo.IsCompileTimeConstant || (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = semanticInfo.ConstantValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>?) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kind == SyntaxKind.LessThanExpression &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> || kind == SyntaxKind.LessThanOrEqualExpression &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Yes, they are almost identical with the only difference that both comparison options are checked, as well as the correctness of the value itself, so we don‚Äôt have to highlight something like Count ()&gt; = 0. <br><br><h5>  Testing CodeIssueProvider </h5><br>  At the moment, our provider is able to detect problems of interest to us.  Compile and run the project along with a new instance of Visual Studio along with the extension included.  Add code and note that calls to Enumerable.Count () are underlined correctly, while calls to other methods with a signature of Count () are not. <br><br><img src="https://habrastorage.org/storage2/d2e/1e9/589/d2e1e95893bae571742e6ece053889ac.png"><br><br>  The next step is to provide an action to solve the problem. <br><br><h5>  CodeAction </h5><br>  To implement the action, we need a class that implements the ICodeAction interface.  ICodeAction is a simple interface that defines the description and icon for the action, as well as the only GetEdit method that returns an edit that transforms the current syntax tree.  So let's start with the constructor of our CodeAction class. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CodeAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICodeActionEditFactory editFactory, IDocument document, BinaryExpressionSyntax binaryExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.editFactory = editFactory; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.document = document; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binaryExpression = binaryExpression; }</code> </pre><br>  For each problem found, a new copy of the CodeAction class will be created, so for convenience we will omit some parameters and change the constructor itself.  For this, an ICodeActionEditFactory implementation is needed to create the transformation of the newly created syntax tree.  Since the syntactic trees in the Roslyn project are immutable, returning a new tree is the only way to make any changes.  Fortunately, Roslyn tries to reuse the tree as much as possible, thus preventing the creation of unnecessary syntax nodes. <br><br>  In addition, a document is required that gives our code access to the syntax tree, project and solution, as well as a link to the syntax node that we want to replace. <br><br>  So, we are closer to the GetEdit method.  It is here that we create a transformation that will replace the detected binary expression with a new one with a call to the Any () method.  Creating a new node is assigned to a simple helper method GetNewNode.  The implementation of both methods is given below: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ICodeActionEdit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syntaxTree = (SyntaxTree)document.GetSyntaxTree(cancellationToken); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newExpression = GetNewNode(binaryExpression). WithLeadingTrivia(binaryExpression.GetLeadingTrivia()). WithTrailingTrivia(binaryExpression.GetTrailingTrivia()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newRoot = syntaxTree.Root.ReplaceNode(binaryExpression, newExpression); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> editFactory.CreateTreeTransformEdit( document.Project.Solution, syntaxTree, newRoot, cancellationToken: cancellationToken); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ExpressionSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNewNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryExpressionSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invocation = node.DescendentNodes(). OfType&lt;InvocationExpressionSyntax&gt;().Single(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caller = invocation.DescendentNodes(). OfType&lt;MemberAccessExpressionSyntax&gt;().Single(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invocation.Update( caller.Update(caller.Expression, caller.OperatorToken, Syntax.IdentifierName(<span class="hljs-string"><span class="hljs-string">"Any"</span></span>)), invocation.ArgumentList); }</code> </pre><br>  Roslyn syntax tree completely coincides with the original code, so each node in the tree can contain extra spaces and comments.  Those.  we keep the original node along with comments and the structure of the code when the nodes themselves change.  To do this, we call the WithLeadingTrivia and WithTrailingTrivia extension methods. <br><br>  Also note that the GetNewNode method saves the parameter list of the Count () method, so if the extension method was called via a lambda expression to count specific elements in the sequence, it will still be replaced by Any (). <br><br><h5>  Let's sum up </h5><br>  To enable our action, update the GetIssues method in the CodeIssueProvider class to return a CodeAction instance for each CodeIssue.  Each problem area of ‚Äã‚Äãthe code can have several actions, allowing the user to choose between them.  In this case, we return one single action as shown below. <br><br>  The updated part of the GetIssues method looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CodeIssue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CodeIssue.Severity.Info, binaryExpression.Span, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">.Format(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Change {0} to use Any() instead of Count() to avoid "</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"possible enumeration of entire sequence."</span></span></span></span><span class="hljs-function"><span class="hljs-params">, binaryExpression</span></span></span><span class="hljs-function">), new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CodeAction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">editFactory, document, binaryExpression</span></span></span><span class="hljs-function">))</span></span>;</code> </pre><br>  Rebuild and run the project to launch a new instance of Visual Studio with the extension loaded.  Now we see that the problem section provides a drop-down list with options for correcting the code. <br><br><img src="https://habrastorage.org/storage2/af3/40f/5e8/af340f5e8df389158c530628a23c3d3e.png"><br><br>  Thus, we have implemented an extension for Visual Studio that will help improve our code. <br></div><p>Source: <a href="https://habr.com/ru/post/137937/">https://habr.com/ru/post/137937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137931/index.html">Freezing Eclipse 3.7 for Mac</a></li>
<li><a href="../137932/index.html">Failure of the master in the PostgreSQL-cluster: how to be?</a></li>
<li><a href="../137933/index.html">Organize your audio library. Practical advice</a></li>
<li><a href="../137935/index.html">Cellular operators will notify subscribers about changes to the tariff plan via SMS</a></li>
<li><a href="../137936/index.html">For Nginx appeared commercial technical support</a></li>
<li><a href="../137938/index.html">Creating a reliable storage distributed to multiple servers on nfs</a></li>
<li><a href="../137940/index.html">RIPE NCC Password Policy Update</a></li>
<li><a href="../137941/index.html">John Barlow conveys heartfelt greetings to the sopa copiers and supporters: lecture in Russia</a></li>
<li><a href="../137943/index.html">Content for the site: better in advance than never</a></li>
<li><a href="../137945/index.html">What are patents in Russia? Likbez, Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>