<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hello World's thorny path</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The inspiration for writing this article was obtained after reading a similar publication for the x86 architecture [1]. 


 This material will help th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hello World's thorny path</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>The inspiration for writing this article was obtained after reading a similar publication for the x86 architecture [1].</em> </p><br><p>  This material will help those who want to understand how the programs are arranged from the inside, what happens before the entrance to the main, and why all this is done.  I will also show how you can use some features of the glibc library.  And at the end, as in the original article [1], the traversed path will be visually presented.  Most of the article is a parsing of the glibc library. </p><br><p>  So let's start our trip.  We will use Linux x86-64, and lldb as a debugging tool.  Also, sometimes we will disassemble the program with objdump. </p><br><p>  The source text will be plain Hello, world ( <em>hello.cpp</em> ): </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Just in case, information about the system and programs</b> <div class="spoiler_text"><pre> <code class="hljs css">* <span class="hljs-selector-tag"><span class="hljs-selector-tag">Clang</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">lldb</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">glibc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.25</span></span> * `<span class="hljs-selector-tag"><span class="hljs-selector-tag">uname</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-r</span></span>` <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.12</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.10-1-ARCH</span></span></code> </pre> </div></div><br><p>  Compile the code and start debugging: </p><br><pre> <code class="bash hljs">clang++ -stdlib=libc++ hello1.cpp -g -o hello1.out lldb hello1.out</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text"><p>  Most of the code considered in the program is almost independent of the selected compiler and the c ++ library.  It just happened that the llvm infrastructure is a bit closer to me than gcc, so the clang compiler with the libc ++ library will be considered, but again, there isn‚Äôt much difference, because most of the code under consideration will be parsed from the glibc library. </p></div></div><br><p>  When <em>bash is</em> used (and not only), a program is created by calling the <em>fork</em> function and creating a new process using <em>execve</em> with passing command line arguments to it.  Also, before transferring control to the first instruction of the executable file, input and output descriptors (STDIN, STDOUT, STDERR) are set, then, in the case of dynamic linking, the necessary library program is loaded and initialized and the functions of the " <em>.preinit_array</em> " section are <em>called</em> .  Only after all this is the first function called, which is in the executable file (not counting the section " <em>.preinit_array</em> "), traditionally called <strong>_start</strong> , which is considered the beginning of the program.  In the case of static linking, the work of the linker, for example, the initialization of the " <em>.preinit_array</em> " section, is located inside the executable file and the functions themselves are slightly different from dynamically linked programs.  We will consider dynamically linked programs. </p><br><p>  Entry point of the executable file is indicated in its header: </p><br><pre> <code class="bash hljs">readelf -h hello1.out | grep Entry</code> </pre> <br><p>  Next, we check which function is located at this address using <code>objdump -d hello1.out</code> .  This is the already mentioned <strong>_start</strong> function, on which we set a breakpoint and start debugging. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">b</span></span> _start r</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">About ABI</b> <div class="spoiler_text"><p>  Wikipedia definition: <br>  ABI (aplication binary interface) is a set of agreements for application access to the operating system and other low-level services, designed for the portability of executable code between machines that have compatible ABIs.  Unlike API, which regulates compatibility at the source code level.  An ABI can be thought of as a set of rules that allow a linker to combine compiled component modules without recompiling all of the code, while defining a binary interface. </p><br><p>  The ABI level is hidden for <em>c</em> / <em>c ++ programmers</em> and all work of this level is implemented by the compiler and the standard <strong>libc</strong> library.  In my case, the <strong>clang</strong> compiler and the <strong>glibc</strong> library follow all ABI rules.  ABI rules for Linux x86-64 are listed in the <strong>System V AMD64 ABI</strong> document [2].  Solaris, Linux, FreeBSD, OS X follow the conventions of this document.  Microsoft has its own specific ABI, which they carefully hide.  The first chapter of this document [2] says that the architecture also obeys the ABI rules for 32-bit processors [3].  Therefore, these are the 2 fundamental documents on which developers of low-level libraries like <em>glibc</em> rely. </p></div></div><br><p>  According to ABI, at the start of the program all registers are not defined except for: </p><br><ul><li>  % rdx: A pointer to a function that must be called before the program ends. </li><li>  % rsp: The stack is aligned on a 16-byte boundary, contains the number of arguments, the arguments themselves, and the environment: <br>  0 (% rsp) argc <br>  8 (% rsp) argv [0] <br>  ... <br>  8 <em>argc (% rsp) NULL</em> <em><br></em>  <em>8</em> (argc + 1) (% rsp) envp [0] <br>  ... <br>  8 * (argc + k + 1) (% rsp) envp [k] <br>  Null <br>  auxiliary vectors <br>  ... <br>  Null <br>  Null <br></li></ul><br><p>  Auxiliary vectors (auxiliary vectors) contain information about the current machine.  You can see their values ‚Äã‚Äãusing <code>LD_SHOW_AUXV=1 ./hello1.out</code> .  The obtained values ‚Äã‚Äãare well described in [4]. </p><br><div class="spoiler">  <b class="spoiler_title">And actually</b> <div class="spoiler_text"><p>  <code>x `$rsp` -s8 -fu -c1</code> - the number of program arguments <br>  <code>p *(char**)($rsp+8)</code> is the name of the program.  Next on the stack are the program arguments, the zero separator, the environment arguments, and the auxiliary vectors. </p></div></div><br><p>  In addition, flag registers are set, SSE and x87 are configured (¬ß3.4.1 [2]). </p><br><p>  You can see that the arguments are already almost prepared for the user-defined function <strong>main</strong> , all that remains is to set the correct pointers.  But in addition to setting up pointers, a lot of work needs to be done before entering the main procedure.  In the future, any function in its description will be accompanied by the location of its source code and the function itself in binary form in the form of a pop-up hint, for example: <abbr title="hello1.cpp; hello1.out">main</abbr> . </p><br><p>  Let's look at the <strong>_start</strong> function, it is small and its main task is to transfer control of the function <strong>__libc_start_main</strong> . </p><br><p>  Disassemble the current function with <code>di</code> (the output here and below is formatted for clarity): </p><br><pre> <code class="hljs perl">_start: <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> %ebp, %ebp mov %rdx, %r9 <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> %rsi mov %rsp, %rdx <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $-<span class="hljs-number"><span class="hljs-number">0x10</span></span>, %rsp <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> %rax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> %rsp lea <span class="hljs-number"><span class="hljs-number">0x1aa</span></span>(%rip), %r8 ; __libc_csu_fini lea <span class="hljs-number"><span class="hljs-number">0x133</span></span>(%rip), %rcx ; __libc_csu_init lea <span class="hljs-number"><span class="hljs-number">0xec</span></span>(%rip), %rdi ; main call *<span class="hljs-number"><span class="hljs-number">0x200796</span></span>(%rip) ; __libc_start_main hlt</code> </pre> <br><p>  The <abbr title="glibc library: sysdeps / x86-64 / start.S; Scrt1.o"><strong>_start</strong></abbr> function <abbr title="glibc library: sysdeps / x86-64 / start.S; Scrt1.o"><strong>is</strong></abbr> connected to our program by the linker as an object file <em>Scrt1.o</em> .  There are several types of object files crt1 (gcrt1, Srct1, Mcrt1) that perform similar functions, but are used in different cases.  For example, <em>Scrt1.o is</em> used when generating <a href="https://en.wikipedia.org/wiki/Position-independent_code">PIC</a> code [5].  You can verify the choice of the object file by compiling the program with the " <code>-v</code> " key.  Note that in the object file, the object offsets <em>__libc_csu_fini</em> , <em>__libc_csu_init</em> and <em>main</em> are not specified, since the offsets of these functions become known only at the linking stage. </p><br><p>  According to the requirements of the ABI, you need to zero <strong><em>% ebp</em></strong> to mark the <abbr title="frame">frame</abbr> as the initial one, which is what the <strong><em>xor% ebp,% ebp</em></strong> instruction does. </p><br><p>  Next is preparing to call the function <strong>__libc_start_main</strong> , the signature of which is: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __libc_start_main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*main) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, __typeof (main) init, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*fini) (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*rtld_fini) (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *stack_end)</code> </pre> <br><p>  And the function arguments, according to the ABI, should be put in the appropriate places: </p><br><table><thead><tr><th>  Argument </th><th>  Position for function call </th><th>  Description </th></tr></thead><tbody><tr><td>  main </td><td>  % rdi </td><td>  The main function of the program </td></tr><tr><td>  argc </td><td>  % rsi </td><td>  Number of program arguments </td></tr><tr><td>  argv </td><td>  % rdx </td><td>  Array of arguments.  After the arguments are the environment variables, and after the auxiliary vectors </td></tr><tr><td>  init </td><td>  % rcx </td><td>  The global object constructor, invoked before main.  The type of this function is the same as the main function. </td></tr><tr><td>  fini </td><td>  % r8 </td><td>  Global object destructor called after main </td></tr><tr><td>  rtld_fini </td><td>  % r9 </td><td>  Dynamic linker destructor.  Frees dynamically allocated libraries </td></tr><tr><td>  stack_end </td><td>  % rsp </td><td>  The current position of the aligned stack </td></tr></tbody></table><br><p>  ABI requires that when calling a function, the stack is aligned on a 16-byte (sometimes 32, and sometimes 64, depending on the type of arguments) boundary.  The request is fulfilled after the execution of the instruction <strong><em>and $ -0x10,% rsp</em></strong> <abbr title="The stack is initially properly aligned (ABI requirement), the instruction is most likely needed for precaution">(?)</abbr> .  The meaning of this alignment is that SIMD instructions (SSE, MMX) work only with aligned data, and scalar instructions read / write <a href="https://stackoverflow.com/a/12491718/3315622">faster</a> with aligned data. </p><br><p>  To save 16-byte alignment, before calling <strong>__libc_start_main</strong> , the% rax register is placed on the stack, which holds an undefined value.  This stack cell will never be read. </p><br><p>  The program should not be returned from the <strong>libc_start_main</strong> function, and the <strong>hlt</strong> instruction is used to indicate the wrong behavior.  The peculiarity of this instruction is that in the protected mode of the processor it can be executed only in the protection ring 0, that is, only the operating system can call it.  We are in the 3rd ring, which means that when we try to execute a command to which the program has no rights, we get the segmentation fault. <br>  After the <strong>hlt</strong> instruction there is also the instruction <strong>nopl 0x0 (% rax,% rax, 1)</strong> , which in turn is needed to align the next function with the 16-byte boundary.  ABI does not require this, but compilers align the beginning of a function to improve performance ( <a href="https://stackoverflow.com/a/4909633/3315622">1</a> , <a href="https://stackoverflow.com/a/7912617/3315622">2</a> ). </p><br><p>  So, go ahead </p><br><pre> <code class="hljs swift">b __libc_start_main <span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><p>  From the source code of the <abbr title="glibc: csu / libc_start.c; libc.so"><strong>__libc_start_main</strong></abbr> function, <abbr title="glibc: csu / libc_start.c; libc.so"><strong>you</strong></abbr> can see that for statically and dynamically linked libraries different code is generated.  You can check how the function code in <abbr title="Disassembling libc.so.6 due to the fact that the file libc.so (in my case) is a regular script for ld"><em>libc.so.6</em></abbr> looks like with <a href="https://stackoverflow.com/a/22775364/3315622">gdb</a> or with lldb: <br> <code>lldb libc.so.6 -b -o 'di -n __libc_start_main'</code> </p> <br><div class="spoiler">  <b class="spoiler_title">A bit about __glibc_ [un] likely</b> <div class="spoiler_text"><p>  The <em>glibc</em> library code contains many entries __glibc_likely and __glibc_unlikely.  A large number of conditional operations are replaced by this macro.  The macro is eventually converted to the following build-in functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __glibc_unlikely(cond) __builtin_expect ((cond), 0) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __glibc_likely(cond) __builtin_expect ((cond), 1)</span></span></code> </pre> <br><p>  __builtin_expect is a kind of optimization that helps the compiler correctly locate parts of code in memory.  We tell the compiler which branch is most likely to be executed, and the compiler places this area of ‚Äã‚Äãmemory right after the comparison instruction, thereby, improving the instruction caching, and the compiler hides the remaining branch, if any, at the end of the function. </p></div></div><br><p>  The <strong>__libc_start_main</strong> function <strong>is a</strong> bit cumbersome, just briefly describing its main actions: </p><br><ul><li>  register <strong>rtld_fini</strong> with <strong>__cxa_atexit</strong> </li><li>  call <strong>__libc_csu_init</strong> </li><li>  create <em>cancellation point</em> </li><li>  <strong>main</strong> </li><li>  <strong>exit</strong> </li></ul><br><h3 id="__cxa_atexit">  __cxa_atexit </h3><br><p>  The <abbr title="glibc: stdlib / cxa_atexit.c; libc.so"><strong>__cxa_atexit</strong></abbr> function, in contrast to <strong>atexit</strong> , which is a wrapper over the first, can accept the parameters of the registered function, but the function should not be <a href="https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/baselib---cxa-atexit.html">called</a> directly from user space.  It should not be called because the function uses a <abbr title="Dynamic Shared Object">DSO-</abbr> identifier that is known only to the compiler.  It is needed so that when calling <strong>__cxa_atexit (f, p, d)</strong> , the function <strong>f (p) is</strong> called when DSO <strong>d is</strong> unloaded [8]. </p><br><div class="spoiler">  <b class="spoiler_title">However, passing arguments to the function parameter</b> <div class="spoiler_text"><p>  An example of using <strong>__cxa_atexit</strong> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; extern "C" int __cxa_atexit (void (*func) (void *), void *arg, void *d); extern void* __dso_handle; void printArg(void *a) { int arg = *static_cast&lt;int*&gt;(a); printf("%d\n",arg); delete (int*)a; } int main() { int *k = new int(17); __cxa_atexit(printArg, k, __dso_handle); }</span></span></span></span></code> </pre> <br><p>  I recommend using this trick only for use.  To call the destructor when exiting the program, it is safer to use any similar <a href="https://stackoverflow.com/a/8053261/3315622">method</a> . </p></div></div><br><p>  <strong>rtld_fini</strong> is a pointer to the <abbr title="glibc: elf / dl-fini.c; ld-linux-x86-64.so.2"><strong>_dl_fini</strong></abbr> linker <abbr title="glibc: elf / dl-fini.c; ld-linux-x86-64.so.2"><strong>function</strong></abbr> .  And yes, the linker is part of the <em>glibc</em> library.  The <strong>_dl_fini</strong> function <strong>deals</strong> with the deinitialization and unloading of all loaded libraries. </p><br><h3 id="__libc_csu_init">  __libc_csu_init </h3><br><p>  You can get into the <abbr title="glibc: csu / elf-init.c; libc_nonshared.a"><strong>__libc_csu_init</strong></abbr> function in the same way as in the previous one.  <strong>__libc_csu_init</strong> calls <strong>_init</strong> and function pointers in the <strong>.init_array</strong> section. </p><br><h4 id="_init">  _init </h4><br><p>  The <strong>_init</strong> function <strong>is</strong> entirely in the <strong>.init</strong> section.  Its code is divided into 2 parts: the <abbr title="glibc: sysdeps / x86_64 / crti.S; crti.o">introduction</abbr> and the <abbr title="glibc: sysdeps / x86_64 / crtn.S; crtn.o">epilogue</abbr> .  The introduction consists of a prologue and an attempt to call the function <strong>__gmon_start__</strong> . </p><br><pre> <code class="hljs perl">_init subq $0x8, %rsp leaq <span class="hljs-number"><span class="hljs-number">0x105</span></span>(%rip), %rax ; __gmon_start_<span class="hljs-number"><span class="hljs-number">_</span></span> testq %rax, %rax je <span class="hljs-number"><span class="hljs-number">0x5555555548a2</span></span> ; je to addq instruction callq *%rax addq $0x8, %rsp retq</code> </pre> <br><p>  The main function of the <strong>_init</strong> function is to initialize the <em>gprof</em> profiler.  The instruction " <code>leaq 0x105(%rip), %rax</code> " takes the address of the function <strong>__gmon_start__</strong> - the function that initializes the profiler.  If the profiler is not present, then the% rax will have the value 0 and the transition <em>je</em> will work.  The instructions <em>subq $ 0x8,% rsp</em> and <em>addq $ 0x8,% rsp</em> align the stack and return it to its original state.  This alignment is necessary due to the fact that when calling a function, we put a return address on the stack, the size of which on the x86-64 architecture is 8 bytes. </p><br><p>  You can add your own code section to the <strong>.init</strong> section.  Consider the <em>hello2.cpp</em> example: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; extern "C" void my_init() { puts("Hello from init"); } __asm__( ".section .init\n" "call my_init" ); int main(){}</span></span></span></span></code> </pre> <br><p>  Consider now what <strong>_init</strong> looks <strong>like</strong> : </p><br><pre> <code class="hljs perl">subq $0x8, %rsp movq <span class="hljs-number"><span class="hljs-number">0x200835</span></span>(%rip), %rax testq %rax, %rax je <span class="hljs-number"><span class="hljs-number">0x5555555547ba</span></span> callq *%rax callq <span class="hljs-number"><span class="hljs-number">0x555555554990</span></span> ; ::my_init() addq $0x8, %rsp retq</code> </pre> <br><p>  As you can see from the listing, between the introduction and the epilogue of the function was added the instruction <code>callq 0x555555554990</code> , which just makes the call to <strong>my_init</strong> .  Apparently the <strong>_init</strong> function and implemented in such a way that you can easily add your own initialization of some parts of the program. </p><br><p>  <strong>Interesting fact</strong> : The attentive reader must have noticed that the output in hello2.cpp is output via the puts function.  If output via <code>cout</code> , then when compiling with the <em>libstdc ++ library there</em> will be a segmentation error, and with the help of the <em>libc ++ library the</em> message will be output normally.  What makes this happen?  The fact is that in <em>libstdc ++</em> <code>cout</code> initialized as a regular global object, and the initialization of global objects occurs a little later.  In the case of <em>libc ++</em> , initialization occurs during the loading of libraries in the <strong>_dl_init</strong> functions from the <em>ld-linux-x86-64.so.2 library</em> .  This function is just called from <strong>_dl_start_user</strong> right before passing control to the <strong>_start</strong> function. </p><br><p>  The advantages and disadvantages of each method.  When the <em>libc ++</em> library is connected, even if standard c ++ output tools like <code>cout</code> will not be used, the constructors will be invoked anyway.  In the case of the <em>libstdc ++ library</em> , even with the optimization flags enabled, the constructor will be called as many times as the <em>iostream</em> header file is <em>included</em> .  Naturally, the constructor itself takes into account the fact that it can be called several times and re-initialization is skipped.  This, of course, does not slow down the initialization of the program, but it is still unpleasant.  Apparently for this reason, many high-performance projects do not use, do not recommend and even <a href="https://llvm.org/docs/CodingStandards.html">prohibit</a> connecting the <em>iostream</em> header file and, as a result, create their own interfaces for I / O. </p><br><h4 id="init_array">  .init_array </h4><br><p>  Then functions are called whose pointers are located in the <em>.init_array</em> section. <br>  Check the contents of the section: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">objdump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-j</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.init_array</span></span></code> </pre> <br><p>  In my case, the contents of <em>.init_array</em> have the following meaning: <code>a00f0000 00000000</code> , which means the address <strong>0x0fa0</strong> in a 64-bit system with little-endian <a href="https://en.wikipedia.org/wiki/Endianness">byte order</a> .  At this address is the <strong>frame_dummy</strong> function. </p><br><h5 id="frame_dummy">  frame_dummy </h5><br><p>  Interestingly, <abbr title="gcc: libgcc / crtstuff.c; crtbeginS.o"><strong>frame_dummy</strong></abbr> is part of the gcc library. </p><br><div class="spoiler">  <b class="spoiler_title">What does it have to do with gcc?</b>  <b class="spoiler_title">We have a clang compiler!</b> <div class="spoiler_text"><p>  Do not forget that the gcc project is very large and has already sprouted roots in linux operating systems.  The gcc project contains not only the compiler, but also the files needed for compilation.  Thus, when linking, crt-files like <em>crtbeginS.o</em> and <em>crtendS.o are used</em> . <br>  Therefore, it will not be possible to <u>completely</u> get rid of the gcc project, and at least it will be necessary to <a href="http://www.omniprog.info/clang_no_gcc.html">leave</a> auxiliary crt files.  Unix operating systems that do not use the <em>gcc</em> compiler as the main one do. </p></div></div><br><p>  <strong>frame_dummy</strong> looks like this: </p><br><pre> <code class="hljs perl">pushq %rbp movq %rsp, %rbp popq %rbp jmp <span class="hljs-number"><span class="hljs-number">0x555555554cc0</span></span> ; register_tm_clones nopw (%rax,%rax)</code> </pre> <br><p>  The <strong>frame_dummy</strong> task is to set the arguments and start the <strong>register_tm_clones</strong> function.  This layer is needed only to put arguments.  In this case, the arguments are not set, but as can be seen from the source code, this is not always the case, depending on the architecture.  Interestingly, the first 2 instructions are the prologue, the third - the epilogue.  The <em>jmp</em> instruction is a tail function call optimization.  And as usual, at the end of the alignment. </p><br><p>  The <abbr title="gcc: libgcc / crtstuff.c; crtbeginS.o"><strong>register_tm_clones</strong></abbr> function is needed in order to activate <a href="https://en.wikipedia.org/wiki/Transactional_memory">transactional</a> <a href="https://gcc.gnu.org/wiki/TransactionalMemory">memory</a> . </p><br><h5 id="inicializaciya-globalnyh-obektov">  Initializing Global Objects </h5><br><p>  Global objects, if present, are initialized here. <br>  If there are global objects, the address of the function <code>_GLOBAL__sub_I_&lt;  &gt;</code> added to the <em>.init_array</em> section. </p><br><p>  Consider an example of initializing global variables: <br>  <strong><em>global1.cpp</em></strong> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello from .init_array"</span></span>);</code> </pre> <br><p>  The variable will be initialized as follows: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">push</span></span> %rbp mov %rsp, %rbp lea <span class="hljs-number"><span class="hljs-number">0xf59</span></span>(%rip), %rdi ; + <span class="hljs-number"><span class="hljs-number">4</span></span> mov $0<span class="hljs-keyword"><span class="hljs-keyword">x</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>, %al call <span class="hljs-number"><span class="hljs-number">0x555555554e80</span></span> ; symbol stub <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> mov %eax, <span class="hljs-number"><span class="hljs-number">0x202130</span></span>(%rip) ; k <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> %rbp ret</code> </pre> <br><p>  The first 2 instructions are a prologue.  Next, we prepare for the call to the <strong>printf</strong> function, putting a pointer to our string in <code>%rdi</code> and setting <code>%al</code> to zero.  According to ABI [2], functions with a variable number of arguments contain a hidden parameter stored in <code>%al</code> , meaning the number of variable arguments contained in the vector registers.  Most likely this is needed to optimize some functions, but <strong>printf</strong> uses this information to move data from vector registers onto the stack. <br>  After calling <strong>printf</strong> , the result of the function is placed in the memory area of ‚Äã‚Äãthe variable <strong>k</strong> and the epilog is called. </p><br><p>  <strong><em>global2.cpp</em></strong> : <br>  Suppose we have a <code>Global</code> class with a non-default constructor and destructor: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> g;</code> </pre> <br><p>  Then the initialization will look like this: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">push</span></span> %rbp mov %rsp, %rbp <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> $0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function">, %</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lea</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x202175</span></span></span><span class="hljs-function">(%</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rip</span></span></span><span class="hljs-function">), %</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rdi</span></span></span><span class="hljs-function"> </span></span>; g call <span class="hljs-number"><span class="hljs-number">0x5555555550e0</span></span> ; Global::Global() lea <span class="hljs-number"><span class="hljs-number">0x1c5</span></span>(%rip), %rdi ; Global::~Global() lea <span class="hljs-number"><span class="hljs-number">0x202162</span></span>(%rip), %rsi ; g lea <span class="hljs-number"><span class="hljs-number">0x202147</span></span>(%rip), %rdx ; __dso_handle call <span class="hljs-number"><span class="hljs-number">0x555555554f10</span></span> ; symbol stub <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: __cxa_atexit mov %eax, -<span class="hljs-number"><span class="hljs-number">0x4</span></span>(%rbp) add $0x1<span class="hljs-number"><span class="hljs-number">0</span></span>, %rsp <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> %rbp ret</code> </pre> <br><p>  Here we see how, after calling the global constructor, the destructor is registered with <strong>__cxa_atexit</strong> .  This is implemented according to Itanium ABI [8]. </p><br><h5 id="inicializiruyuschiy-vyzov-funkciy">  Initializing function call </h5><br><p>  From glibc, initialization is called as follows: <code>(*__init_array_start [i]) (argc, argv, envp);</code> </p><br><p>  Notice that the initialization function passes parameters similar to the main function, so we can use them.  In the gcc and clang compilers, there is an attribute <code>constructor</code> , with which the function is called before the object initialization stage. </p><br><p>  In it we also can transfer these arguments.  Check the output of the program using the following global function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__((constructor)) hello(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **env) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"#args = %d\n"</span></span>, argc); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"filename = %s\n"</span></span>, argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  This can be used for more practical purposes (hello3.cpp): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; class C { public: C(int i) { printf("Program has %d argument(s)\n", i); } }; int constructorArg; const C c(constructorArg); void __attribute__((constructor (65535))) hello(int argc, char ** argv, char **env){ constructorArg = argc; } int main(){}</span></span></span></span></code> </pre> <br><p>  The <a href="https://gcc.gnu.org/onlinedocs/gcc-7.2.0/gcc/Common-Function-Attributes.html">priority of the</a> call is specified in the parameters of the <code>constructor</code> attribute. </p><br><p>  As you probably already guessed, the program will display the correct number of arguments, and most interestingly, the object <code>c</code> is constant.  The main disadvantage of this approach is the lack of support for the standard and, as a result, the lack of cross-platform.  Also, such code is highly dependent on the <em>libc</em> library used. </p><br><p>  I would like to add that global variables of the form <code>int x = 1 + 2 * 3;</code>  they are not initialized at all, their values ‚Äã‚Äãare initially written by the compiler into the memory.  If you want the variables initialized by simple functions like <code>int s = sum(4, 5)</code> to be initially initialized, add the identifier <em>constexpr</em> from the C ++ 11 standard to the <code>sum</code> function. </p><br><h3 id="sozdanie-cancellation-point">  Create a <em>cancellation point</em> </h3><br><p>  The cancellation point is created by calling <abbr title="glibc: sysdeps / x86_64 / setjmp.S; libc.so"><strong>setjmp</strong></abbr> and setting a global variable. <br>  Saving the <strong>setjmp</strong> context is needed to set <abbr title="cancellation buffer">the undo buffer</abbr> so that when <a href="https://linux.die.net/man/3/pthread_cancel">the</a> main thread is <a href="https://linux.die.net/man/3/pthread_cancel">canceled</a> , it can be correctly terminated. </p><br><div class="spoiler">  <b class="spoiler_title">Example of canceling the main thread</b> <div class="spoiler_text"><p>  File <em>cancel.cpp</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; pthread_t g_thr = pthread_self(); void * thread_start(void *) { pthread_cancel(g_thr); return 0; } int main() { pthread_t thr; pthread_create(&amp;thr, NULL, thread_start, NULL); pthread_detach(thr); while (1) { pthread_testcancel(); } }</span></span></span></span></code> </pre> <br><p>   <em>cancel.cpp</em> ,         , ,     <strong>exit</strong> . ,            ,    ,            ,      . </p><br><p>  ,    ,        <strong>setjmp</strong> : </p><br><pre> <code class="hljs swift">br <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> -n __libc_start_main -<span class="hljs-type"><span class="hljs-type">R</span></span> <span class="hljs-number"><span class="hljs-number">162</span></span></code> </pre> <br><p>   :     ,  ‚Äî    . </p></div></div><br><p>   <strong>setjmp</strong>    <strong>__GI__setjmp</strong> .             ,   .                 [7].     ,    ,      <abbr title="Procedure Linkage Table"><em>PLT</em></abbr> . </p><br><h3 id="main">  main </h3><br><p>       . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>     , : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>);</code> </pre> <br><p>  or </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>);</code> </pre> <br><p>   <em>C++</em>  <code>&lt;&lt;</code>    .    ,   ,   ,    ,      .    <a href="https://stackoverflow.com/a/4421729/3315622"></a> ,   . </p><br><p> <code>endl</code>     libc++,    libstdc++   : <code>ostream&amp; endl(ostream&amp;);</code> </p><br><p>   <code>ostream</code> ,       <code>&lt;&lt;</code>  ,    <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor</a> . </p><br><p>       .       IFUNC-,           <abbr title="glibc: sysdeps/x86_64/multiarch/strlen-avx2.S; libc.so"><strong>__strlen_avx2</strong></abbr>  <abbr title="glibc: sysdeps/x86_64/strlen.S; libc.so"><strong>_strlen_sse2</strong></abbr> .       <abbr title="glibc: string/strlen.c; libc.so"><strong>strlen</strong></abbr>    . </p><br><p>      <abbr title="stdout   libio/stdio.c,    libio/stdfiles.c; libc.so"><em>stdout</em></abbr>        <abbr title="glibc: libio/filedoalloc.c; libc.so"><strong>_IO_file_doallocate</strong></abbr>   <strong>malloc</strong> ,        1 .      <a href="https://stackoverflow.com/a/13933741/3315622"> </a> ,     <a href="http://en.cppreference.com/w/cpp/io/c/setvbuf"><strong>setvbuf</strong></a> . </p><br><p>       <em>stdout</em> ,       .            <code>flush</code> ,     <code>stdout</code>     . </p><br><p>       ,    <code>flush</code> ,    <abbr title="glibc: libio/iofwrite.c; libc.so"><strong>fwrite</strong></abbr> ,   <abbr title="glibc: sysdeps/unix/sysv/linux/write.c; libc.so"><strong>__libc_write</strong></abbr> ,   <em>syscall</em>   ( ,   ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> __libc_write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nbytes) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ({ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultvar = ({ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultvar; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __arg3 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (nbytes); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __arg2 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (buf); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __arg1 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (fd); <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a3 <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">"rdx"</span></span>) = __arg3; <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a2 <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">"rsi"</span></span>) = __arg2; <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a1 <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">"rdi"</span></span>) = __arg1; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> ( <span class="hljs-string"><span class="hljs-string">"syscall\n\t"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (resultvar) : <span class="hljs-string"><span class="hljs-string">"0"</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) , <span class="hljs-string"><span class="hljs-string">"r"</span></span> (_a1), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (_a2), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (_a3) : <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"cc"</span></span>, <span class="hljs-string"><span class="hljs-string">"r11"</span></span>, <span class="hljs-string"><span class="hljs-string">"cx"</span></span>); (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) resultvar; }); resultvar; }); }</code> </pre> <br><p>     <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">statement expressions</a> ,    gcc: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">int</span></span> l = ({<span class="hljs-attribute"><span class="hljs-attribute">int</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> c = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">c</span></span> += b});</code> </pre> <br><p>        ,   <code>c += b</code>     <code>l == 12</code> . </p><br><p>  <strong>__libc_write</strong> (     <strong>__GI___libc_write</strong>    ,   <strong>_setjmp</strong> )         <a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">syscall</a> ,    <em>syscall</em> ,  <a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html"></a>  C  .       <code>rax</code> .            <code>=a</code> ,       <em>rax</em> ,  <code>"0" (1)</code>    ,       <code>rax</code>   1 ( <em>sys_write</em> ). </p><br><p>    ,       ,    <em>sys_write</em>    ,      . </p><br><p>     ,  ABI [2],      .            : %rdi, %rsi, %rdx, %r10, %r8, %r9. </p><br><p>   <a href="http://syscalls.kernelgrok.com/">x86</a>  <a href="http://www.cs.utexas.edu/~bismith/test/syscalls/syscalls64_orig.html">x86-64</a>    <a href="https://unix.stackexchange.com/questions/338650/why-are-linux-system-call-numbers-in-x86-and-x86-64-different"></a> ! </p><br><p>  ,    ,      -         ,      ,    .         PIC ( <a href="https://habrahabr.ru/company/badoo/blog/323904/">1</a> , <a href="https://habrahabr.ru/company/badoo/blog/324616/">2</a> ). </p><br><h3 id="exit">  exit </h3><br><p>  <abbr title="glibc: stdlib/exit.c; libc.so"><strong>exit</strong></abbr>    : </p><br><ol><li> <abbr title="glibc: libio/iofwrite.c; libc.so"><strong>__call_tls_dtors</strong></abbr> ‚Äî   thread local storage ,        . </li><li>  ,    <strong>atexit</strong> <br><ul><li> <strong>_dl_fini</strong> ‚Äî   ,    <code>_start</code>   <code>r9</code> ,       . </li><li>    (    ). </li></ul></li><li>    <em>__libc_atexit</em> <br><ul><li> <abbr title="glibc: libio/genops.c; libc.so"><strong>_IO_cleanup</strong></abbr> ‚Äî      . </li></ul></li><li> <abbr title="glibc: sysdeps/unix/sysv/linux/_exit.c; libc.so"><strong>_exit</strong></abbr> ‚Äî     . </li></ol><br><p>  <strong>_exit</strong>    231 ( <em>sys_exit_group</em> ),           <em>%rdi</em> .       . </p><br><p>  Linux     <em>sys_exit</em> .      ,      ,     <em>sys_exit_group</em>     .    ,    ,     ,      <em>sys_exit</em>          ,       [6]. </p><br><p>     ,     ,      "Hello, World!!!",    C/C++,   <em>glibc</em> .       :  ,   ,   setjmp, atexit... </p><br><p>        ,    <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">dot</a> </p><br><p><img src="https://habrastorage.org/webt/59/db/8c/59db8c0827b45124461456.png"></p><br><p> [1] ‚Äî <a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a> <br> [2] ‚Äî <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-r252.pdf">https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-r252.pdf</a> <br> [3] ‚Äî <a href="https://github.com/hjl-tools/x86-psABI/wiki/intel386-psABI-1.1.pdf">https://github.com/hjl-tools/x86-psABI/wiki/intel386-psABI-1.1.pdf</a> <br> [4] ‚Äî <a href="https://habrahabr.ru/post/128111/">https://habrahabr.ru/post/128111/</a> <br> [5] ‚Äî <a href="https://dev.gentoo.org/~vapier/crt.txt">https://dev.gentoo.org/~vapier/crt.txt</a> <br> [6] ‚Äî <a href="http://syprog.blogspot.ru/2012/03/linux-threads-through-magnifier-local.html">http://syprog.blogspot.ru/2012/03/linux-threads-through-magnifier-local.html</a> <br> [7] ‚Äî <a href="https://sourceware.org/glibc/wiki/Style_and_Conventions">https://sourceware.org/glibc/wiki/Style_and_Conventions#Double-underscore_names_for_public_API_functions</a> <br> [8] ‚Äî <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">https://itanium-cxx-abi.github.io/cxx-abi/abi.html#dso-dtor</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339698/">https://habr.com/ru/post/339698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339688/index.html">Developer Tacts</a></li>
<li><a href="../339690/index.html">Cocos2d-x - Working with sprites</a></li>
<li><a href="../339692/index.html">How to successfully implement the Help Desk? 12 examples (part 2)</a></li>
<li><a href="../339694/index.html">New 3CX Call Flow Designer: Complicated Call Routing Without Programming</a></li>
<li><a href="../339696/index.html">Knowledge sharing and copyright management platform. Look at the state order?</a></li>
<li><a href="../339700/index.html">Why can LLVM call a function that is never called?</a></li>
<li><a href="../339702/index.html">Comparing tick-to-trade delays with CEPappliance and Solarflare TCPDirect</a></li>
<li><a href="../339704/index.html">Telegram: sending messages to a mobile number to chat with a bot</a></li>
<li><a href="../339708/index.html">FrontFest.Vyorstka: let's talk about accessibility, saving traffic and future CSS</a></li>
<li><a href="../339710/index.html">Announcement: Veeam Backup & Replication 9.5 (and beyond) new features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>