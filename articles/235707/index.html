<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Raise SOC: ARM + FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The other day, the EBV SoCrates Evaluation Board came into my hands. In a nutshell - this is a board with SoC from the company Altera , on board which...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Raise SOC: ARM + FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f17/cd0/45d/f17cd045d9c3411c8dc81ac58b65f55d.jpg"><br><br>  The other day, the <b>EBV SoCrates Evaluation Board</b> came into my hands.  In a nutshell - this is a board with <b>SoC</b> from the company <b>Altera</b> , on board which there is a dual-core ARM and FPGA Cyclone V. <br><br>  <b>ARM</b> and <b>FPGA</b> on the same chip - it should be very interesting!  But first, all this good must be ‚Äúraised‚Äù. <br>  I will tell about this process in this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you get into the hands of such or a similar board and you are not completely sure what to do with it.  If you always thought that <b>FPGA</b> is something complicated and it is not clear how to approach this.  Or you are just a curious engineer.  Then come in.  We are all happy. <br><br>  And as a small bonus, let's measure the bandwidth between the <b>CPU</b> and the <b>FPGA</b> . <br><a name="habracut"></a><br><h3>  Work plan </h3><br>  Our plan consists of the following points: <br><ul><li>  Getting <b>FPGA</b> Firmware </li><li>  Kernel build </li><li>  Build <b>U-Boot</b> and <b>Preloader</b> </li><li>  Build <b>rootfs</b> </li><li>  Writing test programs </li><li>  Create SD card </li><li>  Startup and bandwidth measurement </li></ul><br>  Go! <br><br><h3>  Creating FPGA Firmware </h3><br>  First of all we need to get the FPGA firmware. <br>  From the tools for this you need a Quartus CAD, you can download it <a href="https://www.altera.com/download">on the official website</a> <br>  I will not describe the installation - everything is pretty obvious there. <br><br><h4>  Project creation </h4><br>  Run Quartus, go to <b>File -&gt; New Project Wizard</b> , click <b>Next</b> , fill in the directory and the name of the project: <br><div class="spoiler">  <b class="spoiler_title">Project name</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b62/9b5/fdc/b629b5fdce6045b8b42aa3c839c6a2e7.png"></div></div><br>  The next page is skipped, then there is a choice of family and type of FPGA. <br><div class="spoiler">  <b class="spoiler_title">FPGA selection</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/1cd/dfb/dde/1cddfbdde3554992ab7618bf47325682.png"></div></div><br>  The remaining settings are not important for us, click <b>Finish</b> . <br><br><h4>  Qsys project </h4><br>  Qsys is a great tool for beginners.  Allows you to get the firmware without writing a single line of code.  Instead, the developer assembles a constructor from predefined cubes (IP peels).  You only need to properly adjust each crust and connect them properly. <br><br>  So, <b>Tools -&gt; Qsys</b> , in the left window ( <b>IP Catalog</b> ) we will need two IP peels: <br><ul><li>  Processors and Peripherals -&gt; Hard Processor Systems -&gt; Arria V / Cyclone V Hard Processor System </li><li>  Basic Functions -&gt; On Chip Memory -&gt; On Chip Memory (RAM or ROM) </li></ul><br>  Hard Processor System (HPS) is our ARM.  With its settings and begin. <br><br>  On the first tab, we are interested in <b>HPS-to-FPGA interface width</b> , so that we have access from the CPU to the internal memory of the FPGA: <br><div class="spoiler">  <b class="spoiler_title">FPGA Interfaces</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/313/1ea/70b/3131ea70bc80426baa9fbfb2da3de9bd.png"></div></div><br>  Next comes a bunch of settings for various interfaces - in which modes work, which pins are used: <br><div class="spoiler">  <b class="spoiler_title">Peripheral pins</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b6a/3bb/edd/b6a3bbedd93e4bdd9665e076ccdd2219.png"></div></div><br>  The next tab is setting up clocks.  In <b>Inputs Clocks</b> leave everything unchanged: <br><div class="spoiler">  <b class="spoiler_title">Input clocks</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d83/ec9/d89/d83ec9d891bf4ba1b54510ed19d5f9f1.png"></div></div><br>  In the <b>Output Clocks</b> set the checkbox to <b>Enable HPS-to-FPGA user 0 clock</b> : <br><div class="spoiler">  <b class="spoiler_title">Output clocks</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ab2/1ce/f5e/ab21cef5e9014c659639fdb095a08561.png"></div></div><br>  Then there is a large subsection with different settings for DDR3 memory. <br><div class="spoiler">  <b class="spoiler_title">DDR3 PHY Setting</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/20f/a85/e7d/20fa85e7d7c94318a611f4d0dd75feb0.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">DDR3 Memory Parameters</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9d0/b00/db6/9d0b00db688a4ed89a3e5967dd2ca2aa.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">DDR3 Memory Timing</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/113/6cb/1cd/1136cb1cd7ad4198a4efa3e038e989db.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">DDR3 Board Settings</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/35b/cf6/ac1/35bcf6ac13ed4502ab9bc21841e35044.png"></div></div><br>  With <b>HPS</b> we figured out, go to the setting of <b>On-Chip</b> memory.  This is a memory that is located directly inside the FPGA. <br>  There are significantly fewer settings: <br><div class="spoiler">  <b class="spoiler_title">On-Chip Memory</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c48/1c0/64d/c481c064d74148e990b57f0aea1202bd.png"></div></div><br>  Now you need to connect the blocks together.  Everything is quite intuitive (note the value of the base address opposite <b>s1</b> ): <br><div class="spoiler">  <b class="spoiler_title">Qsys Connections</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/399/f23/10c/399f2310cf2640fca549e97da4115747.png"></div></div><br>  Is done.  Save ( <b>File -&gt; Save</b> ) under the name <b>soc.</b> <br><br>  It remains to generate files.  <b>Generate HDL</b> button, in the appeared window again press <b>Generate</b> , wait, <b>Finish</b> . <br><br><h4>  Project compilation </h4><br>  Now you need to add the generated files to the project: <br>  <b>Assignments -&gt; Settings</b> tab <b>Files</b> , add the file <b>soc / synthesis / soc.qip</b> <br><br>  It is necessary to apply the settings for DDR pins.  But before that you need to perform the first stage of compilation: <br>  <b>Processing -&gt; Start -&gt; Start Analysis &amp; Synthesis</b> <br><br>  Run the script to configure the pins: <br>  <b>Tools -&gt; Tcl Scripts</b> .  In the window that appears, select <b>Project -&gt; soc -&gt; synthesis -&gt; submodules -&gt; hps_sdram_p0_pin_assignments.tcl</b> , <b>Run</b> . <br><br>  Final project compilation: <br>  <b>Processing -&gt; Start Compilation</b> <br><br>  We received the file <b>soc.sof</b> with FPGA firmware.  But we want to flash the FPGA directly from the CPU, so we will need a different format.  Perform the conversion.  This can be done from the GUI, but in the console easier.  And indeed, it‚Äôs time to break the GUI off :). <br><br>  To convert, you need to start the terminal and go to the directory with our project.  Then go to <b>output_files</b> and execute the command (do not forget that the directory with Quartus utilities must be in the <b>PATH</b> variable): <br><pre><code class="bash hljs">quartus_cpf -c soc.sof soc.rbf</code> </pre> <br>  Hooray!  We got the FPGA firmware. <br><br><h3>  Kernel build </h3><br>  Now we will assemble the core for our ARM. <br>  From tools you will need <a href="http://www.altera.com/devices/processor/arm/cortex-a9/software/proc-soc-embedded-design-suite.html">Altera SoC EDS</a> .  From here we will take the <b>arm-linux-gnueabihf- compiler</b> for cross-compiling. <br><br>  We pump out the core: <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/coliby/terasic_MTL.git</code> </pre> <br>  Run the script that will add the compiler directories to the <b>PATH</b> and launch <b>bash</b> : <br><pre> <code class="bash hljs">/opt/altera/quartus14.0/embedded/embedded_command_shell.sh</code> </pre> <br>  Set the environment variables: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ARCH=arm <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CROSS_COMPILE=arm-linux-gnueabihf- <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LOADADDR=0x8000</code> </pre><br>  Go to the directory with the kernel and perform the configuration: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> terasic_MTL/ make socfpga_defconfig</code> </pre> <br>  Build a kernel image for <b>U-Boot</b> : <br><pre> <code class="bash hljs">make -j 4 uImage</code> </pre> <br>  Now we need to get the so-called <b>.dtb</b> (Device Tree Blob) file.  This is a binary file containing information about the platform - interfaces, pins, clock signals, address space, etc.  The kernel reads this file during initialization and makes changes to it.  This allows you to use one assembled core on multiple hardware platforms. <br>  So, we get the <b>.dtb</b> file: <br><pre> <code class="bash hljs">make socfpga_cyclone5.dtb</code> </pre> <br>  But this file is not for our platform, so we will have to make small changes to it.  To do this, convert the file to text format <b>.dts</b> (Device Tree Source): <br><pre> <code class="bash hljs">./scripts/dtc/dtc -I dtb -O dts -o soc.dts arch/arm/boot/dts/socfpga_cyclone5.dtb</code> </pre> <br>  Now in <b>soc.dts</b> you need to remove the block <b>bridge @ 0xff200000</b> .  This can be done either by hand or by applying a patch: <br><pre> <code class="bash hljs">patch soc.dts dts.patch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">dts.patch</b> <div class="spoiler_text"><pre> <code class="bash hljs">942,966d941 &lt; bridge@0xff200000 { &lt; compatible = <span class="hljs-string"><span class="hljs-string">"altr,h2f_lw_bridge-1.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"simple-bus"</span></span>; &lt; reg = &lt;0xff200000 0x200000&gt;; &lt; <span class="hljs-comment"><span class="hljs-comment">#address-cells = &lt;0x1&gt;; &lt; #size-cells = &lt;0x1&gt;; &lt; ranges = &lt;0x200 0xff200200 0x80 0x100 0xff200100 0x80&gt;; &lt; &lt; tsc@0x200 { &lt; compatible = "terasic,mlt_touch_screen"; &lt; reg = &lt;0x200 0x80&gt;; &lt; width_pixel = &lt;0x320&gt;; &lt; height_pixel = &lt;0x1e0&gt;; &lt; interrupts = &lt;0x0 0x28 0x4&gt;; &lt; }; &lt; &lt; vip2@0x100 { &lt; compatible = "ALTR,vip-frame-reader-13.0", "ALTR,vip-frame-reader-9.1"; &lt; reg = &lt;0x100 0x80&gt;; &lt; max-width = &lt;0x320&gt;; &lt; max-height = &lt;0x1e0&gt;; &lt; mem-word-width = &lt;0x100&gt;; &lt; bits-per-color = &lt;0x8&gt;; &lt; }; &lt; }; &lt;</span></span></code> </pre></div></div><br>  Now convert the file back to <b>.dtb</b> : <br><pre> <code class="bash hljs">./scripts/dtc/dtc -I dts -O dtb -o soc.dtb soc.dts</code> </pre><br>  So, we are interested in two files: <br><ul><li>  <b>arch / arm / boot / uImage</b> </li><li>  <b>soc.dtb</b> </li></ul><br><br><h3>  Build U-Boot and Preloader </h3><br>  The process of starting the <b>SoC is</b> as follows: <br><ol><li>  Boot rom </li><li>  Preloader </li><li>  Bootloader </li><li>  OS </li></ol><br>  <b>Boot ROM</b> - this is the first stage of the boot, which is performed immediately after raising the power.  Its main function is to define and execute the second stage, <b>Preloader</b> . <br><br>  <b>Preloader</b> functions are most often the initialization of the <b>SDRAM</b> interface and the configuration of the <b>HPS</b> pins.  The initialization of <b>SDRAM</b> allows the next stage to be loaded from external memory, since its code may not fit into 60 KB of available internal memory. <br><br>  <b>Bootloader</b> can participate in the further initialization of <b>HPS</b> .  This stage also loads the operating system or user application.  Usually (and in our case) <b>U-Boot</b> acts as a <b>bootloader</b> . <br><br>  <b>OS</b> - everything is simple.  This is our favorite <b>Linux</b> .  We already have a kernel for it, we will get the root file system a bit later. <br>  And now we will deal with <b>Preloader</b> and <b>U-Boot</b> <br><br>  Open the terminal, run the script already familiar to us: <br><pre> <code class="bash hljs">/opt/altera/quartus14.0/embedded/embedded_command_shell.sh</code> </pre> <br>  Go to the directory with our project: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/src/soc_test/</code> </pre> <br>  After compilation, the <b>hps_isw_handoff</b> directory should appear <b>there</b> , go to it: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> hps_isw_handoff</code> </pre> <br>  We start the generation of the necessary files: <br><pre> <code class="bash hljs">bsp-create-settings --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> spl --bsp-dir build --preloader-settings-dir soc_hps_0 --settings build/settings.bsp --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> spl.boot.WATCHDOG_ENABLE <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  After this, the <b>build</b> directory should appear. <br>  Putting Preloader: <br><pre> <code class="bash hljs">make -C build</code> </pre> <br>  Putting up the U-boot: <br><pre> <code class="bash hljs">make -C build uboot</code> </pre> <br>  Now we need to set up variables for <b>U-Boot</b> .  First, create a text file <b>u-boot-env.txt</b> . <br><div class="spoiler">  <b class="spoiler_title">u-boot-env.txt</b> <div class="spoiler_text"><pre> <code class="bash hljs">console=ttyS0 baudrate=115200 bootfile=uImage bootdir=boot bootcmd=run mmcboot bootdelay=3 fdt_file=soc.dtb fdt_addr_r=0xf00000 ethaddr=00:01:02:03:04:05 kernel_addr_r=0x10000000 mmcroot=/dev/mmcblk0p2 mmcpart=2 con_args=setenv bootargs <span class="hljs-variable"><span class="hljs-variable">${bootargs}</span></span> console=<span class="hljs-variable"><span class="hljs-variable">${console}</span></span>,<span class="hljs-variable"><span class="hljs-variable">${baudrate}</span></span> misc_args=setenv bootargs <span class="hljs-variable"><span class="hljs-variable">${bootargs}</span></span> uio_pdrv_genirq.of_id=generic-uio mmc_args=setenv bootargs <span class="hljs-variable"><span class="hljs-variable">${bootargs}</span></span> root=<span class="hljs-variable"><span class="hljs-variable">${mmcroot}</span></span> rw rootwait mmcboot=mmc rescan; ext2load mmc 0:<span class="hljs-variable"><span class="hljs-variable">${mmcpart}</span></span> <span class="hljs-variable"><span class="hljs-variable">${kernel_addr_r}</span></span> <span class="hljs-variable"><span class="hljs-variable">${bootdir}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${bootfile}</span></span>; ext2load mmc 0:<span class="hljs-variable"><span class="hljs-variable">${mmcpart}</span></span> <span class="hljs-variable"><span class="hljs-variable">${fdt_addr_r}</span></span> <span class="hljs-variable"><span class="hljs-variable">${bootdir}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${fdt_file}</span></span>; run mmc_args con_args misc_args; bootm <span class="hljs-variable"><span class="hljs-variable">${kernel_addr_r}</span></span> - <span class="hljs-variable"><span class="hljs-variable">${fdt_addr_r}</span></span> verify=n</code> </pre></div></div><br>  Then we convert it into a binary format, not forgetting to specify the size of the region containing the variables - 4096 bytes is enough for us.  Even if the actual size exceeds the specified, <b>mkenvimage</b> will report this. <br><pre> <code class="bash hljs">./build/uboot-socfpga/tools/mkenvimage -s 4096 -o u-boot-env.img u-boot-env.txt</code> </pre> <br>  We are interested in three files: <br><ul><li>  <b>build / uboot-socfpga / u-boot.img</b> </li><li>  <b>u-boot-env.img</b> </li><li>  <b>build / preloader-mkpimage.bin</b> </li></ul><br><br><h3>  Build rootfs </h3><br>  This section is written for those who use <b>Debian</b> (or if your distribution also has <b>debootstrap</b> ).  If you are not among them, you can use <a href="http://www.rocketboards.org/foswiki/Documentation/GSRD131GettingStartedYocto">Yocto</a> or any other method convenient for you. <br><br>  Install the necessary packages: <br><pre> <code class="bash hljs">sudo apt-get install debootstrap qemu-user-static binfmt-support</code> </pre> <br>  Create a directory and download the necessary files there: <br><pre> <code class="bash hljs">mkdir rootfs sudo debootstrap --arch armel --foreign wheezy rootfs http://ftp.debian.org/debian</code> </pre><br>  To run applications compiled under the ARM architecture, we will use <b>qemu static</b> .  To do this, copy the file to our <b>rootfs</b> : <br><pre> <code class="bash hljs">sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin/</code> </pre> <br>  Go to our new file system: <br><pre> <code class="bash hljs">sudo chroot rootfs /bin/bash</code> </pre> <br>  If the interpreter's invitation has changed to ‚ÄúI have no name! @Hostname: / #‚Äù, then everything went well. <br>  Finish the installation process: <br><pre> <code class="bash hljs">/debootstrap/debootstrap --second-stage</code> </pre> <br>  In <b>/ etc / inittab we</b> leave the following lines: <br><div class="spoiler">  <b class="spoiler_title">/ etc / inittab</b> <div class="spoiler_text"><pre> <code class="bash hljs">id:5:initdefault: si::sysinit:/etc/init.d/rcS ~~:S:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/sbin/sulogin l0:0:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 0 l1:1:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 1 l2:2:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 2 l3:3:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 3 l4:4:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 4 l5:5:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 5 l6:6:<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>:/etc/init.d/rc 6 z6:6:respawn:/sbin/sulogin S:2345:respawn:/sbin/getty 115200 console</code> </pre></div></div><br>  Set password: <br><pre> <code class="bash hljs">passwd</code> </pre> <br>  Create an archive: <br><pre> <code class="bash hljs">tar -cpzf rootfs.tar.gz --exclude=rootfs.tar.gz /</code> </pre> <br><br><h3>  Writing test programs </h3><br>  In a nutshell, almost all interaction between <b>SoC</b> components occurs by mapping the address space of one component into the address space of another. <br>  Consider an example.  In our project with the help of <b>Qsys,</b> we indicated that on the <b>HPS-to-FPGA</b> interface, starting from address <b>0, there</b> is an <b>On-Chip</b> memory block with a size of <b>262,144</b> bytes.  The <b>HPS-to-FPGA</b> interface itself is mapped to the CPU address space at <b>0xC0000000</b> (see the documentation for <b>Cyclone V</b> ).  As a result, CPU access by addresses from ( <b>0xC0000000 + 0</b> ) to ( <b>0xC0000000 + 262143</b> ) will result in accessing the internal FPGA memory. <br><br>  Therefore, to work, we need a utility with which you can read / write about arbitrary memory addresses.  Here is its source code: <br><div class="spoiler">  <b class="spoiler_title">mem.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/mman.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #define MAP_SIZE (4096) #define MAP_MASK (MAP_SIZE-1) int main( int argc, char *argv[] ) { int fd; if( argc &lt; 2 ) { printf( "Usage:\n" ); printf( "%s byte_addr [write_data]\n", argv[ 0 ] ); exit( -1 ); } // /dev/mem    ,    . fd = open( "/dev/mem", O_RDWR | O_SYNC ); if( fd &lt; 0 ) { perror( "open" ); exit( -1 ); } void *map_page_addr, *map_byte_addr; off_t byte_addr; byte_addr = strtoul( argv[ 1 ], NULL, 0 ); //    /dev/mem     .   . map_page_addr = mmap( 0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, byte_addr &amp; ~MAP_MASK ); if( map_page_addr == MAP_FAILED ) { perror( "mmap" ); exit( -1 ); } //     (   ) map_byte_addr = map_page_addr + (byte_addr &amp; MAP_MASK); uint32_t data; //   ,   ,  --     . if( argc &gt; 2 ) { data = strtoul( argv[ 2 ], NULL, 0 ); *( ( uint32_t *) map_byte_addr ) = data; } else { data = *( ( uint32_t *) map_byte_addr ); printf( "data = 0x%08x\n", data ); } //  . if( munmap( map_page_addr, MAP_SIZE ) ) { perror( "munmap" ); exit( -1 ); } close( fd ); return 0; }</span></span></span></span></code> </pre></div></div><br>  Now you need to build it using the cross compiler.  To do this, run the script: <br><pre> <code class="bash hljs">/opt/altera/quartus14.0/embedded/embedded_command_shell.sh</code> </pre> <br>  And compile: <br><pre> <code class="bash hljs">arm-linux-gnueabihf-gcc -o mem.o mem.c</code> </pre> <br>  We also need a bandwidth measurement utility: <br><div class="spoiler">  <b class="spoiler_title">memblock.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/mman.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; //    #define COP_WRITE (0) #define COP_READ (1) #define COP_CHECK (2) int main( int argc, char *argv[ 0 ] ) { int fd; void *map_addr; if( argc &lt; 5 ) { printf( "Usage:\n" ); printf( "%s &lt;cop&gt; &lt;address&gt; &lt;word_count&gt; &lt;cycles&gt;\n", argv[ 0 ] ); exit( -1 ); } // /dev/mem    ,    . fd = open( "/dev/mem", O_RDWR | O_SYNC ); if( fd &lt; 0 ) { perror( "open" ); exit( -1 ); } uint8_t cop; off_t addr; uint32_t word_cnt; uint32_t cycle_cnt; //   cop = strtoul( argv[ 1 ], NULL, 0 ); //   addr = strtoul( argv[ 2 ], NULL, 0 ); //    / word_cnt = strtoul( argv[ 3 ], NULL, 0 ); //    cycle_cnt = strtoul( argv[ 4 ], NULL, 0 ); //    /dev/mem     . map_addr = mmap( 0, word_cnt * 4, PROT_READ | PROT_WRITE, MAP_SHARED, fd, addr ); if( map_addr == MAP_FAILED ) { perror( "map" ); exit( -1 ); } uint32_t cycle; uint32_t word; uint32_t data; //      switch( cop ) { //    "". case( COP_WRITE ): for( cycle = 0; cycle &lt; cycle_cnt; cycle++ ) { for( word = 0; word &lt; word_cnt; word++ ) { *( ( uint32_t *) map_addr + word ) = word; } } break; //      . case( COP_READ ): for( cycle = 0; cycle &lt; cycle_cnt; cycle++ ) { for( word = 0; word &lt; word_cnt; word++ ) { data = *( ( uint32_t *) map_addr + word ); printf( "idx = 0x%x, data = 0x%08x\n", word, data ); } } break; //      " ". case( COP_CHECK ): for( cycle = 0; cycle &lt; cycle_cnt; cycle++ ) { for( word = 0; word &lt; word_cnt; word++ ) { data = *( ( uint32_t *) map_addr + word ); if( data != word ) { printf( "Error! write = 0x%x, read = 0x%x\n", word, data ); exit( -1 ); } } } break; default: printf( "Error! Unknown COP\n" ); exit( -1 ); } if( munmap( map_addr, word_cnt * 4 ) ) { perror( "munmap" ); exit( -1 ); } close( fd ); return 0; }</span></span></span></span></code> </pre></div></div><br>  Compile: <br><pre> <code class="bash hljs">arm-linux-gnueabihf-gcc -o memblock.o memclock.c</code> </pre> <br><br>  Accordingly, the files of interest to us: <br><ul><li>  <b>mem.o</b> </li><li>  <b>memblock.o</b> </li></ul><br><br><h3>  Create SD card </h3><br>  It is time to put the pieces together.  At the moment we should have the following files: <br><ul><li>  soc.rbf </li><li>  uImage </li><li>  soc.dtb </li><li>  preloader-mkpimage.bin </li><li>  u-boot.img </li><li>  u-boot-env.img </li><li>  rootfs.tar.gz </li><li>  mem.o </li><li>  memblock.o </li></ul><br>  If there is no one of them, then you missed something :) <br><br>  Create a directory and copy all the specified files into it.  Next we need to find and connect the microSD card. <br>  In subsequent commands, the card is assumed to be defined as a <b>/ dev / sdb</b> device.  We will create two sections on it: <br><ul><li>  <b>/ dev / sdb1</b> - for Preloader and U-Boot </li><li>  <b>/ dev / sdb2</b> - for filesystem </li></ul><br>  If the map is defined under a different name, make the appropriate changes. <br><br>  Just in case, we will overwrite everything with zeros. <br>  <b>Attention!</b>  <b>Once again check that / dev / sdb is a card, not your second hard disk.</b> <br><pre> <code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=/dev/sdb bs=10M</code> </pre> <br>  In order to create partitions, use the <b>fdisk</b> utility: <br><pre> <code class="bash hljs">sudo fdisk /dev/sdb</code> </pre> <br>  Next, you need to enter the following commands (empty line - enter Enter): <br><div class="spoiler">  <b class="spoiler_title">Commands for fdisk</b> <div class="spoiler_text"><pre> <code class="bash hljs">o n p 1 2048 +1M n p 2 t 1 a2 t 2 83 w</code> </pre></div></div><br>  You can check what we did: <br><pre> <code class="bash hljs">sudo fdisk -l /dev/sdb</code> </pre> <br>  It should be something like: <br><div class="spoiler">  <b class="spoiler_title">Fdisk -l output</b> <div class="spoiler_text"><pre> <code class="bash hljs">Disk /dev/sdb: 1966 MB, 1966080000 bytes 61 heads, 62 sectors/track, 1015 cylinders, total 3840000 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x02be07e5 Device Boot Start End Blocks Id System /dev/sdb1 2048 4095 1024 a2 Unknown /dev/sdb2 4096 3839999 1917952 83 Linux</code> </pre></div></div><br>  Now copy the image with <b>U-Boot</b> variables to the map: <br><pre> <code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=u-boot-env.img of=/dev/sdb bs=1 seek=512</code> </pre> <br>  After this, copy the <b>Preloader</b> : <br><pre> <code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=preloader-mkpimage.bin of=/dev/sdb1</code> </pre> <br>  And the <b>U-Boot itself</b> : <br><pre> <code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=u-boot.img of=/dev/sdb1 bs=64k seek=4</code> </pre> <br>  Create an <b>ext3</b> file system: <br><pre> <code class="bash hljs">sudo mkfs.ext3 /dev/sdb2</code> </pre> <br>  Mount it: <br><pre> <code class="bash hljs">sudo mount /dev/sdb2 /mnt/</code> </pre> <br>  And we deploy our <b>rootfs</b> into it: <br><pre> <code class="bash hljs">sudo tar xvf rootfs.tar.gz -C /mnt/</code> </pre> <br>  Next, copy the kernel image, <b>dtb</b> , FPGA firmware and test programs: <br><pre> <code class="bash hljs">sudo cp uImage /mnt/boot/ sudo cp soc.dtb /mnt/boot/ sudo cp soc.rbf /mnt/boot/ sudo cp mem.o /mnt/root/ sudo cp memblock.o /mnt/root/</code> </pre><br>  Unmount the file system: <br><pre> <code class="bash hljs">sudo umount /dev/sdb2</code> </pre> <br>  Everything, the map is ready! <br><br><h3>  Startup and bandwidth measurement </h3><br>  Finally, everything is ready for work.  Insert the card, connect the USB and power. <br>  Go to the console: <br><pre> <code class="bash hljs">minicom -D /dev/ttyUSB0 -b 115200 -s</code> </pre> <br>  First of all, <b>FPGA</b> . <br>  For this it is necessary to set the switch <b>P18</b> on the board to the ‚ÄúOn On On On‚Äù position (switches 1 to 5). <br>  We look at the current state of <b>FPGA</b> : <br><pre> <code class="bash hljs">cat /sys/class/fpga/fpga0/status</code> </pre> <br>  We should see the <b>configuration phase</b> <br>  Fill the firmware: <br><pre> <code class="bash hljs"> dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/boot/soc.rbf of=/dev/fpga0 bs=4096</code> </pre> <br>  And look at the state again: <br><pre> <code class="bash hljs">cat /sys/class/fpga/fpga0/status</code> </pre> <br>  The state should change to <b>user mode</b> .  This means that the FPGA is configured and ready for operation. <br><br>  Now we check our utilities.  But before that, a little more "work with a file." <br>  Our cross-compiler and <b>Debian have</b> different dynamic linker names.  Therefore, in order for the utilities to work, we need to create a link to the correct linker: <br><pre> <code class="bash hljs">ln -s /lib/ld-linux.so.3 /lib/ld-linux-armhf.so.3</code> </pre> <br>  So, we run the utility (an explanation of what kind of address will be slightly lower): <br><pre> <code class="bash hljs">./mem.o 0xFFD0501C</code> </pre> <br>  If as a result you see the line <b>data = 0x00000007</b> , then everything is in order. <br><br>  As I wrote above, the internal memory of the FPGA will be mapped into the address space starting at address <b>0xC0000000</b> .  But before we can work with this memory, we need to do two more actions. <br><br>  The first is that since by default all interfaces between the <b>CPU</b> and the <b>FPGA</b> are in reset, we have to remove it.  The block <b>Reset Manager (rstmgr)</b> , with the base address <b>0xFFD05000</b> , and specifically its register <b>brgmodrst</b> with offset <b>0x1C,</b> are responsible for this.  The final register address is <b>0xFFD0501C</b> .  Only three low-order bits are involved: <br><ul><li>  <b>0th</b> - reset of the <b>HPS-to-FPGA</b> interface </li><li>  <b>1st</b> ‚Äî <b>LWHPS-to-FPGA</b> interface reset </li><li>  <b>2nd</b> ‚Äî <b>FPGA-to-HPS</b> interface reset </li></ul><br>  The logic of all bits is the same - if there is a unit there, then the corresponding interface is in reset.  As a result, the default value for this register is <b>0x7</b> , which we saw when we read from it with the help of our utility.  We need to remove the reset from the <b>HPS-to-FPGA</b> interface, so we have to write the number <b>0x6</b> into the register: <br><pre> <code class="bash hljs">./mem.o 0xFFD0501C 0x6</code> </pre> <br>  After this, we again read the register to make sure that the data were recorded correctly: <br><pre> <code class="bash hljs">./mem.o 0xFFD0501C</code> </pre> <br>  Secondly, we need to enable the mapping of the <b>HPS-to-FPGA</b> interface <b>to the</b> <b>CPU</b> address space.  The unit <b>L3 (NIC-301) GPV (l3regs)</b> with the base address <b>0xFF800000</b> , and specifically its <b>remap</b> register with offset <b>0,</b> is responsible for this.  For <b>HPS-to-FPGA</b> responsible bit number <b>3</b> .  As a result, we need to write the number <b>0x8</b> into the register: <br><pre> <code class="bash hljs">./mem.o 0xFF800000 0x8</code> </pre> <br>  Unfortunately, this register is available only for writing, so we will not be able to read the data for verification. <br><br>  Now we can read and write in <b>FPGA</b> memory.  Check it out.  We read: <br><pre> <code class="bash hljs">./mem.o 0xC0000000</code> </pre> <br>  Naturally, there should be zeros.  Now write something there: <br><pre> <code class="bash hljs">./mem.o 0xC0000000 0x12345678</code> </pre> <br>  And read again: <br><pre> <code class="bash hljs">./mem.o 0xC0000000</code> </pre> <br>  Must match the recorded. <br><br>  Hooray!  We finally made it!  We got a working <b>SoC</b> with <b>FPGA</b> and organized access to its memory from the <b>CPU</b> . <br>  But just reading / writing is somehow quite boring.  Let's at least measure the bandwidth of our interface.  Moreover, it will take very little time. <br><br>  For this we need our second <b>memblock</b> utility: <br><pre> <code class="bash hljs">root@desktop:~<span class="hljs-comment"><span class="hljs-comment"># ./memblock.o Usage: ./memblock.o &lt;cop&gt; &lt;address&gt; &lt;word_count&gt; &lt;cycles&gt;</span></span></code> </pre><br>  It works as follows: if the first <b>cop</b> argument is 0, then the <b>word_count of</b> 32-bit words, starting with the address <b>address</b> , will contain a sequence of numbers from <b>0</b> to <b>word_count-1</b> .  The entire procedure will be performed <b>cycles</b> times (this is done for more accurate measurement of the bandwidth). <br>  If <b>cop</b> is 1, then the same words will be read and displayed. <br>  If <b>cop</b> is 2, then the words will be read, and their meanings will be compared with those that were hypothetically recorded. <br><br>  Check it out.  Let's write some data: <br><pre> <code class="bash hljs">./memblock.o 0 0xC0000000 10 1</code> </pre> <br>  Now we consider them: <br><pre> <code class="bash hljs">./memblock.o 1 0xC0000000 10 1</code> </pre> <br>  The result should be as follows: <br><div class="spoiler">  <b class="spoiler_title">Output memblock.o</b> <div class="spoiler_text"><pre> <code class="bash hljs">data = 0x00000000 data = 0x00000001 data = 0x00000002 data = 0x00000003 data = 0x00000004 data = 0x00000005 data = 0x00000006 data = 0x00000007 data = 0x00000008 data = 0x00000009</code> </pre></div></div><br>  Now let's try to compare the data, specifically asking a little more words: <br><pre> <code class="bash hljs">./memblock.o 2 0xC0000000 11 1</code> </pre> <br>  Should get the following string: <br><pre> <code class="bash hljs">Error! write = 0xa, <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> = 0x0</code> </pre> <br>  Now we start recording over the entire memory capacity in the amount of 1000 repetitions and measure the recording time: <br><pre> <code class="bash hljs">time ./memblock.o 0 0xC0000000 0x10000 1000</code> </pre> <br>  The average of 5 starts is 11.17 seconds.  Consider the bandwidth: <br><pre> <code class="bash hljs">1000  * 65536  * 4  * 8 /_ / ( 11.17 * 10^6 ) = 187.75 /c</code> </pre><br>  Not very thick.  And what about reading? <br><pre> <code class="bash hljs">time ./memblock.o 2 0xC0000000 0x10000 1000</code> </pre> <br>  Average time 10.5 seconds.  What translates into: <br><pre> <code class="bash hljs">1000 * 65536 * 4 * 8 / ( 10.5 * 10^6 ) = 199.73 /c</code> </pre><br>  About the same.  Naturally, for the execution of any of these operations, one of the two cores is loaded at 100%. <br><br>  If you add the <b>-O3</b> flag during compilation, then the write and read <b>bandwidth</b> will be <b>212 Mbit / s</b> and <b>228 Mbit / c,</b> respectively.  Slightly better, but also not a meteor. <br><br>  But this is not surprising - we did not do anything to increase this bandwidth.  It would be nice to play around with a more tricky optimization, look towards the core, or, at worst, at least screw <b>DMA</b> to unload the processor. <br>  But this is already in the next article, if, of course, it will be interesting to someone. <br><br>  Thanks to those who got to the end!  Good luck! <br><br><h3>  useful links </h3><br>  <a href="http://www.altera.com/literature/lit-cyclone-v.jsp">Official</a> <b>Cyclone V</b> <a href="http://www.altera.com/literature/lit-cyclone-v.jsp">Documentation</a> <br>  <a href="http://www.rocketboards.org/foswiki/Documentation/WebHome">Rocketboards.org</a> - many different articles about boards with SoC <br>  <a href="http://www.rocketboards.org/foswiki/Documentation/EBVSoCratesEvaluationBoard">Information</a> specifically on the EBV SoCrates Evaluation Board </div><p>Source: <a href="https://habr.com/ru/post/235707/">https://habr.com/ru/post/235707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235691/index.html">Remove ads in uTorrent in 15 seconds</a></li>
<li><a href="../235693/index.html">Samsung introduced a new smartphone GALAXY Note 4 and its modification with a curved screen - GALAXY Note Edge</a></li>
<li><a href="../235699/index.html">We build Touch ID in iOS application</a></li>
<li><a href="../235701/index.html">GitHub's CSS</a></li>
<li><a href="../235703/index.html">Noise Security Bit # 9 (about Black Hat 2014 and Defcon 22)</a></li>
<li><a href="../235711/index.html">Button gouging and pedaling Vim</a></li>
<li><a href="../235713/index.html">SMS virus under the Android OS or "Hello :) You photo ..."</a></li>
<li><a href="../235715/index.html">Sony's latest news at IFA 2014</a></li>
<li><a href="../235717/index.html">How we fought the brakes in AndEngine</a></li>
<li><a href="../235719/index.html">Battle Arsenal of Erlang Developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>