<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>90 new features (and APIs) in JDK 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article " 90 New Features (and APIs) in JDK 11 " by Simon Ritter. 





 The new six-month JDK relea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>90 new features (and APIs) in JDK 11</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to you the translation of the article " <a href="https://www.azul.com/90-new-features-and-apis-in-jdk-11/">90 New Features (and APIs) in JDK 11</a> " by Simon Ritter. </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p>  The new six-month JDK release cycle for many means that some have not even figured out what new features are in JDK 10, and on the threshold is JDK 11. <a href="https://www.azul.com/109-new-features-in-jdk-10/">In one of the early blogs</a> , all 109 new features and APIs were listed managed to be found in JDK 10. Therefore, for JDK 11, it was decided to do the same.  However, a different format was chosen.  This post will be divided into two sections: new features that are available to developers (public API) and everything else.  Thus, if you are only interested in what directly affects your development, you can skip the second part. </p><br><p>  The total number of changes that we managed to calculate turned out to be 90 (this is JEP plus new classes and methods, excluding separate methods for the <a href="httpclient/intro.html">HTTP client</a> and <a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm">Flight Recorder</a> ) ( <em>note of the translator: Java Flight Recorder (JFR) was one of the commercial additions from Oracle's built-in in the JDK, but since Java 11, thanks to <a href="http://openjdk.java.net/jeps/328">JEP 328</a> , was transferred to open source)</em> .  Although it was possible to find eleven changes less in JDK 11 than in JDK 10, I think it is fair to say that more functionality was added to JDK 11, uniquely at the JVM level. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi">  New visible to the developer features </h3><br><p>  There are quite a few changes in JDK 11 that could affect the style of development.  There is a slight syntax change, a lot of new APIs and the ability to run applications in one file without using a compiler ( <em>note the translator: the so-called <a href="http://openjdk.java.net/jeps/330">shebang files</a></em> ).  In addition, a big (and breaking) change is the removal of the <strong><a href="https://docs.oracle.com/javase/9/docs/api/java.se.ee-summary.html">java.se.ee</a></strong> aggregation module, which may affect the transfer of an existing application to JDK 11. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/323">JEP 323: Local-Variable Syntax for Lambda Parameters</a></strong> </p><br><p>  JDK 10 introduced local variable output (or type inference) ( <a href="http://openjdk.java.net/jeps/286">JEP 286</a> ).  This simplifies the code, since you no longer need to explicitly specify the type of a local variable, you can use <strong>var</strong> instead.  JEP 323 extends the use of this syntax, which is now also applicable to the parameters of lambda expressions.  A simple example: </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  An attentive Java programmer would point out that lambda expressions already have type inference, so using var would (in this case) be redundant.  We could just as easily write the same code as: </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Why was it necessary to add support for var?  The answer is one special case - when you want to add annotation to the lambda parameter.  It is impossible to do without the participation of any type.  To avoid using an explicit type, we can use var to simplify things, thus: </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  This change required changes to <a href="https://docs.oracle.com/javase/specs/">the Java Language Specification (JLS)</a> , in particular: </p><br><p>  Page 24: The description of the var special identifier. <br>  Page 627-630: Lambda parameters <br>  Page 636: Runtime evaluation of Lambda expressions <br>  Page 746: Lambda syntax </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/330">JEP 330: Launch Single-File Source-Code Programs</a></strong> </p><br><p>  One of the criticisms of Java is syntax redundancy, and the ‚Äúceremony‚Äù associated with the launch of even a trivial application can seriously raise the entry threshold for a beginner.  To write an application that simply prints ‚ÄúHello World!‚Äù, You need to write a class with a publicly available static void main method and use the System.out.println () method.  Having done this, you must compile the code with javac.  Finally, you can run an application that will greet the world.  Running the same script in most modern languages ‚Äã‚Äãis much easier and faster. </p><br><p>  JEP 330 eliminates the need to compile a single-file application.  Now just enter: </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Java launcher identifies that the file contains Java source code and compiles the code into a * .class file before its execution. </p><br><p>  Arguments placed after the source file name are passed as arguments when the application is started.  Arguments placed before the source file name are passed as arguments to the java launcher after the code is compiled (this allows you to set things like the classpath on the command line).  Arguments related to the compiler (for example, the path to the classes) will also be passed to javac for compilation. </p><br><p>  Example: </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p>  It will be equivalent to: </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p>  This JEP also provides support for ‚Äúshebang‚Äù files.  To reduce the need to even mention the java launcher on the command line, you can include it in the first line of the source file.  For example: </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p>  The -source flag with the Java version used is mandatory. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/321">JEP 321: HTTP Client (Standard)</a></strong> </p><br><p>  JDK 9 has provided a new API to support the HTTP Client protocol ( <a href="http://openjdk.java.net/jeps/110">JEP 110</a> ).  Since JDK 9 provided the <a href="https://en.wikipedia.org/wiki/Java_Platform_Module_System">Java Platform Module System (JPMS)</a> , this API was included as <a href="http://openjdk.java.net/jeps/11">an incubator module</a> .  Incubator modules are designed to provide new APIs, but do not turn them into the Java SE standard.  Developers can try the API by providing feedback.  After making the necessary changes (this API has been updated in JDK 10), the API can be transferred to the main module to become part of the standard. </p><br><p>  The HTTP Client API is now part of the Java SE 11 standard. This introduces a new module and package for the JDK, <a href="http/module-summary.html">java.net.http</a> .  Main classes: </p><br><ul><li>  Httpclient </li><li>  Httprequest </li><li>  HttpResponse </li><li>  Websocket </li></ul><br><p>  The API can be used synchronously or asynchronously.  In asynchronous mode, CompletionFutures and CompletionStages are used. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/320">JEP 320: Remove The Java EE and CORBA Modules</a></strong> </p><br><p>  With the introduction of JPMS into JDK 9, it was possible to split the monolithic rt.jar file into several modules.  An additional advantage of JPMS is that you can now create a Java runtime environment that includes only the modules necessary for your application, significantly reducing the overall size.  Having explicitly defined boundaries, obsolete modules are now easier to remove from the Java API.  This is what this JEP does;  The java.se.ee meta module includes six modules that will no longer be part of the Java SE 11 standard and will not be included in the JDK. </p><br><p>  Remote modules: </p><br><ul><li>  corba ( <em>approx. translator:</em> <del>  <em>rest in peace</em> </del>  <em>burn in hell</em> ) </li><li>  transaction </li><li>  activation </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p>  These modules were marked obsolete (@Deprecated) since JDK 9 and were not included by default in compilation or runtime.  If you tried to compile or run an application that uses the API from these modules on JDK 9 or JDK 10, then you would fail.  If you use API from these modules in your code, you will need to provide them as a separate module or library.  Judging by the reviews, it seems that the java.xml modules that are part of the support of the JAX-WS, SOAP web services are the ones that cause the most problems. </p><br><h3 id="novyy-publichnyy-api">  New public API </h3><br><p>  Many new APIs in JDK 11 are the result of the fact that the HTTP client module is now part of the standard, as well as the inclusion of Flight Recorder. </p><br><p>  A complete sketchy list of API changes, including a comparison of different versions of the JDK, <a href="https://gunnarmorling.github.io/jdk-api-diff/jdk10-jdk11-api-diff.html">can be found here.</a> </p><br><p>  All new methods are listed here, different from those contained in the modules java.net.http and jdk.jfr.  Also, new methods and classes are not listed in the java.security modules, which are quite specific for <a href="http://openjdk.java.net/jeps/324">JEP 324</a> and <a href="http://openjdk.java.net/jeps/329">JEP 329</a> changes (there are six new classes and eight new methods). </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>void writeBytes (byte [])</strong> : writes all bytes from the argument to the OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p>  Two new constructors that allow you to specify Charset. </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p>  Four new constructors that allow you to specify Charset. </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream ()</strong> : returns an InputStream that does not read bytes.  Looking at this method (and the one in the OutputStream, Reader and Writer), the question arises as to why it can be useful.  You can think of them as <strong>/ dev / null</strong> ‚Äî to throw out output that you don't need, or to provide input that always returns zero bytes. </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString (int)</strong> : This is the overloaded form of the existing method, but instead of char, an int is used.  Int is a Unicode code point. </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int compare (CharSequence, CharSequence)</strong> : compares two instances of CharSequence <a href="https://ru.stackoverflow.com/questions/489888/%25D0%25A7%25D1%2582%25D0%25BE-%25D1%2582%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B5-%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5-%25D1%2581%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B8-%25D1%2587%25D1%2582%25D0%25BE-%25D0%25BE%25D0%25BD%25D0%25BE-%25D1%2581%25D0%25BE%25D0%25B1%25D0%25BE%25D0%25B9-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D0%25B5%25D1%2582">lexicographically</a> .  Returns a negative value, zero or a positive value if the first sequence is lexicographically less, equal to or greater than the second, respectively. </li></ul><br><h4 id="javalangrefreference">  java.lang.ref.Reference </h4><br><ul><li>  <strong>lang.Object clone ()</strong> : I must admit, this change causes confusion.  The Reference class does not implement the Cloneable interface, and this method throws a CloneNotSupportedException exception.  There must be a reason for including it, perhaps for something in the future.  ( <em>comment of the translator: <a href="https://stackoverflow.com/questions/52527797/why-unsupported-clone-method-was-added-to-java-lang-ref-reference-in-java-11">there is a discussion on StackOverflow</a> , a <a href="https://bugs.openjdk.java.net/browse/JDK-8202260">ticket in OpenJDK</a></em> ) </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p>  There are no new methods here, but it is worth mentioning that the <strong>runFinalizersOnExit ()</strong> method is now removed from both classes (there may be a problem when migrating to JDK 11). </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p>  I think this is one of the highlights of the new APIs in JDK 11. There are some useful new methods here. </p><br><ul><li>  <strong>boolean isBlank ()</strong> : returns true if the string is empty or contains only spaces, false otherwise. </li><li>  <strong>Stream lines ()</strong> : returns a Stream from a String extracted from this string, separated by a string delimiter. </li><li>  <strong>String repeat (int)</strong> : returns a string whose value is the concatenation of this string repeated a number of times. </li><li>  <strong>String strip ()</strong> : Returns a string whose value is this string; all spaces at the beginning and end of the string are removed. </li><li>  <strong>String stripLeading ()</strong> : returns a string whose value is this string, all spaces at the beginning of the string are removed. </li><li>  <strong>String stripTrailing ()</strong> : returns a string whose value is this string, all spaces at the end of the string are deleted. </li></ul><br><p>  Most likely, you look at <strong>strip ()</strong> and ask: ‚ÄúHow does this differ from the existing <strong>trim ()</strong> method?‚Äù The answer lies in the difference in the definition of spaces.  ( <em>comment of translator: in short, <strong>strip ()</strong> understands Unicode better, <a href="https://stackoverflow.com/questions/51266582/difference-between-string-trim-and-strip-methods-in-java-11/51266583">detailed parsing on StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p>  Both of these classes have a new <strong>compareTo ()</strong> method that accepts a StringBuffer / StringBuilder and returns an int.  The lexical comparison method is similar to the new <strong>compareTo ()</strong> method in CharSequence. </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p>  No new methods.  The <strong>destroy ()</strong> and <strong>stop (Throwable) methods</strong> have been removed.  The <strong>stop ()</strong> method, which takes no arguments, is still present.  May lead to compatibility issue. </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p>  All of these classes now have a <strong>mismatch ()</strong> method, which finds and returns the relative index of the first mismatch between this buffer and the transferred buffer. </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int interestOpsAnd (int)</strong> : Atomically sets the key's interest to the bitwise intersection (‚Äúand‚Äù) of the existing set of interests and the value passed. </li><li>  <strong>int interestOpsOr (int)</strong> : Atomically sets the key's interest to the bitwise union (‚Äúor‚Äù) of the existing set of interests and the value passed. </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select (java.util.function.Consumer, long)</strong> : select and perform actions on the keys whose corresponding channels are ready for I / O operations.  long argument is a timeout. </li><li>  <strong>int select (java.util.function.Consumer)</strong> : the same as above, but without a timeout. </li><li>  <strong>int selectNow (java.util.function.Consumer)</strong> : the same as above, only non-blocking. </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString (Path)</strong> : reads all content from file to string, decoding from bytes to characters using UTF-8 encoding. </li><li>  <strong>String readString (Path, Charset)</strong> : as stated above, with the difference that decoding from bytes to characters occurs using the specified Charset. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.OpenOption [])</strong> : Write CharSequence to a file.  Characters are encoded in bytes using UTF-8 encoding. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.Charset, OpenOption [])</strong> : the same as above, the characters are encoded in bytes using the charset specified in Charset. </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>Path of (String, String [])</strong> : Returns a Path from a string argument to a path or a sequence of strings, which when combined form a string path. </li><li>  <strong>Path of (net.URI)</strong> : Returns a Path from a URI. </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Object [] toArray (java.util.function.IntFunction)</strong> : returns an array containing all the elements in this collection, using the provided generation function to allocate the returned array. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach (java.util.function.Consumer)</strong> : Performs the passed action for each Iterable until all the elements have been processed, or the action throws an exception. </li><li>  <strong>boolean removeAll (java.util.Collection)</strong> : removes all elements of this collection that are also contained in the specified collection (optional operation). </li><li>  <strong>boolean removeIf (java.util.function.Predicate)</strong> : Removes all items from this collection that satisfy the given predicate. </li><li>  <strong>boolean retainAll (java.util.Collection)</strong> : Saves only those elements in this collection that are contained in the passed collection (optional operation). </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>long convert (java.time.Duration)</strong> : converts the transmitted Duration to this type. </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>Predicate not (Predicate)</strong> : Returns the predicate, which is the negation of the predicate passed. </li></ul><br><p>  This is one of my favorite new APIs in JDK 11. As an example, you can convert this code: </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p>  at </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p>  or if we use static import: </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p>  Personally, I believe that this version is more understandable and concise. </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty ()</strong> : Returns true if not present, otherwise false. </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Predicate asMatchPredicate ()</strong> : I think it might be the pearl of the new JDK API 11. It creates a predicate that checks whether this pattern matches the given input string. </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate (ByteBuffer)</strong> : compresses the input and fills the specified buffer. </p><br></li><li><p>  <strong>int deflate (ByteBuffer, int)</strong> : compresses the input and fills the specified buffer.  Returns the actual amount of compressed data. </p><br></li><li><p>  <strong>void setDictionary (ByteBuffer)</strong> : Sets the specified dictionary to be compressed into bytes in this buffer.  This is the overloaded form of the existing method, which ByteBuffer can now accept, rather than a byte array. </p><br></li><li><p>  <strong>void setInput (ByteBuffer)</strong> : Sets the input for compression.  Also the overloaded form of the existing method. </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate (ByteBuffer)</strong> : unpacks the bytes into the specified buffer.  Returns the actual number of unzipped bytes. </li><li>  <strong>void setDictionary (ByteBuffer)</strong> : Sets the specified dictionary to bytes in this buffer.  The overloaded form of the existing method. </li><li>  <strong>void setInput (ByteBuffer)</strong> : Sets the input for decompression.  The overloaded form of the existing method. </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p>  This is a new class in JDK 11. Used to support a print dialog request or page setup.  Must be displayed on top of all windows or a specific window. </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>void addAll (Collection)</strong> : adds all the elements present in the collection. </li><li>  <strong>void addAll (int, Collection)</strong> : adds all the elements present in the collection, starting at the specified index. </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices ()</strong> : Returns an array of all selected indices in the selected model, in ascending order. </li><li>  <strong>int getSelectedItemsCount ()</strong> : Returns the number of selected items. </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause ()</strong> : returns a throwable cause wrapper in the executing client represented by EvalException, or null if the cause does not exist or is unknown. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api">  New features (non-public API) </h3><br><p>  <a href="http://openjdk.java.net/jeps/181">JEP 181: Nest-Based Access Control</a> </p><br><p>  Java (and other languages) supports nested classes through inner classes.  For proper operation, the compiler must perform some tricks.  For example: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p>  The compiler modifies this to create something like this before compiling: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p>  Although, logically, the inner class is part of the same code as the outer class, it is compiled as a separate class.  Therefore, this requires a synthetic method ("bridge"), which must be created by the compiler to provide access to the private field of the outer class. </p><br><p>  This JEP represents the concept of "nest", where two members of the same nest (Outer and Inner from our example) are neighbors.  Two new attributes have been added to the * .class file format: NestHost and NestMembers.  These changes are also useful for other bytecode-compiled languages ‚Äã‚Äãthat support nested classes. </p><br><p>  This feature provides three new methods for java.lang.Class: </p><br><ul><li>  <strong>Class getNestHost ()</strong> </li><li>  <strong>Class [] getNestMembers ()</strong> </li><li>  <strong>boolean isNestmateOf (clazz)</strong> </li></ul><br><p>  This feature also required changes to <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/">the Java Virtual Machine Specification (JVMS)</a> , particularly in section 5.4.4 ‚ÄúAccess Control‚Äù. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/309">JEP 309: Dynamic Class-File Constants</a></strong> </p><br><p>  This JEP describes the extension of the * .class file format to support the new form with the constant pool CONSTANT_Dynamic (often referred to in presentations as condy).  The idea of ‚Äã‚Äãa dynamic constant seems like an oxymoron, but, in fact, you can think of it as the final meaning in Java.  The value of the constant pool is not set at the compilation stage (unlike other constants), but is used the bootstrap method to determine the value at run time.  Therefore, the value is dynamic, but since its value is specified only once, it is also constant. </p><br><p>  This function will be primarily useful to those who develop new languages ‚Äã‚Äãand compilers.  Who will generate the bytecode and * .class files in to run on the JVM.  This will simplify some tasks. </p><br><p>  This feature provides a new java.lang.invoke.ConstantBootstraps class with nine new methods.  I will not list them all here;  these are methods for bootstrapping dynamically calculated constants. </p><br><p>  This feature required changes to the JVMS, in particular, the way the special invoke byte code and section 4.4 ‚ÄúThe Constant Pool‚Äù are used. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/315">JEP 315: Improve Aarch64 Intrinsics</a></strong> </p><br><p>  It was a Red Hat JEP.  The JVM can now use more specialized instructions available in the Arm 64 command set. In particular, this improves the sin (), cos () and log () methods of the java.lang.Math class. </p><br><p>  <strong><a href="http://openjdk.java.net/jeps/318">JEP 318: The Epsilon Garbage Collector</a></strong> </p><br><p>  Red Hat also contributed to this JEP.  The Epsilon garbage collector is somewhat unusual as it does not collect garbage!  It will allocate new memory if it is required when creating new objects, but it does not free up the space occupied by objects without references. </p><br><p>  It would seem, then what is the point?  There are at least two uses: </p><br><ul><li>  First of all, this collector is designed so that the new GC algorithms are evaluated in terms of their impact on performance.  The idea is to run a sample application with Epsilon GC and generate a metric.  The new GC algorithm is turned on, the same tests are run and the results are compared. </li><li>  For very short or short-lived tasks (think about serverless functions in the cloud), where you can guarantee that you will not exceed the memory allocated to the heap space.  This can improve performance due to the absence of overheads (including collecting the statistics necessary to make a decision about running the builder) in the application code. </li></ul><br><p>  If the heap space is exhausted, the subsequent work of the JVM can be configured in one of three ways: </p><br><ul><li>  Called normal OutOfMemoryError. </li><li>  Perform heap reset </li><li>  Hard stopping the JVM and possibly performing an external task (for example, starting a debugger). </li></ul><br><p>  <a href="http://openjdk.java.net/jeps/324"><strong>JEP 324: Key Agreement with Curve25519 and Curve448</strong></a> </p><br><p>  Cryptographic standards are constantly changing and improving.  In this case, the existing Diffie-Hellman scheme with an elliptic curve is replaced by Curve25519 and Curve448.  This is the key agreement scheme defined in RFC-7748. </p><br><p>  <a href="http://openjdk.java.net/jeps/327"><strong>JEP 327: Unicode 10</strong></a> </p><br><p>  The Java platform supports Unicode, to ensure that all character sets are processed.  Since Unicode was updated to <a href="https://unicode.org/versions/Unicode10.0.0/">version 10</a> , the JDK was also updated to support this version of the standard. </p><br><p>  I am always intrigued to see what Unicode developers include in newer versions.  Unicode 10 has 8,518 new characters.  This includes the bitcoya symbol, the N√ºshu character set (used by Chinese women for writing poetry), and Soyombo and Zanabazar Square (are the symbols used in historical Buddhist texts for writing Sanskrit, Tibetan and Mongolian).  There are also many other Emoji, including the long-awaited (apparently) <a href="https://emojipedia.org/face-with-one-eyebrow-raised/">Colbert Emoji</a> . </p><br><p>  Remember that starting with JDK 9, you can use UTF-8 in properties files (.properties).  This means that any Unicode character can be used in such files.  Including emojis.  Or N√ºshu. </p><br><p>  <a href="http://openjdk.java.net/jeps/328"><strong>JEP 328: Flight Recorder</strong></a> </p><br><p> Flight Recorder ‚Äî       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="http://openjdk.java.net/jeps/329"><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 ‚Äî     ,    ,    RC4. </p><br><p> <a href="http://openjdk.java.net/jeps/331"><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="http://openjdk.java.net/jeps/332"><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://datatracker.ietf.org/doc/rfc8446/">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="http://openjdk.java.net/jeps/333"><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://www.cubrid.org/blog/understanding-java-garbage-collection">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC ‚Äî region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="http://openjdk.java.net/jeps/335"><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="http://openjdk.java.net/jeps/336"><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 ‚Äî     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody">  findings </h3><br><p> JDK 11 ‚Äî   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://www.azul.com/downloads/zulu/"> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424683/">https://habr.com/ru/post/424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424673/index.html">CLRium # 4: .NET Community Meeting</a></li>
<li><a href="../424675/index.html">What happens in retail</a></li>
<li><a href="../424677/index.html">Brief history of the numeric keypad</a></li>
<li><a href="../424679/index.html">Repair computer peripherals essentials</a></li>
<li><a href="../424681/index.html">IT digest of October events (part one)</a></li>
<li><a href="../424685/index.html">The US Securities and Exchange Commission filed a lawsuit against the head of Tesla, Ilona Mask, including due to fraud</a></li>
<li><a href="../424687/index.html">These are the right bees: mechanical adaptation to dynamic effects</a></li>
<li><a href="../424689/index.html">Control of the situation makes you happy</a></li>
<li><a href="../424691/index.html">We invite you to the conference Azov Developers Meetup 2018 - October 13 in Taganrog</a></li>
<li><a href="../424693/index.html">Adding a watermark to all images of the site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>