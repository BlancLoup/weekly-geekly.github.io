<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple intent classifier</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time I learned how to use neural networks to understand what the user wants to achieve from the bot. What I did then had a number of drawbacks. F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple intent classifier</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/347496/">Last time</a> I learned how to use neural networks to understand what the user wants to achieve from the bot.  What I did then had a number of drawbacks.  First, I limited myself to only one kind of phrases.  Secondly, I used the ponderous nmt to get the intent out of the phrase.  At the same time, such a problem is usually solved by ordinary classifiers. <br><a name="habracut"></a><br><h3>  More convenient generation of educational data </h3><br>  Last time, to generate phrases, I wrote <i>something</i> on a python.  Even for the only kind of phrases, this was too unsupported solution.  Now it required more variety, so writing on pure python was no longer interesting.  Especially when there is a more convenient tool - RiveScript. <br><br>  In RiveScript, I made templates for different phrases, and only intent and possibly some parameters are input, and the phrase is already generated in RiveScript. <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">make_sample</b> <div class="spoiler_text"><pre><code class="python hljs">tag_var_re = re.compile(<span class="hljs-string"><span class="hljs-string">r'data-([az-]+)\((.*?)\)|(\S+)'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rs, cls, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> tokens = [cls] + list(args) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kwargs.items(): tokens.append(k) tokens.append(v) result = rs.reply(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>.join(map(str, tokens))).strip() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result == <span class="hljs-string"><span class="hljs-string">'[ERR: No Reply Matched]'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"failed to generate string for {}"</span></span>.format(tokens)) cmd, en, tags = [cls], [], [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tag, value, just_word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tag_var_re.findall(result): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> just_word: en.append(just_word) tags.append(<span class="hljs-string"><span class="hljs-string">'O'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: _, tag = tag.split(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, maxsplit=<span class="hljs-number"><span class="hljs-number">1</span></span>) words = value.split() en.append(words.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>)) tags.append(<span class="hljs-string"><span class="hljs-string">'B-'</span></span>+tag) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words: en.append(word) tags.append(<span class="hljs-string"><span class="hljs-string">'I-'</span></span>+tag) cmd.append(tag+<span class="hljs-string"><span class="hljs-string">':'</span></span>) cmd.append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>+value+<span class="hljs-string"><span class="hljs-string">'"'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cmd, en, tags</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">using</b> <div class="spoiler_text"><pre> <code class="python hljs"> rs = RiveScript(utf8=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) rs.load_directory(os.path.join(this_dir, <span class="hljs-string"><span class="hljs-string">'human_train_1'</span></span>)) rs.sort_replies() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'yes'</span></span>, <span class="hljs-string"><span class="hljs-string">'no'</span></span>, <span class="hljs-string"><span class="hljs-string">'ping'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(COUNT): add_sample(make_sample(rs, c)) to_remind = [<span class="hljs-string"><span class="hljs-string">'wash hands'</span></span>, <span class="hljs-string"><span class="hljs-string">'read books'</span></span>, <span class="hljs-string"><span class="hljs-string">'make tea'</span></span>, <span class="hljs-string"><span class="hljs-string">'pay bills'</span></span>, <span class="hljs-string"><span class="hljs-string">'eat food'</span></span>, <span class="hljs-string"><span class="hljs-string">'buy stuff'</span></span>, <span class="hljs-string"><span class="hljs-string">'take a walk'</span></span>, <span class="hljs-string"><span class="hljs-string">'do maki-uchi'</span></span>, <span class="hljs-string"><span class="hljs-string">'say hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'say yes'</span></span>, <span class="hljs-string"><span class="hljs-string">'say no'</span></span>, <span class="hljs-string"><span class="hljs-string">'play games'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(COUNT): r = random.choice(to_remind) add_sample(make_sample(rs, <span class="hljs-string"><span class="hljs-string">'remind'</span></span>, r))</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">RiveScript</b> <div class="spoiler_text"><pre> <code class="hljs lua">+ hello - hello - hey - hi + ping - {@hello}{<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>}|, sweetie{/<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>} - {@hello} there - {<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>}are |{/<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>}you {<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>}here|there{/<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>}? - ping - yo + yes - yes - yep - yeah + no - no - <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> yet - nope</code> </pre><pre> <code class="hljs pgsql">+ remind * @ maybe-please remind-<span class="hljs-keyword"><span class="hljs-keyword">without</span></span>-please data-remind-action(&lt;star&gt;) + remind-<span class="hljs-keyword"><span class="hljs-keyword">without</span></span>-please * - remind me <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &lt;star&gt; - remind me data-remind-<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>({@<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &lt;star&gt; - remind me <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &lt;star&gt; data-remind-<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>({@<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>}) + <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> - today - later - tomorrow + maybe-please * - &lt;@&gt; {weight=<span class="hljs-number"><span class="hljs-number">3</span></span>} - please, &lt;@&gt; - &lt;@&gt;, please</code> </pre> </div></div></div></div><br>  As a result of such tricks it turns out something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Source line for generation: <code>remind do maki-uchi</code> <br>  Derived from RiveScript: <code>please, remind me data-remind-when(tomorrow) to data-remind-action(do maki-uchi)</code> <br>  String "in English": <code>please, remind me tomorrow to do maki-uchi</code> <br>  Bots line: <code>remind when: "tomorrow" what: "do maki-uchi"</code> <br>  Related tags: <code>OOO B-when O B-action I-action</code> <br><br>  Although the tags are not needed for classification, they will be needed later for the tagger. <br><br><h3>  Self classifier </h3><br>  My main problem last time was complete ignorance of terminology.  Now I already know some keywords, so I just drove into the search engine "classify sentence tensorflow" and got a bunch of more or less usable materials.  However, even this was not required, because I had already saved a <a href="https://machinelearningmastery.com/use-word-embedding-layers-deep-learning-keras/">bookmark</a> , which almost completely suited me.  I especially liked the fact that there is no need for a separate dictionary, because the model proposed there can build word embeddings directly from the test suite. <br><br><div class="spoiler">  <b class="spoiler_title">word embeddings</b> <div class="spoiler_text">  To be honest, for a long time I did not understand what word embeddings is.  In fact, this is just a kind of dictionary in which each word corresponds to a vector of floats, and for ‚Äúclose‚Äù words these vectors will be close.  Whatever that means. </div></div><br>  The network shown in the example requires only one thing - so that instead of words a list of integers is supplied to it.  Of course, I could make a list of all available words and replace each word with its number in this list.  But it would not be very interesting.  Moreover, the example proposed to use the function one_hot, which is part of keras.preprocessing.text. <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">classifier itself</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_embed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sentence)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> one_hot(sentence, HASH_SIZE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_make_classifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_length, vocab_size, class_count)</span></span></span><span class="hljs-function">:</span></span> result = Sequential() result.add(Embedding(vocab_size, <span class="hljs-number"><span class="hljs-number">8</span></span>, input_length=input_length)) result.add(Flatten()) result.add(Dense(class_count, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)) result.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'acc'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prep_func, train, validation=None, epochs=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, verbose=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> X, y = prep_func(*train) validation_data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> validation <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> prep_func(*validation) model.fit(X, y, epochs=epochs, verbose=verbose, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, validation_data=validation_data) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translator</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, class_count=None, cls=None, lb=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> class_count <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lb <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Class count is not known"</span></span>) self.max_length = <span class="hljs-number"><span class="hljs-number">32</span></span> self.lb = lb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> LabelBinarizer() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> class_count <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lb <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: class_count = len(lb.classes_) self.classifier = cls <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> _make_classifier(self.max_length, HASH_SIZE, class_count) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_classifier_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, lines, labels)</span></span></span><span class="hljs-function">:</span></span> X = pad_sequences([_embed(line) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lines], padding=<span class="hljs-string"><span class="hljs-string">'post'</span></span>, maxlen=self.max_length) y = self.lb.transform(labels) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X, y <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train_classifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, lines, labels, validation=None)</span></span></span><span class="hljs-function">:</span></span> _train(self.classifier, self._prepare_classifier_data, (lines, labels), validation) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">classifier_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, lines, labels)</span></span></span><span class="hljs-function">:</span></span> X = pad_sequences([_embed(line) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lines], padding=<span class="hljs-string"><span class="hljs-string">'post'</span></span>, maxlen=self.max_length) y = self.lb.transform(labels) loss, accuracy = self.classifier.evaluate(X, y) print(loss, accuracy*<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">classify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, line)</span></span></span><span class="hljs-function">:</span></span> res = self._classifier_predict(line) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max(res[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &gt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.lb.inverse_transform(res)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'unknown'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">classify2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, line)</span></span></span><span class="hljs-function">:</span></span> res = self._classifier_predict(line) print(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>.join(map(str, zip(self.lb.classes_, res[<span class="hljs-number"><span class="hljs-number">0</span></span>])))) m = max(res[<span class="hljs-number"><span class="hljs-number">0</span></span>]) c = self.lb.inverse_transform(res)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0.05</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'probably '</span></span> + c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'unknown '</span></span> + c + <span class="hljs-string"><span class="hljs-string">'? '</span></span> + str(m)</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">training</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_sentences</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fen: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [l.strip() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fen.readlines()] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_labels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fpa: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [line.strip().split(maxsplit=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fpa]</code> </pre> <pre> <code class="python hljs"> sentences = load_sentences(os.path.join(data_dir, <span class="hljs-string"><span class="hljs-string">"train.en"</span></span>)) labels = load_labels(os.path.join(data_dir, <span class="hljs-string"><span class="hljs-string">"train.pa"</span></span>)) tags = load_sentences(os.path.join(data_dir, <span class="hljs-string"><span class="hljs-string">"train.tg"</span></span>)) label_count = len(set(labels)) translator = Translator(label_count) translator.lb.fit(labels) translator.train_classifier(sentences, labels)</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">using</b> <div class="spoiler_text"><pre> <code class="python hljs"> classifier = model_from_json(os.path.join(data_dir, <span class="hljs-string"><span class="hljs-string">"trained.cls"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(os.path.join(data_dir, <span class="hljs-string"><span class="hljs-string">"trained.lb"</span></span>), <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> labels_file: lb = pickle.load(labels_file) translator = Translator(lb=lb, cls=classifier, tagger=tagger) line = <span class="hljs-string"><span class="hljs-string">' '</span></span>.join(sys.argv) print(translator.classify2(line))</code> </pre> </div></div></div></div><br>  I composed the first 4 classes of phrases (yes, no, ping and remind), implemented saving and loading and decided to try.  To my surprise, the classifier incorrectly translated even phrases from the training set.  Then I added a test score to the learning script.  This estimate showed an accuracy of 98-99%.  Then I copied the translation script, but instead of analyzing the phrase argument, I sent the cross-validation again.  And got the result in 25%.  Just as if the neural network randomly chose one of four classes. <br><br>  The one_hot function came under suspicion.  I was embarrassed that to encode words you only need to know the size of the dictionary, but not the content.  Experiments have shown that one_hot will produce the same results within the same script run, but different for different launches.  After unsuccessful attempts to use something else, I decided to read the documentation more carefully. <br><br>  As it turned out, for good reason. <br><blockquote>  <b>one_hot</b> <br>  One-hot encodes a text into a vocabulary of size n. <br>  This is a wrapper function. </blockquote>  Here, it would seem, nothing hints. <blockquote>  <b>hashing_trick</b> <br>  Converts in a fixed-size hashing space </blockquote>  It seems too nothing.  But if you still look below at the list of arguments ... <blockquote>  <b>hash_function</b> : defaults to python <code>hash</code> function, can be 'md5' or any function.  It is not a consistent hashing function. </blockquote>  I changed one_hot to hashing_trick from md5, but the result did not change, I received the same 25% correct answers.  Using one_hot was certainly a mistake, but not the only one. <br><br>  The next suspect was the save and load function of the trained neural network.  As it turned out, model.to_json and model_from_json work only with the network model, but do not save or load weight.  And to save the weights, it was also necessary to install the h5py package.  After correcting this annoying error, I finally got results that are similar to the truth: <br> <code>$ ./translate4.py 'please, remind me to make some tea' <br> probably remind</code> <br> <br>  After that, I composed several more classes of phrases, bringing their total number to 10. With different variants, it turned out 13 - two options for remind (one action or two) and three options for find (search by one key phrase, or by two with AND and with OR). <br><br><h3>  Result </h3><br>  I got a simple classifier, which quickly (a few seconds) learns and gives good results.  Much better than using nmt for this.  The next step should be a tagger.  I could again use the finished sequence tagging, but I really do not want to keep the multi-gigabyte GloVe.  Therefore, I continue this experiment, trying to make a tagger that would suit me.  So far unsuccessfully. <br><br>  At some point, messing with the tagger, I almost gave up.  But then I came across <a href="https://habrahabr.ru/company/yandex/blog/349372/">an article about Alice</a> .  Just the day before, I decided to distract myself from analyzing the text in the direction of how the brain should work.  What I was able to come up with turned out to be the first step in the direction of how it was done in Alice.  Plus, again, we are talking about semantic analysis of phrases.  And they did it.  So you can hope that I can too.  But I‚Äôll understand how to use bidirectional LSTM instead of the usual ones, and what state-of-the-art is, and so on. <br><br>  All the code for my experiments is available <a href="https://github.com/aragaer/human2pa/tree/test_4">in a githaba</a> . </div><p>Source: <a href="https://habr.com/ru/post/348224/">https://habr.com/ru/post/348224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348212/index.html">Game development for NES in C. Chapters 4-6. Drawing character</a></li>
<li><a href="../348214/index.html">Transcription of geographical names in Open Street Map. Latvia, Lithuania, Poland, Estonia</a></li>
<li><a href="../348218/index.html">New lite text markup language based on pair quotes (pq)</a></li>
<li><a href="../348220/index.html">Reason on which database to choose</a></li>
<li><a href="../348222/index.html">The second part of the comparison of python and tcl</a></li>
<li><a href="../348226/index.html">Developing a game for Android on Python based on Kivy. From A to Z: pitfalls and non-obvious solutions. Part 1</a></li>
<li><a href="../348228/index.html">News from the world of OpenStreetMap ‚Ññ393 (01/23/2018-29.01.2018)</a></li>
<li><a href="../348230/index.html">GCCGO versus "standard" implementation</a></li>
<li><a href="../348232/index.html">3CX v15.5 SP3 Beta: updated conferences, improved hosting and new pricing policy</a></li>
<li><a href="../348234/index.html">Telegram bots. Downloading files larger than 50mb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>