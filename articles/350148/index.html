<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part XIII: I18n and L10n (Edition 2018)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Miguel grinberg 



 There 


 This is the thirteenth part of the Flask Mega-Tutorial series, in which I will tell you how to implement multi-language...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part XIII: I18n and L10n (Edition 2018)</h1><div class="post__text post__text-html js-mediator-article"><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/349604/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This is the thirteenth part of the Flask Mega-Tutorial series, in which I will tell you how to implement multi-language support for your application.  As part of this work, you will also learn about creating your own CLI extensions for flask. </p><br><p>  For reference, below is a list of articles in this series. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> (This article) </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  Chapter 21: User Notifications (Available April 24, 2018) </li><li>  Chapter 22: Reference Tasks (Available May 1, 2018) </li><li>  Chapter 23: Application Programming Interfaces (APIs) (Available May 8, 2018) </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work, or simply do not have the patience to wait for the article for a week, I (Miguel Greenberg) offer the full version of this manual (in English) in the form of an electronic book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  This chapter focuses on internationalization and localization, abbreviated as I18n and L10n.  In order to make the application accessible to people who do not speak English, a translation process will be implemented, which, with the help of language translation services, will allow me to offer users a language-application to choose from. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="vvedenie-v-flask-babel">  Introduction to Flask-Babel </h2><br><p>  As you probably already guessed, there is an extension Flask, which simplifies the work with translations.  The extension is called <a href="https://pythonhosted.org/Flask-Babel/">Flask-Babel</a> and is installed using pip: </p><br><pre><code class="plaintext hljs">(venv) $ pip install flask-babel</code> </pre> <br><p>  Flask-Babel is initialized, like most other Flask extensions: </p><br><blockquote>  <em><code>app/__init__.py</code></em> : Initializing Flask-Babel. </blockquote><br><pre> <code class="plaintext hljs"># ... from flask_babel import Babel app = Flask(__name__) # ... babel = Babel(app)</code> </pre> <br><p>  As an example, I will tell you how to translate the application into Spanish, as I happen to speak this language.  I could also work with translators who know other languages ‚Äã‚Äãand support them.  To keep track of the list of supported languages, add a configuration variable: </p><br><blockquote>  <em>config.py</em> : List of supported languages. </blockquote><br><pre> <code class="plaintext hljs">class Config(object): # ... LANGUAGES = ['en', 'es']</code> </pre> <br><p>  I use two-letter language codes for this application, but if you need to be more specific, you can add a country code.  For example, you can use <code>en-US</code> , <code>en-GB</code> and <code>en-CA</code> to support English with different dialects of the United States, United Kingdom, or Canada. </p><br><p>  The <code>Babel</code> instance is provided by the <code>localeselector</code> decorator.  The decorated function is called for each request to select the translation of the language to use: </p><br><blockquote>  <em><code>app/__init__.py</code></em> : Select your preferred language. </blockquote><br><pre> <code class="plaintext hljs">from flask import request # ... @babel.localeselector def get_locale(): return request.accept_languages.best_match(app.config['LANGUAGES'])</code> </pre> <br><p>  Here I use the attribute of the Flask <code>request</code> object, called <code>accept_languages</code> .  This object provides a high-level interface for working with the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language">Accept-Language</a> header sent by clients with the request.  This header indicates the client‚Äôs language and language preferences as a weighted average.  The contents of this header can be configured on the browser settings page, while the default is usually imported from the language settings in the computer's operating system.  Most people do not even know that such a setting exists, but this is useful because users can provide a list of preferred languages, each of which has weight.  If you're interested, here's an example of the <code>Accept-Languages</code> complex header: </p><br><pre> <code class="plaintext hljs">Accept-Language: da, en-gb;q=0.8, en;q=0.7</code> </pre> <br><p>  We see that Danish ( <code>da</code> ) is the preferred language (the default weight value is 1.0), followed by British English ( <code>en-gb</code> ) with a weight of 0.8, and as a last option General English ( <code>en</code> ) with a weight of 0.7 . </p><br><p>  To choose the best language, you need to compare the list of languages ‚Äã‚Äãrequested by the client with the languages ‚Äã‚Äãthat the application supports, and using the weights provided by the client, find the best language.  Perhaps this logic seems too complicated to you, but all this is encapsulated into the <code>best_match()</code> method, which takes the list of languages ‚Äã‚Äãoffered by the application as an argument and returns the best choice. </p><br><h2 id="markirovka-tekstov-dlya-perevoda-v-ishodnom-kode-python">  Text marking for translation in Python source code </h2><br><p>  Early rejoiced.  Now about the sad.  A typical workflow when creating an application in several languages ‚Äã‚Äãis to markup all texts that need translation in the source code.  After the texts are marked, Flask-Babel will scan all the files and extract these texts into a separate translation file using the <a href="https://www.gnu.org/software/gettext/">gettext</a> tool.  Unfortunately, this is a tedious task that needs to be completed for translation. </p><br><p>  I'm going to show you some examples of this labeling, but you can get a complete set of changes from the <a href="">package</a> for this chapter or the GitHub repository. </p><br><p>  The way in which texts are marked for translation is to wrap them in a function call, which is called as a <code>_()</code> convention, just an underscore.  The simplest cases are those where literal strings appear in the source code.  The following is an example of a flash () `statement: </p><br><pre> <code class="plaintext hljs">from flask_babel import _ # ... flash(_('Your post is now live!'))</code> </pre> <br><p>  The idea is that the <code>_()</code> function transfers the text to the base language (in this case, English).  She will use the best language in her opinion, chosen by the <code>get_locale</code> function, decorated with the <code>localeselector</code> function, to find the right translation for this client.  Then the <code>_()</code> function will return the translated text, which in this case will be an argument for <code>flash()</code> . </p><br><p>  Unfortunately, not all cases are so simple.  Consider this other <code>flash()</code> call from the application: </p><br><pre> <code class="plaintext hljs">flash('User {} not found.'.format(username))</code> </pre> <br><p>  This text has a dynamic component that is inserted in the middle of the static text.  The <code>_()</code> function has a syntax that supports this type of text, but is based on the old string substitution syntax: </p><br><pre> <code class="plaintext hljs">flash(_('User %(username)s not found.', username=username))</code> </pre> <br><p>  There is an even more difficult case.  Some string literals are assigned outside the request, usually when the application is launched, so when these texts are evaluated, there is no way to know which language to use.  Examples of this are labels associated with form fields.  The only solution for processing these texts is to find a way to postpone the evaluation of the string until it is used, which will be under the actual query.  Flask-Babel provides a <em>lazy evaluation</em> version of the <code>_()</code> deferred calculation, called <code>lazy_gettext()</code> : </p><br><pre> <code class="plaintext hljs">from flask_babel import lazy_gettext as _l class LoginForm(FlaskForm): username = StringField(_l('Username'), validators=[DataRequired()]) # ...</code> </pre> <br><p>  Here I import the alternative translation function and rename it to <code>_l ()</code> , so that it was similar in name to the original <code>_()</code> .  This new function transfers the text to a special object containing the translation method, which will take place later, when the string is used. </p><br><p>  The Flask-Login extension displays a message every time a user is redirected to the login page.  This message is written in English and is formed in the defaults of the extension itself.  To make sure that this message is also translated, I am going to override the default message and provide another option decorated by the <code>_l()</code> function for a deferred call: </p><br><pre> <code class="plaintext hljs">login = LoginManager(app) login.login_view = 'login' login.login_message = _l('Please log in to access this page.')</code> </pre> <br><h2 id="razmetka-tekstov-dlya-perevoda-v-shablonah">  Markup of texts for translation in templates </h2><br><p>  In the previous section, you saw how to mark up translatable texts in the source code of Python modules, but this is only part of the process, since the template files also contain text.  The <code>_()</code> function is also available in templates, so the process is very similar.  For example, consider this HTML fragment from <em>404.html</em> : </p><br><pre> <code class="plaintext hljs">&lt;h1&gt;File Not Found&lt;/h1&gt;</code> </pre> <br><p>  Version with translation support: </p><br><pre> <code class="plaintext hljs">&lt;h1&gt;{{ _('File Not Found') }}&lt;/h1&gt;</code> </pre> <br><p>  Note that here, besides wrapping text with <code>_()</code> , you need to add <code>{{...}}</code> to make <code>_()</code> compute instead of being considered a literal in the template. </p><br><p>  For more complex phrases containing dynamic components, you can use arguments: </p><br><pre> <code class="plaintext hljs">&lt;h1&gt;{{ _('Hi, %(username)s!', username=current_user.username) }}&lt;/h1&gt;</code> </pre> <br><p>  There is a particularly difficult case in <em><code>_post.html</code></em> , which made me understand: </p><br><pre> <code class="plaintext hljs"> {% set user_link %} &lt;a href="{{ url_for('user', username=post.author.username) }}"&gt; {{ post.author.username }} &lt;/a&gt; {% endset %} {{ _('%(username)s said %(when)s', username=user_link, when=moment(post.timestamp).fromNow()) }}</code> </pre> <br><p>  The problem here is that I wanted the username to be a link pointing to the user profile page, not just a name, so I had to create an intermediate variable called <code>user_link</code> using the <code>set</code> and <code>endset</code> template directives and then pass this as translation function argument. </p><br><p>  As I mentioned above, you can <a href="">download a</a> version of the application with all the translated texts in the Python source code and templates. </p><br><h2 id="izvlechenie-teksta-dlya-perevoda">  Extract text for translation </h2><br><p>  After you have an application with all <code>_()</code> and <code>_l()</code> in place, you can use the <code>pybabel</code> command to extract them into the <em>a.pot</em> file, which means <em><a href="https://ru.wikipedia.org/wiki/Gettext">portable object template</a></em> .  This is a text file containing all texts that have been marked as needing translation.  The purpose of this file is to serve as a template for creating translation files into any other language. </p><br><p>  The extraction process requires a small configuration file that tells <code>pybabel</code> which files to scan for translatable texts.  Below you can see the <em>babel.cfg</em> that I created for this application: </p><br><blockquote>  <em>babel.cfg</em> : PyBabel configuration file. </blockquote><br><pre> <code class="plaintext hljs">[python: app/**.py] [jinja2: app/templates/**.html] extensions=jinja2.ext.autoescape,jinja2.ext.with_</code> </pre> <br><p>  The first two lines define the names of the Python and Jinja2 template files, respectively.  The third line defines two extensions provided by the Jinja2 template engine, which help Flask-Babel correctly analyze template files. </p><br><p>  To extract all texts in a <em>.pot</em> file, you can use the following command: </p><br><pre> <code class="plaintext hljs">(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .</code> </pre> <br><p>  The <code>pybabel extract</code> command reads the configuration file specified in the <code>-F</code> parameter, and then scans all the <em>py</em> and <em>html</em> files in directories corresponding to the configured sources, starting from the directory specified in the command (current directory or <code>.</code> In this case.) By default, <code>pybabel</code> will be look for <code>_()</code> as a text marker, but I also used the <em>lazy</em> option, which I imported as <code>_l()</code> , so I need to tell the search tool with the <code>-k</code> <code>_l</code> option.  The <code>-o</code> parameter specifies the name of the output file. </p><br><p>  I should note that <em>messages.pot is</em> not a file that should be included in the project.  This is a file that can be easily regenerated at any time simply by running the command above again.  Thus, there is no need to transfer this file to the version control system. </p><br><h2 id="sozdanie-language-catalog">  Creating a Language Catalog </h2><br><p>  The next step in the process is to create a translation for each language, which will be supported in addition to the basic one, which in this case is English.  I said that I was going to start by adding Spanish ( <code>es</code> language code), so the command that does this is: </p><br><pre> <code class="plaintext hljs">(venv) $ pybabel init -i messages.pot -d app/translations -l es creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot</code> </pre> <br><p>  The <code>pybabel init</code> command takes the <code>messages.pot</code> file as input and creates a new directory for a specific language specified in the <code>-l</code> parameter to the directory specified in the <code>-d</code> parameter.  I will save all translations in the <em>app / translations</em> directory, because there Flask-Babel will look for the default translation files.  The command will create an <code>es</code> subdirectory inside this directory for Spanish data.  In particular, there will be a new file called <em>app / translations / es / LC_MESSAGES / messages.po</em> .  That is where the translations should be made. </p><br><p>  If you want to support other languages, then repeat the above command with each of the language codes.  So that each language gets its own repository with the file <em>messages.po</em> . </p><br><p>  This <em>messages.po</em> file created in each language repository uses a format that is the de facto standard for language translations, the format used by the <a href="http://www.gnu.org/software/gettext/">gettext</a> utility.  Here are a few lines of the beginning of Spanish messages.po: </p><br><pre> <code class="plaintext hljs"># Spanish translations for PROJECT. # Copyright (C) 2017 ORGANIZATION # This file is distributed under the same license as the PROJECT project. # FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, 2017. # msgid "" msgstr "" "Project-Id-Version: PROJECT VERSION\n" "Report-Msgid-Bugs-To: EMAIL@ADDRESS\n" "POT-Creation-Date: 2017-09-29 23:23-0700\n" "PO-Revision-Date: 2017-09-29 23:25-0700\n" "Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n" "Language: es\n" "Language-Team: es &lt;LL@li.org&gt;\n" "Plural-Forms: nplurals=2; plural=(n != 1)\n" "MIME-Version: 1.0\n" "Content-Type: text/plain; charset=utf-8\n" "Content-Transfer-Encoding: 8bit\n" "Generated-By: Babel 2.5.1\n" #: app/email.py:21 msgid "[Microblog] Reset Your Password" msgstr "" #: app/forms.py:12 app/forms.py:19 app/forms.py:50 msgid "Username" msgstr "" #: app/forms.py:13 app/forms.py:21 app/forms.py:43 msgid "Password" msgstr ""</code> </pre> <br><p>  If you skip the header, you can see that below is a list of strings that were extracted from the <code>_()</code> and <code>_l()</code> calls.  For each text you get a link to the location of the text in the application.  Then the string <code>msgid</code> contains the text in the base language, and the next line <code>msgstr</code> contains the empty string.  These blank lines must be edited to have the text in the target language. </p><br><p>  There are <a href="https://localise.biz/free/poeditor">many applications</a> that work with the translation of <code>.po</code> files.  If you feel comfortable when editing a text file, then this is sufficient, but if you are working with a large project, then it may be recommended to work with a specialized editor.  The most popular translation application is open source <code>poedit</code> , which is available for all major operating systems.  If you are familiar with <code>VIM</code> , then the <code>po.vim</code> plugin provides some key mappings that make working with these files easier. </p><br><p>  Below you can see part of the Spanish version of <em>messages.po</em> after I added the translation: </p><br><pre> <code class="plaintext hljs">#: app/email.py:21 msgid "[Microblog] Reset Your Password" msgstr "[Microblog] Nueva Contrase√±a" #: app/forms.py:12 app/forms.py:19 app/forms.py:50 msgid "Username" msgstr "Nombre de usuario" #: app/forms.py:13 app/forms.py:21 app/forms.py:43 msgid "Password" msgstr "Contrase√±a"</code> </pre> <br><p>  <a href="">The download package</a> for this chapter also contains this file, so you do not have to worry about this part of the application. </p><br><p>  The file <em>messages.po</em> is a kind of source file for translations.  If you want to start using these translated texts, the file must be compiled into a format that is effective for the application to use at run time.  To collect all translations for an application, you can use the <code>pybabel compile</code> as follows: </p><br><pre> <code class="plaintext hljs">(venv) $ pybabel compile -d app/translations compiling catalog app/translations/es/LC_MESSAGES/messages.po to app/translations/es/LC_MESSAGES/messages.mo</code> </pre> <br><p>  This operation adds the <em>messages.mo</em> file next to the <em>messages.po</em> in each language repository.  The <em>.mo</em> file is the file that Flask-Babel will use to download translations to the application. </p><br><p>  After creating <em>messages.mo</em> for Spanish or any other languages ‚Äã‚Äãadded to the project, these languages ‚Äã‚Äãare ready for use in the application.  If you want to see how the application looks in Spanish, you can change the language configuration in a web browser so that Spanish is the preferred language.  For Chrome, this is the extended part in the settings: </p><br><p><img src="https://habrastorage.org/webt/sf/tf/rv/sftfrvpmnttmnnigxi7mq6i52a0.jpeg"></p><br><p>  If you prefer not to change your browser settings, another alternative is to force the use of a language, forcing the <code>localeselector</code> function <code>localeselector</code> always return the same.  For Spanish, it looks like this: </p><br><blockquote>  <em><code>app/__init__.py</code></em> : Spanish selection (directive). </blockquote><br><pre> <code class="plaintext hljs">@babel.localeselector def get_locale(): # return request.accept_languages.best_match(app.config['LANGUAGES']) return 'es'</code> </pre> <br><p>  Running the application in a browser configured in Spanish, or in the case of forcing the <code>es</code> value of the <code>localeselector</code> , will cause all texts to appear in Spanish in the application. </p><br><h2 id="obnovlenie-perevodov">  Update translations </h2><br><p>  One of the common situations when working with translations is that you can start using the translation file, even if it is incomplete.  This is perfectly normal; you can compile incomplete files <em>messages.po</em> .  In this case, po-files and any available translations will be used, and the missing ones will use the base language.  Then you can continue working on the translations and compile to update <em>messages.mo</em> . </p><br><p>  Another common occurrence is if you skipped some texts when adding <code>_()</code> wrappers.  In this case, you will see that the texts you have missed will remain in English, because Flask-Babel does not know anything about them.  In this case, you need to add <code>_()</code> or <code>_l()</code> wrappers when detecting texts that do not have them, and then perform an update procedure that includes two steps: </p><br><pre> <code class="plaintext hljs">(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot . (venv) $ pybabel update -i messages.pot -d app/translations</code> </pre> <br><p>  The <code>extract</code> command is identical to the one I described earlier, but now it will generate a new version of <em>messages.pot</em> with all the previous texts, plus something new that you have recently wrapped with <code>_()</code> or <code>_l()</code> .  An update call accepts a new <em>messages.pot</em> file and merges it into all the <em>messages.po</em> files associated with the project.  It will be an intelligent merge, in which any existing texts will be left alone, while only entries that have been added or deleted in <em>messages.pot</em> will be affected. </p><br><p>  After updating <em>messages.po,</em> you can continue and translate all new tests, and then compile the messages again to make them available to the application. </p><br><h2 id="perevod-dat-i-vremeni">  Date and time translation </h2><br><p>  Now I have a complete Spanish translation for all the texts in the Python code and templates.  But if you run the application in Spanish and are a good observer, then you will notice that there are a few more places that have remained in English.  I mean timestamps created by Flask-Moment and moment.js, which obviously were not included in the translation, because none of the texts created by these packages is part of the source code or application template. </p><br><p>  moment.js supports localization and internationalization, so all I need to do is configure the correct language.  Flask-Babel returns the selected language and locale for this case using the <code>get_locale()</code> function, so I'm going to add a locale to the <code>g</code> object in order to access it from the base template: </p><br><blockquote>  <em><code>app/routes.py</code></em> : Save the selected language in flask.g. </blockquote><br><pre> <code class="plaintext hljs"># ... from flask import g from flask_babel import get_locale # ... @app.before_request def before_request(): # ... g.locale = str(get_locale())</code> </pre> <br><p>  The <code>get_locale()</code> function from Flask-Babel returns an object, but I just want to have a language code that can be obtained by converting an object to a string.  Now that I have <code>g.locale</code> , I can access it from the base template to set up <em>moment.js</em> with the correct language: </p><br><blockquote>  <em>app / templates / base.html</em> : Set the locale for moment.js. </blockquote><br><pre> <code class="plaintext hljs">... {% block scripts %} {{ super() }} {{ moment.include_moment() }} {{ moment.lang(g.locale) }} {% endblock %}</code> </pre> <br><p>  And now all dates and times should appear in the same language as the text.  Below you can see how the app looks in Spanish: </p><br><p><img src="https://habrastorage.org/webt/q5/gm/ly/q5gmly3xs-mlkq4coeppx2-4u_i.png"></p><br><p>  At this stage, all texts, except those that were provided by the user in blog posts or profile descriptions, should be translated into other languages. </p><br><h2 id="usovershenstvovaniya-dlya-komandnoy-stroki">  Command line enhancements </h2><br><p>  You will probably agree with me that the <code>pybabel</code> commands are long and hard to remember.  I'm going to use this feature to show you how you can create custom commands integrated with the flask command.  So far you have seen the use of <code>flask run</code> , <code>flask shell</code> , and several <code>flask db</code> sub-commands in Flask-Migrate.  In fact, it is easy to add application-specific commands to flask.  So now I'm going to create some simple commands that run the <code>pybabel</code> with all the arguments that are specific to this application.  The commands I'm going to add are: </p><br><ul><li>  <code>flask translate init LANG</code> add new language </li><li>  <code>flask translate update</code> update all language repositories </li><li>  <code>flask translate compile</code> to compile all language repositories </li></ul><br><p>  <code>babel export</code> will not be a command, because the generation of the <em>messages.pot</em> file is always a prerequisite for the execution of <code>init</code> or <code>update</code> commands.  Therefore, the implementation of these commands will generate the translation template file as a temporary file. </p><br><p>  Flask relies on <a href="http://click.pocoo.org/5/">Click</a> for all its command-line operations.  Commands, such as <code>translate</code> , which are the root for several subcommands, are created using the <code>app.cli.group()</code> decorator.  I'm going to put these commands in a new module called <em>app / cli.py</em> : </p><br><blockquote>  <em>app / cli.py</em> : Translate a group of commands. </blockquote><br><pre> <code class="plaintext hljs">from app import app @app.cli.group() def translate(): """Translation and localization commands.""" pass</code> </pre> <br><p>       ,      docstring.    ,        ,      . </p><br><p> <code>Update</code> -  <code>compile</code> -  ,      : </p><br><blockquote> <em>app/cli.py</em> :     . </blockquote><br><pre> <code class="plaintext hljs">import os # ... @translate.command() def update(): """Update all languages.""" if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'): raise RuntimeError('extract command failed') if os.system('pybabel update -i messages.pot -d app/translations'): raise RuntimeError('update command failed') os.remove('messages.pot') @translate.command() def compile(): """Compile all languages.""" if os.system('pybabel compile -d app/translations'): raise RuntimeError('compile command failed')</code> </pre> <br><p>  ,           <code>translate</code> .    ,   <code>translate()</code> ‚Äî  ,    ,  Click   .  ,     <code>translate()</code> , <em>docstrings</em> -            <em>--help</em> . </p><br><p>   ,    ,         .  ,        .    ,    <code>RuntimeError</code> ,     .  <code>update()</code>        ,     ,    <em>messages.pot</em>   ,            . </p><br><p>  <code>init</code>       .  : </p><br><blockquote> <em>app/cli.py</em> : <strong>Init</strong> ‚Äî sub- . </blockquote><br><pre> <code class="plaintext hljs">import click @translate.command() @click.argument('lang') def init(lang): """Initialize a new language.""" if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'): raise RuntimeError('extract command failed') if os.system( 'pybabel init -i messages.pot -d app/translations -l ' + lang): raise RuntimeError('init command failed') os.remove('messages.pot')</code> </pre> <br><p>     <code>@click.argument</code>    . Click  ,        ,        <code>init</code> . </p><br><p>         ,   .       <em>microblog.py</em>    : </p><br><blockquote> <em>microblog.py</em> :    . </blockquote><br><pre> <code class="plaintext hljs">from app import cli</code> </pre> <br><p>  ,    ,     <em>cli.py</em> ,     -  ,           . </p><br><p>   ,  <code>flask --help</code>   <code>translate</code>   .  <code>flask translate --help</code>    -,   : </p><br><pre> <code class="plaintext hljs">(venv) $ flask translate --help Usage: flask translate [OPTIONS] COMMAND [ARGS]... Translation and localization commands. Options: --help Show this message and exit. Commands: compile Compile all languages. init Initialize a new language. update Update all languages.</code> </pre> <br><p>   ,            .    , : </p><br><pre> <code class="plaintext hljs">(venv) $ flask translate init &lt;language-code&gt;</code> </pre> <br><p>         <code>_()</code>  <code>_l()</code> : </p><br><pre> <code class="plaintext hljs">(venv) $ flask translate update</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">(venv) $ flask translate compile</code> </pre> <br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/349604/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350148/">https://habr.com/ru/post/350148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350136/index.html">Random evolutionary strategies in machine learning</a></li>
<li><a href="../350138/index.html">How to whale eat java application and not choke</a></li>
<li><a href="../350140/index.html">Asynchronous work with PostgreSQL in C</a></li>
<li><a href="../350142/index.html">Development of an external battery on four LiFePO4 batteries</a></li>
<li><a href="../350144/index.html">Richard Hamming: Chapter 29. You get what you measure</a></li>
<li><a href="../350152/index.html">We are testing the array of OceanStor Dorado V3: so ordinary that right at all</a></li>
<li><a href="../350154/index.html">ViyaDB: analytical database for unsorted data</a></li>
<li><a href="../350156/index.html">Learn OpenGL. Lesson 4.8 - Advanced GLSL</a></li>
<li><a href="../350158/index.html">SMEV 3. Electronic signature of messages in Java and CryptoPro</a></li>
<li><a href="../350160/index.html">30 seconds CSS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>