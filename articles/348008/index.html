<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are friends of gRPC with a long-lived project, PHP and front-end</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of years ago we fairly quietly worked with our small team and did hosting. It turned out that each service in the system had its own unique a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are friends of gRPC with a long-lived project, PHP and front-end</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/6e/ou/g0/6eoug0fgey9ltcwivzplzu1vwzo.png"></p><br><p>  A couple of years ago we fairly quietly worked with our small team and did hosting.  It turned out that each service in the system had its own unique and unique API.  But then it became a problem and it was decided to redo everything. </p><br><p>  We will talk about how to combine the external API with the internal one and what to do if you have a lot of PHP code, but you want to take advantage of gRPC. </p><a name="habracut"></a><br><p>  Now they talk a lot about microservices and SOA in general.  Our infrastructure is no exception: after all, we are engaged in hosting and our services allow us to manage almost a thousand servers. </p><br><p>  Over time, services in our system began to appear more and more: have become a domain registrar - we register in a separate service;  there are a lot of server metrics - we are writing a service that does samples from ClickHouse / InfluxDB;  You need to make an emulator of launching tasks ‚Äúlike through Crontab‚Äù;  for users - we write service.  It will probably be familiar to many. </p><br><p>  Inbound tasks in developing a lot.  The number of different services is growing smoothly and, seemingly, unnoticed.  It is impossible to take into account all the future nuances in advance, therefore one API was replaced by <em>other, better ones</em> .  But the day came when it became apparent that <strong>too many protocols were divorced</strong> : </p><br><p><img src="https://habrastorage.org/webt/dv/x3/nu/dvx3nurva8bge9aleuaognqxw1w.png"></p><br><p>  The more services and connections between them became, the longer and more difficult it was to solve problems: it was necessary to study several different APIs, write clients to them and only then begin the real work. </p><br><p>  Oh, yes ... because the documentation is also needed.  Otherwise the following dialogues take place in chat: <br>  - <em>Guys, how can I get user balance from billing?</em> <br>  - <em>Make a call to billing / getBalance (customerId)</em> <br>  - <em>How to get a list of services?</em> <br>  - <em>I do not remember, look for the desired controller in</em> <br></p><p>  In short, the dream of a magical single standard and technology for creating a network API, which will solve all the problems and save us time, has arisen. </p><br><h2 id="formiruem-trebovaniya">  We form requirements </h2><br><p>  A little thought, we made a small list of requirements: </p><br><ul><li>  The API description method used should be declarative. </li><li>  The result should be unambiguous and human-readable: you need to carry out code review </li><li>  We need the ability to describe both a successful flow and errors.  And this should be done explicitly for each method. </li><li>  Based on the description, you need to generate as much boring code as possible for the client and server. </li></ul><br><p>  As a result of searches, evaluations and small tests, we stopped at <a href="https://grpc.io/">gRPC</a> .  This framework is not new and <a href="https://habrahabr.ru/company/infopulse/blog/265805/">has already been written</a> about it <a href="https://habrahabr.ru/company/infopulse/blog/265805/">on Habr√©</a> . </p><br><p>  Out of the box, he met almost all of our requirements.  If in a nutshell: </p><br><ul><li>  Declarative description of methods and data structures </li><li>  It is very readable and simple.  It is easy to carry out code review on the resulting .proto files.  IDL syntax is close to popular PL </li><li>  Generators have been delivered for most of the popular PL (but there is a nuance. About it below) </li><li>  gRPC is simply an RPC mechanism with no strict API organization requirements.  This makes it possible to develop your own principles and guidelines based on the experience gained. </li></ul><br><p>  However, the ideal technology does not exist.  For us, there were several stumbling blocks: </p><br><ul><li>  We are actively using PHP <a href="https://github.com/grpc/grpc/issues/10221">and it does not know how to server gRPC</a> ; </li><li>  Our frontend is still waiting for the usual HTTP.  At the moment, we were forced to ‚Äúproxy‚Äù front-end requests through a separate application that generates the right requests to the internal API.  In most cases, this is an extra boring job.  I would like to give everything inside our system through one protocol with automatic conversion to HTTP for the frontend. </li></ul><br><p>  Fortunately, we solved these problems quite easily.  Further I will assume that the reader is familiar with gRPC.  If not, it is better to first refer to the article mentioned above. </p><br><div class="spoiler">  <b class="spoiler_title">But why you just did not use Swagger (OpenAPI)?!?</b>  <b class="spoiler_title">He's great!</b> <div class="spoiler_text"><p>  Yes indeed.  OpenAPI and the toolbox provided by Swagger look enticing. </p><br><p>  Immediately I must say that comparing OpenAPI and gRPC is not entirely correct.  gRPC is primarily a framework that solves the technical problem of RPC interaction.  It offers its own protocol, serialization method, service description language, and some tuling. </p><br><p>  OpenAPI is primarily <strong><em>a specification</em></strong> trying to become a single standard for describing interfaces.  Let it now be strongly oriented towards REST, but <a href="https://github.com/OAI/OpenAPI-Specification/issues/801">there are proposals to add support for RPC</a> .  Perhaps in the future, OpenAPI will become the modern equivalent of web services and WSDL. </p><br><p>  Nevertheless, our team found several arguments in favor of using gRPC instead of OpenAPI: </p><br><ul><li> First, OpenAPI as a specification is currently <strong>focused on interfaces built on REST principles</strong> .  In our system, most of the interactions between services are internal.  Using REST principles can often lead to unnecessary complication: it is not always possible to turn any method of the type <code>doSomethingVerySpecialShit</code> into the right resource available at its URL.  Well, or rather, of course you can (converting the verb-method into a noun), but it will look very alien.  There are no such problems with gRPC; </li><li>  Secondly, let's be honest: <strong><em>few developers can correctly and correctly design such an API</em></strong> .  At interviews, people often can not explain the meaning of the abbreviation REST =) Of course, this is a weak argument: with proper expertise in the company, everything can be taught.  But we decided that now it is better to spend time on other tasks; </li><li>  Thirdly, it is more convenient for us to share the description of services in the form of simple and understandable files that can be read fairly quickly and comfortably.  In our opinion, Protobuf definitely wins: the <strong><em>description of methods and structures due to its own IDL is close to popular PL</em></strong> .  OpenAPI offers to describe them in yaml or json.  Despite the fact that these formats are also accessible for perception, they still remain the same formats for data serialization, and not a full-fledged IDL; </li><li>  Fourth, gRPC has <a href="https://grpc.io/docs/guides/concepts.html">unidirectional and bidirectional streams</a> .  In OpenAPI, similar functions (as far as we could figure out) <a href="https://swagger.io/docs/specification/callbacks/">perform callbacks</a> .  It seems that this is a similar thing, but <a href="https://github.com/OAI/OpenAPI-Specification/issues/770">judging</a> by the <a href="https://github.com/OAI/OpenAPI-Specification/issues/396">proposals</a> , <strong>full-fledged bilateral streams have not yet been implemented</strong> , and we sometimes use them (for example, to transfer large blobs in parts). </li></ul><br><p>  If we sum up a little, then we can say that OpenAPI turned out to be too large for us and did not always offer adequate solutions.  I recall that our ultimate goal - to move to a single technical and organizational standard for RPC.  Implementing REST principles would require rethinking and refactoring many things, which would be a task from a completely different weight category. </p><br><p>  You can also read, for example, with <a href="https://medium.com/apis-and-digital-transformation/openapi-and-grpc-side-by-side-b6afb08f75ed">this article-comparison</a> .  In general, we agree with her. </p></div></div><br><h2 id="vse-lyubyat-php">  Everybody loves PHP </h2><br><p>  As I said above, we have a lot of business logic written in PHP.  If we <a href="https://grpc.io/docs/tutorials/basic/php.html">turn to the documentation</a> , then we will have a bummer: <strong>due to the peculiarities of the code execution model, it cannot act as a server</strong> (various reactphp does not count).  But it works well as a client and, if you feed the proto-file with the service description to the code generator, it will honestly generate classes for all structures (request and response).  So, the problem is completely solved. </p><br><p>  All that we found on the topic of how PHP works as a server is a <a href="https://groups.google.com/d/msg/grpc-io/F3IyYaI_6S0/Rh5cOUGIFwAJ">discussion on this topic in Google Groups</a> .  In this discussion, one of the participants said that they are working on the possibility of proxying gRPC in FastCGI (PHP-FPM wants to see it used by us).  This is exactly what we were looking for.  Unfortunately, we were unable to contact, find out the status of this project and participate in it. </p><br><p>  In this regard, it was decided to write a small proxy, which could accept requests and convert them to FactCGI.  Since gRPC runs on top of HTTP / 2 and the method call in it is in fact a regular HTTP request, the task is not complicated. </p><br><p>  As a result, we quickly made such a proxy in the Go language.  For its work, it requires only a small config with information about where to proxy.  We have <a href="https://github.com/LTD-Beget/grpc-to-fpm">published its</a> code <a href="https://github.com/LTD-Beget/grpc-to-fpm">for everyone</a> . </p><br><p>  The scheme of work is as follows: </p><br><ol><li>  Accept the request; </li><li>  Remove the body serialized in Protobuf from it; </li><li>  Form the headers for the FastCGI request; </li><li>  We send a FastCGI request to PHP-FPM; </li><li>  In PHP, we process the request.  We form the answer; </li><li>  We receive the answer, we convert to gRPC, we send to the addressee; </li></ol><br><p><img src="https://habrastorage.org/webt/re/ih/uu/reihuui2amsxwb0mn_sbigva2tu.png"></p><br><p>  Thus, the principle of processing a request in PHP is very simple: </p><br><ul><li>  The request body will be contained in the body ( <code>php://input</code> stream); </li><li>  The requested service and its method are contained in the query parameter <code>r</code> (we use Yii2 and its router wants to see the route in this parameter) </li></ul><br><div class="spoiler">  <b class="spoiler_title">For example, for such a service</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">'proto3'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> api.customer; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> CustomerService { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> getSomeInfo(GetSomeInfoRequest) returns (GetSomeInfoResponse) {} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> GetSomeInfoRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> login = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> GetSomeInfoResponse { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> first_name = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> second_name = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> </div></div><br><p>  When <code>getSomeInfo</code> requested, the <code>r</code> parameter will contain <code>api.customer.customer-service/get-some-info</code> . </p><br><p>  Concentrated example of request processing in the application: </p><br><div class="spoiler">  <b class="spoiler_title">example.php</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,    gRPC : // package.service-name/method-name $route = $_GET['r']; //  ,   protobuf $body = file_get_contents("php://input"); try { //       50% if (rand(0, 1)) { throw new \RuntimeException("Some error happened!"); } //        ,  // -,   ,      -  $request = new GetSomeInfoRequest; $request-&gt;parse($body); $customer = findCustomer($request-&gt;getLogin()); $response = (new GetSomeInfoResponse) -&gt;setFirstName($customer-&gt;getFirstName()); echo $response-&gt;serialize(); } catch (\Throwable $e) { //  -. //    ,  : // https://github.com/grpc/grpc-go/blob/master/codes/codes.go $errorCode = 13; header("X-Grpc-Status: ERROR"); header("X-Grpc-Error-Code: {$errorCode}"); header("X-Grpc-Error-Description: {$e-&gt;getMessage()}"); }</span></span></code> </pre> </div></div><br><p>  As you can see, everything is quite simple.  You can implement this logic in any popular framework and make a convenient layer of controllers in which all serialization / deserialization will occur automatically. </p><br><div class="spoiler">  <b class="spoiler_title">Our method handlers look something like this (we finished our Yii2)</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">app</span></span>\<span class="hljs-title"><span class="hljs-title">api</span></span>\<span class="hljs-title"><span class="hljs-title">controllers</span></span>\<span class="hljs-title"><span class="hljs-title">customer</span></span>\<span class="hljs-title"><span class="hljs-title">actions</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">app</span></span>\<span class="hljs-title"><span class="hljs-title">api</span></span>\<span class="hljs-title"><span class="hljs-title">base</span></span>\<span class="hljs-title"><span class="hljs-title">Action</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    protobuf  use app\generated\api\customer\GetSomeInfoRequest; use app\generated\api\customer\GetSomeInfoResponse; class GetSomeInfoAction extends Action { public function run(GetSomeInfoRequest $request): GetSomeInfoResponse { //         $customer = findCustomer($request-&gt;getLogin()); //   return (new GetSomeInfoResponse) -&gt;setFirstName($customer-&gt;getFirstName()) -&gt;setSecondName($customer-&gt;getSecondName()); } }</span></span></code> </pre> </div></div><br><p>  Exception handling and converting them into the corresponding <a href="">gRPC statuscodes is</a> implemented at the application level and occurs automatically. <br>  All the developer needs is to create an Action and specify the expected types for the request and response in the signature of the <code>run</code> method. </p><br><p>  <strong>To generate code in PHP</strong> </p><br><ul><li>  Not so long ago, the official support for <a href="https://github.com/google/protobuf/tree/master/php">protobuf-plugin</a> came out.  Recommended for use. </li><li>  At the moment, we ourselves are still using the <a href="https://github.com/stanley-cheung/Protobuf-PHP">unofficial plugin</a> and are planning to migrate. </li></ul><br><p>  <strong>Benefits</strong> </p><br><ul><li>  We entered PHP into a common gRPC based messaging system; </li><li>  The proxy used is lightweight by itself, does not encode / decode requests; </li><li>  The proxy does not require .proto files for their work.  You can ‚Äústart and forget‚Äù (in our case, the proxy is simply launched in the adjacent container via docker-compose. Nginx is no longer needed to return HTTP). </li></ul><br><p>  <strong>disadvantages</strong> </p><br><ul><li>  Despite the lightness, another potential point of failure was added; </li><li>  It is necessary once to write a bit of code to automate the generation of classes and adapt the router / controllers for your framework; </li><li>  No server support for streams.  We think that under certain restrictions their implementation is not difficult, but so far such a need has not arisen; </li></ul><br><h2 id="gateway-dlya-frontenda">  Gateway frontend </h2><br><p>  If we have more or less solved the issues with internal messaging, then the frontend still remains.  Ideally, I would like to strive for using a single stack of technologies for both backend and frontend: it's easier and cheaper.  Therefore, we began to study this issue. </p><br><p>  Almost immediately, we found <a href="https://github.com/grpc-ecosystem/grpc-gateway">the grpc-gateway project</a> , which allows us to generate proxies for converting gRPC / Protobuf to HTTP / JSON.  It seems that this is a good solution for returning the API to the frontend and for those customers who do not want or cannot use gRPC (for example, if you need to write some one-time bash script quickly). </p><br><p>  About this project there <a href="https://habrahabr.ru/post/337716/">is</a> also <a href="https://habrahabr.ru/post/337716/">an article on Habr√©</a> , so literally in two words: a plugin for <code>protoc</code> based on the transmitted .proto files with a description of the service and special meta-information about the HTTP routes in which they generate code for reverse proxy.  Next, the main file is written with hands, in which the generated proxy server is simply started (the grpc-gateway authors describe in detail all the actions <a href="">in README.md</a> ). </p><br><p>  True, out of the box for us there were a couple of inconveniences: </p><br><ul><li>  I would like to add a few middleware before proxying an incoming request (authentication via JWT, logging, etc.); </li><li>  Each service stores its API in a separate repository (so that the client can easily connect it as a submodule).  It is necessary to maximally automate the process of updating .proto-files and assembling the current version of gateway; </li><li>  Among other things, when commissioning a new service, it is necessary to make changes to the code of the main file; </li></ul><br><p>  In short, you need to make changes often and quickly.  We'll have to work a little on convenience. </p><br><p>  The grpc-gateway itself is a protoc <strong><em>plugin that generates a proxy</em></strong> and is written in Go.  Based on this decision, it begs itself: <strong><em>write a generator that generates a plugin that generates a proxy</em></strong> =) Well, automate the launch and deployment of all this in our Gitlab CI. </p><br><p><img src="https://habrastorage.org/webt/d0/iz/nr/d0iznrtgi02ihjty1do2dsd8knm.png"></p><br><p>  The result is a generator generator, which takes a simple config to the input: </p><br><pre> <code class="hljs objectivec">- url: git.repository.com/api0/example-service <span class="hljs-meta"><span class="hljs-meta">#    .proto  ref: c4d0504f690ee66349306f66578cb15787eefe72 #  target: grpc-external.example.service.consul:50051 #    - ...</span></span></code> </pre> <br><p>  After changing it and starting the build, in our CI, a generator is launched that downloads all the necessary repositories based on the config, generates code for the main file, wraps the proxy itself with various middleware, and the output is a ready-made binary, which is then deployed to production. </p><br><p>  <strong>Benefits</strong> </p><br><ul><li>  We have extended most of our principles for describing and working with the front-end API; </li><li>  The developer on the backend operates with only one protocol; </li><li>  Depla changes is quite simple: simply config and push the config.  Then everything is collected and updated in the CI; </li><li>  All HTTP routes are written <a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/d64f5319e5fab76565cc3be5c3ce8b18f931de5b/examples/examplepb/echo_service.proto">directly in the proto-files</a> in the description of each method. </li></ul><br><p>  <strong>disadvantages</strong> </p><br><ul><li>  Yes, another proxy =) On the other hand, we still need a place in which authentication will be performed; </li><li>  Hayload lovers may notice that there is a moment of converting json into protobuf and it is certainly worth some resources; </li><li>  You need to spend a couple of hours to understand how HTTP headers are proxied and how various types are converted from protobuf to JSON ( <a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3#json</a> ) </li></ul><br><h2 id="rezultat-i-vyvody">  Result and conclusions </h2><br><p>  As a result of all these technical perturbations, we were able to quickly prepare our infrastructure for the transition to a single messaging protocol.  Thus, we were able to simplify and speed up the exchange of information between developers, added strictness to our interfaces in the issue of types, moved to the Design First design principle and preliminary Code Review at the level of interservice interfaces. </p><br><p>  It turned out something like this: <br><img src="https://habrastorage.org/webt/l5/c1/qj/l5c1qjtj0szsjxllbi8njgl8lfe.png"></p><br><p>  At the moment we have transferred most of the internal messaging to gRPC and are working on a new public API.  All this happens in the background as far as possible.  However, this process is not as complicated as it seemed before.  Instead, we were able to quickly and consistently design our APIs, share them between developers, conduct a Code Review, and generate clients.  For cases when HTTP is needed (for example, for internal web interfaces), we simply add a few annotations, add a couple of lines to the grpc-gateway config and get a ready endpoint. </p><br><p>  We would also like to make it possible in the future to use gRPC or a similar protocol <a href="https://github.com/improbable-eng/grpc-web">directly on the frontend</a> =) </p><br><p>  It cannot be said that there were no jambs and difficulties.  Among the interesting problems characteristic of gRPC, we have identified the following: </p><br><ul><li>  Lack of normal documentation on client and server configuration parameters.  For example, we are faced with a limit on the length of a response message.  It turned out that the <code>grpc.max_receive_message_length</code> parameter is responsible for it.  It was possible to find it only by digging in the client‚Äôs source code; </li><li>  The package system and the include path used in the code generation are rather long dismayed.  We have to develop rules for the integration of proto-files and write scripts to correctly generate code through <code>protoc</code> .  True, you need to do this only once; </li><li>  Not for all the YP generators are written perfectly.  For example, for the same PHP it was necessary <a href="https://github.com/google/protobuf/issues/2944">to actively vote for the support of fluent-interfaces for the generated structures</a> .  Also, there were funny problems before when using reserved words for different YAPs in protobuf (for example, <code>public</code> or <code>private</code> ).  Now it is almost completely fixed; </li><li>  In the current version of Protobuf, each type (except for custom structure types) has a default value.  It works about the same as in Go.  If not to transfer value for any <code>uint32</code> , then on the server we will receive <code>0</code> , but not <code>null</code> .  This may be unusual, but, on the other hand, it turned out to be quite convenient; </li></ul><br><p>  In addition to the technical aspects described in this article, there were other things that need to be given close attention when switching to a new API: </p><br><ul><li>  Decide where and in what form you will store your documentation or, as in our case, interface descriptions in .proto files; </li><li>  Understand how you will version it; </li><li>  Write guidelines about design principles.  In the case of gRPC, the freedom it provides can play a cruel joke: your API will turn into a vinaigrette from various naming methods, structures and other beautiful things.  To do this, we have developed a small set of rules and methods for solving typical problems within the team. </li></ul><br><p>  We hope that our experience will be useful to teams working on long-lived projects and ready to deal with what is usually called the term "historically." </p><br><h2 id="poleznye-ssylki-iz-stati">  Useful links from the article </h2><br><ul><li>  <a href="https://habrahabr.ru/company/infopulse/blog/265805">Article about gRPC on Habr√©</a> </li><li>  <a href="https://medium.com/apis-and-digital-transformation/openapi-and-grpc-side-by-side-b6afb08f75ed">OpenAPI vs. gRPC Comparison</a> </li><li>  <a href="https://github.com/LTD-Beget/grpc-to-fpm">GRPC Proxy -&gt; FastCGI</a> </li><li>  The <a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a> project and <a href="https://habrahabr.ru/post/337716">an article about it</a> </li><li>  The guys are trying to use <a href="https://github.com/improbable-eng/grpc-web">gRPC in the browser</a> </li><li>  <a href="https://github.com/njpatel/grpcc">Interactive debug console</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348008/">https://habr.com/ru/post/348008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347998/index.html">We integrate TeamCity with JIRA - without plug-ins and administrators</a></li>
<li><a href="../348000/index.html">Convolutional neural network, part 1: structure, topology, activation functions and training set</a></li>
<li><a href="../348002/index.html">News from the world of OpenStreetMap ‚Ññ392 (01.16.2018-22.01.2018)</a></li>
<li><a href="../348004/index.html">Swift Package Manager</a></li>
<li><a href="../348006/index.html">Cryptocurrency Phishing</a></li>
<li><a href="../348010/index.html">False alarms. New technique of catching two birds with one stone. Part 2</a></li>
<li><a href="../348012/index.html">As I measured the quality of technical support work</a></li>
<li><a href="../348014/index.html">Blockchain: features, structure, EDS and task for a student, part 1</a></li>
<li><a href="../348016/index.html">And so it will come down ... or the Hole as a means of protection</a></li>
<li><a href="../348018/index.html">Even in Java 9, ArrayList can still (and should) be improved.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>