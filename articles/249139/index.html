<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 6 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the main course 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 6 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content of the main course </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/"><b>Article 6: A little more than just a shader: shadow rendering</b></a> </li></ul><br><br><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li></ul><br><br><br><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Shadow mapping </h1><br>  Well, our short course is coming to an end, the task for today is to learn how to draw shadows (attention, rendering of half-shadows is a separate topic): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50d/e2a/be9/50de2abe990efa345664f98c9464a4c8.png"><br><br>  As always, the code is available <a href="https://github.com/ssloy/tinyrenderer/tree/0c1d955e4f86c25f31f97e4f4563313ddba0c104">on github</a> <br><a name="habracut"></a><br>  Until now, we have been able to shade convex objects due to normals on the surface, but for non-convex objects our renders gave an incorrect result, why is the demon's right (for us) left shoulder lit?  Why is there no horn shadow on my left cheek?  Disorder. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4a/f24/130/b4af24130ecb1536703e4793308af425.png"><br><br>  The idea is very simple: we will render in two passes.  If we render the picture for the first time, putting the camera in the place of the light source, then we will know exactly which places are lit.  And then in the second pass we will use the result of the work of the first pass.  There are almost no difficulties.  Let's write this shader: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="hljs pgsql">struct DepthShader : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_tri; DepthShader() : varying_tri() {} virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> the vertex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .obj file gl_Vertex = Viewport*Projection*ModelView*gl_Vertex; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> screen coordinates varying_tri.set_col(nthvert, proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(gl_Vertex/gl_Vertex[<span class="hljs-number"><span class="hljs-number">3</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gl_Vertex; } virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> fragment(Vec3f bar, TGAColor &amp;color) { Vec3f p = varying_tri*bar; color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)*(pz/depth); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } };</code> </pre> <br></div></div><br>  This shader simply draws the contents of the z-buffer in the frame buffer.  I call this shader from main (): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> { // rendering the shadow buffer TGAImage depth(width, height, TGAImage::RGB); lookat(light_dir, center, up); viewport(width/<span class="hljs-number"><span class="hljs-number">8</span></span>, height/<span class="hljs-number"><span class="hljs-number">8</span></span>, width*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>, height*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>); projection(<span class="hljs-number"><span class="hljs-number">0</span></span>); DepthShader depthshader; Vec4f screen_coords[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model-&gt;nfaces(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { screen_coords[j] = depthshader.vertex(i, j); } triangle(screen_coords, depthshader, depth, shadowbuffer); } depth.flip_vertically(); // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> place the origin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the bottom left corner <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the image depth.write_tga_file("depth.tga"); } Matrix M = Viewport*Projection*ModelView;</code> </pre><br></div></div><br><br>  I put the camera in the place of the light source (lookat (light_dir, center, up);) and render it.  The z-buffer of this rendering pass is saved by the shadowbuffer pointer.  Note that with the very last line I save the transition matrix from the coordinates of the object to the screen coordinates. <br><br>  Here is the result of this shader, the first pass of rendering is finished. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/f74/399/9b9/f743999b9d21aee9d0704c4036e18dce.png"></div></div><br><br>  I do the second pass with another shader: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct Shader : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; uniform_M; // Projection*ModelView mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; uniform_MIT; // (Projection*ModelView).invert_transpose() mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; uniform_Mshadow; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> framebuffer screen coordinates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> shadowbuffer screen coordinates mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_uv; // triangle uv coordinates, written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the vertex shader, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the fragment shader mat&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_tri; // triangle coordinates <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> Viewport <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>, written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> VS, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> FS Shader(Matrix M, Matrix MIT, Matrix MS) : uniform_M(M), uniform_MIT(MIT), uniform_Mshadow(MS), varying_uv(), varying_tri() {} virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert)); Vec4f gl_Vertex = Viewport*Projection*ModelView*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); varying_tri.set_col(nthvert, proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(gl_Vertex/gl_Vertex[<span class="hljs-number"><span class="hljs-number">3</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gl_Vertex; } virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> fragment(Vec3f bar, TGAColor &amp;color) { Vec4f sb_p = uniform_Mshadow*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(varying_tri*bar); // corresponding <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the shadow buffer sb_p = sb_p/sb_p[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> idx = <span class="hljs-type"><span class="hljs-type">int</span></span>(sb_p[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + <span class="hljs-type"><span class="hljs-type">int</span></span>(sb_p[<span class="hljs-number"><span class="hljs-number">1</span></span>])*width; // <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the shadowbuffer <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">.3</span></span>+<span class="hljs-number"><span class="hljs-number">.7</span></span>*(shadowbuffer[idx]&lt;sb_p[<span class="hljs-number"><span class="hljs-number">2</span></span>]); Vec2f uv = varying_uv*bar; // interpolate uv <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> pixel Vec3f n = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_MIT*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;normal(uv))).normalize(); // normal Vec3f l = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_M *embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(light_dir )).normalize(); // light vector Vec3f r = (n*(n*l*<span class="hljs-number"><span class="hljs-number">2.</span></span>f) - l).normalize(); // reflected light <span class="hljs-type"><span class="hljs-type">float</span></span> spec = pow(std::max(rz, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f), model-&gt;specular(uv)); <span class="hljs-type"><span class="hljs-type">float</span></span> diff = std::max(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, n*l); TGAColor c = model-&gt;diffuse(uv); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) color[i] = std::min&lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">20</span></span> + c[i]*shadow*(<span class="hljs-number"><span class="hljs-number">1.2</span></span>*diff + <span class="hljs-number"><span class="hljs-number">.6</span></span>*spec), <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } };</code> </pre><br></div></div><br><br>  This is practically one-to-one shader from the end of the previous article, with one exception: <br>  I declared a constant matrix that does not change during operation of either the vertex or fragment shaders mat &lt;4.4, float&gt; uniform_Mshadow. <br><br>  This matrix will allow me to turn the screen coordinates of the current shader into the screen coordinates of the already rendered shadow buffer! <br><br>  About how we consider it in the next paragraph.  Let's see how we use it, let's pay attention to these four lines of the shader: <br><br><pre> <code class="hljs pgsql"> Vec4f sb_p = uniform_Mshadow*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(varying_tri*bar); // corresponding <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the shadow buffer sb_p = sb_p/sb_p[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> idx = <span class="hljs-type"><span class="hljs-type">int</span></span>(sb_p[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + <span class="hljs-type"><span class="hljs-type">int</span></span>(sb_p[<span class="hljs-number"><span class="hljs-number">1</span></span>])*width; // <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the shadowbuffer <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">.3</span></span>+<span class="hljs-number"><span class="hljs-number">.7</span></span>*(shadowbuffer[idx]&lt;sb_p[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre><br><br>  varying_tri * bar gives me the screen coordinates of the current snippet that we draw.  We submerge them in homogeneous coordinates, transform with our magic matrix uniform_Mshadow and ta-dam, we know the xyz coordinates in the shadow shader space that we used for the first pass.  Now, in order to understand whether this point is lit or not, it is enough for us to compare its z-coordinate and the value of the z-buffer from the first pass! <br><br>  What does the second shader call in main () look like?  Everything is pretty standard: <br><br><pre> <code class="hljs pgsql"> Matrix M = Viewport*Projection*ModelView; { // rendering the frame buffer TGAImage frame(width, height, TGAImage::RGB); lookat(eye, center, up); viewport(width/<span class="hljs-number"><span class="hljs-number">8</span></span>, height/<span class="hljs-number"><span class="hljs-number">8</span></span>, width*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>, height*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>); projection(<span class="hljs-number"><span class="hljs-number">-1.</span></span>f/(eye-center).norm()); Shader shader(ModelView, (Projection*ModelView).invert_transpose(), M*(Viewport*Projection*ModelView).invert()); Vec4f screen_coords[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model-&gt;nfaces(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { screen_coords[j] = shader.vertex(i, j); } triangle(screen_coords, shader, frame, zbuffer); } frame.flip_vertically(); // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> place the origin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the bottom left corner <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the image frame.write_tga_file("framebuffer.tga"); }</code> </pre><br>  I remind you that the matrix M is a matrix for converting object coordinates into screen coordinates of the shadow buffer.  We put the camera in the place where it should be, set up the viewport and the perspective projection parameters, and declare the second-pass rendering shader. <br><br>  We know that Viewport * Projection * ModelView is a matrix for converting object coordinates into screen coordinates of the second shader.  But we need to know the transformation matrix of the screen of the second shader to the screen of the first shader.  It's simple: (Viewport * Projection * ModelView) .invert () converts the screen of the second shader to object coordinates, and then multiply simply by M, getting the final transformation matrix as M * (Viewport * Projection * ModelView) .invert (). <br><br>  Everything would be fine if it were not a trifle: nineteen in half, it seems, is not divided.  Here is the result of our two-pass render: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://habrastorage.org/getpro/habr/post_images/164/be1/dce/164be1dce9e980d47a90159103b954a3.png"></div></div><br><br>  What is it?  This artifact is known as the <a href="http://en.wikipedia.org/wiki/Z-fighting">fight for z</a> .  If a pixel should be lit, then its z-coordinate should be in the z-buffer of the shadow shader.  Or should it be the neighboring pixel z-value?  In general, the resolution of our z-buffer is not enough to give a picture without artifacts.  We will deal with this problem by brute force: <br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">.3</span></span>+<span class="hljs-number"><span class="hljs-number">.7</span></span>*(shadowbuffer[idx]&lt;sb_p[<span class="hljs-number"><span class="hljs-number">2</span></span>]+<span class="hljs-number"><span class="hljs-number">43.34</span></span>); <span class="hljs-comment"><span class="hljs-comment">// magic coeff to avoid z-fighting</span></span></code> </pre><br>  I shift one z-buffer relative to another by some constant, which is enough for this artifact to disappear.  Yes, it creates new artifacts (which ones?), But significantly less noticeable to the eye.  Everything, the result of our program is visible in the title picture. <br><br>  Congratulations, our short course has come to an end.  We wrote from scratch a very good, I think, analogue of OpenGL. <br><br><h1>  Did you sign up to volunteer? </h1><br>  As a bonus to the short course, next time I will show how to count the tangent basis to our surface (to use the textures defined in tangent space) and at the same time we write a simple shader that can work with luminous objects (see the crystal in the head of diablo): <br><br><img src="http://habrastorage.org/getpro/habr/post_images/e3c/d70/492/e3cd704925f52b5466ab3c4f9fbab899.png"><br><br>  Samuel Sharit very kindly provided us with this model, of course, it can be used without his special permission only within the framework of this training course, as well as the head model of a Negro made by Vidar Rapp. </div><p>Source: <a href="https://habr.com/ru/post/249139/">https://habr.com/ru/post/249139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249127/index.html">Practice "Intel IoT". Galileo Gen2 - Eclipse & libmraa + UPM</a></li>
<li><a href="../249129/index.html">Push non-ASCII to inappropriate locations.</a></li>
<li><a href="../249131/index.html">Three words that can change the world</a></li>
<li><a href="../249135/index.html">CLR bug: how to drag an object into a sandbox without marshalling and call a callback</a></li>
<li><a href="../249137/index.html">GHOST (dot) WEB: First Blood</a></li>
<li><a href="../249141/index.html">Building crosswords using the Wolfram Language (Mathematica)</a></li>
<li><a href="../249143/index.html">Automate and speed up the process of setting up cloud servers with Ansible. Part 1: Introduction</a></li>
<li><a href="../249145/index.html">2014 dotGo conference in Paris</a></li>
<li><a href="../249151/index.html">Free internet for tablet from Beeline and MTS</a></li>
<li><a href="../249155/index.html">Analytics for December, plans for a new iPhone, Roskomnadzor measures - and other news of the week for a mobile developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>