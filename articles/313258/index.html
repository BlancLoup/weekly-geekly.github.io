<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Divide & Conquer over the Strassen algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello friends! As students of a well-known educational project, we, with bo_0m , after our introductory lecture on the Advanced programming course in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Divide & Conquer over the Strassen algorithm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9ca/10e/198/9ca10e198ef2d6aa4283560d270a20fb.jpg" alt="image"><br><br>  Hello friends!  As students of a well-known educational project, we, with <a href="https://habrahabr.ru/users/bo_0m/" class="user_link">bo_0m</a> , after our introductory lecture on the <i>Advanced programming</i> course <i>in Java</i> , received our first homework.  It was necessary to implement a program that would multiply the matrices.  And everything would be okay, so it was a coincidence that next week the Joker conference was supposed to take place, and our teacher decided to cancel the lesson on this occasion, giving us a few hours of free Friday evening.  Do not waste the same time in vain!  Since no one is in a hurry, then you can get creative. <br><br>  Welcome, under the hood ‚Üì <br><a name="habracut"></a><br><h5>  <b>The first thing that comes to mind</b> </h5><br>  Probably every technical university student had to multiply the matrices.  The algorithm was always the same, namely, a simple cubic method of multiplication.  And no matter how it sounds, but this method is not so bad (for matrix dimensions less than 100). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>We all started with this:</i> <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; A.rows(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; B.columns(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; A.columns(); k++) { C[i][j] += A[i][k] * B[k][j]; } } }</code> </pre> <br>  Looking ahead, I will say that we will use a modified version using transposition.  About this modification is well written <a href="https://habrahabr.ru/post/114797/">here</a> , and not only about it. <br><br>  Okay, let's go further! <br><br><h5>  <b>Strassen Algorithm</b> </h5><br>  Perhaps not everyone knows, but the author of the algorithm, Volker Strassen, is not only alive, but also actively teaching, as well as an honorary professor in the department of mathematics and statistics at the University of Constance.  Be sure to read about this person at least on the <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D1%2582%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B5%25D0%25BD,_%25D0%25A4%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BA%25D0%25B5%25D1%2580">wiki</a> . <br>  A bit of theory from Wikipedia: <br><br><blockquote>  Let A and B be two (n * n) -matrices, moreover, n is a power of 2. Then each A and B matrix can be divided into four ((n / 2) * (n / 2)) - matrices and through them be expressed product of matrices A and B: </blockquote><br><div style="text-align:center;"><img src="http://s8.hostingkartinok.com/uploads/images/2016/10/4980b9a9ef873d68e1b21259a50c8020.jpg" alt="image"></div><br><blockquote>  Define new items: </blockquote><br><div style="text-align:center;"><img src="http://s8.hostingkartinok.com/uploads/images/2016/10/0e16bf2e1b5b76cfb6bdd2ca22352cc1.jpg" alt="image"></div><br><blockquote>  Thus, we need only 7 multiplications at each stage of the recursion.  The elements of the matrix C are expressed from Pk by the formulas: </blockquote><br><div style="text-align:center;"><img src="http://s8.hostingkartinok.com/uploads/images/2016/10/0cd3f682c05940191f61217308ee17cc.jpg" alt="image"></div><br><blockquote>  The recursive process continues n times, until the size of the matrices Ci, j is sufficiently small, then the usual method of matrix multiplication is used.  This is done due to the fact that the Strassen algorithm loses its efficiency in comparison with the ordinary one on small matrices due to the greater number of additions. </blockquote><br>  let's go to practice! <br><br>  To implement the Strassen algorithm, we need additional functions.  As mentioned above, the algorithm works only with square matrices, the dimension of which is equal to degree 2, so we will bring the original matrices to this form. <br><br>  For this, a function was implemented that defines a new dimension: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((x &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) result++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-comment"><span class="hljs-comment">//****************************************************************************************** private static int getNewDimension(int[][] a, int[][] b) { return 1 &lt;&lt; log2(Collections.max(Arrays.asList(a.length, a[0].length, b[0].length))); //  -  }</span></span></code> </pre><br>  And a function that expands the matrix to the desired size: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] addition2SquareMatrix(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; a[i].length; j++) { result[i][j] = a[i][j]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  The original matrices now satisfy the requirements for the implementation of the Strassen algorithm.  We also need a function that allows us to split the matrix of size n * n into four matrices (n / 2) * (n / 2) and the inverse to reconstruct the matrix: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a11, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a12, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a21, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a22)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = a.length &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { System.arraycopy(a[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, a11[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, n); System.arraycopy(a[i], n, a12[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, n); System.arraycopy(a[i + n], <span class="hljs-number"><span class="hljs-number">0</span></span>, a21[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, n); System.arraycopy(a[i + n], n, a22[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, n); } } <span class="hljs-comment"><span class="hljs-comment">//****************************************************************************************** private static int[][] collectMatrix(int[][] a11, int[][] a12, int[][] a21, int[][] a22) { int n = a11.length; int[][] a = new int[n &lt;&lt; 1][n &lt;&lt; 1]; for (int i = 0; i &lt; n; i++) { System.arraycopy(a11[i], 0, a[i], 0, n); System.arraycopy(a12[i], 0, a[i], n, n); System.arraycopy(a22[i], 0, a[i + n], n, n); } return a; }</span></span></code> </pre><br>  So we got to the most interesting, the main function of matrix multiplication by the Strassen algorithm is as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Strassen Algorithm</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] multiStrassen(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiply(a, b); } n = n &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a11 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a12 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a21 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a22 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b11 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b12 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b21 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b22 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; splitMatrix(a, a11, a12, a21, a22); splitMatrix(b, b11, b12, b21, b22); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p1 = multiStrassen(summation(a11, a22), summation(b11, b22), n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p2 = multiStrassen(summation(a21, a22), b11, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p3 = multiStrassen(a11, subtraction(b12, b22), n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p4 = multiStrassen(a22, subtraction(b21, b11), n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p5 = multiStrassen(summation(a11, a12), b22, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p6 = multiStrassen(subtraction(a21, a11), summation(b11, b12), n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p7 = multiStrassen(subtraction(a12, a22), summation(b21, b22), n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c11 = summation(summation(p1, p4), subtraction(p7, p5)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c12 = summation(p3, p5); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c21 = summation(p2, p4); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c22 = summation(subtraction(p1, p2), summation(p3, p6)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collectMatrix(c11, c12, c21, c22); }</code> </pre><br></div></div><br>  At this could be finished.  The implemented algorithm works <s>homework done</s> , but inquiring minds crave adult perfomance.  Let Java 7 be with us. <br><br><h5>  <b>It's time to parallelize</b> </h5><br>  Java 7 provides an excellent API for parallelizing recursive tasks.  With its release, one of the additions to the java.util.concurrent packages appeared - the implementation of the Divide and Conquer - Fork-Join paradigm.  The idea is this: recursively we divide the task into subtasks, solve, and then combine the results.  More information about this technology can be found in the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">documentation</a> . <br><br>  Let's see how easily and effectively you can apply this paradigm to our Strassen algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Algorithm implementation with Fork / Join</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myRecursiveTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecursiveTask</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">[][]&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> serialVersionUID = -<span class="hljs-number"><span class="hljs-number">433764214304695286L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myRecursiveTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] compute() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiply(a, b); } n = n &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a11 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a12 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a21 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a22 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b11 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b12 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b21 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] b22 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n][n]; splitMatrix(a, a11, a12, a21, a22); splitMatrix(b, b11, b12, b21, b22); myRecursiveTask task_p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(summation(a11,a22),summation(b11,b22),n); myRecursiveTask task_p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(summation(a21,a22),b11,n); myRecursiveTask task_p3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(a11,subtraction(b12,b22),n); myRecursiveTask task_p4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(a22,subtraction(b21,b11),n); myRecursiveTask task_p5 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(summation(a11,a12),b22,n); myRecursiveTask task_p6 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(subtraction(a21,a11),summation(b11,b12),n); myRecursiveTask task_p7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myRecursiveTask(subtraction(a12,a22),summation(b21,b22),n); task_p1.fork(); task_p2.fork(); task_p3.fork(); task_p4.fork(); task_p5.fork(); task_p6.fork(); task_p7.fork(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p1 = task_p1.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p2 = task_p2.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p3 = task_p3.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p4 = task_p4.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p5 = task_p5.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p6 = task_p6.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] p7 = task_p7.join(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c11 = summation(summation(p1, p4), subtraction(p7, p5)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c12 = summation(p3, p5); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c21 = summation(p2, p4); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] c22 = summation(subtraction(p1, p2), summation(p3, p6)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collectMatrix(c11, c12, c21, c22); } }</code> </pre><br></div></div><br><h5>  <b>Climax</b> </h5><br>  You probably can‚Äôt wait to see the performance comparison of the algorithms on real hardware.  Immediately make a reservation that we will conduct testing on square matrices.  So, we have: <br><br><ol><li>  Traditional (Cubic) Matrix Multiplication Method </li><li>  Traditional using transpose </li><li>  Strassen Algorithm </li><li>  Strassen's Parallel Algorithm </li></ol><br>  The dimension of the matrices will be set in the interval [100..4000] and in increments of 100. <br><br><img src="http://s8.hostingkartinok.com/uploads/images/2016/10/116de484ec49017865a973634e9a8880.png" alt="image"><br><br>  As expected, our first algorithm immediately fell out of the top three.  But with his modernized brother (transposition version), not everything is so simple.  Even on rather large dimensions, this algorithm is not only not inferior, but often exceeds the Strassen single-threaded algorithm.  And yet, having a trump in the sleeve in the form of the Fork-Join Framework, we managed to get significant performance gains.  Parallelization of the Strassen algorithm allowed us to reduce the multiplication time by almost 3 times, and also to head our final total. <br><br>  The source code is available <a href="http://pastebin.com/FFZzbHSV">here</a> . <br><br>  We welcome feedback and comments to our work.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/313258/">https://habr.com/ru/post/313258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313248/index.html">Mikrotik: VLAN using a switching chip</a></li>
<li><a href="../313250/index.html">Validation in HTML5</a></li>
<li><a href="../313252/index.html">Comparing Postgres schemas and related issues with views</a></li>
<li><a href="../313254/index.html">Category theory on javascript. Part 1. Category of sets</a></li>
<li><a href="../313256/index.html">YML (Yandex Market Language) - Generation of a product file for Yandex Webmaster</a></li>
<li><a href="../313260/index.html">According to the players of the IT market, the bill on the regulation of online cinemas will slow down their development</a></li>
<li><a href="../313262/index.html">7 rules of working with Linkedin that will help you get the desired result and save your nerves to counterparties</a></li>
<li><a href="../313264/index.html">How to find out the attendance of 3.8 million sites</a></li>
<li><a href="../313268/index.html">What is a ‚Äútrap for a person‚Äù in the data center and why is it needed?</a></li>
<li><a href="../313270/index.html">Elections 2016. Part 1 - Results and Comparisons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>