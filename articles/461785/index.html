<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Disadvantages of RISC-V</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I originally wrote this document a few years ago, as an execution core verification engineer in ARM. Of course, my opinion was influenced by in-depth ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Disadvantages of RISC-V</h1><div class="post__text post__text-html js-mediator-article">  I originally wrote this document a few years ago, as an execution core verification engineer in ARM.  Of course, my opinion was influenced by in-depth work with the executive cores of different processors.  So do it for a discount, please: maybe I'm too categorical. <br><br>  However, I still believe that the creators of RISC-V could do much better.  On the other hand, if I had designed a 32-bit or 64-bit processor today, I would probably have implemented just such an architecture to take advantage of the existing tools. <br><br>  The article originally described the RISC-V 2.0 instruction set.  For version 2.2, it made some updates. <br><a name="habracut"></a><br><h1>  Original Foreword: Some Personal Opinion </h1><br>  The RISC-V instruction set has been reduced to an absolute minimum.  Much attention is paid to minimizing the number of instructions, normalizing coding, etc. This desire for minimalism has led to false orthogonality (such as reusing the same instruction for transitions, calls, and returns) and mandatory verbosity, which inflates both size and quantity instructions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, here is the C code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readidx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[idx]; }</code> </pre> <br>  This is a simple case of indexing an array, a very common operation.  This is the compilation for x86_64: <br><br><pre> <code class="plaintext hljs">mov eax, [rdi+rsi*4] ret</code> </pre> <br>  or ARM: <br><br><pre> <code class="plaintext hljs">ldr r0, [r0, r1, lsl #2] bx lr // return</code> </pre> <br>  However, for RISC-V, the following code is required: <br><br><pre> <code class="plaintext hljs">slli a1, a1, 2 add a0, a1, a1 lw a0, a0, 0 jalr r0, r1, 0 // return</code> </pre> <br>  Simplification RISC-V simplifies the decoder (i.e., the CPU front end) by executing more instructions.  But scaling the width of the pipeline is a complex problem, while decoding slightly (or strongly) irregular instructions is well implemented (the main difficulty arises when it is difficult to determine the length of the instruction: this is especially evident in the x86 instruction set with numerous prefixes). <br><br>  The simplification of the set of instructions should not be brought to the limit.  Register and register addition with a shift of the register memory is a simple and very common instruction in programs, and it is very easy for the processor to effectively implement it.  If the processor is not able to implement the instruction directly, then it can be relatively easy to break it down into its components;  this is a much simpler problem than merging sequences of simple operations. <br><br>  We must distinguish between ‚Äúcomplex‚Äù specific instructions of CISC processors - complicated, rarely used and inefficient instructions - from ‚Äúfunctional‚Äù instructions common to CISC and RISC processors, which combine a small sequence of operations.  The latter are used frequently and with high performance. <br><br><h1>  Mediocre implementation </h1><br><ul><li>  Almost unlimited extensibility.  Although this is the goal of RISC-V, it creates a fragmented, incompatible ecosystem that must be managed with extreme caution. <br></li><li>  The same instruction ( <code>JALR</code> ) is used for calls, and for returns, and for register-indirect branches, where additional decoding is required for branch prediction <br><ul><li>  Call: <code>Rd</code> = <code>R1</code> <br></li><li>  Return: <code>Rd</code> = <code>R0</code> , <code>Rs</code> = <code>R1</code> <br></li><li>  Indirect transition: <code>Rd</code> = <code>R0</code> , <code>Rs</code> ‚â† <code>R1</code> <br></li><li>  (Strange transition: <code>Rd</code> ‚â† <code>R0</code> , <code>Rd</code> ‚â† <code>R1</code> ) </li></ul></li><li>  Encoding with a variable length of the recording field is not self-synchronizing (this is often found - for example, a similar problem with x86 and Thumb-2 - but this causes various problems with both implementation and security, for example, reverse-oriented programming, i.e. ROP attacks ) <br></li><li>  RV64I requires a character extension for all 32-bit values.  This leads to the fact that the upper half of 64-bit registers becomes impossible to use for storing intermediate results, which leads to unnecessary special placement of the upper half of the registers.  It is more optimal to use the extension with zeros (since it reduces the number of switches and can usually be optimized by tracking the ‚Äúzero‚Äù bit, when the upper half is known to be zero) <br></li><li>  Multiplication is optional.  Although fast multiplication blocks can occupy a fairly substantial area on tiny crystals, you can always use slightly slower circuits that actively use the existing ALU for multiple multiplication cycles. <br></li><li>  <code>LR</code> / <code>SC</code> strict progression requirements for a limited subset of applications.  Although this restriction is rather strict, it potentially creates some problems for small implementations (especially without a cache) <br><ul><li>  This seems like a replacement for CAS instruction, see comment below </li></ul></li><li>  Memory sticky bits FP and rounding mode are in the same register.  This requires serialization of the FP channel if the RMW operation is performed to change the rounding mode. <br></li><li>  <code>FP</code> instructions are encoded for 32, 64, and 128-bit precision, but not 16-bit (which is much more common in hardware than 128 bits) <br><ul><li>  It can be easily fixed: <code>2'b10</code> encoding <code>2'b10</code> free <br></li><li>  <i>Update:</i> <i>Decimal</i> placeholder appeared in version 2.2, but there is no half precision placeholder.  The mind is incomprehensible. </li></ul></li><li>  The way FP values ‚Äã‚Äãare represented in the FP register file is not defined, but observable (via load / store) <br><ul><li>  Emulator authors will hate you <br></li><li>  Migration of virtual machines may become impossible <br></li><li>  <i>Update:</i> version 2.2 requires wider NaN-boxing values </li></ul></li></ul><br><h1>  poorly </h1><br><ul><li>  There are no condition codes, and instead, compare-and-branch statements are used.  This is not a problem in itself, but the consequences are unpleasant: <br><ul><li>  Reduced coding space in conditional branches due to the need to encode one or two register specifiers <br></li><li>  No conditional selection (useful for very unpredictable transitions) <br></li><li>  No carry-over addition / subtraction with carry-over or borrowing <br></li><li>  (Note that this is still better than sets of commands that write flags to the general register, and then switch to the received flags) </li></ul></li><li>  High-precision counters only seem to be <i>required</i> at the ISA user level.  In practice, providing them with applications is an excellent vector for attacks on third-party channels <br></li><li>  Multiplication and division are part of the same expansion, and it seems that if one is implemented, then the other should also be.  Multiplication is much simpler than division, and is common on most processors, but division is not. <br></li><li>  There are no atomic instructions in the basic instruction set architecture.  Multi-core microcontrollers are becoming more common, so atomic instructions like LL / SC are inexpensive (for minimal implementation within a single [multi-core] processor, only 1 bit of processor status is needed) <br></li><li>  <code>LR</code> / <code>SC</code> are in the same extension as more complex atomic instructions, which limits flexibility for small implementations <br></li><li>  General atomic instructions (not <code>LR</code> / <code>SC</code> ) do not include <code>CAS</code> primitive <br><ul><li>  The <code>CmpHi:CmpLo</code> to avoid the need for an instruction that reads five registers ( <code>Addr</code> , <code>CmpHi:CmpLo</code> , <code>SwapHi:SwapLo</code> ), but this will likely impose less implementation overhead than the guaranteed forward <code>LR</code> / <code>SC</code> , which is provided as replacements </li></ul></li><li>  Atomic instructions are offered that work on 32-bit and 64-bit values, but not 8-bit or 16-bit ones <br></li><li>  For RV32I, there is no way to transfer the DP FP value between an integer and an FP register file, except through memory, that is, from 32-bit integer registers it is impossible to make a 64-bit double-precision floating-point number, you must first write the intermediate value to memory and load him into the register file from there <br></li><li>  For example, a 32-bit instruction <code>ADD</code> in RV32I and 64-bit <code>ADD</code> in RVI64 same encoding and RVI64 added more and other coding <code>ADD.W</code> .  This is an unnecessary complication for a processor that implements both instructions - it would be preferable to add a new 64-bit encoding instead. <br></li><li>  No <code>MOV</code> instructions.  The mnemonic code of the <code>MV</code> command is translated by the assembler into the instruction <code>MV rD, rS</code> -&gt; <code>ADDI rD, rS, 0</code> .  High-performance processors typically optimize <code>MOV</code> instructions <code>MOV</code> , making extensive use of reordering instructions.  An instruction with a direct 12-bit operand was chosen as the canonical form of the <code>MV</code> instruction in RISC-V. <br><ul><li>  In the absence of <code>MOV</code> the <code>ADD rD, rS, r0</code> instruction <code>ADD rD, rS, r0</code> actually becomes preferable to the canonical <code>MOV</code> , since it is easier to decode, and operations with zero register (r0) in the CPU are usually optimized </li></ul></li></ul><br><h1>  Awful </h1><br><ul><li>  <code>JAL</code> spends 5 bits on encoding the communication register, which is always equal to <code>R1</code> (or <code>R0</code> for transitions) <br><ul><li>  This means that the RV32I uses 21-bit branch displacement.  This is not enough for large applications - for example, web browsers - without using multiple sequences of commands and / or ‚Äúbranch islands‚Äù <br></li><li>  This is a deterioration compared to version 1.0 of the command architecture! </li></ul></li><li>  Despite the great effort to uniformly encode, load / store instructions are encoded differently (case and immediate fields change) <br><ul><li>  Apparently, the orthogonality of the encoding of the output register was preferable to the orthogonality of the encoding of two strongly related instructions.  This choice seems a bit odd given that address generation is more time critical </li></ul></li><li>  There are no memory loading commands with register offsets ( <code>Rbase</code> + <code>Roffset</code> ) or indexes ( <code>Rbase</code> + <code>Rindex</code> &lt;&lt; <code>Scale</code> ). <br></li><li>  <code>FENCE.I</code> implies a complete synchronization of the instruction cache with all previous repositories, with or without fenced.  Implementations need to either clear all I $ on the fence, or look for D $ and the storage buffer <br></li><li>  In RV32I, reading 64-bit counters requires reading the upper half twice, comparing and branching in the case of transferring between the lower and upper half during a read operation <br><ul><li>  Typically, 32-bit ISAs include a read special pair register instruction to avoid this problem. </li></ul></li><li>  There is no architecturally defined space for hint coding, so that instructions from this space do not cause an error on older processors (processed as <code>NOP</code> ), but do something on the most modern CPUs <br><ul><li>  Typical examples of pure NOP hints are things like spinlock yield <br></li><li>  Newer processors also have more sophisticated hints (with visible side effects on the newer processors; for example, x86 border check instructions are encoded in hint space so that the binaries remain backward compatible) </li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/461785/">https://habr.com/ru/post/461785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461771/index.html">Say no to silence: from the nursery to the office</a></li>
<li><a href="../461773/index.html">Airtest IDE - a new way in testing automation of mobile games?</a></li>
<li><a href="../461775/index.html">3 cases for using Celery in a Django application</a></li>
<li><a href="../461779/index.html">80% of your company data is not available to you. What to do with it?</a></li>
<li><a href="../46178/index.html">Ingraham - the systemist in the style of the 50s</a></li>
<li><a href="../461787/index.html">Android text display</a></li>
<li><a href="../46179/index.html">Stages of development of a promotional site. Task formulation</a></li>
<li><a href="../461793/index.html">Ivan Ponomarev about Kafka Streams API at jug.msk.ru meeting</a></li>
<li><a href="../461797/index.html">Tales of service. A frivolous post about serious work</a></li>
<li><a href="../4618/index.html">J & P: You can make good money on smartphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>