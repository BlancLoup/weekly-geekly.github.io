<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bash Scripts, Part 5: Signals, Background Tasks, Script Management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bash scripts: start 
 Bash scripts, part 2: loops 
 Bash scripts, part 3: command line options and keys 
 Bash scripts, part 4: input and output 
 Bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bash Scripts, Part 5: Signals, Background Tasks, Script Management</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="https://habrahabr.ru/company/ruvds/blog/325522/">Bash scripts: start</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/325928/">Bash scripts, part 2: loops</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326328/">Bash scripts, part 3: command line options and keys</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326594/">Bash scripts, part 4: input and output</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326826/">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327248/">Bash scripts, part 6: functions and library development</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327530/">Bash scripts, part 7: sed and word processing</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327754/">Bash scripts, part 8: awk data processing language</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327896/">Bash scripts, part 9: regular expressions</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328346/">Bash scripts, part 10: practical examples</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328436/">Bash scripts, part 11: expect and automate interactive utilities</a> </blockquote><br> <a href="https://habrahabr.ru/company/ruvds/blog/326826/"><img src="https://habrastorage.org/files/803/892/bfe/803892bfe548499aa763df324d40fd01.png" alt="image"></a> <br><br>  Last time, we talked about working with input, output, and error streams in bash scripts, about file descriptors, and about stream redirection.  Now you already know enough to write something of your own.  At this stage in the development of bash, you may well have questions about how to manage running scripts, how to automate their launch. <br><a name="habracut"></a><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  Until now, we entered script names on the command line and pressed Enter, which led to the immediate launch of programs, but this is not the only way to call scripts.  Today we will talk about how the script can work with Linux signals, about different approaches to running scripts and managing them while working. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#3AC1EF">Linux signals</font> </h2><br>  In Linux, there are more than three dozen signals that the system or applications generate.  Here is a list of the most commonly used, which will probably come in handy when developing command line scripts. <br><table><tbody><tr><td width="120">  <b>Signal code</b> <br></td><td width="100">  <b>Title</b> <br></td><td>  <b>Description</b> <br></td></tr><tr><td>  one <br></td><td>  SIGHUP <br></td><td>  Terminal closing <br></td></tr><tr><td>  2 <br></td><td>  SIGINT <br></td><td>  Process stop signal by the user from the terminal (CTRL + C) <br></td></tr><tr><td>  3 <br></td><td>  SIGQUIT <br></td><td>  Process stop signal by the user from the terminal (CTRL + \) with a memory dump <br></td></tr><tr><td>  9 <br></td><td>  Sigkill <br></td><td>  The final completion of the process <br></td></tr><tr><td>  15 <br></td><td>  Sigterm <br></td><td>  Process completion request signal <br></td></tr><tr><td>  17 <br></td><td>  Sigstop <br></td><td>  Forced suspension of the process, but not the completion of its work <br></td></tr><tr><td>  18 <br></td><td>  Sigtstp <br></td><td>  Suspending the terminal process (CTRL + Z), but not shutting down <br></td></tr><tr><td>  nineteen <br></td><td>  Sigcont <br></td><td>  Continuation of the previously stopped process <br></td></tr></tbody></table><br>  If the bash shell receives a <code>SIGHUP</code> signal when you close the terminal, it terminates.  Before exiting, it sends a <code>SIGHUP</code> signal to all processes running in it, including running scripts. <br><br>  The <code>SIGINT</code> signal temporarily stops the operation.  The Linux kernel no longer allocates processor time to the shell.  When this happens, the shell notifies the processes by sending them a <code>SIGINT</code> signal. <br><br>  Bash scripts do not control these signals, but they can recognize them and execute certain commands to prepare the script for the consequences caused by the signals. <br><br><h2>  <font color="#3AC1EF">Sending signals to scripts</font> </h2><br>  The bash shell allows you to send signals to scripts using keyboard shortcuts.  This is very useful if you need to temporarily stop the running script or terminate it. <br><br><h3>  <font color="#3AC1EF">Shutdown process</font> </h3><br>  The <code>CTRL + C</code> key combination generates a <code>SIGINT</code> signal and sends it to all processes running in the shell, which leads to their completion. <br><br>  Run the following command in the shell: <br><br><pre> <code class="hljs perl">$ <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br>  After that, we will complete her work with the <code>CTRL + C</code> key combination. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/6fa/3d5/9376fa3d5c77d38976f575f4bef8b2c2.png"></div><br>  <i><font color="#999999">Shutting down the process from the keyboard</font></i> <br><br><h3>  <font color="#3AC1EF">Pause process</font> </h3><br>  The <code>CTRL + Z</code> key combination allows you to generate a <code>SIGTSTP</code> signal, which pauses the process but does not complete its execution.  Such a process remains in memory, its work can be resumed.  Run the command in the shell: <br><br><pre> <code class="hljs perl">$ <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br>  And temporarily stop it with the key combination <code>CTRL + Z</code> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/0cd/419/b590cd419f80c0561924073eb776ee1e.png"></div><br>  <i><font color="#999999">Process suspension</font></i> <br><br>  The number in square brackets is the job number that the shell assigns to the process.  The shell considers the processes running in it as tasks with unique numbers.  The first process is assigned number 1, the second - 2, and so on. <br><br>  If you pause the task associated with the shell and try to exit it, bash will issue a warning. <br><br>  You can view suspended tasks with the following command: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ps</span></span> ‚Äìl</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb5/87e/940/cb587e940d70ca8d553b89eeaca21f79.png"></div><br>  <i><font color="#999999">Task list</font></i> <br><br>  For a suspended process, <code>T</code> is displayed in column <code>S</code> , which displays the status of the process.  This indicates that the command is either suspended or in the trace state. <br><br>  If you need to shut down a suspended process, you can use the <code>kill</code> command.  Details about it can be read <a href="https://likegeeks.com/main-linux-commands-easy-guide/">here</a> . <br><br>  Her call looks like this: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> processID</code> </pre> <br><h2>  <font color="#3AC1EF">Interception of signals</font> </h2><br>  To enable Linux signal tracking in the script, use the <code>trap</code> command.  If the script receives the signal specified when calling this command, it processes it independently, and the shell will not process such a signal. <br><br>  The <code>trap</code> command allows the script to respond to signals, otherwise they are processed by the shell without its participation. <br><br>  Consider an example that shows how when you call the <code>trap</code> command, you <code>trap</code> code to be executed and the list of signals separated by spaces that we want to intercept.  In this case, this is just one signal: <br><br><pre> <code class="hljs swift">#!/bin/bash trap <span class="hljs-string"><span class="hljs-string">"echo ' Trapped Ctrl-C'"</span></span> <span class="hljs-type"><span class="hljs-type">SIGINT</span></span> echo <span class="hljs-type"><span class="hljs-type">This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a test script <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">10</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  The <code>trap</code> command used in this example displays a text message whenever it detects a <code>SIGINT</code> signal, which can be generated by pressing <code>Ctrl + C</code> on the keyboard. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83d/18c/ae5/83d18cae50802de6c4d705c36637c3b0.png"></div><br>  <i><font color="#999999">Interception of signals</font></i> <br><br>  Each time you press <code>CTRL + C</code> , the script executes the <code>echo</code> command specified by the <code>trace</code> call instead of letting the shell exit. <br><br><h2>  <font color="#3AC1EF">Interception of an exit signal from a script</font> </h2><br>  You can intercept the exit signal from the script by using the name of the signal <code>EXIT</code> when calling the <code>trap</code> command: <br><br><pre> <code class="hljs swift">#!/bin/bash trap <span class="hljs-string"><span class="hljs-string">"echo Goodbye..."</span></span> <span class="hljs-type"><span class="hljs-type">EXIT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">5</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/eb3/f1d/7bbeb3f1d02a61f02878cc119a1c1076.png"></div><br>  <i><font color="#999999">Interception of an exit signal from a script</font></i> <br><br>  When exiting the script, be it a normal shutdown or shutdown caused by a <code>SIGINT</code> signal, the interception will trigger and the shell will execute the <code>echo</code> command. <br><br><h2>  <font color="#3AC1EF">Modification of intercepted signals and cancellation of interception</font> </h2><br>  To modify the signals captured by the script, you can issue the <code>trap</code> command with new parameters: <br><br><pre> <code class="hljs swift">#!/bin/bash trap <span class="hljs-string"><span class="hljs-string">"echo 'Ctrl-C is trapped.'"</span></span> <span class="hljs-type"><span class="hljs-type">SIGINT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">5</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done trap <span class="hljs-string"><span class="hljs-string">"echo ' I modified the trap!'"</span></span> <span class="hljs-type"><span class="hljs-type">SIGINT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">5</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Second Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/916/a7a/72e/916a7a72e1abdfc4dc5126ad031c601f.png"></div><br>  <i><font color="#999999">Modification of signal interception</font></i> <br><br>  After modification, the signals will be processed in a new way. <br><br>  Interception of signals can be canceled, for this it is enough to execute the <code>trap</code> command, passing it a double dash and the name of the signal: <br><br><pre> <code class="hljs swift">#!/bin/bash trap <span class="hljs-string"><span class="hljs-string">"echo 'Ctrl-C is trapped.'"</span></span> <span class="hljs-type"><span class="hljs-type">SIGINT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">5</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done trap -- <span class="hljs-type"><span class="hljs-type">SIGINT</span></span> echo <span class="hljs-string"><span class="hljs-string">"I just removed the trap"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">5</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Second Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  If the script receives a signal before the interception is canceled, it will process it as specified in the current <code>trap</code> command.  Run the script: <br><br><pre> <code class="hljs ruby">$ ./myscript</code> </pre> <br>  And press <code>CTRL + C</code> on the keyboard. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9df/198/61e/9df19861e4a635dcd0e3dcfb6a48bdeb.png"></div><br>  <i><font color="#999999">Signal captured before interception cancellation</font></i> <br><br>  The first pressing of <code>CTRL + C</code> was at the time the script was executed, when the signal interception was in effect, so the script executed the <code>echo</code> command assigned to the signal.  After the execution reached the intercept cancellation command, the <code>CTRL + C</code> command worked in the usual way, exiting the script. <br><br><h2>  <font color="#3AC1EF">Running command line scripts in the background</font> </h2><br>  Sometimes bash scripts take a long time to complete a task.  In this case, you may need to be able to work normally on the command line, without waiting for the script to complete.  Implementing it is not so difficult. <br><br>  If you saw the list of processes displayed by the <code>ps</code> command, you might have noticed processes that run in the background and are not tied to the terminal. <br>  Let's write this script: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">10</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sleep <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  Run it by specifying an ampersand ( <code>&amp;</code> ) after the name: <br><br><pre> <code class="hljs ruby">$ ./myscipt &amp;</code> </pre> <br>  This will cause it to run as a background process. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/5f0/b34/b695f0b34f4569d1bacf26e43320dba9.png"></div><br>  <i><font color="#999999">Running the script in the background</font></i> <br><br>  The script will run in the background process, its identifier will be displayed in the terminal, and when its execution is completed, you will see a message about it. <br><br>  Note that although the script runs in the background, it continues to use the terminal to display messages in <code>STDOUT</code> and <code>STDERR</code> , that is, the text or error messages it displays can be seen in the terminal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/419/a3d/2da419a3df3716a57b260cea3ae2458e.png"></div><br>  <i><font color="#999999">Process list</font></i> <br><br>  With this approach, if you exit the terminal, the script running in the background will also terminate. <br><br>  What if you want the script to continue working after the terminal is closed? <br><br><h2>  <font color="#3AC1EF">Execution of scripts that do not shut down when closing the terminal</font> </h2><br>  Scripts can be executed in background processes even after exiting a terminal session.  You can use the <code>nohup</code> command to do this.  This command allows you to start the program, blocking the <code>SIGHUP</code> signals sent to the process.  As a result, the process will be executed even when exiting the terminal in which it was launched. <br><br>  Apply this technique when running our script: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">nohup</span></span> ./myscript &amp;</code> </pre> <br>  This is what will be displayed in the terminal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b19/617/919b196174424f1f93d3f172d644980d.png"></div><br>  <i><font color="#999999">Nohup command</font></i> <br><br>  The <code>nohup</code> command unbinds the process from the terminal.  This means that the process will lose references to <code>STDOUT</code> and <code>STDERR</code> .  In order not to lose the data output by the script, <code>nohup</code> automatically forwards messages arriving in <code>STDOUT</code> and <code>STDERR</code> to the file <code>nohup.out</code> . <br><br>  Please note that when running several scripts from the same directory, what they output will fall into one file <code>nohup.out</code> . <br><br><h2>  <font color="#3AC1EF">View assignments</font> </h2><br>  The <code>jobs</code> command allows you to view current jobs that are running in the shell.  Let's write this script: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> -le <span class="hljs-number"><span class="hljs-number">10</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Loop #$count"</span></span> sleep <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  Run it: <br><br><pre> <code class="hljs ruby">$ ./myscript</code> </pre> <br>  And temporarily stop the key combination <code>CTRL + Z</code> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/34f/505/e3934f505f0d1029a3cc706129ea6cd9.png"></div><br>  <i><font color="#999999">Start and pause script</font></i> <br><br>  Let's run the same script in the background, while redirecting the output of the script to a file so that it does not display anything on the screen: <br><br><pre> <code class="hljs ruby">$ ./myscript &gt; outfile &amp;</code> </pre> <br>  Having now <code>jobs</code> command, we will see information about both the suspended script and the one that works in the background. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ca/9bb/7f2/0ca9bb7f2f04c6a656ede99cb1365158.png"></div><br>  <i><font color="#999999">Retrieving Script Information</font></i> <br><br>  The <code>-l</code> switch when invoking the <code>jobs</code> command indicates that we need information about process <code>ID</code> . <br><br><h2>  <font color="#3AC1EF">Restart suspended jobs</font> </h2><br>  In order to restart the script in the background, you can use the <code>bg</code> command. <br><br>  Run the script: <br><br><pre> <code class="hljs ruby">$ ./myscript</code> </pre> <br>  Press <code>CTRL + Z</code> , which temporarily stops its execution.  Run the following command: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">bg</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/a1d/bbd/105a1dbbd3148791c3259fd3ca66f10c.png"></div><br>  <i><font color="#999999">Bg command</font></i> <br><br>  Now the script runs in the background. <br><br>  If you have several suspended tasks, you can transfer its number to the <code>bg</code> command to restart a specific task. <br><br>  To restart the job in normal mode, use the <code>fg</code> command: <br><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">fg</span></span> 1</code> </pre> <br><h2>  <font color="#3AC1EF">Script Scheduling</font> </h2><br>  Linux provides a couple of ways to run bash scripts at a specified time.  This is the <code>at</code> command and the <code>cron</code> job scheduler. <br><br>  Calling the at command looks like this: <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">at</span></span> [-f filename] <span class="hljs-built_in"><span class="hljs-built_in">time</span></span></code> </pre> <br>  This command recognizes multiple time indication formats. <br><br><ul><li>  Standard, with hours and minutes, for example - 10:15. </li><li>  Using AM / PM indicators, before or after noon, for example - 10:15 PM. </li><li>  Using special names such as <code>now</code> , <code>noon</code> , <code>midnight</code> . </li></ul><br>  In addition to the possibility of specifying the start time of a job, the <code>at</code> command can also be passed a date using one of its supported formats. <br><br><ul><li>  The standard format for specifying the date at which the date is written according to the templates <code>MMDDYY</code> , <code>MM/DD/YY</code> , or <code>DD.MM.YY</code> </li><li>  Textual representation of the date, for example, <code>Jul 4</code> or <code>Dec 25</code> , while the year can be specified, or you can do without it. </li><li>  Record <code>now + 25 minutes</code> . </li><li>  Record type <code>10:15PM tomorrow</code> . </li><li>  Record type <code>10:15 + 7 days</code> . </li></ul><br>  We will not go into this topic, consider a simple way to use the command: <br><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> -f ./myscript now</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41b/3df/99c/41b3df99c30ec2c689f435b03a249225.png"></div><br>  <i><font color="#999999">Scheduling tasks using the at command</font></i> <br><br>  The <code>-M</code> key when calling <code>at</code> used to send what the script displays to the email if the system is properly configured.  If sending the email is not possible, this key will simply suppress the output. <br><br>  To view the list of tasks waiting to be completed, you can use the <code>atq</code> command: <br><br><pre> <code class="hljs ruby">$ atq</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b03/ceb/bce/b03cebbcef29c5e9532c6be32df21e34.png"></div><br>  <i><font color="#999999">List of tasks awaiting execution</font></i> <br><br><h2>  <font color="#3AC1EF">Deleting tasks waiting to be completed</font> </h2><br>  To remove a task that is pending execution, the <code>atrm</code> command <code>atrm</code> .  When you call it indicate the job number: <br><br><pre> <code class="hljs ruby">$ atrm <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30e/a31/76f/30ea3176f974fc0d9a8a9c56d465f908.png"></div><br>  <i><font color="#999999">Delete job</font></i> <br><br><h2>  <font color="#3AC1EF">Run scripts on a schedule</font> </h2><br>  Planning to run scripts once using the <code>at</code> command can make life easier in many situations.  But what if you want the script to run at the same time every day, or once a week, or once a month? <br><br>  Linux has a <code>crontab</code> utility that allows you to schedule scripts to run regularly. <br><br>  <code>Crontab</code> runs in the background and, based on data in the so-called cron-tables, runs jobs on a schedule. <br><br>  To view the existing <code>cron</code> job table, use the following command: <br><br><pre> <code class="hljs ruby">$ crontab ‚Äìl</code> </pre> <br>  When scheduling a script to run according to a schedule, <code>crontab</code> accepts data on when the task should be performed in the following format: <br><br><pre> <code class="hljs 1c"><span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-built_in"><span class="hljs-built_in"></span></span> , <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-built_in"><span class="hljs-built_in"></span></span> .</code> </pre> <br>  For example, if it is necessary that a certain script with the name <code>command</code> executed daily at 10:30, this would correspond to the following entry in the task table: <br><br><pre> <code class="hljs markdown">30 10 <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> * command</code> </pre> <br>  Here, the universal symbol " <code>*</code> ", used for the fields that specify the day of the month, the month and the day of the week, indicates that <code>cron</code> must execute the command every day of every month at 10:30. <br><br>  If, for example, you want the script to run at <code>4:30PM</code> every Monday, you will need to create the following entry in the task table: <br><br><pre> <code class="hljs markdown">30 16 <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> 1 command</code> </pre> <br>  The numbering of the days of the week starts with 0, 0 means Sunday, 6 means Saturday.  Here is another example.  Here the command will be executed at 12 noon on the first day of each month. <br><br><pre> <code class="hljs markdown">00 12 1 <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> command</code> </pre> <br>  The numbering of the months starts from 1. <br>  To add an entry to the table, you need to call <code>crontab</code> with the <code>-e</code> key: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">crontab</span></span> ‚Äìe</code> </pre> <br>  Then you can enter the schedule generation commands: <br><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> * * * <span class="hljs-regexp"><span class="hljs-regexp">/home/likegeeks</span></span><span class="hljs-regexp"><span class="hljs-regexp">/Desktop/myscript</span></span></code> </pre> <br>  Thanks to this command, the script will be called daily at 10:30.  If you encounter the error ‚ÄúResource temporarily unavailable‚Äù, execute the following command with root user rights: <br><br><pre> <code class="hljs swift">$ rm -f /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/crond.pid</code> </pre> <br>  It is even easier to organize the periodic launch of scripts using <code>cron</code> , using several special directories: <br><br><pre> <code class="hljs">/etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly</code> </pre> <br>  If you place the script file in one of them, it will lead, respectively, to its hourly, daily, weekly or monthly launch. <br><br><h2>  <font color="#3AC1EF">Running scripts at login and at shell startup</font> </h2><br>  Automate the launch of scripts can be based on various events, such as user logon or shell launch.  <a href="https://likegeeks.com/linux-environment-variables/">Here</a> you can read about the files that are processed in such situations.  For example, these are the following files: <br><br><pre> <code class="hljs perl">$HOME/.bash_profile $HOME/.bash_login $HOME/.profile</code> </pre> <br>  To run the script at login, place its call in the <code>.bash_profile</code> file. <br><br>  What about running scripts when opening a terminal?  Organize this will help file <code>.bashrc</code> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we discussed issues related to the management of the life cycle of scenarios, talked about how to run scripts in the background, how to plan their execution on a schedule.  Next time, read about functions in bash scripts and library development. <br><br>  Dear readers!  Do you use the tools to schedule the launch of command line scripts on a schedule?  If so, please tell us about them. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/326826/">https://habr.com/ru/post/326826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326814/index.html">Working with ConstraintLayout via XML Markup</a></li>
<li><a href="../326816/index.html">Let's start with mathematics. Vectorization of calculations in the implementation of technology RAID-6</a></li>
<li><a href="../326818/index.html">Week before the International Mobile Conference MBLT17</a></li>
<li><a href="../326822/index.html">The main thing is the tail. Software development pipeline technology</a></li>
<li><a href="../326824/index.html">Scaling TLS</a></li>
<li><a href="../326828/index.html">Permafrost, coal mine and piqlFilm: a new approach to data storage and protection</a></li>
<li><a href="../326830/index.html">We write Telegram-bot on Rust, which will run the code on ... Rust?</a></li>
<li><a href="../326832/index.html">How to approach the analysis of the site in terms of a hacker and identify vulnerabilities?</a></li>
<li><a href="../326834/index.html">Amateur CNC?</a></li>
<li><a href="../326840/index.html">Mustached shooter with a polygonal belly. Part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>