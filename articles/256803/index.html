<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IO Ninja is a programmable terminal emulator / sniffer (part 3). We write "answering machine"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the cycle of articles about the terminal / sniffer IO Ninja and proceed to consider one of the most advantageous sides of the new version ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IO Ninja is a programmable terminal emulator / sniffer (part 3). We write "answering machine"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b61/b7e/756/b61b7e756a1f85df0edf526a0ccf3e0c.png" alt="jancy" align="right">  We continue the <a href="http://habrahabr.ru/company/tibbo/blog/255221/">cycle of articles</a> about the terminal / sniffer <a href="http://tibbo.com/ioninja/">IO Ninja</a> and proceed to consider one of the most advantageous sides of the new version of our product - programmability.  It opens up new applications of such seemingly ordinary tools as a terminal or sniffer. <br><br><h1>  Plugin Architecture Overview </h1><br>  As in the previous, second version of the product, the executable files of the third version of IO Ninja contain only the framework of necessary components (including UI widgets, logging engine and classes for working with IO, such as io.Socket, io.Serial, io.PCap, and t .d.)  The logic of working with specific transports is contained in plugins written in the <a href="http://tibbo.com/jancy/">Jancy</a> language.  These plug-ins are located in the selected ‚Äúscripts‚Äù folder as source codes and are available both for review and editing by users. <br><a name="habracut"></a><br clear="all">  In addition to modifying the built-in plug-ins, it is also possible to add the missing functionality using custom plug-ins of two types: <br><br><ol><li>  Session plugin (session plugin) - heavy; </li><li>  Plugin layer (layer plugin) - easy. </li></ol><br>  The first type of plug-in is a full-fledged session plugin that creates a session from scratch.  Here is what should be implemented in a typical session plugin: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Defining the format of records in a log and creating a log representative ‚Äî a function that turns log entries into a final, readable representation; </li><li>  Formation of UI (menu, buttons on the toolbar, properties in the property editor, etc.); </li><li>  Creation of transport and other IO-objects (sockets, ports, files, etc.); </li><li>  Handling events from UI widgets and IO objects and tying everything together. <div class="spoiler">  <b class="spoiler_title">for example</b> <div class="spoiler_text">  by pressing the connect button, it is necessary to start the connection setup process, make an entry in the log with the ‚Äústart-install-connection‚Äù code and data describing the remote node address;  When the connection is completed, create a corresponding entry in the log and update the UI (in particular, unblock the Send button), etc. </div></div></li></ul><br>  In principle, using a session plugin, you can write a solution for any task, from testing a certain sequence of requests and responses to a full-fledged protocol analyzer.  However, even without familiarizing yourself with the source code of embedded IO Ninja sessions, it is obvious that writing a complete session is quite a laborious process, not very suitable for rapid prototyping and writing test scripts on your knees.  In addition, I do not want to re-implement or copy-paste the logic of working with the transport connection.  After all, this is all done in standard plugins, what about reuse?  Finally, the writing of a full-fledged session largely ties everything to one specific transport, while at times it is necessary, for example, to check a certain sequence of requests on several different transports at once.  Similarly, a protocol analyzer often simply needs to parse the data, regardless of which transport it was delivered to. <br><br>  To solve all the above problems, IO Ninja provides a second type of plug-in - a light plugin layer (layer plugin). <br><br>  Plugin layer cannot work by itself.  Instead, it connects to a carrier session and expands its functionality accordingly.  He can do this with the help of: <br><br><ul><li>  Changes to the log representative; </li><li>  Attaching a log filter to ‚Äúdisguise‚Äù unwanted / uninteresting entries; </li><li>  Attachment of a log converter to generate secondary logs for decoding protocol messages (this usually also requires changing the log representative); </li><li>  Joining a log listener to monitor the events of the carrier session and, possibly, to perform some kind of response; </li><li>  Creating your own UI elements in addition to the UI carrier session. </li></ul><br>  The plugin layer is what most likely will have to be written for most practical tasks. <br><br><h1>  IDE </h1><br>  To facilitate the development of all types of IO Ninja plug-ins on Jancy, we provide the native integrated development environment IO Ninja IDE.  This environment is based on the <a href="https://netbeans.org/features/platform/index.html">NetBeans Platform</a> and provides all the standard code assist tools: syntax highlighting, auto-completion lists, argument-tips, go-to-definition lists, etc.  In addition, there are wizards for generating templates of typical plugins. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/8d9/6df/c1a8d96df1ce0a19a96ba674697c9cd2.png" alt="IO Ninja IDE"><br><br>  This development environment is delivered in two variations.  The first is a separate IO Ninja IDE package, which is installed as a standalone product.  The second variation is suitable for developers who already have and use NetBeans for their projects (like several programmers in our office, including me).  In this case, instead of installing a separate IO Ninja IDE, you can add NetBeans plug-ins for IO Ninja to an already present NetBeans installation.  Both the first and second options can be found here: <a href="http://tibbo.com/ioninja/downloads.html">http://tibbo.com/ioninja/downloads.html</a> . <br><br>  Developers who for some reason do not like NetBeans, or who do not recognize the IDE as such, can develop plug-ins in their favorite text editor - vim, emacs, sublime, notepad finally. <br><br>  Next, we will demonstrate the process of creating from scratch typical plugins using IO Ninja IDE.  As a test protocol that our plug-ins will work with, let's take a real protocol for communicating Tibbo programmable devices with an interactive cross-debugger.  For testing, you can use Device Explorer, which is part of the TIDE IDE development environment for Tibbo programmable devices (download TIDE or a separate Device Explorer here: <a href="http://tibbo.com/downloads/basic/software.html">http://tibbo.com/downloads/basic/software.html</a> ). <br><br>  So let's get started. <br><br><h1>  Answering machine </h1><br>  The first plugin we write will emulate a server of a certain protocol (in our example, the Tibbo programmable device protocol) to help us test the client side of this protocol.  In other words, our plugin will perform the functions of an answering machine, namely: wait for the data, assemble them into packets, analyze and send something in response. <br><br>  Launch IO Ninja IDE (or NetBeans with plug-ins for IO Ninja), click on the menu item File-&gt; New Project, and select the project category: Categories - IO Ninja, Projects - Plugin Project (if you use a separate IO Ninja IDE, then these categories will be only available).  On the next screen, select the plugin type plugin type template - Answering Machine, drive in some meaningful name in the Project Name (for example, TiosEmu) and click Next. <br><br><img src="http://tibbo.com/images/ninja/habrahabr/ide-new-plugin.png" alt="image"><br><br>  After filling the string descriptors on the next screen (Layer Name, Layer Description, etc.) and clicking the Finish button, the plug-in working core will be generated: the plugin sends a meaningful response to the ‚Äúhelp‚Äù, ‚Äúabout‚Äù and ‚Äúversion‚Äù commands in its original form, CR (carriage return) or LF (line feed). <br><br>  Run the plugin to look at its work.  As mentioned above, the plug-in layer cannot work by itself and requires a carrier session, which must provide transport.  When you run the plugin layer for the first time, IO Ninja IDE will ask you what to use as a carrier session. <br><br>  For testing, select TCP Listener, adapter ‚ÄúAll IPv6 adapters‚Äù, port 1001, click Listen.  Open the second session of TCP Connection, remote address "[:: 1]: 1001", click Connect (as you guessed, it was an unobtrusive demonstration of IPv6 support, which appeared in version 3.4.0;) <br><br>  Now send the ‚Äúhelp‚Äù, ‚Äúabout‚Äù or ‚Äúversion‚Äù commands (possible in chunks) and enjoy the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2a/c4f/67e/e2ac4f67e777c9843c6e0fbba59d25c7.png" alt="image"><br><br>  Now let's analyze our plugin a bit.  Open the only source file of the plugin TiosEmuLayer.jnc.  The plug-in essentially consists of one TiosEmuLayer class inherited from doc.Layer, the base class for layer plug-ins (using Ctrl + Click, you can walk through API declarations and familiarize yourself with the framework of available IO Ninja components). <br><br>  Let's look at the constructor of our plugin: <br><br><pre><code class="cpp hljs">construct (doc.PluginHost* pluginHost) { basetype.construct (pluginHost); m_rxScanner.construct (scanRx); pluginHost.m_log.attachListener (onLogRecord @ pluginHost.m_mainThreadScheduler); }</code> </pre> <br>  The first and second lines are clear without comments - as you can guess, the calls to the constructors of the parent class and the member field.  But the last line requires some explanation. <br><br>  The log file in IO Ninja is a sequence of records, each of which contains a timestamp, an integer record code, and (optionally) a block of arbitrary binary data.  Immediately, we note that this block does not carry the text itself, in the form in which the user sees it in the log window, but the necessary parameters by which this text can be restored (the recovery of text lines of the log with the help of representative functions will be described in more detail in section dedicated to the creation of a protocol analyzer plugin). <br><br>  When a session plugin receives or sends data, corresponding records are added to the log.  The plugin layer can ‚Äúmonitor‚Äù the log for new entries, select from them those that are of interest (for example, RX) and perform certain actions in response. <br><br>  This model - although at first it may seem somewhat unnatural (why not monitor events on the socket immediately instead of a log?), Was chosen according to a number of parameters: simple to implement, transparent and predictable, provides standardization in interactions of plug-ins of arbitrary nature, suitable for creating cascades of processing, does not introduce strong connectivity, etc.  Of course, such a model has certain limitations, but we will not dwell on this here in detail. <br><br>  The attachListener method adds the log listener.  The next non-obvious point is the use of the dog @.  In Jancy, the dog @ (reads ‚Äúat‚Äù) denotes a binary layout operator to create pointers to functions that are guaranteed to be called in the desired environment.  In this case, we want the listener to be called in the main thread of the plugin. <br><br>  Inside our listener, we check the record code and, if it is log.StdRecordCode.Rx (that is, incoming data), we pass it for further processing, and otherwise we ignore it: <br><br><pre> <code class="cpp hljs">onLogRecord ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> timestamp, <span class="hljs-keyword"><span class="hljs-keyword">uint_t</span></span> recordCode, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recordCode == <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.StdRecordCode.Rx) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> m_rxScanner.write (p, size); }</code> </pre><br>  Now let's dwell on the mechanism for processing incoming data in emulators and protocol analyzers. <br><br>  Communication protocols can be divided into categories according to various criteria: protocol level in the OSI model, packet-oriented (message-oriented protocols) and stream-oriented (stream-oriented-protocols), binary and text, etc. <br><br>  In terms of writing a protocol analyzer, two factors represent the greatest value: <br><br><ol><li>  whether the protocol relies on the delivery of the message as a whole (or is pre-accumulation required); </li><li>  whether fixed headers are used (or do requests and responses have different lengths, and requires parsing of the request / response language by a certain parser). </li></ol><br>  For example, TCP / IP stack protocols down to the transport layer inclusive rely on the delivery of messages as a whole and use fixed headers, and at the levels above there are options: let's say DHCP relies on delivery as a whole and uses headers, and HTTP works with the stream and uses text requests / replies. <br><br>  In the case where fixed headers are used, it is most convenient to parse the protocols using the mechanism of structures, pointers and address arithmetic supported by Jancy and familiar to C / C ++ programmers.  Here, the fact that Jancy has a high degree of compatibility with C / C ++ will help a lot - it allows you to simply copy the C-definitions of protocol headers from publicly available sources and directly paste them into the Jancy script (sometimes even cosmetic changes are not required). <br><br>  Unfortunately, this mechanism is completely unsuitable for parsing protocols belonging to the opposite category, namely, when, instead of going through the structures of headers, it is necessary to analyze the language of requests / responses.  In this case, a certain <i>parser</i> is required - it means that it is logical to apply the methodology that is used when building compilers.  To be fair, it should be noted that the grammar of the query language in protocols is, as a rule, immeasurably simpler than that in even the most primitive programming languages. <br><br>  So.  The first stage in the compilation cascade is lexical analysis (or tokenization), that is, the division into lexemes and the transformation of the input stream of characters into a stream of tokens.  The module that performs this task is called the lexer (or scanner).  Unlike file compilers, writing a lexer for a streaming protocol is complicated by the fact that it is not always easy to split the input IO stream into compilation units. <br><br>  In Jancy, as in the language that was specifically created for use in IO Ninja, there is a convenient tool for parsing IO streams.  This is a built-in incremental lexical analyzer generator.  It works on the principle of well-known tools like <a href="http://en.wikipedia.org/wiki/Lex_(software)">Lex</a> , <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> , <a href="http://www.complang.org/ragel/">Ragel</a> , etc.  Let's look at the code generated by the wizard: <br><br><pre> <code class="cpp hljs">jnc.AutomatonResult automaton TiosEmuLayer.scanRx () { %% <span class="hljs-string"><span class="hljs-string">"about"</span></span> [\r\n] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmitString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"IO Ninja - Tios Emu\r\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; %% <span class="hljs-string"><span class="hljs-string">"version"</span></span> [\r\n] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmitString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Version 1.0.0\r\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; %% <span class="hljs-string"><span class="hljs-string">"help"</span></span> [\r\n] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmitString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"This is a starting point for your test utility\r\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; %% . <span class="hljs-comment"><span class="hljs-comment">// ignore everything else }</span></span></code> </pre><br>  Automaton functions are compiled into a DFA to recognize lexemes, each of which is described using a regular expression.  When the machine detects a token, it performs the corresponding action. <br><br>  The automaton function itself cannot be called directly - after all, it is necessary to store the state of the automaton somewhere (including the accumulated part of the token).  For this purpose, an object of the jnc.Recognizer class is used, and already it will implicitly call our automaton, make necessary transitions between states, rollbacks, accumulation of token characters, etc. <br><br>  Here is an instance of this class in the generated plugin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TiosEmuLayer</span></span></span><span class="hljs-class">:</span></span> doc.Layer { jnc.Recognizer m_rxScanner; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  As an analogy clear to all, the following example can be given.  There is a game console and there is a game disc.  To play the game, you need to insert a disk into the console.  In this case, the game can be played incrementally, since the status of the passage is saved on the hard disk of the console.  In this example, replace the prefix with a copy of the jnc.Recognizer class, the game disc is replaced by an automaton function, and the passing of the game is replaced by the input stream, and everything will fall into place. <br><br>  But enough theory, let's practice: let's add to our plug-in command recognition TiOS. <br><br>  First, TiOS works via UDP, which means that incremental parsing with state preservation between the received data segments does not make sense and is even harmful: one datagram is one command.  Therefore, instead of jnc.Recognizer.write, we will use the jnc.Recognizer.recognize method (which takes place in the sequence reset, write, eof) <br><br>  Further, since the TiOS device in its original state does not have an IP address at all (it must be assigned by an application spinning on the device, either from settings or from a DHCP server), direct IP addressing is generally impossible.  Therefore, the TiOS protocol uses the broadcast IP address to communicate with the device, and the device uses the MAC address in the packet body to address the device when broadcasting. <br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  The MAC address of the ethernet frame, by the way, does not have to be broadcast.  Many modern switches artificially limit the allowed speed of broadcast traffic, so our interactive cross-debugger TIDE uses PCap to generate UDP frames, in which IP is broadcast, and here is MAC - of a specific device. </div></div><br>  Add a field with the MAC of our fictitious device to the plugin class (note the hex-literal, a means of Jancy's convenient assignment of hard-coded binary constants, for example, icons, cursors, public keys, etc.): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uchar_t</span></span> MacAddress [<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TiosEmuLayer</span></span></span><span class="hljs-class">:</span></span> doc.Layer { MacAddress m_macAddress = <span class="hljs-number"><span class="hljs-number">0</span></span>x<span class="hljs-string"><span class="hljs-string">"1 2 3 4 5 6"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_macAddressString = formatMacAddress (m_macAddress); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Let's write a couple of helpers to work with MAC addresses - after all, we will have to check the MAC addresses of the commands that have arrived, as well as add the MAC to the response packets. <div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MacAddress </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMacAddress</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ MacAddress address; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { address [i] = (<span class="hljs-keyword"><span class="hljs-keyword">uchar_t</span></span>) atoi (p); p = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span> (p, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; p++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatMacAddress</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MacAddress address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"%1.%2.%3.%4.%5.%6"</span></span> ( address [<span class="hljs-number"><span class="hljs-number">0</span></span>], address [<span class="hljs-number"><span class="hljs-number">1</span></span>], address [<span class="hljs-number"><span class="hljs-number">2</span></span>], address [<span class="hljs-number"><span class="hljs-number">3</span></span>], address [<span class="hljs-number"><span class="hljs-number">4</span></span>], address [<span class="hljs-number"><span class="hljs-number">5</span></span>] ); }</code> </pre></div></div><br>  In addition to the MAC prefix, any TiOS packet can be terminated with a suffix to identify and match requests and responses (some analogue of the sequence number / acknowledgment number in TCP) - if the request contained such a suffix, then the response to this request should have the same suffix. <br><br>  Our plugin emulator will support the commands "?"  (echo), ‚ÄúX‚Äù (get-device-status), ‚ÄúPC‚Äù (get-vm-status), ‚ÄúB‚Äù (buzz) - this is enough to be seen from the Tibbo Device Explorer.  The first command is used to auto-detect devices in the local segment, the second and third commands return the expanded status of the device and the virtual machine. <br><br>  So, we sculpt a packet analyzer using automaton functions. <br><br><pre> <code class="cpp hljs">TiosEmuLayer.onLogRecord ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> timestamp, <span class="hljs-keyword"><span class="hljs-keyword">uint_t</span></span> recordCode, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recordCode != <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.StdRecordCode.Rx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> m_packetScanner.recognize (scanPacket, p, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) m_reply = <span class="hljs-string"><span class="hljs-string">"C"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* id = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span> (p, <span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// find id - if there's any try transmitString ($"[$m_macAddressString]$m_reply$id"); } jnc.AutomatonResult automaton TiosEmuLayer.scanPacket (jnc.Recognizer* recognizer) { %% "_?" m_reply = "A"; %% "_[" (\d+ '.')* \d+ ']' MacAddress address = parseMacAddress (recognizer.m_lexeme + 2); if (memcmp (address, m_macAddress, sizeof (address)) != 0) { m_reply = null; return jnc.AutomatonResult.Stop; // don't scan further } recognizer.m_automatonFunc = scanCommand; // change automaton }</span></span></code> </pre><br>  The onLogRecord function sends the RX data for analysis to the automatic function scanPacket and then sends a response packet (or silently quits if no answer is needed).  To form response packets, Jancy formatting literals (Perl-like formatting) are used. <br><br>  The machine scanPacket demonstrates the extremely useful possibility of parsing multilanguage input data (analogous to fgoto / fcall for changing machines in Ragel).  After parsing and checking the first part of the packet containing the MAC prefix, we ‚Äújump‚Äù to the second automaton, scanCommand, to parse the packet body with the actual command and identifying suffix: <br><br><pre> <code class="cpp hljs">jnc.AutomatonResult automaton TiosEmuLayer.scanCommand (jnc.Recognizer* recognizer) { %% id = <span class="hljs-string"><span class="hljs-string">'|'</span></span> .* %% <span class="hljs-string"><span class="hljs-string">'X'</span></span> id? m_reply = <span class="hljs-string"><span class="hljs-string">"A&lt;IONJ-3.4.0&gt;/ec8ec901-bb4b-4468-bfb9-bf482589cc17/test!"</span></span>; %% <span class="hljs-string"><span class="hljs-string">"PC"</span></span> id? m_reply = <span class="hljs-string"><span class="hljs-string">"A*R*/00/&amp;h A:0000,B:0000,PC:00000000,SP:00,FL:Z**/65535"</span></span>; %% <span class="hljs-string"><span class="hljs-string">'B'</span></span> id? m_reply = <span class="hljs-string"><span class="hljs-string">"A"</span></span>; }</code> </pre><br>  The second automaton demonstrates the ability to define named regular expressions for later use.  Note that standard classes of characters such as spaces, decimal digits, etc.  do not need special definitions and are accessible, as in Perl, through the escape sequences \ d, \ D, s, \ S, \ w, \ W. <br><br>  We launch our plug-in on the carrier UDP session, select the adapter ‚ÄúAll IPv4 Adapters‚Äù and open port 65535. We want our plug-in to respond to the address from which the request came - for this we select the Auto-switch Remote Address checkbox (a button with a compass ).  Now we start Device Explorer and we see the dummy device generated by our emulator.  Fanfare, fireworks, hulks. <br><br><img src="http://tibbo.com/images/ninja/habrahabr/device-explorer-tios-emu.png" alt="image"><br><br>  The full text of the plugin can be downloaded here: <a href="">http://tibbo.com/downloads/open/ioninja-plugin-samples/TiosEmu.zip</a> <br><br><h1>  Conclusion </h1><br>  Of course, the output we did not have a full-fledged TiOS emulator, but rather a blank blank.  However, this should be quite enough to demonstrate the concept itself and to understand which direction to dig further - this emulator may well serve as a starting point for writing some more useful testing utility in your particular case. <br><br>  In the next part of the article, we will look at creating a plug-in layer for analyzing the protocol. </div><p>Source: <a href="https://habr.com/ru/post/256803/">https://habr.com/ru/post/256803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256793/index.html">Why are you still hacked</a></li>
<li><a href="../256795/index.html">What kind of beast is HL7 Interoperability?</a></li>
<li><a href="../256797/index.html">New MSP432 Microcontroller Family</a></li>
<li><a href="../256799/index.html">Application KolibriOS. Part 1: Review</a></li>
<li><a href="../256801/index.html">How to save on the purchase of heavy iron</a></li>
<li><a href="../256805/index.html">HP StormRunner Load. A practical guide. Part II</a></li>
<li><a href="../256809/index.html">HP Blade Workshop Video</a></li>
<li><a href="../256811/index.html">Dino Esposito will perform in St. Petersburg</a></li>
<li><a href="../256813/index.html">Vivaldi TP3 - we do the browser together</a></li>
<li><a href="../256815/index.html">BalanceBall. Self-balancing platform from A to Z</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>