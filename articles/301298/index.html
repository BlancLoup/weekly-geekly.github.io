<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous Symphony: JavaFX Tasks and Netty Sockets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good Friday everyone! 

 We finally got around to a book about Netty, which was recommended to us, including grateful readers of our habroblog. 



 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous Symphony: JavaFX Tasks and Netty Sockets</h1><div class="post__text post__text-html js-mediator-article"> Good Friday everyone! <br><br>  We finally got around to a book about Netty, which was recommended to us, including grateful readers of our habroblog. <br><br><img src="https://habrastorage.org/files/f2b/ddf/398/f2bddf398ffb440495287edbf4d9f01c.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To be honest, we haven‚Äôt had anything narrow-topic in Java for a long time.  But the topic of Netty causes the most lively interest on Habr√©, so we decided to post a review material on it (the author got the idea of ‚Äã‚Äãthe post from <a href="http://www.amazon.com/Netty-Action-Norman-Maurer/dp/1617291471/">this</a> book) and arrange the most indicative survey.  Come in, speak up! <br><a name="habracut"></a><br><br>  This article explains how to integrate Netty client / server framework into a JavaFX application.  Although you can write a distributed application using simple protocols that work on a request / response model, such as HTTP or RMI, these protocols are often inefficient and not functional enough for applications requiring constant server updates, push notifications that perform long-term operations.  Netty uses an efficient network implementation based on asynchronous processing and state-dependent connections.  This structure allows you to do without additional tricks, for example, does not require a survey to update client code. <br><br>  By integrating Netty with JavaFX, you need to ensure that interactions with your UI are implemented in the interaction FX in your thread without blocking the UI.  Thus, you need to wrap Netty calls into the Task class from FX.  The FX Task class provides a stream for long-term operations, and in most cases you can let Netty just wait for a response ( <code>wait()</code> ).  This is done by calling sync (), which provides a lock, but does not cause the application to hang. <br><br>  This example is based on a program for the exchange of echo requests between the client and the server, which I found in the book " <a href="https://www.manning.com/books/netty-in-action">Netty in Action</a> " by Norman Maurer and Marvin Allen Wolftal.  After the connection is established, the client collects the string <code>java.lang.String</code> and sends it to the server.  The server converts this string with <code>toUpperCase()</code> and sends the resulting string back to the client.  The client displays a string in the user interface. <br><br>  All the code for this post is on <a href="https://github.com/bekwam/examples-javafx-repos1/tree/master/examples-javafx-parent/examples-javafx-netty-in-action">GitHub</a> . <br><br>  <b>Project</b> <br><br>  For convenience, I packed all server and client code into one Maven project.  The following UML class diagram shows which classes are in our program. <br><br><img src="https://habrastorage.org/files/477/821/1a3/4778211a35554a37a9625125a91565eb.png"><br><br>  FX Echo Client Class Diagram <br><br>  <code>EchoServer</code> and <code>EchoClient</code> contain <code>main()</code> functions, which are entry points for server and client processes.  <code>EchoServer</code> contains Netty code for bootstrapping, linking and creating a pipeline with a special <code>EchoServerHandler</code> handler.  <code>EchoClient</code> creates an <code>EchoClient</code> user interface <code>EchoClientController</code> that contains Netty code for creating a connection, breaking a connection, sending and receiving.  The <code>EchoClientController</code> also creates a client pipeline using the <code>EchoClientHandler</code> . <br><br>  The diagram shows the connection / send / receive / break connection sequence.  It is not normalized, therefore some operations (‚ÄúEnter Text‚Äù, ‚ÄúNetty Connect‚Äù) are nominal and are not in the code.  Data exchange in the program is mainly implemented using standard binding JavaFX and Netty Futures. <br><br><img src="https://habrastorage.org/files/84f/7a4/e50/84f7a4e504d34a3aa935296f020439ad.png"><br><br>  So, this is how our sequence looks like schematically. <br><br><ol><li>  The user clicks the Connect button. </li><li>  The <code>EchoClientController</code> controller <code>EchoClientController</code> and connects to the <code>EchoServer</code> . </li><li>  The user enters the text and presses the Send button. </li><li>  The <code>writeAndFlush()</code> operation is called on the channel.  The <code>channelRead()</code> and <code>channelReadComplete()</code> methods of the <code>channelRead()</code> handler are <code>EchoServerHandler</code> . </li><li>  The <code>channelRead()</code> method of the <code>channelRead()</code> handler performs its own <code>write()</code> method, and the <code>channelReadComplete()</code> method performs <code>flush()</code> . </li><li>  <code>EchoClientHandler</code> receives data </li><li>  <code>EchoClientHandler</code> sets the <code>EchoClientHandler</code> property associated with the UI.  Automatically updated <code>TextField</code> field in the UI. </li><li>  The user presses the Disconnect button. </li><li>  The EchoClientController controller closes its Channel channel and disables the EventGroup group (it is not shown in the diagram). </li></ol><br><br>  <b>Client Code</b> <br><br>  Since all the code is on GitHub, I will focus on the interaction of client-side JavaFX and Netty interaction.  Omitting a trivial subclass of EchoClient JavaFX Application that creates a scene (Stage) and loads an EchoClient.fxml file.  The client code we are interested in is in the <code>EchoClientController</code> class. <br><br>  <b>connect ()</b> <br><br>  The <code>connect()</code> method takes a host and a port from the UI and creates a Netty channel, which is then saved as an <code>EchoClientController</code> field. <br><br>  From EchoClientController.java <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> HBox hboxStatus; <span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> ProgressIndicator piStatus; <span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> Label lblStatus; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BooleanProperty connected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBooleanProperty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StringProperty receivingMessageModel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleStringProperty(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Channel channel; <span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( connected.get() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ;    } String host = tfHost.getText(); int port = Integer.parseInt(tfPort.getText()); group = new NioEventLoopGroup(); Task&lt;Channel&gt; task = new Task&lt;Channel&gt;() { @Override protected Channel call() throws Exception { updateMessage("Bootstrapping"); updateProgress(0.1d, 1.0d); Bootstrap b = new Bootstrap(); b .group(group) .channel(NioSocketChannel.class) .remoteAddress( new InetSocketAddress(host, port) ) .handler( new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new EchoClientHandler(receivingMessageModel)); } }); ChannelFuture f = b.connect(); Channel chn = f.channel(); updateMessage("Connecting"); updateProgress(0.2d, 1.0d); f.sync(); return chn; } @Override protected void succeeded() { channel = getValue(); connected.set(true); } @Override protected void failed() { Throwable exc = getException(); logger.error( "client connect error", exc ); Alert alert = new Alert(AlertType.ERROR); alert.setTitle("Client"); alert.setHeaderText( exc.getClass().getName() ); alert.setContentText( exc.getMessage() ); alert.showAndWait(); connected.set(false); } }; hboxStatus.visibleProperty().bind( task.runningProperty() ); lblStatus.textProperty().bind( task.messageProperty() ); piStatus.progressProperty().bind(task.progressProperty()); new Thread(task).start(); }</span></span></code> </pre><br><br>  Netty calls for initial download and connection are wrapped in a JavaFX task.  The task is a key concept when programming in JavaFX, and I have a rule: putting any code into a task that can potentially run for longer than a second.  Thus, I have almost everything in my tasks, with the exception of manipulations with Java objects in RAM. <br><br>  The task provides several properties: <code>runningProperty</code> , <code>messageProperty</code> , <code>progressProperty</code> .  I associate them with UI elements: a HBox container, a Label label, a ProgressIndicator indicator.  Thanks to JavaFX binding, there is no need to register listeners and call setter () methods on user interface controls. <br><br>  The <code>call()</code> method returns the channel.  In this implementation, I do not care about the asynchronous behavior of Netty - because I already work in the new <code>Thread()</code> - so I can wait until the <code>sync()</code> call returns.  The return value of the channel is set in the <code>succeeded()</code> method field  If Netty throws an exception, the <code>failed()</code> method is called, the message is logged and displayed to the user in a dialog box. <br><br>  The methods <code>succeeded()</code> , <code>failed()</code> , <code>updateMessage()</code> and <code>updateProgress()</code> are executed in the FX stream, but <code>call()</code> is not.  The <code>call()</code> method should not update the UI in any way.  The call () method should deal only with the long-term operation of Netty. <br><br>  <b>send ()</b> <br><br>  The <code>send()</code> method uses the saved <code>Channel</code> object to call the <code>writeAndFlush()</code> method.  This <code>writeAndFlush()</code> will be launched using the <code>EchoClientHandler</code> delegate via the Netty framework. <br><br>  Also from EchoClientController.java <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !connected.get() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String toSend = tfSend.getText(); Task task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Void </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ChannelFuture f = channel.writeAndFlush( Unpooled.copiedBuffer(toSend, CharsetUtil.UTF_8) ); f.sync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Throwable exc = getException(); logger.error( <span class="hljs-string"><span class="hljs-string">"client send error"</span></span>, exc ); Alert alert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Alert(AlertType.ERROR); alert.setTitle(<span class="hljs-string"><span class="hljs-string">"Client"</span></span>); alert.setHeaderText( exc.getClass().getName() ); alert.setContentText( exc.getMessage() ); alert.showAndWait(); connected.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }; hboxStatus.visibleProperty().bind( task.runningProperty() ); lblStatus.textProperty().bind( task.messageProperty() ); piStatus.progressProperty().bind(task.progressProperty()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(task).start(); }</code> </pre><br><br>  Notice the similarity with <code>connect()</code> .  The newly created task is connected with all the same three progress objects.  There is no <code>succeeded()</code> method, and the <code>failed()</code> method contains the same logic as the error handler in the <code>connect()</code> implementation. <br><br>  The task returns nothing (returned type is void).  In an optimistic scenario, the call should work right away, but if it didn‚Äôt work, then you should wait for an error.  Since the <code>call()</code> method is already in my new thread, I can afford to wait in the <code>sync()</code> method. <br><br>  <b>disconnect ()</b> <br><br>  The <code>disconnect()</code> method works with the Task task on the same principle as the two previous methods.  The other two methods use one updateMessage / Progress pair.  In this method, wrapping a connection with Netty takes place in two separate steps.  Not much time is needed to execute <code>sync()</code> in close ().  The <code>shutdownGracefully()</code> method takes significantly longer.  However, in my experiments, the UI never hung. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FXML</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !connected.get() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Task&lt;Voidgt; task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task&lt;Void&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Void </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ updateMessage(<span class="hljs-string"><span class="hljs-string">"Disconnecting"</span></span>); updateProgress(<span class="hljs-number"><span class="hljs-number">0.1</span></span>d, <span class="hljs-number"><span class="hljs-number">1.0</span></span>d); channel.close().sync(); updateMessage(<span class="hljs-string"><span class="hljs-string">"Closing group"</span></span>); updateProgress(<span class="hljs-number"><span class="hljs-number">0.5</span></span>d, <span class="hljs-number"><span class="hljs-number">1.0</span></span>d); group.shutdownGracefully().sync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">succeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ connected.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ connected.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); Throwable t = getException(); logger.error( <span class="hljs-string"><span class="hljs-string">"client disconnect error"</span></span>, t ); Alert alert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Alert(AlertType.ERROR); alert.setTitle(<span class="hljs-string"><span class="hljs-string">"Client"</span></span>); alert.setHeaderText( t.getClass().getName() ); alert.setContentText( t.getMessage() ); alert.showAndWait(); } }; hboxStatus.visibleProperty().bind( task.runningProperty() ); lblStatus.textProperty().bind( task.messageProperty() ); piStatus.progressProperty().bind(task.progressProperty()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(task).start(); }</code> </pre><br><br>  <b>Reading</b> <br><br>  Reading from the server is mediated through the <code>EchoClientHandler</code> object.  When creating this object, a reference is made to the <code>StringProperty</code> property, which is a model element with which the user interface is also associated.  I could pass UI elements directly to the handler, but at the same time the principle of sharing responsibility is violated and it becomes more difficult to apply this notification to several views at once.  Thus, the <code>StringProperty</code> property can communicate with any number of UI elements, and when an update comes from the handler, all these UI elements are updated. <br><br>  Here is the code for EchoClientHandler.java.  Note the FX Thread protection in the <code>channelRead0()</code> method. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Sharable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelInboundHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Logger logger = LoggerFactory.getLogger( EchoClientHandler.class ); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StringProperty receivingMessageModel; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoClientHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringProperty receivingMessageModel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.receivingMessageModel = receivingMessageModel; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelRead0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext arg0, ByteBuf in)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String cm = in.toString(CharsetUtil.UTF_8); Platform.runLater( () -&gt; receivingMessageModel.set(cm) ); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exceptionCaught</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ logger.error( <span class="hljs-string"><span class="hljs-string">"error in echo client"</span></span>, cause ); ctx.close(); } }</code> </pre><br><br>  The last note about the binding sequence ... we do not know when it will be called <br>  <code>channelRead0()</code> (in this case, we rely on asynchronous Netty), but when such a call occurs, we will set the model object.  I finish updating the model object, providing some protection for FX Thread.  FX - since it is a binding framework - will update all UI elements, for example, <code>TextField</code> . <br><br>  <b>Final Notes on Client Code</b> <br><br>  When integrating Netty with JavaFX, the most important thing is to use tasks.  Thanks to the tasks, the UI does not hang, thanks to the properties provided, all work can be tracked visually.  Thanks to the tasks, there is no need for asynchronous processing by Netty (at least at the application level), so tasks can be blocked for as long as possible without blocking the user interface.  When receiving notifications about new data, try using JavaFX binding, mediated through a dedicated model object, and thus updating the UI, rather than making individual calls to specific objects. <br><br>  <b>Server code</b> <br><br>  I just quote here the entire server code without comments, since the article is devoted to client aspects of Netty.  A very similar example is in the Manning book. <br><br>  From EchoServer.java <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( args.length != <span class="hljs-number"><span class="hljs-number">1</span></span> ) { System.err.println(<span class="hljs-string"><span class="hljs-string">"usage: java EchoServer port"</span></span>); System.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = Integer.parseInt(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EchoServer(port).start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EchoServerHandler echoServerHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EchoServerHandler(); EventLoopGroup group = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NioEventLoopGroup(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ServerBootstrap b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerBootstrap(); b .group(group) .channel(NioServerSocketChannel.class) .localAddress(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(port)) .childHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChannelInitializer() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SocketChannel ch)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ch.pipeline().addLast( echoServerHandler ); } }); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { group.shutdownGracefully().sync(); } } }  EchoServerHandler.java <span class="hljs-meta"><span class="hljs-meta">@Sharable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServerHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChannelInboundHandlerAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Logger logger = LoggerFactory.getLogger( EchoServerHandler.class ); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ByteBuf in = (ByteBuf)msg; String in_s = in.toString(CharsetUtil.UTF_8); String uc = in_s.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( logger.isInfoEnabled() ) { logger.info(<span class="hljs-string"><span class="hljs-string">"[READ] read "</span></span> + in_s + <span class="hljs-string"><span class="hljs-string">", writing "</span></span> + uc); } in.setBytes(<span class="hljs-number"><span class="hljs-number">0</span></span>, uc.getBytes(CharsetUtil.UTF_8)); ctx.write(in); <span class="hljs-comment"><span class="hljs-comment">//      ( ) } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { if( logger.isDebugEnabled() ) { logger.debug("[READ COMPLETE]"); } ctx.flush(); } @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { super.channelActive(ctx); if(logger.isDebugEnabled() ) { logger.debug("[CHANNEL ACTIVE]"); } ctx.channel().closeFuture().addListener(f -&gt; logger.debug("[CLOSE]")); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { logger.error( "error in echo server", cause); ctx.close(); } }</span></span></code> </pre><br><br>  Although modern high-speed computers may well spend some cycles on polling, thanks to the effective network level, your application will respond quickly and be dynamic, and also save the server from unnecessary work. </div><p>Source: <a href="https://habr.com/ru/post/301298/">https://habr.com/ru/post/301298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301288/index.html">Experience of moving to a Single Page Application with an emphasis on SEO</a></li>
<li><a href="../301290/index.html">UX for beginners: a practical guide. Part 1</a></li>
<li><a href="../301292/index.html">Yum, cheat sheet</a></li>
<li><a href="../301294/index.html">In Russia, launched the first accelerator for FMCG startups</a></li>
<li><a href="../301296/index.html">Air quality control (CO2 and temperature) in the office and at home, with their own hands</a></li>
<li><a href="../301300/index.html">How to create your own VPS hosting from scratch and start making money on it (introduction)</a></li>
<li><a href="../301302/index.html">Non-visual methods to protect the site from spam. Part 3. Repeats</a></li>
<li><a href="../301304/index.html">I2P: Accelerating Asymmetric Cryptography with Spreadsheets</a></li>
<li><a href="../301306/index.html">Google-oriented programming</a></li>
<li><a href="../301310/index.html">Do-it-yourself travel planner for a couple of hours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>