<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is worth exchange Cortex-M3?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ARM Cortex-M3 is probably the most popular 32-bit processor core for embedded systems today. Microcontrollers on its base produce dozens of manufactur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is worth exchange Cortex-M3?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/9b4/cec/de9/9b4cecde956d450a9b81dc0a0c502d61.png" align="right">  ARM Cortex-M3 is probably the most popular 32-bit processor core for embedded systems today.  Microcontrollers on its base produce dozens of manufacturers.  The reason for this is a universal, well-balanced architecture, and the result is a continuously growing base of ready-made software and hardware solutions. <br><br>  In general, there is nothing to blame the Cortex-M3, but today I propose to consider in detail the Cortex-M4F - an extended version of the well-loved processor core.  To transfer a project from a microcontroller based on a Cortex-M3 to a crystal based on a Cortex-M4F is quite simple, and for a number of tasks such a transition is worth the effort. <br><br>  Under the cat a brief overview of modern Cortex, a detailed description of the blocks and commands that distinguish the Cortex-M4F from the Cortex-M3, as well as a comparison of the processor cores on the real problem - we will measure the flicker frequency of the lamp on microcontrollers with different cores. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Part of the review </h4><hr><br>  A huge number of articles and reviews have been written about how each generation of the ARM processor cores succeeded each other.  I see no reason to paint everything that is in Wikipedia, but I recall the basic facts. <br><br>  ARM Ltd.  develops microprocessor and microcontroller cores with a RISC architecture and sells licenses for the manufacture of crystals using appropriate technology to electronic component manufacturers.  There are dozens and even hundreds of such manufacturers all over the world, there are domestic companies among them. <br>  Modern ARM cores are united by the name Cortex. <br>  <i>By the way, the word ‚Äúcortex‚Äù is translated as ‚Äúcerebral cortex‚Äù - a structure responsible for coordinated work of organs, thinking, and higher nervous activity.</i>  <i>In my opinion, a great name.</i> <br><br>  So, ARM Cortex processor cores are divided into three main groups: <br><ul><li>  Cortex-A - Application Processors - for applications requiring high performance;  most often, they run linux, android and the like. </li><li>  Cortex-R - Embedded Real-time Processors - for real-time applications </li><li>  Cortex-M - Embedded Processors - for embedded systems </li></ul><br><br>  Consider the last group, gradually approaching the Cortex-M3 / Cortex-M4F pair.  In total, at the end of 2015, six processor cores were presented: Cortex-M0, -M0 +, -M1, -M3, -M4, -M7. <br>  The Cortex-M1 often falls out of this list, this is because -M1 is designed and used exclusively in FPGA-related applications.  The remaining cores do not have such a specialized application and differ in performance - from the simplest -M0 to high-performance -M7. <br><br><img src="https://habrastorage.org/files/baa/688/121/baa68812100e44879c8537d4e06500b1.png"><br><br>  Compared to Cortex-M0, Cortex-M0 + is additionally equipped with an MPU memory protection unit, Micro Trace Buffer for debugging programs, and also has a two-stage conveyor instead of three-step and simplified access to peripheral units and I / O lines. <br><br>  Cortex-M0 and Cortex-M0 + have a single-Von-Neumann architecture, and the core Cortex-M3 is already Harvard.  Cortex-M3 is quite different from the "younger" representatives of the line and has much more opportunities. <br><br>  Cortex-M4 is built according to absolutely the same architecture and ‚Äústructurally‚Äù does not differ from the Cortex-M3.  The difference is in the supported command system, but more on that later.  Cortex-M4F differs from -M4 in the presence of the FPU floating point unit. <br><br>  The Cortex-M7 architecture is relatively new and differs from the Cortex-M3 / M4 as much as the Cortex-M3 / M4 differs from the Cortex-M0.  The 6-step superscalar pipeline, a separate cache for data and commands, a configurable TCM memory, and other distinctive features of this core are ‚Äúsharpened‚Äù for maximum performance.  Indeed, the capabilities of the Cortex-M7 based controllers are compared with the Cortex-A5 and -R5, rather than with other controllers of the Embedded Processors group.  The boundaries of technology continue to blur. <br><br>  Despite the completely different capabilities of the cores of the Cortex-M group, the instruction set of each core includes all the commands supported in the younger cores.  This ensures the possibility of developing software-compatible microcontrollers based on different cores, and this is what most manufacturers of microcontrollers are doing. <br><br><img src="https://habrastorage.org/files/851/620/089/85162008940b4d819a9a288dba29792c.png"><br><br>  The Cortex-M0 and Cortex-M0 + kernels have the same instruction set.  The Cortex-M3 instruction set includes all the Cortex-M0 commands and about a hundred additional instructions.  The Cortex-M4 and Cortex-M7 processor cores have, again, an identical instruction set ‚Äî the Cortex-M3 instruction set plus the so-called DSP instructions.  The Cortex-M4F core, in addition to the Cortex-M4 / M7 set, supports floating-point commands, and the Cortex-M7F command system includes 14 more commands for double-precision floating-point operations. <br><br><h4>  Part theoretical </h4><hr><br>  So, the closest "neighbors" of the popular Cortex-M3 processor core are Cortex-M4, supplemented by support for DSP instructions, and Cortex-M4F, additionally containing an FPU and supporting the appropriate commands.  Consider the DSP and FPU commands. <br><br><h4>  DSP instructions </h4><br>  The DSP abbreviation is often stands for Digital Signal Processor, i.e.  A separate and completely independent controller or coprocessor designed for the tasks of digital signal processing.  Do not confuse a specialized DSP chip and a set of DSP instructions.  DSP commands (decrypted by Digital Signal Process <b>ing</b> instead of Process <b>or</b> ) is a set of commands that is supported by a number of ARM processor cores and corresponds to some typical operations for digital signal processing. <br><br>  The first group of such operations is Single-cycle Multiply Accumulate or simply MAC. <br>  For the smallest ones: multiplication with accumulation is described by the formula S = S + A x B. The corresponding commands describe multiplication of two registers with summation of the result into the accumulator and related operations: multiplication with subtraction of the result from the accumulator, multiplication without using the accumulator, etc. <br><br>  Operations are provided for 16- and 32-bit variables and play an important role in many typical digital signal processing algorithms.  For example, an <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D1%2581_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B8%25D0%25BC%25D0%25BF%25D1%2583%25D0%25BB%25D1%258C%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B9">FIR filter</a> (this is a classic, almost banal ‚Äúfor example‚Äù) is a sequence of multiplication with accumulation, which means its speed directly depends on the speed of multiplication with accumulation. <br>  All MAC instructions in microcontrollers with a Cortex-M4 (F) core are executed in one machine cycle. <br><br>  The second group of DSP instructions is <b>parallel data processing</b> operations (Single Instruction Multiple Data, SIMD), which allow optimizing data processing due to parallelism of calculations.  Pairs of independent variables are placed in pairs in one register of a higher dimension, and arithmetic operations are already performed on ‚Äúlarge‚Äù registers. <br>  For example, the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0553a/CHDGJDJF.html">SADD16</a> command implies the simultaneous addition of two pairs of 16-bit signed numbers with the result <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0553a/CHDGJDJF.html">written</a> to the register storing the first operand. <br><br><pre><code class="objectivec hljs">SADD16 R1, R0</code> </pre> <br><img src="https://habrastorage.org/files/175/4b5/a27/1754b5a272474a4b9f82eb170030dcc2.png"><br><br>  Since general-purpose registers are 32 bits wide, not only two 16-bit variables (half words) can be written to each of them, but also up to four 8-bit variables (bytes).  Now it's easy to figure out why you need the SADD8 command. <br><br>  Here is a more complicated operation: multiplication of the older half words, multiplication of the lower half words, and summation of works among themselves and with 64-bit accumulation.  The SMLALD team describes all these actions and performs Cortex-M4 in one machine cycle.  SMLALD, like many other commands, combines multiplication with the accumulation and processing of data on the principle of SIMD. <br><br><pre> <code class="objectivec hljs">SMLALD R6, R8, R5, R1</code> </pre><br><img src="https://habrastorage.org/files/3c6/e60/dca/3c6e60dcae2e4cf8a553689ebf04995b.png"><br><br>  Both simple SIMD commands (signed and unsigned 8- and 16-bit addition and subtraction, etc.), and complex instructions like SMLALD are executed in one machine cycle. <br><br>  The next group of DSP instructions is the Saturating instructions.  They are also known as cut-off operations and provide protection against overflows.  When using standard commands, the register storing the result, when overflowed, ‚Äúreboots‚Äù from scratch, and commands providing saturation, when overflowing, fix the result at the maximum allowed by the digit capacity.  Thus, the programmer eliminates the need to take care of overflow flags. <br><br><img src="https://habrastorage.org/files/7d7/3d7/56f/7d73d756f06c4080988ca8dd92e6be75.png"><br><br>  Among the commands of the Cortex-M4 processor core there are both ‚Äúordinary‚Äù arithmetic operations and the same operations with saturation.  The use of the latter is especially in demand in tasks where the accuracy of calculations can be sacrificed for the sake of speed.  There are a lot of such tasks in DSP. <br><br><h4>  FPU instructions </h4><br>  Hardware support for floating-point calculations (or a dot, whichever you like) is a feature of the Cortex-M4F core and more senior Cortex-M members. <br><br>  Commands for floating-point calculations allow you to perform operations on real numbers with maximum performance.  In general, today two numbers are used to represent real numbers - fixed and floating point.  In the first case, the number of digits for recording the whole and fractional parts is fixed and the calculations are reduced to operations on integers; in the second, the number is represented as a set of a sign bit, several order bits and a mantissa: <br><br>  (-1) <sup>s</sup> * m √ó b <sup>e</sup> , <br>  where s is the sign, b-base, e is the order, and m is the mantissa <br><br>  Using floating point format is preferable when processing signals due to a much wider range of float variable values.  Using FPU operations also saves the developer from having to keep track of the bit depth.  The single-precision floating-point format is described by the IEEE 754 standard, this representation is used in microcontrollers with the Cortex-M4F core.  The range of acceptable values ‚Äã‚Äãis (10 <sup>‚Äì38</sup> ... 10 <sup>38</sup> ) with approximate conversion to decimal numbers. <br><br><img src="https://habrastorage.org/files/87e/ea7/c17/87eea7c176b742a3a887d1e198976779.png"><br><br>  By the way, for the double-precision floating-point format, which is supported in the Cortex-M7F, the same principle is used, but instead of the 32-bit representation, 64-bit is used, i.e.  the order is 11 bits, and the mantissa is 52. <br><br>  About how and why the floating-point format is used more than once is written on Habr√© (for example, an excellent article).  I, perhaps, do not write better, so go ahead. <br><br><h4>  List of assembler DSP and FPU commands </h4><br>  To get a feel for the scale ‚Äî understand how much data processing can be accelerated using Cortex-M4 ‚Äî you can study the full list of DSP and FPU instructions.  I have big doubts about the practical value of these tables, it‚Äôs interesting to see. <br>  All DSP and most FPU instructions are executed in one machine cycle. <br><br><div class="spoiler">  <b class="spoiler_title">Cortex-M4 core DSP instructions</b> <div class="spoiler_text"><table border="1"><tbody><tr><td>  <strong>Team</strong> </td><td>  <strong>Operation</strong> </td></tr><tr><td>  PKHTB, PKHBT </td><td>  rewriting the half-word from one register to another, if necessary, shifting the contents of the "receiving" register </td></tr><tr><td>  QADD </td><td>  sign addition with saturation </td></tr><tr><td>  QADD16 </td><td>  sign addition of the corresponding half-words of two operands (with saturation) </td></tr><tr><td>  QADD8 </td><td>  sign addition of the corresponding bytes of two operands (with saturation) </td></tr><tr><td>  QASX </td><td>  the sign addition of the younger half-word of the second operand and the higher half-word of the first operand, the sign subtraction of the higher half-word of the second operand from the younger half-word of the first operand (with saturation) <br></td></tr><tr><td>  QDADD </td><td>  doubling the second operand, summing the result with the first operand (signed, with saturation) </td></tr><tr><td>  QDSUB </td><td>  doubling the second operand, subtracting the result from the first operand (signed, with saturation) </td></tr><tr><td>  QSAX </td><td>  signed subtraction of the lower half-word of the second operand from the higher half-word of the first operand + sign addition of the lower half-word of the first operand and higher half-word of the second operand (with saturation) </td></tr><tr><td>  QSUB </td><td>  sign subtraction (with saturation) </td></tr><tr><td>  QSUB16 </td><td>  sign subtraction of the corresponding half words of two operands (with saturation) </td></tr><tr><td>  QSUB8 </td><td>  signed subtraction of the corresponding bytes of two operands (with saturation) </td></tr><tr><td>  SADD16 </td><td>  sign addition of the corresponding half words of two operands </td></tr><tr><td>  SADD8 </td><td>  sign addition of the corresponding bytes of two operands </td></tr><tr><td>  SASX </td><td>  the sign addition of the upper half word of the first transpend and the lower half word of the second operand with the entry in the upper half word of the result, the sign subtraction of the lower half word of the second operand from the higher half word of the first half word with a record in the younger half word of the result <br></td></tr><tr><td>  SEL </td><td>  selection of bytes from operands in accordance with GE [3: 0] bits ("flags" set when various conditions of the "greater or equal" type are met when performing arithmetic operations) </td></tr><tr><td>  SHADD16 </td><td>  sign addition of the corresponding half-words of operands, shift of two results by one bit to the right </td></tr><tr><td>  SHADD8 </td><td>  the sign addition of the corresponding byte operands, the shift of the four results by one bit to the right </td></tr><tr><td>  SHASX </td><td>  sign addition of the high half word of the first operand and the lower half word of the second operand, writing the result to the upper half word of the specified register with a right shift by one bit, sign subtraction of the high half word of the second operand from the lower half word of the first operand, writing result to the lower half word of the specified register with right shift by one bit </td></tr><tr><td>  SHSAX </td><td>  sign subtraction of the lower half word of the second operand from the high half word of the first operand, writing the result to the lower half word of the specified register with a shift to the right by one bit, sign addition of the high half word of the second operand and the lower half word of the first operand, writing the result to the senior half word of the specified register with right shift by one bit </td></tr><tr><td>  SHSUB16 </td><td>  signed subtraction of the high and low half words of the second operand from the corresponding half words of the first operand, shift the result by a bit to the right </td></tr><tr><td>  SHSUB8 </td><td>  signed subtraction of the high and low bytes of the second operand from the corresponding bytes of the first operand, shift the result by a bit to the right </td></tr><tr><td>  SMLABB, SMLABT, SMLATB, SMLATT </td><td>  multiplying the upper or lower half words of two operands with 32-bit accumulation </td></tr><tr><td>  SMLAD, SMLADX </td><td>  pairwise multiplication of the half-words of two operands, summing two products with 32-bit accumulation </td></tr><tr><td>  SMLALBB, SMLALBT, SMLALTB, SMLALTT </td><td>  multiplication of the sign half-words of two operands (major or minor) with 64-bit accumulation and 64-bit result </td></tr><tr><td>  SMLALD, SMLALDX </td><td>  pairwise multiplication of two bytes taken from the first operand by two bytes from the second operand, the summation of the two products obtained with 64-bit accumulation and 64-bit result </td></tr><tr><td>  SMLAWB, SMLAWT </td><td>  multiplying the upper or lower half-word of the first operand by the second operand with 32-bit accumulation, the first 32 bits of the 48-bit result are written into the resulting register </td></tr><tr><td>  SMLSD </td><td>  subtracting the product of the higher half words of two operands from the lower half words of two operands with 32-bit accumulation </td></tr><tr><td>  SMLSLD </td><td>  subtracting the product of the higher half words of two operands from the lower half words of two operands with 64-bit accumulation </td></tr><tr><td>  SMMLA </td><td>  multiplying two operands with 32-bit accumulation (only 32 high-order digits are taken) </td></tr><tr><td>  SMMLS, SMMLR </td><td>  multiplying two operands, subtracting the result from the specified register (only 32 senior bits of the product are taken) </td></tr><tr><td>  SMMUL, SMMULR </td><td>  multiplication of operands (the result is the highest 32-bit product) </td></tr><tr><td>  SMUAD </td><td>  multiplication of the higher half words of two operands, multiplication of the lower half words of two operands, addition of products </td></tr><tr><td>  SMULBB, SMULBT SMULTB, SMULTT </td><td>  multiplication of the upper or lower half words of two opernds </td></tr><tr><td>  SMULWB, SMULWT </td><td>  multiplying the first operand by the upper or lower half word of the second operand; the first 32 bits of the 48-bit result are written to the resulting register </td></tr><tr><td>  SMUSD, SMUSDX </td><td>  multiplication of the higher half words of two operands, multiplication of the lower half words of two operands, subtraction of the first product from the second </td></tr><tr><td>  SSAT16 </td><td>  sign saturation of half words to the specified value </td></tr><tr><td>  SSAX </td><td>  significant subtraction of the lower half-word of the second operand from the higher half-word of the first operand with the entry in the lower half-word of the result, the addition of the higher half-word of the first operand and the younger half-word of the second operand with a record in the high-half word </td></tr><tr><td>  SSUB16 </td><td>  sign subtraction of the corresponding half words of two operands </td></tr><tr><td>  SSUB8 </td><td>  signed subtraction of the corresponding bytes of the two operands </td></tr><tr><td>  SXTAB </td><td>  extracting bits [7: 0] from the register and converting them into a 32-bit word, taking into account the sign, adding the result with the word or half-word </td></tr><tr><td>  SXTAB16 </td><td>  extracting bits [7: 0] and [23:16] from the register, converting them to half-words, taking into account the sign, adding the result to a word or half-word </td></tr><tr><td>  SXTAH </td><td>  extracting bits [15: 0] from the register and converting them into a 32-bit word, taking into account the sign, adding the result with the word or half-word </td></tr><tr><td>  SXTB16 </td><td>  conversion of two bytes to two half words, taking into account the sign, the addition of the result with a word or a half-word </td></tr><tr><td>  UADD16 </td><td>  unsigned addition of the corresponding half words of two operands </td></tr><tr><td>  UADD8 </td><td>  unsigned addition of the corresponding bytes of two operands </td></tr><tr><td>  USAX </td><td>  addition of the lower half-word of the first operand and the higher half-word of the second operand with recording the result in the lower half-word of the result, unsigned subtraction of the lower half-word of the second operand from the higher half-word of the first operand with a record in the older half-word of the result </td></tr><tr><td>  UHADD16 </td><td>  unsigned addition of the corresponding half words of the two operands and shift the results by one bit to the right </td></tr><tr><td>  UHADD8 </td><td>  unsigned addition of the corresponding bytes of the two operands and shift the results by one bit to the right </td></tr><tr><td>  Uhasx </td><td>  unsigned addition of the upper half-word of the first operand and the lower half-word of the second operand with a shift of the result of addition by one bit to the right and writing to the higher half-word of the result, unsigned subtraction of the higher half-word of the second operand from the younger half-word of the first operand with shift of the result of subtraction by one bit to the right and writing to the younger half-word result </td></tr><tr><td>  UHSAX </td><td>  unsigned subtraction of the second half-word of the second operand from the upper half-word of the first operand with a shift of the subtraction result by one bit to the right and writing to the upper half-word of the result, unsigned addition of the younger half-word of the first operand and the higher half-word of the second operand with a shift of the addition result by one bit to the right and writing to the younger half-word result, </td></tr><tr><td>  UHSUB16 </td><td>  unsigned subtraction of the corresponding half words of two operands, shifting the result one bit to the right </td></tr><tr><td>  UHSUB8 </td><td>  unsigned subtraction of the corresponding bytes of the two operands, shift the result one bit to the right </td></tr><tr><td>  Umaal </td><td>  unsigned multiplication with double 32-bit accumulation and 64-bit result </td></tr><tr><td>  UQADD16 </td><td>  unsigned addition of 16-bit variables (with saturation) </td></tr><tr><td>  UQADD8 </td><td>  unsigned addition of 8-bit variables (with saturation) </td></tr><tr><td>  Uqasx </td><td>  unsigned subtraction of the lower half-word of the second operand from the higher half-word of the first operand, unsigned addition of the younger half-word of the first operand and the higher half-word of the second operand (with saturation) </td></tr><tr><td>  UQSAX </td><td>  unsigned subtraction of the lower half-word of the second operand from the higher half-word of the first operand, unsigned addition of the younger half-word of the first operand and the higher half-word of the second operand (with saturation) </td></tr><tr><td>  UQSUB16 </td><td>  unsigned subtraction of the corresponding half words of two operands (with saturation) </td></tr><tr><td>  UQSUB8 </td><td>  unsigned subtraction of the corresponding bytes of two operands (with saturation) </td></tr><tr><td>  USAD8 </td><td>  unsigned subtraction of the corresponding bytes of the two operands, the addition of absolute differences </td></tr><tr><td>  USADA8 </td><td>  unsigned subtraction of the corresponding bytes of the two operands, the addition of absolute differences, the addition of the result of the operation with the contents of the battery </td></tr><tr><td>  USAT16 </td><td>  unsigned saturation of half words to the specified value </td></tr><tr><td>  Uasx </td><td>  unsigned subtraction of the higher half-word of the second operand from the lower half-word of the first operand with the entry in the lower half-word of the result, the addition of the higher half-word of the first operand and the younger half-word of the second operand with a record of the result in the higher half-word result </td></tr><tr><td>  USUB16 </td><td>  unsigned subtraction of the corresponding half words of two operands </td></tr><tr><td>  USUB8 </td><td>  unsigned subtraction of the corresponding bytes of the two operands </td></tr><tr><td>  UXTAB </td><td>  extracting bits [7: 0] from the register and converting them into a 32-bit word without a sign, adding the result with a word or a half-word </td></tr><tr><td>  UXTAB16 </td><td>  extracting bits [7: 0] and [23:16] from the register, converting them to half-words without taking into account the sign, adding the result to a word or half-word </td></tr><tr><td>  Uxtah </td><td>  extract bits [15: 0] from the register and convert them to a 32-bit word without a sign, adding the result to a word or a half-word </td></tr><tr><td>  UXTB16 </td><td>  conversion of two bytes to two half-words without a sign, adding the result with a word or a half-word </td></tr></tbody></table><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Cortex-M4F FPU kernel instructions</b> <div class="spoiler_text"><br><br><br><table border="1"><tbody><tr><td>  <strong>Team</strong> </td><td>  <strong>Operation</strong> </td></tr><tr><td>  VABS.F32 </td><td>  obtaining the absolute value of the operand </td></tr><tr><td>  VADD.F32 </td><td>  addition of operands </td></tr><tr><td>  VCMP.F32 </td><td>  comparing two operands or operand and zero </td></tr><tr><td>  VCMPE.F32 </td><td>  comparison of two operands or operand and zero with checking for an incorrect operand (NaN) </td></tr><tr><td>  VCVT.S32.F32 </td><td>  conversion between data types (float / integer) </td></tr><tr><td>  VCVT.S16.F32 </td><td>  conversion between data types (floating point / fixed point) </td></tr><tr><td>  VCVTR.S32.F32 </td><td>  conversion between data types (float / integer) with rounding </td></tr><tr><td>  VCVT &lt;B | H&gt; .F32.F16 </td><td>  conversion between data types (floating point half-word - it's also a half-precision number / floating-point) </td></tr><tr><td>  VCVTT &lt;B | T&gt; .F32.F16 </td><td>  conversion between data types (floating point / floating point half-word) </td></tr><tr><td>  VDIV.F32 </td><td>  division of operands </td></tr><tr><td>  VFMA.F32 </td><td>  multiplication of two variables, adding the result of multiplication to the contents of the specified register </td></tr><tr><td>  VFNMA.F32 </td><td>  Invert the first sample, multiply the result by the second operand, add the product and the inverted value from the specified register </td></tr><tr><td>  VFMS.F32 </td><td>  Invert the first sample, multiply the result by the second operand, add the product and the value from the specified register </td></tr><tr><td>  VFNMS.F32 </td><td>  multiplying two operands, adding the product and the inverted value from the specified register </td></tr><tr><td>  VLDM.F &lt;32 | 64&gt; </td><td>  extracting the contents of several specified registers from program memory </td></tr><tr><td>  VLDR.F &lt;32 | 64&gt; </td><td>  extracting the contents of the specified register from the program memory </td></tr><tr><td>  VLMA.F32 </td><td>  multiplication with accumulation </td></tr><tr><td>  VLMS.F32 </td><td>  subtracting the product of two operands from the specified register </td></tr><tr><td>  VMOV </td><td>  transferring data between "standard" ARM registers and FPSCR registers (Floating-Point Status and Control Register), transferring data between registers storing floating-point format (FPU registers), writing constants to FPU registers, etc. </td></tr><tr><td>  VMOV, VMRS, VMSR </td><td>  data transfer between the ‚Äústandard‚Äù ARM registers and the FPSCR (Floating-Point Status and Control Register) registers </td></tr><tr><td>  VMUL.F32 </td><td>  multiplication of operands </td></tr><tr><td>  VNEG.F32 </td><td>  inversion </td></tr><tr><td>  VNMLA.F32 </td><td>  multiplication of two operands, result inventing, addition of the inverted product and the inverted value from the specified register </td></tr><tr><td>  VNMLS.F32 </td><td>  multiplication of two operands, product and inverted value from the specified register </td></tr><tr><td>  VNMUL </td><td>  multiplication of two operands, result inventing </td></tr><tr><td>  VPOP </td><td>  pop </td></tr><tr><td>  VPUSH </td><td>  push </td></tr><tr><td>  VSQRT.F32 </td><td>  square root </td></tr><tr><td>  VSTM </td><td>  saving the contents of several specified registers to the program memory </td></tr><tr><td>  VSTR.F &lt;32 | 64&gt; </td><td>  saving the contents of the specified register to the program memory </td></tr><tr><td>  VSUB.F &lt;32 | 64&gt; </td><td>  subtraction of operands </td></tr></tbody></table><br></div></div><br><br>  However, in practice, the kernel instructions themselves are not often used.  Usually during development it is enough to deal with the documentation for the controller and the libraries from the core and chip manufacturers.  In particular, for the Cortex cores, there is an ARM CMSIS library set, which is used for Cortex-M processors from different manufacturers.  CMSIS also includes the CMSIS-DSP library, it includes: <br><br><ul><li>  basic math functions, vector operations </li><li>  fast trigonometric and transcendental functions (sin, cos, sqrt, etc.) </li><li>  linear and bilinear interpolations </li><li>  complex arithmetic </li><li>  statistical functions </li><li>  filtering algorithms - IIR, FIR filters, minimal mean square error algorithm </li><li>  signal conversion algorithms (FFT, etc.) </li><li>  matrix arithmetic </li><li>  PID controller </li><li>  array functions </li></ul><br><br><h4>  Part practical </h4><hr><br><br>  As a rule, the comparison of the Cortex-M3 and Cortex-M4 (F) cores ends with beautiful graphs - histograms that show a significant acceleration of the operation of the Cortex-M4 based controller when performing typical DSP operations (FIR filter, FFT, matrix calculations, FID -regulator, etc.).  Without instructions of the used controllers, a technique of calculations and measurements. <br><br>  But we will not compare Tide and Regular laundry detergent; instead, we will take a real hardware and software platform. <br><br><blockquote>  At this point, it makes sense to digress and think a little about the problems for which the mathematical apparatus Cortex-M4F is relevant.  It is clear that the work with streaming data and multimedia performance of the Cortex-M4 core is not enough, we are talking more about control systems and data processing. <br>  For example, some telemetry data is being collected.                 ,       ,  ¬´¬ª   .       ‚Äî    ,           . <br>           .   -  -.           bluetooth ?  Of course not.            . <br>      .      ,    ¬´ ¬ª? !      ,               . </blockquote><br><br>            EFM32 Wonder Gecko  SiLabs.                . -. <br><br> <a href="http://www.silabs.com/products/mcu/32-bit/efm32-wonder-gecko/pages/efm32-wonder-gecko.aspx">EFM32WG</a> ‚Äî      Cortex-M4F.    EFM32,                .         Cortex-M3  Cortex-M4F. <br><br> <u> :</u> <br><br>  EFM32WG-STK3800 ‚Äî         Cortex-M4F <br>  EFM32GG-STK3700 ‚Äî         Cortex-M3 <br>       . <br><img src="https://habrastorage.org/files/71f/d92/f75/71fd92f7578a489c9f1355689e9d846c.png"><br><br> <u> </u> <br>      Simplicity Studio.  SiLabs- ,    , ,   ,     Silabs.      ‚Äî IDE,     energy profiler,         user guide   . <br><br>  <u>The essence of the experiment</u> <br>                  .  ,        ,   ,    0,5   :    512         .               ProcessFFT(). <br>     ,    .                . <br><br><img src="https://habrastorage.org/files/665/769/c20/665769c2004b44299661bb6b9bb578c5.jpg"><br><br>  Simplicity Studio,  Simplicity IDE,  . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">   ,   ‚Äî    ,    Simplicity IDE,    IAR, Keil     . <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/***************************************************************************/</span></span><span class="hljs-comment"><span class="hljs-comment">/** * @file lightsensefft.c * @brief FFT transform example * @details * Use ADC in order to capture and analyse input from the * light sensor on the STK. Runs floating point FFT algorithm from the CMSIS * DSP Library, and estimate the frequency of the most luminous light source * using sinc interpolation. The main point with this example is to show the * use of the CMSIS DSP library and the floating point capability of the CPU. * * @par Usage * Connect the light sensor output to the ADC input by shorting pins * 15 and 14 on the EXP_HEADER of the STK. * Direct various light sources to the light sensor. Expect no specific * frequency from daylight or from a flashlight. Mains powered incandescent * bulbs should give twice the mains frequency. Using another STK running the * "blink" example modified to various blink rates is an excellent signal * source. The frequency bandwidth is approximately 10-500 Hz. * The frequency shows in the 4 digit numerical display upper right on * the LCD. The LCD also displays the number of CPU cycles used to do * the FFT transform. * * @author Silicon Labs * @version 1.04 ******************************************************************************* * @section License * &lt;b&gt;(C) Copyright 2014 Silicon Labs, http://www.silabs.com&lt;/b&gt; ******************************************************************************* * * Permission is granted to anyone to use this software for any purpose, * including commercial applications, and to alter it and redistribute it * freely, subject to the following restrictions: * * 1. The origin of this software must not be misrepresented; you must not * claim that you wrote the original software. * 2. Altered source versions must be plainly marked as such, and must not be * misrepresented as being the original software. * 3. This notice may not be removed or altered from any source distribution. * * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Silicon Labs has no * obligation to support this Software. Silicon Labs is providing the * Software "AS IS", with no express or implied warranties of any kind, * including, but not limited to, any implied warranties of merchantability * or fitness for any particular purpose or warranties against infringement * of any proprietary rights of a third party. * * Silicon Labs will not be liable for any consequential, incidental, or * special damages, or any other relief, or for any claim by any third party, * arising from your use of this Software. * ******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_common.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_emu.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_cmu.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_chip.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_adc.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_gpio.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_rtc.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_acmp.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_lesense.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"segmentlcd.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arm_math.h"</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"math.h"</span></span></span><span class="hljs-meta"> /** * Number of samples processed at a time. This number has to be equal to one * of the accepted input sizes of the rfft transform of the CMSIS DSP library. * Increasing it gives better resolution in the frequency, but also a longer * sampling time. */ #define BUFFER_SAMPLES 512 /** (Approximate) sample rate used for sampling data. */ #define SAMPLE_RATE (1024) /** The GPIO pin used to power the light sensor. */ #define EXCITE_PIN gpioPortD,6 /* Default configuration for alternate excitation channel. */ #define LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF \ { \ false, /* Alternate excitation enabled.*/ \ lesenseAltExPinIdleDis, /* Alternate excitation pin is disabled in idle. */ \ false /* Excite only for corresponding channel. */ \ } /* ACMP */ #define ACMP_NEG_REF acmpChannelVDD #define ACMP_THRESHOLD 0x38 /* Reference value for the lightsensor. * Value works well in office light * conditions. Might need adjustment * for other conditions. */ /* LESENSE Pin config */ #define LIGHTSENSE_CH 6 #define LIGHTSENSE_EXCITE_PORT gpioPortD #define LIGHTSENSE_EXCITE_PIN 6 #define LIGHTSENSE_SENSOR_PORT gpioPortC #define LIGHTSENSE_SENSOR_PIN 6 #define LCSENSE_SCAN_FREQ 5 #define LIGHTSENSE_INTERRUPT LESENSE_IF_CH6 /** Buffer of uint16_t sample values ready to be FFT-ed. */ static uint16_t lightToFFTBuffer[BUFFER_SAMPLES]; /** Buffer of float samples ready for FFT. */ static float32_t floatBuf[BUFFER_SAMPLES]; /** Complex (interleaved) output from FFT. */ static float32_t fftOutputComplex[BUFFER_SAMPLES * 2]; /** Magnitude of complex numbers in FFT output. */ static float32_t fftOutputMag[BUFFER_SAMPLES]; /** Flag used to indicate whether data is ready for processing */ static volatile bool dataReadyForFFT; /** Indicate whether we are currently processing data through FFT */ static volatile bool processingFFT; /** Instance structures for float32_t RFFT */ static arm_rfft_instance_f32 rfft_instance; /** Instance structure for float32_t CFFT used by the RFFT */ static arm_cfft_radix4_instance_f32 cfft_instance; /**************************************************************************//** * Interrupt handlers prototypes *****************************************************************************/ void LESENSE_IRQHandler(void); /**************************************************************************//** * Functions prototypes *****************************************************************************/ void setupCMU(void); void setupACMP(void); void setupLESENSE(void); /**************************************************************************//** * @brief LESENSE_IRQHandler * Interrupt Service Routine for LESENSE Interrupt Line *****************************************************************************/ void LESENSE_IRQHandler(void) { /* Clear interrupt flag */ LESENSE_IntClear(LIGHTSENSE_INTERRUPT); } /***************************************************************************//** * @brief Enables LFACLK and selects osc as clock source for RTC ******************************************************************************/ void RTC_Setup(CMU_Select_TypeDef osc) { RTC_Init_TypeDef init; /* Ensure LE modules are accessible */ CMU_ClockEnable(cmuClock_CORELE, true); /* Enable osc as LFACLK in CMU (will also enable oscillator if not enabled) */ CMU_ClockSelectSet(cmuClock_LFA, osc); /* Division prescaler to decrease consumption. */ CMU_ClockDivSet(cmuClock_RTC, cmuClkDiv_32); /* Enable clock to RTC module */ CMU_ClockEnable(cmuClock_RTC, true); init.enable = false; init.debugRun = false; init.comp0Top = true; /* Count only to top before wrapping */ RTC_Init(&amp;init); /* RTC clock divider is 32 which gives 1024 ticks per second. */ RTC_CompareSet(0, ((1024 * SAMPLE_RATE) / 1000000)-1); /* Enable interrupt generation from RTC0, needed for WFE (wait for event). */ /* Notice that enabling the interrupt in the NVIC is not needed. */ RTC_IntEnable(RTC_IF_COMP0); } /**************************************************************************//** * @brief Enable clocks for all the peripherals to be used *****************************************************************************/ void setupCMU(void) { /* Ensure core frequency has been updated */ SystemCoreClockUpdate(); /* Set the clock frequency to 11MHz so the ADC can run on the undivided HFCLK */ CMU_HFRCOBandSet(cmuHFRCOBand_11MHz); /* ACMP */ CMU_ClockEnable(cmuClock_ACMP0, true); /* GPIO */ CMU_ClockEnable(cmuClock_GPIO, true); /* ADC */ CMU_ClockEnable(cmuClock_ADC0, true); /* Low energy peripherals * LESENSE * LFRCO clock must be enables prior to enabling * clock for the low energy peripherals */ CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFRCO); CMU_ClockEnable(cmuClock_CORELE, true); CMU_ClockEnable(cmuClock_LESENSE, true); /* RTC */ CMU_ClockEnable(cmuClock_RTC, true); /* Disable clock source for LFB clock. */ CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_Disabled); } /**************************************************************************//** * @brief Sets up the ACMP *****************************************************************************/ void setupACMP(void) { /* Configuration structure for ACMP */ static const ACMP_Init_TypeDef acmpInit = { .fullBias = false, /* The lightsensor is slow acting, */ .halfBias = true, /* comparator bias current can be set to lowest setting.*/ .biasProg = 0x0, /* Analog comparator will still be fast enough */ .interruptOnFallingEdge = false, /* No comparator interrupt, lesense will issue interrupts. */ .interruptOnRisingEdge = false, .warmTime = acmpWarmTime512, /* Not applicable, lesense controls this. */ .hysteresisLevel = acmpHysteresisLevel5, /* Some hysteresis will prevent excessive toggling. */ .inactiveValue = false, /* Not applicable, lesense controls this. */ .lowPowerReferenceEnabled = false, /* Can be enabled for even lower power. */ .vddLevel = 0x00, /* Not applicable, lesense controls this through .acmpThres value. */ .enable = false /* Not applicable, lesense controls this. */ }; /* Initialize ACMP */ ACMP_Init(ACMP0, &amp;acmpInit); /* Disable ACMP0 out to a pin. */ ACMP_GPIOSetup(ACMP0, 0, false, false); /* Set up ACMP negSel to VDD, posSel is controlled by LESENSE. */ ACMP_ChannelSet(ACMP0, acmpChannelVDD, acmpChannel0); /* LESENSE controls ACMP thus ACMP_Enable(ACMP0) should NOT be called in order * to ensure lower current consumption. */ } /**************************************************************************//** * @brief Sets up the LESENSE *****************************************************************************/ void setupLESENSE(void) { /* LESENSE configuration structure */ static const LESENSE_Init_TypeDef initLesense = { .coreCtrl = { /* LESENSE configured for periodic scan. */ .scanStart = lesenseScanStartPeriodic, .prsSel = lesensePRSCh0, .scanConfSel = lesenseScanConfDirMap, .invACMP0 = false, .invACMP1 = false, .dualSample = false, .storeScanRes = false, .bufOverWr = true, .bufTrigLevel = lesenseBufTrigHalf, .wakeupOnDMA = lesenseDMAWakeUpDisable, .biasMode = lesenseBiasModeDutyCycle, /* Lesense should duty cycle comparator and related references etc. */ .debugRun = false }, .timeCtrl = { .startDelay = 0 /* No start delay needed for this application. */ }, .perCtrl = { /* DAC is not needed for this application. */ .dacCh0Data = lesenseDACIfData, .dacCh0ConvMode = lesenseDACConvModeDisable, .dacCh0OutMode = lesenseDACOutModeDisable, .dacCh1Data = lesenseDACIfData, .dacCh1ConvMode = lesenseDACConvModeDisable, .dacCh1OutMode = lesenseDACOutModeDisable, .dacPresc = 0, .dacRef = lesenseDACRefBandGap, .acmp0Mode = lesenseACMPModeMuxThres, /* Allow LESENSE to control ACMP mux and reference threshold. */ .acmp1Mode = lesenseACMPModeMuxThres, .warmupMode = lesenseWarmupModeNormal /* Normal mode means LESENSE is allowed to dutycycle comparator and reference. */ }, .decCtrl = { /* Decoder or statemachine not used in this code example. */ .decInput = lesenseDecInputSensorSt, .initState = 0, .chkState = false, .intMap = true, .hystPRS0 = false, .hystPRS1 = false, .hystPRS2 = false, .hystIRQ = false, .prsCount = true, .prsChSel0 = lesensePRSCh0, .prsChSel1 = lesensePRSCh1, .prsChSel2 = lesensePRSCh2, .prsChSel3 = lesensePRSCh3 } }; /* Channel configuration */ /* Only one channel is configured for the lightsense application. */ static const LESENSE_ChDesc_TypeDef initLesenseCh = { .enaScanCh = true, .enaPin = false, /* Pin is input, no enabling needed. Separate pin is exciting the sensor. */ .enaInt = true, /* Enable interrupt for this channel. */ .chPinExMode = lesenseChPinExHigh, /* Excite by pullin pin high. */ .chPinIdleMode = lesenseChPinIdleDis, /* During Idle, excite pin should be disabled (tri-stated). */ .useAltEx = true, /* Use alternate excite pin. */ .shiftRes = false, /* Not applicable, only for decoder operation. */ .invRes = false, /* No need to invert result. */ .storeCntRes = true, /* Not applicable, don't care really. */ .exClk = lesenseClkLF, /* Using low frequency clock for timing the excitation. */ .sampleClk = lesenseClkLF, /* Using low frequency clock for timing the sample instant. */ .exTime = 0x01, /* 1 LFclk cycle is enough excitation time, this depends on response time of light sensor. */ .sampleDelay = 0x01, /* Sampling should happen when excitation ends, it it happens earlier, excitation time might as well be reduced. */ .measDelay = 0x00, /* Not used here, basically only used for applications which uses the counting feature. */ .acmpThres = ACMP_THRESHOLD, /* This is the analog comparator threshold setting, determines when the acmp triggers. */ .sampleMode = lesenseSampleModeACMP, /* Sampling acmp, not counting. */ .intMode = lesenseSetIntLevel, /* Interrupt when voltage goes above threshold. */ .cntThres = 0x0000, /* Not applicable. */ .compMode = lesenseCompModeLess /* Not applicable. */ }; /* Alternate excitation channels configuration. */ /* The lightsensor is excited by alternate excite channel 0. */ static const LESENSE_ConfAltEx_TypeDef initAltEx = { .altExMap = lesenseAltExMapALTEX, .AltEx[0] = { .enablePin = true, .idleConf = lesenseAltExPinIdleDis, .alwaysEx = true }, .AltEx[1] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[2] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[3] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[4] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[5] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[6] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF, .AltEx[7] = LESENSE_LIGHTSENSE_ALTEX_DIS_CH_CONF }; /* Initialize LESENSE interface _with_ RESET. */ LESENSE_Init(&amp;initLesense, true); /* Configure LESENSE channel */ LESENSE_ChannelConfig(&amp;initLesenseCh, LIGHTSENSE_CH); /* Configure alternate excitation channels */ LESENSE_AltExConfig(&amp;initAltEx); /* Set scan frequency */ LESENSE_ScanFreqSet(0, LCSENSE_SCAN_FREQ); /* Set clock divisor for LF clock. */ LESENSE_ClkDivSet(lesenseClkLF, lesenseClkDiv_2); } /**************************************************************************//** * @brief Sets up the GPIO *****************************************************************************/ void setupGPIO(void) { /* Configure the drive strength of the ports for the light sensor. */ GPIO_DriveModeSet(LIGHTSENSE_EXCITE_PORT, gpioDriveModeStandard); GPIO_DriveModeSet(LIGHTSENSE_SENSOR_PORT, gpioDriveModeStandard); /* Initialize the 2 GPIO pins of the light sensor setup. */ GPIO_PinModeSet(LIGHTSENSE_EXCITE_PORT, LIGHTSENSE_EXCITE_PIN, gpioModePushPull, 0); GPIO_PinModeSet(LIGHTSENSE_SENSOR_PORT, LIGHTSENSE_SENSOR_PIN, gpioModeDisabled, 0); } /**************************************************************************//** * @brief Configure ADC for 12 bit mode, sample channel 0 with Vdd as reference * and use shortest acquisition time. *****************************************************************************/ static void ADC_Config(void) { CMU_ClockEnable(cmuClock_ADC0, true); ADC_Init_TypeDef init = ADC_INIT_DEFAULT; ADC_InitSingle_TypeDef singleInit = ADC_INITSINGLE_DEFAULT; /* Init common settings for both single conversion and scan mode- */ /* Set timebase to 10, this gives 11 cycles which equals 1us at 11 MHz. */ init.timebase = 10; /* Set ADC clock prescaler to 0, we are using 11MHz HFRCO, which results in HFPERCLK </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 13MHz- */ init.prescale = 0; ADC_Init(ADC0, &amp;init); /* Init for single conversion use, measure channel 0 with Vdd as reference. */ /* Using Vdd as reference removes the 5us warmup time for the bandgap reference. */ singleInit.reference = adcRefVDD; singleInit.input = adcSingleInpCh5; /* Resolution can be set lower for even more energy efficient operation. */ singleInit.resolution = adcRes8Bit; /* Assuming we are mesuring a low impedance source we can safely use the shortest */ /* acquisition time. */ singleInit.acqTime = adcAcqTime1; ADC_InitSingle(ADC0, &amp;singleInit); /* Enable ADC Interrupt when Single Conversion Complete. */ /* This is necessary for WFE (wait for event) to work. */ /* Notice that enabling the interrupt in the NVIC is not needed. */ ADC0-&gt;</span></span></span><span class="hljs-meta">IEN = ADC_IEN_SINGLE; } /**************************************************************************//** * @brief A separate function for taking all the samples is preferred since * the whole idea is to stay in EM2 between samples. If other code is added, * it might be more energy efficient to configure the ADC to use DMA while * the cpu can do other work. *****************************************************************************/ void doAdcSampling(uint16_t* buffer) { uint16_t sample_count = 0; /* Enable RTC, this can be enabled all the time as well if needed. */ RTC_Enable(true); while(sample_count </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; BUFFER_SAMPLES) { /* Enable deep sleep to enter EM2 between samples. */ SCB-&gt;</span></span></span><span class="hljs-meta">SCR = SCB_SCR_SEVONPEND_Msk | SCB_SCR_SLEEPDEEP_Msk; /* Go to sleep while waiting for RTC event (set by RTC_IRQ pending bit) */ /* Since IRQ is not enabled in the NVIC, no ISR will be entered */ __WFE(); /* Start ADC conversion as soon as we wake up. */ ADC_Start(ADC0, adcStartSingle); /* Clear the interrupt flag */ RTC_IntClear(RTC_IF_COMP0); /* Clear pending RTC IRQ */ NVIC_ClearPendingIRQ(RTC_IRQn); /* Wait while conversion is active in EM1, should be almost finished since it */ /* takes 13 cycles + warmup (1us), and it was started a while ago. */ /* Disable deep sleep so we wait in EM1 for conversion to finish. */ SCB-&gt;SCR = SCB_SCR_SEVONPEND_Msk; __WFE(); /* Clear the interrupt flag */ ADC_IntClear(ADC0, ADC_IF_SINGLE); /* Clear pending IRQ */ NVIC_ClearPendingIRQ(ADC0_IRQn); /* Get ADC result */ buffer[sample_count++] = ADC_DataSingleGet(ADC0); } RTC_Enable(false); } /***************************************************************************//** * @brief * Process the sampled data through FFT. *******************************************************************************/ void ProcessFFT(void) { uint16_t *inBuf; int32_t value; int i; inBuf = lightToFFTBuffer; /* * Convert to float values. */ for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; BUFFER_SAMPLES; ++i) { value = (int32_t)*inBuf++; floatBuf[i] = (float32_t)value; } /* Process the data through the RFFT module, resulting complex output is * stored in fftOutputComplex */ arm_rfft_f32(&amp;rfft_instance, floatBuf, fftOutputComplex); /* Compute the magnitude of all the resulting complex numbers */ arm_cmplx_mag_f32(fftOutputComplex, fftOutputMag, BUFFER_SAMPLES); } /***************************************************************************//** * @brief * Find the maximal bin and estimate the frequency using sinc interpolation. * @return * Frequency of maximal peak *******************************************************************************/ float32_t GetFreq(void) { float32_t maxVal; uint32_t maxIndex; /* Real and imag components of maximal bin and bins on each side */ float32_t rz_p, iz_p, rz_n, iz_n, rz_0, iz_0; /* Small correction to the "index" of the maximal bin */ float32_t deltaIndex; /* Real and imag components of the intermediate result */ float32_t a, b, c, d; #define START_INDEX 4 /* Find the biggest bin, disregarding the first bins because of DC offset and * low frequency noise. */ arm_max_f32(&amp;fftOutputMag[START_INDEX], BUFFER_SAMPLES / 2 - START_INDEX, &amp;maxVal, &amp;maxIndex); maxIndex += START_INDEX; /* Perform sinc() interpolation using the two bins on each side of the * maximal bin. For more information see page 113 of * http://tmo.jpl.nasa.gov/progress_report/42-118/118I.pdf */ /* z_{peak} */ rz_0 = fftOutputComplex[maxIndex * 2]; iz_0 = fftOutputComplex[maxIndex * 2 + 1]; /* z_{peak+1} */ rz_p = fftOutputComplex[maxIndex * 2 + 2]; iz_p = fftOutputComplex[maxIndex * 2 + 2 + 1]; /* z_{peak-1} */ rz_n = fftOutputComplex[maxIndex * 2 - 2]; iz_n = fftOutputComplex[maxIndex * 2 - 2 + 1]; /* z_{peak+1} - z_{peak-1} */ a = rz_p - rz_n; b = iz_p - iz_n; /* z_{peak+1} + z_{peak-1} - 2*z_{peak} */ c = rz_p + rz_n - (float32_t)2.0 * rz_0; d = iz_p + iz_n - (float32_t)2.0 * iz_0; /* Re (z_{peak+1} - z_{peak-1}) / (z_{peak+1} + z_{peak-1} - 2*z_{peak}) */ deltaIndex = (a*c + b*d) / (c*c + d*d); return ((float32_t)maxIndex + deltaIndex) * (float32_t)SAMPLE_RATE / (float32_t)BUFFER_SAMPLES; } /***************************************************************************//** * @brief * Main function. Setup ADC, FFT, clocks, PRS, DMA, Timer, * and process FFT forever. *******************************************************************************/ int main(void) { uint32_t time; arm_status status; /* Chip errata */ CHIP_Init(); /* Enable clocks for used peripherals */ setupCMU(); /* Setup the ACMP */ setupACMP(); /* Setup the GPIO */ setupGPIO(); /* setup lesense */ setupLESENSE(); /* Enable LCD without voltage boost */ SegmentLCD_Init(false); SegmentLCD_Symbol(LCD_SYMBOL_GECKO, 1); SegmentLCD_Symbol(LCD_SYMBOL_EFM32, 1); /* Initialize the CFFT/CIFFT module */ status = arm_rfft_init_f32(&amp;rfft_instance, &amp;cfft_instance, BUFFER_SAMPLES, 0, /* forward transform */ 1); /* normal, not bitreversed, order */ if (status != ARM_MATH_SUCCESS) { /* Error initializing RFFT module. */ SegmentLCD_Write(" Error "); while (1) ; } /* Configure RTC to use LFXO as clock source */ RTC_Setup(cmuSelect_LFXO); /* Configure ADC */ ADC_Config(); /* Enable DWT */ CoreDebug-&gt;</span></span></span><span class="hljs-meta">DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; /* Make sure CYCCNT is running */ DWT-&gt;CTRL |= 1; while (1) { /* Power the light sensor with GPIO. */ GPIO_PinModeSet( EXCITE_PIN, gpioModePushPull, 1); /* Do sampling. */ doAdcSampling(lightToFFTBuffer); /* Power off the light sensor. */ GPIO_PinModeSet( EXCITE_PIN, gpioModeDisabled, 0); /* Do FFT, measure number of cpu cycles used. */ time = DWT-&gt;CYCCNT; ProcessFFT(); time = DWT-&gt;CYCCNT - time; /* Display dominant frequency. */ SegmentLCD_Number( (int)GetFreq() ); /* Display cpu cycle count used to do FFT. */ SegmentLCD_LowerNumber( (int)time ); /* Check last ADC value to determine if lightlevel is too low. */ /* Go to sleep with lesense enabled if ADC reading is below 10. */ if(lightToFFTBuffer[BUFFER_SAMPLES-1] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 10) { /* Write to LCD that lightlevel is too low. */ SegmentLCD_NumberOff(); SegmentLCD_Write("DARK"); /* Set gpio in pushpull for lesense operation. */ GPIO_PinModeSet(LIGHTSENSE_EXCITE_PORT, LIGHTSENSE_EXCITE_PIN, gpioModePushPull, 0); LESENSE-&gt;</span></span></span><span class="hljs-meta">ROUTE = LESENSE_ROUTE_ALTEX0PEN; /* Start scan. */ LESENSE_ScanStart(); /* Enable deep sleep to enter EM2. */ SCB-&gt;SCR = SCB_SCR_SEVONPEND_Msk | SCB_SCR_SLEEPDEEP_Msk; /* Go to sleep while waiting for LESENSE event */ /* Since IRQ is not enabled in the NVIC, no ISR will be entered */ __WFE(); /* Clear interrupt flag */ LESENSE_IntClear(LIGHTSENSE_INTERRUPT); /* Clear pending RTC IRQ */ NVIC_ClearPendingIRQ(LESENSE_IRQn); LESENSE_ScanStop(); LESENSE-&gt;ROUTE &amp;= ~LESENSE_ROUTE_ALTEX0PEN; } } }</span></span></code> </pre><br></div></div><br>  <u>Go</u> <br>     DBG,  ,        (   light sensor), . <br>  :   .     ,    ‚Äî 100  (     50 ,  ¬´ ¬ª         ,    , ..   ).        ¬´DARK¬ª,     ‚Äî ¬´¬ª . <br><br><img src="https://habrastorage.org/files/9ed/877/e30/9ed877e30c2c4a858fc098100b441074.png"><br><br>    <a href="http://geektimes.ru/post/254812/">energy profiler</a> ,      ,     . <br>     EFM32WG-STK3800. <br><br><img src="https://habrastorage.org/files/6f7/416/34d/6f741634dbfc4f73b0d4d6040e50d97c.png"><br><br>     EFM32WG990F256   49 ,   ‚Äî 411 .                 Cortex-M3,     DSP-  FPU- . <br><br>       <br><div class="spoiler"> <b class="spoiler_title">    EFM32WG990F256  EFM32GG990F1024,</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/2df/db1/690/2dfdb1690abc43269318239dc7f118e3.png"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> ,            cortex-m3  cortex-m4,</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f29/728/96f/f2972896f9754ac2a6696f959b4cc901.png"><br><img src="https://habrastorage.org/files/2df/db1/690/2dfdb1690abc43269318239dc7f118e3.png"><br></div></div><br><div class="spoiler"> <b class="spoiler_title">    fpu.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/064/fa6/a3f/064fa6a3f0794cf4a9f10f4245de3cc6.png"><br><img src="https://habrastorage.org/files/752/f02/52a/752f0252a32b42d38b5b64b9c651b563.png"><br></div></div><br> ,   IDE     ,        ,         . <br><br> ,           . <br><br><img src="https://habrastorage.org/files/fb8/645/802/fb86458022bd440fa77d22776b682471.png"><br><br>      :       48 ,         ,           . <br><br>   ,                .      ¬´¬ª       .    Cortex-M3   2.2  ,         . <br><br>   ,  ,            Cortex-M3,           ,      . <br><br> <i>         ,     .   </i> </div><p>Source: <a href="https://habr.com/ru/post/277491/">https://habr.com/ru/post/277491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277479/index.html">A bit about Kotlin</a></li>
<li><a href="../277481/index.html">Android meeting dedicated to the Kotlin language</a></li>
<li><a href="../277485/index.html">6 impressive web technologies of 2015</a></li>
<li><a href="../277487/index.html">Murat Urtembaev - the first Soviet hacker</a></li>
<li><a href="../277489/index.html">Javascript Property Enhancement</a></li>
<li><a href="../277495/index.html">How to turn from a server-side programmer into a client-side in 7 days</a></li>
<li><a href="../277497/index.html">GitHub has added template support for Issue and pull requests.</a></li>
<li><a href="../277499/index.html">API for working with services: Basic moments</a></li>
<li><a href="../277501/index.html">Audio advertising: asked - we answer</a></li>
<li><a href="../277505/index.html">9 secrets of online payments. Part 2: regular payments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>