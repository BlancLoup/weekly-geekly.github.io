<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ThreeFlow branch strategy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Of all my conversations with colleagues about different aspects of software development, one topic emerges more often than others. Why are there ‚Äúmore...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ThreeFlow branch strategy</h1><div class="post__text post__text-html js-mediator-article">  Of all my conversations with colleagues about different aspects of software development, one topic emerges more often than others.  Why are there ‚Äúmore often‚Äù - it repeats over and over again, like a broken record - these are conversations on the topic of what GitFlow is bad for and why it should be avoided. <br><br>  The article "A <a href="https://habrahabr.ru/post/106912/">successful branching model for Git</a> " describes a method that later received the name "GitFlow" became the de facto standard of how to start using Git in your project.  If you search Google for something like " <a href="https://encrypted.google.com/search%3Fq%3Dgit%2Bbranching%2Bstrategy">git branching strategy,</a> " then this method will be described by the first link (and most likely by several of the following). <br><br>  Personally, I hate GitFlow and in recent years convinced many development teams to stop using it, which, I think, saved them a lot of time and nerves.  GitFlow makes teams organize code change management worse than it can be.  But since this is such a popular method (at least in the search engine results), teams without sufficient experience who are looking for ‚Äúsomething that works at least somehow‚Äù find it when searching quickly, and also see the word ‚Äúsuccessful‚Äù right in the title of the article with its description - well, they start to use it thoughtlessly.  I want to at least slightly change this pattern of behavior, having described in this article a simpler and no less successful strategy for using Git branches, which I implemented in many teams.  Often these teams tried to use GitFlow, but experienced problems that disappeared with the transition to ThreeFlow. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I call this strategy ThreeFlow because it has exactly three branches.  Not four.  Not two.  Three. <br><a name="habracut"></a><br>  Well, immediately a warning: there is no silver bullet, and ThreeFlow is not a panacea either.  It does not always fit.  I think it will work badly for embedded-development and for open-source projects.  But she is very successful for situations where the entire project team works in the same company and there are no pull requests from external developers.  Those.  everyone in the team has full access to the code and all the necessary rights to write to the repository. <br><br><h2>  So what is wrong with GitFlow? </h2><br>  In short, ‚Äúnot so‚Äù with GitFlow is his idea of ‚Äã‚Äãcreating a branch for each developed feature.  Branches for features - the root of evil.  All that these branches give are problems, problems and problems again.  If you don‚Äôt take anything out of this article anymore, or stop reading it right here - just remember the thought that branching for features is terrible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a7/7f5/e8e/6a77f5e8e841594f67823ee9eebc8496.png" alt="image"><br><br>  In fairness it should be noted that the original article speaks of branches for features, that they "usually exist only on the machines of individual developers, but not in the main repository (origin)."  But in the same article illustrating GitFlow drawings show it differently.  We see "origin" with branches of features.  Moreover, I have seen a lot of development teams using GitFlow and none of them paid attention to the author's recommendation to use branches only on individual developers' machines.  Everyone I saw used feature branches as a long-term tool that exists in ‚Äúorigin‚Äù. <br><br>  There is nothing wrong with doing branches for features in your car.  This is a good way to switch between tasks if the needs of your project require working on several of them at the same time.  This is a good way to keep the master branch clean, in case you need to make a small fix without having to synchronize all your work with a remote repository.  But I would go further than the recommendations of the original GitFlow and would strictly forbid the creation of feature branches to origin. <br><br>  If you use long-existing branches for individual features, then the <a href="http://c2.com/xp/IntegrationHell.html">hell of their integration will be your permanent reality</a> .  Two engineers successfully work each on their own features, each in their own branch, nothing seems to foretell trouble.  But none of them sees the work of the other.  Even if they regularly synchronize their branches with the main branch of the development, they see only the commits of completed and completed features, but not the current work of each other.  And then developer A infuses completing the development of his feature and pouring code into the main branch.  Developer B takes away these changes and gets the classic problem ‚Äúwho is the last, he also rakes up conflicts‚Äù.  He may have been late just a minute, but now he will spend hours trying to understand what Developer A has written here and how it all should be done.  And the longer this ‚Äúisolated‚Äù development was carried out in separate branches of features - the more pain and suffering there would be with merge. <br><br>  Long existing branches for features is not a simplification of work at all.  It‚Äôs just postponing problems for later.  The main form of communication between developers is the source code.  You can console yourself with the fact that you have regular stand-ups, planning meetings and retrospectives, but all this is not important.  Imagine a rehearsal of the orchestra, where the musicians have been discussing for a long time how they will play some kind of piece, but then the conductor asks them to disperse and rehearse their parts separately.  Will such rehearsals make sense?  So with software development - work in feature branches is essentially an analogue of deathly silence in communications between developers.  Branches for features <a href="https://blog.newrelic.com/2012/11/14/long-running-branches-considered-harmful/">are awful</a> . <br><br>  In addition, the branches for the features are scaled horribly.  One developer who creates himself a branch for a feature for his own comfort is not a problem.  But your team is growing, and each developer has a branch for each actively developed feature.  Congratulations, you now have a problem for each pair of branches.  Let you have only 8 programmers and each of them works on just one feature in its branch.  And here you already have 28 (number of pairs) dangling communication lines.  We add another developer with another branch - and now you have 36 "cliffs". <br><br><h2>  Using flags to enable features </h2><br>  Instead of using branches to design features, try <a href="https://www.martinfowler.com/articles/feature-toggles.html">using flags</a> to turn them on and off.  It's simple.  Start the development of a new feature with the announcement of the boolean flag, according to which it will be included.  Set it to false by default - and in this case call the old code, without the code for the new feature: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(newCodeEnabled) { <span class="hljs-comment"><span class="hljs-comment">//   } else { //   }</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/a9c/5d9/45d/a9c5d945d7818a14dae63ea1ade29786.jpg" alt="image" align="right">  The flag itself can be either hard-wired in the code, or put into an external config (possibly using something like <a href="https://www.consul.io/docs/agent/options.html">Consul</a> or <a href="https://zookeeper.apache.org/">Zookeeper</a> ), which will give the opportunity to turn on and off the new functionality for testing or even in production.  Project managers and customers love to see in front of them a product control panel with a list of features that they can turn on or off themselves, without the need to involve developers and rebuild the project. <br><br>  When two developers work in the same (main) branch on different features, they create a flag for each of them.  And they just commit the code regularly.  The chances of a conflict in this case are minimal.  Everyone can commit code when they see fit.  Anyone can synchronize their local repository with the main one - and the out-of-sync will be minimal (certainly not more than one working day).  Either there will be no conflict at all, or they will be minimal.  It‚Äôs much easier to understand what your colleague has changed in this ten lines in the last hour than to rake out global changes in days or weeks, as GitFlow suggests. <br><br>  And yes, if you write tests for your code (and you write them, right?), Then you need to test the code branch with the flag disabled, and the one where the flag is turned on.  If you are developing two interdependent features - at the time of development you will need 4 tests for all their combinations.  This sounds like a threat of complicating and slowing down development, but do not forget that after the development of new features, the ‚Äúold‚Äù code blocks (and tests for them) will be deleted, so you will not get a geometric increase in complexity. <br><br>  Flags for new features can be used more dynamically.  You can link them to specific groups of users for beta testing or A / B tests. <br><br>  When the development of the feature is completed and it is enabled by default in production, you can schedule a small, low-priority task to remove the old code and the flag itself.  Or, if for some reason you want to retain the possibility of disabling features (problems with the stability of the new code, load control on the backend), you can not do that.  In any case, it is important to consciously make a decision to remove or leave the flag and the old code - if you forget about it, then over time your code will acquire the moss of the old unused functionality, which will only distract developers and not bring any real benefit. <br><br>  The value of the approach with flags for the inclusion of new features is simply impossible to overestimate.  I guarantee that as soon as you start using flags for features instead of branches for them, you will never want to go back.  In my memory, almost always the development of a large new feature in a separate long-lived branch sooner or later led to problems requiring the attention of several programmers at once and deep knowledge of Git.  At the same time, the approach with work in one branch and flags for new features never led to any conflicts that could not be solved in a couple of minutes by one person. <br><br><h2>  So ThreeFlow </h2><br>  So, we figured out why branches for features is bad and what can we replace them with.  Now we can talk about the ThreeFlow branching model itself, which follows from this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d0/da0/52f/6d0da052ff8011f97945bf4081ab26e6.png" alt="image"><br><br>  In this approach, all developers work in the same master branch.  If the feature is trivial, it is simply implemented and added by one commit.  If the development of the feature takes some time, then the flag is added first (disabled by default) to activate it.  The developer includes this flag locally to develop and test a new feature, but the code in the main repository still uses the ‚Äúold‚Äù code branches.  To add commits to master, use rebase.  If you used a local branch to work on features, it should be moved to master, so we will not have any traces of this branch to origin. <br><br>  That's all.  This is how the whole development process happens.  One branch, master.  All code in it.  Everything you need is turned on or off with flags.  All developers have the same code, often synchronized with each other.  Everything else in ThreeFlow concerns only the release strategy, not the development. <br><br><h2>  Releases </h2><br>  When the time comes for release (on schedule or when management says), a ‚Äúcut‚Äù of the master branch into the release candidate branch is done.  The same thread is used for all release candidates. <br><br>  The purpose of this branch is to give the build that the QA team will receive to perform regression (and other) tests.  Theoretically, the new features of this release candidate have already been checked by QA in the course of their development and inclusion, but perhaps the QA will want to double-check them in the release candidate. <br><br>  To create a release candidate, you do something like this: <br><br><pre> <code class="bash hljs">$ git checkout candidate <span class="hljs-comment"><span class="hljs-comment"># ,  candidate   origin/candidate $ git pull # ,       $ git merge --no-ff origin/master $ git tag candidate-3.2.645 $ git push --follow-tags</span></span></code> </pre> <br>  The reason for using the "--no-ff" flag here is because we want to create a merge commit (a new commit with two parents).  One of his parents will be the previous HEAD of the release candidate branch, and the second will be the HEAD of the master branch.  This will allow you to easily track in the history of who created the release candidate, and also what exactly was included in it (which commits of the master branch). <br><br>  You may also have noticed that we have created a tag for the release candidate.  A little more detail about this. <br><br>  If bugs are detected when testing a release candidate, they will be corrected right in the release candidate's branch, the new release candidate will be marked there, and the changes with corrections will be sent back to master.  These changes should also be applied with the "--no-ff" parameter, because we want to accurately show which code was moved between branches. <br><br>  When a release candidate is tested and approved, we update the release branch so that its HEAD points to the HEAD release candidate branch.  Since we have a tag for each release candidate, we can launch it into the release branch: <br><br><pre> <code class="bash hljs">$ git push --force origin candidate-3.2.647:release</code> </pre> <br>  The "--force" parameter here means that we ignore all changes in the release branch and simply forcibly set its HEAD to the same commit that designates the last release candidate tag (candidate-3.2.647 in the example above).  Notice that this is not a merge at all, but this is because we don‚Äôt need it here.  We don‚Äôt want to complicate the story in Git, and indeed the only reason for creating a release branch is the theoretical need for an emergency fix found on a production critical issue.  Yes, this "--force" will grind all the hotfixes in the release branch.  But you know, if you release the next version of the product with new features at the same time, while another member of your team fixes production bugs - you have serious problems with project management and communications.  They should be solved even before the start of all these dances around the branches and releases.  Fixes in the release branch should be very rare and, of course, should be later in the release candidate and master branches. <br><br>  The reason why we use "--force" rather than merge is that when merge is committed to HEAD, the release candidate branches and the commit to HEAD release branches may have different sha-1, which is not what we need.  We do not want to create a new commit with the release, we want to call the release exactly the commit that was chosen as a release candidate, which was tested by the QA team and approved for release by those responsible for it.  This is what "--force" does. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6ee/367/4ed6ee3670cb7cfc1449534430a2d194.png" alt="image"><br><br>  If you follow these recommendations, the story in your git repository will look very similar to the picture above, showing exactly what commits moved between branches. <br><br><h2>  Release notes </h2><br>  You can easily generate ‚Äúrelease notes‚Äù for new releases.  You just need to get the difference between the last release tag and the current release candidate tag.  Since in the release branch we have something that once was definitely a release candidate, we can find out exactly how: <br><br><pre> <code class="bash hljs">$ git describe --tags release candidate-3.1.248</code> </pre> <br>  Now that we know that candidate-3.2.259 is in our release candidate, we can get the difference between these two tags: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --oneline candidate-3.1.248..candidate-3.2.259</code> </pre> <br>  Well, or even simpler, without tags, just compare the HEAD of the release and candidate branches: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --oneline release..candidate</code> </pre> <br><h2>  Applicable operations </h2><br>  Here are some commonly used operations when working on ThreeFlow.  All examples assume that your local branches are correctly correlated with remote branches and contain relevant changes.  If you are not sure about this, it will always be a good idea to do git fetch once again and then use names like origin / master instead of just master <br><br>  <b>How can I make a release candidate from the master branch?</b> <br><br><pre> <code class="bash hljs">$ git checkout candidate $ git pull $ git merge --no-ff master $ git tag candidate-3.2.645 <span class="hljs-comment"><span class="hljs-comment">#optionally tag the candidate $ git push --follow-tags</span></span></code> </pre> <br>  <b>How do I release from a release candidate?</b> <br><br><pre> <code class="bash hljs">$ git push --force origin &lt;tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the candidate&gt;:release</code> </pre> <br>  If for some reason you decided not to tag release candidates, you will have to do: <br><br><pre> <code class="bash hljs">$ git push --force origin candidate:release</code> </pre> <br>  <b>How can I find a branch in which there is some particular commit?</b> <br>  Sometimes people want to make sure that a particular change is included in the release candidate or release.  Here's how to check it out: <br><br><pre> <code class="bash hljs">$ git branch -r -contains &lt;sha of commit&gt;</code> </pre> <br>  <b>How can I find the tag pointed to by the HEAD of some branch?</b> <br><br><pre> <code class="bash hljs">$ git describe --tags &lt;branch&gt;</code> </pre> <br>  <b>How do I know which commits will be included in some new release?</b> <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --oneline release..&lt;tag of release candidate&gt;</code> </pre> <br>  or: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --oneline release..origin/candidate</code> </pre> <br>  <b>How do I set up release candidates and releases?</b> <br>  Any project starts with the first commit.  Usually this is something simple, like adding a readme file.  I advise you to simply make the branches of release candidates and releases from this commit.  What we need to get is the first merge-commit with two parents.  This way we get the correct story.  So, in general, any commit master branch will do.  Why not take the first one? <br><br><pre> <code class="bash hljs">$ git branch candidate `git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --format=%H --reverse | head -1` $ git checkout candidate $ git push</code> </pre> <br>  To make a branch for releases: <br><br><pre> <code class="bash hljs">$ git branch release $ git branch release --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-upstream-to=origin/release</code> </pre> <br><h2>  Questions </h2><br>  <b>Isn't it described as a ‚Äúcactus model‚Äù?</b> <br>  You might think that the branch strategy described in the article is very similar to the ‚Äú <a href="https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/">cactus model</a> ‚Äù described by Jussi Judin (also as an alternative to GitFlow and also using the master branch for the entire work).  Yes, for the most part the way it is.  The key difference is that Judin proposes to move commits from the master branch to the release branch selectively (‚Äúcherry-picks‚Äù).  I am totally against it.  Selectively moving commits is an extreme measure that should be used last of all in a completely catastrophic state of the master and a great need for an urgent release.  I prefer to use a move (rebase) rather than a merge.  And avoid selectivity. <br><br>  Another difference is the existence of release candidate branches in ThreeFlow, which I accept as the minimum necessary evil.  Personally, my goal is to maintain the master branch in such a state that it was possible to poke a finger into each commit and immediately calmly put it into production.  But I noticed that many commandos find it difficult and uncomfortable to work in this mode.  People prefer to have a buffer in the form of a QA team, who need to give a build approved by developers (‚Äútake this one, not the one, that bad one‚Äù) and get feedback about its quality from them.  And the ThreeFlow model gives them that opportunity.  In teams that are well suited to product quality, the differences between the release and release branches will be minimal. <br><br>  <b>Isn't it described by GitFlow just without branches for features?</b> <br>  In fact, I explained this strategy to those who previously used GitFlow in a similar way: ‚ÄúYou do not use branches for features, all development goes in the develop branch, which we will now call master, and what you call master we will call branch releases.  The main idea of ‚Äã‚ÄãThreeFlow was to minimize the complexity.  GitFlow encourages the creation of new entities (branches) for any reason (for features, releases, hotfixes).  The larger the project and the longer it goes - the worse its story looks.  ThreeFlow strives to minimize the number of branches - no branches for features or hotfixes.  Features are written in the master, hotfixes roll on the release candidate, or even release.  And instead of a bunch of release branches, we always have what we call the current release candidate and the current release.  Only three branches.  Is always. <br><br>  We also do not need to invent a naming system for branches (we have only three of them and their names are constant): master, candidate, release. <br><br>  There is always an answer to the question ‚Äúwhere should I put my code?‚Äù.  If this is a hot fix in production, release.  If this is a bug fix in the release candidate - in the candidate.  If this is the usual daily work - in the master. <br><br>  <b>What about review code?</b> <br>  If you have a rule to revise the entire code before it gets into the main development branch, then it will be logical to add another branch (let's call it develop - yes, steal that name from GitFlow, why not).  So, all the development will go in it, and then the reviewer will transfer the approved commits from it to the master (well, or ask them to modify).  Of course, it will be necessary to somehow track what was transferred and what is not, and this can cause difficulties.  It must be admitted that strictly following the idea of ‚Äã‚Äãreviewing the code before the commit to the main branch may not work for your team when using ThreeFlow or will require further adaptation of this approach.  I heard that people successfully used tools like Gerrit for such purposes, although I never used it myself. <br><br>  <b>What about code bases in which several artifacts are stored?</b> <br>  In many cases, code that actually contains several projects can be stored in one code base.  These individual build artifacts require separate validation cycles by the QA department and will have separate release candidate versions.  How will ThreeFlow work in this case? <br><br>  It will work well.  Most recently, I once worked in a similar project.  We had one Git repository from which several different artifacts were collected and deployed.  The solution is obvious: each artifact adds two branches to the repository.  You still write all the code in the master and work on the features using the disable flags.  To do this, you do not need to know how much and what artifacts will be collected from the repository.  But it comes to release, and here each artifact needs its own branches for release candidates and releases: foo_candidate, foo_release, bar_candidate, bar_release.  That's all. <br><br>  It scales better than you think.  In one of my last projects we had one big code base from which 4 different artifacts were collected.  Some common code, something individually for each subproject - well, you understand.  On the one hand - 8 branches for release candidates and releases, plus one master.  But on the other hand, each artifact had its own separate team, and for each of them only their three branches were relevant, so that their total number was of little concern to them. <br><br>  <b>Is it possible to somehow avoid the recruitment of additional Git command arguments?</b> <br>  One of the features of the proposed approach is that almost every command used actually has additional arguments.  Every time you do a merge, you need to remember to add "--no-ff".  When you make a release and tag it - I advise you to use "--follow-tags" when pushing to save tags to origin.  You can make these tags apply by default: <br><br><pre> <code class="bash hljs">$ git config --global merge.ff no</code> </pre> <br>  Now you can use the merge command without the "--no-ff" parameter (it will be added implicitly) <br><br>  Similarly with tags when pushing: <br><br><pre> <code class="bash hljs">$ git config --global push.followTags <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  You can also configure automatic rebase when pull: <br><br><pre> <code class="bash hljs">$ git config --global branch.master.rebase <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  You can even make all new branches automatically reuse when you pull if you use local branches to work on individual features: <br><br><pre> <code class="bash hljs">$ git config --global branch.autosetuprebase always</code> </pre> <br>  You can also remove the "--global" key from the above commands, if you want to apply these rules only to the current repository, and not to all in general. <br><br>  <b>Can I use merge for a release branch?</b> <br>  Well, first of all, you are a free person and you can do whatever you want.  I just describe a strategy that works well for me and some other people.  It seems to me that it is better than GitFlow (because it is easier). <br><br>  Secondly, yes, if you don‚Äôt like the idea of ‚Äã‚Äãpushing the "--force" key and losing some of the historical information, you can do a merge with the "--no-ff" key.  Plus, there‚Äôs also the fact that you don‚Äôt need to memorize different ways to transfer a commit between branches.  Just make yourself a merge --no-ff always, and that's all. <br><br>  In fact, the first version of ThreeFlow described exactly this behavior, merging with the --no-ff option for releases.  It worked fine, the story was well read.  The only thing I didn‚Äôt like was that the build artifact from the release branch was not formally the same commit that was previously considered a release candidate and went through QA and approval for release.  It turns out, we tested one, then did something else, and here it is another rel.  Poorly.  You can, of course, replace the merger with fast forwarding, but this also leads to the loss of information, and it‚Äôs not a fact that it is guaranteed to succeed. <br><br>  In my opinion, push + force more clearly indicates that the content of the release is actually not a branch in the terminology of the chain of inherited commits and should not be interpreted as follows.  This is just a pointer to the actual code that is currently running in production.  And the release branch itself simply points to a series of tags that were once laid out in production.  Well, since this is still a branch with the actual code, you can always make a hotfix for production right in it. <br><br><h2>  Summarize </h2><br>  Using Git without a coherent branching strategy is a dangerous business.  So take this one: <br><br><ul><li>  There are three branches: master, candidate, release </li><li>  We work in the master.  All new commits are added using rebase. </li><li>  Features in the development process are disabled flags.  Included when they are ready. </li><li>  When it comes time to make a release candidate - it is made from the master by merging (merge with the "--no-ff" key) of its commits with the candidate branch. </li><li>  ,  QA   -,       (  merge   "--no-ff")  master </li><li>     -  ,     "--forced"   release </li><li>        release     candidate  master </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/80c/2be/8fd/80c2be8fdb65efbee47f64983b6057e3.png" alt="image"><br><br>  That's all.    ThreeFlow        Git,         . <br><br>    ?    ?     ,    "--force"    ,  ?       ! </div><p>Source: <a href="https://habr.com/ru/post/345826/">https://habr.com/ru/post/345826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345816/index.html">WD Red drives - a balanced solution for use in small and medium NAS</a></li>
<li><a href="../345818/index.html">Visualization of the development of SEMrush.com 2017</a></li>
<li><a href="../345820/index.html">Backup Mikrotik with SSH and SCP</a></li>
<li><a href="../345822/index.html">Defining a file format with Python</a></li>
<li><a href="../345824/index.html">Parallel data sorting in GPU</a></li>
<li><a href="../345830/index.html"># Acceleration4X. Principle number 0/1. Variable environment</a></li>
<li><a href="../345832/index.html">Issue # 5: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../345834/index.html">"Hello Christmas - New Year!" Or program NanoCAD with Visual Basic .NET</a></li>
<li><a href="../345836/index.html">Richard Hamming: The Basics of the Digital (Discrete) Revolution</a></li>
<li><a href="../345840/index.html">‚ÄúWishes‚Äù for 1C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>