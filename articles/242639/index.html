<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perfect transfer and universal references in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, a link to Eli Bendersky ‚Äôs article ‚ÄúPerfect forwarding and universal references in C ++‚Äù was published on isocpp.org. In this small article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perfect transfer and universal references in C ++</h1><div class="post__text post__text-html js-mediator-article">  Recently, a link to Eli Bendersky <a href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c">‚Äôs</a> article <a href="http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c">‚ÄúPerfect forwarding and universal references in C ++‚Äù</a> was published on isocpp.org.  In this small article there is a simple answer to a simple question - to solve which problems and how to use rvalue links. <br><a name="habracut"></a><br>  One of the innovations in C ++ 11, which aims to increase the efficiency of programs, is the family of emplace methods in STL containers.  For example, the std :: vector method has the emplace_back method (almost an analogue of the push_back method) and the emplace method (almost the analogue of the insert method). <br>  Here is a small example showing the purpose of these new methods: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyKlass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyKlass(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ii_, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ff_) {...} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: {...} }; some function { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;MyKlass&gt; v; v.push_back(MyKlass(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3.14f</span></span>)); v.emplace_back(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3.14f</span></span>); }</code> </pre> <br>  If you follow the calls to the constructors and destructors of the class MyKlass, during the push_back call you can see the following: <br><br><ul><li>  First, the constructor of the temporary object class MyKlass is executed. </li><li>  Then, for the object directly located inside the vector, the displacement constructor is called (if it is defined in MyClass, if not defined, then the copy constructor is called) </li><li>  Temporary object destructor </li></ul><br>  As you can see, quite a lot of work is being done, the greater amount of which is not very necessary, since the object passed to the push_back method is obviously an rvalue reference and is destroyed immediately after the execution of this expression.  Thus, there is no reason to create and destroy a temporary object.  Why, in this case, not to create an object right inside the vector?  This is exactly what the emplace_back method does.  For the expression from the example v.emplace_back (2, 3.14f), only one constructor is executed that creates an object inside the vector.  Without the use of temporary objects.  The emplace_back itself calls the MyKlass constructor and passes the necessary arguments to it.  This behavior was made possible thanks to two innovations from C ++ 11: templates with a variable number of arguments (variadic templates) and perfect transmission (perfect forwarding).  In this article I want to explain how the perfect transmission works and how to use it. <br><br><h4>  The problem of perfect transmission </h4><br>  Suppose there is some func function that accepts parameters of types E1, E2, ..., En.  You want to create a wrapper function that accepts the same set of parameters.  In other words, to define a function that will transfer the received parameters to another function without creating temporary variables, that is, it will perform an ideal transfer. <br>  In order to specify the task, consider the method of emplace_back, which was described above.  vector :: emplace_back passes its parameters to the constructor T without knowing anything about what T is. <br>  The next step is to look at several examples showing how this behavior can be achieved without the use of the C ++ 11 innovations.  For simplicity, we will not take into account the need to use templates with a variable number of argument parameters; suppose that only two arguments are required. <br>  The first option that comes to mind: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 e1, T2 e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); }</code> </pre><br>  But this obviously will not work as needed if func takes parameters by reference, since the wrapper takes parameters by value.  In this case, if func changes the parameters received by reference, this will not affect the parameters passed to the wrapper (copies created inside the wrapper will be modified). <br>  Well, then we can remake the wrapper so that it takes the parameters by reference.  This will not be a hindrance if func will be taken not by reference, but by value, since the func inside the wrapper will make the necessary copies for itself. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1&amp; e1, T2&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); }</code> </pre><br>  Here is another problem.  Rvalue cannot be passed to a function as a reference.  Thus, a completely trivial call will not compile: <br><pre> <code class="cpp hljs">wrapper(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// :    rvalue- wrapper(i, foo_returning_float()); //   </span></span></code> </pre><br>  And immediately there is no, if the thought came to make these links constant - this also does not solve the problem.  Because func may require non-constant links as parameters. <br>  All that remains is a rough approach used in some libraries: overload the function for constant non-constant references: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1&amp; e1, T2&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T1&amp; e1, T2&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1&amp; e1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T2&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T1&amp; e1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T2&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(e1, e2); }</code> </pre><br>  Exponential growth.  You can imagine how much fun it will bring when you need to handle some reasonable number of parameters of real functions.  To make matters worse, C ++ 11 adds rvalue links, which also need to be taken into account in the wrapper function, and this is definitely not an extensible solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Link compression and special type inference for rvalue links </h4><br>  In order to explain how the perfect transfer is implemented in C ++ 11, you must first understand two new rules that have been added to this programming language. <br>  Let's start with a simple one ‚Äî link collapsing.  As you know, taking a link to a link in C ++ is not allowed, but this can sometimes happen when implementing templates: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T&amp; k = t; }</code> </pre><br>  What happens if you call this function like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ii = <span class="hljs-number"><span class="hljs-number">4</span></span>; baz&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&gt;(ii);</code> </pre><br>  When instantiating a template, T is set equal to int &amp;.  What is the type of the variable k inside the function?  The compiler "sees" int &amp; &amp; - and since this is a forbidden construction, the compiler simply converts it into a regular link.  In fact, prior to C ++ 11, this behavior was not standardized, but many compilers accepted and converted such code, as it is often found in metaprogramming.  After rvalue links were added to C ++ 11, it became important to determine the behavior when combining different types of links (for example, what does int &amp;&amp; &amp;? Mean). <br>  So the link compression rule appeared.  This rule is very simple - a single ampersand (&amp;) always wins.  Thus - (&amp; &amp; &amp;) is (&amp;), as well as (&amp;&amp; and &amp;), and (&amp; &amp; &amp;).  The only case in which the result of compression is (&amp;&amp;) is (&amp;&amp; and &amp;&amp;).  This rule can be compared with the result of a logical OR, where &amp; is 1, and &amp;&amp; is 0. <br>  Another C ++ addition that is directly related to the topic under consideration is the special type deduction rules for rvalue references in various cases [1].  Consider an example of a template function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) {</span></span> }</code> </pre><br>  Don't let a double ampersand fool you - t here is not an rvalue link [2].  When appearing in a given situation (when a special type inference is needed), T &amp;&amp; takes on special significance - when func is instantiated, T changes depending on the type transferred.  If a lvalue of type U is passed, then T becomes U &amp;.  If U is an rvalue, then T becomes just U. Example: <br><pre> <code class="cpp hljs">func(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 4  rvalue: T  int double d = 3.14; func(d); // d  lvalue; T  double&amp; float f() {...} func(f()); // f()  rvalue; T  float int bar(int i) { func(i); // i  lvalue; T  int&amp; }</span></span></code> </pre><br>  This rule may seem unusual and even strange.  It is.  But, nevertheless, this rule becomes quite obvious when it comes to the understanding that this rule helps to solve the problem of perfect transmission. <br><br><h4>  Implementing perfect transmission using std :: forward </h4><br>  Now let's go back to our wrapper template function described above.  Here is how it should be implemented using C ++ 11: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1&amp;&amp; e1, T2&amp;&amp; e2)</span></span></span><span class="hljs-function"> </span></span>{ func(forward&lt;T1&gt;(e1), forward&lt;T2&gt;(e2)); }</code> </pre><br>  And this is how forward [3] is implemented: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:remove_reference&lt;T&gt;::type&amp; t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&amp;&amp;&gt;(t); }</code> </pre><br>  Consider the following challenge: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ii ...; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ff ...; wrapper(ii, ff);</code> </pre><br>  Consider the first argument (the second is similar): ii is an lvalue, so T1 becomes int &amp; according to the special type inference rule.  The call to func (forward &lt;int &amp;&gt; (e1), ...) is obtained.  Thus, the forward pattern is instantiated by the int &amp; type and we get the following version of this function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; &amp;&amp;&gt;(t); }</code> </pre><br>  Time to apply link compression rule: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&gt;(t); }</code> </pre><br>  In other words, the argument is passed by reference to func, as required for lvalue. <br>  The following example: <br><pre> <code class="cpp hljs">wrapper(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14f</span></span>);</code> </pre><br>  Here the arguments are rvalue, so T1 becomes an int.  We receive call func (forward (e1), ...).  Thus, the template function forward is instantiated by type int and we get the following version of the function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp;&gt;(t); }</code> </pre><br>  The argument received by reference is converted to an rvalue reference, which is required to receive from forward. <br>  The template function forward can be considered as some kind of wrapper over static_cast &lt;T &amp;&amp;&gt; (t), when T can take the value U &amp; or U &amp;&amp;, depending on the type of input argument (lvalue or rvalue).  Now the wrapper is one template that handles any combination of argument types. <br>  The template forward function is implemented in C ++ 11, in the header file ‚Äúutility‚Äù, in the namespace std. <br><br>  Another point to note is the use of std :: remove_reference.  In fact, forward can be implemented without using this function.  Link compression will do all the work, so using std :: remove_reference for this is redundant.  However, this function allows you to infer T &amp; t in a situation where this type cannot be inferred (according to the C ++ standard, 14.8.2.5), therefore it is necessary to explicitly specify the template parameters when calling std :: forward. <br><br><h4>  Universal links </h4><br>  In his speeches, blog posts and books, Scott Myers gives the name ‚Äúuniversal reference‚Äù for rvalue links, which are in the context of type inference.  Successful is the name or not, it is difficult to say.  As for me, when I first read the relevant chapter of the new book ‚ÄúEffective C ++‚Äù, I felt confused.  More or less, everything became clear later when I figured out the underlying mechanisms (link compression and special type inference rules). <br>  The trap is that the phrase ‚Äúuniversal links‚Äù [4] is of course shorter and more beautiful than ‚Äúrvalue links in the context of type inference‚Äù.  But if there is a desire to actually understand some code, it will not be possible to avoid a complete description. <br><br><h4>  Examples of using perfect transmission </h4><br>  Ideal transfer is quite useful because it makes programming at a higher level possible.  Higher-order functions are functions that can take other functions as arguments or return them.  Without a perfect transfer, the use of higher-order functions is rather cumbersome, since there is no convenient way to pass arguments to a function inside a wrapper function.  By the term ‚Äúfunction‚Äù, here, in addition to the functions themselves, I also mean classes, the constructors of which are also functions. <br>  At the beginning of this article, I described the container method emplace_back.  Another good example is the standard make_unique template function, which I described in a <a href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/">previous article</a> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T&gt; make_unique(Args&amp;&amp;... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)); }</code> </pre><br>  I admit honestly that in that article I simply ignored the strange double ampersand and focused on a variable number of template arguments.  But now it is completely easy to fully understand the code.  It goes without saying that the ideal transfer and templates with a variable number of arguments are very often used together, because, in most cases, it is not known how many arguments the function or constructor takes, to which we pass these arguments. <br>  As an example with a much more complicated use of the ideal transfer, you can see the implementation of std :: bind. <br><br><h4>  References to sources </h4><br>  Here are some sources that helped me a lot when preparing the material: <br><ol><li>  The 4th edition of The C ++ Programming Language by Bjarne Stroustrup </li><li>  The new "Effective Modern C ++" by Scott Myers.  In this book, ‚Äúuniversal links‚Äù are widely discussed.  In fact, more than one fifth of this book is devoted to this topic. </li><li>  Technical paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">n1385</a> : "The forwarding problem: Arguments". </li><li>  Thomas Becker <a href="http://thbecker.net/articles/rvalue_references/section_01.html">C ++ Rvalue references explained</a> - well written and very useful article </li></ol><br>  Notes: <br>  [1] Auto and decltype can also be used, here I describe only the case of using a pattern. <br>  [2] I consider as unsuccessful the decision of the C ++ Standardization Committee on the choice of notation for rvalue links (overload &amp;&amp;).  Scott Myers admitted in his speech (and commented a bit on his blog) that after 3 years this material is still not easy to learn.  And Bjorn Straustrup in The 4th edition of ‚ÄúThe C ++ Programming Language‚Äù, when describing std :: forward, forgot the explicit indication of the template argument.  It can be concluded that this is indeed a rather difficult area. <br>  [3] This is a simplified version of std :: forward from STL C ++ 11.  There is still an additional version that is explicitly overloaded for the rvalue arguments.  I still try to figure out why it is needed.  Let me know if there is any idea. <br>  [4] Forwarding references are another designation that I have met. <br><br>  From the translator: on CppCon2014, many (including Meyers, Stroustrup, Saffer) decided to use the term <i>forwarding references</i> instead of <i>universal references</i> . <br><br>  A couple of articles on Habr√© on this topic: <br>  <a href="http://habrahabr.ru/post/226229/">Brief introduction to rvalue links</a> <br>  <a href="http://habrahabr.ru/post/157961/">"Universal" links in C ++ 11 or T &amp;&amp; do not always mean "Rvalue Reference"</a> </div><p>Source: <a href="https://habr.com/ru/post/242639/">https://habr.com/ru/post/242639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242621/index.html">Objective-C Minimalism</a></li>
<li><a href="../242623/index.html">Brackets for doubters and newbies</a></li>
<li><a href="../242627/index.html">A cozy book post for you and your project.</a></li>
<li><a href="../242629/index.html">Hands off the console</a></li>
<li><a href="../242631/index.html">Sync music and gaming events on Unity</a></li>
<li><a href="../242643/index.html">Create a portfolio based on photos from Instagram</a></li>
<li><a href="../242645/index.html">‚ÄúNever say never‚Äù or working with timezone correctly</a></li>
<li><a href="../242647/index.html">The simplest SMTP server for development</a></li>
<li><a href="../242649/index.html">Lattice inheritance</a></li>
<li><a href="../242653/index.html">New profession at the first attempt or sincerity at the interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>