<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unnecessary items or how we balance between servers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Some time ago, people realized that it was simply impossible to increase the capacity of the server in accordance with the increase in load....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unnecessary items or how we balance between servers</h1><div class="post__text post__text-html js-mediator-article">  <b>Hi, Habr!</b>  Some time ago, people realized that it was simply impossible to increase the capacity of the server in accordance with the increase in load.  It was then that we learned the word "cluster".  But no matter how beautiful this word may sound, you still have to technically combine disparate servers into a single whole - that same cluster.  <a href="http://habrahabr.ru/company/ivi/blog/237349/">Through the cities and villages,</a> we got to our sites in my previous opus.  And today, my story will go about how system integrators divide the load between cluster members, and how we did it. <br><br> <a href="http://habrahabr.ru/company/ivi/blog/240237/"><img src="https://habrastorage.org/files/f1b/395/4e3/f1b3954e31144badab09069df1715645.jpg"></a> <br><br>  Inside the publication you are also waiting for a bonus in the form of three certificates for a <a href="http://www.ivi.ru/plus/">monthly ivi + subscription</a> . <br><a name="habracut"></a><br><h2>  <font color="#fd004c">Do like everyone else</font> </h2><br>  What tasks are set for the cluster? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>1.</b> A lot of traffic <br>  <b>2.</b> High reliability <br>  <font color="#FFFFFF">03d63a0996fb</font> <br>  How to achieve this?  The easiest way to share the load between servers is not to divide it.  Or rather: give a complete list of servers - let the customers understand themselves.  How?  Yes, simply registering all the IP-addresses of servers in the DNS for a given name.  An ancient and famous <a href="https://ru.wikipedia.org/wiki/Round_robin_DNS">round-robin DNS</a> balancing.  And in general, it works well until the need to add a node arises - I already <a href="http://habrahabr.ru/company/ivi/blog/237349/">wrote</a> about the inertia of DNS caches.  DNS balancing looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/037/2b1/0f6/0372b10f64ac4d5aa3dcbbd4827e2ac2.png"></div><br>  And if you need to remove the server from the cluster (well, it broke), comes the skull.  In order not to attack us, we need to quickly hang up the IP of the failed server somewhere.  Where?  Well, let's say, on a neighbor.  Okay, how can we automate this?  For this, a bunch of protocols like <abbr title="Virtual Router Redundancy Protocol">VRRP</abbr> , <abbr title="Common Address Redundancy Protocol - public address duplication protocol">CARP</abbr> with its own advantages and disadvantages were invented. <br><br>  The first thing that is usually rested is the ARP cache on the router, which does not want to understand that the IP address has moved to another MAC.  However, modern implementations either ‚Äúping‚Äù a router from a new MAC (updating the cache in this way), or generally use a virtual MAC, which does not change during operation. <br><br>  The second thing that hits the head is server resources.  We are not going to keep one of the two servers in hot standby?  The server should work!  Therefore, we will reserve two addresses on each server via VRRP: one - primary and one backup.  If one of the servers of the pair fails, the second will take over all of its load ... maybe ... if it manages.  And this ‚Äúpairing‚Äù will be the main drawback, because it is not always possible or advisable to keep double the reserve of server power. <br><br>  It is also impossible not to notice that each server requires its own globally routable IP address.  In our difficult time this can be a big problem. <br><br>  In general, I rather do not like this method of balancing and reservation, but for a number of tasks and traffic volumes it is good.  Simple  Does not require additional equipment - everything is done with server software. <br><br><h2>  <font color="#fd004c">On the ball</font> </h2><br>  Continuing the enumeration of simple solutions, or maybe you should just hang the same IP address on multiple servers?  Well, in IPv6 there is an opportunity to do anycast in one domain (and then balancing will be there only for the hosts inside it, and for external ones - not at all), but in IPv4 such a thing will just create an ARP conflict (better known as address conflict) .  But this is if "in the forehead." <br><br>  And if you use a small twist code-named "shared address" (shared address), then this is possible.  The essence of the trick is to first turn the incoming unique to broadcast (well, if anyone wants - let him do multicast), and then only one of the servers responds to packets from this client.  How is the transformation?  Very simple: all servers in a cluster in response to an ARP request return the same MAC: either nonexistent on the network or multicast.  After that, the network itself will propagate incoming packets to all members of the cluster.  How do the servers agree on who is responsible?  For simplicity, let's say this: by the remainder of dividing srcIP by the number of servers in the cluster.  Next - a matter of technology. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ff0/afc/37d/ff0afc37db94489c9abd4c130d85ee48.png"></div><br>  <i><font color="#999999">Balancing with shared address</font></i> <br><br>  This technique is implemented by different modules and different protocols.  For FreeBSD, this feature is implemented in <a href="https://www.freebsd.org/doc/handbook/carp.html">CARP</a> .  For Linux in a past life, I used <a href="http://www.linux-ha.org/ClusterIP">ClusterIP</a> .  Now he, apparently, does not develop.  But I'm sure there are other implementations.  For Windows, this is in the built-in clustering tools.  In general, there is a choice. <br><br>  The advantage of this balancing is still purely server implementation: no special configuration from the network is required.  The public address is used only one.  Adding or shutting down a single server in a cluster is fast. <br><br>  The disadvantages are, firstly, the need for additional checks at the application level, and secondly (and even ‚Äúin the main‚Äù) - this restriction on the incoming band: the amount of incoming traffic can not exceed the band in the physical connection of servers.  And this is obvious: after all, incoming traffic goes to all servers at the same time. <br><br>  So overall, this is a good way to balance traffic if you have some incoming traffic, but it should be used wisely.  And here I will modestly say that now we do not use this method.  Just because of the problem of incoming traffic. <br><br><h2>  <font color="#fd004c">Never talk to integrators</font> </h2><br>  For some reason it seems to me that the task of balancing between servers should be typical.  And for a typical task there should be typical solutions.  And who sells well typical solutions?  Integrators!  And we asked ... <br><br>  Do I have to say that we were offered solutions from the wagons of the most different equipment?  From <a href="http://habrahabr.ru/post/143564/">Cisco ACE</a> to every <a href="https://f5.com/products/modules/local-traffic-manager">F5 BigIP LTM</a> .  Expensive.  But is it good?  Well, there is still a wonderful free software L7 balancer <a href="http://www.haproxy.org/">haproxy</a> . <br><br>  What is the meaning of these things?  The point is that they do balancing at the application level - Layer 7. In fact, such balancers are full proxies: they establish a connection with the client and the server on their own behalf.  In theory, this is good in that they can adhere the client to a specific server (server affinity) and even choose a backend depending on the requested content (an extremely useful thing for such a resource as <a href="http://www.ivi.ru/">ivi.ru</a> ).  And with a certain setting - and filter requests by URL, defending against various kinds of attacks.  The main advantage is that such balancers can determine the viability of each node in the cluster on their own. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ac8/92e/828/ac892e82804c459b932141bb3e2beffd.png"></div><br>  <i><font color="#999999">Balancers are included in the network somehow</font></i> <br><br>  I admit, my past experience shouted "Without balancers, nothing is possible to do."  We counted ... and were amazed. <br><br>  The most productive balancers that we were offered had a bandwidth of 10 Gbit / s.  By our standards, it is not funny (servers with heavy content are connected with 2 * 10 Gbit / s).  Accordingly, to get the right lane, you would have to fill the whole rack with such balancers, taking into account the redundancy.  Look here at this scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d6a/a11/ac6/d6aa11ac6ec447a3b81d61f99dfbd96f.png"></div><br>  <i><font color="#999999">This is the physical connection of the balancer.</font></i> <br><br>  Of course, there is also a partial proxy mode (half-proxy), when only half of the traffic passes through the balancer: from the client to the server, and back from the server goes directly.  But this mode disables the L7 functionality, and the balancer becomes L3-L4, which dramatically reduces its value.  And then there are two consecutive problems: first, you need to make sufficient network capacity (first of all - by ports, then - by reliability).  Then the question arises: how to balance the load between the balancers?  In Moscow, to put a rack with equipment for balancing, in theory, probably possible.  But in regions where our nodes are minimalist (servers and tsiska) the addition of several balancers is somehow not funny.  In addition, the longer the chain, the lower the reliability.  And we need it? <br><br><h2>  <font color="#fd004c">ECMP or nothing else</font> </h2><br>  The decision went almost randomly.  It turns out that a modern router by itself can balance traffic.  If you think this is reasonable: after all, the same subnet can be accessed through different channels with the same quality.  This feature is called <b>ECMP</b> - Equal Cost Multiple Paths.  Seeing routes that are identical in their metrics (in the general sense of the word), the router simply divides the packets between these routes. <br><br>  OK, the idea is interesting, but will it work?  We conducted a test run, registering static routes from the router towards several servers.  The concept turned out to be workable, but additional study was required. <br><br>  <b>First</b> , it is necessary to ensure that all IP packets belonging to the same TCP session on the same server.  After all, otherwise the TCP session simply does not take place.  This is the so-called ‚Äúper-flow‚Äù mode (or ‚Äúper-destination‚Äù), and it seems to be enabled by default on Cisco routers. <br><br>  <b>Secondly</b> , static routes are not suitable - because we need to be able to automatically remove a broken server from the cluster.  Those.  you must use some kind of dynamic routing protocol.  For uniformity, we chose <abbr title="Border Gateway Protocol, Border Gateway Protocol">BGP</abbr> .  A software router is installed on the servers (now it is <a href="http://www.nongnu.org/quagga/">quagga</a> , but in the near future we will switch to <a href="http://bird.network.cz/">BIRD</a> ), which announces the ‚Äúserver‚Äù network on the router.  As soon as the server stops sending announcements, the router stops distributing traffic.  Accordingly, for balancing on the router, the <code>maximum-paths ibgp</code> value is <code>maximum-paths ibgp</code> equal to the number of servers in the cluster (with some reservations): <br><br><pre> <code class="hljs pgsql"> router bgp <span class="hljs-number"><span class="hljs-number">57629</span></span> address-<span class="hljs-keyword"><span class="hljs-keyword">family</span></span> ipv4 maximum-paths ibgp <span class="hljs-number"><span class="hljs-number">24</span></span></code> </pre><br>  But BGP itself guarantees only the network availability of the server, but not the application.  To check the functionality of the application software, a script is running on the server that performs a number of checks, and if something went wrong, it simply extinguishes BGP.  Next thing router - stop sending packets to this server. <br><br>  <b>Third</b> , the heterogeneity of the distribution of requests between servers was noticed.  Small, and compensated by our clustering software, But I wanted some uniformity.  It turned out that by default the router balances packets based on the sender and recipient addresses of the packet, that is, L3 balancing.  Assuming that the address of the recipient (server) is always the same, this indicates a non-uniformity in the source addresses.  Given the massive NAT'izatsii Internet, this is not surprising.  The solution turned out to be simple - to force the router to take into account the receiver and source ports (L4 balancing) with a command like <br><br><pre> <code class="hljs pgsql">platform ip cef <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>-sharing <span class="hljs-keyword"><span class="hljs-keyword">full</span></span></code> </pre><br>  or <br><br><pre> <code class="hljs sql">ip cef <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>-sharing algorithm <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-ports <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> destination</code> </pre><br>  depending on iOS.  The main thing is that you do not have such a command: <br><br><pre> <code class="hljs pgsql">ip <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>-sharing per-packet</code> </pre><br>  The final scheme looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9b3/d66/f5f/9b3d66f5f75146e4b13dc5f12e3c7b1b.png" alt="7e2d4044161d"></div><br>  Did you notice anything familiar?  Well there, that this is actually anycast, just not between regions, but inside one node?  So this is it! <br><br>  The advantages of L3-L4 balancing can be called efficiency: a router should be, without it in any way.  Reliability is also at the proper level - if the router suddenly breaks, then it doesn't matter anymore.  Additional equipment is not purchased - this is good.  Public addresses are also not consumed - the same IP is served by several servers at once. <br><br>  There are, alas, and disadvantages. <br><br>  <b>1.</b> You have to install additional software on the server, configure it, etc.  True, this software is quite modest, and does not consume server resources.  So - tolerated. <br><br>  <b>2.</b> Transients of one server (inclusion in a cluster or an exception) affect the entire cluster.  After all, the router does not know anything about the servers - he thinks that he is dealing with routers and channels.  Accordingly, all connections are distributed to all available channels.  No server-affinity.  As a result, when you turn off the server, all connections are shuffled between all remaining servers.  And all active TCP sessions are broken (strictly speaking - not all, there is a chance that some will return to the same server).  This is bad, but given our protection against such situations (the player re-queries the content when the connections are broken), and some feints with your ears (which I will tell you about), you can live. <br><br>  <b>3.</b> There are restrictions on how many equal routes a router can share traffic: on cisco 3750X and 4500-X it is 8, on 6500 + Sup2T - 32 (but there is one joke).  In general, this is enough, in addition, there are tricks that allow you to unleash this restriction. <br><br>  <b>4.</b> In this scheme, the load on all servers is distributed evenly, which imposes the requirement of sameness on all servers.  And if you add a more modern, powerful server to the cluster, the load on it will be no more than on the neighbor.  Fortunately, our clustering software eliminates this problem to a large extent.  In addition, the routers still have a function <i>unequal cost multiple paths</i> , which we have not yet involved. <br><br>  <b>5.</b> Typical BGP timeouts can lead to situations where the server is no longer available and the balancing router still distributes the load to it.  But <abbr title="Bidirectional Forwarding Detection">BFD</abbr> will help us with this.  Read more about the protocol - <a href="http://en.wikipedia.org/wiki/Bidirectional_Forwarding_Detection">read wikipedia.</a>  Actually, it is because of the BFD that we decided to switch to BIRD. <br><br><h2>  <font color="#fd004c">Subtotal</font> </h2><br>  The exclusion of balancers from the traffic flow chain allowed us to save on equipment, increased the reliability of the system and kept the minimalism of our regional hubs.  We had to apply a few tricks to compensate for the shortcomings of such a balancing scheme (I hope I still have a chance to talk about these tricks).  But in the existing scheme there is still an extra element.  And I really hope to remove it this year and tell you how we did it. <br><br>  By the way, while I was writing (more precisely, the draft was losing out) this article, my colleagues at Habr√© wrote a very good <a href="http://habrahabr.ru/company/selectel/blog/250201/">article about balancing algorithms</a> .  I recommend to read! <br><br>  <b>PS</b> Certificates are disposable, so that ‚Äúwhoever first got up, he was in the shower‚Äù. <br><br>  Our previous publications: <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/249359/">Blowfish on guard ivi</a> <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/247813/">Non-personalized recommendations: the association method</a> <br>  <font color="#fd004c">"</font> <a href="http://habrahabr.ru/post/237349/">By cities and villages or as we balance between CDN nodes</a> <br>  <font color="#fd004c">"</font> <a href="http://habrahabr.ru/post/236253/" title="b706a658aa01">I am Groot.</a>  <a href="http://habrahabr.ru/post/236253/" title="b706a658aa01">We do our analytics on events</a> <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/236065/">All on one or as we built CDN</a> </div><p>Source: <a href="https://habr.com/ru/post/240237/">https://habr.com/ru/post/240237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240225/index.html">Expressive JavaScript: Program Structure</a></li>
<li><a href="../240227/index.html">How to keep a customer: 5 gorgeous examples of email marketing</a></li>
<li><a href="../240231/index.html">Retrieving and caching screenshots from video by URL</a></li>
<li><a href="../240233/index.html">The official Panasonic online store sends the password in clear and in a copy to 3 recipients.</a></li>
<li><a href="../240235/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ129 (October 5 - 12, 2014)</a></li>
<li><a href="../240243/index.html">The most "ordinary" space gadgets</a></li>
<li><a href="../240245/index.html">A simple reminder for Linux</a></li>
<li><a href="../240247/index.html">How we spent the whole day 10 rubles or Hakaton poison</a></li>
<li><a href="../240261/index.html">From the diary of the prize-winner of the first All-Russian Programming Olympiad for schoolchildren in 1989</a></li>
<li><a href="../240265/index.html">Using Backbone.js when working with html5 canvas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>