<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We test in the browser with the help of Geb</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Geb in practice 
 I, for example, love when the robots do all the work for me. Therefore, I consider it necessary all kinds of scripts, inspections, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We test in the browser with the help of Geb</h1><div class="post__text post__text-html js-mediator-article"><h2>  Geb in practice </h2><br>  I, for example, love when the robots do all the work for me.  Therefore, I consider it necessary all kinds of scripts, inspections, spell checkers and, of course, automatic tests.  By the way, how do you like this testik: <br><br><pre><code class="hljs mel">Browser.drive(driver: new InternetExplorerDriver()) { go <span class="hljs-string"><span class="hljs-string">"http://www.google.com"</span></span> $(<span class="hljs-string"><span class="hljs-string">'form'</span></span>, action:<span class="hljs-keyword"><span class="hljs-keyword">endsWith</span></span>(<span class="hljs-string"><span class="hljs-string">'/search'</span></span>)).q = <span class="hljs-string"><span class="hljs-string">'   geb  spock'</span></span> $(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, value:<span class="hljs-string"><span class="hljs-string">''</span></span>).click() waitFor { $(<span class="hljs-string"><span class="hljs-string">'#search'</span></span>) } assert $(<span class="hljs-string"><span class="hljs-string">'#search'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>() == <span class="hljs-number"><span class="hljs-number">1</span></span> assert $(<span class="hljs-string"><span class="hljs-string">'#search'</span></span>).find(<span class="hljs-string"><span class="hljs-string">'li.g a.l'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> println <span class="hljs-string"><span class="hljs-string">" : "</span></span> + $(<span class="hljs-string"><span class="hljs-string">'#res'</span></span>).find(<span class="hljs-string"><span class="hljs-string">'li.g a.l'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>() }.<span class="hljs-keyword"><span class="hljs-keyword">quit</span></span>()</code> </pre> <br>  It seems to me that such tests have a high degree of readability - it does not even matter what language it is.  It is possible to write a few more similar tests on the same model, without having any idea about Geb, Groovy and how it works.  But for a full understanding of a little dig into the basics. <a name="habracut"></a><br><br><h2>  About Geb and Selenium </h2><br>  Who today has not heard about <a href="http://seleniumhq.org/">Selenium</a> ?  Probably the one who has not smelled gunpowder and still thinks that all browsers are the same.  For a long time I will not talk about it, you just need to know: <br><ul><li>  Selenium allows you to run automated tests directly in the browser, reproducing all sorts of glitches and features. </li><li>  You can do everything that a regular user does, namely, type text, scroll, move the mouse, etc.  At the same time carefully watching the behavior of the page in the browser. </li></ul>  Why is all this so relevant?  In modern web applications, an incredible amount of JavaScript-code, special effects, animation, AJAX and other delights.  There are no normal tools to control quality <em>without a browser</em> in general. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, Selenium is a full-fledged robot for testing in conditions as close to reality as possible.  (Historically, you can still recall Rational Robot, which was sharpened by Internet Explorer and had rather poor interaction with the page.) <br><br>  Selenium itself provides several options for writing tests: <br><ol><li>  Using javascript.  Tests are run directly in the browser and have direct access to the downloaded web page, which allows them to perform any manipulations. </li><li>  Through the managing server.  In a separate process, test code is run in an arbitrary language.  This code calls a special program - WebDriver - which transmits commands to the browser and allows you to control the state of the page. </li></ol>  Not everyone likes to write tests on JavaScript, so the second method - WebDriver - is becoming more common.  It is suitable for developing tests in any language, it is also convenient in that it allows you to perform tests on another machine. <br><br>  So, <a href="http://gebish.org/">Geb</a> is another test-writing tool using WebDriver and based on the Groovy language.  You can use Geb inside the Groovy script using the following magic words: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Grab</span></span>(group=<span class="hljs-string"><span class="hljs-string">'org.codehaus.geb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>=<span class="hljs-string"><span class="hljs-string">'geb-core'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'0.6.2'</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Grab</span></span>(group=<span class="hljs-string"><span class="hljs-string">'org.seleniumhq.selenium'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>=<span class="hljs-string"><span class="hljs-string">'selenium-api'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'2.14.0'</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Grab</span></span>(group=<span class="hljs-string"><span class="hljs-string">'org.seleniumhq.selenium'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>=<span class="hljs-string"><span class="hljs-string">'selenium-firefox-driver'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'2.19.0'</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Grab</span></span>(group=<span class="hljs-string"><span class="hljs-string">'org.seleniumhq.selenium'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>=<span class="hljs-string"><span class="hljs-string">'selenium-ie-driver'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'2.19.0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> geb.Browser <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.openqa.selenium.firefox.FirefoxDriver ...</code> </pre><br><br><h2>  Geb language </h2><br>  One of the features of Groovy (like all dynamic languages) is that it can be easily converted into another completely unrecognizable language - for any needs. <br><br>  In our case, Geb provides a browser control language.  You can do everything that a human user can: <br><ul><li>  Follow URL </li><li>  Fill out forms </li><li>  Move the mouse </li><li>  Click on the link </li><li>  Interact with all sorts of popup windows and frames. </li></ul>  Example: <br><br><pre> <code class="hljs mel">Browser.drive { go <span class="hljs-string"><span class="hljs-string">"http://www.gramant.ru"</span></span> $(<span class="hljs-string"><span class="hljs-string">'.block .caption'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Grails'</span></span>) .closest(<span class="hljs-string"><span class="hljs-string">'.block'</span></span>) .find(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">startsWith</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>)) .click() assert $(<span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-string"><span class="hljs-string">'Grails | Gramant'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>() == <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  As you can see, Geb allows you to use syntax that resembles jQuery (but does not coincide with it completely).  This is convenient for finding the necessary elements in the page.  The <strong>click ()</strong> method allows you to click on DOM elements, the <strong>&lt;&lt;</strong> operation - to send text to the browser, and so on. <br><br>  Enough to navigate.  True, people still know how to read information on the page.  To do this, it would be good for him to first understand what page he is on now.  Let's think for a start, what is a testing <em>page</em> in general? <br><br><h2>  Pages and Modules </h2><br>  We commanded <pre> <code class="hljs scala">go <span class="hljs-symbol"><span class="hljs-symbol">'http</span></span>:<span class="hljs-comment"><span class="hljs-comment">//www.gramant.com'</span></span></code> </pre>  and went to gramant.com.  Now you can ‚Äúread‚Äù this page, i.e.  analyze and find errors.  So?  Not really.  When the browser hits the page, it may happen: <ul><li>  HTTP redirect </li><li>  Any mysterious javascript code will work and redirect you to another page. </li></ul>  We think that we are on one page, but we are on another.  Further tests will go the <em>wrong way</em> .  Therefore, it is very important to understand which <strong>logical</strong> page we are on. <br><br>  Geb suggests using logical pages (Page) and so-called modules.  We will try to illustrate this with the following example: <br><br><img src="https://habrastorage.org/storage2/37d/e59/9b0/37de599b0a227f45c22e94d1964721f8.png"><br>  Why do we need such an abstraction as a <strong>page</strong> ?  It would seem that just look at the current URL and we will find out.  For example: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchResultsPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Page</span></span></span><span class="hljs-class"> </span></span>{ static url = <span class="hljs-string"><span class="hljs-string">"/yandsearch"</span></span> }</code> </pre><br>  But it happens that the same <em>logical</em> page can have many different URLs and states, and it is not always correct to determine the page by URL (which can change unpredictably).  You can do this, for example, by the title: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchResultsPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Page</span></span></span><span class="hljs-class"> </span></span>{ static at = { $(<span class="hljs-symbol"><span class="hljs-symbol">'titl</span></span>e').text() ==~ '.*:  .* ' } }</code> </pre><br>  There are other options for determining the current page;  as you can see, it all depends on the application.  Sometimes many different URLs correspond to the same page;  Sometimes, at the same URL, depending on the internal context, several different pages may appear.  In general, the pseudo-property <strong>at</strong> contains the logic to determine whether the browser is currently on this page. <br><br>  A few words about the modules.  The diagram shows that the <em>module</em> is part of the page (block), and there are modules that are present on several pages.  For example, the Yandex search bar is available both on the portal page and above the search results.  The meaning of the modules is the reuse of the testing code. <br><br>  Modules can be defined, for example, as follows: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ static content = { username {} password {} loginButton { $(<span class="hljs-string"><span class="hljs-string">"input"</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-string"><span class="hljs-string">"submit"</span></span>) } } }</code> </pre><br>  And then use them like this: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Page</span></span></span><span class="hljs-class"> </span></span>{ static content = { login { module <span class="hljs-type"><span class="hljs-type">LoginModule</span></span> } } } <span class="hljs-type"><span class="hljs-type">Browser</span></span>.drive { to <span class="hljs-type"><span class="hljs-type">HomePage</span></span> login.username &lt;&lt; <span class="hljs-symbol"><span class="hljs-symbol">'use</span></span>r' login.password &lt;&lt; <span class="hljs-symbol"><span class="hljs-symbol">'passwor</span></span>d' login.loginButton.click() }</code> </pre><br>  There is, of course, the ability to define many instances of a module within a page - this is relevant for all sorts of lists.  For example, search results - each result can be declared as a module.  This is done using the <strong>moduleList</strong> construct, which I will not dwell on. <br><br><h2>  AJAX and everything, everything, everything </h2><br>  In modern times a lot of amazing things can happen inside a browser: <br><ul><li>  AJAX requests </li><li>  Animation </li><li>  Drag &amp; drop </li><li>  Popup-windows of different types </li></ul>  Testing such things automatically is possible only with the help of in-browser tests.  Geb offers several tools: <br><br><h5>  Access to javascript variables </h5><br>  Through the <strong>js</strong> object, you can access the value of JavaScript <em>global</em> variables: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Browser</span></span>.drive { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span> js.myGlobalVar == <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  You can also use <em>global</em> functions: <br><br><pre> <code class="hljs python">Browser.drive { js.globalCall() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> js.globalFunc() == <span class="hljs-number"><span class="hljs-number">1</span></span> js.<span class="hljs-string"><span class="hljs-string">"document.write"</span></span>(<span class="hljs-string"><span class="hljs-string">"go geb!"</span></span>) js.exec(<span class="hljs-string"><span class="hljs-string">"return document.location.href"</span></span>) == <span class="hljs-string"><span class="hljs-string">'http://www.gramant.ru'</span></span> }</code> </pre><br>  I used this mechanism a little, so I assume that Geb will try to correctly convert all types of JavaScript data (as described <a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/JavascriptExecutor.html">here</a> ) to Groovy types, but I don‚Äôt give a tooth. <br><br>  It is convenient to use jQuery to emulate mouse events.  Geb provides a special jQuery property for such calls: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-type"><span class="hljs-type">Browser</span></span>.drive { <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-comment"><span class="hljs-comment">"div#a"</span></span>).jquery.mouseover() }</code> </pre><br>  This line will work <strong>only</strong> on the condition that jQuery version 1.4 and higher is loaded on the test page.  In fact, such code is translated into <strong>js.exec ()</strong> . <br><br><h5>  Waiting condition </h5><br>  You can wait for something: either setting some JavaScript variables, or the appearance of certain information on a page using the <strong>waitFor</strong> construction. <br><br><pre> <code class="hljs mel">Browser.driver { go <span class="hljs-string"><span class="hljs-string">'http://www.youtube.com/watch?v=8d1hp8n1stA'</span></span> $(<span class="hljs-string"><span class="hljs-string">'button#watch-share'</span></span>).click() waitFor { $(<span class="hljs-string"><span class="hljs-string">'#watch-actions-share'</span></span>).displayed } $(<span class="hljs-string"><span class="hljs-string">'#watch-actions-share'</span></span>).find(<span class="hljs-string"><span class="hljs-string">'button.share-panel-embed'</span></span>).click() waitFor { $(<span class="hljs-string"><span class="hljs-string">'textarea.share-embed-code'</span></span>).displayed } println <span class="hljs-string"><span class="hljs-string">"Embed code   : "</span></span> + $(<span class="hljs-string"><span class="hljs-string">'textarea.share-embed-code'</span></span>).value() }</code> </pre><br>  This script gets the embed code for the YouTube video by clicking a few buttons and waiting for the animation to complete. <br><br>  Of course, the waitFor method will not wait forever and will crash upon reaching a certain timeout, interrupting the test.  The default is 5 seconds. <br><br><h5>  Using WebElement and Actions </h5><br>  We mentioned about Drag &amp; Drop.  At the moment (version 0.6.2), Geb does not have a convenient abstraction for performing such operations.  However, it is always possible to use Selenium directly by accessing an instance of WebDriver (via browser.driver): <br><br><pre> <code class="hljs pgsql">WebElement underlyingElement = $(<span class="hljs-string"><span class="hljs-string">'#myElement'</span></span>).getElement(<span class="hljs-number"><span class="hljs-number">0</span></span>) Action action = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Actions(browser.driver) .clickAndHold(underlyingElement) .moveByOffset(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>() .build() action.<span class="hljs-keyword"><span class="hljs-keyword">perform</span></span>()</code> </pre><br>  The <strong><a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/interactions/Actions.html">Actions</a></strong> class is a low-level way to create a sequence of browser actions in order to perform them sequentially using the perform () method.  I draw your attention to the fact that Actions are <strong>more powerful</strong> in their functionality than just calls to JavaScript code and far from all user actions can be simulated through JavaScript.  The implementation of Actions on the browser side depends heavily on which driver is used and is not portable.  Using Actions is practically the only option for generating tap-events on touch-screen tablets.  There are restrictions - Actions do not allow you to make manipulations with Flash-components on the page;  this is only possible via ExternalInterface using JavaScript, which is much more complicated. <br><br><h2>  Geb inside grails </h2><br>  To use Geb in Grails, it is convenient to use the <a href="http://grails.org/plugin/spock">Spock plugin</a> .  I will not go long about the Spock Framework, there is enough information about it.  Spock is more convenient than the standard JUnit, primarily because it allows you to write tests in your meta-language <em>specifications</em> (again, based on Groovy).  This is both shorter and more expressive. <br><br>  A few words about setting up Geb for Grails 1.3.x.  An example of such a project is posted <a href="https://github.com/geb/geb-example-grails/">here</a> .  The required section in <strong>BuildConfig.groovy</strong> will look like this: <br><br><pre> <code class="hljs bash">dependencies { <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(<span class="hljs-string"><span class="hljs-string">"org.seleniumhq.selenium:selenium-htmlunitdriver:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$seleniumVersion</span></span></span><span class="hljs-string">"</span></span>) { exclude <span class="hljs-string"><span class="hljs-string">"xml-apis"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(<span class="hljs-string"><span class="hljs-string">"org.seleniumhq.selenium:selenium-chrome-driver:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$seleniumVersion</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(<span class="hljs-string"><span class="hljs-string">"org.seleniumhq.selenium:selenium-firefox-driver:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$seleniumVersion</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"org.codehaus.geb:geb-spock:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gebVersion</span></span></span><span class="hljs-string">"</span></span> } plugins { <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">":tomcat:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$grailsVersion</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">":hibernate:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$grailsVersion</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">":geb:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gebVersion</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">":spock:0.5-groovy-1.7"</span></span> }</code> </pre><br>  The current gebVersion is 0.6.2, substitute the desired one. <br><br>  We know that there are two types of tests in Grails - test / unit and test / integration.  Spock also adds test / functional - ‚Äúfunctional‚Äù tests. <br><br>  Geb inside functional tests (Spock specifications) is similar to ordinary, but you do not need to launch the browser and configure the driver inside the test - everything has already been done.  An example of a simple specification (we assume that the HomePage, LoginPage classes are already described by us): <br><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@Stepwise</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreSpec</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GebReportingSpec</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unauthorized</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goes</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page</span></span></span><span class="hljs-function">"</span></span>() { when: to <span class="hljs-type"><span class="hljs-type">HomePage</span></span> then: at <span class="hljs-type"><span class="hljs-type">LoginPage</span></span> } }</code> </pre><br>  Each method inside the specification is a separate test.  At first, this test tries to enter the main page, but since the user is not authorized, he should end up with LoginPage. <br><br>  Of course, there are Geb configuration files that define: <br><ul><li>  Which browser to use and with which driver </li><li>  Various Geb settings (such as timeout). </li></ul>  In the demo, there is an example of a <a href="https://github.com/geb/geb-example-grails/blob/master/test/functional/GebConfig.groovy">GebConfig.groovy</a> file. <br><br>  It seems to be enough.  We collect: <br><br><pre> <code class="hljs mel">grails -Dgeb.<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>=firefox test-app :spock</code> </pre><br>  and see how our robot is trying to test something there. <br><br>  It quickly turns out that our tests do not work on Chrome and IE.  The reason is that it is really possible to launch either HtmlUnit (which is useless for testing) or Firefox from scratch and without any available tools.  For Firefox, a new profile is automatically created that ‚Äúexpands‚Äù the browser for later management via FirefoxDriver.  Yes, Selenium / Geb works great on Firefox, because it was originally designed for Firefox. <br><br>  As for IE and Chrome, everything is a bit more complicated with them.  The general situation can be understood from the table: <br><table><tbody><tr><th>  Browser </th><th>  What is required </th><th>  Restrictions </th></tr><tr><td><img src="http://habrastorage.org/storage2/e5a/0fb/a86/e5a0fba86b86b85f91089c1e6e82f914.png" width="16" height="16" alt="firefox">  Firefox </td><td>  - </td><td>  Under some OS is subject to the <a href="http://code.google.com/p/selenium/wiki/ScalingWebDriver">problem of exhaustion of TCP ports</a> . </td></tr><tr><td><img src="http://habrastorage.org/storage2/512/78c/df8/51278cdf8c65d918061c504af043b6c3.png">  Chrome </td><td>  You will need to download and install a separate platform-dependent service (ChromeDriverService). </td><td>  There is no support for <code>Actions</code> . </td></tr><tr><td><img src="http://habrastorage.org/storage2/51e/cf0/390/51ecf039035426e4aa0c0aa764545876.png">  Opera </td><td>  - </td><td>  Not lower than version 11.5, only one instance of the browser at a time. </td></tr><tr><td><img src="http://habrastorage.org/storage2/f18/6b2/a86/f186b2a864dd223907f3f2218ebcdb12.png">  Internet Explorer </td><td>  Requires the launch of a separate service.  Requires browser pre-settings (Protection Mode). </td><td>  Versions 6,7,8,9.  Supports exactly one instance of the browser. </td></tr></tbody></table>  As you can see, the Chrome driver does not support Actions!  Which is pretty unpleasant. <br><br>  What else officially supports Selenium (and, therefore, Geb)? <br><ul><li>  IPhone Browser </li><li>  Android Browser </li></ul><br><h2>  Whether to write browser tests? </h2><br>  The beauty of browser tests in the guaranteed behavior on a specific browser. <br><br>  However, browser tests: <br><ul><li>  They work slowly (much slower than any unit test) - simply due to the fact that the browser‚Äôs response rate is limited; </li><li>  When testing complex JavaScript / AJAX-stuffing - difficult to write; </li><li>  Require support.  Any change to CSS classes and page hierarchy can break tests.  And, as a rule, the number of such small visual changes greatly exceeds the number of changes, for example, in the database schema or business logic. </li></ul>  The simplest formula describing the need to write automated tests might look like this: <br><br><img src="http://habrastorage.org/storage2/fc0/564/5b2/fc05645b237817cafbbca21fc136b8b0.png"><br><br>  The formula is beautiful, but rather meaningless, as it is very difficult to estimate the complexity of the support and the cost of manual testing the iteration in advance.  But it is clear that with an increase in the number of iterations, the idea to automate testing will occur to you more and more often.  At a low speed of execution of browser tests, you can not pay much attention - it's still faster than performing manual testing.  True, the formula does not take into account the fact that not all manual work can be automated - try, say, to explain to the robot what it means to ‚Äúgo to the layout‚Äù. <br><br>  There are also subtleties in browser testing.  For example, Selenium is not always able to independently determine whether a website that has been accessed by the browser is accessible at all.  Indeed, in the case of, say, cutting down the Internet, the browser seems to be showing <em>something</em> .  But this is not your expected page, but the internal message of the browser in the ‚Äúcheck your Internet settings‚Äù style.  All these situations you will have to define and include in the test package.  In addition, sometimes you have to adapt the application for automatic tests, making some compromises. <br><br>  In general, this may sound strange, but an automatic test is a program.  Therefore, sometimes its development and support can be entrusted to programmers.  This approach eliminates the strict division of labor between the programmer and the tester.  As part of an established system for assembling and testing, the part applies the principle of ‚Äúhe himself broke the test himself and the order‚Äù.  That is, roughly speaking, it does not matter who wrote the test - from the moment of its creation it becomes common property and both testers and programmers are responsible for the test. <br><br>  We should also mention the so-called recording - the ability to record your actions in the browser and create tests on their basis.  This feature is provided by Selenium IDE in Firefox.  It sounds great, but tests created in this way usually have low <em>stability</em> , that is, the likelihood of them breaking due to some kind of page change is very high.  This happens because recording does not know how to properly address the blocks of the page with which you interact - whether you need to use CSS classes, #id or some other methods.  In addition, the logic (stuffing) of the Selenium tests for you still can not come up with. <br><br>  I summarize: Geb is a pleasant to use and quite working product (we don‚Äôt really pay attention to the version number, for the stability of Geb is provided by Selenium), which is quite suitable for writing browser tests for Grails applications.  Leaving you alone with him: <a href="http://gebish.org/">http://gebish.org</a> . </div><p>Source: <a href="https://habr.com/ru/post/139233/">https://habr.com/ru/post/139233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139223/index.html">Windows Server 8 Beta</a></li>
<li><a href="../139224/index.html">In Russia, WP-smartphones are becoming more popular iPhone</a></li>
<li><a href="../139225/index.html">How are your data security at NASA?</a></li>
<li><a href="../139226/index.html">MIDI and OSC - the main protocols for the interaction of musical applications</a></li>
<li><a href="../139232/index.html">Programming Championship VK Cup 2012</a></li>
<li><a href="../139237/index.html">Learning English and the good old CMD</a></li>
<li><a href="../139239/index.html">Php 5.4 is finally out</a></li>
<li><a href="../139240/index.html">Ringmark: Mobile Browser Test Suite</a></li>
<li><a href="../139242/index.html">Added cost of living</a></li>
<li><a href="../139244/index.html">Electronic Tax Return in Estonia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>