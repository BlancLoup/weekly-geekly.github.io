<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convert React to Angular using a universal abstract tree. Proof of concept</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Good day, my name is Vladimir Milenko, I am a Frontend-developer in the company Lightspeed, and today we will talk about the problem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convert React to Angular using a universal abstract tree. Proof of concept</h1><div class="post__text post__text-html js-mediator-article"><h1 id="vstuplenie">  Introduction </h1><br><p>  Good day, my name is Vladimir Milenko, I am a Frontend-developer in the company Lightspeed, and today we will talk about the problem of the absence of components in a particular framework and attempts to automatically convert them. </p><br><h1 id="predystoriya">  Prehistory </h1><br><p>  Historically, both in eCommerce and in Retail products for admin panels we use React.JS as the main framework, but the platform for restaurants uses Angular, which prevents them from using our component library.  Before my release, this problem became more acute, due to the need to bring UI / UX to one type.  I decided to conduct a small study on the migration of components, make a Proof of Concept and share sensations.  This will be the post. </p><a name="habracut"></a><br><h1 id="nemnogo-teorii">  Some theory </h1><br><p>  To understand the rest, you need to know the following notation: </p><br><p>  AST is an abstract syntax tree, it is a representation of code in the form of a tree, there are no brackets, etc.  An example of frequent use of AST is babel, it builds AST using parsers, and then leaves are transpiled with the types introduced in es6 - into es5-supported. </p><br><p>  <a href="https://ru.m.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">https://ru.m.wikipedia.org/wiki/Abstract_syntax_tree</a> </p><br><h1 id="podhod-k-resheniyu-problemy">  Problem solving approach </h1><br><p>  The first thing that came to mind was of course to convert directly from React to Angular, then thinking well (and this does not always work on vacation), this idea was completely rejected due to the lack of opportunities for direct conversion without an intermediate tree. </p><br><p>  A good idea is a universal tree with more abstraction, more top-level, if you can say so.  The main idea was to translate complex structures into more abstract ones, about examples a little later. </p><br><p>  The process will look something like this: </p><br><ol><li>  Parsing js to AST </li><li>  Parse syntax parsing </li><li>  UST (universal abstract tree) generation based on the obtained top-level constructions </li><li>  TypeScript AST + Angular Template html generation from UST </li></ol><br><p>  The basic principles on which the world works (cross out) is a parser.  I came to the conclusion that the best thing is to build the whole thing on matchers and predicates. </p><br><p>  For the theoretical work of the parser, we need to describe the matcher function and the parser function, but we also add the desired type of input node to limit the list of matchers in which we will check the current node (not for the sake of optimization, but convenience). </p><br><p> Matcher returns <code>true/false</code> depending on the node passed to it.  It does checks on the node, whether it is the parser that is needed or not. </p><br><p>  If the matcher returns <code>true</code> , we will call the parsing function already.  The parser function should return a UST node ‚Äî an abstract description of what happened in the AST node being parsed. </p><br><p>  The basic concept of parsing is that each parser should be able to trigger a parsing node without affecting the resultant tree.  This will come in handy for us both in matching and in parsing, since we will generate children and sometimes make a start from children. </p><br><h1 id="parsing-vhodnyh-parametrov-komponenta">  Parsing component input parameters </h1><br><p>  Perhaps this is one of the most interesting tasks.  As we all know, a React component can take parameters from a variety of places: <code>state, props, context, outer scope</code> . </p><br><p>  At the PoC stage, we consider only <code>props</code> , and even only in a certain design, but more on that later. </p><br><p>  So, in AST there is no tracking variable, i.e.  when looking at a particular node, you will see the <code>Identifier</code> , but this will not give you the slightest idea where this variable came from. </p><br><p>  AST-traversal will come to the rescue, which will prompt the current scope of a particular node. </p><br><p>  We will consider the following parameter as the input parameter of the component: </p><br><p> <code>const {a} = this.props;</code> </p> <br><p>  In other words, we will search for <code>VariableDeclaration</code> , where <code>id</code> is <code>ObjectPattern</code> , and <code>init</code> is <code>MemberExpression</code> , with <code>property</code> - necessarily <code>'props'</code> . </p><br><h1 id="ot-teorii-k-praktike">  From theory to practice </h1><br><p>  Used tools: </p><br><ol><li>  Parsing AST - <code>babylon</code> </li><li>  Determination of types of nodes AST - <code>babel-types</code> </li><li>  Tree <code>babel-traverse</code> - <code>babel-traverse</code> </li><li>  Generate Angular Pseudo-Templates - <code>parse5</code> </li></ol><br><p>  Parsing Parsing Interface: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ParserPredicate</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">matchingType</span></span>:string; <span class="hljs-attribute"><span class="hljs-attribute">isMatching</span></span>: (token:any) =&gt; boolean; <span class="hljs-attribute"><span class="hljs-attribute">parse</span></span>: (token:any) =&gt; any; }</code> </pre> <br><p>  Well, immediately an example of implementation: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSXExpressionMap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParserPredicate</span></span></span><span class="hljs-class"> </span></span>{ matchingType = <span class="hljs-string"><span class="hljs-string">'JSXExpressionContainer'</span></span>; parse(token: JSXExpressionContainer): any { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expression = token.expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CallExpression; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callee = expression.callee <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseObject = (callee.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Identifier).name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrowExpression = expression.arguments[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ArrowFunctionExpression; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderOutput = resolverRegistry.resolve(arrowExpression.body); let baseItem = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBaseObjectName(callee); let newBaseItem = resolveVariable(token, baseItem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { type: <span class="hljs-string"><span class="hljs-string">'ForLoop'</span></span>, baseItem: { type: <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>, name: newBaseItem }, arguments: arrowExpression.params, children: renderOutput, mutations: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMutations(callee) } } getBaseObjectName(callee: MemberExpression) { let temp = callee; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isIdentifier(temp.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)) { temp = temp.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.callee; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (temp.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Identifier).name; } getMutations(callee: MemberExpression) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isCallExpression(callee.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [callee]; } isMatching(token: JSXExpressionContainer): boolean { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isCallExpression(token.expression)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expression = token.expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CallExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isMemberExpression(expression.callee)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callee = expression.callee <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isIdentifier(callee.property)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnToBeCalled = (callee.property <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Identifier).name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fnToBeCalled === <span class="hljs-string"><span class="hljs-string">'map'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Based on the code above, it will become clear that this predicate is waiting at the input of JSXExpressionContainer, then various checks follow to determine whether this parser is really needed for the input node. <br>  This predicate will work on the following JSX construction: </p><br><pre> <code class="hljs javascript">{ items.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">=&gt;</span></span>(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{x}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>) }</code> </pre> <br><h2 id="parsing">  Parsing </h2><br><p>  The parsing function parses the construct into pieces, it also allows you to find the mutations of the original parameter, </p><br><pre> <code class="hljs javascript">{ items.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">=&gt;</span></span>x&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">=&gt;</span></span>x&gt;<span class="hljs-number"><span class="hljs-number">10</span></span>).map<span class="hljs-comment"><span class="hljs-comment">//etc }</span></span></code> </pre> <br><p>  Next comes the process of defining a variable, the function resolveVariable is responsible for this.  It serves to determine the scope and search for the definition of this variable: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resolveVariable = (token:any, identifier:string) =&gt; { let newIdentifier = identifier; traverse(resolverRegistry.ast, { enter: (path) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.node !== token) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.scope.bindings[identifier]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binding = path.scope.bindings[identifier]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> declaratorNode = binding.path.node <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VariableDeclarator; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObjectPattern(declaratorNode.id) &amp;&amp; isMemberExpression(declaratorNode.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> = declaratorNode.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThisExpression(<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) &amp;&amp; isIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>.property)) { newIdentifier = resolverRegistry.registerVariable(identifier, <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>.property.name === <span class="hljs-string"><span class="hljs-string">'props'</span></span> ? <span class="hljs-string"><span class="hljs-string">'Input'</span></span> : <span class="hljs-string"><span class="hljs-string">'Local'</span></span>); } } } } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newIdentifier; };</code> </pre> <br><p>  In this code, we are fixedly looking for <code>const {varName} = this.props</code> .  Since this is a PoC, this is quite enough.  This function returns a uuid with a variable identifier to the process of building the template and the AST class of the component. </p><br><p>  At the exit of the parser, we get a UST-node, with the type <code>ForLoop</code> . </p><br><h1 id="generaciya-shablona-i-klassa-novogo-komponenta">  Generating a template and class of a new component </h1><br><p>  In this case, we are starting to use <code>parse5</code> and <code>babel-types</code> .  Generators work on the principle of matchers, but without a predicate, in this case the generator is responsible for the complete generation of a particular type. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForLoopGenerator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Generator</span></span></span><span class="hljs-class"> </span></span>{ matchingType = <span class="hljs-string"><span class="hljs-string">'ForLoop'</span></span>; generate(node: any):any { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> children = node.children; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attrs:<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;any&gt; = getAttributes(children.attributes.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x:any</span></span></span><span class="hljs-function">)=&gt;</span></span>x.name !== <span class="hljs-string"><span class="hljs-string">'key'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> originalName = resolverRegistry.vars.get(node.baseItem.name); attrs.push({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>:<span class="hljs-string"><span class="hljs-string">'*ngFor'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">`let </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${node.</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].name}</span></span></span><span class="hljs-string"> of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${originalName &amp;&amp; originalName.name}</span></span></span><span class="hljs-string">`</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> htmlNode = { <span class="hljs-attr"><span class="hljs-attr">tagName</span></span>:children.identifier.value, <span class="hljs-attr"><span class="hljs-attr">nodeName</span></span>:children.identifier.value, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: attrs, <span class="hljs-attr"><span class="hljs-attr">childNodes</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;any&gt;<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">, }; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">keyAttribute</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attributes</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x:any</span></span></span><span class="hljs-function">) =&gt;</span></span> x.name === <span class="hljs-string"><span class="hljs-string">'key'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyAttribute) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMemberExpression(keyAttribute.value)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {value} = keyAttribute; key = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value.object.name}</span></span></span><span class="hljs-string">.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value.property.name}</span></span></span><span class="hljs-string">`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> children.children) { htmlNode.childNodes.push(angularGenerator.generate(child)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> htmlNode; } }</code> </pre> <br><p>  Next, the resulting html nodes will be converted to html using <code>parse5</code> . </p><br><h2 id="generaciya-klassa-komponenta">  Generate component class </h2><br><p>  At the moment, the class generator works very simply, it collects the input parameters from the variables and adds them to the class. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AngularComponentGenerator</span></span></span><span class="hljs-class"> </span></span>{ generateInputProps():<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> declarations:<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;any&gt; = []; resolverRegistry.vars.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, key, map1</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (value.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'Input'</span></span>: declarations.push( b.classProperty( b.identifier(value.name), <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, [ b.decorator(b.identifier(<span class="hljs-string"><span class="hljs-string">'Input'</span></span>)) ] ) ); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> declarations; } generate() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> src = b.file( b.program( [ b.exportNamedDeclaration( b.classDeclaration(b.identifier(<span class="hljs-string"><span class="hljs-string">'MyComponent'</span></span>), <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, b.classBody( [ ...this.generateInputProps(), ] ), [ b.decorator(b.callExpression( b.identifier(<span class="hljs-string"><span class="hljs-string">'Component'</span></span>), [ b.objectExpression( [ b.objectProperty(b.identifier(<span class="hljs-string"><span class="hljs-string">'selector'</span></span>),b.stringLiteral(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>),<span class="hljs-literal"><span class="hljs-literal">false</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>,[]), b.objectProperty(b.identifier(<span class="hljs-string"><span class="hljs-string">'templateUrl'</span></span>),b.stringLiteral(<span class="hljs-string"><span class="hljs-string">'./my-component.component.html'</span></span>),<span class="hljs-literal"><span class="hljs-literal">false</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>,[]), ] ) ] )) ]), [], <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, ) ] )); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> generator(src).code; } }</code> </pre> <br><h1 id="rezultaty-i-vyvody">  Results and conclusions </h1><br><p>  At the input component: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {a} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {b} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"asd"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Title</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { a } { b } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { a.map(asd =&gt; (</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{asd.key}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{asd}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">text</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">asd</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">text</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)) } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { children } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">And here we go</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>) } }</code> </pre> <br><p>  It turns out this pattern: </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"asd"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Title</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{a}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{b}}</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let asd of a"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{asd}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">text</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">asd</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">text</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-content</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-content</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">And here we go</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  And this class: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, templateUrl: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./my-component.component.html"</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> a; <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> b; }</code> </pre> <br><h2 id="obschie-vyvody">  General conclusions </h2><br><ol><li>  At the moment there is a feeling that the converter is possible </li><li>  We need a static predicate analyzer to prevent intersections </li><li>  A lot of work </li></ol><br><p>  Thanks for attention. </p><br><p>  Link to the <a href="https://github.com/VladimirMilenko/angular-react-converter">repository</a> where the work is going.  There are still a lot of crutches, but this is a PoC, so it can be. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350772/">https://habr.com/ru/post/350772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350758/index.html">For a beginner webmaster: make a one-page on Bootstrap 4 for half an hour</a></li>
<li><a href="../350760/index.html">Protection of ASP.NET applications from hacking</a></li>
<li><a href="../350762/index.html">Introducing "npm ci" for faster and more reliable builds.</a></li>
<li><a href="../350764/index.html">Expanding the capabilities of CleanTalk Anti-Spam</a></li>
<li><a href="../350768/index.html">DigiCert revokes 23 thousand SSL certificates: what is the reason</a></li>
<li><a href="../350774/index.html">Java 9 - Have you switched? Not? Do not need ...!?</a></li>
<li><a href="../350776/index.html">Is it easy to speak at a conference for the first time?</a></li>
<li><a href="../350778/index.html">How do you work with Laravel?</a></li>
<li><a href="../350780/index.html">Thin diskless client based on Ubuntu that does not require mounting the file system over the network</a></li>
<li><a href="../350782/index.html">Learn OpenGL. Lesson 4.9 - Geometric Shader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>