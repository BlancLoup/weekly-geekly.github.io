<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another Monad Guide (part 3: Monad Laws)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By mike vanier 

 In the last article, I talked about two fundamental monadic operations of the Monad type class: the binding operator (bind, >> = ) a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another Monad Guide (part 3: Monad Laws)</h1><div class="post__text post__text-html js-mediator-article">  By mike vanier <br><br>  In the last article, I talked about two fundamental monadic operations of the <font color="blue">Monad</font> type class: the binding operator (bind, <font color="blue">&gt;&gt; =</font> ) and the <font color="blue">return</font> function.  In this article I‚Äôll finish with the definition of the <font color="blue">Monad</font> type class and talk about monad laws. <br><a name="habracut"></a><br><h4>  Full <font color="blue">Monad</font> Type Class </h4><br>  Let's take a look at the whole definition of the <font color="blue">Monad</font> type class: <br><br><blockquote>  <font>class</font> <font color="#cccc00">Monad</font> m <font>where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> m b <font>)</font> <font color="#339933">-&gt;</font> m b <br>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m a <br>  <font>(</font> <font color="#339933">&gt;&gt;</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> m b <font color="#339933">-&gt;</font> m b <br>  <font>fail</font> <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> m a </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We see the familiar: <font color="blue">&gt;&gt; =</font> operator and the <font color="blue">return</font> function with the same types, but besides them there is also the <font color="blue">&gt;&gt;</font> operator and the <font color="blue">fail</font> function.  What do they mean? <br><br>  The <font color="blue">fail</font> function is initially a very primitive way of reporting an error.  It is called when the operator <font color="blue">&gt;&gt; =</font> cannot bind a value of type <font color="blue">a</font> and a function of type <font color="blue">a -&gt; mb</font> due to matching errors.  I don‚Äôt want to go into the details of this mechanism right now because it‚Äôs boring;  see <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">the</a> Haskell <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">documentation</a> if you need it.  In most cases, do not worry about <font color="blue">fail</font> . <br><br>  Operator <font color="blue">&gt;&gt; a</font> little more interesting.  He has this type: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt;</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> m b <font color="#339933">-&gt;</font> m b </blockquote><br><br>  This operator is a monadic sequence operator.  In particular, it is a variant of monadic application ( <font color="blue">&gt;&gt; =</font> or ‚Äúbind‚Äù), which discards an unpacked value of type <font color="blue">a</font> before performing an ‚Äúaction‚Äù of type <font color="blue">mb</font> .  It is defined as follows: <br><br><blockquote>  mv1 <font color="#339933">&gt;&gt;</font> mv2 <font color="#339933">=</font> mv1 <font color="#339933">&gt;&gt; =</font> <font>(</font> \ <font color="#339933">_</font> <font color="#339933">-&gt;</font> mv2 <font>)</font> </blockquote><br><br>  We can see here that any value unpacked from the monadic value <font color="blue">mv1</font> is rejected, and then the final monadic value <font color="blue">mv2 is returned</font> .  The operator is useful when the type of the unpacked value is <font color="blue">()</font> , that is, is an empty type.  A good example is the <font color="blue">putStrLn</font> function: <br><br><blockquote>  <font>putStrLn</font> <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br>  Imagine that you want to print two lines, one after another, with end-of-line characters after each.  It is possible to <br><br><blockquote>  <font>putStrLn</font> <font>"This is string 1."</font>  <font color="#339933">&gt;&gt;</font> <font>putStrLn</font> <font>"This is string 2."</font> </blockquote><br><br>  And why does this work?  Let's look at the types: <br><br><blockquote>  <font>(</font> <font>putStrLn</font> <font>"This is string 1."</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font>putStrLn</font> <font>"This is string 2."</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br>  That is, the operator <font color="blue">&gt;&gt;</font> combines two monadic values ‚Äã‚Äãof type <font color="blue">IO ()</font> into one resulting monadic value of type <font color="blue">IO ()</font> .  Let's take the operator <font color="blue">&gt;&gt;</font> and specialize it for our case: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt;</font> <font>)</font> <font color="#339933">::</font> m a <font color="#339933">-&gt;</font> m b <font color="#339933">-&gt;</font> m b </blockquote><br><br>  If <font color="blue">m</font> is <font color="blue">IO</font> , and <font color="blue">a</font> , and <font color="blue">b</font> - <font color="blue">()</font> , we get: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt;</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br>  According to the record, we can say that the operator <font color="blue">&gt;&gt;</font> probably performs two ‚Äúactions‚Äù in a row - printing a string. <br><br>  Now a more complex example.  We need to read a line of text from the terminal and print it twice.  We can do it like this: <br><br><blockquote>  readAndPrintLineTwice <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  readAndPrintLineTwice <font color="#339933">=</font> <font>getLine</font> <font color="#339933">&gt;&gt; =</font> <font>(</font> \ s <font color="#339933">-&gt;</font> <font>(</font> <font>putStrLn</font> s <font color="#339933">&gt;&gt;</font> <font>putStrLn</font> s <font>)</font> <font>)</font> </blockquote><br><br>  Due to operator priorities, the record can be left without brackets: <br><br><blockquote>  readAndPrintLineTwice <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  readAndPrintLineTwice <font color="#339933">=</font> <font>getLine</font> <font color="#339933">&gt;&gt; =</font> \ s <font color="#339933">-&gt;</font> <font>putStrLn</font> s <font color="#339933">&gt;&gt;</font> <font>putStrLn</font> s </blockquote><br><br>  So what does this mean?  <font color="blue">getLine</font> is a monadic value (‚Äúaction‚Äù) that reads a line of text from the terminal.  The <font color="blue">&gt;&gt; =</font> operator "unpacks" this string from a monadic value and connects it with the name <font color="blue">s</font> (because <font color="blue">\ s -&gt; putStrLn s &gt;&gt; putStrLn s</font> is a monadic function, the second argument of the <font color="blue">&gt;&gt; =</font> operator).  Then the string, called <font color="blue">s</font> , is used by the monadic value <font color="blue">putStrLn s &gt;&gt; putStrLn s</font> , which it prints out two consecutive times. <br><br>  If this seems mysterious to you, it is not your fault.  Something strange is happening here, in the depths, but as long as I have not talked about the monad of the state, I cannot explain it.  But now you must be able to trace <i>what is</i> happening, even if you still do not fully understand <i>how</i> it is happening. <br><br>  Right now, I'm going to go back a little and look at the monad laws.  They play a large role in the use of the <font color="blue">&gt;&gt; =</font> operator and the <font color="blue">return</font> function for each specific monad.  After that we turn to more practical materials. <br><br><h4>  Three Laws of Monadality </h4><br>  Many important laws go in groups of three: three mechanical laws of Newton, three laws of thermodynamics, Three Laws of Asimov Robotics, three Keplerian laws of planetary motion, and so on and so forth.  The monads are no different in this, well, of course, except that the ‚ÄúThree Monad Laws‚Äù is more important than anything else.  ;-) <br><br>  For the <font color="blue">&gt;&gt; =</font> operator and the <font color="blue">return</font> function to be correct for a particular monad, they must have the correct types of this monad.  So, for example, the definitions <font color="blue">&gt;&gt; =</font> and return for the <font color="blue">Maybe</font> monad contain its type: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">Maybe</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> b <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> b <br>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">Maybe</font> a </blockquote><br><br>  And for <font color="blue">IO</font> monads contain type <font color="blue">IO</font> : <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b <br>  <font>return</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b </blockquote><br><br>  However, this is not enough.  These functions / operators are also required to satisfy three ‚Äúmonad laws‚Äù.  Monadic laws are actually very simple;  they are designed to ensure that the monadic composition will work in a predictable way.  First I will give you a ‚Äúnice‚Äù version of the monad laws, and then I will show the (ugly) way as they are usually described.  (Tell me, thank you: the ‚Äúnice‚Äù option is much easier to understand.) <br><br><h5>  Nice version </h5><br>  Here is a pleasant definition of three monad laws expressed in terms of a monadic composition (remember that the operator <font color="blue">(&gt; =&gt;)</font> is a monadic operator of composition of functions): <br><br><blockquote>  1 <font color="#339933">.</font>  <font>return</font> <font color="#339933">&gt; =&gt;</font> f <font color="#339933">==</font> f <br>  2  f <font color="#339933">&gt; =&gt;</font> <font>return</font> <font color="#339933">==</font> f <br>  3  <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> <font color="#339933">&gt; =&gt;</font> h <font color="#339933">==</font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> </blockquote><br><br>  What do these laws tell us? <br><br>  Laws 1 and 2 say what a <font color="blue">return</font> should be: it is a unit (neutral element) for a monadic composition of functions (the first rule states that return is a left unit, and the second rule is a right one).  In other words, the composition of the monadic function <font color="blue">f</font> and <font color="blue">return</font> (in any order) simply returns the function <font color="blue">f</font> .  Analogues can be considered 0 - the neutral element for the addition function of integers, and 1 - the neutral element for the integer multiplication function;  in each case, the neutral element connected to the normal value with the help of the corresponding function simply returns this value back. <br><br>  Law 3 states that the monadic function of composition is associative: when we want to combine three monadic functions ( <font color="blue">f</font> , <font color="blue">g</font> , <font color="blue">h</font> ), it does not matter which two we connect first.  This is analogous to the fact that addition and multiplication are also associative when applied to integers. <br><br>  Do not these laws seem vaguely familiar to you?  Take a look at the relevant "laws", which satisfies the usual function of the composition: <br><br><blockquote>  1 <font color="#339933">.</font>  <font>id</font>  f <font color="#339933">==</font> f <br>  2  f <font color="#339933">.</font>  <font>id</font> <font color="#339933">==</font> f <br>  3  <font>(</font> f <font color="#339933">.</font> g <font>)</font> <font color="#339933">.</font>  h <font color="#339933">==</font> f <font color="#339933">.</font>  <font>(</font> g <font color="#339933">.</font> h <font>)</font> </blockquote><br><br>  where <font color="blue">id</font> is a neutral element, one.  Got a resemblance?  Composition of a function with a unit on the left or on the right will again give the same function, and the function of the composition is associative.  The monadic function of the composition must be associative, and <font color="blue">return</font> must be the monadic equivalent of a single function, so that the behavior of the monadic composition is as predictable as the behavior of a regular composition. <br><br>  What is the significance of these laws in terms of the programmer?  Since we want our monads to behave intelligently, our definitions of <font color="blue">return</font> and <font color="blue">&gt;&gt; =</font> must satisfy these laws.  We will soon find out how to check the correctness of the definitions <font color="blue">&gt;&gt; =</font> and <font color="blue">return</font> .  [Note that monad laws are expressed in terms of the <font color="blue">&gt; =&gt;</font> operator, not the <font color="blue">&gt;&gt; =</font> operator, but we will see a version using <font color="blue">&gt;&gt; =</font> , - it is equivalent.] <br><br>  <i>However</i> , there is a catch: Haskell <i>does not</i> check for monad laws!  The only thing that is checked is that the definition types <font color="blue">return</font> and <font color="blue">&gt;&gt; =</font> are correct.  Whether the laws are enforced or not, the programmer must verify. <br><br>  Many people ask: ‚ÄúWhy Haskell <i>cannot</i> verify the monad laws?‚Äù The answer is simple: Haskell is not powerful enough yet!  In order to get a sufficiently powerful language that would prove the correctness of monad laws, you need something like a theorem prover (teorem prover).  Proofs of theorems capture the imagination, and they, perhaps, are the future of programming, but they are much more complicated than traditional programming languages.  If you are interested, there is a respected proof of the Coq theorem, it is available <a href="http://coq.inria.fr/">here</a> .  But in Haskell, the programmer himself must take care that the monad he wrote does not violate the monad laws. <br><br><h5>  Ugly version </h5><br>  The problem with the nice version is that the <font color="blue">&gt; =&gt;</font> operator is not defined directly in the <font color="blue">Monad</font> type class;  instead, the <font color="blue">&gt;&gt; =</font> operator is defined, and the <font color="blue">&gt; =&gt;</font> operator is derived from it, as I showed above.  So if we restrict definitions to operators <font color="blue">&gt;&gt; =</font> and <font color="blue">return</font> , we need monadic laws containing only <font color="blue">return</font> and <font color="blue">&gt;&gt; =</font> .  And in this form, they are presented in most books and documentation on monads in Haskell, despite the lower intuitiveness than shown in the previous section. <br><br>  In terms of the <font color="blue">&gt;&gt; =</font> operator and <font color="blue">return</font> functions, monadic laws look like this: <br><br><blockquote>  1 <font color="#339933">.</font>  <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <font color="#339933">==</font> f x <br>  2  mv <font color="#339933">&gt;&gt; =</font> <font>return</font> <font color="#339933">==</font> mv <br>  3  <font>(</font> mv <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#339933">==</font> mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> </blockquote><br><br>  where the types of different values ‚Äã‚Äãare: <br><br><blockquote>  mv <font color="#339933">::</font> m a <br>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> m c </blockquote><br><br>  for some types <font color="blue">a</font> , <font color="blue">b</font> , <font color="blue">c</font> and some monad <font color="blue">m</font> . <br><br><h5>  Derive the ugly version of the monad laws from the pleasant version </h5><br>  Let's have fun and try to get the ugly version of the monad laws out of the nice version.  In our calculations, we will need a definition of a monadic composition, which we have analyzed above: <br><br><blockquote>  f <font color="#339933">&gt; =&gt;</font> g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> </blockquote><br><br>  Act 1: <br><br><blockquote>  <font>return</font> <font color="#339933">&gt; =&gt;</font> f <font color="#339933">==</font> f <br>  \ x <font color="#339933">-&gt;</font> <font>(</font> <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">==</font> \ x <font color="#339933">-&gt;</font> f x <br>  <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <font color="#339933">==</font> f x <font color="#5d478b">- QED ("What was required to prove")</font> </blockquote><br><br>  Note that <font color="blue">\ x -&gt; fx is</font> the same as just <font color="blue">f</font> . <br><br>  Act 2: <br><br>  f&gt; =&gt; return == f <br>  \ x -&gt; (fx &gt;&gt; = return) == \ x -&gt; fx <br>  fx &gt;&gt; = return == fx <br>  let mv == fx <br>  mv &gt;&gt; = return == mv - QED <br><br>  Act 3: <br><br><blockquote> <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> <font color="#339933">&gt; =&gt;</font> h <font color="#339933">==</font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> <br>  \ x <font color="#339933">-&gt;</font> <font>(</font> <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> x <font color="#339933">&gt;&gt; =</font> h <font>)</font> <font color="#339933">==</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> <font>)</font> <br>  <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> x <font color="#339933">&gt;&gt; =</font> h <font color="#339933">==</font> f x <font color="#339933">&gt;&gt; =</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> <br>  <font>(</font> \ y <font color="#339933">-&gt;</font> <font>(</font> f y <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> x <font color="#339933">&gt;&gt; =</font> h <font color="#339933">==</font> f x <font color="#339933">&gt;&gt; =</font> <font>(</font> \ y <font color="#339933">-&gt;</font> <font>(</font> g y <font color="#339933">&gt;&gt; =</font> h <font>)</font> <font>)</font> <br>  <font color="#5d478b">- Calculate (\ y -&gt; (f y &gt;&gt; = g)) x we ‚Äã‚Äãget: (f x &gt;&gt; = g)</font> <br>  <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font color="#339933">&gt;&gt; =</font> h <font color="#339933">==</font> f x <font color="#339933">&gt;&gt; =</font> <font>(</font> \ y <font color="#339933">-&gt;</font> <font>(</font> g y <font color="#339933">&gt;&gt; =</font> h <font>)</font> <font>)</font> <br>  <font color="#5d478b">- Let mv = f x, then:</font> <br>  <font>(</font> mv <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font color="#339933">&gt;&gt; =</font> h <font color="#339933">==</font> mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ y <font color="#339933">-&gt;</font> <font>(</font> g y <font color="#339933">&gt;&gt; =</font> h <font>)</font> <font>)</font> <br>  <font color="#5d478b">- Replace g with f, h with g:</font> <br>  <font>(</font> mv <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#339933">==</font> mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ y <font color="#339933">-&gt;</font> <font>(</font> f y <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> <br>  <font color="#5d478b">- Replace y with x in the right expression and we get:</font> <br>  <font>(</font> mv <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#339933">==</font> mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> <font color="#5d478b">- QED</font> </blockquote><br><br>  At the calculation step <font color="blue">(\ y -&gt; (fy &gt;&gt; = g)) x,</font> we simply apply the entire function ( <font color="blue">\ y -&gt; ...</font> ) to the argument <font color="blue">x</font> ;  at the same time, <font color="blue">y</font> is replaced by the variable <font color="blue">x</font> in the function body (it is indicated by ellipsis (...)), and the function body is returned as a result.  In the functional programming language Lingo, this operation is called <i>beta reduction</i> .  {1: In this case, we are talking about the section of mathematics called lambda calculus, which describes, among other things, beta-reduction.} Beta-reduction is the main way to calculate functions.  The last step, where <font color="blue">y</font> is replaced by <font color="blue">x</font> , is correct because, why the following two functions: <br><br><blockquote>  \ x <font color="#339933">-&gt;</font> f x <br>  \ y <font color="#339933">-&gt;</font> f y </blockquote><br><br>  Is the same thing (the name of the formal argument does not matter).  In the functional language Lingo, we would say that the two functions are <i>alpha equivalent</i> .  Other steps you must have understood. <br><br><h5>  What is the idea? </h5><br>  Monad laws can sometimes be used in code, replacing a long expression with a shorter one (for example, instead of <font color="blue">return x &gt;&gt; = f,</font> you can simply write <font color="blue">fx</font> ).  However, we will show in the following articles that the main use of monad laws is that they allow the derivation of <font color="blue">return</font> and <font color="blue">&gt;&gt; =</font> definitions for specific monads. <br><br>  At the end of this article I want to show you the neat syntactic form of a record, with which monadic code looks much nicer. <br><br><h4>  <font color="blue">Do-</font> abstract </h4><br><br>  Recall the <font color="blue">readAndPrintLineTwice</font> function defined above: <br><br><blockquote>  readAndPrintLineTwice <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  readAndPrintLineTwice <font color="#339933">=</font> <font>getLine</font> <font color="#339933">&gt;&gt; =</font> \ s <font color="#339933">-&gt;</font> <font>putStrLn</font> s <font color="#339933">&gt;&gt;</font> <font>putStrLn</font> s </blockquote><br><br>  It has one virtue: it is written in one line.  The disadvantage is not the most readable line in the world.  The designers of the Haskell language have noticed that monadic definitions are often difficult to read, and have come up with a really nice syntactic sugar, with which the definitions are more readable. <br><br>  This syntactic sugar is based on the observation that a huge number of operations in monadic code are recorded in two forms: <br><br><blockquote>  <font color="#5d478b">- Form 1.</font> <br>  <font color="#5d478b">- mv :: m a</font> <br>  <font color="#5d478b">- f :: a -&gt; m b</font> <br><br>  mv <font color="#339933">&gt;&gt; =</font> \ x <font color="#339933">-&gt;</font> mf x <br><br>  <font color="#5d478b">- Form 2.</font> <br>  <font color="#5d478b">- mv :: m a</font> <br>  <font color="#5d478b">- mv2 :: m b</font> <br><br>  mv <font color="#339933">&gt;&gt;</font> mv2 </blockquote><br><br>  The notation was designed with the intention of making these two forms easy to read.  It starts with the <font color="blue">do</font> keyword, followed by some monadic operations.  So these two of our examples will be written in <font color="blue">do-</font> notation: <br><br><blockquote>  <font color="#5d478b">- Form 1, do-notation.</font> <br>  <font>do</font> v <font color="#339933">&lt;-</font> mv <br>  f v <br><br>  <font color="#5d478b">- Form 2, do-notation.</font> <br>  <font>do</font> mv <br>  mv2 </blockquote><br><br>  In Form 1, the first line means that we take the monadic value of <font color="blue">mv</font> and ‚Äúunpack‚Äù it into the usual one called <font color="blue">v</font> .  The second line is just the calculation of <font color="blue">f</font> from <font color="blue">v</font> .  The result of the <font color="blue">fv</font> string is the result of the entire expression. <br><br>  In Form 2, the first line "is executed" monadic value ("action") <font color="blue">mv</font> .  In the second line, ‚Äúperformed‚Äù is another monadic value (‚Äúaction‚Äù) of <font color="blue">mv2</font> .  Thus, we have just a notation that links in the sequence <font color="blue">mv</font> and <font color="blue">mv2</font> , as the operator <font color="blue">&gt;&gt;</font> does. <br><br>  The compiler in Haskell converts a convenient <font color="blue">do-</font> notation into a record without <font color="blue">do</font> for Form 1 and Form 2. This is just a syntactic transformation, and the meaning of both records is identical.  In addition, both forms can be mixed in one expression of each of the notations.  Example: <br><br><blockquote>  <font color="#5d478b">- mv :: m a</font> <br>  <font color="#5d478b">- v1 :: a</font> <br>  <font color="#5d478b">- f :: a -&gt; m b</font> <br>  <font color="#5d478b">- v2 :: b</font> <br>  <font color="#5d478b">- mv3 :: m c</font> <br><br>  <font>do</font> <br>  v1 <font color="#339933">&lt;-</font> mv <br>  v2 <font color="#339933">&lt;-</font> f v1 <br>  mv3 <br>  <font>return</font> v2 </blockquote><br><br>  This is exactly the same as: <br><br><blockquote>  mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ v1 <font color="#339933">-&gt;</font> <br>  <font>(</font> f v1 <font color="#339933">&gt;&gt; =</font> <font>(</font> \ v2 <font color="#339933">-&gt;</font> <br>  <font>(</font> mv3 <font color="#339933">&gt;&gt;</font> <br>  <font>(</font> <font>return</font> v2 <font>)</font> <font>)</font> <font>)</font> <font>)</font> <font>)</font> </blockquote><br><br>  Or without skokbok: <br><br><blockquote>  mv <font color="#339933">&gt;&gt; =</font> \ v1 <font color="#339933">-&gt;</font> <br>  f v1 <font color="#339933">&gt;&gt; =</font> \ v2 <font color="#339933">-&gt;</font> <br>  mv3 <font color="#339933">&gt;&gt;</font> <font>return</font> v2 </blockquote><br><br>  You can imagine that when monadic expressions grow, the <font color="blue">do-</font> form remains as easy to read, while the form without <font color="blue">do</font> (also called ‚ÄúSugarless‚Äù) often becomes completely unreadable.  That's why <font color="blue">do-</font> abstract exists.  Another great thing is that the <font color="blue">do-</font> concept works for <i>all</i> monads, not just any one. <br><br>  In addition, you can mix <font color="blue">do-</font> notation and de-sugated notation in one expression.  Like this: <br><br><blockquote>  <font>do</font> v1 <font color="#339933">&lt;-</font> mv <br>  v2 <font color="#339933">&lt;-</font> f v1 <br>  mv3 <font color="#339933">&gt;&gt;</font> <font>return</font> v2 </blockquote><br><br>  Sometimes this is useful, but can often cause poor readability of the code. <br><br>  Let's see how our previous examples will look like in <font color="blue">do-</font> notation. <br><br><blockquote>  <font color="#5d478b">- Read the line, then print it.</font> <br>  readAndPrintLine <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  readAndPrintLine <font color="#339933">=</font> <br>  <font>do</font> <br>  line <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font>putStrLn</font> line <br><br>  <font color="#5d478b">- We print two lines, one after another.</font> <br>  <font color="#5d478b">- Not a function.</font> <br>  <font>do</font> <br>  <font>putStrLn</font> <font>"This is string 1."</font> <br>  <font>putStrLn</font> <font>"This is string 2."</font> <br><br>  <font color="#5d478b">- Read the line and print it twice.</font> <br>  readAndPrintLineTwice <font color="#339933">::</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <br>  readAndPrintLineTwice <font color="#339933">=</font> <br>  <font>do</font> <br>  line <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font>putStrLn</font> line <br>  <font>putStrLn</font> line </blockquote><br><br>  Here the code is much easier to read thanks to the <font color="blue">do-</font> notation.  Interestingly, it has an added advantage (or disadvantage, depending on what views you hold): Haskell code looks imperative!  If we read the code from top to bottom, it looks like an imperative language, in which, instead of assigning an arrow, <font color="blue">&lt;-</font> .  Say, <font color="blue">readAndPrintLine</font> can be described as: ‚Äúcall <font color="blue">getLine</font> to read the line that we put in the variable <font color="blue">line</font> ;  then call <font color="blue">putStrLn</font> to print this variable. ‚ÄùThis is definitely not what actually happens (for example, <font color="blue">line</font> is not a variable), but you can read it like that.  For a large amount of code that performs many input and output actions, a <font color="blue">do-</font> abstract is a very convenient way of writing. <br><br>  Do-notation has other useful properties.  For example, you can embed the <font color="blue">let-</font> expressions and <font color="blue">case</font> expressions in the body of the <font color="blue">do-</font> notation, which is often convenient.  I will not go into details, because this is a routine - take any other Haskell tutorial to explore this point. <br><br><h5>  Next </h5><br>  In the next article, I'll start talking about monads, starting with <font color="blue">Maybe</font> (the monad for calculations where an error can occur) and ending with the list monad (for calculations with multiple results). <br><br><h5>  Content </h5><br>  <a href="http://habrahabr.ru/blogs/Haskell/127556/">Part 1: The Basics</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128070/">Part 2: functions &gt;&gt; = and return</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128538/">Part 3: Monad Laws</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/129909/">Part 4: Maybe Monad and List Monad</a> </div><p>Source: <a href="https://habr.com/ru/post/128538/">https://habr.com/ru/post/128538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128533/index.html">Getting Started with the Google+ API</a></li>
<li><a href="../128534/index.html">Analysis of static C ++ code analysis tools</a></li>
<li><a href="../128535/index.html">Simple implementation of the long polling mechanism in PHP</a></li>
<li><a href="../128536/index.html">Text localization features</a></li>
<li><a href="../128537/index.html">Windows 8 as part of a new personal computing device concept</a></li>
<li><a href="../128539/index.html">Writing a class in php to interpret BrainLoller</a></li>
<li><a href="../128541/index.html">Image enhancement based on Matlab frequency filtering</a></li>
<li><a href="../128543/index.html">Asynchronous unit testing for C ++</a></li>
<li><a href="../128545/index.html">Graduate and Postgraduate Studies in Japan</a></li>
<li><a href="../128546/index.html">ProfitConf - conference of web developers in Novosibirsk on September 25-26</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>