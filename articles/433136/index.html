<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>System.Transactions infrastructure in the .NET world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Did you using (var scope = new TransactionScope(TransactionScopeOption.Required)) type in C # using (var scope = new TransactionScope(TransactionScope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>System.Transactions infrastructure in the .NET world</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/df/aq/ctdfaqnuvdjaw6tobyxja78mk-s.png"></div><br>  Did you <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> type in C # <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> ?  This means that the code running in the <code>using</code> block is in a transaction and after exiting this block, the changes will be committed or canceled.  It sounds clear until you start digging deeper.  And the deeper you dig, the "stranger and stranger" becomes.  Anyway, on closer acquaintance with the <code>TransactionScope</code> class and, in general, .NET transactions, a whole lot of questions arose. <br><br>  What is the <code>TransactionScope</code> class?  As soon as we use the <code>using (var scope = new TransactionScope())</code> construct, everything in our program immediately becomes transactional?  What is a ‚ÄúResource Manager‚Äù and a ‚ÄúTransaction Manager‚Äù?  Can I write my own resource manager and how does it ‚Äúconnect‚Äù to the <code>TransactionScope</code> instance created?  What is a distributed transaction and is it true that a distributed transaction in SQL Server or Oracle Database is the same as a .NET distributed transaction? <br><br>  In this publication, I tried to collect material that helps find answers to these questions and form an understanding of transactions in the .NET world. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  <a href="https://habr.com/ru/company/custis/blog/433136/">Introduction</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">What are transactions and what problems do they solve?</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">What transactions are considered here</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">TL; DR by section</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Transactions based on System.Transactions</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">What is it</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Resource managers</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Types of resource managers</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Using TransactionScope</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Applicability of software transactions</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Example of non-permanent resource manager</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">TL; DR by section</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Distributed transactions</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">What is it</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Transactional Protocols</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Biphasic fixation</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Cheat Sheet Interfaces System.Transations</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Software Distributed Transaction Restrictions and Alternatives</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">So is it in .NET Core?</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Distributed transactions and WCF</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">TL; DR by section</a> <br>  <a href="https://habr.com/ru/company/custis/blog/433136/">Conclusion-cheat sheet</a> </div></div><br><a name="Introduction"></a><h2>  Introduction </h2><br><a name="Transactions"></a><h4>  What are transactions and what problems do they solve? </h4><br>  The transactions in question are operations that transfer the system from one acceptable state to another and are guaranteed not to leave the system in an unacceptable state even in the event of unforeseen situations.  What kind of acceptable states are, in general, depends on the context.  Here we will consider an acceptable situation in which the data we process is complete.  This implies that the changes that make up the transaction, all together or committed, or not made.  In addition, changes to one transaction can be isolated from changes made to the system by another transaction.  The basic requirements for transactions are indicated by the acronym ACID.  For the first acquaintance with them, the <a href="https://ru.wikipedia.org/wiki/ACID">Wikipedia article</a> will do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/p7/2b/4rp72bf2l_qdxmlhawxsjslkj-i.png" width="250"></div><br>  A classic example of a transaction is the transfer of money between two accounts.  In this situation, withdrawing money from account No. 1 without crediting to account No. 2 is unacceptable, in the same way as crediting to account No. 2 without withdrawing from account No. 1. In other words, we want both operations - both withdrawal and crediting - run immediately.  If some of them fail, then the second operation should not be performed.  You can call this principle "all or nothing."  Moreover, it is desirable that operations are performed synchronously even in the event of system failures such as power outages, that is, we see the system in an acceptable state as soon as it becomes available after recovery. <br><br>  In mathematical terms, we can say that there is an invariant with respect to the system, which we would like to preserve.  For example, the amount on both accounts: it is necessary that after the transaction (money transfer) the amount remains the same as before it.  By the way, in the classic example with the transfer of money, accounting also appears - the subject area, where the notion of a transaction naturally arose. <br><br>  We illustrate the example of transferring money between two accounts.  The first picture shows the situation when the transfer of 50 rubles from account number 1 to account number 2 was completed successfully.  Green indicates that the system is in an acceptable state (the data is consistent). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/az/ra/snazracqgy0u8fdxtrtksb8jc7g.png"></div><br>  Now let's imagine that the transfer is made outside the transaction and after the withdrawal of money from account No. 1 there was a failure, due to which the withdrawn money was not credited to account No. 2. The system would be in an unacceptable state (red). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8h/ph/yj8hphqu7cszpcdvnboh97h3xfe.png"></div><br>  If the error occurred between the withdrawal and crediting operations, but the transfer was carried out within a single transaction, the withdrawal operation will be canceled.  As a result, the system will remain in its original acceptable state. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/6b/wi/3d6bwim5vko1yam5mhiv1ekl9ve.png"></div><br>  I will give examples of situations from the experience of our company in which transactions are useful: accounting for goods (accounting for the amount of goods of various kinds that are in certain stores and on the way), accounting for storage resources (accounting for the volume of the room occupied by goods of a certain type, volume of the room free to place the goods, the amount of goods that employees can move and automated storage systems for the day). <br><br>  The problems that arise when data integrity is compromised are obvious.  The information provided by the system does not just become unreliable - it loses touch with reality and turns into nonsense. <br><br><a name="KindsOfTransactions"></a><h4>  What transactions are considered here </h4><br>  Transaction benefits are known.  So, to maintain data integrity, we need a relational database, because this is where transactions are made?  Not really.  It was said above that the concept of a transaction depends on the context, and now we will briefly consider which transactions we can talk about when discussing information systems. <br><br>  To begin with, let's separate the concepts of subject domain transactions (business transactions) and system transactions.  The latter can be implemented in different places and in different ways. <br><br>  Let's enter from the highest level - the subject area.  An interested person can declare that there are some acceptable states and he does not want to see the information system outside these states.  Let's not invent unnecessary examples: transferring money between accounts is suitable here.  Just to clarify that the transfer is not necessarily the transfer of money between the settlement accounts of two bank customers.  Equally important is the task of accounting, when accounts must reflect the sources and purpose of the funds of the organization, and transfer - a change in the distribution of funds for these sources and destinations.  This was an example of a <b>domain transaction</b> . <br><br>  Now let's see the most common and interesting examples of the implementation of system transactions.  In system transactions, various technical means provide the requirements of the subject area.  A classic, proven solution of this kind is <strong>relational DBMS transactions</strong> (the first example).  Modern database management systems (both relational <a href="">and not-so</a> ) provide a transaction mechanism that allows you to either save (fix) all changes made during a specified period of work, or discard them (roll back).  When using such a mechanism, the operations of withdrawing money from one account and crediting it to another account, which constitute the transaction of the subject area, will be combined with the means of the DBMS into a system transaction and either executed together or not at all. <br><br>  Using the DBMS is, of course, not necessary.  Roughly speaking, you can generally implement the DBMS transaction mechanism in your favorite programming language and enjoy the unstable and error-prone analogue of existing tools.  But your ‚Äúbicycle‚Äù can be optimized for specific situations in the subject area. <br><br>  There are more interesting options.  Modern industrial programming languages ‚Äã‚Äã(C # and Java in the first place) offer tools designed specifically for organizing transactions involving completely different subsystems, and not just a DBMS.  In this publication we will call such transactions software.  In the case of C #, these are <b>transactions from the System.Transactions namespace</b> (second example), and this is described below. <br><br>  Before moving on to the <code>System.Transactions</code> transaction, one cannot but mention another interesting phenomenon.  Tools <code>System.Transactions</code> allow the programmer to independently implement the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">software transactional memory</a> .  In this case, software operations that affect the state of the system (in the case of classical imperative programming languages, this is an assignment operation) are included by default in transactions that can be fixed and rolled back in much the same way as DBMS transactions.  With this approach, the need to use synchronization mechanisms (in C # - <code>lock</code> , in Java - <code>synchronized</code> ) is significantly reduced.  A further development of this idea is a <strong>software transactional memory supported at the platform level</strong> (third example).  Such a miracle is expectedly found in a language whose elegance exceeds its industrial applicability, Clojure.  And for worker-peasant languages ‚Äã‚Äãthere are plug-in libraries that provide the functionality of software transactional memory. <br><br>  System transactions can include several information systems, in which case they become distributed.  Both DBMS transactions and software transactions can be distributed;  it all depends on what kind of functionality the particular transaction implementation tool supports.  Details of distributed transactions are discussed in the corresponding section.  I will give a picture to make it easier to understand the items under discussion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/yd/4s/diyd4spwelqhd61eoetfacuncjm.png"></div><br><a name="TLDR1"></a><h4>  TL; DR by section </h4><br>  There are processes that consist of several indivisible (atomic) operations applied to the system, in general, not necessarily informational.  Each indivisible operation can leave the system in an unacceptable state when the integrity of the data is violated.  For example, if the transfer of money between two accounts is represented by two indivisible operations of withdrawing from account No. 1 and crediting to account No. 2, then performing only one of these operations will violate the integrity of the data.  Money or disappear unknown where, or appear from nowhere.  A transaction combines indivisible operations so that they are performed all together (of course, sequentially, if necessary) or not performed at all.  You can talk about subject-matter transactions and transactions in technical systems that usually implement subject-matter transactions. <br><br><a name="SystemTransactions"></a><h2>  Transactions based on System.Transactions </h2><br><a name="WhatIsIt1"></a><h4>  What is it </h4><br>  In the .NET world, there is a software framework designed by the creators of a transaction management platform.  From the perspective of the transaction programmer, this framework consists of the <code>TransactionScope</code> , <code>TransactionScopeOption</code> , <code>TransactionScopeAsyncFlowOption</code> and <code>TransactionOptions</code> of the <code>System.Transactions</code> namespace.  If we talk about .NET Standard, then all this is available starting with <a href="">version 2.0</a> . <br><br>  Transactions from the <code>System.Transactions</code> namespace are based on <a href="http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf">the X / Open XA standard from The Open Group consortium</a> .  This standard introduces many of the terms discussed below, and, most importantly, describes distributed transactions, to which a special section is also devoted to this publication.  Software transactions are also based on this standard in other platforms, such <a href="https://ru.wikipedia.org/wiki/Java_Transaction_API">as Java</a> . <br><br>  A typical transaction usage scenario for a C # programmer is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { <span class="hljs-comment"><span class="hljs-comment">// -  ,    . scope.Complete(); }</span></span></code> </pre> <br>  Inside the <code>using</code> block is placed the code that performs the work, the results of which should be recorded or canceled all together.  Classic examples of such work are reading and writing to the database or sending and receiving messages from the queue.  When the control leaves the <code>using</code> block, the transaction will be committed.  If you remove the call to <code>Complete</code> , the transaction will be rolled back.  Pretty simple. <br><br>  It turns out that during a transaction rollback, all operations made inside such a <code>using</code> block will be canceled?  And if I assigned some variable a different value, then this variable will restore the old value?  When I first saw a similar design, I thought so.  In fact, of course, not all changes will roll back, but only very <i>special ones</i> .  If all changes had been rolled back, then this would have been the software transactional memory described above.  Now let's see what these particular changes are that can participate in software transactions based on <code>System.Transactions</code> . <br><br><a name="ResourceManagers"></a><h4>  Resource managers </h4><br>  In order for something to support transactions based on <code>System.Transactions</code> , it is necessary that it has information that transaction work is currently in progress and that it is registered in some register of participants in the transaction.  You can get information about whether transaction work is going on by checking the static <code>Current</code> property of the <code>System.Transactions.Transaction</code> class.  Entering a block <code>using</code> above view just sets this property if it has not been set before.  And to register as a party to a transaction, you can use methods like <code>Transaction.Enlist <i>Smth</i></code> .  In addition, you need to implement the interface required by these methods.  A resource manager (Resource Manager) is exactly that ‚Äúsomething‚Äù that supports interaction with transactions from <code>System.Transactions</code> (a more specific definition is given below). <br><br>  What are resource managers?  If we work from C # with a DBMS, such as SQL Server or Oracle Database, we usually use the appropriate drivers, and they are the control resources.  In the code, they are represented by the <code>System.Data.SqlClient.SqlConnection</code> and <code>Oracle.ManagedDataAccess.Client.OracleConnection</code> .  Also, <a href="http://fukyo-it.blogspot.com/2012/02/truly-understanding-net-transactions.html">they say</a> MSMQ supports transactions based on <code>System.Transactions</code> .  Guided by the knowledge and examples drawn from the Internet, you can create your own resource manager.  The simplest example is in the next section. <br><br>  In addition to resource managers, we must also have a transaction manager (Transaction Manager), who will monitor the transaction and timely give orders to the resource manager.  Depending on which resource managers participate in the transaction (which characteristics they have and where they are located), different transaction managers are connected to the work.  In this case, the selection of the appropriate version occurs automatically and does not require the intervention of a programmer. <br><br>  More specifically, a resource manager is an instance of a class that implements the special interface <code>System.Transactions.IEnlistmentNotification</code> .  An instance of the class, as instructed by the client, is registered as a participant in the transaction, using the static property <code>System.Transactions.Transaction.Current</code> .  Later, the transaction manager calls the methods of the specified interface as necessary. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/ea/vp/tweavpimeod539do_fkzpr6yzrw.png"></div><br>  Clearly, the set of resource managers involved in a transaction may change at runtime.  For example, after entering the <code>using</code> block, we can first do something in SQL Server, and then in Oracle Database.  Depending on this set of resource managers, the transaction manager used is determined.  To be more precise, the transaction protocol being used is determined by the set of resource managers, and the one who supports it is determined by the transaction manager based on the protocol.  We will consider transaction protocols <a href="https://habr.com/ru/company/custis/blog/433136/">later</a> when we talk about distributed transactions.  The mechanism for automatically selecting the appropriate transaction manager at run time when the resource managers involved in a transaction change is called Transaction Promotion. <br><br><a name="KindsOfResourceManagers"></a><h4>  Types of resource managers </h4><br>  Resource managers can be divided into two large groups: durable and non-permanent. <br><br>  Durable Resource Manager is a resource manager that supports transactions even if the information system is unavailable (for example, when the computer is restarted).  Non-permanent resource manager (Volatile Resource Manager) - a resource manager that does not support a transaction if the information system is unavailable.  A non-persistent resource manager supports in-memory transactions only. <br><br>  Classic durable resource managers are a DBMS (or a DBMS driver for a software platform).  No matter what happens - even if the operating system fails, even if the power is turned off - the DBMS will guarantee the integrity of the data after it comes back to a working state.  For this, of course, you have to pay some inconvenience, but in this article we will not consider them.  An example of a non-persistent resource manager is the software transaction memory mentioned above. <br><br><a name="TransactionScope"></a><h4>  Using TransactionScope </h4><br>  When creating an object of type <code>TransactionScope</code> you can specify some parameters. <br><br>  First, there is a setting that tells the runtime environment what you need: <br><br><ol><li>  use a transaction that already exists at the moment; </li><li>  be sure to create a new one; </li><li>  instead, execute code inside a <code>using</code> block outside of a transaction. </li></ol><br>  For all this, the <code>System.Transactions.TransactionScopeOption</code> enumeration is responsible. <br><br>  Secondly, you can set the transaction isolation level.  This is a parameter that allows you to find a compromise between the independence of change and the speed of work.  The most independent level ‚Äî serializable ‚Äî ensures that there are no situations where changes made within one uncommitted transaction can be seen in another transaction.  Each next level adds one such specific situation where simultaneously running transactions can affect each other.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By default, a transaction is opened on a serializable level, which can be unpleasant (see, for example, </font></font><a href="https://habr.com/company/custis/blog/433136/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this comment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setting a transaction isolation level during creation </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a recommendation for resource managers. They may not even support all levels presented in the listing </font></font><code>System.Transactions.IsolationLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In addition, we must bear in mind that when using a connection pool for working with a database, the connection for which the transaction isolation level was changed will </font></font><a href="https://yarfullstack.com/post/2017-03/isolation-level-and-connection-pool/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retain this level</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> upon returning to the pool </font><font style="vertical-align: inherit;">. Now, when the programmer gets this connection from the pool and relies on the default values, he will observe unexpected behavior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typical work scenarios c</font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and significant pitfalls (namely, nested transactions) are well covered in </font></font><a href="https://habr.com/post/115480/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article on Habr√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="Applicability"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Applicability of software transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be said that in almost any information system that is in industrial operation, processes are launched that can lead the system to an unacceptable state. </font><font style="vertical-align: inherit;">Therefore, it is necessary to control these processes, find out whether the current state of the system is acceptable, and, if not, restore it. </font><font style="vertical-align: inherit;">Software transactions are a ready-made tool for keeping the system in acceptable condition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each case it would be constructive to consider the cost:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integration of processes into the software transaction infrastructure (these processes need to be aware of </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and many other things);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maintaining this infrastructure (for example, the cost of renting equipment with Windows on board); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> employee training (since the topic of .NET transactions is not very common). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We should not forget that the transaction process may be required to report its progress to the "outside world", for example, to keep a log of actions outside the transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, the rejection of software transactions will require the creation or implementation of some other means of maintaining data integrity, which will also have its value. </font><font style="vertical-align: inherit;">In the end, there are cases when data integrity problems are so rare that it is easier to restore the acceptable state of the system with surgical interventions than to maintain an automatic recovery mechanism.</font></font><br><br><a name="Example"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example of non-permanent resource manager </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now consider an example of a simple resource manager that does not support recovery from a system failure. We will have a software transactional memory block that stores some value that can be read and rewritten. In the absence of a transaction, this block behaves like a normal variable, and in the presence of a transaction, it retains an initial value that can be restored after the transaction is rolled back. The code for such a resource manager is as follows:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Stm</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Transactions</span></span>.<span class="hljs-title"><span class="hljs-title">IEnlistmentNotification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _current; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _original; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _enlisted; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _current; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Enlist()) { _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_enlisted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTx = System.Transactions.Transaction.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTx == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; currentTx.EnlistVolatile(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, System.Transactions.EnlistmentOptions.None); _enlisted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IEnlistmentNotification public void Commit(System.Transactions.Enlistment enlistment) { _original = _current; _enlisted = false; } public void InDoubt(System.Transactions.Enlistment enlistment) { _enlisted = false; } public void Prepare(System.Transactions.PreparingEnlistment preparingEnlistment) { preparingEnlistment.Prepared(); } public void Rollback(System.Transactions.Enlistment enlistment) { _current = _original; _enlisted = false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> IEnlistmentNotification }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be seen that the only formal requirement is the implementation of the interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. From interesting things worth noting methods </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(not part </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The method </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just checks if the code works within the transaction, and, if so, registers an instance of its class as a non-permanent resource manager. The method </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is invoked by the transaction manager before committing the changes. Our resource manager signals its readiness to commit by calling a method </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following is a code showing an example of using our resource manager:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stm&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { stm.Value = <span class="hljs-number"><span class="hljs-number">2</span></span>; scope.Complete(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If immediately after exiting the block </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to read the property </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the set value is expected there </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And if you remove the call </font></font><code>scope.Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the transaction will be rolled back and the property </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will have the value </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set before the transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplified sequence of calls when working with transactions is </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown in the diagram below.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/je/1d/09je1dkghhmmwts6rvaufuntpna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be seen that in this example not all the possibilities provided by the infrastructure are considered </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will take a closer look at them after we become familiar with transactional protocols and distributed transactions in the next section.</font></font><br><br><a name="TLDR2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; DR by section </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A programmer can use a class </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to execute some code within an existing or new transaction. A transaction is committed if and only if a </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method is called </font><font style="vertical-align: inherit;">on an existing instance of a class </font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despite the fact that before that it had called</font></font><code>Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The programmer can indicate whether he wants to start a new transaction without fail, take advantage of an existing one or, conversely, execute a code outside of an existing transaction. Only resource managers are involved in the transaction - software components that implement certain functionality. Resource managers can be durable (recovering from a system failure) and non-permanent (non-recovering). A DBMS is an example of a durable resource manager. Coordination of resource managers is handled by a transaction manager ‚Äî a software component that is automatically selected by the runtime environment without the participation of the programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A non-persistent resource manager is a class that implements the interface </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and in the method.</font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confirming its readiness to commit changes or, on the contrary, signaling a rollback of changes. </font><font style="vertical-align: inherit;">When the caller does something with the resource manager, it checks to see if the transaction is open now, and, if open, is registered with the method </font></font><code>System.Transactions.Transaction.EnlistVolatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="DistributedTransactions"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distributed transactions </font></font></h2><br><a name="WhatIsIt2"></a><h4>  What is it </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distributed transaction involves several information subsystems (in fact, not everything is so simple, below is described in more detail). </font><font style="vertical-align: inherit;">It is understood that changes in all systems involved in a distributed transaction must either be committed or rolled back. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, various means of transaction implementation were presented: the DBMS, the infrastructure </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the software transactional memory built into the platform. </font><font style="vertical-align: inherit;">Distributed transactions can be provided with these tools. </font><font style="vertical-align: inherit;">For example, in Oracle Database, changing (and actually reading) data in several databases within a single transaction automatically turns it into a distributed one. </font><font style="vertical-align: inherit;">Then we will talk about software distributed transactions, which can include heterogeneous resource managers.</font></font><br><br><a name="TransactionProtocols"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transactional Protocols </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaction Protocol is a set of principles by which applications involved in a transaction interact. The following protocols are most common in the .NET world. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lightweight.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A maximum of one durable resource manager is used. All transactional interactions occur within the same application domain, or the resource manager supports promotion and single-phase commit (implements </font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OleTx.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interworking between multiple application domains and multiple computers is allowed. The use of many durable resource managers is allowed. All participating computers must be running Windows. Uses remote procedure call (RPCs). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS-AT.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interworking between multiple application domains and multiple computers is allowed. The use of many durable resource managers is allowed. Participating computers can be running different operating systems, not just Windows. Hypertext Transmission Protocol (HTTP) is used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was noted above that the current transactional protocol influences the choice of the transaction manager, and the choice of the protocol is influenced by the characteristics of the control resources involved in the transaction. Now we list the known transaction managers. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lightweight Transaction Manager (LTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Introduced in the .NET Framework 2.0 and later. Manages transactions using the Lightweight protocol. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel Transaction Manager (KTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Introduced in Windows Vista and Windows Server 2008. Manages transactions using the Lightweight protocol. It can call a transactional file system (Transactional File System, TxF) and a transaction registry (Transactional Registry, TxR) in Windows Vista and Windows 2008. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed Transaction Coordinator (MSDTC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Manages transactions using the OleTx and WS-AT protocols. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should also be borne in mind that some of the resource managers do not support all the protocols listed. For example, MSMQ and SQL Server 2000 do not support Lightweight, so transactions involving MSMQ or SQL Server 2000 will be managed by MSDTC, even if they are the only participants. Technically, this limitation arises from the fact that the specified resource managers, implementing, of course, the interface</font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not implement the interface </font></font><code>System.Transactions.IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In it there is, among other things, a method </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that the runtime environment calls, if necessary, to switch to a more ‚Äúcool‚Äù transaction manager. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the ambiguity of the concept of a distributed transaction should become apparent. </font><font style="vertical-align: inherit;">For example, you can define a distributed transaction as a transaction in which it participates:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at least two any resource managers; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as many non-permanent resource managers and at least two durable ones; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at least two of any resource managers, necessarily located on different computers. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, it is always better to clarify exactly which transactions in question. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in this context, MSDTC is primarily discussed. </font><font style="vertical-align: inherit;">It is a software component of Windows that manages distributed transactions. </font><font style="vertical-align: inherit;">There is a graphical interface for configuration and monitoring of transactions, which can be detected in the Component Services utility by following the path ‚ÄúComputers - My Computer - Distributed Transaction Coordinator - Local DTC‚Äù.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/35/gc/vo35gcdta3c9qx5w5cnsuxkbzz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For configuration, select the ‚ÄúProperties‚Äù item in the context menu of the ‚ÄúLocal DTC‚Äù node, and to monitor distributed transactions, select the ‚ÄúTransaction statistics‚Äù item in the central panel. </font></font><br><br><a name="TwoPhaseCommit"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biphasic fixation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If several resource managers are involved in a transaction, the results of their work may differ: for example, one of them has succeeded, and he is ready to commit changes, while the other has an error, and he is going to roll back the changes. However, the essence of a distributed transaction lies precisely in the fact that the changes of all the controlling resources involved in the transaction are either fixed all together or rolled back. Therefore, in such cases, the two-phase fixation protocol is usually used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the essence of this protocol is as follows. During the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first phase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resource managers involved in the transaction prepare enough information to recover from a failure (if it is a durable resource manager) and to successfully complete the work as a result of committing. From a technical point of view, the resource manager signals that he has completed the first phase, calling the method </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the method </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Or the resource manager can notify about the rollback of changes by calling the method </font></font><code>ForceRollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When all involved in the transaction resource managers "voted", that is, notified the transaction manager about whether they want to commit or roll back the changes, the </font><b><font style="vertical-align: inherit;">second phase</font></b><font style="vertical-align: inherit;"> begins</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. At this time, resource managers are instructed to record their changes (if all participants voted for fixation) or to refuse changes (if at least one participant voted for rollback). Technically, this is expressed in calling methods </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">methods </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that implement resource managers and in which they call the method </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resource manager can call the method </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">during the first phase. In this case, it is assumed that he is not going to record any changes (for example, works only for reading) and will not participate in the second phase. More details about the two-phase fixation can be found </font></font><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/transactions/committing-a-transaction-in-single-phase-and-multi-phase"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the connection between the transaction manager and at least one of the resource managers is lost, then the transaction becomes frozen (‚Äúin doubt‚Äù, in-doubt). </font><font style="vertical-align: inherit;">The transaction manager, by invoking methods </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, notifies the available resource managers that can respond appropriately about this event. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also a </font></font><a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">three-phase fixation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and its modifications with its advantages and disadvantages. </font><font style="vertical-align: inherit;">The three-phase commit protocol is less common, perhaps because it requires even more expenses for messages between interacting subsystems.</font></font><br><br><a name="Interfaces"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cheat Sheet Interfaces System.Transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something difficult turns out. To sort things out a bit, I will briefly describe the main namespace interfaces </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needed to create a resource manager. Here is the class diagram.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/rj/sx/bsrjsxptqz6w3g7l6zxawrzeyco.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEnlistmentNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The resource manager must implement this interface. The transaction manager calls the implemented methods in the following order. During the first phase, he calls the method </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(unless the stars came together to call the method </font></font><code>ISinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as described in the next paragraph). As part of this method, the resource manager saves the information necessary for recovery after a failure, prepares for final fixation of changes on its side and votes for the fixation or rollback of changes. If there comes a second phase, depending on the availability of resources and control of the results of the vote Managing transactions is one of three methods: </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resource manager implements this interface if it wants to provide the transaction manager with the ability to optimize execution by reducing the second phase of commit. If the transaction manager sees only one resource manager, then in the first fixation phase he tries to call the method </font></font><code>SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(instead of </font></font><code>IEnlistmentNotification.Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) to the </font><font style="vertical-align: inherit;">resource manager </font><font style="vertical-align: inherit;">and thereby eliminate the vote and the transition to the second phase. This approach has advantages and disadvantages, which are most clearly written by Microsoft </font></font><a href="https://msdn.microsoft.com/en-us/library/cc229955.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITransactionPromoter.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The resource manager implements this interface (not directly, but through the interface</font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), if it wants to provide the transaction manager with the ability to adhere to the Lightweight protocol even with a remote call, until other conditions arise that will require complication of the protocol. When the protocol needs to be complicated, a method will be called </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPromotableSinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The resource manager implements this interface in order, first, to implement the interface </font></font><code>ITransactionPromoter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and second, so that the transaction manager can use a single-phase commit by calling the </font></font><code>IPromotableSinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">methods </font></font><code>IPromotableSinglePhaseNotification.Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The transaction manager calls the method </font></font><code>IPromotableSinglePhaseNotification.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to mark the successful registration of the resource manager using the simplified scheme. More or less, this can be understood from the </font></font><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/transactions/optimization-spc-and-promotable-spn"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft document</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little more look at the class</font></font><code>System.Transactions.Enlistment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and his heirs. Instances of this type provide a transaction manager when invoking interface methods implemented by a resource manager.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bd/xc/qibdxcddktegq5h2xnpuaelygj0.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resource manager can call a single method of this type, - </font></font><code>Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to signal the successful completion of its part of the work. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreparingEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using an instance of this type during the first commit phase, the resource manager can signal its intention to commit or roll back the changes. </font><font style="vertical-align: inherit;">A durable resource manager can also get the information required to recover from a system failure. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SinglePhaseEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using an instance of this type, the resource manager can transmit information to the transaction manager about the results of its work when using the simplified scheme (single-phase commit).</font></font><br><br><a name="LimitationsAndAlternatives"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Software Distributed Transaction Restrictions and Alternatives </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A brief survey of opinions found on the Internet shows that in many areas distributed transactions are going out of fashion. Look, for example, at </font></font><a href="https://habr.com/company/flant/blog/347518/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this spiteful comment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The main object of criticism, which is briefly described </font></font><a href="https://habr.com/company/nixsolutions/blog/321686/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , is the synchronous (blocking) nature of distributed transactions. If a user sent a request, during the processing of which a distributed transaction was organized, he will receive a response only after all subsystems included in the transaction have finished (or with an error). At the same time, there is an opinion supported by research that the two-phase commit protocol shows poor performance, especially with an increase in the number of subsystems involved in the transaction, which is mentioned, for example, in</font></font><a href="https://habr.com/company/avito/blog/426101/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of this publication on "Habr√©"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the creator of the system prefers to return the answer to the user as soon as possible, putting the reconciliation of the data for later, then some other solution is more suitable for him. In the context of the Brewer theorem ( </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAP theorems</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), it can be said that distributed transactions are suitable for cases where data consistency (Consistency) is more important than availability (Availability).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are other practical restrictions on the use of software distributed transactions. For example, it was experimentally established that distributed transactions using the OleTx protocol should not cross network domains. In any case, the long attempts to get them to work were not crowned with success. In addition, it was found that the interaction between several instances of the Oracle Database (distributed transaction DBMS) imposes serious restrictions on the applicability of software distributed transactions (again failed to start).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the alternatives to distributed transactions? First, it must be said that it will be very difficult to do without technical transactions (ordinary, not distributed). There will surely be processes in the system that may temporarily violate the integrity of the data, and it will be necessary to somehow oversee such processes. Similarly, in terms of the subject area, a concept may arise that includes a process that is implemented by a set of processes in different technical systems, which should begin and end in the field of complete data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turning to alternatives to distributed transactions, you can note solutions based on messaging services, such as RabbitMQ and Apache Kafka. In </font></font><a href="https://habr.com/company/nixsolutions/blog/322214/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this publication on "Habr√©"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> four such solutions are considered:</font></font><br><br><ol><li>   ,        ,    ; </li><li>    ,           (Transaction Log Tailing); </li><li>       ,       ; </li><li>             (Event Sourcing). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another alternative is the Saga template. It assumes a cascade of subsystems with its local transactions. Upon completion, each system calls the following (either independently or with the help of a coordinator). For each transaction, there is a corresponding cancellation transaction, and the subsystem, instead of transferring control further, on the contrary, initiates the cancellation of changes made by previous subsystems. On "Habr√©" there are several good articles about the template "Saga". For example, </font></font><a href="https://habr.com/company/avito/blog/426101/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this publication</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides general information about maintaining the ACID principles in the microservices, and in </font></font><a href="https://habr.com/company/oleg-bunin/blog/418235/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an example of the implementation of the Saga template with the coordinator is discussed in detail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our company, some products successfully use software distributed transactions through WCF, but there are other options. One day, when we tried to make friends with a distributed transaction, we had many problems, including collisions with the limitations described above and parallel troubles with updating the software infrastructure. Therefore, in the conditions of a shortage of resources for running around another capital decision, we used the following tactics. The called party fixes the changes in any case, but notes that they are in the draft state, therefore these changes do not affect the work of the called system. Then the caller when completing his work through a distributed transaction DBMS activates the changes made by the called system. In this way,instead of software distributed transactions, we used distributed DBMS transactions, which in this case turned out to be much more reliable.</font></font><br><br><a name="NetCore"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So is it in .NET Core? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET Core (and even in .NET Standard) there are all the necessary types for organizing transactions and creating your own resource manager. </font><font style="vertical-align: inherit;">Unfortunately, transactions based on .NET Core </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have a serious limitation: they only work with the Lightweight protocol. </font><font style="vertical-align: inherit;">For example, if the code uses two long-lived resource managers, then at run-time, the environment will throw an exception as soon as the second manager is contacted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that .NET Core is being tried to be independent of the operating system, therefore the list of transaction managers such as KTM and MSDTC is excluded, and they are needed to support transactions with the specified properties. </font><font style="vertical-align: inherit;">It is possible that the connection of transaction managers in the form of plug-ins will be implemented, but so far this has been written with water, so it‚Äôs impossible to count on the industrial use of distributed transactions in .NET Core. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From experience, you can be sure of the differences in distributed transactions in the .NET Framework and in the .NET Core by writing the same code, compiling and running it on different platforms.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of such a code that calls sequentially SQL Server and Oracle Database.</font></font></b> <div class="spoiler_text"><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { MsSqlServer(); Oracle(); scope.Complete(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Oracle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oracle.ManagedDataAccess.Client.OracleConnection(<span class="hljs-string"><span class="hljs-string">"User Id=some_user;Password=some_password;Data Source=some_db"</span></span>)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MsSqlServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnectionStringBuilder { DataSource = <span class="hljs-string"><span class="hljs-string">"some_computer\\some_db"</span></span>, UserID = <span class="hljs-string"><span class="hljs-string">"some_user"</span></span>, Password = <span class="hljs-string"><span class="hljs-string">"some_password"</span></span>, InitialCatalog = <span class="hljs-string"><span class="hljs-string">"some_scheme"</span></span>, Enlist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnection(builder.ConnectionString)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ready to build projects </font></font><a href="https://github.com/CUSTIS-public/NetDistributedTransactionsExample"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running the example for .NET Core ends in error. </font><font style="vertical-align: inherit;">The location and type of the thrown exception depend on the order of the DBMS call, but in any case this exception indicates an invalid transactional operation. </font><font style="vertical-align: inherit;">Running the example for the .NET Framework ends successfully if MSDTC is running at the time; </font><font style="vertical-align: inherit;">in this case, in the MSDTC GUI, you can observe the registration of a distributed transaction.</font></font><br><br><a name="WCF"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distributed transactions and WCF </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Windows Communication Foundation (WCF) is the software framework of the .NET world for organizing and invoking network services. Compared with the more fashionable approaches of REST and ASP.NET Web API, it has its own advantages and disadvantages. WCF is very good at making .NET transactions, and in the world of the .NET Framework it is convenient to use it for organizing transactions distributed between a client and a service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET Core, this technology works only on the client side, that is, you cannot create a service, but you can only access an existing one. This, however, is not very important, because, as mentioned above, with the distributed transactions in the .NET Core things are not very good at all. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How WCF works</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For readers who are not familiar with WCF, here we will give the most brief background information about what this technology is in practice. Context - two information systems, called client and service. The client at runtime accesses another information system that supports the service of interest to the client, and requires that some operation be performed. Then control is returned to the client.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a service on WCF, you usually need to write an interface that describes the contract of the service being created, and a class that implements this interface. The class and interface are laid out with special WCF attributes, distinguishing them from other types, and specify some details of the behavior during the discovery and service invocation. These types are wrapped into something that works as a server (for example, in a DLL, which IIS is used for), and are supplemented with a configuration file (there are variants), where the details of the service implementation are indicated. Once started, the service can be accessed, for example, by a network address; In the Internet browser, you can see the contracts that the requested service implements.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A programmer who wants to access an existing WCF service uses a console utility or a graphical interface built into the development environment to generate C # (or other supported language) types corresponding to the service contracts at the service‚Äôs existing address. The file with the obtained types is included in the project of the client application, and after that the programmer uses the same terms that are contained in the service interface, enjoying the benefits of progress (static typing). In addition, the client‚Äôs configuration file contains the technical characteristics of the called service (configuration is possible in the code, without a configuration file).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF supports different modes of transport, encryption and other more subtle technical parameters. </font><font style="vertical-align: inherit;">Most of them are united by the concept of "binding" (Binding). </font><font style="vertical-align: inherit;">There are three important WCF service parameters:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the address at which it is available; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> binding; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contract (interfaces). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All these parameters are set in the service and client configuration files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our company, WCF (with and without distributed transactions) is widely used in embedded products, however, given the fashion trends, its use in new products is still under question. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to initiate distributed transactions in WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To initiate transactions based on WCF </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the programmer needs to place several attributes in the code, make sure that the bindings used support distributed transactions, are written on the client and in the service, </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and that a suitable transaction manager is running on all the computers involved. it will be MSDTC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed transaction bindings: NetTcpBinding, NetNamedPipeBinding, WSHttpBinding, WSDualHttpBinding, and WSFederationHttpBinding. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method (operation) of the service interface must be marked with an attribute </font></font><code>System.ServiceModel.TransactionFlowAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then, with certain attribute parameters and when the </font></font><code>TransactionScopeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">parameter is set, </font><font style="vertical-align: inherit;">the </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transaction will be distributed between the client and the service. </font><font style="vertical-align: inherit;">In addition, by default, it is considered that the service votes to commit a transaction, unless an exception was thrown during execution. </font><font style="vertical-align: inherit;">To change this behavior, you must set the corresponding </font></font><code>TransactionAutoComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">parameter value </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code of the simplest WCF service supporting distributed transactions.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.ServiceModel.ServiceContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationContract] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyService</span></span> : <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationBehavior(TransactionScopeRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(input)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.Length; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, it differs from the usual service code only in the use of an attribute </font></font><code>System.ServiceModel.TransactionFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and in a special attribute setting </font></font><code>System.ServiceModel.OperationBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration example for this service.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.MyService"</span></span> behaviorConfiguration=<span class="hljs-string"><span class="hljs-string">"serviceBehavior"</span></span>&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">""</span></span> binding=<span class="hljs-string"><span class="hljs-string">"wsHttpBinding"</span></span> bindingConfiguration=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.IMyService"</span></span>/&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">"mex"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"IMetadataExchange"</span></span> binding=<span class="hljs-string"><span class="hljs-string">"mexHttpBinding"</span></span>/&gt; &lt;/service&gt; &lt;/services&gt; &lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> maxReceivedMessageSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxBufferPoolSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> transactionFlow=<span class="hljs-string"><span class="hljs-string">"true"</span></span> closeTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> openTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> receiveTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> sendTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span>&gt; &lt;security mode=<span class="hljs-string"><span class="hljs-string">"None"</span></span>/&gt; &lt;readerQuotas maxArrayLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxStringContentLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span>/&gt; &lt;/binding&gt; &lt;/wsHttpBinding&gt; &lt;/bindings&gt; &lt;/system.serviceModel&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the WSHttpBinding type binding and the attribute are used </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></div></div><br><a name="TLDR3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; DR by section </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed transactions include multiple resource managers, and all changes must either be committed or rolled back. Some modern DBMS implement distributed transactions, which represent a convenient mechanism for connecting several databases. Software (not implemented in a DBMS) distributed transactions can include different combinations of resource managers on different computers running different operating systems, but they have limitations that need to be considered before relying on them. A modern alternative to distributed transactions are messaging-based solutions. In .NET Core, distributed transactions are not yet supported.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF is one of the standard and proven tools for creating and accessing services in the .NET world, supporting several modes of transport and encryption. </font><font style="vertical-align: inherit;">WCF is very close friends with distributed transactions based on </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setting up distributed transactions for WCF consists in marking the code with several attributes and adding a couple of words in the service and client configuration files. </font><font style="vertical-align: inherit;">Not all WCF bindings support distributed transactions. </font><font style="vertical-align: inherit;">In addition, obviously, transactions in WCF have the same limitations as without using WCF. </font><font style="vertical-align: inherit;">The .NET Core platform so far only allows accessing services on WCF and not creating them.</font></font><br><br><a name="Conclusion"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion-cheat sheet </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This publication provides an overview of the fundamentals of .NET software transactions. Some conclusions regarding the trends in software transactions can be found in the sections on the applicability and limitations of the subjects in question, and in the conclusion the main theses of the publication are collected. I suppose that they can be used as a cheat sheet when considering software transactions as one of the options for implementing a technical system or for refreshing relevant information in memory. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions (domain, DBMS, software)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The requirements of the subject area are sometimes formulated as transactions ‚Äî operations that, starting in the area of ‚Äã‚Äãcomplete data, upon completion (including unsuccessful ones) should also come in the area of ‚Äã‚Äãcomplete data (possibly already different). These requirements are usually implemented as system transactions. A classic example of a transaction is the transfer of money between two accounts, consisting of two indivisible operations - withdrawing money from one account and crediting to another. In addition to the well-known transactions implemented by the means of the DBMS, there are also software transactions, for example, in the .NET world. Resource managers are software components that are aware of the existence of such transactions and are able to be included in them, that is, to commit or roll back the changes made.Resource managers receive commit and rollback instructions from the transaction manager that forms the basis of the infrastructure</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durable and non-permanent resource managers.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durable resource managers support data recovery after a system failure. DBMS drivers for .NET usually offer this functionality. Non-permanent resource managers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> support disaster recovery. Software transactional memory ‚Äî a way to manage objects in RAM ‚Äî can be viewed as an example of a non-persistent resource manager. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions and .NET resource managers.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The .NET programmer uses software transactions and creates his own resource managers using types from the namespace</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This infrastructure allows the use of transactions of different nesting and isolation (with known limitations). The use of transactions is not difficult, and it consists in wrapping the code in a block </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with certain characteristics. However, resource managers that are included in the transaction in this way must support the required functionality on their part. Using heterogeneous resource managers in a transaction or using one manager in different ways can automatically turn a transaction into a distributed one. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed transactions (DBMS, software).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distributed transaction covers several subsystems, changes in which must be synchronized, that is, they are either fixed together or rolled back. Distributed transactions are implemented in some modern DBMS. Software distributed transactions (these are not the ones that are implemented by the DBMS) impose additional restrictions on the interacting processes and platforms. Distributed transactions are gradually falling out of fashion, yielding to messaging services solutions. To turn a regular transaction into a distributed one, the programmer has little to do: when you include a resource manager with certain characteristics in the transaction, the transaction manager will automatically do everything necessary at run time. Regular software transactions are available in .NET Core and .NET Standard, while distributed transactions are not available.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed transactions through WCF. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF is one of the standard .NET tools for creating and invoking services, including standardized protocols. </font><font style="vertical-align: inherit;">In other words, the specifically configured WCF services can be accessed from any application, not just .NET or Windows. </font><font style="vertical-align: inherit;">To create a distributed transaction over WCF, you need to mark up the types that make up the service with additional attributes and make minimal changes to the service and client configuration files. </font><font style="vertical-align: inherit;">In .NET Core and .NET Standard, you cannot create WCF services, but you can create WCF clients. </font></font><br><br> <a href="https://github.com/CUSTIS-public/NetDistributedTransactionsExample"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example for testing System.Transactions on GitHub</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Links</b> <div class="spoiler_text"><h4>  Basic concepts </h4><br> <a href="https://ru.wikipedia.org/wiki/ACID">ACID</a> ( ¬´¬ª) <br> <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/transactions/committing-a-transaction-in-single-phase-and-multi-phase">  </a> ( Microsoft) <br> <a href="https://msdn.microsoft.com/en-us/library/cc229955.aspx"> </a> ( Microsoft) <br> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">  </a> ( ¬´¬ª) <br> <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP"> </a> ( ¬´¬ª) <br> <a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol"> </a> ( ¬´¬ª) <br><br><h4>     </h4><br> <a href="http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf">   X/Open XA</a> ( The Open Group) <br> <a href="https://ru.wikipedia.org/wiki/Java_Transaction_API">Java Transaction API</a> ( ¬´¬ª) <br> <a href="">     Cache</a> (  InterSystems) <br><br><h4>   .NET </h4><br> <a href="http://fukyo-it.blogspot.com/2012/02/truly-understanding-net-transactions.html">   .NET</a> (   Tech Blog Collection) <br> <a href="https://habr.com/post/115480/">     TransactionScope</a> (¬´¬ª) <br> <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/transactions/optimization-spc-and-promotable-spn">  ,     </a> ( Microsoft) <br> <a href="">   .NET Standard 2.0</a> ( .NET Standard  GitHub) <br> <a href="https://yarfullstack.com/post/2017-03/isolation-level-and-connection-pool/">       </a> ( YarFullStack) <br><br><h4>    </h4><br> <a href="https://habr.com/company/nixsolutions/blog/321686/">     </a> (¬´¬ª) <br> <a href="https://habr.com/company/nixsolutions/blog/322214/">     </a> (¬´¬ª) <br> <a href="https://habr.com/company/avito/blog/426101/">    ¬´¬ª     </a> (¬´¬ª) <br> <a href="https://habr.com/company/oleg-bunin/blog/418235/">     ¬´¬ª  </a> (¬´¬ª) <br> <a href="https://habr.com/company/flant/blog/347518/">    </a> (¬´¬ª) <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editorial staff</font></font></b> <div class="spoiler_text"><ul><li> 20.12.2018 . </li><li> 21.12.2018  .      <a href="https://habr.com/users/olegaxenow/" class="user_link">OlegAxenow</a> . </li><li> 23.12.2018      <a href="https://habr.com/users/qw1/" class="user_link">qw1</a> . </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/433136/">https://habr.com/ru/post/433136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433122/index.html">React-Hot-Loader v4.6</a></li>
<li><a href="../433126/index.html">Zabbix Review: how to organize code review for monitoring configuration</a></li>
<li><a href="../433128/index.html">What IT professionals play and do not play (summary 2018)</a></li>
<li><a href="../433130/index.html">May the force be with us: our own immunity against cancer</a></li>
<li><a href="../433132/index.html">"Calendar tester" for December. Try a different approach</a></li>
<li><a href="../433138/index.html">Five principles of product design in Booking</a></li>
<li><a href="../433140/index.html">Ready client module Google Pay</a></li>
<li><a href="../433142/index.html">Timeless classics, or review of new attack vectors through Microsoft Office</a></li>
<li><a href="../433144/index.html">Released .NET Core 2.2. What's new? (1 of 3)</a></li>
<li><a href="../433146/index.html">[Competition] Top 25 game consoles (shake old)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>