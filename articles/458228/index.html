<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do we need virtual functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. If you know the answer to the question in the title, congratulations, you do not need this article. It is addressed to newcomers to programm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do we need virtual functions</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr.  If you know the answer to the question in the title, congratulations, you do not need this article.  It is addressed to newcomers to programming, like me, who cannot always independently deal with all the subtleties of C ++ and other typed languages, and if they can, it‚Äôs better to still learn from the mistakes of others. <br><br>  In this article, I will not just answer the question " <i>Why do we need virtual functions in C ++</i> ", but I will give an example from my practice.  For a short answer, you can turn to search engines that give something like the following: " <i>Virtual functions are needed to provide polymorphism ‚Äî one of the three whales of the OOP. Thanks to them, the machine can determine the type of object itself using a pointer without loading the programmer with this task.</i> "  Okay, but the question ‚Äúwhy‚Äù remains, although now it means a bit more: ‚Äú <i>Why rely on a car, waste extra time and memory, if you can podcast the pointer yourself, because the type of object to which it refers is almost always known?</i> ‚Äù Indeed, casting at first glance leaves virtual functions out of work, and it is precisely this that causes misconceptions and bad code.  In small projects, the loss is not noticeable, but, as you will soon see, with the growth of the caste program, the listing increases in an almost geometric progression. <br><a name="habracut"></a><br>  To begin with, we will recall where in general may be needed castes and virtual functions.  A type is lost when an object declared with type A is allocated with a new operation to allocate memory for an object of type B compatible with type A, usually inherited from A. Most often, the object is not one, but the whole array.  An array of pointers of the same type, each of which is waiting for the assignment of a memory area with objects of completely different types.  Here is an example we consider. <br><br>  I won‚Äôt be too long, the task was as follows: based on the document marked up with Markedit hypertext markup language (you can read about it <a href="https://habr.com/ru/post/444876/">here</a> ), build a parse tree and create a file containing the same document in HTML markup.  My solution consists of three consecutive subroutines: parsing the source text into tokens, building a syntax tree from tokens and building an HTML document based on it.  We are interested in the second part. <br>  The point is that the nodes of the target tree have different types (section, paragraph, text node, link, footnote, etc.), but for parent nodes, pointers to child nodes are stored in an array, and therefore have one type - Node. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The parser itself in a simplified form works like this: it creates a root of the syntactic tree of the <b>Root</b> type, declares an <b>open_node</b> pointer of the general type <b>Node</b> , which is immediately assigned the address of the <b>tree</b> , and the variable <b>type of the</b> enumerated type of <b>Node_type</b> , and then begins the cycle that searches the tokens from the very first until the last.  At each iteration, the <b>open_node</b> type of the open node is <b>first</b> entered into the type <b>variable</b> (types are stored in the node structure as an enumeration), followed by a <b>switch statement</b> that checks the type of the next token (the types of tokens are already carefully provided by the lexer).  In each branch of the switch, one more branch is presented that checks the <b>type</b> variable, where, as we remember, there is an open node type.  Depending on its value, different actions are performed, for example: add a certain type of node-list to an open node, open another node of a certain type in an open node and send its address to <b>open_node</b> , close an open node, throw an exception.  Applies to the topic of the article, we are interested in the second example.  Every open node (and generally every node that can be opened) already contains an array of pointers to <b>Node</b> type nodes.  Therefore, when we open a new node in an open node (assign the next array pointer to a memory for an object of another type), for the C ++ semantic analyzer it remains an instance of <b>Node</b> type, without acquiring new fields and methods.  A pointer to it is now assigned to the variable <b>open_node</b> , without losing the <b>Node</b> type.  But how to work with the pointer of the general <b>Node</b> type when you need to call a method, for example, a paragraph?  For example, <b>open_bold ()</b> , which opens a bold font node in it?  After all, <b>open_bold () is</b> declared and defined as a method of the <b>Paragraph</b> class, and <b>Node</b> knows absolutely nothing about it.  In addition, <b>open_node is</b> also declared as a pointer to a <b>Node</b> , and methods must accept from all types of opening nodes. <br><br>  There are two solutions: the obvious and the correct.  Obvious for a newbie is <b>static_cast</b> , and the right is virtual functions.  Let's first look at one branch of the parser switch, written using the first method: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; }</span></span></code> </pre> <br>  Not bad.  And now, I will not drag you for a long time, I will show the same piece of code written using virtual functions: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; }</span></span></code> </pre><br>  The win is obvious, but do we really need it?  After all, then you have to declare all the methods of all derived classes as virtual in the <b>Node</b> class and somehow implement them in each derived class.  The answer is yes, indeed.  There are not so many methods in this program (29), and their implementation in derived classes that are not related to them, consists of only one line: <b>throw string (‚Äúerror!‚Äù);</b>  .  You can turn on creative mode and come up with a unique line for each release of the exception.  But the most important thing is that due to the reduction of the code, the number of errors in it has decreased.  Casting is one of the most important causes of code errors.  Because after applying <b>static_cast, the</b> compiler stops swearing if the above class contains the method being called.  Meanwhile, different classes may contain different methods with the same name.  In my case, the code hid 6 !!!  errors, while one of them was duplicated in several branches of the switch.  Here she is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node:: open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_italic();</code> </pre><br>  Further, under the spoilers, I cite the full listings of the first and second versions of the parser. <br><br><div class="spoiler">  <b class="spoiler_title">Parser with casting</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_bold(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_bold(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_bold(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_italic(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_italic(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_italic(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_underlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_overlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_throwlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_subscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_superscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_marked(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_marked(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_marked(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_monospace(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); else if (type == Node::BOLD || type == Node::ITALIC || type == Node::UNDERLINED || type == Node::OVERLINED || type == Node::THROWLINED || type == Node::SUBSCRIPT || type == Node::SUPERSCRIPT || type == Node::MARKED || type == Node::MONOSPACE) open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section&gt;(open_node).open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::TITLE) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::LINK) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else { // INLINE if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_image(lexer[i-3].lexeme, lexer[i-1].lexeme); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); /// ROOT, /// SECTION, /// PARAGRAPH, TITLE, QUOTE, UNORDERED_LIST, ORDERED_LIST, /// BOLD, ITALIC, UNDERLINED, OVERLINED, THROWLINED, SUBSCRIPT, SUPERSCRIPT, MARKED, MONOSPACE, /// LINK break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parser with access to virtual methods</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH || type == Node::TITLE || type == Node::QUOTE || type == Node::TITLE || type == Node::QUOTE) open_node = open_node-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::LINK) throw string("unexpected underline inside link!"); else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = open_node-&gt;open_overlined(); else if (type == Node::TITLE) open_node = open_node-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = open_node-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::LINK) open_node = open_node-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else // TITLE, INLINE open_node = open_node-&gt;close(); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::LINK) open_node = open_node-&gt;close(); else // PARAGRAPH, TITLE, QUOTE, INLINE open_node = open_node-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else { // TITLE, LINK, INLINE if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) throw string("title cant't contain a cite!"); else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_quote(); } else if (type == Node::SECTION) open_node = open_node-&gt;open_quote(); else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From 1357 lines the code was reduced to 487 - almost three times, not counting the length of the lines! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One question remains: what about the execution time? </font><font style="vertical-align: inherit;">How many milliseconds should we pay to ensure that the computer itself determines the type of open node? </font><font style="vertical-align: inherit;">I conducted an experiment - fixed the time of the parser in milliseconds in the first and second cases for the same document on my home computer. </font><font style="vertical-align: inherit;">Here is the result: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casting - 538 ms. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtual functions - 1174 ms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total, 636 ms - a fee for compact code and no errors. </font><font style="vertical-align: inherit;">A lot of it?</font></font> Maybe.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if we need a program that works as fast as possible and requires the smallest possible amount of memory, we would not turn to the PLO and generally write it in assembly language, spending a week of time and risking a huge number of errors. </font><font style="vertical-align: inherit;">So my choice - wherever </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meet in the program </font><font style="vertical-align: inherit;">, replace them with virtual functions. </font><font style="vertical-align: inherit;">What is your opinion?</font></font></div><p>Source: <a href="https://habr.com/ru/post/458228/">https://habr.com/ru/post/458228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458214/index.html">Pentest-laboratory "Pentestit Test lab 12" - full passage</a></li>
<li><a href="../458218/index.html">Oral Surgery or not? That is the question</a></li>
<li><a href="../458220/index.html">The digest of interesting materials for the mobile developer # 304 (June 24 - 30)</a></li>
<li><a href="../458222/index.html">We break the memory game: a whole detective</a></li>
<li><a href="../458224/index.html">Software for Boeing-737 Max was written by outsourcers earning $ 9 per hour</a></li>
<li><a href="../45823/index.html">Habrobydlo</a></li>
<li><a href="../45824/index.html">10,000 Applications</a></li>
<li><a href="../458244/index.html">An endless and ridiculous list of what you need to know to safely use public Wi-Fi networks</a></li>
<li><a href="../458246/index.html">Random coincidences of life, or how did it happen that at the tractor factory you were presented with a cake</a></li>
<li><a href="../45825/index.html">UFO video from the ISS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>