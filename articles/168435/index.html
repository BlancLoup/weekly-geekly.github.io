<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classic sapper on html5 and libcanvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will explain step by step how to write the most common, classic sapper using Html5 Canvas, AtomJS, and the LibCanvas tile engine. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classic sapper on html5 and libcanvas</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/624/2aa/2da/6242aa2da8b1002ad0891b027cc282ed.png"><br><br>  In this article I will explain step by step how to write the most common, classic sapper using Html5 Canvas, AtomJS, and the LibCanvas tile engine. <br><br>  And also see the sequel - " <a href="http://habrahabr.ru/post/168705/">Isometric Sapper on LibCanvas (html5)</a> " 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  We use the standard template for the "start" of our application.  It is important not to forget to include js-files after creating the appropriate classes. <br><br><pre><code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>LibCanvas :: Mines<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/files/styles.css"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/files/js/atom.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/files/js/libcanvas.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/"</span></span></span><span class="hljs-tag">&gt;</span></span>Return to index<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ LibCanvas.extract(); atom.dom(</span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Mines.Controller(); }); }; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"js/controller.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  I drew two pictures - mines and flags.  Everything else we will do "manually" right in the application.  Combined them in one sprite to reduce the number of requests and preload before you start the application.  In the code, you can also see the cutting with the help of <a href="">atom.ImagePreloader</a> : <br><br><pre> <code class="hljs actionscript"><span class="hljs-comment"><span class="hljs-comment">/** @class Mines.Controller */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'Mines.Controller'</span></span>, { initialize: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ atom.ImagePreloader.run({ flag: <span class="hljs-string"><span class="hljs-string">'flag-mine.png [48:48]{0:0}'</span></span>, mine: <span class="hljs-string"><span class="hljs-string">'flag-mine.png [48:48]{1:0}'</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.start.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ); }, start: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.images = images; } });</code> </pre><br><br><h2>  Drawing </h2><br>  I love to visually see what comes up, so I prefer to start with the programming of the drawing, and only then go to the logic.  In order for our code to work, we will use <a href="https://github.com/theshock/libcanvas/tree/master/Docs/Ru/Engines/Tile"><code>LibCanvas.Engines.Tile</code></a> .  Add a class <code>View</code> , in which we create our engine.  We also need to create a simple application and bind the engine to the application using <code>TileEngine.Element.app</code> .  The default value will be equal to the closed cell.  Do not forget to create this <code>View</code> , in our controller. <br><br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@class</span></span></span><span class="hljs-comment"> Mines.View */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'Mines.View'</span></span>, { initialize: function (controller, fieldSize) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.images = controller.images; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine = new TileEngine({ size: fieldSize, cellSize: new Size(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>), cellMargin: new Size(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), defaultValue: <span class="hljs-string"><span class="hljs-string">'closed'</span></span> }) .setMethod( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createMethods() ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app = new App({ size : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine.countSize(), simple: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = TileEngine.Element.app( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.engine ); },</code> </pre><br><br><pre> <code class="hljs lua">/** @class Mines.Controller */ // ... start: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images)</span></span></span></span> { this.images = images; this.view = new Mines.View( this, new Size(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>) ); }</code> </pre><br><br>  Do not rush to run this code, we have not yet defined the <code>createMethods</code> method of the <code>View</code> class.  Let's generally define what we can have cell states. <br><br>  During the game we can see this: <br><br>  1. Numbers from 1 to 8. <br>  2. Closed cell <br>  3. Open but empty cell <br>  4. Checkbox <br><br>  After its completion - the following: <br><br>  1. All mines <br>  2. If you hit one of them, it is highlighted. <br>  3. If the flag is set incorrectly somewhere <br><br>  Total, 8 + 3 + 3 = 14 different states.  We describe them all: <br><br><pre> <code class="hljs bash">/** @class Mines.View */ // ... createMethods: <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span></span> () { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { 1: this.number.bind(this, 1), 2: this.number.bind(this, 2), 3: this.number.bind(this, 3), 4: this.number.bind(this, 4), 5: this.number.bind(this, 5), 6: this.number.bind(this, 6), 7: this.number.bind(this, 7), 8: this.number.bind(this, 8), explode : this.explode.bind(this), closed : this.closed .<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(this), mine : this.mine .<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(this), flag : this.flag .<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(this), empty : this.empty .<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(this), wrong : this.wrong .<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(this) }; },</code> </pre><br><br>  As you can see, we will call the corresponding <code>View</code> methods, bringing them to the current context.  In order to see what we have, we need to add the corresponding cells on the field. <br><br><pre> <code class="hljs lua">/** @class Mines.Controller */ // ... start: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images)</span></span></span></span> { // ... // todo: <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> after <span class="hljs-built_in"><span class="hljs-built_in">debug</span></span> <span class="hljs-string"><span class="hljs-string">'1 2 3 4 5 6 7 8 empty mine flag explode wrong closed'</span></span> .split(<span class="hljs-string"><span class="hljs-string">' '</span></span>) .forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, i)</span></span></span></span> { this.view.engine .getCellByIndex(new Point(i, <span class="hljs-number"><span class="hljs-number">3</span></span>)) .value = name; }.bind(this));</code> </pre><br><br>  We simply took all the indexes and assigned them in turn to different cells of the field.  Now draw.  First of all, we need to create a common method that will ‚Äúpaint‚Äù the cell ‚Äî fill and draw with the necessary color.  If a line 1 pixel wide will be drawn in whole coordinates - it will blur <font color="#666">(see <a href="http://htmlbook.ru/html5/canvas">htmlbook.ru/html5/canvas</a> , the answer to the question "B. Why do we start x and yc 0.5, and not from 0?")</font> , We will use the experimental rectangle method <code>snapToPixel</code> <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... color: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell, fillStyle, strokeStyle)</span></span></span></span> { var strokeRect = cell.rectangle.clone().snapToPixel(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx .fill( cell.rectangle, fillStyle) .stroke( strokeRect, strokeStyle ); },</code> </pre><br><br>  Now in turn we add rendering methods.  Empty cage - just paint: <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... empty: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.color(ctx, cell, <span class="hljs-string"><span class="hljs-string">'#999'</span></span>, <span class="hljs-string"><span class="hljs-string">'#aaa'</span></span>); },</code> </pre><br><br>  Mina and the flag are just pictures on an empty cell: <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... mine: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this .empty(ctx, cell) .drawImage( this.images.get(<span class="hljs-string"><span class="hljs-string">'mine'</span></span>), cell.rectangle ); }, flag: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this .empty(ctx, cell) .drawImage( this.images.get(<span class="hljs-string"><span class="hljs-string">'flag'</span></span>), cell.rectangle ); },</code> </pre><br><br>  The mine on which we blew is drawn with a red background: <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... explode: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this .color(ctx, cell, <span class="hljs-string"><span class="hljs-string">'#c00'</span></span>, <span class="hljs-string"><span class="hljs-string">'#aaa'</span></span>) .drawImage( this.images.get(<span class="hljs-string"><span class="hljs-string">'mine'</span></span>), cell.rectangle ); },</code> </pre><br><br>  Incorrectly set flag - red cross.  It is easy to draw it.  First, we restrict the drawing within our rectangle with <code>clip</code> . <br>  Fill it with a background, and then draw two red lines - from the top-left to the bottom-right and from the bottom-left corner to the top-right. <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... wrong: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { var r = cell.rectangle; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.empty(ctx, cell) .save() .clip( r ) .set({ lineWidth: Math.round(cell.rectangle.width / <span class="hljs-number"><span class="hljs-number">8</span></span>) }) .stroke( new Line( r.from , r.to ), <span class="hljs-string"><span class="hljs-string">'#900'</span></span> ) .stroke( new Line( r.bottomLeft, r.topRight ), <span class="hljs-string"><span class="hljs-string">'#900'</span></span> ) .restore(); },</code> </pre><br><br>  A closed cell is also quite simple to draw - a gradient from dark to light, from the top-left corner to the bottom-right. <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... closed: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.fill( cell.rectangle, ctx.createGradient(cell.rectangle, { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-string"><span class="hljs-string">'#eee'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">'#aaa'</span></span> }) ); },</code> </pre><br><br>  And, actually, numbers.  First, add a list of colors for each digit to the prototype.  There is no zero, therefore we set zero. <br>  Please note that the first argument of the function is our <code>number</code> .  That is what we bind in the <code>createMethods</code> method. <br>  After that, draw the cell as empty, and on top, with the text, write the number. <br><br><pre> <code class="hljs lua">/** @class Mines.View */ // ... numberColors: [null, <span class="hljs-string"><span class="hljs-string">'#009'</span></span>, <span class="hljs-string"><span class="hljs-string">'#060'</span></span>, <span class="hljs-string"><span class="hljs-string">'#550'</span></span>, <span class="hljs-string"><span class="hljs-string">'#808'</span></span>, <span class="hljs-string"><span class="hljs-string">'#900'</span></span>, <span class="hljs-string"><span class="hljs-string">'#555'</span></span>, <span class="hljs-string"><span class="hljs-string">'#055'</span></span>, <span class="hljs-string"><span class="hljs-string">'#000'</span></span> ], number: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number, ctx, cell)</span></span></span></span> { var size = Math.round(cell.rectangle.height * <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.empty(ctx, cell) .text({ text : number, color : this.numberColors[number], size : size, lineHeight: size, weight: <span class="hljs-string"><span class="hljs-string">'bold'</span></span>, align : <span class="hljs-string"><span class="hljs-string">'center'</span></span>, to : cell.rectangle }); }</code> </pre><br><br>  Our implementation allows us to change the size of the cells and they will look great anyway: <br><br><img src="https://habrastorage.org/storage2/b12/4ff/1e9/b124ff1e91a22fad7c68c04a8e56e07f.png"><br><br><h2>  Min generator </h2><br>  As you can see, the drawing is completely ready.  Now we just need to make a simple action and the cell will change its appearance. <br><br>  Delete our debugging code and create a generator instance: <br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** @class Mines.Controller */</span></span> // .. <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (images) { this.images = images; this.size = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); this.mines = <span class="hljs-number"><span class="hljs-number">20</span></span>; this.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Mines.<span class="hljs-keyword"><span class="hljs-keyword">View</span></span>( this, this.size ); this.generator = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Mines.Generator( this.size, this.mines ); }</code> </pre><br><br>  To begin, learn to scatter mines in the field.  Of course, it would be nice to take into account any doubtful situations, but so far we have one requirement for it - to generate the field after the first user click, so that it does not immediately fall on a mine. <br><br><img src="https://habrastorage.org/storage2/4de/eed/e8a/4deeede8a775c77b53bbaf4561dd8163.png"><br><br>  We will have a very simple algorithm for generating mines - we create a list of valid points (all except the one we clicked on) - the <code>snapshot</code> method, then ‚Äúpull‚Äù the necessary number of random ones out of them - the <code>createMines</code> method: <br><pre> <code class="hljs php"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@class</span></span></span><span class="hljs-comment"> Mines.Generator */</span></span> atom.<span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>( <span class="hljs-string"><span class="hljs-string">'Mines.Generator'</span></span>, { mines: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, initialize: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fieldSize, minesCount)</span></span></span><span class="hljs-function"> </span></span>{ this.fieldSize = fieldSize; this.minesCount = minesCount; }, <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@private</span></span></span><span class="hljs-comment"> */</span></span> snapshot: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ignore)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y, point, result = [], size = this.fieldSize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (y = size.height; y--;) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x = size.width; x--;) { point = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!point.equals(ignore)) { result.push(point); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }, <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@private</span></span></span><span class="hljs-comment"> */</span></span> createMines: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(count, ignore)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snapshot = this.snapshot( ignore ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atom.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.create(count, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapshot.popRandom(); }); } });</code> </pre><br><br>  The next step is to add an api-method that will be called to generate these mines and index them for quick access.  Create a two-dimensional hash with values ‚Äã‚Äãof 1, where mine is and 0, where there are no mines.  It is important for us to use Integer, the reason we will see below.  Now we have a quick <code>isMine</code> method to determine if there is a mine by coordinate.  The <code>isReady</code> method will be used to tell external classes whether a minefield has already been generated. <br><br><pre> <code class="hljs markdown">/<span class="hljs-emphasis"><span class="hljs-emphasis">** @class Mines.Generator *</span></span>/ // .. isReady: function () { return this.mines != null; }, isMine: function (point) { return this.mines[<span class="hljs-string"><span class="hljs-string">point.y</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">point.x</span></span>]; }, generate: function (ignore) { var mines, minesIndex, size = this.fieldSize; mines = this.createMines(this.minesCount, ignore); minesIndex = atom.array.fillMatrix(size.width, size.height, 0); mines.forEach(function (point) { minesIndex[<span class="hljs-string"><span class="hljs-string">point.y</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">point.x</span></span>] = 1; }); this.mines = minesIndex; },</code> </pre><br><br>  The next step is to get the cell value if there is no mine there.  The algorithm is very simple - we take all the neighbors that do not go beyond the field, we consider the sum of their values.  It is in this place that the mine is an Integer and was useful to us. <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** @class Mines.Generator */</span></span> // .. initialize: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (fieldSize, minesCount) { //       ,      this.bindMethods([ <span class="hljs-string"><span class="hljs-string">'isValidPoint'</span></span>, <span class="hljs-string"><span class="hljs-string">'isMine'</span></span> ]); // .. getValue: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>) { //    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.getNeighbours(<span class="hljs-type"><span class="hljs-type">point</span></span>) //      (<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(this.isMine) //       .sum(); }, // ,        isValidPoint: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>.x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-type"><span class="hljs-type">point</span></span>.y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-type"><span class="hljs-type">point</span></span>.x &lt; this.fieldSize.width &amp;&amp; <span class="hljs-type"><span class="hljs-type">point</span></span>.y &lt; this.fieldSize.height; }, //   -   ,  ,     getNeighbours: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>.neighbours.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>( this.isValidPoint ); },</code> </pre><br><br><h2>  User interaction </h2><br>  We have a game engine, now you need to make all this a game, not just logic.  Create an <code>Action</code> class that will be responsible for all user actions.  The first thing we do is react to a user‚Äôs click.  With <code>TileEngine.Mouse</code> we will listen to mouse events associated with the field.  We hang <code>Mouse.prevent</code> on the <code>'contextmenu'</code> event so that the annoying menu does not pop up.  When clicking we check the button.  The left mouse button is 0, the middle one is 1, the right one is 2. Recall that in the original game the left click meant opening the cage, the middle shouting revealed all others, and the right click showed mines. <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** @class Mines.Controller */</span></span> // .. <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (images) { // .. this.action = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Mines.Action(this); }</code> </pre><br><br><pre> <code class="hljs javascript"><span class="hljs-comment"><span class="hljs-comment">/** @class Mines.Action */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'Mines.Action'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: [ <span class="hljs-string"><span class="hljs-string">'open'</span></span>, <span class="hljs-string"><span class="hljs-string">'all'</span></span>, <span class="hljs-string"><span class="hljs-string">'close'</span></span> ], <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.controller = controller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindMouse(); }, <span class="hljs-attr"><span class="hljs-attr">bindMouse</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view, mouse; view = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.controller.view; mouse = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mouse(view.app.container.bounds); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App.MouseHandler({ <span class="hljs-attr"><span class="hljs-attr">mouse</span></span>: mouse, <span class="hljs-attr"><span class="hljs-attr">app</span></span>: view.app }) .subscribe( view.element ); mouse.events.add( <span class="hljs-string"><span class="hljs-string">'contextmenu'</span></span>, Mouse.prevent ); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TileEngine.Mouse( view.element, mouse ).events .add( <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell, e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activate(cell, e.button); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }, <span class="hljs-attr"><span class="hljs-attr">activate</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell, actionCode</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( cell.point.dump(), actionCode ); } });</code> </pre><br><br>  Add the first interactivity.  We will receive by index the name of the method that needs to be called, and at the same time we will write the simplest method - <code>close</code> .  If the cell is closed, then set the flag on it, if the flag is already on the cell, then mark it closed.  Now you can see the first interaction - the flag on the cell appears by the right mouse button. <br><br><pre> <code class="hljs lua">/** @class Mines.Action */ // ... activate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell, actionCode)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof actionCode == <span class="hljs-string"><span class="hljs-string">'number'</span></span>) { actionCode = this.actions[actionCode]; } this[actionCode](cell); }, <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value == <span class="hljs-string"><span class="hljs-string">'closed'</span></span>) { cell.value = <span class="hljs-string"><span class="hljs-string">'flag'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value == <span class="hljs-string"><span class="hljs-string">'flag'</span></span>) { cell.value = <span class="hljs-string"><span class="hljs-string">'closed'</span></span>; } }, <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { }, all: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { }</code> </pre><br><br>  Now we describe the opening of the cell.  For starters, open only those cells that are closed.  There is nothing to interact with all sorts of static numbers and flags.  Second, we check whether our mines are ready and, if not, start the generator. <br><br>  If the mine is open, we call the <code>lose</code> method, where we mark the cell as exploded. <br>  If there is a number in the cell, then we simply write it, no other actions can be done with this cell. <br>  If the cell is empty, we need to recursively open all the cells around, so while creating a method and mark the cell as empty. <br><br><pre> <code class="hljs lua">/** @class Mines.Action */ // ... <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value != <span class="hljs-string"><span class="hljs-string">'closed'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; var value, gen = this.controller.generator; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gen.isReady()) { gen.generate(cell.point); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gen.isMine(cell.point)) { this.lose(cell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = gen.getValue(cell.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { cell.value = value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.openEmpty(cell); } } }, lose: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cell.value = <span class="hljs-string"><span class="hljs-string">'explode'</span></span>; }, openEmpty: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { cell.value = <span class="hljs-string"><span class="hljs-string">'empty'</span></span>; },</code> </pre><br><br>  To open all the cells around the empty one, we just get the neighbors and pass to the <code>open</code> method.  We will use this for recursive opening of empty cells and for quick opening by the middle mouse button. <br><br><pre> <code class="hljs lua">/** @class Mines.Action */ // ... openNeighbours: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { this.controller.generator .getNeighbours(cell.point) .forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point)</span></span></span></span> { this.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>( this.getCell(point) ); }.bind(this)); }, openEmpty: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { cell.value = <span class="hljs-string"><span class="hljs-string">'empty'</span></span>; this.openNeighbours(cell); }, getCell: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.controller.view.engine.getCellByIndex(point); }, all: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parseInt(cell.value)) { this.openNeighbours(cell); } },</code> </pre><br><br>  We lose the game in the following way - we go through all the cells where we were locked and in fact there was a mine - we draw a mine.  Where we had a flag, but in fact there are no mines - we display an error.  We also block the <code>open</code> and <code>close</code> methods after losing. <br><br><pre> <code class="hljs lua">/** @class Mines.Action */ // ... lost: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, lose: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { this.lost = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; cell.value = <span class="hljs-string"><span class="hljs-string">'explode'</span></span>; this.controller.view.engine.cells .forEach(this.checkCell.bind(this)); }, checkCell: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value == <span class="hljs-string"><span class="hljs-string">'closed'</span></span> || cell.value == <span class="hljs-string"><span class="hljs-string">'flag'</span></span>) { var isMine = this.controller.generator.isMine(cell.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMine &amp;&amp; cell.value == <span class="hljs-string"><span class="hljs-string">'closed'</span></span>) { cell.value = <span class="hljs-string"><span class="hljs-string">'mine'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isMine &amp;&amp; cell.value == <span class="hljs-string"><span class="hljs-string">'flag'</span></span>) { cell.value = <span class="hljs-string"><span class="hljs-string">'wrong'</span></span>; } } }, // ... <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.lost) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; // ... <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cell)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.lost) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; // ...</code> </pre><br><br><img src="http://habrastorage.org/storage2/567/62b/32c/56762b32c5c67733cb4c0879c1301fa3.png"><br><br><h2>  Victory! </h2><br>  It remains to display the victory, elapsed time and display the number of mines that are left to open.  We will not bother with the appearance, we will use the geeky, but working <code>atom.trace</code> .  Get the number of minutes.  Calculate the number of empty cells - this is the number of cells just minus the number of minutes.  Each time a cell is opened, we will decrease the value of empty cells by one.  When they reach zero - the game is won.  Let us draw the canvas and with a slight delay display the alert to the user. <br><br><pre> <code class="hljs ruby">/** @class Mines.Action *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... initialize: function (controller) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... this.startTime = null; this.minesLeft = controller.mines; this.minesTrace = atom.trace(0); this.changeMines(0); this.emptyCells = controller.size.width * controller.size.height - this.minesLeft; }, changeMines: function (delta) { this.minesLeft += delta; this.minesTrace.value = "Mines: " + this.minesLeft; }, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... open: function (cell) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... if (!gen.isReady()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... this.startTime = Date.now(); } if (gen.isMine(cell.point)) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... } else { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... if (--this.emptyCells == 0) { this.win(); } } }, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... win: function () { var time = Math.round( (Date.now()-this.startTime) /</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> ); alert.delay(<span class="hljs-number"><span class="hljs-number">100</span></span>, window, [<span class="hljs-string"><span class="hljs-string">'Congratulations! Mines has been neutralized in '</span></span>+ time +<span class="hljs-string"><span class="hljs-string">' sec!'</span></span>]); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-symbol"><span class="hljs-symbol">close:</span></span> function (cell) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value == <span class="hljs-string"><span class="hljs-string">'closed'</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... this.changeMines(-<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.value == <span class="hljs-string"><span class="hljs-string">'flag'</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... this.changeMines(+<span class="hljs-number"><span class="hljs-number">1</span></span>); } },</code> </pre><br><br><h2>  <a href="http://libcanvas.github.com/games/mines/">Play sapper</a> </h2></div><p>Source: <a href="https://habr.com/ru/post/168435/">https://habr.com/ru/post/168435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168419/index.html">How many English words do you know?</a></li>
<li><a href="../168421/index.html">Life on the Lobachevsky plane</a></li>
<li><a href="../168423/index.html">Bitcasa out of beta</a></li>
<li><a href="../168425/index.html">Transition from Java to Scala (Clojure, Haskell, Erlang ..) as an increase in programming abstraction</a></li>
<li><a href="../168433/index.html">Counter-Strike: Source released under Linux</a></li>
<li><a href="../168439/index.html">Jevix library for Python</a></li>
<li><a href="../168441/index.html">Announced stable release of MySQL 5.6</a></li>
<li><a href="../168443/index.html">Australian court decided that Google is not responsible for advertising on its pages.</a></li>
<li><a href="../168445/index.html">Has the government refused to build the Death Star? Well, we have a kickstarter!</a></li>
<li><a href="../168447/index.html">HP Board of Directors is considering dividing a company</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>