<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Personalize IMGUI and Unity Editor. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More than a year has passed since the release of the Unity UI system, so Richard Fine decided to write about its predecessor, IMGUI. In the last part ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Personalize IMGUI and Unity Editor. Part two</h1><div class="post__text post__text-html js-mediator-article">  More than a year has passed since the release of the Unity UI system, so Richard Fine decided to write about its predecessor, IMGUI.  In the last part of the material we covered how to create a MyCustomSlider.  We have a simple functional element IMGUI, which can be used in custom editors, PropertyDrawers, EditorWindows, etc. But this is not all.  In the second part of the article we will talk about how to expand its functionality, for example, add the ability to multi-edit. <br><br><img src="https://habrastorage.org/files/59a/333/b26/59a333b26acd4d06a62c3f0a21e28c77.jpg"><br><a name="habracut"></a><br><br>  <b>Control functions</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another important point is the relationship of IMGUI with the Scene View component.  You must be familiar with auxiliary UI elements, such as orthogonal arrows, rings, or lines that allow you to move, rotate, and scale objects.  These elements are called control functions.  Interestingly, they are also supported in IMGUI. <br><br>  The standard GUI and EditorGUI class elements used in Unity Editor / EditorWindows are two-dimensional, but the basic concepts of IMGUI, such as control identifiers and event types, are not tied to either the Unity editor or 2D.  The control functions for the three-dimensional Scene View elements are represented by the <a href="http://docs.unity3d.com/ScriptReference/Handles.html">Handles</a> class, which replaces the GUI and EditorGUI.  For example, instead of the <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.IntField.html">EditorGUI.IntField</a> function that creates an element for editing a single integer, you can use the function that allows you to edit the value of Vector3 using the interactive arrows in Scene View: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PositionHandle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Quaternion rotation</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><br>  Control functions can also be used to create custom interface elements.  In this case, the basic concepts remain the same as when creating elements of the editor, although interaction with the mouse is somewhat complicated: in a three-dimensional environment, it is not enough to simply check that the coordinates of the cursor correspond to the rectangle.  This is where the <a href="http://docs.unity3d.com/ScriptReference/HandleUtility.html">HandleUtility</a> class <a href="http://docs.unity3d.com/ScriptReference/HandleUtility.html">comes in handy.</a> <br><br>  By writing the OnSceneGUI function in the custom class of the editor, you can use the control functions in the editors, and the functions from the GUI in the Scene View.  To do this, you will have to make additional efforts: install GL-matrices or use <a href="http://docs.unity3d.com/ScriptReference/Handles.BeginGUI.html">Handles.BeginGUI ()</a> and <a href="http://docs.unity3d.com/ScriptReference/Handles.EndGUI.html">Handles.EndGUI ()</a> to set the context. <br><br>  <b>State objects</b> <br><br>  In the case of MyCustomSlider, we needed to track 2 things: the floating value of the slider (which was transmitted by the user and returned to it) and the change of the slider at a specific point in time (for this we used the hotControl element).  But what if the item contains much more information? <br><br>  IMGUI provides a simple storage system for so-called state objects associated with interface elements.  To do this, define a new class that will be used to store data, and associate a new object with the control identifier.  Each object can be assigned no more than one identifier, and IMGUI does it by itself - using the built-in constructor.  When you load the editor code, such objects are not serialized (even if the [Serializable] label is set), so they cannot be used for long-term data storage. <br><br>  Suppose we need a button that returns TRUE each time it is pressed, but turns red when holding it for longer than two seconds.  To track the time a button is pressed, we use the state object.  Let's declare a class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FlashingButtonInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mouseDownAt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MouseDownNow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { mouseDownAt = EditorApplication.timeSinceStartup; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsFlashing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> controlID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUIUtility.hotControl != controlID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> elapsedTime = EditorApplication.timeSinceStartup - mouseDownAt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elapsedTime &lt; <span class="hljs-number"><span class="hljs-number">2f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((elapsedTime - <span class="hljs-number"><span class="hljs-number">2f</span></span>) / <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br>  The time a button is pressed will be stored in the mouseDownAt property when MouseDownNow () is called, and the IsFlashing function will determine whether the button should be red-lit at the moment.  Naturally, if hotControl is not involved or less than two seconds have passed since the button was pressed, the button will not light up.  But otherwise, its color will change every 0.1 seconds. <br><br>  Now we will write the code for the button itself: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlashingButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Rect rc, GUIContent content, GUIStyle style</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> controlID = GUIUtility.GetControlID (FocusType.Native); <span class="hljs-comment"><span class="hljs-comment">// Get (or create) the state object var state = (FlashingButtonInfo)GUIUtility.GetStateObject( typeof(FlashingButtonInfo), controlID); switch (Event.current.GetTypeForControl(controlID)) { case EventType.Repaint: { GUI.color = state.IsFlashing (controlID) ? Color.red : Color.white; style.Draw (rc, content, controlID); break; } case EventType.MouseDown: { if (rc.Contains (Event.current.mousePosition) &amp;&amp; Event.current.button == 0 &amp;&amp; GUIUtility.hotControl == 0) { GUIUtility.hotControl = controlID; state.MouseDownNow(); } break; } case EventType.MouseUp: { if (GUIUtility.hotControl == controlID) GUIUtility.hotControl = 0; break; } } return GUIUtility.hotControl == controlID; }</span></span></code> </pre><br><br>  Everything is very simple.  Note that the code snippets for the response to mouseDown and mouseUp are very similar to those we used earlier to handle the capture of the slider in the scroll bar.  The only differences are the state.MouseDownNow () call when the mouse button is pressed, and the GUI.color value is changed when the button is redrawn. <br><br>  You may have noticed another difference related to the redraw event, namely the style.Draw () call.  This is worth talking in more detail. <br><br>  <b>GUI styles</b> <br><br>  When creating our first element, we used <a href="http://docs.unity3d.com/ScriptReference/GUI.DrawTexture.html">GUI.DrawTexture</a> to draw the slider itself.  But with the FlashingButton element, everything is not so simple - the button should include not only an image in the form of a rounded rectangle, but also an inscription.  We could try to draw a button using GUI.DrawTexture and place GUI.Label on top of it, but there is a better way.  Let's try to use the <a href="http://docs.unity3d.com/ScriptReference/GUI.Label.html">GUI.Label</a> image drawing technique without using the GUI.Label itself. <br><br>  The <a href="http://docs.unity3d.com/ScriptReference/GUIStyle.html">GUIStyle</a> class contains information about the visual properties of an interface element: from font and text color to the spacing between elements.  In addition, GUIStyle stores functions used to determine the width and height of objects using a style, as well as to directly draw elements on the screen. <br><br>  GUIStyle can include different styles for drawing an element: when the cursor is hovering over it, when it has received keyboard focus, when it is disabled or when it is active (with the mouse button held down).  For any state, you can define a color and a background image, and GUIStyle will substitute them when drawing an element, based on its control ID. <br><br>  There are 4 ways to use GUIStyles for drawing interface elements: <br><br>  ‚Ä¢ Write a new style (new GUIStyle ()), setting the required values. <br>  ‚Ä¢ Use one of the built-in styles of the <a href="http://docs.unity3d.com/ScriptReference/EditorStyles.html">EditorStyles</a> class (if you want your custom elements to look like standard). <br>  ‚Ä¢ If you need to slightly change the existing style, for example, align the button text to the right.  You can copy the desired style of the EditorStyles class and change the desired property manually. <br>  ‚Ä¢ Extract style from <a href="http://docs.unity3d.com/ScriptReference/GUISkin.html">GUISkin</a> . <br><br>  GUISkin is a large collection of GUIStyle objects that can be created in the project itself as a separate resource and edited using the Unity Inspector.  Having created a new GUISkin and opening it, you will see slots for all standard interface elements: buttons, text boxes, switches, etc. But the section on user styles is of particular interest.  Here you can put any number of GUIStyle objects with unique names that can be retrieved using the <a href="http://docs.unity3d.com/ScriptReference/GUISkin.GetStyle.html">GUISkin.GetStyle (‚Äústyle_name‚Äù)</a> method.  It remains to figure out how to load GUISkin objects from code.  There are several ways to do this.  If the object is in the Editor Default Resources folder, use the <a href="http://docs.unity3d.com/ScriptReference/EditorGUIUtility.LoadRequired.html">EditorGUIUtility.LoadRequired ()</a> function;  to load from another directory use <a href="http://docs.unity3d.com/ScriptReference/AssetDatabase.LoadAssetAtPath.html">AssetDatabase.LoadAssetAtPath ()</a> .  The main thing - in no case do not put resources intended only for the editor, in resource packages or in the Resources folder. <br><br>  Now that we have a GUIStyle, we can draw a <a href="http://docs.unity3d.com/ScriptReference/GUIContent.html">GUIContent</a> containing the desired text, image, and tooltip using <a href="http://docs.unity3d.com/ScriptReference/GUIStyle.Draw.html">GUIStyle.Draw ()</a> .  The arguments are the coordinates of the rectangle in which the drawing is performed, the GUIContent itself and the control identifier. <br><br>  <b>IMGUI markup</b> <br><br>  You may have noticed that each of the interface elements we examined had a Rect parameter that determines its position on the screen.  At the same time, we just talked about the fact that GUIStyle includes markup properties.  This begs the question: do you really need to manually calculate all the values ‚Äã‚Äãof Rect, taking into account the peculiarities of the markup?  In principle, it is possible.  But IMGUI offers a simpler solution - a markup engine that does this automatically. <br><br>  For this there is a special type of event - EventType.Layout.  After IMGUI sends such an event to the interface, its elements call markup functions: <a href="http://docs.unity3d.com/ScriptReference/GUILayoutUtility.GetRect.html">GUILayoutUtility.GetRect ()</a> , <a href="http://docs.unity3d.com/ScriptReference/GUILayout.BeginHorizontal.html">GUILayout.BeginHorizontal</a> / <a href="http://docs.unity3d.com/ScriptReference/GUILayout.BeginVertical.html">Vertical</a> , and <a href="http://docs.unity3d.com/ScriptReference/GUILayout.EndHorizontal.html">GUILayout.EndHorizontal</a> / <a href="http://docs.unity3d.com/ScriptReference/GUILayout.EndVertical.html">Vertical</a> and others.  IMGUI remembers the results of these calls as a tree that contains all the interface elements and the space they need.  After the tree is built, it is recursively traversed, during which the sizes of the elements and their position relative to each other are calculated. <br><br>  When any other event is fired, for example EventType.Repaint, the elements call the markup functions again.  But this time IMGUI repeats the ‚Äúrecorded‚Äù calls and returns the finished rectangles.  In other words, if during the Layout event the parameters of the rectangles have already been calculated using the GUILayoutUtility.GetRect () function, when another event is triggered, it will simply substitute the previously saved result. <br><br>  By analogy with identifiers of control elements, when executing a Layout event and other events, it is important to follow the order of calls to markup functions so that elements do not receive data from foreign rectangles.  It is also worth considering that the values ‚Äã‚Äãreturned by the GUILayoutUtility.GetRect () call during the Layout event are useless, since IMGUI will not know which element each rectangle corresponds to until the end of the event and the processing of the tree. <br><br>  So let's add some markup for our bar with a slider.  This is easy: by getting a square from IMGUI, we can call the ready code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCustomSlider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, GUIStyle style</span></span></span><span class="hljs-function">)</span></span> { Rect position = GUILayoutUtility.GetRect(GUIContent.none, style); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyCustomSlider(position, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, style); }</code> </pre><br><br>  If GUILayoutUtility.GetRect is called during the Layout event, IMGUI remembers that a certain style is needed for empty content (empty because no image or text is specified for it).  During other events, GetRect returns an existing rectangle.  It turns out that during the Layout event our element MyCustomSlider will be called with an irregular rectangle, but this is unimportant, because without it we still cannot call GetControlID (). <br><br>  All data on the basis of which IMGUI determines the size of the rectangle is contained in the style.  But what if the user wants to set one or more parameters manually? <br><br>  To do this, use the class <a href="http://docs.unity3d.com/ScriptReference/GUILayoutOption.html">GUILayoutOption</a> .  Objects of this class are a kind of instructions for the marking system, indicating how exactly the rectangle should be calculated (for example, have a certain height / width value or fill the available space vertically / horizontally).  To create such an object, you need to call the factory functions of the class GUILayout, such as <a href="http://docs.unity3d.com/ScriptReference/GUILayout.ExpandWidth.html">GUILayout.ExpandWidth ()</a> or <a href="http://docs.unity3d.com/ScriptReference/GUILayout.MinHeight.html">GUILayout.MinHeight ()</a> , and transfer them to GUILayoutUtility.GetRect () as an array.  They are then stored in the markup tree and taken into account when processing it. <br><br>  Instead of creating custom arrays from GUILayoutOption objects, we use the C # params keyword, which allows you to call a method with any number of parameters from which an array is automatically constructed.  Here is the new feature of our band: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCustomSlider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, GUIStyle style, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GUILayoutOption[] opts</span></span></span><span class="hljs-function">)</span></span> { Rect position = GUILayoutUtility.GetRect(GUIContent.none, style, opts); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyCustomSlider(position, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, style); }</code> </pre><br><br>  As you can see, all data entered by the user is passed straight to GetRect. <br><br>  A similar method of combining the function of an IMGUI element with a version of the same function using automatic markup placement is applicable to any IMGUI element, including the built-in GUI class.  It turns out that the <a href="http://docs.unity3d.com/ScriptReference/GUILayout.html">GUILayout</a> class provides hosted versions of elements from the GUI class (and we use the <a href="http://docs.unity3d.com/ScriptReference/EditorGUILayout.html">EditorGUILayout</a> class corresponding to the EditorGUI). <br><br>  In addition, elements placed automatically and manually can be combined.  The space is reserved using GetRect, after which it can be divided into separate sections for different elements.  The markup system does not use control identifiers, so several elements can be placed on one rectangle (or vice versa).  Sometimes this approach works much faster than with fully automatic placement. <br><br>  Note that when writing PropertyDrawers it is not recommended to use markup; instead, it is better to use a rectangle passed to the PropertyDrawer.OnGUI () overload.  The point is that the Editor class itself does not use markup, but computes a simple rectangle that shifts down for each next property.  Therefore, if markup is used for PropertyDrawer, the Editor will not know about the previous properties and, therefore, will not place the rectangle correctly. <br><br>  <b>Using serialized properties</b> <br><br>  So, you can already create your own IMGUI element.  It remains to discuss a couple of points that will help bring it to the Unity quality standard. <br><br>  First is the use of <a href="http://docs.unity3d.com/ScriptReference/SerializedProperty.html">SerializedProperty</a> .  We'll talk about the serialization system in more detail in the next article, but for now let's summarize: the SerializedProperty interface allows you to access any property that the Unity serialization system (load and save) is connected to.  Thus, we can use any variable from scripts or objects displayed in the Unity Inspector. <br>  SerializedProperty provides access not only to the value of a variable, but also to various kinds of information, for example, comparing the current and initial values ‚Äã‚Äãof a variable or the state of a variable with its child fields in the Inspector window (minimized / expanded).  In addition, the interface integrates any user-defined variable value changes into the Undo and scene-dirtying systems.  It does not use a managed version of the object, which has a positive effect on performance.  Therefore, the use of SerializedProperty is necessary for the full functioning of any complex interface elements. <br><br>  The signature of EditorGUI class methods that take SerializedProperty objects as arguments is somewhat different from the usual one.  Such methods do not return anything, because changes are made directly to the SerializedProperty.  An improved version of our band will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCustomSlider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Rect controlRect, SerializedProperty prop, GUIStyle style</span></span></span><span class="hljs-function">)</span></span></code> </pre><br><br>  Now we have no value parameter, prop is passed instead to SerializedProperty.  With <a href="http://docs.unity3d.com/ScriptReference/SerializedProperty-floatValue.html">prop.floatValue,</a> we can retrieve the value of the floating number when drawing the strip and change it when dragging the slider. <br><br>  There are other benefits of using SerializedProperty in IMGUI code.  Suppose the value of <a href="http://docs.unity3d.com/ScriptReference/SerializedProperty-prefabOverride.html">prefabOverride</a> shows changes in the value of a property in a template object.  By default, the modified properties are in bold, but we can set a different display style using GUIStyle. <br><br>  Another important possibility is editing multiple objects, that is, displaying several values ‚Äã‚Äãat once with the help of a single element.  If <a href="http://docs.unity3d.com/ScriptReference/EditorGUI-showMixedValue.html">EditorGUI.showMixedValue is</a> set to TRUE, the item is used to display multiple values. <br>  Using the prefabOverride and showMixedValue mechanisms requires setting the context for a property using <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.BeginProperty.html">EditorGUI.BeginProperty ()</a> and <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.EndProperty.html">EditorGUI.EndProperty ()</a> .  As a rule, if an element's method accepts an argument of the SerializedProperty class, it must itself call BeginProperty and EndProperty.  If it accepts ‚Äúpure‚Äù values ‚Äã‚Äã(for example, the EditorGUI.IntField method, which accepts an int and does not work with properties), calls to BeginProperty and EndProperty should be contained in the code that calls this method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MySliderDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertyHeight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializedProperty property, GUIContent label</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EditorGUIUtility.singleLineHeight; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GUISkin _sliderSkin; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sliderSkin == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) _sliderSkin = (GUISkin)EditorGUIUtility.LoadRequired (<span class="hljs-string"><span class="hljs-string">"MyCustomSlider Skin"</span></span>); MyCustomSlider (position, property, _sliderSkin.GetStyle (<span class="hljs-string"><span class="hljs-string">"MyCustomSlider"</span></span>), label); } } <span class="hljs-comment"><span class="hljs-comment">// Then, the updated definition of MyCustomSlider: public static void MyCustomSlider(Rect controlRect, SerializedProperty prop, GUIStyle style, GUIContent label) { label = EditorGUI.BeginProperty (controlRect, label, prop); controlRect = EditorGUI.PrefixLabel (controlRect, label); // Use our previous definition of MyCustomSlider, which we've updated to do something // sensible if EditorGUI.showMixedValue is true EditorGUI.BeginChangeCheck(); float newValue = MyCustomSlider(controlRect, prop.floatValue, style); if(EditorGUI.EndChangeCheck()) prop.floatValue = newValue; EditorGUI.EndProperty (); }</span></span></code> </pre><br><br>  <b>Conclusion</b> <br><br>  I hope this article will help you understand the basics of IMGUI.  To become a true professional, you have to master many other aspects: the SerializedObject / SerializedProperty system, the features of working with CustomEditor / EditorWindow / PropertyDrawer, the use of the Undo class, etc. Anyway, IMGUI allows you to unlock the widest potential of Unity to create custom tools for sale on the Asset Store or personal use. </div><p>Source: <a href="https://habr.com/ru/post/278213/">https://habr.com/ru/post/278213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278199/index.html">Features support 10 data centers around the world: my experience and rake</a></li>
<li><a href="../278201/index.html">Intel has prepared a working prototype of the 5G platform</a></li>
<li><a href="../278205/index.html">360 Total Security welcomes Habrahabr</a></li>
<li><a href="../278207/index.html">CMake - create dynamic libraries</a></li>
<li><a href="../278209/index.html">Kaspersky Security Center - the struggle for automation</a></li>
<li><a href="../278217/index.html">The book "Paradox. Nine great mysteries of physics "</a></li>
<li><a href="../278219/index.html">ORegex: From characters to objects</a></li>
<li><a href="../278221/index.html">Hacker has published data of SIM-cards and accounts of 3 million subscribers of a major African operator</a></li>
<li><a href="../278223/index.html">Using PowerShell to work with Veeam Backup Free Edition</a></li>
<li><a href="../278227/index.html">The digest of interesting materials from the world of Drupal # 18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>