<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple Stream implementation from Java 8 to C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! The article will present a simplified implementation of Stream from Java 8 in C ++. I will say right away that: 


- Unlike Java, deferred calc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple Stream implementation from Java 8 to C ++</h1><div class="post__text post__text-html js-mediator-article"><p> Hello!  The article will present a simplified implementation of <code>Stream</code> from Java 8 in C ++.  I will say right away that: </p><br><ul><li>  Unlike Java, deferred calculations are not used. </li><li>  no parallel versions; </li><li>  sometimes combines <code>Stream</code> and <code>Collectors</code> ; </li><li>  simple and ready-made solutions from STL are used, there is no pure OP, where only recursion is present; </li><li>  optimization techniques are not used. </li></ul><br><p>  In this version, the main focus is on making a bicycle quickly and simply).  About FP is mentioned to a minimum (attention is not paid to combinators :)). </p><br><h2>  Interface </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stream</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StreamImpl&lt;Type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> StreamImpl&lt;Type&gt; Parent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::Parent; <span class="hljs-comment"><span class="hljs-comment">//   using Parent::data; using Parent::isEmpty; using Parent::count; using Parent::flatMap; using Parent::map; using Parent::reduce; using Parent::filter; using Parent::allMatch; using Parent::noneMatch; using Parent::groupingBy; using Parent::partitionBy; using Parent::minElement; using Parent::maxElement; ~Stream() = default; };</span></span></code> </pre> <a name="habracut"></a><br><p>  Here you can add simple static type checks: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_copy_assignable&lt;Type&gt;::value, <span class="hljs-string"><span class="hljs-string">"Type is not copy assignable"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_default_constructible&lt;Type&gt;::value, <span class="hljs-string"><span class="hljs-string">"Type is not default constructible"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_copy_constructible&lt;Type&gt;::value, <span class="hljs-string"><span class="hljs-string">"Type is not"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_volatile&lt;Type&gt;::value, <span class="hljs-string"><span class="hljs-string">"volatile data can't be used in Stream"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>&gt;::value, <span class="hljs-string"><span class="hljs-string">"Stream can't used with nullptr"</span></span>);</code> </pre> <br><p>  Actually, it remains to consider what <code>StreamImpl</code> . </p><br><h2>  Streamreaml </h2><br><p>  <code>Stream</code> works with containers or container-like types (such as <code>QString</code> , <code>QByteArray</code> , etc.).  Containers in turn may consist of containers.  The container with non-container data will be terminal for functions of type <code>flatMap</code> </p><br><p>  Define <code>StreamImpl</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isContainer = Private::is_nested_stl_compatible_container&lt;ContainerType&gt;::value&gt; class StreamImpl;</code> </pre> <br><p>  Where <code>is_nested_stl_compatible_container</code> is an auxiliary <code>is_nested_stl_compatible_container</code> - <code>is_nested_stl_compatible_container</code> for defining the container's ‚Äúcontainer‚Äù (SFINAE helps with this): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_iterator</span></span></span><span class="hljs-class"> {</span></span> DECLARE_SFINAE_TESTER(Unref, T, t, *t) DECLARE_SFINAE_TESTER(Incr, T, t, ++t) DECLARE_SFINAE_TESTER(Decr, T, t, --t) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ContainerType Type; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = GET_SFINAE_RESULT(Unref, Type) &amp;&amp; (GET_SFINAE_RESULT(Incr, Type) || GET_SFINAE_RESULT(Decr, Type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_stl_compatible_container</span></span></span><span class="hljs-class"> {</span></span> DECLARE_SFINAE_TESTER(Begin, T, t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cbegin(t)) DECLARE_SFINAE_TESTER(End, T, t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cend(t)) DECLARE_SFINAE_TESTER(ValueType, T, t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type)) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ContainerType Type; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = GET_SFINAE_RESULT(Begin, Type) &amp;&amp; GET_SFINAE_RESULT(End, Type) &amp;&amp; GET_SFINAE_RESULT(ValueType, Type); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_nested_stl_compatible_container</span></span></span><span class="hljs-class"> {</span></span> DECLARE_SFINAE_TESTER(ValueType, T, t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type::value_type)) <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ContainerType Type; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = is_stl_compatible_container&lt;Type&gt;::value &amp;&amp; GET_SFINAE_RESULT(ValueType, Type); }; }</code> </pre> <br><p>  Consider the organization of the SFINAE tester: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECLARE_SFINAE_BASE(Name, ArgType, arg, testexpr) \ typedef char SuccessType; \ typedef struct { SuccessType a[2]; } FailureType; \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename ArgType&gt; \ static decltype(auto) test(ArgType &amp;&amp;arg) \ -&gt; decltype(testexpr, SuccessType()); \ static FailureType test(...); #define DECLARE_SFINAE_TESTER(Name, ArgType, arg, testexpr) \ struct Name { \ DECLARE_SFINAE_BASE(Name, ArgType, arg, testexpr) \ }; #define GET_SFINAE_RESULT(Name, Type) (sizeof(Name::test(std::declval&lt;Type&gt;())) == \ sizeof(typename Name::SuccessType))</span></span></span></span></code> </pre> <br><p>  The SFINAE tester uses SFINAE by type and SFINAE by expression. </p><br><p>  Suppose that the SFINAE tester has determined that we have a container with container data. </p><br><h2>  Container with container data </h2><br><p>  <code>StreamImpl</code> for a container with container data simply inherits from <code>StreamBase</code> - an interface with basic functionality that will be discussed later. </p><br><div class="spoiler">  <b class="spoiler_title">Container data container interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamImpl</span></span></span><span class="hljs-class">&lt;Tp, true&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StreamBase&lt;Tp&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> StreamBase&lt;Tp&gt; Parent; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Tp ContainerType; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::Parent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::flatMap; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::isEmpty; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::count; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::reduce; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::filter; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::allMatch; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::noneMatch; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::groupingBy; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::partitionBy; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::minElement; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::maxElement; };</code> </pre> </div></div><br><h2>  Container with non-container data </h2><br><p>  <code>StreamImpl</code> for a container with non-container data is intended for working with data of type <code>QVector&lt;int&gt;</code> , as well as for pseudo-containers of type <code>QString</code> , but for working with <code>std::initalizer</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamImpl</span></span></span><span class="hljs-class">&lt;Tp, false&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StreamBase&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Private::select_type&lt;Tp&gt;::type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> StreamBase&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Private::select_type&lt;Tp&gt;::type&gt; Parent; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Private::select_type&lt;Tp&gt;::type ContainerType; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::Parent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::isEmpty; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::count; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::reduce; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::filter; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::allMatch; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::noneMatch; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::groupingBy; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::partitionBy; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::minElement; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Parent::maxElement; <span class="hljs-comment"><span class="hljs-comment">//    flatMap, . StreamBase::flatMap() auto flatMap() const { return Stream&lt;Tp&gt;(data()); } };</span></span></code> </pre><br><p>  As you can see, the implementation is identical to <code>StreamImpl&lt;Tp, true&gt;</code> , except that <code>flatMap</code> terminal and the base class is inferred by the <code>select_type&lt;Tp&gt;::type</code> <code>flatMap</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_to_container</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; is_stl_compatible_container&lt;Tp&gt;::value, Tp, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_to_container&lt;Tp&gt;::type &gt;; }; }</code> </pre> <br><p>  Which turns a non-container into a container using an open <code>type_to_container</code> , which is then passed to <code>std::initalizer_list</code> .  For pseudo-container no "magic" is used.  The default implementation of the <code>type_to_container</code> metafunction is as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_to_container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = QVector&lt;Tp&gt;; };</code> </pre> <br><p>  Having considered the details, go to the base. </p><br><h2>  Streambase </h2><br><p>  Let's look at a simple basic interface.  <code>StreamBase</code> works with containers whose elements can be containers. </p><br><p>  For greater ease of implementation, <code>StreamBase</code> copies source data or moves it to itself. </p><br><p>  Non-terminal functions return <code>Stream</code> .  Calls to non-terminal functions can join chains and get something like monads in the OP. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamBase</span></span></span><span class="hljs-class"> {</span></span> Container m_data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container::value_type value_type; ~StreamBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; StreamBase(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StreamBase &amp;other) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamBase &amp;&amp;other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move&lt;Container&gt;(other.m_data))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Container &amp;data)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container &amp;&amp;data_)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(data_))</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  You can add a static check for the container: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_copy_assignable&lt;Container&gt;::value, <span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_default_constructible&lt;Container&gt;::value, <span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_copy_constructible&lt;Container&gt;::value, <span class="hljs-string"><span class="hljs-string">"..."</span></span>);</code> </pre> <br><p>  Service functions are very simple: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Container </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cbegin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">noexcept</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::cbegin(m_data)))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cbegin(m_data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">noexcept</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::cend(m_data)))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cend(m_data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">noexcept</span></span></span></span><span class="hljs-function"><span class="hljs-params">(cbegin() == cend()))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cbegin() == cend(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">noexcept</span></span></span></span><span class="hljs-function"><span class="hljs-params">(m_data.size()))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.size(); }</code> </pre> <br><p>  Consider the implementation of the <code>map</code> .  The essence of the operation is that an applicator function is applied to each element of the container, and the result is placed in another container.  The applicator function can return values ‚Äã‚Äãof another type.  Actually, all the work is done in an auxiliary function, which returns a new container.  This container will be transferred to <code>Stream</code> .  The applicator can pass additional parameters. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F &amp;&amp;f, Params&amp;&amp; ...params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = map_helper(data(), f, params...); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream&lt;result_type&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;result_type&gt;(result)); }</code> </pre> <br><p>  The <code>filter</code> operation calls the predicate function for each element of the container element, and if <code>true</code> , the element is copied to another container. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; Stream&lt;Container&gt; filter(F &amp;&amp;f, Params&amp;&amp; ...params) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Container result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(result), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(result)&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Container&gt;(result)); }</code> </pre> <br><p>  The <code>reduce</code> operation (the convolution on the left is used here) is more interesting.  <code>reduce</code> "collapses" the container into one value, moving from left to right, applying the operator function to the current element, as the first operand, and as the second - the initial initial value, with which the previous elements are collapsed: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F &amp;&amp;f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value_type &amp;initial, Params&amp;&amp; ...params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(cbegin(), cend(), initial, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, _1, _2, params...)); }</code> </pre> <br><p>  If we have a container of containers with elements of type T, then as a result of using <code>flatMap</code> will be a container with elements of type T. In the return value, <code>flatMap</code> is called for each new <code>Stream</code> value displayed until it reaches the terminal version of <code>flatMap</code> . </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ value_type result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(append, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(result), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream&lt;value_type&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;value_type&gt;(result)).flatMap(); }</code> </pre> <br><p>  Finding the minimum and maximum without optional is of no interest: </p><br><div class="spoiler">  <b class="spoiler_title">Min / Max</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F &amp;&amp;f, Params ...params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max_element(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != cend() ? *it : value_type(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max_element(cbegin(), cend()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != cend() ? *it : value_type(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F &amp;&amp;f, Params ...params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min_element(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != cend() ? *it : value_type(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min_element(cbegin(), cend()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != cend() ? *it : value_type(); }</code> </pre> </div></div><br><p>  The analog of <code>distinct</code> also very simple: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; Stream&lt;value_type&gt; unique(F &amp;&amp;f, Params ...params) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QList&lt;value_type&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_copy(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(result), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream&lt;value_type&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;value_type&gt;(result)); }</code> </pre> <br><p>  If there is a search for all matching items: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; Stream&lt;value_type&gt; allMatch(F &amp;&amp;f, Params ...params) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filter(f, params...); }</code> </pre> <br><p>  Just do a search for all inappropriate (through denial): </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; Stream&lt;value_type&gt; noneMatch(F &amp;&amp;f, Params ...params) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allMatch(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logical_not&lt;&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)) ); }</code> </pre> <br><p>  Breaking up the elements: we take two lists - we put in one, what satisfies the predicate, and in the other, what doesn't, and then in the spirit of the original we put all this in <code>QMap</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; QMap&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, QList&lt;value_type&gt;&gt; partitionBy(F &amp;&amp;f, Params&amp;&amp; ...params) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QList&lt;value_type&gt; out_true; QList&lt;value_type&gt; out_false; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition_copy(cbegin(), cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(out_true), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(out_false), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); QMap&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, QList&lt;value_type&gt;&gt; result { { <span class="hljs-literal"><span class="hljs-literal">true</span></span>, out_true } , { <span class="hljs-literal"><span class="hljs-literal">false</span></span>, out_false } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Clustering (splitting into groups): two functions of the <code>clasterizator</code> are <code>clasterizator</code> - for splitting into groups, and then a <code>clasterizator</code> function is performed (if specified) on each group element. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupingBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F &amp;&amp;f, Params&amp;&amp; ...params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clasterize(m_data, f, params...); }</code> </pre> <br><p>  Difficulties only in the definition of types: <code>invoke</code> (which will be in C ++ 17) is used to determine the types returned by the <code>clasterizator</code> and <code>finisher</code> , until it is legalized using the implementation presented at the very end: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Claserizer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Finisher&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupingBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Claserizer &amp;&amp;clasterizator, Finisher &amp;&amp;finisher)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> claster_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(Private::invoke(clasterizator, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;value_type&gt;())); QMap&lt;claster_type, QList&lt;value_type&gt;&gt; clasters = clasterize(data(), clasterizator); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> item_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(Private::invoke( finisher, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(clasters)::mapped_type&gt;())); QMap&lt;claster_type, item_type&gt; result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = clasters.cbegin(); it != clasters.cend(); ++it) result[it.key()] = finisher(it.value()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContainerType &amp;c, F &amp;&amp;f, Params&amp;&amp; ...params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ret_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(Private::invoke(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;value_type&gt;(), params...)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> make_templated_type&lt;ContainerType, ret_type&gt;::type; result_type result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cbegin(c), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::cend(c), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(result), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  The cluster device looks awful, but does a simple job: </p><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ContainerType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Params&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clasterize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContainerType &amp;c, F &amp;&amp;f, Params&amp;&amp; ...params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ret_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(Private::invoke(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;value_type&gt;(), params...)); QMap&lt;ret_type, QList&lt;value_type&gt;&gt; result; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> applier = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, params...); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> action = [&amp;result, &amp;applier](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type &amp;item) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { result[applier(item)].push_back(item); }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(c.cbegin(), c.cend(), action); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> value_type&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value_type &amp;result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value_type &amp;item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(item.cbegin(), item.cend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(result)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } };</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">std :: invoke</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Functor, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; (!is_member_pointer&lt;_Functor&gt;::value &amp;&amp; !is_function&lt;_Functor&gt;::value &amp;&amp; !is_function&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_pointer&lt;_Functor&gt;::type&gt;::value), <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> result_of&lt;_Functor&amp;(_Args&amp;&amp;...)&gt;::type &gt;::<span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Functor&amp; __f, _Args&amp;&amp;... __args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;_Args&gt;(__args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Functor, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; (is_member_pointer&lt;_Functor&gt;::value &amp;&amp; !is_function&lt;_Functor&gt;::value &amp;&amp; !is_function&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_pointer&lt;_Functor&gt;::type&gt;::value), <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> result_of&lt;_Functor(_Args&amp;&amp;...)&gt;::type &gt;::<span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Functor&amp; __f, _Args&amp;&amp;... __args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(__f)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;_Args&gt;(__args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Functor, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; (is_pointer&lt;_Functor&gt;::value &amp;&amp; is_function&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_pointer&lt;_Functor&gt;::type&gt;::value), <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> result_of&lt;_Functor(_Args&amp;&amp;...)&gt;::type &gt;::<span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Functor __f, _Args&amp;&amp;... __args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;_Args&gt;(__args)...); }</code> </pre> </div></div><br><h2>  Total </h2><br><p>  Let's try to apply our works: </p><br><pre> <code class="cpp hljs"> { QStringList x = {<span class="hljs-string"><span class="hljs-string">"functional"</span></span>, <span class="hljs-string"><span class="hljs-string">"programming"</span></span>}; Stream&lt;QList&lt;QStringList&gt;&gt; stream(QList&lt;QStringList&gt;{x}); qDebug() &lt;&lt; stream.flatMap().data(); }</code> </pre> <br><p>  <code>QList&lt;QStringList&gt;</code> turns into a QString with the contents: "functionalprogramming". </p><br><p>  Nothing happens to a simple container (here <code>std::initalizer_list&lt;int&gt;</code> will turn into <code>QVector&lt;int&gt;</code> ) </p><br><pre> <code class="cpp hljs"> { Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; is({<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}); qDebug() &lt;&lt; is.flatMap().data(); }</code> </pre> <br><p>  But with the "difficult" happens <code>QVector&lt;QVector&lt;int&gt;&gt;</code> will turn into <code>QVector&lt;int&gt;</code> with the contents (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 , 14, 15, 16, 17, 18, 19, 100, 111, 112, 113, 114, 115, 116, 117, 118, 119): </p><br><pre> <code class="cpp hljs"> { QVector&lt;QVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; x = { {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>}, {<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">19</span></span>}, {<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">111</span></span>,<span class="hljs-number"><span class="hljs-number">112</span></span>,<span class="hljs-number"><span class="hljs-number">113</span></span>,<span class="hljs-number"><span class="hljs-number">114</span></span>,<span class="hljs-number"><span class="hljs-number">115</span></span>,<span class="hljs-number"><span class="hljs-number">116</span></span>,<span class="hljs-number"><span class="hljs-number">117</span></span>,<span class="hljs-number"><span class="hljs-number">118</span></span>,<span class="hljs-number"><span class="hljs-number">119</span></span>}, }; Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt; t(x); qDebug() &lt;&lt; t.flatMap().data(); }</code> </pre> <br><p>  Check with lambda functions, functional objects and pointers to functions: </p><br><pre> <code class="cpp hljs"> Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; t{{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>}}; qDebug() &lt;&lt; t.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;QString(*)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;(&amp;QString::number), <span class="hljs-number"><span class="hljs-number">2</span></span>) .filter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logical_not&lt;&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(QString::isEmpty, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1)) ) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(&amp;QString::length) .filter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::greater&lt;&gt;(), <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logical_and&lt;&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::greater_equal&lt;&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less_equal&lt;&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-number"><span class="hljs-number">100</span></span>) ) ) .reduce(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::multiplies&lt;&gt;(), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Here, the list of ints turns into a list of strings representing ints in the binary number system, then the lengths of the strings are calculated, from which those that are greater than 1 are selected, and then using the functional composition created with <code>std::bind</code> , elements are selected in range [1, 100], and then these elements are multiplied. </p><br><p>  Horror! </p><br><p>  And finally, in the first part of the example, we divide the elements into digits / non-digits and independently group them by a significant byte ( <code>QChar::cell</code> ), and then, again, we independently group the elements <code>x</code> by a significant byte and count their number. </p><br><pre> <code class="cpp hljs"> { QStringList x = {<span class="hljs-string"><span class="hljs-string">"flat 0"</span></span>,<span class="hljs-string"><span class="hljs-string">"Map 1"</span></span>,<span class="hljs-string"><span class="hljs-string">"example"</span></span>}; Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt; t(x); Stream&lt;QString&gt; str(t.flatMap().data()); qDebug() &lt;&lt; str.partitionBy(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(QChar::*)()<span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt;(&amp;QChar::isDigit)); qDebug() &lt;&lt; str.groupingBy(&amp;QChar::cell); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.size(); }; qDebug() &lt;&lt; str.groupingBy(&amp;QChar::cell, count); }</code> </pre> <br><p>  PS: sorry for such examples ... At night, nothing better was invented) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322924/">https://habr.com/ru/post/322924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322906/index.html">Cirrascale Artificial Intelligence Cloud: Experiments with AI and Deep Learning</a></li>
<li><a href="../322908/index.html">Test article on checking vulnerabilities in habrahabr</a></li>
<li><a href="../322912/index.html">Some aspects of the use of cartographic materials or how not to get on 300 thousand rubles. for the site map</a></li>
<li><a href="../322914/index.html">Security Week 09: Cloudflare Vulnerability, IoT Bears Privacy</a></li>
<li><a href="../322916/index.html">59 ways to monetize your indie game</a></li>
<li><a href="../322930/index.html">Ideal catalog, architecture sketch</a></li>
<li><a href="../322932/index.html">Amazon S3 about three or four hours worked intermittently, Medium, Slack, Coursera, Trello lay</a></li>
<li><a href="../322934/index.html">Competition for the best domain for CDN from King Servers (Updated)</a></li>
<li><a href="../322936/index.html">Four key Linux skills in 2017</a></li>
<li><a href="../322938/index.html">How IT professionals work. Alexander Kozlov, team leader of SimbirSoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>