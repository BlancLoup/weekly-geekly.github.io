<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STP operation principle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reason to create STP 
 The reason for creating the STP protocol was the occurrence of loops on the switches. What is a loop? The definition of a loop ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STP operation principle</h1><div class="post__text post__text-html js-mediator-article"><h4>  Reason to create STP </h4><br>  The reason for creating the STP protocol was the occurrence of loops on the switches.  What is a loop?  The definition of a loop is: <br><br>  <b>Bridging loop (Switching loop)</b> - a state in the network, in which there is an infinite transfer of frames between switches connected to the same network segment. <br><br>  From the definition it becomes clear that the occurrence of a loop creates big problems - it leads to an overload of switches and inoperability of this network segment.  How does the loop come about?  The picture below shows the topology in which a loop will occur in the absence of any protective mechanisms: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a><a href="https://habr.com/somelink"></a> <a href="https://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst4000/8-2glx/configuration/guide/spantree.html"><img src="https://habrastorage.org/getpro/habr/post_images/126/e5d/0de/126e5d0dea4a92a1d6ec0c4dd2c7c897.jpg" alt="My image"></a> <a name="habracut"></a><br><br>  The occurrence of a loop under the following conditions: <br><br>  <b>1. Any host sends a Broadcast frame:</b> <br><br><ol><li>  For example, VPC5 sends a packet with a broadcasted destination address. </li><li>  Having received this packet, Switch1 must send it through all ports, except for the port from which the packet came.  The packet will be sent through the ports Gi0 / 0, Gi1 / 0. </li><li>  Switches Switch2, Switch3 accepting this packet will also have to send it a packet.  Thus, Switch2, which received a packet from Switch1, will send it to Switch3, and Switch3 will send it to Switch2. </li><li>  Further, Switch2, receiving the packet from Switch3, sends it to Switch1, and Switch3, receiving the packet from Switch2, will also send it to Switch1.  Thus, we come to step 1) and it will continue indefinitely.  Everything is also aggravated by the fact that, at step 4), Switch1 will already have two frame instances, since it will receive them from both Switch2 and Switch3. </li></ol><br>  Steps 1) - 4) will be repeated indefinitely and on commutators this happens in a split second.  Also, looping causes the MAC address table on the switches to constantly change and the MAC address of the sender of the VPC5 to be constantly assigned to either the Gi0 / 0 interface, the Gi1 / 0, or the Gi0 / 2 (if at that moment other packages).  Such a cycle will lead to incorrect operation of the network and all switches.  And sending broadcasts to hosts is common, as in the example ARP protocol. <br><br>  <b>2. A loop can also be formed without sending a broadcast frame.</b> <br><br><ol><li>  For example, VPC5 sends a frame with a unicast destination mac address. </li><li>  It is possible that the destination MAC address is not in the switch MAC address table.  In this case, the switch will forward the packet through all ports, except the port from which it received the frame.  And we get the same situation as with the Broadcast frame. </li><li>  Below we will look at the STP protocol on Cisco switches.  They use STP separately for each vlan, protocol PVST +.  We have only one vlan, so the meaning does not change. </li></ol><br><h4>  STP Basics </h4><br>  The principle of operation of this protocol is based on the fact that all redundant links between switches are logically blocked and traffic is not transmitted through them.  To build a topology without redundant channels, a tree is built (mathematical graph).  To build such a tree, you first need to determine the root of the tree from which the graph will be built.  Therefore, the first step of the STP protocol is to define the root switch (Root Switch).  To determine the Root Switch, switches exchange BPDU messages.  In general, the STP protocol uses two types of messages: BPDU ‚Äî contains information about switches and TCN ‚Äî notifies you of a topology change.  Consider BPDU in more detail.  Talk about TCN in more detail below.  When STP is enabled on the switches, the switches begin to send BPDU messages.  These messages contain the following information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ab/b03/95d/8abb0395d6af59aa1d0d89717a430640.jpg" alt="My image"><br><br>  The BPDU frame has the following fields: <br><br><ul><li>  The protocol version identifier STA (2 bytes).  Switches must support the same version of the STA protocol. </li><li>  STP protocol version (1 byte) </li><li>  Type BPDU (1 byte).  There are 2 types of BPDU - configuration and reconfiguration notification </li><li>  Flags (1 byte) </li><li>  Root Switch ID (8 bytes) </li><li>  The cost of the route to the root switch (Root Path Cost) </li><li>  Sender ID (Bridge ID) (8 bytes) </li><li>  Port identifier from which this packet is sent (Port ID) (2 bytes) </li><li>  Message Lifetime (2 bytes).  Measured in units of 0.5 s, used to identify outdated messages. </li><li>  Maximum message lifetime (2 bytes).  If a BPDU frame has a lifetime longer than the maximum, then the frame is ignored by the switches. </li><li>  Hello interval (2 bytes), the interval at which BPDU packets are sent </li><li>  Delay state transition (2 bytes).  Minimum time for the switch to become active </li></ul><br>  The main fields that require special attention are the following: <br><br><ul><li>  Sender ID (Bridge ID) </li><li>  Root Bridge ID (Root Bridge ID) </li><li>  Port ID from which this packet is sent (Port ID) </li><li>  The cost of the route to the root switch (Root Path Cost) </li></ul><br>  To determine the root switch, the Bridge ID is used.  Bridge ID is a number of 8 bytes in length, which consists of Bridge Priority (priority, from 0 to 65535, by default 32768) and the MAC address of the device.  The switch with the lowest priority is selected as the root switch; if the priorities are equal, then MAC addresses are compared (character-wise, the one that is less wins). <br><br>  Here is the output of the Bridge ID information from the Switch1 switch from the first picture.  Priority - 32769 (by default 32768 + Vlan Id), MAC addresses - Address 5000.0001.0000: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/0a9/a20/f0e0a9a20fcaf20601fb2e5ffb02564e.jpg" alt="My image"><br><br>  Imagine the picture, the switches just turned on and now begin to build a topology without loops.  As soon as the switches are loaded, they begin sending out BPDUs, where they inform everyone that they are the root of the tree.  In BPDU, as the Root Bridge ID, switches specify their own Bridge ID.  For example, Switch1 sends BPDUs to Switch3, and Switch3 sends to Switch1.  BPDU from Switch1 to Switch3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/6ef/4e3/dc96ef4e309f4c565aa7fc68eda75137.jpg" alt="My image"><br><br>  BPDU from Switch3 to Switch1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/809/4de/aee/8094deaeef6449cdf3dc280000fc6e78.jpg" alt="My image"><br><br>  As we see from the Root Identifier, both commutators tell each other that it is he who is the Root switch. <br><br><h4>  Choosing a root switch </h4><br>  While the STP topology is not built, normal traffic is not transmitted due to special port states, which will be discussed below.  So, Switch3 is obtained by BPDU from Switch1 and examines this message.  Switch3 looks in the Root Bridge ID field and sees that another Root Bridge ID is listed there than in the message that Switch3 sent itself.  He compares the Root Bridge ID in this message with his Root Bridge ID and sees that at least Priority is the same, but the MAC address of this switch (Switch1) is better (less) than that of it.  Therefore, Switch3 accepts Root Bridge ID from Switch1 and stops sending its BPDUs, but only listens to BPDUs from Switch1.  The port on which the best BPDU was received becomes the Root Port.  Switch1 also received BPDU from Switch3, makes a comparison, but in this case, the behavior of Switch1 does not change, since the resulting BPDU contains a worse Root Bridge ID than Switch1.  Thus, the root switch was defined between Switch1 and Switch3.  In a similar pattern, the root switch is selected between Switch1 and Switch2.  Gi0 / 0 ports on Switch2 and Switch3 become the Root Port - the port that leads to the root switch.  Through this port, Switch2 and Switch3 accept BPDUs from the Root Bridge.  Now let's see what happens to the channel between Switch2 and Switch3. <br><br><h4>  Blocking redundant channels </h4><br>  As we see from the topology, the channel between Switch2 and Switch3 must be blocked to prevent looping.  How does STP handle this? <br><br>  After Root Bridge is selected, Switch2 and Switch3 stop sending BPDUs through Root Port, but they send BPDUs received from Root Bridge through all of their other active ports, while changing only the following fields in the BPDU data: <br><br><ul><li>  Sender ID (Bridge ID) - is replaced with your identifier. </li><li>  Port ID from which the given packet is sent (Port ID) - changed to the port ID from which the BPDU will be sent. </li><li>  Root Path Cost - the cost of the route to the root switch - the cost of the route is calculated relative to the switch itself. </li></ul><br>  Thus, Switch2 receives the following BPDU from Switch3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cb/1cb/bdf/0cb1cbbdfae70fb3ccf78a2ef590e847.jpg" alt="My image"><br>  And Switch3 from Switch2 gets this BPDU: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/cc4/3a4/91ecc43a4ba7a061e38552d59fa26075.jpg" alt="My image"><br><br>  After exchanging such BPDUs, Switch2 and Switch3 understand that the topology is redundant.  Why do switches understand that topology is redundant?  Both Switch2 and Switch3 in their BPDUs report the same Root Bridge.  This means that there are two ways to Root Bridge, relative to Switch3, through Switch1 and Switch2, and this is the very redundancy we are fighting against.  There are also two ways for Switch2 - via Switch1 and Switch3.  To get rid of this redundancy <br>  You must lock the channel between Switch3 and Switch2.  How does this happen? <br><br>  The choice of which switch to block the port is as follows: <br><br><ul><li>  Smaller Root Path Cost. </li><li>  Smaller Bridge ID. </li><li>  Smaller port id. </li></ul><br>  In this scheme, the Root Path Cost plays a more important role than the Bridge ID.  I used to think that this choice is similar to the choice of the Root switch and was surprised that, for example, in such a topology, the port on the switch with the worst priority would be blocked: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a36/58f/9fc/a3658f9fca69d52cadf3b6d632e9d4c3.jpg" alt="My image"><br><br>  Here, as it turned out, the port Gi 0/1 is blocked on the switch Sw2.  In this voting, Root Path Cost becomes decisive.  Let's return to our topology.  Since the path to the Root Bridge is the same, Switch2 wins in this choice, since its priority is equal, the Bridge ID is compared.  At Switch2 - 50: 00: 00: 02: 00: 00, at Switch3 - 50: 00: 00: 03: 00: 00.  Switch2 has a better (lower) MAC address.  After the choice is made, Switch3 stops forwarding any packets through this port - Gi1 / 0, including BPDU, and only listens to BPDU from Switch2.  This port state in STP is called Blocking (BLK).  The Gi2 / 0 port on Switch2 works in the normal mode and forwards various packets if necessary, but Switch3 discards them immediately, listening only to BPDUs.  Thus, in this example, we built a topology without redundant channels.  The only redundant link between Switch2 and Switch3 was blocked by switching the port Gi1 / 0 on Switch3 to a special blocking state - BLK.  Now we will analyze STP mechanisms in more detail. <br><br><h4>  Port states </h4><br>  We said above that, for example, the port Gi1 / 0 on Switch3 enters a special blocking state - Blocking.  In STP, the following port states exist: <br><br>  <b>Blocking</b> - blocking.  In this state, no frames are transmitted through the port.  Used to avoid redundancy topology. <br><br>  <b>Listening</b> - listening.  As we said above, before the root switch is selected yet, the ports are in a special state where only BPDUs are transmitted, data frames are not transmitted and are not accepted in this case.  The Listening state does not enter the next even if the Root Bridge is defined.  This port state lasts for the Forward delay timer, which, by default, is 15. Why do you always have to wait 15 seconds?  This is due to the caution of the STP protocol so that an incorrect Root Bridge was not chosen by chance.  After this period, the port enters the next state - Learning. <br><br>  <b>Learning</b> - learning.  In this state, the port listens and sends BPDUs, but does not send information with data.  The difference between this state and Listening is that the frames with data that arrive at the port are studied and the information about MAC addresses is entered into the table of MAC addresses of the switch.  The transition to the next state also takes Forward delay timer. <br><br>  <b>Forwarding</b> - forwarding.  This is the normal port state in which both BPDU packets and regular data frames are sent.  Thus, if we go through the scheme when the switches are only loaded, we get the following scheme: <br><br><ol><li>  The switch places all its connected ports in the Listening state and starts sending BPDUs, where it declares itself as the root switch.  During this time period, either the switch remains the root, if it does not receive the best BPDU, or it selects the root switch.  It lasts 15 seconds. </li><li>  After it goes to the Learning state and learns the MAC addresses.  15 seconds. </li><li>  Specifies which ports to transfer to the Forwarding state, and which in Blocking. </li></ol><br><h4>  Port roles </h4><br>  In addition to the states of the ports, the STP also needs to determine the ports for their role.  This is done so that on which port BPDUs should be expected from the root switch and through which ports to transmit copies of BPDUs received from the root switch.  Port roles are as follows: <br><br>  <b>Root Port</b> - the root port of the switch.  When selecting the root switch, the root port is also determined.  This is the port through which the root switch is connected.  For example, in our topology, the Gi0 / 0 ports on Switch2 and Switch3 are the root ports.  Through these ports, Switch2 and Switch3 do not send BPDUs, but only listen to them from the Root Bridge.  The question arises - how is the root port selected?  Why is the Gi1 / 0 port not selected?  Do you also have a connection with the switch through it?  To determine the root port in STP, a metric is used, which indicates the BPDU - Root Path Cost field (the cost of the route to the root switch).  This cost is determined by the speed of the channel. <br><br>  Switch1 in its BPDU in the field Root Path Cost puts 0, since it is the Root Bridge itself.  But when Switch2, when sending BPDUs to Switch3, changes this field.  He puts Root Path Cost equal to the cost of the channel between himself and Switch1.  In the BPDU picture from Switch2 and Switch3, you can see that in this field, the Root Path Cost is 4, since the channel between Switch1 and Switch2 is 1 Gbps.  If the number of switches is greater, then each next switch will summarize the cost of Root Path Cost.  Table Root Path Cost. <br><br>  <b>Designated Port</b> is the designated port of the segment.  For each network segment there should be a port that is responsible for connecting this segment to the network.  Relatively speaking, a network segment can mean a cable that connects this segment.  For example, the Gi0 / 2 ports on Switch1, Switch3 connect individual network segments to which only this cable leads.  Also, for example, the ports on the Root Bridge cannot be blocked and all are designated segment ports.  After this explanation, more strict definitions can be given for the assigned ports: <br>  Designated Port (assigned) - non-root port of the bridge between network segments, receiving traffic from the corresponding segment.  In each network segment there can be only one assigned port.  At the root switch all ports are assigned. <br><br>  It is also important to note that the port Gi1 / 0 on Switch2 is also assigned, despite the fact that this communication channel is blocked on Switch3.  Relatively speaking, Switch2 has no information that the port is blocked at the other end. <br><br>  <b>Nondesignated Port</b> - unassigned port segment.  Non-designated Port (unassigned) - a port that is not the root, or designated.  Transmission of data frames through such a port is prohibited.  In our example, the port Gi1 / 0 is unassigned. <br><br>  <b>Disabled Port</b> - a port that is in the off state. <br><br><h4>  Timers and STP Convergence </h4><br>  After the STP has completed building a loop-free topology, the question remains - How to identify changes in the network and how to respond to them?  BPDU messages with which STP is running are sent to the Root Bridge every 2 seconds, by default.  This timer is called Hello Timer.  The remaining switches receive this message through their root port and forward it through all designated ports.  Above it is said in more detail what changes happen to the BPDU when forwarding its switches.  If during the time specified by the Max Age timer (default is 20 seconds), the switch did not receive any BPDUs from the root switch, then this event is interpreted as a loss of communication with the Root Bridge.  In order to more correctly describe the convergence of the protocol, it is necessary to change our topology and put hubs between switches.  We added hubs so that when one of the switches fails or the link fails, the other switches do not detect this by dropping the link, but using timers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/0e7/105/ea30e7105f926c505b0a46f1e2adf758.jpg" alt="image"><br><br>  Before you begin it is also important to talk more about another type of STP message - TCN.  TCN is distributed by switches in the event of a topology change ‚Äî as soon as a topology has changed on a switch, for example, the state of the interface has changed.  The TCN is sent by the switch only through the Root Port.  As soon as the root switch receives a TCN, it immediately changes the storage time parameter of MAC addresses in the table from 300 seconds to 15 (what it is done for below) and in the next BPDU, the Root Switch taps the flag - TCA (Topology Change Acknledgement), which sent to the switch that sent the TCN to indicate that the TCN was received.  As soon as the TCN reaches the Root Bridge, it sends out a special BPDU that contains the TCN flag on all other interfaces to the other switches.  The picture shows the structure of TCN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/0e9/123/8710e9123047de570b5fbf6eb8127ca9.jpg" alt="image"><br><br>  TCN was included in the STP so that non-root switches can report a change in the network.  They cannot do this with regular BPDUs, since non-root switches do not send BPDUs.  As you can see, the TCN structure does not contain any information about what exactly has changed and where, but simply reports that something has changed somewhere.  We now turn to the question of the convergence of STP. <br><br>  Let's see what happens if we disable the Gi0 / 1 interface on Switch1 and see with what mechanisms the STP tree is rebuilt.  Switch2 will stop receiving BPDUs from Switch1 and will not receive BPDUs from Switch3, since this port is blocked on Switch3.  Switch2 will take 20 seconds (Max Age Timer) to understand the loss of communication with the Root Bridge.  Until that time, Gi0 / 0 on Switch2 will be in the Forwarding state with the Root Port role.  As soon as Max Age Timer expires and Switch2 understands the loss of communication, it will rebuild the STP tree and, as it is typical of STP, it will begin to consider itself Root Bridge.  It will send a new BPDU, where it will point itself as the Root Bridge through all active ports, including Switch3.  But the Max Age timer expired on Switch2 also expired on Switch3 for the Gi1 / 0 interface.  This port has not received BPDU for 20 seconds and this port will switch to the LISTENING state and send BPDUs with the indication as Root Bridge - Switch1.  As soon as Switch2 accepts this BPDU, it will no longer consider itself Root Bridge and will select Gi1 / 0 as Root Port.  At this point, Switch2 will also send TCN via Gi1 / 0, since this is the new Root Port.  This will cause the storage time of the MAC addresses on the switches to decrease from 300 seconds to 15. But this will not fully restore the network‚Äôs performance, you must wait until the Gi1 / 0 port on Switch3 passes the Listening state and then Learning.  It will take time equal to two periods. Forward delay timer - 15 + 15 = 30 seconds.  What we get is that when the connection is lost, Switch2 waits until the Max Age timer expires = 20 seconds, re-selects the Root Bridge via another interface and waits another 30 seconds while the previously blocked port switches to the Forwarding state.  In total, the connection between VPC5 and VPC6 is interrupted for 50 seconds.  As mentioned by several suggestions above, when the Root Port was changed from Gi0 / 0 to Gi1 / 0 to TC2, TCN was sent.  If this did not happen, then all MAC addresses learned through the Gi 0/0 port would remain bound to Gi0 / 0.  For example, the MAC address of VPC5 and VPC7, although the STP will complete convergence after 50 seconds, the connection between VPC6 and VPC5, VPC7 would not be restored, since all packets destined for VPC5, VPC7 were sent via Gi0 / 0.  It would be necessary to wait not 50 seconds, but 300 seconds while the table of MAC addresses is rebuilt.  With TCN, the storage time changed from 300 seconds to 15 and while the Gi1 / 0 interface on Switch3 passed the Listening state, and then the Learning and MAC address information is updated. <br><br>  Also an interesting question is what happens if we re-enable the Gi0 / 1 interface on Switch1?  When you enable the Gi0 / 1 interface, it will, as befits, switch to the Listening state and begin sending BPDUs.  As soon as Switch2 receives BPDUs on Gi0 / 0, it will immediately re-select its Root Port, since here Cost will be the smallest and start sending traffic through Gi0 / 0 interface, but we need to wait until Gi0 / 1 interface passes Listening, Learning status to Forwarding .  And the delay will not be 50 seconds, but 30. <br><br>  The STP protocol also considers various technologies to optimize and secure the operation of the STP protocol.  In more detail in this article I will not consider them, materials about them can be found in abundance on various sites. </div><p>Source: <a href="https://habr.com/ru/post/419491/">https://habr.com/ru/post/419491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419477/index.html">Easier than it seems. Chapter 11</a></li>
<li><a href="../419479/index.html">Security "Ekaterinburg Arena": how we prepared the stadium for the 2018 World Cup</a></li>
<li><a href="../419483/index.html">PowerShell and Shift + Ins, or how to gain Hermes speed when working with GPP</a></li>
<li><a href="../419485/index.html">There's an app for that: Mobius announcement 2018 Moscow</a></li>
<li><a href="../419489/index.html">Trailer? Electric car? Needed! If it's with batteries</a></li>
<li><a href="../419495/index.html">Who "invented" bone conduction, why it is used and how it is safe for hearing</a></li>
<li><a href="../419497/index.html">Review of a large Hercules Strong 3D printer</a></li>
<li><a href="../419501/index.html">Deep Learning: Recognizing Scenes and Points of Interest in Images</a></li>
<li><a href="../419503/index.html">The book Algorithms and Data Structures. Extracting Java Information</a></li>
<li><a href="../419505/index.html">Receive parcels without notifications and passports can now be by mail across the country</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>