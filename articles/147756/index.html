<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a cache with a limit on the number of elements in Python - solutions: simple and more complicated</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task statement 
 Suppose that we have a need to have some kind of service that would give us any information upon request, and give it as soon as poss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a cache with a limit on the number of elements in Python - solutions: simple and more complicated</h1><div class="post__text post__text-html js-mediator-article"><h4>  Task statement </h4><br>  Suppose that we have a need to have some kind of service that would give us any information upon request, and give it as soon as possible.  What does any normal person do for this?  Improves caching of the most frequently requested data.  In this case, if at least a little to think about the future, the size of the cache should be limited. <br>  For ease of implementation, in the case of Python, we will make a restriction on the number of items in the cache ( <i>here it is assumed that the data is more or less uniform in size and also takes into account the specifics that determining the amount of memory actually occupied by any Python object is a <b>very</b> trivial task for anyone interested , let him <a href="http://packages.python.org/Pympler/asizeof.html">come here</a></i> ), and in order for the cache to contain the most frequently used information - <i>let's</i> build it according to the principle of <a href="http://en.wikipedia.org/wiki/Cache_algorithms">recently recently used</a> , i.e.  the more a piece of information was requested a long time ago, the greater the chance that he would ‚Äúfly out‚Äù of the cache. <br><br>  I will talk about two solutions (simpler and more complicated) in this article. <a name="habracut"></a><br><br><h4>  Philosophical retreat </h4><br>  I noticed that often the code written on Python does not shine with optimizations on memory consumption or speed ( <i>here you can casually note that this is not only the fault of the programmers-users of the language, there is simply no good toolkit, or at least I don‚Äôt know about this ( yes, I know about cProfile, but it doesn‚Äôt always help, for example, it doesn‚Äôt have an attach-detach; it‚Äôs not a problem for the faint-hearted to look for memory leaks, if pympler finishes ...), if someone tells you, I will</i> ).  Basically, this is even correct, as Python is usually used when the program execution time or memory consumption is not critical, but the time of writing the code and the simplicity of its further support are critical, so the obvious, even less economical solution will be more convenient. <br>  Though the aforesaid does not mean at all that any code on Python needs to be written ‚Äúanyhow‚Äù.  In addition, sometimes performance and memory consumption can become critical, even if the code runs on a server machine with a good processor and tons of memory. <br>  Just such a case (lack of CPU time) and motivate me to research this issue and replace one caching class with another. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  A simple solution </h4><br>  It is often said that ‚Äúthe simplest solution is the right one,‚Äù although in the case of programming this is by no means always the case, is it not?  However, if there is a task to ensure the cache, but there are no special requirements for speed (for example, the fact that this cache is used is very slow in itself, and there is no point in investing in a complex implementation), then you can get by with trivial solutions. <br><br><h5>  Implementation </h5><br>  So, a relatively simple solution: <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> weakref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleCache</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cacheSize)</span></span></span><span class="hljs-function">:</span></span> self.cache = weakref.WeakValueDictionary() self.cache_LRU = [] self.cacheSize = cacheSize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># no exception catching - let calling code handle them if any value = self.cache[key] return self.touchCache(key, value) def __setitem__(self, key, value): self.touchCache(key, value) def touchCache(self, key, value): self.cache[key] = value if value in self.cache_LRU: self.cache_LRU.remove(value) self.cache_LRU = self.cache_LRU[-(self.cacheSize-1):] + [ value ] return value</span></span></code> </pre> <br><br><h5>  Using </h5><br>  After creation, you can work with such a cache as you would with a regular dict, but when you read / write an element it will be placed at the end of the queue, and due to the combination of WeakValueDictionary () and the list that stores no more than cacheSize elements, we get the number limit saved data. <br>  Thus, after executing a piece of code <br><pre> <code class="python hljs">cache = SimpleCache(<span class="hljs-number"><span class="hljs-number">2</span></span>) cache[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'a'</span></span> cache[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">'b'</span></span> cache[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-string"><span class="hljs-string">'c'</span></span></code> </pre> <br>  only the 'b' and 'c' entries will remain in the cache (the 'a', as the oldest, will be preempted). <br><br><h5>  Advantages and disadvantages </h5><br>  The advantage is relative simplicity (about 20 lines of code, after reading the documentation on WeakValueDictionary, the principle of operation becomes clear). <br>  The disadvantage is the speed of work, because  each time the cache is touched, the entire list has to be re-created, removing an element from its arbitrary location (in fact, a whole bunch of long operations on working with the list take place there, so ‚Äúif value in self.cache_LRU‚Äù is a linear search in the list, then .remove () - once again a linear search, then another cut is taken - i.e., an almost complete copy of the list is created).  In a word, relatively long. <br><br><h4>  Difficult decision </h4><br>  Now let's think about it - how can we accelerate such a class?  Obviously, the main problems we have are precisely with keeping the cache_LRU up to date - as I said before, searching through it, then deleting an item and rebuilding is expensive operations.  Here we will come to the rescue by such a thing as a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA">bidirectional linked list</a> - it will provide us with the support of the ‚Äúlast used - at the end‚Äù, but WeakValueDictionary () will help with a quick search on this list (dictionary search is much faster than linear searching, since inside dictionaries implement something like binary trees on the key hashes <i>(here Ostap suffered - I can honestly say that I did not look at the sources, so I‚Äôm just guessing how the dictionary search works)</i> <br><br><h5>  Implementation </h5><br>  First we create a class - a list item in which we will wrap the stored data: <br><pre> <code class="python hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> __slots__ = [<span class="hljs-string"><span class="hljs-string">'prev'</span></span>, <span class="hljs-string"><span class="hljs-string">'next'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-string"><span class="hljs-string">'__init__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__weakref__'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self.prev, self.next, self.value = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, value</code> </pre> <br>  Here it is necessary to note the use of such a thing as __slots__, which allows you to significantly save memory and a little - performance compared to the same class implementation, but without this attribute (what it is and what it is eaten with - in the <a href="http://docs.python.org/reference/datamodel.html">official documentation</a> ). <br>  Now we create the cache class (we throw the element class ‚Äúin order to avoid‚Äù): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> weakref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastCache</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> __slots__ = [<span class="hljs-string"><span class="hljs-string">'prev'</span></span>, <span class="hljs-string"><span class="hljs-string">'next'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-string"><span class="hljs-string">'__init__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__weakref__'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self.prev, self.next, self.value = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, maxCount)</span></span></span><span class="hljs-function">:</span></span> self.dict = weakref.WeakValueDictionary() self.head = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.tail = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.count = <span class="hljs-number"><span class="hljs-number">0</span></span> self.maxCount = maxCount <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_removeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, element)</span></span></span><span class="hljs-function">:</span></span> prev, next = element.prev, element.next <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev: <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> prev.next == element prev.next = next <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> self.head == element: self.head = next <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next: <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> next.prev == element next.prev = prev <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> self.tail == element: self.tail = prev element.prev, element.next = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> self.count &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> self.count -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_appendElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, element)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element.prev, element.next = self.tail, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.head <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.head = element <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.tail <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.tail.next = element self.tail = element self.count += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key, *arg)</span></span></span><span class="hljs-function">:</span></span> element = self.dict.get(key, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> element: self._removeElement(element) self._appendElement(element) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element.value <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(*arg): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-string"><span class="hljs-string">"'%s' is not found in the dictionary"</span></span>, str(key)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__len__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.dict) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> element = self.dict[key] <span class="hljs-comment"><span class="hljs-comment"># At this point the element is not None self._removeElement(element) self._appendElement(element) return element.value def __setitem__(self, key, value): try: element = self.dict[key] self._removeElement(element) except KeyError: if self.count == self.maxCount: self._removeElement(self.head) element = FastCache.Element(value) self._appendElement(element) self.dict[key] = element def __del__(self): while self.head: self._removeElement(self.head)</span></span></code> </pre> <br>  Here you can pay attention to the following significant / interesting points: <br><ul><li>  implementation of the get () method is slightly different from the standard for dictionaries, since  if the default value is not specified, but the key is absent, it throws an exception (works the same as cache [key]), and if there is a default value, it returns it </li><li>  the presence of the __del__ method is mandatory; otherwise, we get (or can get) the leakage of the entire cache - after all, all the elements of the list are referencing each other, which means that their reference counters will never be reset without help;  by the way, as it turned out, the built-in (at least in 2.6) garbage collector, although it seems to collect the simplest link cycles, doesn‚Äôt cope with this list </li><li>  if desired, you can slightly improve performance by throwing out assertions </li></ul><br><h5>  Using </h5><br>  Completely similar to the previous implementation (and the logic is similar inside, only it uses not the simple type of list built into Python, but implements its bidirectional list <s>with chess and poetess</s> ). <br><br><h4>  Another simple solution with good performance. </h4><br>  Thanks <a href="https://habrahabr.ru/users/seriyps/" class="user_link">seriyPS</a> for the tip! <br>  Another solution emerged, which looks as simple as the first (if not simpler) and works almost as fast as a complex one.  So, the implementation: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OrderedDict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ODCache</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OrderedDict)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cacheSize)</span></span></span><span class="hljs-function">:</span></span> self.cacheSize = cacheSize OrderedDict.__init__(self) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> value = OrderedDict.__getitem__(self, key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._touchCache(key, value) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__setitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key, value)</span></span></span><span class="hljs-function">:</span></span> self._touchCache(key, value) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_touchCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: OrderedDict.__delitem__(self, key) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> OrderedDict.__setitem__(self, key, value) toDel = len(self) - self.cacheSize <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> toDel &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> OrderedDict.keys(self)[:toDel]: OrderedDict.__delitem__(self, k) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value</code> </pre><br><br><h4>  Another solution is good performance. </h4><br>  The solution from the comments (according to the tests I used is the leader in speed), thanks to <a href="https://habrahabr.ru/users/tbd/" class="user_link">tbd</a> : <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListDictBasedCache</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> __slots__ = [<span class="hljs-string"><span class="hljs-string">'__key2value'</span></span>, <span class="hljs-string"><span class="hljs-string">'__maxCount'</span></span>, <span class="hljs-string"><span class="hljs-string">'__weights'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, maxCount)</span></span></span><span class="hljs-function">:</span></span> self.__maxCount = maxCount self.__key2value = {}<span class="hljs-comment"><span class="hljs-comment"># key-&gt;value self.__weights = []# keys ordered in LRU def __updateWeight(self, key): try: self.__weights.remove(key) except ValueError: pass self.__weights.append(key)# add key to end if len(self.__weights) &gt; self.__maxCount: _key = self.__weights.pop(0)# remove first key self.__key2value.pop(_key) def __getitem__(self, key): try: value = self.__key2value[key] self.__updateWeight(key) return value except KeyError: raise KeyError("key %s not found" % key) def __setitem__(self, key, value): self.__key2value[key] = value self.__updateWeight(key) def __str__(self): return str(self.__key2value)</span></span></code> </pre> <br><br><h4>  Comparison </h4><br>  Bare words are one thing, but unbiased numbers are another.  Therefore, I do not urge to take my word for it, on the contrary - we will measure these classes! <br>  Here the <a href="http://docs.python.org/library/timeit.html">timeit</a> module built into Python comes to <a href="http://docs.python.org/library/timeit.html">our rescue</a> : <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StubClass</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, something)</span></span></span><span class="hljs-function">:</span></span> self.something = something <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cacheClass, cacheSize, repeat)</span></span></span><span class="hljs-function">:</span></span> d = cacheClass(cacheSize) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(repeat * cacheSize): d[i] = StubClass(i) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testCacheReadGen</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cacheClass, cacheSize)</span></span></span><span class="hljs-function">:</span></span> d = cacheClass(cacheSize) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(cacheSize): d[i] = StubClass(i) self.d = d self.s = cacheSize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, repeat)</span></span></span><span class="hljs-function">:</span></span> cacheSize, d = self.s, self.d <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(cacheSize * repeat): tmp = d[random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, cacheSize<span class="hljs-number"><span class="hljs-number">-1</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minMaxAvg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lst)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(lst), max(lst), <span class="hljs-number"><span class="hljs-number">1.0</span></span> * sum(lst) / len(lst) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> timeit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAllCaches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(classes, cacheSize, repeats)</span></span></span><span class="hljs-function">:</span></span> templ = <span class="hljs-string"><span class="hljs-string">'%s: min %.5f, max %.5f, avg %.5f'</span></span> genmsg = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> cls, res: templ % ((cls.__name__.ljust(<span class="hljs-number"><span class="hljs-number">20</span></span>),) + tuple(minMaxAvg(res))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> classes: t = timeit.Timer(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: testCache(cls, cacheSize, repeats[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> genmsg(cls, t.repeat(*repeats[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAllCachesRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(classes, cacheSize, repeats)</span></span></span><span class="hljs-function">:</span></span> templ = <span class="hljs-string"><span class="hljs-string">'%s: min %.5f, max %.5f, avg %.5f'</span></span> genmsg = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> cls, res: templ % ((cls.__name__.ljust(<span class="hljs-number"><span class="hljs-number">20</span></span>),) + tuple(minMaxAvg(res))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> classes: tst = testCacheReadGen(cls, cacheSize) t = timeit.Timer(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: tst(repeats[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> genmsg(cls, t.repeat(*repeats[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'write'</span></span> testAllCaches((SimpleCache, FastCache, ODCache, ListDictBasedCache), <span class="hljs-number"><span class="hljs-number">100</span></span>, (<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'read'</span></span> testAllCachesRead((SimpleCache, FastCache, ODCache, ListDictBasedCache), <span class="hljs-number"><span class="hljs-number">100</span></span>, (<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br><br>  Startup results on my machine (Intel Core i5 2540M 2.6GHz, Win7 64-bit, ActivePython 2.7.2 x64-bit): <br><pre>  write
 SimpleCache: min 9.36119, max 9.49077, avg 9.42536
 FastCache: min 0.39449, max 0.41835, avg 0.40880
 ODCache: min 0.79536, max 0.82727, avg 0.81482
 ListDictBasedCache: min 0.25135, max 0.27334, avg 0.26000
 read
 SimpleCache: min 9.61617, max 9.73143, avg 9.66337
 FastCache: min 0.19294, max 0.21941, avg 0.20552
 ODCache: min 0.22270, max 0.25816, avg 0.23911
 ListDictBasedCache: min 0.16475, max 0.17725, avg 0.16911 </pre><br>  The difference between simple and complex solutions is quite noticeable - about 20 times!  The solution on OrderedDict is a little behind in terms of performance, but only slightly.  For further conclusions, it is necessary to make more complex measurements, reflecting the peculiarity of the cache problem ‚Äî quick access to arbitrary pieces of information, rather than some linear, as was used above. <br><br>  On memory consumption, we run the previous script with another section of main and look at the memory consumption by the Python interpreter through the task manager: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'measure me - no cache'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-comment"><span class="hljs-comment"># let user interrupt this with Ctrl-C pass testCache(FastCache, 1000, 1) print 'measure me - cached' while True: time.sleep(10) exit()</span></span></code> </pre> <br>  The measurement results are in the table: <br><table border="1"><tbody><tr><td>  Cache class </td><td>  before creating cache </td><td>  after creating cache </td><td>  cache consumption </td></tr><tr><td>  Simplecache </td><td>  4228K </td><td>  4768K </td><td>  540K </td></tr><tr><td>  Fastcache </td><td>  4232K </td><td>  4636K </td><td>  404K </td></tr><tr><td>  Odcache </td><td>  4496K </td><td>  4936K </td><td>  440K </td></tr><tr><td>  ListDictBasedCache </td><td>  4500K </td><td>  4880K </td><td>  380K </td></tr></tbody></table><br>  As you can see, a complex solution not only adds noticeably faster (~ 20 times) elements, but also consumes slightly less memory than a simple one. <br><br>  In the specific task that I solved by creating such a cache, replacing it reduced the request return time from about 90 seconds to about 70 (more dense profiling and rewriting almost the entire response generation logic then helped bring the response time to 30 seconds, but this is completely other story). </div><p>Source: <a href="https://habr.com/ru/post/147756/">https://habr.com/ru/post/147756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147751/index.html">Installing ZTE AX226 in Ubuntu 11.04 and 12.04</a></li>
<li><a href="../147752/index.html">It's not a shame to watch such an advertisement: Thematic selection of the best commercials about telecom 2012</a></li>
<li><a href="../147753/index.html">Big Systems / Big Data in Moscow</a></li>
<li><a href="../147754/index.html">History of MdlVis, Warcraft III Model Editor</a></li>
<li><a href="../147755/index.html">Decrypted In-App App Store Mechanism</a></li>
<li><a href="../147757/index.html">Write once, render anywhere - we use one template engine on the client and server</a></li>
<li><a href="../147758/index.html">A set of notes. Performance and protection, from site to system</a></li>
<li><a href="../147759/index.html">Type classes in Scala</a></li>
<li><a href="../147761/index.html">US smartphone market (new research)</a></li>
<li><a href="../147762/index.html">The history of computer science in persons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>