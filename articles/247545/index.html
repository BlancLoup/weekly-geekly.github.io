<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the development of web-applications on PSGI / Plack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Dmitriy Shamatrin. 
 With the permission of the author of the original articles of the cycle, I publish a cycle on Habr√©. 
 The original artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the development of web-applications on PSGI / Plack</h1><div class="post__text post__text-html js-mediator-article">  Author: <a href="http://pragmaticperl.com/authors/6">Dmitriy Shamatrin.</a> <br>  With the permission of the author of the original articles of the cycle, I publish a cycle on Habr√©. <br>  <a href="http://pragmaticperl.com/issues/02/pragmaticperl-02-%25D0%25B2%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B2-%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D1%2583-web-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-%25D0%25BD%25D0%25B0-psgiplack.html">The original article on the website of the magazine pragmaticperl.com</a> <br><br>  <i>PSGI / Plack is a modern way to write Perl web applications.</i>  <i>Virtually every framework supports or uses this technology in one way or another.</i>  <i>The article presents a brief introduction that will help you quickly navigate and move on.</i> <i><br></i> <br><br>  We live in a time when technologies and approaches in the field of web development change very quickly.  First there was CGI, then when it was not enough, FastCGI appeared.  FastCGI solved the main CGI problem.  In CGI, with each call, it was necessary to restart the server program, data exchange was performed using STDIN and STDOUT.  In FastCGI, interaction with the server occurs via TCP / IP or Unix Domain Socket.  Now we have PSGI. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h2>  What it is? </h2><br>  PSGI, as its developer Tatsuhiko Miyagawa says, is ‚ÄúPearl barley for web frameworks and web servers‚Äù.  The closest relatives are WSGI (Python) and Rack (Ruby).  The idea here is this.  A developer often spends quite a lot of time to adapt his application to as many engines as possible, while PSGI provides a single interface for working with various servers, which greatly simplifies life. <br><br><h2>  Special features </h2><br>  Of course, the article format does not allow to fully describe all the nuances, therefore, hereinafter there will be only key points. <br><br><ul><li>  $ env is used to exchange information between the client and the server (this is a link to the hash); </li><li>  PSGI application - a link to the Perl-function, which takes as a parameter $ env; </li><li>  the function returns a link to an array, which consists of 3 elements: HTTP status, [HTTP headers], [Response body]; </li><li>  the function may return a link to another function, but this will be discussed in other more in-depth articles; </li><li>  the file extension containing the application launch code must be .psgi. </li></ul><br><br>  At this stage, this is all that is needed in order to begin to deal with the code directly. <br><br><h2>  PSGI application </h2><br>  Below is the code for the simplest PSGI application. <br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-comment"><span class="hljs-comment">#     $env return [200, ['Content-Type' =&gt; 'text/plain'], ["hello, world\n"]]; };</span></span></code> </pre> <br><br>  We save this application in the app.psgi file, or any other with the psgi extension.  We look at the features.  Then on the code.  Then again on the features.  It all fits.  We start. <br><br>  When you run perl app.psgi, it "silently" works, but the application is not running. <br><br><h2>  Basic PSGI Servers </h2><br>  In order to run PSGI applications we need a PSGI server.  At the moment there are several servers. <br><br><ul><li>  Twiggy </li><li>  Starman </li><li>  Feersum </li><li>  Corona </li></ul><br><br><h2>  PSGI Servers in Brief </h2><br><ul><li>  Starman - pre-forking server;  works pretty fast, can do a lot out of the box, support for unix domain sockets, for example; </li><li>  Twiggy - asynchronous server, based on AnyEvent; </li><li>  Feersum - subjectively, the fastest of this entire list;  the main part is implemented as XS-modules.  Based on EV; </li><li>  Corona - asynchronous server, based on Coro. </li></ul><br><br>  All of these servers are available on CPAN.  In the future, we will use Starman, then change it to Twiggy, and then to Feersum.  Each task has its own server. <br><br><h2>  Application launch </h2><br>  The application will run exactly the same on any of these servers, maybe under Corona it will have to be slightly modified.  After installing the server, and in our case it is Starman, the starman executable should appear in / usr / bin or / usr / local / bin.  Start is made by the following command: <br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/starman app.psgi</code> </pre><br>  By default, PSGI servers use port 5000.  We can change it by running the application with the key --port 8080, for example.  Recall that PSGI is a specification.  In this case, we used this specification to write a simple web application.  Obviously, for normal development we need to implement a lot of auxiliary functions, from getting GET parameters to getting cookie data.  This all would not be without the necessary functionality. <br><br><h3>  Plack </h3><br>  Plack is a PSGI implementation (Perl has a standard Pack module, because the implementation was named Plack).  Plack makes life easier for us, as developers.  It contains a huge number of functions for working with $ env. <br>  In the basic configuration Plack consists of a fairly large number of modules.  At this stage, we are only interested in these: <br><ul><li>  Plack </li><li>  Plack :: Request </li><li>  Plack :: Response </li><li>  Plack :: Builder </li><li>  Plack :: Middleware </li></ul><br>  Plack :: Request and Plack :: Response return various values ‚Äã‚Äãof type Hash :: MultiValue, which should be noted. <br><br><h3>  Hash :: MultiValue </h3><br>  The module, the author of which is also Tatsuhiko Miyagawa, is a hash, but with one nuance.  It can store multiple values ‚Äã‚Äãin a single key.  For example: $ hash-&gt; get ('key') returns value, if there are several values ‚Äã‚Äãby key, then it will return the last one, and if all values ‚Äã‚Äãare needed, then you can use the $ hash-&gt; get_all ('key') function, then the result will be ('value1', 'value2').  Hash :: MultiValue also takes into account the context of the call, so be careful. <br><br><h3>  Plack :: Request </h3><br>  A module that contains functions for working with client requests.  There are many methods, you can always find it on CPAN.  Within this article, further, we will use the following methods: <br><ul><li>  env - returns $ env; </li><li>  method - returns the request method: GET, POST, OPTIONS, HEAD, etc .; </li><li>  path_info is an important method;  returns the local path to the current script; </li><li>  parameters - returns parameters (x-www-form-url-encoded, address line parameters) in the form of Hash :: MultiValue; </li><li>  uploads - returns parameters (transmitted using multipart-form-data) also in the form of Hash :: MultiValue. </li></ul><br><br><h3>  Plack :: Response </h3><br><ul><li>  status - sets the status (HTTP response code), when called without parameters, returns the previously set status; </li><li>  headers - sets the response headers; </li><li>  finalize - exit point, the last function of the application;  returns PSGI response according to specification. </li></ul><br><br><h3>  Plack :: Builder </h3><br>  We will not consider the methods; we only note that this is a very flexible router.  For example, it allows you to install a handler (PSGI application) to a local address: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $my_cool_app; }; };</code> </pre><br><br>  Result - calls to / will be redirected to the appropriate PSGI application.  In this case, it is $ my_cool_app. <br><br>  Routes can be nested, for example: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { mount <span class="hljs-string"><span class="hljs-string">"/another"</span></span> =&gt; builder { $my_another_cool_app; }; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $my_cool_app; }; }; };</code> </pre><br><br>  And these routes can be nested.  In this example, everything that does not go into / another is sent to /. <br><br><h3>  Plack :: Middleware </h3><br>  Base class for creating middleware applications.  Middleware is ‚Äúmiddleware‚Äù.  It is used when you need to modify a PSGI request or a ready PSGI response, as well as provide specific conditions for running a certain part of the application. <br><br><h2>  Rewrite the application on Plack </h2><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); };</code> </pre><br><br>  This is the simplest application using Plack.  It clearly demonstrates the principle of its work. <br><br>  What to look for.  $ app - function reference.  Very often, when there is a rapid spelling of something similar, a symbol is forgotten;  after the end of a reference to a function or the creation of a Plack :: Request without passing $ env.  It should be attentive. <br><br>  You can use perl -c app.psgi to check the syntax. <br><br>  Here is another important point regarding the writing of PSGI applications: when forming the response body, you should make sure that there are bytes, and not characters (for example, UTF-8).  Such an error is very difficult.  Its presence results in an empty server response with an error in psgi.error: <br><br>  "Wide character at syswrite" <br><br>  Our application starts like the previous one. <br><ul><li>  $ req is an object of type Plack :: Request;  $ req contains customer request data;  it gets them from the $ env hash, which is passed to the function; </li><li>  $ res - Plack :: Response, this is the answer to the client;  built on request using the new_response method, accepts a response code as a parameter (200 in our case); </li><li>  body - sets the response body; </li><li>  finalize - the transformation of the response object into a reference to an array of a PSGI response (which, as described above, consists of the status, headers, and body of the response). </li></ul><br><br>  Yes, Hello world is certainly not bad, but a little functional.  Now, using all the tools, let's try to write the simplest application (but it will be much more useful, really). <br><br>  We write an API that implements three functions: <br><ul><li>  the first will take the string as an input parameter and say that the string was successfully accepted;  address to address - localhost: 8080 /; </li><li>  second function will take a string as parameter and return, for example, whether it is a palindrome string (word or phrase that appears equally on both sides, for example - "Argentina mannitol Negro");  will be located at localhost: 8080 / palindrome; </li><li>  the third function will take the same string as a parameter and return it upside down;  will be located at localhost: 8080 / reverse. </li></ul><br><br>  As a result of writing the code, we should have something that can do the following things: <br><br><ul><li>  when accessing / responding that everything is ok, if the string parameter is passed; </li><li>  when accessing / palindrome, check the presence of the string parameter, respond whether it is a palindrome or not; </li><li>  when accessing / reverse, give an inverted string. </li></ul><br><br>  To turn the string, we will use the following construction: <br><br><pre> <code class="perl hljs">$string = <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $string;</code> </pre><br><br>  To determine whether a string is a palindrome, we will use the following function: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">palindrome</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $string = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $string = <span class="hljs-keyword"><span class="hljs-keyword">lc</span></span> $string; $string =~ <span class="hljs-regexp"><span class="hljs-regexp">s/\s//gs</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($string eq <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $string) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><br><h2>  application </h2><br>  Plack :: Request allows you to get parameters using the parameters method. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters();</code> </pre><br><br>  We will finalize the application and bring it to the form: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { $body = <span class="hljs-string"><span class="hljs-string">'string exists'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); };</code> </pre><br>  We start.  The first part is ready. <br><br>  Going to <a href="http://localhost/">localhost</a> : 8080 /? String = 1 we will see an answer that tells us that there is a string.  Going to <a href="http://localhost/">localhost</a> : 8080 / will return an error. <br><br>  The rest of the logic can be implemented directly in the same application, dividing the logic by path_info, which will contain the current path.  For reference, parsing path_info can be implemented as follows: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @path = <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-string"><span class="hljs-string">'\/'</span></span>, $req-&gt;path_info(); <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> @path;</code> </pre><br><br>  And now in $ path [0] is the path we need. <br><br>  <i>Important: after making changes to the code, the server must be restarted!</i> <br><br><h2>  Plack :: Builder </h2><br>  And now you should take a closer look at the router. <br><br>  It allows you to use other PSGI applications as components.  The ability to connect middleware will also be very useful. <br><br>  We will remake the first application so that it uses the router. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;header(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">charset =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { $body = <span class="hljs-string"><span class="hljs-string">'string exists'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app; }; };</code> </pre><br>  Now $ main_app is the main PSGI application.  $ app joins it at /.  In addition, a function was added to set the headers in the response (via the header method).  It is important to make an important note: in this application, to simplify all the functions are placed in one file.  For more complex applications, of course, this is not recommended. <br><br>  Now we connect the component to turn the string in the form of an application that will be located at <a href="http://localhost/">localhost</a> : 8080 / reverse. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;header(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">charset =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { $body = <span class="hljs-string"><span class="hljs-string">'string exists'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $reverse_app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { $body = <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $params-&gt;{string}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/reverse"</span></span> =&gt; builder { $reverse_app }; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app; }; };</code> </pre><br>  The verification address is <a href="http://localhost/">localhost</a> : 8080 / reverse? String = test% 20string. <br><br>  2/3 tasks completed.  However, in this case, the $ app and $ reverse_app are very similar.  Let's do a little refactoring.  Make a function that will return another function (otherwise, a higher order function). <br><br>  Now the application looks like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_app</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $param = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;header(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">charset =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($param eq <span class="hljs-string"><span class="hljs-string">'reverse'</span></span>) { $body = <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $params-&gt;{string}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'string exists'</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/reverse"</span></span> =&gt; builder { build_app(<span class="hljs-string"><span class="hljs-string">'reverse'</span></span>) }; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { build_app() }; };</code> </pre><br>  So much better.  Now add the third and last function to our API and finally finish the application.  As a result of all the improvements, the following application appeared: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_app</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $param = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;header(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">charset =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $body; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string}) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($param eq <span class="hljs-string"><span class="hljs-string">'reverse'</span></span>) { $body = <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $params-&gt;{string}; } <span class="hljs-keyword"><span class="hljs-keyword">elsif</span></span> ($param eq <span class="hljs-string"><span class="hljs-string">'palindrome'</span></span>) { $body = palindrome($params-&gt;{string}) ? <span class="hljs-string"><span class="hljs-string">'Palindrome'</span></span> : <span class="hljs-string"><span class="hljs-string">'Not a palindrome'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'string exists'</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $body = <span class="hljs-string"><span class="hljs-string">'empty string'</span></span>; } $res-&gt;body($body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">palindrome</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $string = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $string = <span class="hljs-keyword"><span class="hljs-keyword">lc</span></span> $string; $string =~ <span class="hljs-regexp"><span class="hljs-regexp">s/\s//gs</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($string eq <span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> $string) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/reverse"</span></span> =&gt; builder { build_app(<span class="hljs-string"><span class="hljs-string">'reverse'</span></span>) }; mount <span class="hljs-string"><span class="hljs-string">"/palindrome"</span></span> =&gt; builder { build_app(<span class="hljs-string"><span class="hljs-string">'palindrome'</span></span>) }; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { build_app() }; };</code> </pre><br>  Link to check: <br><br>  <a href="http://localhost/">localhost</a> : 8080 / palindrome? string = argentina% 20Manit% 20negra <br><br>  Further articles will cover more in-depth topics: middleware, sessions, cookies, server overview, with examples for each specific + small benchmarks, PSGI / Plack features and subtleties, PSGI under load, review of ways to deploy PSGI applications, PSGI framework, profiling , Starman + Nginx, running CGI scripts in PSGI mode or ‚ÄúI have a CGI application, but I want PSGI‚Äù and so on. </div><p>Source: <a href="https://habr.com/ru/post/247545/">https://habr.com/ru/post/247545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247533/index.html">Programming tutorial for kids</a></li>
<li><a href="../247535/index.html">We do tetris under FPGA</a></li>
<li><a href="../247539/index.html">ROS Speech Recognition with Google Speech API</a></li>
<li><a href="../247541/index.html">Parse security in iOS application</a></li>
<li><a href="../247543/index.html">Impress Application Server in simple terms</a></li>
<li><a href="../247547/index.html">Creating an environment for web development based on Docker</a></li>
<li><a href="../247551/index.html">Five popular myths about C ++, part 2</a></li>
<li><a href="../247553/index.html">network-enabled single-mode on FreeBSD</a></li>
<li><a href="../247555/index.html">When nobody reads Habr</a></li>
<li><a href="../247557/index.html">About goals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>