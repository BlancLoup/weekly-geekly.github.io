<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Google leanback - big brother care</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, readers of Habr. I would like to share my experience of developing an application for Android TV on the example of DetailsFragment. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Google leanback - big brother care</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, readers of Habr.  I would like to share my experience of developing an application for Android TV on the example of DetailsFragment. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2s/px/sg/2spxsgupsfjavarwj0ax_cbcrlo.jpeg"></div><br>  There are official examples <a href="https://github.com/googlesamples/androidtv-Leanback">here</a> and official documentation <a href="https://developer.android.com/training/tv/start/start.html">here</a> .  What made me express my opinion?  This is what official examples do not meet modern development requirements, for example, modularity and extensibility.  Sometimes there is a certain duality when using a particular mechanism.  Consider in more detail DetailsFragment. <br><br>  In order to start developing your application for the android platform, in my opinion, you should accept 2 basic truths: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  A bad idea to move away from official recommendations and develop a customized application.  Google took care to make it extremely difficult. </li><li>  Single Activity Architecture is also not quite suitable, it is fraught with memory leaks associated with the internal implementation of the leanback library. </li></ul><a name="habracut"></a><br>  So, first things first: <br><br><h2>  <font color="#fd004c">Briefly about the library Leanback</font> </h2><br>  The Leanback library is a set of screen templates with various functional features.  There are screens for displaying lists, content cards, dialogs, etc. These screens handle all custom transitions between elements and animations, and also have quite extensive functionality for building simple out-of-box applications.  The ideology of this library is that all applications based on it should be similar in terms of use.  My personal opinion is a pretty good idea to create a uniform application in the market.  I don't need to think anymore, will the user know what can be scrolled down?  He learns, because he has already used hundreds of similar applications. <br><br>  But, as in a large number of libraries connected to the project, there are sharp differences between the customer‚Äôs expectations of the product and the capabilities of this library.  In one example, I will try to make two main conclusions that I have drawn for myself by developing this application. <br><br><h3>  <font color="#fd004c">So, the DetailsFragment class</font> </h3><br>  This class serves to display the ‚Äúcontent card‚Äù.  Content cards are a screen space that displays complete information about a particular entity object.  In most cases, when a user clicks something in the list of similar entity objects, he hits exactly on the content card. <br><br><h3>  <font color="#fd004c">What is DetailsFragment?</font> </h3><br>  This class is a collective image of custom views.  The logical structure is as follows: <br><br><img src="https://habrastorage.org/webt/wl/mk/jb/wlmkjbloko2cl3oh8rte-nq1nqk.png"><br><br>  We will understand in order what element is engaged in. <br><br><ul><li>  ArrayObjectAdapter is a class that collects all the elements on the screen. </li><li>  DetailsOverviewRow - part of the main adapter, responsible for the display of functional elements (Actions), for information (DescriptionView) and the image of the content card. </li><li>  Additional Row - this series includes additional elements that extend the functionality of the content card. </li></ul><br>  And so at first glance, we all just have a certain ‚Äúmatryoshka‚Äù in which the roles are clearly distributed (in fact, not, then we will see this for ourselves). <br><br>  I‚Äôll dwell only on the basic concepts of DetailsOverviewRow, because in my opinion they are really quite interesting. <br><br>  The DetailsOverviewRow class has the following main methods: <br><br><ul><li>  setImageDrawable (Drawable drawable) - this method sets the ‚Äúavatar‚Äù of our content card.  An alternative method for setting avatars may be setImageBitmap (Context context, Bitmap bm). </li><li>  void setActionsAdapter (ObjectAdapter adapter) - setting the adapter for content card events (for example, buy / watch / add to favorites and so on).  ObjectAdapter is an abstract class.  In leanback there are several implementations on classic structures (for example, ArrayObjectAdapter).  We can add different classes to our ObjectAdapter, in this case we can resort to the standard Action class. </li><li>  To install DescriptionView, the constructor of the DetailsOverviewRow class is used, which accepts a certain model. </li></ul><br>  I wonder how DetailsOverviewRow puts our model with information to display?  Where does the markup for this display come from? <br><br><h2>  <font color="#fd004c">Presenter (not classic MVP)</font> </h2><br>  It so happened that Google called the class, which is responsible for how this or that model looks like within the framework of the internal view, presenter.  Next, for convenience, I will call it a UI presenter. <br><br>  So, UI presenters, this is essentially how our data objects or entity objects get on the screen.  If we draw an analogy with the classic android development, the adapter does it all. <br><br>  In the case of DescriptionView, we need to create a ui presenter that will put the model on a given custom view.  There are 2 main ways we can do this: <br><br><ul><li>  FullWidthDetailsOverviewRowPresenter - this class is derived from RowPresenter.  It is a full-screen DetailsOverviewRow display.  Appearance: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/jv/c6/ljjvc6i7_zunnruf3ix-noxwin0.png" height="500" width="350"></div></li><li>  DetailsOverviewRowPresenter is no longer supported.  Displayed as in the picture below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/pe/w-/7mpew-cn_pdz-ueyameyjqpcegk.png" height="175" width="350"></div></li></ul><br>  As a result, we choose FullWidthDetailsOverviewRowPresenter, since there are no alternatives out of the box. <br><br>  Creating a ui presenter will look like this: <br><br><pre><code class="java hljs">FullWidthDetailsOverviewRowPresenter rowPresenter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FullWidthDetailsOverviewRowPresenter( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DetailsDescriptionPresenter(context))</code> </pre> <br>  DetailsDescriptionPresenter is a class that extends from Presenter.  Responsible for the custom mapping of the entity object (most often it contains the name and description). <br><br>  As mentioned earlier, ui presenter is an analogue of the adapter in classic android.  The following methods are required for implementation: <br><br><ul><li>  ViewHolder onCreateViewHolder (ViewGroup parent) - this method is designed to create a ViewHolder object.  Here we can create our custom view and pass it to the ViewHolder. </li><li>  void onBindViewHolder (ViewHolder viewHolder, Object item) is a method for constructing our ViewHolder.  As you can see, there is a little slippery situation here, since the data object is transferred as a java object.  You can get a runtime error if you use the downward transform incorrectly. </li><li>  void onUnbindViewHolder (ViewHolder viewHolder) - this method serves to free our holder from resources so that the garbage collector can safely remove it. </li></ul><br><h2>  <font color="#fd004c">Overall picture</font> </h2><br>  Throughout the android TV project, you will use an ArrayObjectAdapter with custom presentations, you may be using factories presenters.  It‚Äôs worth remembering that they simply invest in each other and in the implementation of a specific screen they give some form of presentation.  For example, I created my own descendant class ui presenter, called it AbstractCardPresenter.  This class has rescued me more than once as it smoothes bumps with the transformations at the level of their appearance.  Also created a basic representation of the cards.  This helped me reuse ready-made views where they are needed and partially customize the cards. <br><br><div class="spoiler">  <b class="spoiler_title">AbstractCardPresenter</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCardPresenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseCardView</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String TAG = <span class="hljs-string"><span class="hljs-string">"AbstractCardPresenter"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Context mContext; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AbstractCardPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ mContext = context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mContext; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ T cardView = onCreateView(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewHolder(cardView); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewHolder viewHolder, Object item)</span></span></span><span class="hljs-function"> </span></span>{ Card card = (Card) item; onBindViewHolder(card, (T) viewHolder.view); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUnbindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewHolder viewHolder)</span></span></span><span class="hljs-function"> </span></span>{ onUnbindViewHolder((T) viewHolder.view); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUnbindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T cardView)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Card card, T cardView)</span></span></span></span>; }</code> </pre><br></div></div><br><h2>  <font color="#fd004c">‚ÄúBad idea to move away from official recommendations‚Äù?</font> </h2><br>  It is bad because in the classes that were carefully written for us, most of the methods are immutable for the simple reason of strong inner connectedness.  In order not to disturb the internal state of the screen (in fact, DetailsFragment and others are fragments), you should use them as intended.  I will not go into the details of the implementation of the internal classes, the state machine and other ideas of the developers of this library.  A real example from my work is the leakage of a fragment using the Single Activity Architecture. <br><br>  This leak was associated with DetailsFragment transitions.  Through trial and error, we managed to find the cause of the leak, fix the leak and write a report to the bug.  Given the low power of the TVs themselves (Sony Brawia 4K 2GB RAM), the OOM problem is quite acute.  Leakage is eliminated by zeroing these transitions.  When using transitions between activations, this problem was not observed. <br><br><pre> <code class="java hljs">TransitionHelper.setReturnTransition(getActivity().getWindow(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); TransitionHelper.setEnterTransition(getActivity().getWindow(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre> <br><h2>  <font color="#fd004c">Out of the box does not work!</font> </h2><br>  If you really want (requires the customer) to change this or that display, you can do this, I will tell you with an example I encountered.  For my development experience under android tv, I have seen many constraints: it is impossible to track the internal fragments created by the library;  their life cycle is not controlled by anyone;  calls to create custom views in constructors (asynchronous data cannot be used).  Google did almost everything so that it was impossible to write ‚Äúhow to‚Äù.  Taking into account modern requests, a non-flexible mechanism turns out to be bad and not needed, but since there are no alternatives (apart from writing your own leanback), you have to live with what we have. <br><br>  The first thing that drew my attention to the implementation of the box is the avatar of the content card.  When you switch the focus up and down, it is absolutely non-animated twitching down. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mj/og/qf/mjogqfszqpeaetj9txz1gcmxby8.gif"><br></div></div><br>  Having narrowed down the search for classes that are responsible for this view, I went to the implementation of the FullWidthDetailsOverviewRowPresenter class to find the answer to the question of how it moves.  I managed to find a method that is responsible for moving the avatar of our content card - void onLayoutLogo (ViewHolder viewHolder, int oldState, boolean logoChanged). <br><br>  The default implementation was as follows: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Layout logo position based on current state. Subclass may override. * The method is called when a logo is bound to view or state changes. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> viewHolder The row ViewHolder that contains the logo. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> oldState The old state, can be same as current viewHolder.getState() * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> logoChanged Whether logo was changed. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewHolder viewHolder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> logoChanged)</span></span></span><span class="hljs-function"> </span></span>{ View v = viewHolder.getLogoViewHolder().view; ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) v.getLayoutParams(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mAlignmentMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ALIGN_MODE_START: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lp.setMarginStart(v.getResources().getDimensionPixelSize( R.dimen.lb_details_v2_logo_margin_start)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ALIGN_MODE_MIDDLE: lp.setMarginStart(v.getResources().getDimensionPixelSize(R.dimen.lb_details_v2_left) - lp.width); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (viewHolder.getState()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATE_FULL: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lp.topMargin = v.getResources().getDimensionPixelSize(R.dimen.lb_details_v2_blank_height) - lp.height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATE_HALF: lp.topMargin = v.getResources().getDimensionPixelSize( R.dimen.lb_details_v2_blank_height) + v.getResources() .getDimensionPixelSize(R.dimen.lb_details_v2_actions_height) + v .getResources().getDimensionPixelSize( R.dimen.lb_details_v2_description_margin_top); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATE_SMALL: lp.topMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } v.setLayoutParams(lp); }</code> </pre><br>  The implementation was found, then I created a descendant class FullWidthDetailsOverviewRowPresenter in which I redefined the onLayoutLogo method and wrote my implementation. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomMovieDetailsPresenter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullWidthDetailsOverviewRowPresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPreviousState = STATE_FULL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomMovieDetailsPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Presenter detailsPresenter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(detailsPresenter); setInitialState(FullWidthDetailsOverviewRowPresenter.STATE_FULL); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLayoutLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ViewHolder viewHolder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> logoChanged)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View v = viewHolder.getLogoViewHolder().view; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) v.getLayoutParams(); lp.setMarginStart(v.getResources().getDimensionPixelSize( android.support.v17.leanback.R.dimen.lb_details_v2_logo_margin_start)); lp.topMargin = v.getResources().getDimensionPixelSize(android.support.v17.leanback.R.dimen.lb_details_v2_blank_height) - lp.height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (viewHolder.getState()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATE_FULL: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPreviousState == STATE_HALF) { v.animate().translationY(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STATE_HALF: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPreviousState == STATE_FULL) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = v.getResources().getDimensionPixelSize(android.support.v17.leanback.R.dimen.lb_details_v2_actions_height) + v .getResources().getDimensionPixelSize(android.support.v17.leanback.R.dimen.lb_details_v2_description_margin_top)+lp.height/<span class="hljs-number"><span class="hljs-number">2</span></span>; v.animate().translationY(offset); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } mPreviousState = viewHolder.getState(); v.setLayoutParams(lp); } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fz/bc/bu/fzbcbu3k99xuz38nhgjdkka3cjc.gif"><br></div></div><br>  In this case, everything was decided relatively simply, with the state when the screen goes down, we animatedly descend behind it and the avatar of the content card.  When returning to the starting position, the animated avatar is also animated upwards.  But there are cases that the method is declared final or is inaccessible, then I resorted to reflection.  Reflection is an extreme stage, as it has several disadvantages: <br><br><ul><li>  When updating the library, it may happen that the field to which we accessed through reflection is renamed, or even worse, is deleted. </li><li>  Reflection is quite a resource-intensive operation, which often causes difficulties in the operating system </li><li>  Reflection is difficult to read and difficult to maintain. </li></ul><br>  In other words, reflection is an extreme instance, to which I resorted once.  But how - I remember the mechanism. <br><br><h2>  <font color="#fd004c">A little bit about the multi-layered architecture in android tv application</font> </h2><br>  In this case, everything is relatively simple, problems can arise only in the layer of user views, since it is sometimes difficult to understand exactly where this or that element belongs.  Returning to our example with DetailsFragment, the real tasks will be something like the following: If the content is purchased, display the ‚ÄúWatch‚Äù button;  If the content is rented, then display the watch button + rental end time, etc .;  With all this, there is a button trailer, a button to add to favorites, etc.  In my opinion, the presenter (MVP) should receive some kind of model and call the addAction method (android.support.v17.leanback.widget.Action action).  That is, based on the data, the presenter concludes which buttons should be added, generates them and invokes the corresponding external interface method with a view.  This is where the problem of dependency presenter from the library leanback.  Since, for good, you need to use this presenter in other parts of our program, for example, on a mobile device, the problem arises rather sharply.  Thus, I introduced a rule for developing presenters in a project in which I participate - not to declare implicit dependencies in the presenter that are tied to the framework. <br><br>  To avoid this, it was decided in the presenters to use a local analogue of android.support.v17.leanback.widget.Action.  This solved a lot of problems in the presenter, but it gave rise to a twofold logic in the twist associated with processing the position of adding and handling pressure, since in the twist we can easily operate with widgets provided by leanback.  The same twofold logic appears when the set of buttons is initially unknown, but they have certain priorities.  For example, the ‚Äúwatch‚Äù button should be in front of the trailer button, the buy button should be after the trailer, and so on.  Accordingly, a certain mechanism appears in the view that matches the identifiers of the buttons and their positions, which makes an ‚Äúpriority to display‚Äù from the identifier.  I avoided this situation quite trivially, but again with the twist I am beginning to acquire logic and know that this is not just an identifier. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; mActionsIndexesList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MovieDetailAction movieDetailAction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Action action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action(movieDetailAction.getId(), movieDetailAction.getTitle(), movieDetailAction.getSubTitle(), movieDetailAction.getIcon()); actionAdapter.set(movieDetailAction.getId(), action); mActionsIndexesList.add(movieDetailAction.getId()); Collections.sort(mActionsIndexesList); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSelectedAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> actionId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Handler().postDelayed(() -&gt; mActionsGridView.smoothScrollToPosition(getActionPositionByActionId(actionId)), <span class="hljs-number"><span class="hljs-number">100</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActionPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> actionId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mActionsIndexesList.indexOf(actionId); }</code> </pre><br><h2>  <font color="#fd004c">In custody</font> </h2><br>  Android Tv application development is relatively new, and therefore interesting.  At the time of this writing, the Android Tv community is decentralized and therefore most of the problems are solved by ‚Äútreading their tracks‚Äù.  Also, in my opinion, programming within limited resources (RAM, computational power, etc.) is quite interesting.  Such a pattern of thinking is not always peculiar to developers of classic android applications and in my opinion is a useful experience. </div><p>Source: <a href="https://habr.com/ru/post/351084/">https://habr.com/ru/post/351084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351072/index.html">Password change: 10 steps to good implementation</a></li>
<li><a href="../351074/index.html">How to quickly write and roll out in the production of machine learning algorithm</a></li>
<li><a href="../351078/index.html">Performance and runtime at the JPoint 2018 conference</a></li>
<li><a href="../351080/index.html">Accelerate javascript build using webpack 2-3</a></li>
<li><a href="../351082/index.html">Operating systems from scratch; Level 1 (younger half)</a></li>
<li><a href="../351086/index.html">Calculation of the timing and cost of projects: how is this done and is it possible to simplify the process?</a></li>
<li><a href="../351090/index.html">Welcome to the CocoaHeads Special Event March 24</a></li>
<li><a href="../351092/index.html">Count Joseph Flavius: whom to kill first</a></li>
<li><a href="../351094/index.html">How to build a GSM phone based on SDR</a></li>
<li><a href="../351096/index.html">dev || bet - the battle of programmers and technology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>