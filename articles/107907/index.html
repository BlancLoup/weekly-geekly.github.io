<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WYSIWYG HTML editor in the browser. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes the practice of using the properties of designMode and contentEditable, as well as related APIs on the example of creating a sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WYSIWYG HTML editor in the browser. Part 3</h1><div class="post__text post__text-html js-mediator-article">  The article describes the practice of using the properties of designMode and contentEditable, as well as related APIs on the example of creating a simple text editor. <a name="habracut"></a><hr>  Translation of the first article in the series, examining the theory of using designMode and contentEditable and related APIs: <a href="http://habrahabr.ru/blogs/webdev/107829/">Part 1</a> .  <a href="http://habrahabr.ru/blogs/webdev/107880/">Part 2</a> . <br><br><h4>  Introduction </h4>  In the <a href="http://dev.opera.com/articles/view/rich-html-editing-in-the-browser-part-1/">first part of the article</a> I examined in detail the theory of creating a browser editor using the properties designMode and contentEditable.  These DOM properties are standardized in HTML 5 and more or less supported in most browsers.  In the second part of the article, I will move from theory to practice, having considered the creation of a simple cross-browser text editor. <br>  You can see the <a href="http://olav.dk/code/dev.opera.com/edit/">finished version of the editor online</a> and <a href="">download its code</a> .  Listings show only the most interesting parts of the code that require explanation, the rest of the code is not considered, because it is boring.  The code is divided into three files: <ul><li>  editor.js: The main infrastructure of the application. </li><li>  editlib.js: A set of functions for modifying selections </li><li>  util.js: A library of general purpose functions. </li></ul><h4>  Frame </h4>  As a basis, we will use a blank page inside the IFrame: <blockquote><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"editorFrame"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"blank.html"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </blockquote>  We can use about: blank to get an absolutely empty page, without elements inside the body, but I preferred to create my own ‚Äúempty‚Äù page, as this will allow us to start working with an empty paragraph in the body. <blockquote><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></blockquote>  This is preferable, since Mozilla starts typing text into an empty p, like all other browsers.  If this is not done, she enters the text directly into the body.  Using the contentEditable property we can do without a frame, but Firefox 2 does not support contentEditable, so it‚Äôs best to still use iFrame.  ( <i>Translator's note: FF2, to put it mildly, is not relevant. So, I think, iframe is no longer needed.</i> ) <br><br><h4>  Setting the edit mode </h4>  We enable editing mode when the page loads, using the function (located in editor.js) <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEditor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> editFrame = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"editorFrame"</span></span>); editFrame.contentWindow.document.designMode=<span class="hljs-string"><span class="hljs-string">"on"</span></span>; } bindEvent(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, <span class="hljs-string"><span class="hljs-string">"load"</span></span>, createEditor);</code> </pre></blockquote>  bindEvent is a function responsible for binding a function to an event (defined in util.js).  Frames, like jQuery, have corresponding functionality that you will most likely prefer to use. The next step is to create a control panel with minimal formatting functions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Control Panel </h4>  Let's start with a simple control: the ‚Äúbold‚Äù button, which will change the outline of the selected text to bold.  Another button should display the state of the document - if the entry point is inside the text in boldface, the button should be highlighted. clicks and syncs button state.  Separation is necessary, since different commands must separate one logic, as we will see later.  Events are triggered at two points - when the user presses a button on the control panel, the controller triggers a command that runs on the document and when the user moves the cursor in the document, we change the state of the button on the control panel. <br><br><h4>  Command and controller implementation </h4>  Since the <b>bold</b> command is initially supported by the API, our command object is just a small wrapper. <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command, editDoc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ editDoc.execCommand(command, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queryState = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> editDoc.queryCommandState(command) }; }</code> </pre></blockquote><blockquote>  <i>Why do we need a wrapper at all?</i>  <i>Since we want our non-standard commands to have the same interface as the standard ones.</i> </blockquote>  Our button is just a span: <blockquote><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boldButton"</span></span></span><span class="hljs-tag">&gt;</span></span>Bold<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></blockquote>  The span is associated with the command object through the controller: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TogglCommandController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command, elem</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateUI = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = command.queryState(); elem.className = state?<span class="hljs-string"><span class="hljs-string">"active"</span></span>:<span class="hljs-string"><span class="hljs-string">""</span></span>; } bindEvent(elem, <span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ command.execute(); updateToolbar(); }); }</code> </pre></blockquote>  <i>A code that was responsible for maintaining the focus of the editing window when you clicked on the button on the control panel was dropped from the listing.</i>  Below we call the ToggleCommandController function to synchronize the state of the button and draw the text, taking into account their two states.  When a button is pressed, the command is executed.  When an updateUI event is raised, the span receives the ‚Äúactive‚Äù class, or loses it, depending on the state of the text.  CSS properties that determine the appearance of the button: <blockquote><pre> <code class="html hljs xml">.toolbar span { border: outset; } .toolbar span.active { border: inset; }</code> </pre></blockquote>  The components are related as follows: <blockquote><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = Command(<span class="hljs-string"><span class="hljs-string">"Bold"</span></span>, editDoc); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elem = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(√ÆboldButton); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TogglCommandController(command, elem); updateListeners.push(controller);</code> </pre></blockquote>  The updateListeners collection contains controllers for the control panel.  The updateToolbar function iterates the list and calls the updateUI method for each controller so that all controls are exactly up to date.  We attach events so that the updateToolbar is called every time the document selection changes: <blockquote><pre> <code class="javascript hljs">bindEvent(editDoc, <span class="hljs-string"><span class="hljs-string">"keyup"</span></span>, updateToolbar); bindEvent(editDoc, <span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>, updateToolbar);</code> </pre></blockquote>  Just as shown above, updateToolbar is called when a command is executed.  Why do we update the entire control panel after executing each command, instead of updating only the button associated with the command?  Since the state of other controls as a result of the command may also change.  For example, if we use the right alignment command, the state of the left alignment button and the centering button will also change.  Instead of keeping track of all possible dependencies, it is easier to update the entire control panel. Now we have a basic interface for commands with two states.  Using the resulting framework, the Bold, Italic, JustifyLeft, JustifyRight, and JustifyCenter commands are implemented. <br><br><h4>  Link </h4>  After we implemented the basic text formatting commands, I decided to give users the ability to add links to the document.  Managing links requires more complex logic, since createLink does not work as we would like.  It creates a link, but does not return information about whether the selection is inside the link or not.  And we need this to synchronize the state of the control panel and the selection. How can we check if the selection is inside the link?  We will do this by writing a function getContaining, which rises above the DOM tree from the element where the cursor is located, until we find the parent of the required type (References in this case. The function returns nothing if the required element is not found).  If the selection is inside the a tag, we are inside the link. We also need a way to request a URL from the user.  A cooler editor would create a custom dialog for this request, but to simplify the task, we simply use the standard window.prompt function.  If the selection inside the link we show its current URL, so that the user could change it.  Otherwise, we simply show the prefix http: //. The code of the Linkcommand function: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">editDoc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tagFilter = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elem</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elem.tagName==<span class="hljs-string"><span class="hljs-string">"A"</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//(1) this.execute = function() { var a = getContaining(editWindow, tagFilter); //(2) var initialUrl = a ? a.href : "http://"; //(3) var url = window.prompt("Enter an URL:", initialUrl); if (url===null) return; //(4) if (url==="") { editDoc.execCommand("unlink", false, null); //(5) } else { editDoc.execCommand("createLink", false, url); //(6) } }; this.queryState = function() { return !!getContaining(editWindow, tagFilter); //(7) }; }</span></span></code> </pre></blockquote>  The logic of the function is as follows: <ol><li>  The function checks if the current item is the desired item.  TagName is always returned in upper case, regardless of the case in the code. </li><li>  getContaining searches for an element with the given name containing the given one.  If it is not found, returns null. </li><li>  If a link is found among the parent elements, we add the href attribute to the dialog.  Otherwise, it will be standard http: //. </li><li>  The prompt returns null if the user clicks Cancel.  In this case, the command is terminated. </li><li>  If the user deletes the URL and clicks OK, then we assume that the user wants to delete the link.  For this we use the standard unlink command. </li><li>  If the user enters the URL and clicks OK, then we create the link using the createLink command.  (if the link already exists, then we replace the URL with a new one). </li><li>  A double negative results in a Boolean type - true if the element is found and false otherwise. </li><li>  We can combine LinkCommand with standard ToggleCommandController, since the control panel interface remains unchanged: all the same methods execute and queryState. </li></ol><h4>  Getcontaining </h4>  Let's look at the getContaining function (found in editlib.js).  The function checks whether the selection is inside an element of a certain type. This is all somewhat more complicated, since the IE API works slightly differently than the API of other browsers.  Therefore, we will have to create two independent implementations of the function and a mechanism that will determine which of them should be used - we will do this by determining the presence of the getSelection property.  Here so: <blockquote><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getContaining = (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.getSelection)?w3_getContaining:ie_getContaining;</code> </pre></blockquote>  The implementation of the function in IE is more interesting, since it shows some features of the selection API in IE. <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ie_getContaining</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">editWindow, filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selection = editWindow.document.selection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection.type==<span class="hljs-string"><span class="hljs-string">"Control"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//(1) // control selection var range = selection.createRange(); if (range.length==1) { var elem = range.item(0); //(3) } else { // multiple control selection return null; //(2) } } else { var range = selection.createRange(); //(4) var elem = range.parentElement(); } return getAncestor(elem, filter); }</span></span></code> </pre></blockquote>  It works like this: <ol><li>  The type of the selection object is either ‚ÄúControl‚Äù or ‚ÄúText‚Äù.  Objects (Control) can be selected several (that is, the user can select several non-adjacent images using ctrl + click). </li><li>  We will not handle the situation with several selected objects;  In this case, we simply cancel the command and nothing happens. </li><li>  If we have one object in the selection, we select it. </li><li>  If the selection is textual, we use this to get the container. </li></ol>  The API used by other browsers is relatively simple: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w3_getContaining</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">editWindow, filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> range = editWindow.getSelection().getRangeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//(1) var container = range.commonAncestorContainer; //(2) return getAncestor(container, filter); }</span></span></code> </pre></blockquote>  It works like this: <ol><li>  While the API allows for multiple selection, the user interface allows only one, so we consider only the first and only range. </li><li>  This method gets the element that contains the current selection. </li></ol>  The getAncestor function is simple - we simply go up the hierarchy of elements until we find what we are looking for or until we reach the top of the hierarchy, in this case we return null: <blockquote><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* walks up the hierachy until an element with the tagName if found. Returns null if no element is found before BODY */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAncestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elem, filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (elem.tagName!=<span class="hljs-string"><span class="hljs-string">"BODY"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filter(elem)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elem; elem = elem.parentNode; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre></blockquote><br><h4>  Commands accepting multiple meanings </h4>  Such editing elements as the choice of font and size require a slightly different approach, since the user can select several options of values.  In the interface for the implementation of this, we used the drop-down list instead of the button, as before.  In addition, we will need to rewrite the objects Command and Controller, so that they can work with a set of values, and not just binary states. Here is the HTML code to select the font: <blockquote><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fontSelector"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span>Default<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Courier"</span></span></span><span class="hljs-tag">&gt;</span></span>Courier<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Verdana"</span></span></span><span class="hljs-tag">&gt;</span></span>Verdana<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Georgia"</span></span></span><span class="hljs-tag">&gt;</span></span>Georgia<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></blockquote>  The command object is still simple, as it is a superstructure of the standard FontName command: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValueCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command, editDoc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ editDoc.execCommand(command, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, value); }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queryValue = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> editDoc.queryCommandValue(command) }; }</code> </pre></blockquote>  The difference between ValueCommand and the previously described commands with binary states is the presence of the queryValue method, which returns the current value as a string.  The controller executes the command when the user selects a value in the drop-down list. <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValueSelectorController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command, elem</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateUI = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = command.queryValue(); elem.value = value; } bindEvent(elem, <span class="hljs-string"><span class="hljs-string">"change"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ editWindow.focus(); command.execute(elem.value); updateToolbar(); }); }</code> </pre></blockquote>  The controller is quite simple, since we use the values ‚Äã‚Äãin the drop-down list directly as values ‚Äã‚Äãfor the command. The drop-down list of font sizes works in the same way - we use the FontSize built-in command and use sizes from 1 to 7 as available values. <br><br><h4>  Non-standard teams </h4>  Until now, we have made all changes to HTML using standard, built-in commands.  But sometimes you may need to change the HTML in a way that no built-in command can do.  In this case, we use the DOM and Range API. As an example, we will create a command that will add some HTML to the entry point.  To keep things simple, it will just span with the text ‚ÄúHello World‚Äù.  But the approach will not change if you want to insert paste any other HTML. The command will look like this: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HelloWorldCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elem = editWindow.document.createElement(<span class="hljs-string"><span class="hljs-string">"SPAN"</span></span>); elem.style.backgroundColor = <span class="hljs-string"><span class="hljs-string">"red"</span></span>; elem.innerHTML = <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>; overwriteWithNode(elem); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queryState = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre></blockquote>  The chip in the overwriteWithNode function, which inserts an element at the current entry point.  (The name of the method indicates that if there is a non-empty selection, its contents will be overwritten).  Due to the differences in DOM between IE and browsers that support the DOM Range standard, the method is applied differently. Let's first consider the version working with the DOM Range: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w3_overwriteWithNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rng = editWindow.getSelection().getRangeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); rng.deleteContents(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isTextNode(rng.startContainer)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refNode = rightPart(rng.startContainer, rng.startOffset) refNode.parentNode.insertBefore(node, refNode); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refNode = rng.startContainer.childNodes[rng.startOffset]; rng.startContainer.insertBefore(node, refNode); } }</code> </pre></blockquote>  range.deleteContents, according to its name, deletes the contents of the selection, if it is not degenerate.  (If the selection is degenerate, then it simply does nothing).  The DOM Range object has properties that allow us to define an input point in the DOM: startContainer is the node that contains the input point and startOffset is the number that indicates the position of the input point in the parent node.  For example, if startContainer is an element and startOffset is three, then the input point is between the third and fourth descendant of the element.  If startContainer is a text node, then startOffset means the offset in characters from the beginning of the parent.  For example, startOffset equal to 3 means that the input point is between the third and fourth characters. <br><br><blockquote>  <i>endContainer and endOffset in the same way indicate the end of the selection.</i>  <i>If the selection is empty (degenerate), then they have the same value as that of startContainer and startOffset.</i> </blockquote><br><br>  If the entry point is inside a text node, then we should split it into two, so that we can insert our data between them.  rightPart is a function that does just that - splits a text node into two nodes and returns the right-hand side.  Then we can use insertBefore to insert the new nodes to the desired point. The version for IE is somewhat trickier.  In IE, the Range object does not provide access to information about the position of the insertion point in the DOM.  Another problem is that we can only paste data using the pasteHTML method, which takes HTML as an argument as a string, not as a tree of DOM nodes.  In general, the IE Range API is completely isolated from the DOM API!  But there is a trick that allows you to still share the DOM API and the IE Range API: We use pasteHTML to insert a marker with a unique ID to find the desired entry point in the DOM: <blockquote><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ie_overwriteWithNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> range = editWindow.document.selection.createRange(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> marker = writeMarkerNode(range); marker.appendChild(node); marker.removeNode(); <span class="hljs-comment"><span class="hljs-comment">// removes node but not children } // writes a marker node on a range and returns the node. function writeMarkerNode(range) { var id = editWindow.document.uniqueID; var html = "&lt;span id='" + id + "'&gt;&lt;/span&gt;"; range.pasteHTML(html); var node = editWindow.document.getElementById(id); return node; }</span></span></code> </pre></blockquote>  Pay attention to remove the marker node after it is finished.  This is necessary not to clog the HTML code. Now we have a command that inserts arbitrary HTML into the selection point.  We used the button on the control panel and the ToggleCommandController function to associate this action with the user interface. <br><br><h4>  findings </h4>  In this article, we looked at a simple framework for creating an HTML editor.  The code can be used as a template for developing more complex editors. </div><p>Source: <a href="https://habr.com/ru/post/107907/">https://habr.com/ru/post/107907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../107900/index.html">Ask.com closes search service</a></li>
<li><a href="../107901/index.html">Questions to Vladimir Ofitserov (worked at Inktomi, Yahoo, Yandex, Google)</a></li>
<li><a href="../107903/index.html">Telephony on Cisco (Call Manager Express) - Part 2</a></li>
<li><a href="../107905/index.html">Download content via YQL</a></li>
<li><a href="../107906/index.html">Published a stop list of domains. RF</a></li>
<li><a href="../107908/index.html">Case "Designing a web service for booking tickets." Business analysis. Description of existing business processes (AS-IS)</a></li>
<li><a href="../107909/index.html">Do sailors have questions?</a></li>
<li><a href="../107910/index.html">ICQ - pay for each user of an alternative client?</a></li>
<li><a href="../107911/index.html">The success of TNT in the fight against pirates</a></li>
<li><a href="../107912/index.html">Lovers of short addresses: the list is still free dvebukvy.rf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>