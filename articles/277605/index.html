<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nuances of developing a plugin for Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently faced with writing plugins for Unity. There was no experience before, and I am only a 2-3 month user of this environment. During the developm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nuances of developing a plugin for Unity</h1><div class="post__text post__text-html js-mediator-article">  Recently faced with writing plugins for Unity.  There was no experience before, and I am only a 2-3 month user of this environment.  During the development of the plugin a lot of interesting points have accumulated, about which there is little information on the Internet.  I want to describe all these moments in more detail for the pioneers, so that they do not fall on the same rake, which I myself attacked many and many times. <br><br>  This article should also be useful for experienced users.  It will consider a useful toolkit and the nuances of plug-in development for OSX, Windows, iOS and Android. <br><a name="habracut"></a><br>  With playing video in Unity for a long time, not everything worked out well.  Built-in tools are very limited, and on mobile platforms they can play videos only in full screen mode, which is not ice for game devas!  At the beginning we used third-party plugins.  However, there either lacked the necessary functionality, or there were bugs, the fixes of which had to wait a long time (if they were fixed at all).  For this reason, we decided to write our own video decoder version for Unity with <s>blackjack and w ...</s> , stop, and with features. <br><br>  I will not post the creation of the plug-in and the code myself - sorry, commercial secret, but I‚Äôll stop on general principles.  To implement the video decoder, I took the codecs vp8 and vp9, which can play the open and WebM format that does not require license fees.  After decoding a video frame, we receive data in the YUV color model.  Then we write each component in a separate texture.  In essence, this is where the plugin‚Äôs work ends.  Further in the Unity itself, the shader decodes the YUV into the RGB color model, which we already apply to the object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You ask - why the shader?  Good question.  At first I tried to convert the color model software on the processor.  For desktops, this is acceptable, and performance is not particularly low, but on mobile platforms, the picture is radically different.  On the iPad 2 in the working scene, the software converter gave 8-12 FPS.  When color conversion in the shader received 25-30 FPS, which is already a normal playable indicator. <br><br>  Let's move on to the nuances of plugin development. <br><br><h1>  Main provisions </h1><br>  The documentation for writing plug-ins for Unity is rather scarce, everything is described in general terms (for iOS, I found many nuances by myself).  <a href="http://docs.unity3d.com/Manual/Plugins.html">Link</a> to dock. <br><br>  What pleases - there are examples collected under the current studios and platforms (except for iOS: probably, Apple did not pay extra to the developers).  The examples themselves are updated with each update of Unity, but there is also a fly in the ointment: APIs often change, interfaces, defaults and constants are renamed.  For example, I took a fresh update, from where I used a new leader.  Then I understood for a long time why the plugin does not work on mobile platforms, until I noticed: <br><br><pre><code class="cpp hljs">SUPPORT_OPENGLES  <span class="hljs-comment"><span class="hljs-comment">//  SUPPORT_OPENGL_ES // </span></span></code> </pre> <br>  Probably the only important point for all platforms that needs to be immediately taken into account is the rendering cycle.  Rendering in Unity can be performed in a separate stream.  This means that the main thread will not work with textures.  To resolve this situation, the scripts have a function <i>IssuePluginEvent</i> , which at the right time pulls the callback, where the work with the resources needed for rendering should be performed.  When working with textures (creation, update, deletion) I recommend using corute, which will pull the callback at the end of the frame: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCoroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {            <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEndOfFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;            GL.IssuePluginEvent(MyPlugin.GetRenderEventFunc(),magicnumber);     } }</code> </pre><br>  What is interesting, if you try to work with textures in the main thread, then the game falls only on the DX9 API, and even then not always. <br><br><h1>  Osx </h1><br>  Probably the most simple and hassle-free platform.  The plugin is going to fast, debugging is also easy.  In xCode, do attach to Process ‚Üí Unity.  You can set bryaki, watch the callstack in the fall, etc. <br><br>  There was only one interesting point.  Recently, Unity has been updated to version 5.3.2.  In the editor, the main graphics API was OpenGL 4, in the older version there was OpenGL 2.1, which is now deprecated.  In the updated version, the editor simply did not lose the video.  Quick debug showed that the function <i>glTexSubImage2D (GL_TEXTURE_2D, 0, 0, 0, width, height, GL_ALPHA, GL_UNSIGNED_BYTE, buffer)</i> returns the error <i>GL_INVALID_ENUM</i> .  Judging by the OpenGL documentation, <i>GL_RED</i> came to replace the <i>GL_ALPHA</i> pixel format, which does not work with OpenGL 2.1 ... I had to back up with a crutch: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLubyte * strVersion = glGetString (GL_VERSION); m_oglVersion = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(strVersion[<span class="hljs-number"><span class="hljs-number">0</span></span>] ‚Äì <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_oglVersion &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) pixelFormat = GL_RED; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pixelFormat = GL_ALPHA;</code> </pre><br>  And the most mysterious thing is that in the final build, compiled under OpenGL 4, everything works fine with the <i>GL_ALPHA</i> flag.  Recorded this nuance in the section of magic, but still made humanly. <br><br>  Unity Editor can be run on an older version of OGL.  To do this, we write in the console: <br><br> <code>Applications/Unity/Unity.app/Contents/MacOS/Unity -force-opengl <br></code> <br>  From useful utilities I want to mention the OpenGL Profiler, which is part of Graphics Tools.  Tools can be downloaded from the Apple site in the Developer section.  The profiler allows you to fully track the status of OpenGL in the application, you can catch errors, view the contents of textures (size, type, format), shaders and buffers in video memory, set breakpoints for different events.  A very useful tool for working with graphics.  Screenshot: <br><br><img src="https://habrastorage.org/files/7d3/58e/c03/7d358ec0380f45408fb32a5529acba17.png"><br><br>  So I found out that the Unity Editor uses 1326 textures. <br><br><h1>  Windows </h1><br>  On this platform, the OpenGL version of the plugin is also assembled without any problems.  But on DirectX 9 I will stop in more detail. <br><br>  1. DirectX 9 has such a feature as a lost device.  OpenGL and DirectX (starting with the 10th version) are free from this drawback.  In fact, there is a loss of control over graphic resources (textures, shaders, meshes in video memory, etc.).  It turns out that we have to handle this situation, and if it happened, we must load or create all the textures again.  According to my observations in many plugins, this is exactly what they do.  I managed to cheat a little: I create textures from Unity scripts, and then pass them pointers to the plugin.  Thus, I leave all the resource management to Unity, and he does an excellent job with the device loss situation. <br><br><pre> <code class="cpp hljs">MyTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(w,h, TextureFormat.Alpha8, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); MyPlugin.SetTexture(myVideo, MyTexture.GetNativeTexturePtr());</code> </pre><br>  2. When it seemed everything was ready, an unexpected problem emerged.  Sometimes and only on some videos the picture was displayed with an offset, as shown in the screenshot: <br><br><img src="https://habrastorage.org/files/2b0/57d/61b/2b057d61b1f1464aa2f91c4d33d11b5c.png"><br><br>  Judging by the appearance of the image, the error could be present in the algorithm for copying data into a texture, in texture coordinates, or was associated with a texture wrap.  Documentation suggested that DirectX, for optimization, can align texture sizes by adding extra bytes.  This information is stored in the structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D3DLOCKED_RECT</span></span></span><span class="hljs-class"> {</span></span> INT  Pitch; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pBits; }</code> </pre><br>  <i>Pitch</i> - the number of bytes in the same row of the texture with alignment. <br>  A little tweaking the copying algorithm got the desired result (added pixels filled with zeros): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(pbyDst, pbySrc, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * width); pixelsDst += locked_rect.Pitch; pixelsSrc += width; }</code> </pre><br>  To debug OpenGL, use the gDEBugger utility, which is similar in functionality to the OpenGL Profiler for OSX: <br><br><img src="https://habrastorage.org/files/8f8/6b5/a6d/8f86b5a6d88740d580e691b9fef6b0cf.gif"><br><br>  Unfortunately, I did not find such utilities for DX9.  Having such a tool would help in finding an error with copying data into a texture. <br><br><h1>  Ios </h1><br>  An example of a project for this platform in the samples was not.  In the documentation there is little useful information and basically only about access to functions from the plugin. <br><br>  I will focus on the important aspects: <br><br>  1. In xCode, we create an ordinary iOS project with the type StaticLib.  We connect OpenGL frameworks - and you can build a plugin. <br><br>  2. The name of the final plugin file does not matter.  In Unity, functions are imported from all plug-ins that are in the iOS folder: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__Internal"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre><br>  3. An important point - if you have a function with the same name in another plugin, then build the build will fail.  Unity ticker will use double implementation.  Advice - call it so that no one thinks of such a name. <br><br>  4. <i>UnityPluginLoad (IUnityInterfaces * unityInterfaces)</i> , which should be called when the plug-in is loaded, is not called!  To find out when the plug-in is still started and get information about the current render device, you need to create your controller inherited from <i>UnityAppController</i> and register the function call for the start of the plug-in and <i>RenderEvent in it</i> .  The created file should be placed in the folder with plug-ins for iOS.  An example implementation of a controller for registering functions: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityAppController.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void MyPluginSetGraphicsDevice(void* device, int deviceType, int eventType); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void MyPluginRenderEvent(int marker); @interface MyPluginController : UnityAppController { } - (void)shouldAttachRenderDelegate; @end @implementation MyPluginController - (void)shouldAttachRenderDelegate; { UnityRegisterRenderingPlugin(&amp;MyPluginSetGraphicsDevice, &amp;MyPluginRenderEvent); } @end IMPL_APP_CONTROLLER_SUBCLASS(MyPluginController)</span></span></code> </pre><br>  5. If the plugin uses several different architectures, for convenience, they can be combined into one static library: <br><br> <code>lipo -arch armv7 build/libPlugin_armv7.a\ <br> -arch i386 build/libPlugin _i386.a\ <br> -create -output build/libPlugin .a <br></code> <br>  6. During testing, I found out that negative texture coordinates are not transferred from the vertex shader to the pixel shader ‚Äî always zeroes come.  By default, textures are created with the address mode <i>CLAMP_TO_EDGE</i> .  In this case, OpenGL ES cuts everything to the range [0..1].  On desktop platforms this is not observed. <br><br>  7. A serious bug was noticed.  If you compile a project for iOS with Script Debugging enabled, then xCode will also crash in the game.  As a result, neither the logs, nor the callstack ... <br><br>  Debugging a plugin for the iOS platform is a pleasure - in xCode there is always a callstack when it crashes.  In the console, you can read the logs of both the scripts and the plug-in, and if you add * .CPP files of the plug-in to the project, you can set breakpoints and use the full functionality of the lldb debugger!  But with scripts everything is much worse, so logging to help. <br><br><h1>  Android </h1><br>  Building for Android requires the most tools: <br><br>  - normal IDE for editing C ++ code.  I used xCode.  And in general, on a Mac for Android, it is somehow easier to compile; <br>  - NDK to build C code into a static library; <br>  - Android Studio with all its needs like Java, etc. The studio is needed for convenient logging of what is happening in the application. <br><br>  Let's walk through interesting points: <br><br>  1. The situation with debugging plug-ins in Android is rather sad, so I recommend to immediately think about writing logs to a file.  You can, of course, get bogged down and try to set up remote debugging, but I didn‚Äôt have time for this and had to go a simpler way by viewing the logs through Android Studio.  To do this, in android / log.h there is a function __android_log_vprint, which works like printf.  For convenience, wrapped in a cross-platform view: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugLog</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* fmt, ...)</span></span></span><span class="hljs-function"> </span></span>{ va_list argList; va_start(argList, fmt); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_ANDROID __android_log_vprint(ANDROID_LOG_INFO, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MyPluginDebugLog"</span></span></span><span class="hljs-meta">, fmt, argList); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> printf (fmt, argList); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> va_end(argList); }</span></span></code> </pre><br>  I advise you not to bypass <i>asserts</i> .  If they are triggered, Android Studio allows you to view the full call stack. <br><br>  2. On this platform, special plugin naming specificity is libMyPluginName.so.  For example, the lib prefix is ‚Äã‚Äãrequired (more details can be found in the Unity documentation). <br><br>  3. In an Android application, all resources are stored in one bundle, which is a jar or zip file.  We can not just open the stream and start reading the data, as in other platforms.  In addition to the video path, you need an Application.dataPath, which contains the path to the Android apk, only in this way can we get and open the necessary asset.  From here we get the length of the file and its offset from the beginning of the bundle: <br><br><pre> <code class="cs hljs">unityPlayer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AndroidJavaClass(<span class="hljs-string"><span class="hljs-string">"com.unity3d.player.UnityPlayer"</span></span>)) activity = unityPlayer.GetStatic&lt;AndroidJavaObject&gt;(<span class="hljs-string"><span class="hljs-string">"currentActivity"</span></span>) assetMng = activity.Call&lt;AndroidJavaObject&gt;(<span class="hljs-string"><span class="hljs-string">"getAssets"</span></span>) assetDesc = assetMng.Call&lt;AndroidJavaObject&gt;(<span class="hljs-string"><span class="hljs-string">"openFd"</span></span>, myVideoPath); offset = assetFileDescriptor.Call&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"getStartOffset"</span></span>); length = assetFileDescriptor.Call&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"getLength"</span></span>);</code> </pre><br>  Open the file stream on the way <i>Application.dataPath with</i> standard tools (fopen or whatever you like), and start reading the file with offset <i>offset</i> - this is our video.  The length is needed to know when the video file will end and to stop further reading. <br><br>  4. Found a bug. <br><br><pre> <code class="cpp hljs">s_DeviceType = s_Graphics-&gt;GetRenderer();</code> </pre><br>  <i>s_DeviceType</i> always contains <i>kUnityGfxRendererNull</i> .  Judging by the forums, this is a Unity error.  I wrapped Android part of the code in define, where by default I determined: <br><br><pre> <code class="cpp hljs">s_DeviceType = kUnityGfxRendererOpenGLES</code> </pre><br>  When developing for Android, you need to be ready to constantly dig in the console and rebuild regularly.  If you initially configure Android.mk and Application.mk correctly, then problems with the build should not arise. <br><br>  Well, sort of, and all.  I tried to dwell on all the important points that were not obvious from the beginning.  Now that you have this knowledge, you can develop a normal plug-in architecture in advance, and you will not have to rewrite the code several times. <br><br><h1>  As a conclusion </h1><br>  According to my preliminary calculations, this work was supposed to take 2-3 weeks, but it took 2 months.  Most of the time had to spend on clarifying the points described above.  The most tedious and long stage is Android.  The process of rebuilding static libraries and the project took about 15 minutes, and debugging was done by adding new logs.  So stock up on coffee and be patient.  And do not forget about the frequent crashes and hangs Unity. <br><br>  I hope this material will be useful and will help save valuable time.  Criticism, questions - welcome! <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/277605/">https://habr.com/ru/post/277605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277593/index.html">List of machine learning resources. Part 2</a></li>
<li><a href="../277597/index.html">How we used Git, CI and code review in the learning process</a></li>
<li><a href="../277599/index.html">Hello, World! On FPGA. Blink LED</a></li>
<li><a href="../277601/index.html">How we automate testing with release management - Part 1</a></li>
<li><a href="../277603/index.html">The rules of good tone when writing a plugin on jQuery</a></li>
<li><a href="../277609/index.html">What to replace Cisco? Import Substitution Access Switches</a></li>
<li><a href="../277615/index.html">Testing plugins for Apache Cordova</a></li>
<li><a href="../277617/index.html">Do not miss the chance to get on // Build: develop or update the UWP application and participate in Race to Build 2016</a></li>
<li><a href="../277625/index.html">Blockchain application stack</a></li>
<li><a href="../277629/index.html">Write code that is easy to remove and not add</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>