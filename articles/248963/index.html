<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 5 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the main course 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 5 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content of the main course </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/"><b>Article 5: We write shaders for our library</b></a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><br><br><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li></ul><br><br><br><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It's time for fun, let's first look at the size of the <a href="https://github.com/ssloy/tinyrenderer/tree/f037c7a0517a632c7391b35131f9746a8f8bb235">current code</a> : <br><ul><li>  geometry.cpp + .h - <b>218</b> lines </li><li>  model.cpp + .h - <b>139</b> lines </li><li>  our_gl.cpp + .h - <b>102</b> lines </li><li>  main.cpp - <b>66</b> lines </li></ul><br><br>  A total of <b>525 lines</b> .  Exactly what I promised at the very beginning of the course.  And note that we are engaged in rendering only in our_gl and main, which is only 168 lines, and nowhere have we called third-party libraries, we have done all the drawing from scratch! <br>  <b>I remind you that my code is needed only for the final comparison with your working code!</b>  <b>In an amicable way, you should write everything from scratch if you follow this series of articles.</b>  <b>I beg you, make the craziest shaders and post pictures in the comments !!!</b> <br><br><img src="https://habrastorage.org/files/985/b3c/0ea/985b3c0eac7544fea05f6f9b56e03690.png"><br><a name="habracut"></a><br>  <i>The black triangles on the horns are a slightly broken model, I just tired of the head of the old Negro, but I don‚Äôt want to fix it.</i> <br><br><hr><br><h1>  Refactor our code to look like the OpenGL structure </h1><br>  So, our main.cpp starts to grow slightly, so let's divide it into two parts <br><ul><li>  <b>our_gl.cpp + .h</b> is a part that we cannot program, roughly speaking, a binary library file. </li><li>  <b>main.cpp</b> - here we can program what we want. </li></ul><br><br>  Let's take a look at what I brought to <b>our_gl</b> ?  The functions of constructing matrices of projection, type and transition to screen coordinates, as well as the matrices themselves, are simply global variables.  Well, the triangle rasterizer function.  Everything! <br><br>  Here is the contents of the file <b>our_gl.h</b> (about the appointment of IShader later): <br><pre><code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"tgaimage.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"geometry.h"</span></span> extern Matrix ModelView; extern Matrix Viewport; extern Matrix Projection; void viewport(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h); void projection(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> coeff=<span class="hljs-number"><span class="hljs-number">0.</span></span>f); <span class="hljs-comment"><span class="hljs-comment">// coeff = -1/c void lookat(Vec3f eye, Vec3f center, Vec3f up); struct IShader { virtual ~IShader(); virtual Vec3i vertex(int iface, int nthvert) = 0; virtual bool fragment(Vec3f bar, TGAColor &amp;color) = 0; }; void triangle(Vec4f *pts, IShader &amp;shader, TGAImage &amp;image, TGAImage &amp;zbuffer);</span></span></code> </pre> <br><br>  <b>There</b> are only 66 lines left in the <b>main.cpp file</b> , so I give it entirely (sorry for the sheet, but I like this file so much that I won't hide it under the spoiler): <br><pre> <code class="hljs lua">#include &lt;vector&gt; #include &lt;iostream&gt; #include <span class="hljs-string"><span class="hljs-string">"tgaimage.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"model.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"geometry.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"our_gl.h"</span></span> Model *model = NULL; const int width = <span class="hljs-number"><span class="hljs-number">800</span></span>; const int height = <span class="hljs-number"><span class="hljs-number">800</span></span>; Vec3f light_dir(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); Vec3f eye(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vec3f center(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Vec3f up(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); struct GouraudShader : public IShader { Vec3f varying_intensity; // written by vertex shader, <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> by fragment shader virtual Vec4f vertex(int iface, int nthvert) { varying_intensity[nthvert] = std::<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, model-&gt;normal(iface, nthvert)*light_dir); // get diffuse lighting intensity Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> the vertex from .obj file <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates } virtual bool fragment(Vec3f bar, TGAColor &amp;color) { float intensity = varying_intensity*bar; // interpolate intensity <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the current pixel color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)*intensity; // well duh <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; // no, we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> discard this pixel } }; int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>** argv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>==argc) { model = new Model(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { model = new Model(<span class="hljs-string"><span class="hljs-string">"obj/african_head.obj"</span></span>); } lookat(eye, center, up); viewport(width/<span class="hljs-number"><span class="hljs-number">8</span></span>, height/<span class="hljs-number"><span class="hljs-number">8</span></span>, width*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>, height*<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>); projection(<span class="hljs-number"><span class="hljs-number">-1.</span></span>f/(eye-center).norm()); light_dir.normalize(); TGAImage image (width, height, TGAImage::RGB); TGAImage zbuffer(width, height, TGAImage::GRAYSCALE); GouraudShader shader; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model-&gt;nfaces(); i++) { Vec4f screen_coords[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { screen_coords[j] = shader.vertex(i, j); } triangle(screen_coords, shader, image, zbuffer); } image. flip_vertically(); // to place the origin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the bottom left corner of the image zbuffer.flip_vertically(); image. write_tga_file(<span class="hljs-string"><span class="hljs-string">"output.tga"</span></span>); zbuffer.write_tga_file(<span class="hljs-string"><span class="hljs-string">"zbuffer.tga"</span></span>); delete model; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Let's analyze it in detail.  Headings are skipped, then global constants follow: screen sizes, where the camera is located, etc. <br>  The structure of GouraudShader will be analyzed in the next paragraph, skipping.  Then it goes directly to main (): <br><ul><li>  Reading a model from an .obj file </li><li>  Initialization of the matrices ModelView, Projection and Viewport (remember, the variables themselves are stored in our_gl module) </li><li>  Passing through the model and drawing it </li></ul><br><br>  The last point begins the most interesting.  The outer loop passes through all triangles. <br>  The inner loop passes through all the vertices of the triangle and for each of them calls the vertex shader. <br><br>  <b>The main purpose of the vertex shader is to calculate the transformed vertex coordinates.</b>  <b>The secondary is to prepare data for the operation of the fragment shader.</b> <br><br>  What happens after we call the vertex shader for all the vertices in the triangle?  We can call the rasterizer of our triangle.  What happens inside it we do not know (no, well, we wrote it ourselves, of course).  Except for one interesting thing.  The triangle rasterizer calls <b>our</b> function, which we give it ‚Äî the fragment shader.  That is, once again, for each pixel inside the triangle, the rasterizer calls a fragment shader. <br><br>  <b>The main purpose of the fragment shader is to determine the color of the current pixel.</b>  <b>Secondary - we can refuse to paint at all this pixel, returning true.</b> <br><br>  OpenGL 2 Pipeline looks like this: <br><img src="http://3dgep.com/wp-content/uploads/2014/01/OpenGL-2.0-Programmable-Shader-Pipeline.png"><br><br>  Since we have a short course of graphics, for now let's restrict ourselves to these two shaders.  In newer versions of OpenGL, new types of shaders have appeared that allow you to create geometry on the fly.  In this picture in blue shows the stages that we can not program, and the red are those that we can.  In fact, our main () is primitive processing.  She calls the vertex shader.  We do not have a collector of primitives, because  we draw blunt triangles directly (it stuck together with primitive processing).  The triangle () function is a rasterizer, for each point it calls a fragment shader and then does depth checks in the z-buffer, and so on. <br><br>  Everything.  You know what shaders are and you can start programming them. <br><br><h1>  How does my embodiment of shaders work on the example of tinting Guro </h1><br><br>  Let's analyze those shaders that I brought in the code <b>main.cpp</b> .  As you might guess, the first shader is the toning of Guro. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://www.loria.fr/~sokolovd/infographie/04-geometry/tmp/output.png"></div></div><br><br>  The vertex shader reads the vertex from the .obj file, plunges it into four-dimensional space (see previous article), finds its screen coordinates.  Returns a projected 3D point, but before that it considers the diffuse luminance coefficient for a given vertex and saves it to the corresponding component of the varying_intensity vector. <br><br>  Once again, the code for convenience: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> Vec3f varying_intensity; // written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> vertex shader, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> fragment shader virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { varying_intensity[nthvert] = std::max(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, model-&gt;normal(iface, nthvert)*light_dir); // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> diffuse lighting intensity Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> the vertex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .obj file <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Viewport*Projection*ModelView*gl_Vertex; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> screen coordinates }</code> </pre><br></div></div><br><br>  varying is a reserved word in the GLSL language, I used varying_intensity as the name just to emphasize the parallel between them (we'll talk about GLSL in the seventh article).  We save in the varying structure the data that will be interpolated inside the triangle, and the fragment shader will receive the already interpolated data. <br><br>  Let's analyze the fragment shader, once again the code for convenience: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript"> Vec3f varying_intensity; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> vertex shader, read <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> fragment shader <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [...] virtual bool fragment(Vec3f bar, TGAColor &amp;color) { float intensity = varying_intensity*bar; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> interpolate intensity <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the current pixel color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)*intensity; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> well duh <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">no</span></span>, we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> discard <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> pixel }</code> </pre><br></div></div><br><br>  It is called a rasterizer for each pixel inside the triangle.  It takes as input <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D1%2580%25D0%25B8%25D1%2586%25D0%25B5%25D0%25BD%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D1%258B">barycentric coordinates</a> for interpolating varying_ data. <br><br>  That is, the interpolated intensity can be calculated as varying_intensity [0] * bar [0] + varying_intensity [1] * bar [1] + varying_intensity [2] * bar [2] or simply the scalar product between the varying_intensity vectors * bar.  In the present GLSL, of course, the shader gets a ready-made value. <br><br>  Note that the fragment shader returns a boolean value.  Its value is easy to understand if you look inside the rasterizer ( <b>our_gl.cpp</b> , triangle ()): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> TGAColor color; <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span> = shader.fragment(c, color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>) { zbuffer.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(Px, Py, TGAColor(Pz)); image.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(Px, Py, color); }</code> </pre><br></div></div><br>  The shader may refuse to draw this pixel, then the rasterizer ignores its z-coordinate without updating the z-buffer.  Useful if we want to do binary masks or whatever else comes to your head. <br><br>  Of course, the rasterizer cannot even come up with what comes into your head, so it cannot compile with your shader in advance.  This is where the abstract class IShader comes to the rescue.  Uff, infrequently I use abstract classes, but there is exactly a case when it would be bad without him.  I don't want to pass pointers to functions at all! <br><br><hr><br><br><h1>  First modification </h1><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vec3f bar, TGAColor &amp;color</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity = varying_intensity*bar; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intensity&gt;<span class="hljs-number"><span class="hljs-number">.85</span></span>) intensity = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intensity&gt;<span class="hljs-number"><span class="hljs-number">.60</span></span>) intensity = <span class="hljs-number"><span class="hljs-number">.80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intensity&gt;<span class="hljs-number"><span class="hljs-number">.45</span></span>) intensity = <span class="hljs-number"><span class="hljs-number">.60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intensity&gt;<span class="hljs-number"><span class="hljs-number">.30</span></span>) intensity = <span class="hljs-number"><span class="hljs-number">.45</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intensity&gt;<span class="hljs-number"><span class="hljs-number">.15</span></span>) intensity = <span class="hljs-number"><span class="hljs-number">.30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">155</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)*intensity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br></div></div><br><br>  I just allow some fixed set of light intensities.  Here is the result of his work: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://www.loria.fr/~sokolovd/infographie/04-geometry/tmp/f2bf83c5994b9051aaba499cb05e65bf.png"></div></div><br><br><hr><br><br><h1>  Texture model </h1><br>  Phong's tinted skip, it was disassembled in detail in the comments, let's apply textures.  To do this, you have to interpol the uv-coordinates.  Nothing new, just add the matrix in two rows (uv) and three columns (texture coordinates of three vertices). <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct Shader : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IShader { Vec3f varying_intensity; // written <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> vertex shader, <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> fragment shader mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_uv; // same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> above virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert)); varying_intensity[nthvert] = std::max(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, model-&gt;normal(iface, nthvert)*light_dir); // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> diffuse lighting intensity Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> the vertex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .obj file <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Viewport*Projection*ModelView*gl_Vertex; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> screen coordinates } virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> fragment(Vec3f bar, TGAColor &amp;color) { <span class="hljs-type"><span class="hljs-type">float</span></span> intensity = varying_intensity*bar; // interpolate intensity <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> pixel Vec2f uv = varying_uv*bar; // interpolate uv <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> pixel color = model-&gt;diffuse(uv)*intensity; // well duh <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>, we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span> this pixel } };</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="https://hsto.org/files/51f/723/ffe/51f723ffe99f4c6888a13091796da8f7.png"></div></div><br><hr><br><h1>  Normalmapping </h1><br><br>  Okay, now we have texture coordinates.  But after all, not only color can be stored in textures, RGB is enough to represent xyz! <br>  Let's load this texture, which for each pixel of our image (and not just for the vertices, as before!) Will give a normal vector. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://www.loria.fr/~sokolovd/infographie/04-geometry/tmp/african_head_nm.png"></div></div><br>  By the way, compare it with such a picture, this is the same information, but in a different reference: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://www.loria.fr/~sokolovd/infographie/04-geometry/tmp/african_head_nm_tangent.png"></div></div><br><br>  One of these pictures gives normal vectors in the global coordinate system, and the other in the tangent, which is defined for each point of our object.  In this texture, the vector z is the normal to the object, the vector x is the vector of the main direction of curvature of the surface, and y is their vectorial product. <br><h3>  Exercise 1 </h3>  Tell me, which of these textures is given in global coordinates, and which in tangents to the object? <br><h3>  Exercise 2 </h3>  Which texture format is preferred - tangent or global?  Why? <br><br>  <b>Please do not hesitate (without reading the comments in advance) to give answers to these questions in the comments!</b> <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs ruby">struct Shader : public IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,float&gt; varying_uv; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> same as above mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,float&gt; uniform_M; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Projection*ModelView mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,float&gt; uniform_MIT; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> (Projection*ModelView).invert_transpose() virtual Vec4f vertex(int iface, int nthvert) { varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert)); Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> read the vertex from .obj file <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Viewport*Projection*ModelView*gl_Vertex; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> transform it to screen coordinates } virtual bool fragment(Vec3f bar, TGAColor &amp;color) { Vec2f uv = varying_uv*bar; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> interpolate uv <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the current pixel Vec3f n = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_MIT*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;normal(uv))).normalize(); Vec3f l = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_M *embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(light_dir )).normalize(); float intensity = std::max(<span class="hljs-number"><span class="hljs-number">0</span></span>.f, n*l); color = model-&gt;diffuse(uv)*intensity; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> well duh <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> no, we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> discard this pixel } }; [...] Shader shader; shader.uniform_M = Projection*ModelView; shader.uniform_MIT = (Projection*ModelView).invert_transpose(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;model-&gt;nfaces(); i++) { Vec4f screen_coords[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { screen_coords[j] = shader.vertex(i, j); } triangle(screen_coords, shader, image, zbuffer); }</code> </pre><br></div></div><br><br>  The uniform keyword in GLSL allows you to transfer constants to shaders, here I passed the Projection * Modelview matrix and its reverse transposed to the shader in order to transform normal vectors (see previous article). <br>  That is, everything is the same as before, only we do not interpolate the normal vector, but take it from the prepared texture, while not forgetting to transform the vector of the direction of light and the normal vector properly. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/161/ecc/7c4/161ecc7c4f0147ca8ae66f0eb21baf29.png"></div></div><br><br><hr><br><br><h1>  Shiny surfaces or specular mapping </h1><br><br>  We continue the conversation!  For the (cheap) deception of the eye, we use <a href="http://en.wikipedia.org/wiki/Phong_reflection_model">the Phong approximation</a> to illuminate the model.  The total luminosity of this area is made up of constant illumination for the whole scene (ambient lighting), illumination for matte surfaces, which we have considered so far (diffuse lighting) and illumination for glossy surfaces (specular lighting): <br><br><img src="http://hsto.org/getpro/habr/comment_images/e37/20a/5df/e3720a5dfedc49edb0bf70f8bc64204a.png"><br><br>  We considered matte surfaces as the cosine of the angle between the normal vector and the light vector.  That is, we assumed that the surface scatters light in approximately all directions.  What happens to glossy surfaces?  In the limiting case (for mirror surfaces) we have light if we see a source of light from this pixel. <br><br>  Here is a picture: <br><img src="http://hsto.org/files/d58/cd3/bba/d58cd3bbab46463e87b782a12a147fbb.png"><br>  If for a given point we considered illumination for matte surfaces as the cosine of the angle between the vectors <b>n</b> and <b>l</b> , then now we are interested in the cosine of the angle between the vectors <b>r</b> (reflected light) and <b>v</b> (direction of gaze). <br><br><h3>  Exercise 3: find the vector r, having vectors n and l </h3><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  if n and l are normalized, then <b>r</b> = 2 <b>n</b> &lt; <b>n</b> , <b>l</b> &gt; - <b>l</b> </div></div><br><br>  I remind you that we considered the light for a matte surface as the cosine of an angle.  But the glossy reflects the source in a much more focused beam!  What will happen if we do the same, only we will raise this cosine to the tenth power?  I remind you that the numbers less than one in the tenth degree will decrease in relation to themselves!  That is, the tenth degree will give a significantly smaller radius of light.  And the hundredth is even smaller.  This degree is stored in a texture that gives glossiness for each point of the surface. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct Shader : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; varying_uv; // same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> above mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; uniform_M; // Projection*ModelView mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; uniform_MIT; // (Projection*ModelView).invert_transpose() virtual Vec4f vertex(<span class="hljs-type"><span class="hljs-type">int</span></span> iface, <span class="hljs-type"><span class="hljs-type">int</span></span> nthvert) { varying_uv.set_col(nthvert, model-&gt;uv(iface, nthvert)); Vec4f gl_Vertex = embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> the vertex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .obj file <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Viewport*Projection*ModelView*gl_Vertex; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> screen coordinates } virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> fragment(Vec3f bar, TGAColor &amp;color) { Vec2f uv = varying_uv*bar; Vec3f n = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_MIT*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;normal(uv))).normalize(); Vec3f l = proj&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(uniform_M *embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(light_dir )).normalize(); Vec3f r = (n*(n*l*<span class="hljs-number"><span class="hljs-number">2.</span></span>f) - l).normalize(); // reflected light <span class="hljs-type"><span class="hljs-type">float</span></span> spec = pow(std::max(rz, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f), model-&gt;specular(uv)); <span class="hljs-type"><span class="hljs-type">float</span></span> diff = std::max(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, n*l); TGAColor c = model-&gt;diffuse(uv); color = c; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++) color[i] = std::min&lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span> + c[i]*(diff + <span class="hljs-number"><span class="hljs-number">.6</span></span>*spec), <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } };</code> </pre><br></div></div><br><br>  Actually, there is nothing to explain here, except for the coefficients.  In line <br><pre>         for (int i = 0; i &lt;3; i ++) color [i] = std :: min &lt;float&gt; (5 + c [i] * (diff + .6 * spec), 255);
</pre><br>  I took 5 for ambient, 1 for diffuse and .6 for specular.  What exactly to take - you decide.  This gives the impression of different materials.  Most often they are given by the artist, but in this case I don‚Äôt have them, so I took about from the bald. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/5ac/940/44f/5ac94044fb2b405f9b9c1647e5b86feb.png"></div></div><br><br><h1>  Conclusion </h1><br>  We have learned how to render very realistic scenes, but the lighting is still far from ideal.  In the next article I will talk about what shadow mapping is.  In one of the orthogonal articles, I will talk about how the new rasterizer works (nothing prevents you from running the same code on the old rasterizer!). </div><p>Source: <a href="https://habr.com/ru/post/248963/">https://habr.com/ru/post/248963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248949/index.html">Finance in Excel + VBA. Black-Scholes Option Calculator</a></li>
<li><a href="../248955/index.html">Aurelia - a new modern JS framework</a></li>
<li><a href="../248957/index.html">ErgoEmacs - a way to Lisp</a></li>
<li><a href="../248959/index.html">Arduino do-it-yourself soldering station</a></li>
<li><a href="../248961/index.html">Vivaldi - what are the features of the new browser</a></li>
<li><a href="../248965/index.html">Test Case Management Tool: how to make the right choice and not regret it</a></li>
<li><a href="../248967/index.html">HP 3PAR StoreServ Webinar</a></li>
<li><a href="../248969/index.html">Panoramic passive radar</a></li>
<li><a href="../248971/index.html">Static analysis of PHP code on the example of symfony2</a></li>
<li><a href="../248973/index.html">27 years of Arctic ice in one minute</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>