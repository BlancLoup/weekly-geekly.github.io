<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go profiling and optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this article, I will explain how to profile and optimize Go applications using the built-in and common tools available in Linux. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go profiling and optimization</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In this article, I will explain how to profile and optimize Go applications using the built-in and common tools available in Linux. <br><br>  What is profiling and optimization?  If your program is not running fast enough, it uses too much memory, it is not optimally using the processor, you want to understand what's wrong, and fix it - this is profiling and optimization. <br><br>  I gave such a definition in order to immediately cut off the issues of incorrect application operation.  In this article we will not talk about the problems of multi-thread programming, about data flights (English <i>data race</i> ), about finding errors (English <i>debugging</i> ).  For all this, Go has its own utilities and approaches, but we will leave this topic for the future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/cc7/3da/ec9/cc73daec92724c60954e0eebae8918a5.jpg"></div><br><br><a name="habracut"></a><br><br><h2>  CPU </h2><br>  Let's start today's review with the processor. <br><br>  In Go there is a built-in profiler, made in the image and likeness of a profiler from the gperftools C / C ++ utility set.  Moreover, an analogue of the pprof utility, designed for visualization of profiling results, has now become the main version and is recommended for visualization for both Go and C / C ++. <br><br>  If we talk about classification, the Go profiler is ‚Äúsampling‚Äù.  This means that with some periodicity we interrupt the work of the program, take the stack trace, write it somewhere, and at the end, based on how often there are different functions in the stack traces, we understand which of them used more processor resources, and some less. <br><br>  We can run almost all Go utilities and profilers in several ways, some of which are described in this article. <br><br>  Let's start with an example, and then we'll talk more. <br><br><h3>  Example </h3><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> perftest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"regexp"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> haystack = <span class="hljs-string"><span class="hljs-string">`Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras accumsan nisl et iaculis fringilla. Integer sapien orci, facilisis ut venenatis nec, suscipit at massa. Cras suscipit lectus non neque molestie, et imperdiet sem ultricies. Donec sit amet mattis nisi, efficitur posuere enim. Aliquam erat volutpat. Curabitur mattis nunc nisi, eu maximus dui facilisis in. Quisque vel tortor mauris. Praesent tellus sapien, vestibulum nec purus ut, luctus egestas odio. Ut ac ipsum non ipsum elementum pretium in id enim. Aenean eu augue fringilla, molestie orci et, tincidunt ipsum. Nullam maximus odio vitae augue fermentum laoreet eget scelerisque ligula. Praesent pretium eu lacus in ornare. Maecenas fermentum id sapien non faucibus. Donec est tellus, auctor eu iaculis quis, accumsan vitae ligula. Fusce dolor nisl, pharetra eu facilisis non, hendrerit ac turpis. Pellentesque imperdiet aliquam quam in luctus. Curabitur ut orci sodales, faucibus nunc ac, maximus odio. Vivamus vitae nulla posuere, pellentesque quam posuere`</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSubstring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { strings.Contains(haystack, <span class="hljs-string"><span class="hljs-string">"auctor"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkRegex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { regexp.MatchString(<span class="hljs-string"><span class="hljs-string">"auctor"</span></span>, haystack) } }</code> </pre> <br>  Before you are two benchmarks, each of which N does a search for a substring in a string.  One does this using a regular expression package, and the other using the strings package.  We are looking for the word auctor. <br><br>  Run the benchmark and look at the results. <br><br><pre> <code class="hljs pgsql">$ go test -bench=. testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkSubstring<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">194</span></span> ns/op BenchmarkRegex<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200000</span></span> <span class="hljs-number"><span class="hljs-number">7516</span></span> ns/op PASS ok github.com/mkevac/perftest00 <span class="hljs-number"><span class="hljs-number">3.789</span></span>s</code> </pre> <br>  The result is expected, because  Regular expressions are much more powerful and therefore slower, but let's try to profile this code. <br><br>  The easiest way to use the profiler in this case is to run the same benchmark with the additional option <i>-cpuprofile cpu.out</i> .  As a result, the <i>cpu.out</i> file will appear in the directory with the results of the profiling and the binary, which is necessary for getting characters, disassembling, etc. <br><br>  The binary is actually always created, but in the usual case it is created in the temporary directory and deleted immediately after the execution of the benchmark.  In the case of a start with profiling, the resulting binary is not deleted. <br><br>  So, let's run BenchmarkRegex <i>Benchmark</i> with profiling: <br><br><pre> <code class="hljs pgsql">$ GOGC=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span> go test -bench=BenchmarkRegex -cpuprofile cpu.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkRegex<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200000</span></span> <span class="hljs-number"><span class="hljs-number">6773</span></span> ns/op PASS ok github.com/mkevac/perftest00 <span class="hljs-number"><span class="hljs-number">1.491</span></span>s</code> </pre> <br>  As you can see, I launched the benchmark with the prefix <i>GOGC = off</i> at the beginning.  The environment variable GOGC, set to off, disables the garbage collector.  I did it consciously, so that the garbage collector and its stack traces did not distract us from the course of my story. <br><br>  By the way, disabling GC for short-lived scripts and programs is an excellent solution that can reduce the program runtime at times.  And not only in Go.  For PHP, we also sometimes use this "trick", as far as I know.  In fact, we reduce the running time due to the memory used on the server. <br><br>  We now use the pprof utility to visualize the call graph. <br><br><pre> <code class="hljs cs">$ go tool pprof perftest00.test cpu.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span></code> </pre> <br>  The easiest way to get a graph is the web command, which automatically saves the SVG image to a temporary directory and launches the browser to display it. <br><br>  If you are working on a remote server, this option will not work.  You need to either proxy the X server using the -Y switch for SSH, or save the SVG file to disk with the command <i>go tool pprof -svg ./perftest00.test ./cpu.out&gt; cpu.svg</i> , copy it to your computer and there open up. <br><br>  In the case of OSX, like mine, you will need to install an XQuartz X server in order for it to work through SSH. <br><br>  Let's look at the resulting call graph. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7f7/5d6/082/7f75d608276c4f8db6f4ba30cc918c99.png"></div><br><br>  Studying such a graph, first of all you need to pay attention to the thickness of the edges (arrows) and the size of the nodes of the graph (squares).  The time is signed on the edges: how long the given node or any of the lower nodes was in the stack trace during the profiling. <br><br>  Let's go on the bold arrows from the very first (top) node and get to the first fork. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f5f/e63/dc6/f5fe63dc625e408cb11c30224b6510dd.png"></div><br><br>  We see our <i>BenchmarkRegex</i> function, we see the <i>regexp.MatchString</i> function that we call, and we see that it splits. <br><br>  If you have ever used regular expressions, then you most likely know that most implementations divide the process into the compilation stage of the initial string representation of the regular expression into some kind of intermediate variant and the actual use of this intermediate variant. <br><br>  A trivial optimization suggests itself: compile once, not repeatedly. <br><br>  Let's do it: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> perftest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"regexp"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> haystack = <span class="hljs-string"><span class="hljs-string">`Lorem ipsum dolor sit amet, consectetur adipiscing [...] Vivamus vitae nulla posuere, pellentesque quam posuere`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern = regexp.MustCompile(<span class="hljs-string"><span class="hljs-string">"auctor"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSubstring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { strings.Contains(haystack, <span class="hljs-string"><span class="hljs-string">"auctor"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkRegex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { pattern.MatchString(haystack) } }</code> </pre> <br>  And see what has changed: <br><br><pre> <code class="hljs pgsql">$ go test -bench=. testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkSubstring<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">170</span></span> ns/op BenchmarkRegex<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">297</span></span> ns/op PASS ok github.com/mkevac/perftest01 <span class="hljs-number"><span class="hljs-number">3.685</span></span>s</code> </pre> <br>  As you can see, the variant with regular expressions has accelerated by an order of magnitude and came close to the variant with a simple search for substrings. <br><br>  But how did the call graph change?  He became "much simpler", because  compilation is now done only once.  Moreover, the compilation call did not fall into the graph at all, since  profiling is sampling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/18a/49f/075/18a49f075f06426f8807084f16bc03e8.png"></div><br><br>  Fine.  Let's see what other ways we have in order to run the Go-profiler CPU. <br><br><h3>  Ways to start profiler </h3><br>  One of the ways we have already seen is the <i>-cpuprofile</i> parameter for the <i>go test</i> command <i>.</i> <br><br>  We can also run the profiler manually using the functions <i>pprof.StartCPUProfile ()</i> and <i>pprof.StopCPUProfile ()</i> .  It is a bit easier to use a very convenient wrapper over these functions from Dave Cheney (English <i>Dave Cheney</i> ) ( <a href="https://github.com/pkg/profile">https://github.com/pkg/profile</a> ), which will create a file for you, write to it, etc. <br><br>  And another great method is to use the <i>net / http / pprof package.</i>  If you import it, it will automatically add an HTTP handler for the URL <i>/ debug / pprof</i> , and you can profile the running program remotely using the same <i>go tool pprof.</i>  Let's see what it looks like. <br><br>  Let's write a simple example: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpuhogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { acc += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> acc&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { acc &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) cpuhogger() }</code> </pre> <br>  As you can see, we imported the <i>net / http / pprof package</i> and started the HTTP server <i>using</i> the <i>http.ListenAndServe ()</i> command.  This is enough to use the profiler while the program is running. <br><br>  Let's now run the program and use the profiler: <br><br><pre> <code class="hljs ruby">$ go tool pprof <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/localhost:8080/debug</span></span><span class="hljs-regexp"><span class="hljs-regexp">/pprof/profile</span></span>?seconds=<span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  As you can see, we simply pass to the pprof utility the path to the handler, on which the profiler ‚Äúlistens‚Äù.  Additionally, you can transfer the profiler time (30 seconds by default). <br><br>  The web command works fine, the top command works fine, but the list and disasm say that there is no information about the source code of the program: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">pprof</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">web</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">pprof</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">top</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">total</span></span> ( 100%) <span class="hljs-selector-tag"><span class="hljs-selector-tag">flat</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flat</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">sum</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">cum</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cum</span></span>% 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> 100% 100% 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> 100% <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpuhogger</span></span> 0 0% 100% 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> 100% <span class="hljs-selector-tag"><span class="hljs-selector-tag">runtime</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.goexit</span></span> 0 0% 100% 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> 100% <span class="hljs-selector-tag"><span class="hljs-selector-tag">runtime</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">pprof</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cpuhogger</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Total</span></span>: 4<span class="hljs-selector-class"><span class="hljs-selector-class">.99s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">No</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">source</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">information</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpuhogger</span></span></code> </pre> <br>  To get the source code information, we need to run pprof a little differently.  You need to give him the path to the binary: <br><br><pre> <code class="hljs ruby">$ go tool pprof pproftest <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/localhost:8080/debug</span></span><span class="hljs-regexp"><span class="hljs-regexp">/pprof/profile</span></span>?seconds=<span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Now we can use both the list and the disasm and make sure that the reality coincides with the expectations. <br><br><pre> <code class="hljs go">(pprof) list cpuhogger Total: <span class="hljs-number"><span class="hljs-number">4.97s</span></span> ROUTINE ======================== main.cpuhogger in /home/marko/goprojects/src/github.com/mkevac/pproftest/main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-number"><span class="hljs-number">4.97s</span></span> <span class="hljs-number"><span class="hljs-number">4.97s</span></span> (flat, cum) <span class="hljs-number"><span class="hljs-number">100</span></span>% of Total . . <span class="hljs-number"><span class="hljs-number">6</span></span>:) . . <span class="hljs-number"><span class="hljs-number">7</span></span>: . . <span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpuhogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { . . <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> . . <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-number"><span class="hljs-number">2.29s</span></span> <span class="hljs-number"><span class="hljs-number">2.29s</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>: acc += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1.14s</span></span> <span class="hljs-number"><span class="hljs-number">1.14s</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> acc&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-number"><span class="hljs-number">1.54s</span></span> <span class="hljs-number"><span class="hljs-number">1.54s</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>: acc &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> . . <span class="hljs-number"><span class="hljs-number">14</span></span>: } . . <span class="hljs-number"><span class="hljs-number">15</span></span>: } . . <span class="hljs-number"><span class="hljs-number">16</span></span>:} . . <span class="hljs-number"><span class="hljs-number">17</span></span>: . . <span class="hljs-number"><span class="hljs-number">18</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { (pprof) disasm cpuhogger Total: <span class="hljs-number"><span class="hljs-number">4.97s</span></span> ROUTINE ======================== main.cpuhogger <span class="hljs-number"><span class="hljs-number">4.97s</span></span> <span class="hljs-number"><span class="hljs-number">4.97s</span></span> (flat, cum) <span class="hljs-number"><span class="hljs-number">100</span></span>% of Total . . <span class="hljs-number"><span class="hljs-number">401000</span></span>: XORL AX, AX <span class="hljs-number"><span class="hljs-number">1.75s</span></span> <span class="hljs-number"><span class="hljs-number">1.75s</span></span> <span class="hljs-number"><span class="hljs-number">401002</span></span>: INCQ AX <span class="hljs-number"><span class="hljs-number">1.14s</span></span> <span class="hljs-number"><span class="hljs-number">1.14s</span></span> <span class="hljs-number"><span class="hljs-number">401005</span></span>: TESTQ $<span class="hljs-number"><span class="hljs-number">0x1</span></span>, AX . . <span class="hljs-number"><span class="hljs-number">40100</span></span>b: JNE <span class="hljs-number"><span class="hljs-number">0x401002</span></span> <span class="hljs-number"><span class="hljs-number">1.54s</span></span> <span class="hljs-number"><span class="hljs-number">1.54s</span></span> <span class="hljs-number"><span class="hljs-number">40100d</span></span>: SHLQ $<span class="hljs-number"><span class="hljs-number">0x1</span></span>, AX <span class="hljs-number"><span class="hljs-number">540</span></span>ms <span class="hljs-number"><span class="hljs-number">540</span></span>ms <span class="hljs-number"><span class="hljs-number">401010</span></span>: JMP <span class="hljs-number"><span class="hljs-number">0x401002</span></span> . . <span class="hljs-number"><span class="hljs-number">401012</span></span>: INT $<span class="hljs-number"><span class="hljs-number">0x3</span></span></code> </pre> <br>  Let's dig deeper for the sake of interest.  We will download what the URL returns on its own: <br><br><pre> <code class="hljs ruby">$ curl <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/localhost:8080/debug</span></span><span class="hljs-regexp"><span class="hljs-regexp">/pprof/profile</span></span>?seconds=<span class="hljs-number"><span class="hljs-number">5</span></span> -o /tmp/cpu.log</code> </pre> <br>  We see that inside /tmp/cpu.log is the same binary data that is returned when using <i>go tool test -cpuprofile</i> or <i>StartCPUProfile ().</i>  "Let us incite" the <i>strings</i> command on this binary file and understand that there are no function names or so-called symbols inside. <br><br><pre> <code class="hljs 1c">$ strings /tmp/cpu.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">| grep cpuhogger</span></span></code> </pre> <br>  Where, then, in the first case, when we started pprof without a binary, were the names of the functions obtained?  It turns out that when importing <i>net / http / pprof</i> , one more URL <i>/ debug / pprof / symbol is added</i> , which returns its name to the address of the function.  Using queries to this URL, the pprof command gets the names of the functions. <br><br>  But this URL does not return the source code of the function, nor disassembled.  To disassemble, we need a binary, and for the source code, we need both a binary and the source code on the disk itself. <br><br>  Be careful: the binary to be transferred and the source code must be exactly those that are running.  Otherwise, you may not receive the data that you expect at all, and you will look for problems where there are none. <br><br><h3>  How does pprof work? </h3><br>  Let us, out of curiosity, see how pprof works and what disadvantages the approach used has. <br><br>  In order to ensure the work of many programs at the same time, modern desktop and server operating systems implement the so-called preemptive multitasking.  The program is allocated a specific time period and a specific processor on which it runs.  After this time, the OS displaces the program and starts another one in its place, if it is ready for operation. <br><br>  But how exactly is the interrupt feature implemented?  After all, the OS is almost the same program.  The thing is that the OS asks the iron to send a signal to it with a certain frequency and assigns a handler to this signal.  When the signal arrives, the processor stops everything that is currently running on it, and starts the specified handler.  In this handler, the OS may or may not force out the current process, replace it with another, etc. <br><br>  The Go profiler works the same way.  Go runtime asks the OS to send a signal (man setitimer) with a certain periodicity and assigns a handler to this signal.  The handler takes the stack-trace of all goroutines (eng. <i>Goroutines</i> ), some additional information, writes it to the buffer and exits. <br><br>  It is with a bug in the process of delivering signals to certain threads that the problem is with previous versions of OS X. <br><br>  What are the disadvantages of this approach? <br><br><ul><li>  Each signal is a change in context.  The thing is quite expensive in our time.  Therefore, at present it is realistic to receive no more than 500 signals per second.  The standard value in Go now is 100 per second.  Sometimes this is not enough. <br></li><li>  For non-standard builds, for example, using <i>-buildmode = c-archive</i> or <i>-buildmode = c-shared</i> , the profiler will not work by default.  This is due to the fact that the signal SIGPROF, which sends the OS, will come to the main program flow, which is not controlled by Go. <br></li><li>  The user space process, which is a Go program, cannot get a nuclear stack-trace.  Non-optimalities and problems sometimes lie in the core. <br></li></ul><br>  The main advantage, of course, is that the Go runtime has full information about its internal structure.  External means, for example, by default do not know anything about gorutines.  For them, there are only processes and threads. <br><br><h3>  System Profilers </h3><br>  We looked at how the go profiler works.  Let's take a look at how standard perf and SystemTap Linux profilers are applicable. <br><br>  Take the very first program from the article, just turn it from benchmarks into a regular program that works endlessly. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"regexp"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> haystack = <span class="hljs-string"><span class="hljs-string">`Lorem ipsum dolor sit amet, consectetur adipiscing [...] Vivamus vitae nulla posuere, pellentesque quam posuere`</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UsingSubstring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { found := strings.Contains(haystack, <span class="hljs-string"><span class="hljs-string">"auctor"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UsingRegex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { found, _ := regexp.MatchString(<span class="hljs-string"><span class="hljs-string">"auctor"</span></span>, haystack) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { UsingSubstring() } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { UsingRegex() } }</code> </pre> <br><h4>  SystemTap </h4><br>  SystemTap is a very powerful profiler that allows you to write small programs in pseudo language.  This program is then automatically converted to C, assembled as a Linux kernel module, loaded, running and unloaded. <br><br>  Let's see if SystemTap sees our functions: <br><br><pre> <code class="hljs vhdl">$ stap -l <span class="hljs-symbol"><span class="hljs-symbol">'process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.*"</span></span>)' <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.UsingRegex@main.go:16"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.UsingSubstring@main.go:11"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.init@main.go:32"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.main.func1@main.go:22"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(<span class="hljs-string"><span class="hljs-string">"systemtap"</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-string"><span class="hljs-string">"main.main@main.go:21"</span></span>)</code> </pre> <br>  Sees  All our functions have a main prefix, as expected. <br><br>  Let's try to measure the time of our two functions and display the results in the form of a histogram. <br><br>  Let's write the following simple script in SystemTap-language.  It remembers the time at the entrance to the function, measures the time at the output, calculates the difference and saves it.  After completing the work, he prints this information. <br><br><pre> <code class="hljs perl">global etime global intervals probe $1.call { etime = gettimeofday_ns() } probe $1.<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { intervals &lt;&lt;&lt; (gettimeofday_ns() - etime)/<span class="hljs-number"><span class="hljs-number">1000</span></span> } probe end { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Duration min:%dus avg:%dus max:%dus count:%d\n"</span></span>, @min(intervals), @avg(intervals), @max(intervals), @count(intervals)) <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Duration (us):\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(@hist_log(intervals)); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) }</code> </pre> <br>  Run the program in one terminal and stap in the other. <br><br><pre> <code class="hljs mel">$ sudo stap main.stap <span class="hljs-string"><span class="hljs-string">'process("systemtap").function("main.UsingSubstring")'</span></span> ^CDuration <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>us avg:<span class="hljs-number"><span class="hljs-number">1</span></span>us <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>:<span class="hljs-number"><span class="hljs-number">586</span></span>us count:<span class="hljs-number"><span class="hljs-number">1628362</span></span> Duration (us): value |-------------------------------------------------- count <span class="hljs-number"><span class="hljs-number">0</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">1443040</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> |@@@@@ <span class="hljs-number"><span class="hljs-number">173089</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> | <span class="hljs-number"><span class="hljs-number">6982</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> | <span class="hljs-number"><span class="hljs-number">4321</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> | <span class="hljs-number"><span class="hljs-number">631</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> | <span class="hljs-number"><span class="hljs-number">197</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> | <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span> | <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">256</span></span> | <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">512</span></span> | <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1024</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  We got the result, but the program fell with an error, having worked quite a bit. <br><br><pre> <code class="hljs go">$ ./systemtap runtime: unexpected <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> main.UsingSubstring called from <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>e000 fatal error: unknown caller pc runtime stack: runtime.throw(<span class="hljs-number"><span class="hljs-number">0x494e40</span></span>, <span class="hljs-number"><span class="hljs-number">0x11</span></span>) /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/<span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">566</span></span> +<span class="hljs-number"><span class="hljs-number">0x8b</span></span> runtime.gentraceback(<span class="hljs-number"><span class="hljs-number">0xffffffffffffffff</span></span>, <span class="hljs-number"><span class="hljs-number">0xc8200337a8</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0xc820001d</span></span>40, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>, <span class="hljs-number"><span class="hljs-number">0x7fff2f</span></span>a88030, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, ...) /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/traceback.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">311</span></span> +<span class="hljs-number"><span class="hljs-number">0x138c</span></span> runtime.scanstack(<span class="hljs-number"><span class="hljs-number">0xc820001d</span></span>40) /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/mgcmark.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">755</span></span> +<span class="hljs-number"><span class="hljs-number">0x249</span></span> runtime.scang(<span class="hljs-number"><span class="hljs-number">0xc820001d</span></span>40) /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">836</span></span> +<span class="hljs-number"><span class="hljs-number">0x132</span></span> runtime.markroot.func1() /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/mgcmark.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">234</span></span> +<span class="hljs-number"><span class="hljs-number">0x55</span></span> runtime.systemstack(<span class="hljs-number"><span class="hljs-number">0x4e4f</span></span>00) /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/asm_amd64.s:<span class="hljs-number"><span class="hljs-number">298</span></span> +<span class="hljs-number"><span class="hljs-number">0x79</span></span> runtime.mstart() /home/marko/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">1087</span></span></code> </pre> <br>  I found a thread about it on <a href="https://goo.gl/N8XH3p">go-nuts</a> , and there is no solution yet.  Judging by everything, how SystemTap changes the program code to intercept functions, I don‚Äôt like the Go runtime when I get the stack trace in GC. <br><br>  The same problem is present in C ++ when handling <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D12275">exceptions</a> .  Uretprobes is not perfect. <br><br>  Well, but it turns out that if you do not use .return sample, then everything is in order?  Let's try. <br><br>  Here is a program that takes random numbers, converts them into a string, and puts them in a buffer: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"math/rand"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, number) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { r := rand.New(rand.NewSource(time.Now().UnixNano())) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++ { value := r.Int() % <span class="hljs-number"><span class="hljs-number">1000</span></span> value = value - <span class="hljs-number"><span class="hljs-number">500</span></span> buf.WriteString(ToString(value)) } }</code> </pre> <br>  We will write a script that builds the distribution of numbers that we convert to a string. <br><br><pre> <code class="hljs perl">global intervals probe process(<span class="hljs-string"><span class="hljs-string">"systemtap02"</span></span>).function(<span class="hljs-string"><span class="hljs-string">"main.ToString"</span></span>).call { intervals &lt;&lt;&lt; $number } probe end { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Variables min:%dus avg:%dus max:%dus count:%d\n"</span></span>, @min(intervals), @avg(intervals), @max(intervals), @count(intervals)) <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Variables:\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(@hist_log(intervals)); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) }</code> </pre> <br>  The program, unlike the previous one, does not use a .return probe, but it takes and uses the number argument. <br><br>  Run and see what happened: <br><br><pre> <code class="hljs mel">$ sudo stap main.stap -c ./systemtap02 Variables <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>:<span class="hljs-number"><span class="hljs-number">-499</span></span>us avg:<span class="hljs-number"><span class="hljs-number">8</span></span>us <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>:<span class="hljs-number"><span class="hljs-number">497</span></span>us count:<span class="hljs-number"><span class="hljs-number">1000</span></span> Variables: value |-------------------------------------------------- count <span class="hljs-number"><span class="hljs-number">-1024</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">-512</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">-256</span></span> |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">249</span></span> <span class="hljs-number"><span class="hljs-number">-128</span></span> |@@@@@@@@@@@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">121</span></span> <span class="hljs-number"><span class="hljs-number">-64</span></span> |@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">-32</span></span> |@@@@@@ <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">-16</span></span> |@@ <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">-8</span></span> |@ <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">-4</span></span> | <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">-2</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> | <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> |@ <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> | <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> |@@@ <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> |@@@@@ <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> |@@@@@@@ <span class="hljs-number"><span class="hljs-number">44</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span> |@@@@@@@@@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">110</span></span> <span class="hljs-number"><span class="hljs-number">256</span></span> |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ <span class="hljs-number"><span class="hljs-number">279</span></span> <span class="hljs-number"><span class="hljs-number">512</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1024</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  We have a beautiful schedule with distribution. <br><br><h4>  Perf </h4><br>  The perf utility and the perf_events subsystem are currently the default Linux profiler.  Source codes and development are mostly kernel repositories and go flush with the kernel. <br><br>  perf top is a command that, similar to top, shows the hottest code in real time.  Run our test program and see what perf top will show. <br><br><pre> <code class="hljs ruby">$ sudo perf top -p $(pidof systemtap)</code> </pre><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2e5/9ae/bdb/2e59aebdbba046df98ef137f05a7f63d.png"></div><br><br>  Everything seems to be fine, and even the source and machine code annotations work. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/083/fa1/dcb/083fa1dcba8c42bd8a7240f735896dd5.png"></div><br><br>  Now let's try to build the so-called <a href="http://www.brendangregg.com/flamegraphs.html">FlameGraph</a> , which was popularized by Brendan Gregg (English <i>Brendan Gregg</i> ).  Brendan is currently working at Netflix and is one of the main popularizers and "engine" of innovations in the field of profiling for Linux. <br><br>  Again, run the program and assemble the stack traces in 10 seconds into the file: <br><br><pre> <code class="hljs delphi">$ sudo perf <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> -F <span class="hljs-number"><span class="hljs-number">99</span></span> -g -p $(pidof systemtap) -- sleep <span class="hljs-number"><span class="hljs-number">10</span></span> [ perf <span class="hljs-keyword"><span class="hljs-keyword">record</span></span>: Woken up <span class="hljs-number"><span class="hljs-number">1</span></span> times <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> data ] [ perf <span class="hljs-keyword"><span class="hljs-keyword">record</span></span>: Captured <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wrote <span class="hljs-number"><span class="hljs-number">0.149</span></span> MB perf.data (<span class="hljs-number"><span class="hljs-number">1719</span></span> samples) ]</code> </pre> <br>  We use the utilities from Brendan to convert perf data to FlameGraph. <br><br><pre> <code class="hljs objectivec">$ sudo perf script | ~/tmp/FlameGraph/stackcollapse-perf.pl &gt; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.perf-folded $ ~/tmp/FlameGraph/flamegraph.pl <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.perf-folded &gt; perf-kernel.svg</code> </pre> <br>  And that's what happened with us: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9d5/0d5/349/9d50d534959643d0affa71fbc6ad4009.png"></div><br><br>  As you can see, unlike the profiler built into Go, here we also have a kernel stack trace. <br><br><h2>  Memory </h2><br>  If we were programming in C or C ++, how would we profile memory usage? <br><br>  In the C / C ++ world, there is Valgrind, a utility that is designed to look for errors when using memory: leakage, going beyond the array boundary, using already freed memory, and a lot more.  All this we do not need, because  in Go, the absence of such problems is guaranteed (except when using cgo, of course). <br><br>  But Valgrind is also able to show memory consumption in the form of a convenient time schedule using the built-in Massif subsystem. <br><br>  If you take a simple C program that simply allocates and then frees up 20 MiB of memory <br><br><pre> <code class="hljs swift">#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main() { const size_t <span class="hljs-type"><span class="hljs-type">MB</span></span> = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; const unsigned <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>; char **buf = calloc(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sizeof</span></span>(*buf)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>; i++) { buf[i] = calloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">MB</span></span>); memset(buf[i], <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-type"><span class="hljs-type">MB</span></span>); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>; i++) { free(buf[i]); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } free(buf); }</code> </pre> <br>  and run it under Massif, we will get something like this graph with stack traces in those places where memory allocations were initiated: <br><br><pre> <code class="hljs mel">-------------------------------------------------------------------------------- Command:            ./main Massif arguments:   --pages-as-heap=yes --time-<span class="hljs-keyword"><span class="hljs-keyword">unit</span></span>=ms ms_print arguments: massif.out<span class="hljs-number"><span class="hljs-number">.15091</span></span> --------------------------------------------------------------------------------   MB <span class="hljs-number"><span class="hljs-number">26.20</span></span>^                                   ::    |                                 ::: #    |                               @@: : #::    |                             ::@ : : #: ::    |                         ::::: @ : : #: : ::::    |                        :: : : @ : : #: : : : ::    |                      :::: : : @ : : #: : : : : :    |                  ::::: :: : : @ : : #: : : : : :::::    |                ::: : : :: : : @ : : #: : : : : :: : @@    |              ::: : : : :: : : @ : : #: : : : : :: : @ ::    |           ::@: : : : : :: : : @ : : #: : : : : :: : @ : :::    |         ::: @: : : : : :: : : @ : : #: : : : : :: : @ : : :::    |       ::: : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: ::    |     ::: : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : ::    | ::::: : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : ::::    |:: : : : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : : : :    |@: : : : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : : : :@    |@: : : : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : : : :@    |@: : : : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : : : :@    |@: : : : : : @: : : : : :: : : @ : : #: : : : : :: : @ : : :: : : : : :@  <span class="hljs-number"><span class="hljs-number">0</span></span> +-----------------------------------------------------------------------&gt;s    <span class="hljs-number"><span class="hljs-number">0</span></span>                                                                   <span class="hljs-number"><span class="hljs-number">39.13</span></span> Number of snapshots: <span class="hljs-number"><span class="hljs-number">66</span></span> Detailed snapshots: [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span> (peak), <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>]</code> </pre> <br>  Massif works in such a way that it overrides the main functions for working with memory (malloc, calloc, realloc, memalign, new, new []) with its own. <br><br>  Go does not use any of these functions.  The Go source implements its own allocator, which requests memory directly from the OS using the mmap or sbrk system calls, and already breaks it up into smaller pieces on its own. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/951/6c5/eb1/9516c5eb151c4af79c8c96a007dcb2ef.png"></div><br><br>  Valgrind can catch mmap / sbrk if asked for it with a special command line parameter, but it's still useless, because, firstly, we will not see these smallest selections and releases, and, secondly, we will not understand which memory is no longer referenced, and which is still ‚Äúlive‚Äù. <br><br>  Other common utilities in the C / C ++ world are also practically useless, since  most of them work in a similar way, i.e.  by intercepting memory allocation and release functions. <br><br>  Options, in fact, two: <br><ul><li>  theoretically, we can intercept the functions of allocating and freeing memory from the Go runtime with something external to the Go program (for example, perf or SystemTap) and try to understand something based on these calls; <br></li><li>  use the built-in go runtime memory usage. <br></li></ul><br><br>  Go is able to collect information about memory allocations at regular intervals.  This frequency can be set manually, but by default it is 1 time per 512 kilobytes of allocated memory. <br><br>  As usual, let's look at an example. <br><br><h3>  Example </h3><br>  Similar to processor profiling, memory profiling can be started using <i>go test</i> , direct <i>runtime.MemProfile ()</i> calls or using the <i>net / http / pprof package</i> .  This time, let's use the last option. <br><br>  So, before you is a program that in one of the gorutin constantly allocates arrays and stores them in another array, and in the other gorutin does the same, but periodically ‚Äúforgets‚Äù about the array of arrays: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocAndKeep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(b, <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>)) time.Sleep(time.Millisecond) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocAndLeave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(b, <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b) == <span class="hljs-number"><span class="hljs-number">20</span></span> { b = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } time.Sleep(time.Millisecond) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> allocAndKeep() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> allocAndLeave() http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Those.  ,         ,       ,    . <br><br>  ,   . <br><br>      <i>go tool pprof</i>    ,    : <br><ul><li> alloc_space ‚Äî   ; <br></li><li> alloc_objects ‚Äî   ; <br></li><li> inuse_space ‚Äî   ; <br></li><li> inuse_objects ‚Äî   . <br></li></ul><br><br>          ,   ‚Äî       . <br><br>     ,  <i>inuse</i>    <i>allocAndKeep(),</i>  <i>alloc</i>   : <br><br><pre> <code class="hljs pgsql">$ go tool pprof -inuse_space memtest http://localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>/pprof/heap Fetching profile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> http://localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>/pprof/heap Saved profile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /home/marko/pprof/pprof.memtest.localhost:<span class="hljs-number"><span class="hljs-number">8080.</span></span>inuse_objects.inuse_space<span class="hljs-number"><span class="hljs-number">.005</span></span>.pb.gz Entering interactive mode (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "help" <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commands) (pprof) top <span class="hljs-number"><span class="hljs-number">15.36</span></span>MB <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">15.36</span></span>MB total ( <span class="hljs-number"><span class="hljs-number">100</span></span>%) Dropped <span class="hljs-number"><span class="hljs-number">2</span></span> nodes (cum &lt;= <span class="hljs-number"><span class="hljs-number">0.08</span></span>MB) flat flat% sum% cum cum% <span class="hljs-number"><span class="hljs-number">15.36</span></span>MB <span class="hljs-number"><span class="hljs-number">100</span></span>% <span class="hljs-number"><span class="hljs-number">100</span></span>% <span class="hljs-number"><span class="hljs-number">15.36</span></span>MB <span class="hljs-number"><span class="hljs-number">100</span></span>% main.allocAndKeep <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">100</span></span>% <span class="hljs-number"><span class="hljs-number">15.36</span></span>MB <span class="hljs-number"><span class="hljs-number">100</span></span>% runtime.goexit $ go tool pprof -alloc_space memtest http://localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>/pprof/heap Fetching profile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> http://localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>/pprof/heap Saved profile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /home/marko/pprof/pprof.memtest.localhost:<span class="hljs-number"><span class="hljs-number">8080.</span></span>alloc_objects.alloc_space<span class="hljs-number"><span class="hljs-number">.008</span></span>.pb.gz Entering interactive mode (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "help" <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commands) (pprof) top <span class="hljs-number"><span class="hljs-number">54.49</span></span>MB <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">54.49</span></span>MB total ( <span class="hljs-number"><span class="hljs-number">100</span></span>%) Dropped <span class="hljs-number"><span class="hljs-number">8</span></span> nodes (cum &lt;= <span class="hljs-number"><span class="hljs-number">0.27</span></span>MB) flat flat% sum% cum cum% <span class="hljs-number"><span class="hljs-number">27.97</span></span>MB <span class="hljs-number"><span class="hljs-number">51.33</span></span>% <span class="hljs-number"><span class="hljs-number">51.33</span></span>% <span class="hljs-number"><span class="hljs-number">29.47</span></span>MB <span class="hljs-number"><span class="hljs-number">54.08</span></span>% main.allocAndKeep <span class="hljs-number"><span class="hljs-number">23.52</span></span>MB <span class="hljs-number"><span class="hljs-number">43.17</span></span>% <span class="hljs-number"><span class="hljs-number">94.49</span></span>% <span class="hljs-number"><span class="hljs-number">25.02</span></span>MB <span class="hljs-number"><span class="hljs-number">45.92</span></span>% main.allocAndLeave <span class="hljs-number"><span class="hljs-number">3</span></span>MB <span class="hljs-number"><span class="hljs-number">5.51</span></span>% <span class="hljs-number"><span class="hljs-number">100</span></span>% <span class="hljs-number"><span class="hljs-number">3</span></span>MB <span class="hljs-number"><span class="hljs-number">5.51</span></span>% <span class="hljs-type"><span class="hljs-type">time</span></span>.Sleep <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">100</span></span>% <span class="hljs-number"><span class="hljs-number">54.49</span></span>MB <span class="hljs-number"><span class="hljs-number">100</span></span>% runtime.goexit</code> </pre> <br>   .    ,   Sleep() -   .  Consider more. <br><br><pre> <code class="hljs pgsql">(pprof) list <span class="hljs-type"><span class="hljs-type">time</span></span>.Sleep Total: <span class="hljs-number"><span class="hljs-number">54.49</span></span>MB <span class="hljs-keyword"><span class="hljs-keyword">ROUTINE</span></span> ======================== <span class="hljs-type"><span class="hljs-type">time</span></span>.Sleep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /home/marko/go/src/runtime/<span class="hljs-type"><span class="hljs-type">time</span></span>.go <span class="hljs-number"><span class="hljs-number">3</span></span>MB <span class="hljs-number"><span class="hljs-number">3</span></span>MB (flat, cum) <span class="hljs-number"><span class="hljs-number">5.51</span></span>% <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Total . . <span class="hljs-number"><span class="hljs-number">48</span></span>:func timeSleep(ns int64) { . . <span class="hljs-number"><span class="hljs-number">49</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ns &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> { . . <span class="hljs-number"><span class="hljs-number">50</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> . . <span class="hljs-number"><span class="hljs-number">51</span></span>: } . . <span class="hljs-number"><span class="hljs-number">52</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>MB <span class="hljs-number"><span class="hljs-number">3</span></span>MB <span class="hljs-number"><span class="hljs-number">53</span></span>: t := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(timer) . . <span class="hljs-number"><span class="hljs-number">54</span></span>: t.<span class="hljs-keyword"><span class="hljs-keyword">when</span></span> = nanotime() + ns . . <span class="hljs-number"><span class="hljs-number">55</span></span>: tf = goroutineReady . . <span class="hljs-number"><span class="hljs-number">56</span></span>: t.arg = getg() . . <span class="hljs-number"><span class="hljs-number">57</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(&amp;timers.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>) . . <span class="hljs-number"><span class="hljs-number">58</span></span>: addtimerLocked(t)</code> </pre> <br> ,  ,   <i>time.Sleep()</i>     new(). <br><br><h3>   (1) </h3><br>      ,   ,    ‚Äî  .     ,     . <br><br>   ,     . <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> printtest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">"test string"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { buf.Reset() fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"string is: %s"</span></span>, s) } }</code> </pre> <br>          <i>fmt.Fprintf()</i> . <br>    ÔøºÔøº-benchmem   test       . <br><br><pre> <code class="hljs pgsql">$ go test -bench=. -benchmem testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkPrint<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op PASS ok github.com/mkevac/converttest <span class="hljs-number"><span class="hljs-number">1.420</span></span>s</code> </pre> <br> ,   1      16 .    ? <br><br>    : <br><br><pre> <code class="hljs cs">$ go test -bench=. -memprofile=mem.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -memprofilerate=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <i>memprofilerate</i>  ,        .       ,       . ,        .   . <br><br>     : <br><br><pre> <code class="hljs mel">$ go tool pprof -alloc_space converttest.test mem.out (pprof) top <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB of <span class="hljs-number"><span class="hljs-number">15.48</span></span>MB total (<span class="hljs-number"><span class="hljs-number">99.59</span></span>%) Dropped <span class="hljs-number"><span class="hljs-number">73</span></span> nodes (cum &lt;= <span class="hljs-number"><span class="hljs-number">0.08</span></span>MB)     flat  flat%   sum%        cum   cum%  <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB <span class="hljs-number"><span class="hljs-number">99.59</span></span>% <span class="hljs-number"><span class="hljs-number">99.59</span></span>%    <span class="hljs-number"><span class="hljs-number">15.43</span></span>MB <span class="hljs-number"><span class="hljs-number">99.67</span></span>%  github.com/mkevac/converttest.BenchmarkPrint        <span class="hljs-number"><span class="hljs-number">0</span></span>     <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">99.59</span></span>%    <span class="hljs-number"><span class="hljs-number">15.47</span></span>MB <span class="hljs-number"><span class="hljs-number">99.93</span></span>%  runtime.goexit        <span class="hljs-number"><span class="hljs-number">0</span></span>     <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">99.59</span></span>%    <span class="hljs-number"><span class="hljs-number">15.42</span></span>MB <span class="hljs-number"><span class="hljs-number">99.66</span></span>%  testing.(*B).<span class="hljs-keyword"><span class="hljs-keyword">launch</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>     <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">99.59</span></span>%    <span class="hljs-number"><span class="hljs-number">15.43</span></span>MB <span class="hljs-number"><span class="hljs-number">99.67</span></span>%  testing.(*B).runN</code> </pre> <br> ,      15 MiB .  Where? <br><br><pre> <code class="hljs go">(pprof) list BenchmarkPrint Total: <span class="hljs-number"><span class="hljs-number">15.48</span></span>MB ROUTINE ======================== github.com/mkevac/converttest.BenchmarkPrint in /home/marko/goprojects/src/github.com/mkevac/converttest/convert_test.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB <span class="hljs-number"><span class="hljs-number">15.43</span></span>MB (flat, cum) <span class="hljs-number"><span class="hljs-number">99.67</span></span>% of Total . . <span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { . . <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer . . <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">"test string"</span></span> . . <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { . . <span class="hljs-number"><span class="hljs-number">13</span></span>: buf.Reset() <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB <span class="hljs-number"><span class="hljs-number">15.43</span></span>MB <span class="hljs-number"><span class="hljs-number">14</span></span>: fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"string is: %s"</span></span>, s) . . <span class="hljs-number"><span class="hljs-number">15</span></span>: } . . <span class="hljs-number"><span class="hljs-number">16</span></span>:}</code> </pre> <br>     fmt.Fprintf().  Good.  ? <br><br><pre> <code class="hljs sql">(pprof) list fmt.Fprintf Total: 15.48MB ROUTINE ======================== fmt.Fprintf in /home/marko/go/src/fmt/print.go 0 12.02kB (flat, cum) 0.076% of Total . . 175:// These routines <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'f'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> take a <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> string. . . <span class="hljs-number"><span class="hljs-number">176</span></span>: . . <span class="hljs-number"><span class="hljs-number">177</span></span>:// Fprintf formats according <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> specifier <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> writes <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> w. . . <span class="hljs-number"><span class="hljs-number">178</span></span>:// It <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> written <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> write <span class="hljs-keyword"><span class="hljs-keyword">error</span></span> encountered. . . <span class="hljs-number"><span class="hljs-number">179</span></span>:func Fprintf(w io.Writer, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, a ...interface{}) (n <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) { . <span class="hljs-number"><span class="hljs-number">11.55</span></span>kB <span class="hljs-number"><span class="hljs-number">180</span></span>: p := newPrinter() . <span class="hljs-number"><span class="hljs-number">480</span></span>B <span class="hljs-number"><span class="hljs-number">181</span></span>: p.doPrintf(<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>, a) . . <span class="hljs-number"><span class="hljs-number">182</span></span>: n, err = w.Write(p.buf) . . <span class="hljs-number"><span class="hljs-number">183</span></span>: p.free() . . <span class="hljs-number"><span class="hljs-number">184</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> . . <span class="hljs-number"><span class="hljs-number">185</span></span>:} . . <span class="hljs-number"><span class="hljs-number">186</span></span>:</code> </pre> <br>  . , , ‚Ä¶ -    .     15 ,   12 . -  . <br><br>       : <br><br><pre> <code class="hljs go">         .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>edb: CALL bytes.(*Buffer).Reset(SB)        .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>ee0: LEAQ <span class="hljs-number"><span class="hljs-number">0x98b6b</span></span>(IP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>ee7: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0x70</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>eec: MOVQ $<span class="hljs-number"><span class="hljs-number">0xb</span></span>, <span class="hljs-number"><span class="hljs-number">0x78</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>ef5: MOVQ $<span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x60</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466</span></span>efe: MOVQ $<span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>07: LEAQ <span class="hljs-number"><span class="hljs-number">0x70d</span></span>92(IP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>0e: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>12: LEAQ <span class="hljs-number"><span class="hljs-number">0x70</span></span>(SP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>17: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0x8</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>1c: MOVQ $<span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>(SP)  <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB    <span class="hljs-number"><span class="hljs-number">15.41</span></span>MB     <span class="hljs-number"><span class="hljs-number">466f</span></span>25: CALL runtime.convT2E(SB)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>2a: MOVQ <span class="hljs-number"><span class="hljs-number">0x18</span></span>(SP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>2f: MOVQ <span class="hljs-number"><span class="hljs-number">0x20</span></span>(SP), CX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>34: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0x60</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>39: MOVQ CX, <span class="hljs-number"><span class="hljs-number">0x68</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>3e: LEAQ <span class="hljs-number"><span class="hljs-number">0x10b35b</span></span>(IP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>45: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>49: MOVQ <span class="hljs-number"><span class="hljs-number">0x58</span></span>(SP), AX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>4e: MOVQ AX, <span class="hljs-number"><span class="hljs-number">0x8</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>53: LEAQ <span class="hljs-number"><span class="hljs-number">0x99046</span></span>(IP), CX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>5a: MOVQ CX, <span class="hljs-number"><span class="hljs-number">0x10</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>5f: MOVQ $<span class="hljs-number"><span class="hljs-number">0xd</span></span>, <span class="hljs-number"><span class="hljs-number">0x18</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>68: LEAQ <span class="hljs-number"><span class="hljs-number">0x60</span></span>(SP), CX        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>6d: MOVQ CX, <span class="hljs-number"><span class="hljs-number">0x20</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>72: MOVQ $<span class="hljs-number"><span class="hljs-number">0x1</span></span>, <span class="hljs-number"><span class="hljs-number">0x28</span></span>(SP)        .          .     <span class="hljs-number"><span class="hljs-number">466f</span></span>7b: MOVQ $<span class="hljs-number"><span class="hljs-number">0x1</span></span>, <span class="hljs-number"><span class="hljs-number">0x30</span></span>(SP)        .    <span class="hljs-number"><span class="hljs-number">12.02</span></span>kB     <span class="hljs-number"><span class="hljs-number">466f</span></span>84: CALL fmt.Fprintf(SB)</code> </pre> <br> -  runtime.convT2E    .  What is it? <br><br>    ,    <i>fmt.Fprintf():</i> <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fprintf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, format </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, a ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br>      ,      .  ,  ,   <i>void*</i>  . <br><br>      ¬´¬ª     , ..     .       ,       ?  Why?        Go. <br><br>  Go   ,   <i>string, chan, func, slice, interface</i>  ..        . <br><br>  ,     string, ..     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/966/7cf/eaa/9667cfeaa4194f838d524b083a07b9c1.png"></div><br><br>  ‚Äî  16 .  8  ‚Äî    ,  , ,  ,   8  ‚Äî  . <br><br>     interface. Interface       8- . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/259/26e/6dc/25926e6dc2a141d1970986f25771b5dc.png"></div><br><br>  8  ‚Äî    ,    ,   8  ‚Äî    . <br><br>     <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">"marko"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} = &amp;s</code> </pre> <br>       ,       8      . <br><br>     .      ,  : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">"marko"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} = s</code> </pre> <br>    Go         <i>runtime.convT2E.</i> <br><br>    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/31f/ed5/b4a/31fed5b4ae604c49b12d71a5861049d6.png"></div><br><br>   16      <i>go test.</i> <br><br>       ¬´¬ª  . <br>   <i>fmt.Fprintf</i>       : <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">"test string"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { buf.Reset() buf.WriteString(<span class="hljs-string"><span class="hljs-string">"string is: "</span></span>) buf.WriteString(s) } }</code> </pre> <br>    0 : <br><br><pre> <code class="hljs pgsql">$ go test -bench=BenchmarkPrint -benchmem testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkPrint<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">27.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">0</span></span> B/op <span class="hljs-number"><span class="hljs-number">0</span></span> allocs/op PASS ok github.com/mkevac/converttest01 <span class="hljs-number"><span class="hljs-number">1.413</span></span>s</code> </pre> <br>     4 . <br><br><h3>   (2) </h3><br>      ¬´¬ª  ,   cgo.     ( <i>char *</i> )    ‚Äî ,  ,    .      ,        . <br><br>  Go,    ,   .  ‚Äî      ,    . <br><br>     <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-string"><span class="hljs-string">'m'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'k'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(array) == <span class="hljs-string"><span class="hljs-string">"marko"</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"equal"</span></span>) } }</code> </pre> <br>    ,     .          . <i>git-blame</i> ,      .  ,  ,          (do not escapes to heap),        ,    . <br><br>         .  ,   ,  ,    ,     .       runtime.  ,       ,      ,   ,        2010 ,      ,      . <br><br>     . <br><br>  -  ,     Go-   ,   escapes to heap. <br><br>    : <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkConvert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-string"><span class="hljs-string">'m'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'k'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { buf.Reset() s = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(array) buf.WriteString(s) } }</code> </pre> <br><pre> <code class="hljs pgsql">$ go test -bench=. -benchmem testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkConvert<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000000</span></span> <span class="hljs-number"><span class="hljs-number">42.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">8</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br>             reflect  unsafe. <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BytesToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { bh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b)) sh := reflect.StringHeader{bh.Data, bh.Len} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(*<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(unsafe.Pointer(&amp;sh)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkNoConvert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{<span class="hljs-string"><span class="hljs-string">'m'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'k'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { buf.Reset() s = BytesToString(array) buf.WriteString(s) } }</code> </pre> <br>      . <br><br><pre> <code class="hljs pgsql">$ go test -bench=. -benchmem testing: <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> run BenchmarkConvert<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000000</span></span> <span class="hljs-number"><span class="hljs-number">44.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">8</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op BenchmarkNoConvert<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000000</span></span> <span class="hljs-number"><span class="hljs-number">19.2</span></span> ns/op <span class="hljs-number"><span class="hljs-number">0</span></span> B/op <span class="hljs-number"><span class="hljs-number">0</span></span> allocs/op PASS ok github.com/mkevac/bytetostring <span class="hljs-number"><span class="hljs-number">3.332</span></span>s</code> </pre> <br><h2>  </h2><br>    ,   Go ‚Äî .    , Go runtime         ,  ,  ,      :   ,     , ,    ..         Go    <i>runtime/trace.go</i> . <br><br>    ‚Äî   .       ,    Chrome    -. <br><br>   ,    ,   . <br><br><h3>  Example </h3><br> -           GC-   debugcharts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2ce/df3/3f2/2cedf33f2058475c96edfd0eb551984d.png"></div><br><br>           <i>runtime.ReadMemStats()</i> ,     GC-          . <br><br>    ,       ¬´ ¬ª,     debugcharts. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/mkevac/debugcharts"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CPUHogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acc <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> t := time.Tick(<span class="hljs-number"><span class="hljs-number">2</span></span> * time.Second) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-t: time.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span> * time.Millisecond) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: acc++ } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> CPUHogger() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> CPUHogger() http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8181"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>      trace,  ,    . <br><br>      10 .  :        runtime  - ,       1-3  .  ,  Chrome  JavaScript     . <br><br><pre> <code class="hljs pgsql">curl http://localhost:<span class="hljs-number"><span class="hljs-number">8181</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>/pprof/trace?seconds=<span class="hljs-number"><span class="hljs-number">10</span></span> -o trace.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span></code> </pre> <br>     <i>go tool trace</i> ,    : <br><br><pre> <code class="hljs mel">go tool <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span> -http <span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span> ./tracetest <span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>.out</code> </pre> <br>  ,      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e8b/5cd/cd7/e8b5cdcd725c4c7792953f231c746745.png"></div><br><br>         : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/480/327/670/4803276706d542598c0ede9dfb4e1f06.png"></div><br><br> ,  ,   , .     ,        ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1af/475/5ab/1af4755ab3564c7fadb2634f4dadf475.png"></div><br><br>  ,   ,        ,    ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0c7/12e/fb3/0c712efb35324fa898673805034d147c.png"></div><br><br>  ,     4 ,         ,     2     50 ,     . ,     - ,  , ,      debugcharts.     ,  . <br><br>      ,        debugcharts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/577/809/781/577809781a5c4b0492cf6b03dab8665b.png"></div><br><br>    - . Debugcharts ,    ,    ,  .      . <br><br>            ,      ,  ,    proc stop  proc start . <br><br>       ,   ,    debugcharts  .    latency   . <br><br>     <i>runtime.ReadMemStats()</i> ,   . <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">180</span></span> // ReadMemStats populates m <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> memory allocator <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span>. <span class="hljs-number"><span class="hljs-number">181</span></span> func ReadMemStats(m *MemStats) { <span class="hljs-number"><span class="hljs-number">182</span></span>         stopTheWorld("read mem stats") <span class="hljs-number"><span class="hljs-number">183</span></span> <span class="hljs-number"><span class="hljs-number">184</span></span>         systemstack(func() { <span class="hljs-number"><span class="hljs-number">185</span></span>                 readmemstats_m(m) <span class="hljs-number"><span class="hljs-number">186</span></span>         }) <span class="hljs-number"><span class="hljs-number">187</span></span> <span class="hljs-number"><span class="hljs-number">188</span></span>         startTheWorld() <span class="hljs-number"><span class="hljs-number">189</span></span> }</code> </pre> <br>        .       . <br><br>   , debugcharts         . <br><br><h2>  Conclusion </h2><br>         ,         ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/daa/101/e04/daa101e043c844269250beec32a4932d.jpg"></div><br><br>     ,    Go: <br><br><ul><li>  CPU; <br></li><li>  ; <br></li><li>    ; <br></li><li> escape-; <br></li><li>  ; <br></li><li> ; <br></li><li>   ; <br></li><li>     ; <br></li><li>     , CPU  GC   . <br></li></ul><br><br>   ,  Go     ,     ,  ,    . <br><br>     Go,     ,    .        perf  SystemTap.    . <br><br>         ,         ‚Äî  ,     ,   , ‚Äî      . <br><br>  ,       . Stay curious! <br><br> <i> ,    C/C++ </i> </div><p>Source: <a href="https://habr.com/ru/post/301990/">https://habr.com/ru/post/301990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301980/index.html">Exclusive interview with PayOnline CEO</a></li>
<li><a href="../301982/index.html">How to increase the conversion of users from the trial to pay in the SaaS-service</a></li>
<li><a href="../301984/index.html">How to build a sales channel for startups. Part one, theoretical</a></li>
<li><a href="../301986/index.html">Dell Compellent Storage QoS</a></li>
<li><a href="../301988/index.html">May 28, Russia celebrates SEO Day</a></li>
<li><a href="../301992/index.html">Chronic non-openers. How to return a client is not too late ...</a></li>
<li><a href="../301994/index.html">Announcement Rust 1.9</a></li>
<li><a href="../301996/index.html">Automation with the help of a bot or how to make a useful decision from hysteria about robots</a></li>
<li><a href="../301998/index.html">Is it time to switch to Swift?</a></li>
<li><a href="../302000/index.html">Setting up Laravel relationships - counting comments (free translation)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>