<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Undefined behavior in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A rather difficult topic for C ++ programmers is undefined behavior. Even experienced developers often can not clearly articulate its causes. The arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Undefined behavior in C ++</h1><div class="post__text post__text-html js-mediator-article">  A rather difficult topic for C ++ programmers is undefined behavior.  Even experienced developers often can not clearly articulate its causes.  The article is intended to bring a little more clarity to this question. <br><br>  The article is a translation of several articles and excerpts from the Standard on this topic. <br><br><h5>  What is the "point of following"? </h5><br>  The standard says: <br><blockquote>  Sequence points - such points in the process of program execution, in which all side effects of the already executed code have finished their action, and side effects of the code to be executed have not yet begun to act.  (¬ß1.9 / 7) </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Side effects?  And what are the "side effects"? </h5><br><blockquote>  <u>A side effect</u> (side effect) (according to the Standard) is the result of accessing a volatile object, changing an object, calling a function from the I / O library, or calling a function that includes some of these actions.  A side effect is a change in the runtime state. </blockquote><br>  Calculating some expression yields some result.  If, in addition to the result, the evaluation of an expression causes changes in the runtime environment, then it is said that this expression has side effects. <br><br>  For example: <br><a name="habracut"></a><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = y++; <span class="hljs-comment"><span class="hljs-comment">// ¬´y¬ª  int</span></span></code> </pre> <br><br>  In addition to the initialization of the variable ‚Äúx‚Äù, the value of the variable ‚Äúy‚Äù has changed due to the side effect of the ++ operator. <br>  Well, that's understandable.  Further to points of following.  An alternative definition of the notion of a ‚Äúpoint of following‚Äù is given by Steve Summit (author of the ‚ÄúC Language in Questions and Answers‚Äù ‚Äã‚Äãblog, comp.lang.c): <br>  <u>The sequence point</u> is the moment in time when the dust settled down, and all the side effects encountered were guaranteed to be completed and left behind. <br><br><h5>  What are the sequence points described in C ++ Standard? </h5><br>  The standard describes the following following points: <br><br><ul><li>  at the end of the evaluation of the full expression (¬ß1.9 / 16).  By ‚Äúfull expression‚Äù (full-expression) is meant an expression that is not a subexpression - part of another expression (note: the evaluation of a full expression may include the evaluation of a subexpression that is not a part of it. For example, the subexpressions involved in the calculation of the argument by default, they are considered part of the expression that called the function, and not the expression that defines this argument). <br><br>  For example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ¬´;¬ª -     </span></span></code> </pre> <br><br></li><li>  in the calculation of the following expressions, namely after calculating the first operand: <br><br>  1. a &amp;&amp; b (¬ß5.14) <br>  2. a ||  b (¬ß5.15) <br>  3. a?  b: c (¬ß5.16) <br>  4. a, b (¬ß5.18) <br><br>  The calculation of these expressions goes from left to right.  After the calculation of the left subexpression, all side effects of this calculation cease.  If after calculating the left subexpression the value of the full expression is known, then the right side is not calculated.  In the latter case, the operator is a comma.  In the function func (a, a ++), a comma is not an operator, but simply a separator between the arguments. <br><br></li><li>  when calling a function (whether the function is inline or not) after calculating all its arguments (if any) and before executing any instructions in its body. <br></li></ul><br><br><h5>  What is ‚Äúindefinite behavior‚Äù? </h5><br>  The standard defines the phrase ‚Äúundefined behavior‚Äù in ¬ß1.3.12: <br><blockquote>  <u>Undefined behavior</u> is a behavior that may arise as a result of using erroneous software constructs or incorrect data that the International Standard does not impose any requirements on.  Indefinite behavior can also occur in situations not explicitly described in the Standard. </blockquote><br>  In other words, indefinite behavior means anything that can happen, starting from a kozyavka that has fallen out of the nose, ending with the pregnancy of your girl. <br><br><h5>  What is the relationship between undefined behavior and sequence points? </h5><br>  Before you know the answer to this question, you must understand the differences between undefined behavior, unspecified behavior, and implementation-defined behavior. <br><blockquote>  Unspecified behavior (according to the Standard) is a behavior for which the Standard offers two or more possible options and does not impose clear requirements on which of them should be chosen in a certain situation. </blockquote><br>  Unspecified behavior arises from the calculation of subexpressions such as: <br><ul><li>  arguments to the function call </li><li>  Operands of operators (eg +, -, =, *, /), except for: <br><ol><li>  binary logic operators (&amp;&amp; and ||) </li><li>  operator conditions (? :) </li><li>  operator comma. </li></ol><br>  (note: except for those operators that contain the following point) <br></li></ul><br><blockquote>  <u>Implementation</u> -defined behavior (according to the Standard) is the behavior of a well-formed software construct with the correct data, which depends on the implementation (must be documented for each implementation). </blockquote><br>  An example of this behavior is pointer size.  In accordance with the Standard, the size of the pointer depends on the specific implementation of the compiler.  Within one particular implementation, the size of different types of pointers may also be different. <br>  I also want to note that the order of calculation of the operands of a particular operator, the subexpressions of a specific expression, and the order of occurrence of side effects are not specified. <br><br>  For example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>, y = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = x++ + y++; <span class="hljs-comment"><span class="hljs-comment">//  ,    x++  y++</span></span></code> </pre> <br><br>  One more example: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">World</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"World !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = Hello() + World(); <span class="hljs-comment"><span class="hljs-comment">/**  ¬´Hello World!¬ª  ¬´World! Hello¬ª ^ |        **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  In ¬ß5 / 4, the Standard says: <br><blockquote>  Between two points of the sequence, the scalar object must change the stored value when calculating the expression no more than once. </blockquote><br>  What does it mean? <br><br>  Speaking a little easier, the variable between two points of the sequence cannot be changed more than once.  In the expression, the next point of the sequence is usually located on the concluding semicolon, and the previous one - at the end of the preceding statement.  The expression may also contain intermediate points of sequence. <br>  Based on the foregoing, the following expressions create undefined behavior: <br><br><pre> <code class="hljs ruby">i++ * ++i; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> i = ++i; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ++i = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> i   <span class="hljs-number"><span class="hljs-number">1</span></span>  i = ++i +<span class="hljs-number"><span class="hljs-number">1</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ i = (i,++i,++i); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      `++i`   `i` (`i`   1   2  )</span></span></code> </pre> <br>  But at the same time: <br><br><pre> <code class="hljs lisp">i = (<span class="hljs-name"><span class="hljs-name">i</span></span>, ++i, <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-comment"><span class="hljs-comment">; //  i = (++i,i++,i) //  int j = i; j = (++i, i++, j*i); // </span></span></code> </pre> <br><br>  In addition (by Standard) - the old value of the expression (before the calculation) should be available only for determining the stored value. <br>  This means that incorrect expressions are those in which access to a value may precede its modification. <br><br>  For example: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d"</span></span>, i,++i); <span class="hljs-comment"><span class="hljs-comment">// ,    ‚Äì  (++i)    .</span></span></code> </pre> <br><br>  One more example: <br><br><pre> <code class="hljs objectivec">a[i] = i++ ; <span class="hljs-comment"><span class="hljs-comment">//  a[++i] = i ,  a[i++] = ++i  ..</span></span></code> </pre> <br><br><h5>  I heard that in C ++ 0x there are no Follow Points, is that true? </h5><br><br>  Yes it's true. <br>  The notion of a ‚Äúpoint of succession‚Äù was replaced by an ISO C ++ committee with a refined and augmented concept of the Relationship of Following [BEFORE AFTER]. <br><br>  What is the Attitude Relation [TO]? <br><blockquote>  <u>Following</u> is a relation that is: <br><ul><li>  asymmetrically </li><li>  transitively </li><li>  occurs between pairs of computations and the partially ordered set that forms them </li></ul></blockquote><br><br>  Formally, this means that with two given expressions A and B, if A [follows to] B, then execution of A must precede execution of B. If A does not [follow TO] B, then execution of A and B is unsequenced (execution of unordered calculations may overlap). <br>  Calculation of A and B are indeterminantly sequenced, when either A [follows TO] B or B [follows TO] A, but what exactly is not specified.  Indefinitely ordered calculations cannot intersect, but any of them can be executed first. <br><br><h5>  What does ‚Äúcomputation‚Äù mean in the context of C ++ 0x? </h5><br>  In C ++ 0x, the evaluation (evaluation) of an expression (or subexpression) generally includes: <br><ul><li>  counting (computation) of a value (including determining the position of an object in memory for calculating the value of a gvalue expression and getting the value by reference for calculating a prvalue expression) </li><li>  initiation of side effects </li></ul><br><br>  The standard tells us (¬ß1.9 / 14): <br><blockquote>  Each value count and side effect associated with the full expression [are preceded by a TO] a value count and side effect count associated with the following full expression to be calculated. </blockquote><br>  A trivial example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; x = <span class="hljs-number"><span class="hljs-number">10</span></span>; ++x;</code> </pre> <br><br>  In this example, the calculation of the value and the side effect associated with the expression (++ x), [should be AFTER] the calculation of the value and side effect (x = 10). <br><br><h5>  After all, there must be some connection between the things described above and the indefinite behavior, right? </h5><br><br>  Of course, there is a connection. <br><br>  ¬ß1.9 / 15 mentions that: <br><blockquote>  The evaluation of the operands of a particular operator or subexpressions of a specific expression is irregular, except for the cases that were described earlier. </blockquote><br>  Note: unordered and indefinitely ordered subexpressions of a full expression that is evaluated more than once during program execution are not necessarily calculated each time in the same order. <br><br>  For example: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">19</span></span> ; num = (num &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) + (num &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) ; }</code> </pre> <br><br>  1) The calculation of the operands of the ‚Äú+‚Äù operator is out of order. <br>  2) The calculation of the operands of the operators "&lt;&lt;" and "&gt;&gt;" is out of order. <br><br><blockquote>  ¬ß1.9 / 15 counting the value of the operands of a particular operator [should be TO] counting the value of the result of the operation of the operator. </blockquote><br>  This means that in the x + y expression, the counting of the values ‚Äã‚Äãof "x" and "y" [should be preceded by] the counting of x + y. <br><br>  Now to the more important: <br><br><blockquote>  ¬ß1.9 / 15 If the occurrence of a side effect of a scalar object is disordered with respect to one of the following events: <br><ul><li>  the occurrence of another side effect of the same object </li><li>  counting values ‚Äã‚Äãusing the value of this object </li></ul><br>  then the program behavior will be UNDEFINED. </blockquote><br><br>  Example: <br><pre> <code class="hljs lisp">f(<span class="hljs-name"><span class="hljs-name">i</span></span> = <span class="hljs-number"><span class="hljs-number">-1</span></span>, i = <span class="hljs-number"><span class="hljs-number">-1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  Explain this expression.  At first glance, the disorder in the calculation of the function's arguments does not entail ambiguity.  However, there is no exact probability that the compiler, by optimizing such an expression, will not create a set of instructions similar in action (in his opinion), which will fail during an operation on the same memory. <br><br>  Suppose that the compiler decided that the best way to assign "-1" would be to zero the variable and decrement it. <br>  Instructions can be formed like this (conditional commands): <br><pre> <code class="hljs matlab">clear <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> decr <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> clear <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> decr <span class="hljs-built_in"><span class="hljs-built_in">i</span></span></code> </pre> <br><br>  And they can: <br><pre> <code class="hljs matlab">clear <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> clear <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> decr <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> decr <span class="hljs-built_in"><span class="hljs-built_in">i</span></span></code> </pre> <br><br>  then the value -2 will be stored in i. <br><br>  When the function is called, each calculation of the value and side effect associated with the expression of the argument of this function, or with the expression calling the function, [should be done before] the execution of any expression or operator in the body of the called function. <br>  The counting of the values ‚Äã‚Äãand the side effects associated with the different arguments are unordered. <br><br><h5>  Program flow </h5><br><br>  Using the terms decoded earlier, the program execution flow can be represented graphically.  In the following diagrams, we denote the calculation of the expression (or subexpressions) as E (x), the sequence point is%, the side effect ‚Äúk‚Äù for the object ‚Äúe‚Äù is denoted by S (k, e).  If for the calculation it is necessary to read the value from the named object (let ‚Äúx‚Äù be the name), the calculation will be denoted by V (x), in other cases, as previously agreed, E (x).  Side effects we write to the right and left of the expressions.  The border between two expressions means that the upper expression evaluates to the lower expression (often because the lower expression depends on the prvalue or lvalue of the upper expression). <br>  For two expressions i ++;  i ++;  the diagram will be: <br><br><pre> <code class="hljs matlab">E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) -&gt; { S(increment, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } | <span class="hljs-comment"><span class="hljs-comment">% | E(i++) -&gt; { S(increment, i) } | %</span></span></code> </pre> <br><br>  As you can see, in this case, we have two sequence points, one of which separates the two changes ‚Äúi‚Äù. <br>  Function calls are also of interest, despite the fact that we omit the diagram for them: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>((a == c - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (b == d - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ f(c++, d++); }</code> </pre> <br><br>  This code is correct, because by the time the body of the function f begins to be executed, all side effects generated by the calculation of the arguments are guaranteed to end: ‚Äúc‚Äù and ‚Äúd‚Äù will be increased by 1. <br>  Now consider the expression i ++ * j ++; <br><pre> <code class="hljs matlab">{ S(increment, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } &lt;- E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) E(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) -&gt; { S(increment, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) } \ / +--+--+ | E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) | <span class="hljs-comment"><span class="hljs-comment">%</span></span></code> </pre><br><br>  Where did the two branches come from?  Recall that the sequence points complete the calculations carried out before their occurrence.  All the multiplication subexpressions are calculated before the multiplication itself, there is no more repetition point in this expression, therefore, we need to take into account the theoretical ‚Äúparallelism‚Äù of calculating the operands to suggest where a competitive change of the same object can occur.  More formally, the two branches are unordered.  Sequence points are a relation that orders some calculations and does not order others.  So  sequence points, as mentioned above, are partial ordering (partial order). <br><br><h5>  Conflicting side effects. </h5><br>  In order to provide the compiler with freedom in generating and optimizing machine code, in cases similar to the multiplication considered above, the procedure for calculating subexpressions is not established and the side effects generated by them are not separated (except for the cases described earlier). <br>  This can lead to conflicts, so the Standard calls the program's behavior indefinite if it tries to modify the same object without participation of the following points.  This applies to scalar objects, because other objects are either immutable (array) or simply do not fall under this rule (class objects).  Undefined behavior also occurs if the expression contains a reference to the previous value of the object and its modification, such as in i * i ++ <br><pre> <code class="hljs erlang-repl">//    ! //  ,    <span class="hljs-string"><span class="hljs-string">'i'</span></span>   ¬´¬ª : V(i) E(i++) -&gt; { S(increment, i) }) \ / +---+---+ | E(i * i++) | <span class="hljs-comment"><span class="hljs-comment">%</span></span></code> </pre><br>  As an exception, it is allowed to read the value of an object if it is necessary to calculate a new value.  Context example: i = i + 1 <br><pre> <code class="hljs matlab"> V(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) E(<span class="hljs-number"><span class="hljs-number">1</span></span>) \ / +---+---+ | E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) \ / +-------+-------+ | E(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; { S(assign, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } | <span class="hljs-comment"><span class="hljs-comment">%</span></span></code> </pre><br><br>  Here we see the appeal to ‚Äúi‚Äù on the right side;  after the calculation of both parts, assignment is made.  So  the side effect and the reference to ‚Äúi‚Äù occur without crossing the point of the sequence, but we turned to ‚Äúi‚Äù only to determine the stored value, therefore there will be no disagreement. <br>  Sometimes, the value is read after modification.  For the occasion <br>  a = (b = 0); <br>  it is fair that the writing in ‚Äúb‚Äù takes place, and then reading from ‚Äúb‚Äù without crossing the sequence point.  However, this is normal, because the new value of ‚Äúb‚Äù is already being read, and the old is not addressed.  In this case, the side effects of the assignment ‚Äúb‚Äù will end not only to the next point of the sequence, but also before reading the value ‚Äúb‚Äù required for the assignment ‚Äúa‚Äù.  The standard explicitly states: ‚Äúthe result of an assignment operation is the value stored in the left operand after the assignment is completed (the result is an lvalue)‚Äù.  Why is the notion of a point following?  Because this concept contains an unnecessary requirement in this situation that all side effects of the left and right operand be completed, instead of considering only the side effects of the assignment returning the lvalue with which the read is performed. <br><br>  Sources: <br><ul><li>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">Current standard version</a> </li><li>  <a href="http://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points%3Flq%3D1">stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points?lq=1</a> </li><li>  <a href="http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior">stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/216189/">https://habr.com/ru/post/216189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216177/index.html">How I did USB MFP wireless</a></li>
<li><a href="../216179/index.html">Data collection methods for analyzing the effectiveness of contextual advertising in offline sales</a></li>
<li><a href="../216181/index.html">C ++ web application, or taming the FastCGI daemon</a></li>
<li><a href="../216185/index.html">Work with Korutins in Unity</a></li>
<li><a href="../216187/index.html">Kohana-form: module of management and form generation</a></li>
<li><a href="../216191/index.html">Develop.re - social link aggregator for programmers</a></li>
<li><a href="../216193/index.html">Asterisk + Cisco SPA5XX, SPA3XX - DND with server notification</a></li>
<li><a href="../216197/index.html">Learning NAS Synology to route traffic to an OpenVPN tunnel with certificate authentication</a></li>
<li><a href="../216199/index.html">Logitech G700. One year later</a></li>
<li><a href="../216201/index.html">Collect and analyze logs with Lumberjack + Logstash + Elasticsearch + RabbitMQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>