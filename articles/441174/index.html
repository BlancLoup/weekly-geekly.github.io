<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PLO is dead, long live PLO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="sources of inspiration 
 This post came about thanks to a recent publication by Aras Prantskevichius on a report intended for junior programmers. It t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PLO is dead, long live PLO</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="image"></div><br><h1>  sources of inspiration </h1><br>  This post came about thanks to a recent publication by <a href="https://twitter.com/aras_p" rel="external nofollow">Aras Prantskevichius</a> on a report intended for junior programmers.  It tells you how to adapt to new ECS architectures.  Aras follows the usual pattern ( <em>explained below</em> ): shows examples of a terrible OOP code, and then demonstrates that the relational model is an excellent alternative solution ( <em>but calls it "ECS", not a relational one</em> ).  I do not in any way criticize Aras - I am a big fan of his work and praise him for his excellent presentation!  I chose his presentation instead of hundreds of other posts about ECS from the Internet because he put additional effort and published a git-repository to study in parallel with the presentation.  It contains a small simple ‚Äúgame‚Äù used as an example of a choice of different architectural solutions.  This small project allowed me to demonstrate my comments on specific material, so thank you, Aras! <br><br>  Slides of Aras are posted here: <a href="http://aras-p.info/texts/files/2018Academy%2520-%2520ECS-DoD.pdf" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , and the code is on github: <a href="https://github.com/aras-p/dod-playground" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  I will not (for now?) Analyze the resulting ECS ‚Äã‚Äãarchitecture from this report, but focus on the ‚Äúbad OOP‚Äù code (similar to the ‚Äústuffed trick‚Äù trick) from its beginning.  I will show how it would look in reality if they correctly corrected all violations of the principles of OOD (object-oriented design, object-oriented design). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>Spoiler: eliminating all OOD violations leads to performance improvements, similar to the Aras transformations in ECS, besides it uses less RAM and requires fewer lines of code than the ECS version!</strong> <br><br>  <em>TL; DR: Before you conclude that OOP sucks, and ECS rules, pause and examine OOD (to know how to properly use OOP), and also understand the relational model (to know how to properly apply ECS).</em> <br><a name="habracut"></a><br>  I have been participating in a lot of discussions about ECS on the forum for a long time, partly because I don‚Äôt think that this model deserves to exist as a separate term ( <em>spoiler: it's just an ad-hoc version of the <a href="https://en.wikipedia.org/wiki/Relational_model" rel="external nofollow">relational model</a></em> ), but also because almost <em>every</em> post, presentation, or article promoting the ECS pattern has the following structure: <br><br><ol><li>  Show an example of a terrible OOP code, the implementation of which has terrible flaws due to excessive use of inheritance (which means that this implementation violates many of the principles of OOD). <br></li><li>  Show that composition is a better solution than inheritance (and not to mention that OOD actually gives us the same lesson). <br></li><li>  Show that the relational model is great for games (but call it ‚ÄúECS‚Äù). </li></ol><br>  This structure infuriates me because: <strong>(A)</strong> this is a scarecrow trick ... soft is compared with warm (bad code and good code) ... and that is not fair, even if done unintentionally and not required to demonstrate that the new architecture is good;  and, more importantly: <strong>(B)</strong> it has a side effect - such an approach suppresses knowledge and inadvertently de-motivates readers from exploring the research that has been conducted for half a century.  About the relational model first started writing in the 1960s.  During the 70s and 80s, this model has improved significantly.  Beginners often have questions like ‚Äú <em>what class do you need to put this data in?</em> ‚Äù, And in response they are often told something vague, like ‚Äú <em>you just need to gain experience and then you just learn to understand with your gut</em> ‚Äù ... but in the 70s this question was actively it was studied and a formal answer was derived for it in the general case;  this is called <a href="https://en.wikipedia.org/wiki/Database_normalization" rel="external nofollow">database normalization</a> .  Discarding existing research and calling ECS ‚Äã‚Äãa completely new and modern solution, you hide this knowledge from newcomers. <br><br>  The basics of object-oriented programming were laid just as long ago, if not earlier ( <em>this style began to be explored in the work of the 1950s</em> )!  However, it was in the 1990s that object-orientation became fashionable, viral, and very quickly turned into the dominant programming paradigm.  There has been an explosion in the popularity of many new OO languages, including Java and (the <em>standardized version</em> ) C ++.  However, since this was connected with the hype, everyone <em>needed to</em> know this loud concept in order to write it into their resume, but only a few really went into it.  These new languages ‚Äã‚Äãhave created many of the features of OO keywords ‚Äî <em>class</em> , <em>virtual</em> , <em>extends</em> , <em>implements</em> ‚Äî and I believe that this is why at that moment OO was divided into two separate entities living their own lives. <br><br>  I will call the use of these OO-inspired language features " <strong><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="external nofollow">OOP</a></strong> " and the use of OO-inspired design / architecture creation techniques " <strong><a href="https://en.wikipedia.org/wiki/Object-oriented_design" rel="external nofollow">OOD</a></strong> ".  All very quickly picked up the PLO.  In educational institutions there are OO courses baking new OOP programmers ... however, the knowledge of OOD is lagging behind. <br><br>  I believe that code that uses OOP language features, but is not following OOD design principles, is <strong>not OO code</strong> .  Most of the criticisms against OOP use gutted code for example, which is not really OO code. <br><br>  The OOP code has a very bad reputation, and in particular because most of the OOP code does not follow the principles of OOD, and therefore is not a ‚Äútrue‚Äù OO code. <br><br><h1>  Prerequisites </h1><br>  As mentioned above, the 1990s marked the peak of the ‚Äúfashion for OO‚Äù, and it was at that time that the ‚Äúbad OOP‚Äù was probably the worst of all.  If you studied PLO at that time, you most likely learned about the "four pillars of PLO": <br><br><ul><li>  Abstraction </li><li>  Encapsulation </li><li>  Polymorphism </li><li>  Inheritance </li></ul><br>  I prefer to call them not four pillars, but "four tools of the PLO."  These are tools that <em><strong>can be</strong></em> used to solve problems.  However, it is not enough just to find out how the tool works, you need to know when <strong><em>to</em></strong> use it ... It is irresponsible for teachers to teach people new tools, not to tell them when each of them should be used.  In the early 2000s, there was resistance to the active misuse of these tools, a kind of ‚Äúsecond wave‚Äù of OOD thinking.  This resulted in the emergence of the <a href="https://en.wikipedia.org/wiki/SOLID" rel="external nofollow">SOLID</a> mnemonic, which provided a quick way to assess the strengths of the architecture.  It should be noted that this wisdom was actually widespread in the 90s, but did not receive a steep acronym that allowed them to be consolidated as five basic principles ... <br><br><ul><li>  <strong><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="external nofollow">The principle of sole responsibility</a></strong> ( <b>S</b> ingle responsibility principle).  Each class should have only one reason for the change.  If the class ‚ÄúA‚Äù has two responsibilities, then you need to create a class ‚ÄúB‚Äù and ‚ÄúC‚Äù to process each of them separately, and then create an ‚ÄúA‚Äù from ‚ÄúB‚Äù and ‚ÄúC‚Äù. </li><li>  <strong><a href="https://en.wikipedia.org/wiki/Open/closed_principle" rel="external nofollow">The principle of openness / closeness</a></strong> ( <b>O</b> pen / closed principle).  Software changes over time ( <em>i.e. support is important</em> ).  Strive to put the parts that are likely to change in <em>implementations (</em> <em>ie, in concrete classes</em> ) and create <em>interfaces (interfaces)</em> based on those parts that most likely will not change ( <em>for example, abstract base classes</em> ). <br></li><li>  <strong><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="external nofollow">Barbara Liskov</a></strong> substitution principle ( <b>L</b> iskov substitution principle).  Each interface implementation must meet the requirements of this interface 100%, i.e.  any algorithm that works with the interface should work with any implementation. </li><li>  <strong><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="external nofollow">Interface separation principle</a></strong> ( <b>I</b> nterface segregation principle).  Make the interfaces as small as possible so that each part of the code ‚Äúknows‚Äù about the smallest amount of code base, for example, avoids unnecessary dependencies.  This tip is also good for C ++, where the compile time becomes huge if you don‚Äôt follow it. </li><li>  Dependency inversion principle ( <b>D</b> ependency inversion principle).  Instead of two specific implementations that communicate directly (and are dependent on each other), they can usually be separated by formalizing their communication interface as the third class used as the interface between them.  It can be an abstract base class that defines calls to methods used between them, or even just a <a href="https://en.wikipedia.org/wiki/Plain_old_data" rel="external nofollow">POD</a> structure that defines the data passed between them. </li><li> Another principle is not included in the SOLID acronym, but I‚Äôm sure that it is very important: <strong><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="external nofollow">‚Äú</a></strong> Composite reuse principle‚Äù.  Composition <em>is the right choice by default</em> .  Inheritance should be left for cases where it is absolutely necessary. </li></ul><br>  So we get SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Below I will refer to these principles, calling them by acronyms - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  A few more comments: <br><br><ul><li>  In OOD, the concepts of <em>interfaces</em> and <em>implementations</em> cannot be tied to any specific OOP keywords.  In C ++, we often create interfaces with <em>abstract base classes</em> and <em>virtual functions</em> , and then <em>implementations</em> inherit from these base classes ... but this is only one specific way of implementing the interface principle.  In C ++, we can also use <a href="https://en.cppreference.com/w/cpp/language/pimpl" rel="external nofollow">PIMPL</a> , <a href="https://en.wikipedia.org/wiki/Opaque_pointer" rel="external nofollow">opaque pointers</a> , <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="external nofollow">duck typing</a> , typedef, etc ... You can create an OOD structure and then implement it in C, in which there are no OOP language keywords at all!  Therefore, when I speak about <em>interfaces</em> , I do not necessarily mean <em>virtual</em> functions ‚Äî I speak about the principle of <a href="https://en.wikipedia.org/wiki/Information_hiding" rel="external nofollow">hiding implementation</a> .  Interfaces <em>can</em> be <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="external nofollow">polymorphic</a> , but most often they are not!  Polymorphism is correctly used very rarely, but interfaces are a fundamental concept for all software. <br><ul><li>  As I made it clear above, if you create a POD structure that simply stores some data for transfer from one class to another, then this structure is used as an <em>interface</em> - this is a formal <a href="https://en.wikipedia.org/wiki/Data_definition_language" rel="external nofollow">description of the data</a> . <br></li><li>  Even if you simply create one separate class with the <em>common</em> and <em>private</em> parts, then everything that is in the common part is the <em>interface</em> , and everything in the private part is the <em>implementation</em> . </li></ul></li><li>  Inheritance actually has (at least) two types - interface inheritance and implementation inheritance. <br><ul><li>  In C ++, interface inheritance includes abstract base classes with pure virtual functions, PIMPL, conditional typedefs.  In Java, interface inheritance is expressed through the <em>implements</em> keyword. </li><li>  In C ++, the inheritance of implementations happens every time the base classes contain something other than pure virtual functions.  In Java, implementation inheritance is expressed using the <em>extends keyword</em> . </li><li>  In OOD, there are many rules for interface inheritance, but inheritance implementations should usually be considered as <a href="https://en.wikipedia.org/wiki/Code_smell" rel="external nofollow">‚Äúcode with a nice smell‚Äù</a> ! </li></ul></li></ul><br>  And finally, I should show a few examples of the terrible learning of the PLO and how it leads to bad code in real life (and the bad reputation of OOP). <br><br><ol><li>  When you were taught hierarchies / inheritance, you might have been given a similar task: <strong><em>Suppose you have a university application that contains a catalog of students and staff.</em></strong>  <strong><em>You can create the base class Person, and then the class Student and the class Staff, inherited from Person.</em></strong> <br><br>  No no no.  Here I will stop you.  The tacit subtext of the LSP principle states that <em>class hierarchies</em> and <em>algorithms that process them</em> are symbiotic.  These are two halves of the whole program.  OOP is an extension of procedural programming, and it is still mainly related to these procedures.  If we do not know which types of algorithms will work with <i>Students</i> and <em>Staff</em> ( <em>and which algorithms will be simplified due to polymorphism</em> ), then it will be completely irresponsible to start creating the structure of class hierarchies.  First you need to know the algorithms <em>and</em> data. </li><li>  When you were taught hierarchies / inheritance, you were probably given a similar task: <b><i>Suppose you have a class of shapes.</i></b>  <b><i>We also have squares and rectangles as subclasses.</i></b>  <b><i>Should the square be a rectangle, or a rectangle square?</i></b> <br><br>  In fact, this is a good example to demonstrate the difference between the inheritance of implementations and the inheritance of interfaces. <br><ul><li>  If you use the inheritance approach, you completely ignore the LSP and think from a practical point of view about the reusability of the code, using inheritance as a tool. <br><br>  From this point of view, the following is completely logical: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  The square has only width, and the rectangle has width + height, that is, expanding the square with the height component, we get a rectangle! <br><ul><li>  As you might have guessed, OOD says that doing so ( <em>probably</em> ) is wrong.  I said <em>"probably"</em> , because here you can argue about the implied characteristics of the interface ... but oh well. <br><br>  The square always has the same height and width, so from the interface of the square it is quite true to assume that the area is equal to "width * width". <br><br>  Inheriting from the square, the class of rectangles (in accordance with the LSP) <strong>should</strong> obey the rules of the interface of the square.  Any algorithm that works correctly for a square should also work correctly for a rectangle. </li><li>  Take another algorithm: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  It will work correctly for squares (calculating the sum of their areas), but will not work for rectangles. <br><br>  Consequently, the rectangle violates the principle of LSP. </li></ul></li><li>  If you use the interface inheritance approach, then neither Square nor Rectangle will inherit from each other.  The interfaces for a square and a rectangle are actually different, and one is not a superset of the other. <br></li><li>  Therefore, OOD prevents the use of inheritance implementations.  As stated above, if you want to reuse the code, then OOD says that the right choice is composition! <br><ul><li>  So the <i>correct</i> version of the above (bad) code inheritance hierarchy of implementations in C ++ looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Public virtual" in Java means "implements".  Used when implementing an interface. <br></li><li>  ‚ÄúPrivate‚Äù allows you to extend the base class without inheriting its interface ‚Äî in this case, the rectangle is <b>not a</b> square, although it is inherited from it. <br></li></ul></li><li>  I do not recommend writing such code, but if you want to use inheritance implementations, then you need to do it that way! </li></ul></li></ul></li></ol><br>  TL; DR - your OOP class told you what inheritance was like.  Your missing OOD class should have told you not to use it 99% of the time! <br><br><h1>  Entity / Component Concepts </h1><br>  Having dealt with the prerequisites, let's move on to what Aras began with - the so-called starting point of the ‚Äútypical OOP‚Äù. <br><br>  But first, one more addition - Aras calls this code ‚Äútraditional OOP‚Äù, and I want to object to this.  This code may be typical of OOP in the real world, but, like the examples above, it violates all sorts of basic principles of OO, so it should not be considered as traditional at all. <br><br>  I will start with the first commit before he began to redo the structure in the direction of ECS: <a href="" rel="external nofollow">‚ÄúMake it work on Windows again‚Äù 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Yes, one hundred lines of code is difficult to understand right away, so let's start gradually ... We need another aspect of the prerequisites - in the games of the 90s it was popular to use inheritance to solve all the problems of code reuse.  You had an Entity, an expandable Character, an expandable Player and Monster, and so on ... This is an inheritance of implementations, as we described it earlier ( <em>"tactile code"</em> ), and it seems that it‚Äôs right to start with it, but as a result it leads to a very inflexible codebase.  Because in OOD there is the ‚Äúcomposition over inheritance‚Äù principle described above.  So, in the 2000s, the ‚Äúcomposition over inheritance‚Äù principle became popular, and game developers started writing similar code. <br><br>  What does this code do?  Well, nothing good <img alt=":D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  In short, <strong>this code re-implements an existing language feature ‚Äî composition</strong> as a runtime library, and not as a language feature.  You can think of it as if the code actually creates a new metalanguage over C ++ and a virtual machine (VM) to execute this metalanguage.  In the demo game Aras, this code is not required ( <em>soon we will completely remove it!</em> ) And serves only to reduce the performance of the game by about 10 times. <br><br>  However, what does he actually do?  This is the concept of " <strong>E</strong> ntity / <strong>C</strong> omponent" ("entity / component") ( <em>sometimes for some unknown reason called the " <strong>E</strong> ntity / <strong>C</strong> omponent system"</em> ), but it is completely different from the concept of " <strong>E</strong> ntity <strong>C</strong> omponent <strong>S</strong> ystem "(" entity-component-system ") ( <em>which for obvious reasons is never called" <strong>E</strong> ntity <strong>C</strong> omponent <strong>S</strong> ystem systems</em> ). It formalizes several principles of "EC": <br><br><ul><li>  the game will be built from non-featured ‚Äúentities‚Äù (‚ÄúEntity‚Äù) ( <em>in this example called</em> GameObjects), which consist of ‚Äúcomponents‚Äù (‚ÄúComponent‚Äù). </li><li>  GameObjects implement the <a href="https://en.wikipedia.org/wiki/Service_locator_pattern" rel="external nofollow">service locator pattern</a> ‚Äî their child components will be queried by type. </li><li>  Components know how GameObjects belong to them - they can find components that are on the same level with them by querying the parent GameObject. <br></li><li>  A composition can be only one level deep ( <em>components cannot have their own child components, GameObjects cannot have child GameObjects</em> ). <br></li><li>  A GameObject can have only one component of each type ( <em>in some frameworks this is a mandatory requirement, in others it is not</em> ). <br></li><li>  Each component (probably) over time changes in some unspecified manner, so the interface contains "virtual void Update". <br></li><li>  GameObjects belong to a scene that can query all GameObjects (and therefore all components). </li></ul><br>  This concept was very popular in the 2000s, and despite its limitations, it was flexible enough to create countless games, then and today. <br><br>  However, this is not required.  In your programming language, there is already support for composition as a feature of the language ‚Äî to access it, there is no need for a bloated concept ... Why, then, do these concepts exist?  Well, to be honest, they allow you to perform <em>dynamic composition at run time</em> .  Instead of hard-typing GameObject types in code, you can load them from data files.  And this is very convenient because it allows game / level designers to create their own object types ... However, in most game projects there are very few designers and literally an entire army of programmers, so I would argue that this is an important opportunity.  Worse, this is not the only way a composition can be realized at runtime!  For example, Unity uses C # as its ‚Äúscripting language‚Äù, and many other games use its alternatives, for example, Lua - a handy tool for designers, can generate C # / Lua code for defining new game objects without the need for a bloated concept like this!  We will re-add this ‚Äúfunction‚Äù in the next post, and make it so that it does not cost us a tenfold reduction in performance ... <br><br>  Let's rate this code according to the OOD: <br><br><ul><li>  GameObject :: GetComponent uses dynamic_cast.  Most people will tell you that dynamic_cast is a ‚Äúcode with a nice touch,‚Äù a big hint that you have an error somewhere.  I would say so - this is evidence that you have broken the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="external nofollow">LSP</a> - you have some kind of algorithm that works with the basic interface, but it needs to know different implementation details.  For this particular reason, the code and "smells bad." <br></li><li>  GameObject is not bad in principle if you imagine that it implements the ‚Äúservice locator‚Äù pattern ... but if you go further than criticism from the OOD point of view, this pattern creates implicit links between parts of the project, and I think ( <em>without reference to Wikipedia capable of supporting I know from computer science</em> ) that implicit communication channels are an <a href="https://en.wikipedia.org/wiki/Anti-pattern" rel="external nofollow">anti-pattern</a> , and they should prefer explicit communication channels.  The same argument applies to bloated ‚Äúevent concepts‚Äù that are sometimes used in games ... <br></li><li>  I want to state that a component is a violation of <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="external nofollow">SRP</a> , because its interface ( <em>virtual void Update (time)</em> ) is too wide.  Using "virtual void Update" in game development is widespread, but I would also say that this is an anti-pattern.  Good software should make it easy for you to think about control flow and data flow.  Placing <em>each element of the gameplay code</em> after a call to ‚Äúvirtual void Update‚Äù completely and completely obfusts the control flow and data flow.  IMHO, invisible <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="external nofollow">side effects</a> , also called <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)" rel="external nofollow">long</a> - <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)" rel="external nofollow">range</a> <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="external nofollow">effects</a> , are among the most common sources of bugs, and ‚Äúvirtual void Update‚Äù ensures that almost everything will be an invisible side effect. <br></li><li>  Although the goal of the Component class is to enable composition, it performs it through inheritance, which is a violation of <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="external nofollow">CRP</a> . </li><li>  The only good side of this example is that the game code climbs out of its skin, if only to comply with the principles of SRP and ISP - it is divided into many simple components with very small responsibilities, which is great for repeated use of the code. <br><br>  However, he is not so good at complying with DIP - many components have direct knowledge of each other. </li></ul><br>  So, all the code shown above can actually be deleted.  All this structure.  Delete GameObject (also called Entity in other frameworks), delete Component, remove FindOfType.  This is part of a useless VM that violates the principles of OOD and terribly slows down our game. <br><br><h1>  Composition without frameworks (i.e. use of features of the programming language itself) </h1><br>  If we remove the composition framework, and we don‚Äôt have the base Component class, how can our GameObjects use the composition and consist of components?  As stated in the title, instead of writing this bloated VM and creating GameObjects on top of it on a strange metalanguage, let's just write them in C ++, because we are game programmers and this is literally our job. <br><br>  Here is the commit in which the Entity / Component framework is deleted: <a href="https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Here is the original version of the source code: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Here is the modified version of the source code: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Briefly about the changes: <br><br><ul><li>  Removed ": public component" from each component type. <br></li><li>  Added a constructor to each component type. <br><ul><li>  OOD is primarily about class state encapsulation, but since these classes are so small / simple, there‚Äôs really nothing to hide: the interface is a description of the data.  However, one of the main reasons why encapsulation is the main pillar is that it allows us to guarantee the constant validity <a href="https://en.wikipedia.org/wiki/Class_invariant" rel="external nofollow">of class invariants</a> ... or if the invariant is broken, then it is enough for you to examine the encapsulated implementation code to find the error.  In this sample code, it is worth adding constructors to implement a simple invariant ‚Äî all values ‚Äã‚Äãmust be initialized. </li></ul></li><li>  I renamed the too general ‚ÄúUpdate‚Äù methods so that their names reflect what they actually do ‚Äî UpdatePosition for MoveComponent and ResolveCollisions for AvoidComponent. <br></li><li>  I deleted three hard-coded blocks of code that resemble the template / prefab ‚Äî the code that creates a GameObject containing specific Component types, and replaced it with three C ++ classes. <br></li><li>  Eliminated antipattern "virtual void Update". <br></li><li>  Instead of components looking for each other through the ‚Äúservice locator‚Äù pattern, the game explicitly links them together in the design. </li></ul><br><h2>  Objects </h2><br>  Therefore, instead of this ‚Äúvirtual machine‚Äù code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  We now have the usual C ++ code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algorithms </h2><br>  Another major change has been made to the algorithms.  Remember, at the beginning I said that interfaces and algorithms work in symbiosis, and should influence the structure of each other?  So, the anti-pattern " <em>virtual void Update</em> " has become the enemy here too.  The initial code contains the main loop algorithm, consisting of only this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  You can argue that it is beautiful and simple, but IMHO is very, very bad.  This completely obfuscates both the <em>flow of control</em> and the <em>flow of data</em> within the game.  If we want to be able to understand our software, if we want to support it, if we want to add new things to it, optimize it, run it efficiently on several processor cores, then we need to understand both the flow of control and the flow of data.  Therefore, ‚Äúvirtual void Update‚Äù needs to be turned on. <br><br>  Instead, we have created a more explicit main loop, which greatly simplifies the understanding of the control flow (the <em>data flow in it is still obfuscated, but we will fix this in the following commits</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  The disadvantage of this style is that for <em>each new type of object</em> added to the game, we will have to add a few lines to the main loop.  I will come back to this in a later post in this series. <br><br><h1>  Performance </h1><br>  There are a lot of huge violations of OOD, some bad decisions were made when choosing a structure and there are still many opportunities for optimization, but I will get to them in the next post of the series.  However, at this stage it is clear that the version with the ‚Äúcorrected OOD‚Äù almost fully meets or defeats the final ‚ÄúECS‚Äù code from the end of the presentation ... And all we did was just take the bad pseudo-OOP code and make it follow the principles OOP (and also deleted a hundred lines of code)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Next steps </h1><br>  Here I want to consider a much wider range of issues, including solving the remaining OOD problems, immutable objects ( <a href="https://en.wikipedia.org/wiki/Functional_programming" rel="external nofollow">programming in the functional style</a> ) and the advantages they can bring in reasoning about data flows, message passing, applying DOD logic to our OOD code, applying relevant wisdom in the OOD code, removing these classes of ‚Äúentities‚Äù that we end up with, and using only pure components, using different styles of connecting components (comparing pointers and  the responsibility of carrying) components of containers from the real world, ECS-revision version for better optimization, as well as further optimization, not mentioned in the report Aras <em>(such as multi-threading / SIMD).</em>  The order will not necessarily be such, and perhaps I will consider not all of the above ... <br><br><h1>  Addition </h1><br>  Links to the article have spread beyond the circles of game developers, so add: " <a href="https://en.wikipedia.org/wiki/Entity%25E2%2580%2593component%25E2%2580%2593system" rel="external nofollow">ECS</a> " ( <em>this Wikipedia article is bad, by the way, it combines the concepts of EC and ECS, and this is not the same thing ...</em> ) - this is a fake template that circulates within communities game developers.  In essence, it is a version of the relational model, in which ‚Äúentities‚Äù are simply IDs, meaning a shapeless object, ‚Äúcomponents‚Äù are rows in specific tables that refer to IDs, and ‚Äúsystems‚Äù are procedural code that can modify components .  This ‚Äúpattern‚Äù has always been positioned as a solution to the problem of excessive use of inheritance, but it does not mention that excessive use of inheritance actually violates the recommendations of the PLO.  From here my indignation.  This is not ‚Äúthe only true way‚Äù of writing software.  The post is designed so that people actually study existing design principles. </div><p>Source: <a href="https://habr.com/ru/post/441174/">https://habr.com/ru/post/441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441160/index.html">How to learn to determine when to say ‚Äúno‚Äù</a></li>
<li><a href="../441166/index.html">We get the master password from the password manager 1Password 4 blocked</a></li>
<li><a href="../441168/index.html">QUIC DataChannels: First Steps</a></li>
<li><a href="../441170/index.html">The head of "Roskosmos" does not believe in Mask's ability to create a rocket engine, superior to Russian developments</a></li>
<li><a href="../441172/index.html">As the 3D printing market grew in 2018 and what does this mean for business</a></li>
<li><a href="../441176/index.html">Yandex.Music was automatically installed on Windows 10 and replaced the standard MP3 application.</a></li>
<li><a href="../441180/index.html">Cloudy, Likely non-switchable ads on the starry sky</a></li>
<li><a href="../441182/index.html">Machine-synaesthetic approach to detecting network DDoS attacks. Part 2</a></li>
<li><a href="../441186/index.html">ASH Viewer: Reboot</a></li>
<li><a href="../441188/index.html">On Twitter, a protocol of administrative offense</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>