<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Singleton (Translated from the English chapter "Singleton" from the book "Pro Objective-C Design Patterns for iOS" by Carlo Chung)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In mathematics and logic, a singleton is defined as ‚Äúa set containing exactly one element‚Äù. Therefore, no matter how big the bag is, every time we try...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Singleton (Translated from the English chapter "Singleton" from the book "Pro Objective-C Design Patterns for iOS" by Carlo Chung)</h1><div class="post__text post__text-html js-mediator-article"> In mathematics and logic, a singleton is defined as ‚Äúa set containing exactly one element‚Äù.  Therefore, no matter how big the bag is, every time we try to get the ball out of it, we will get the same one.  In what situations need a singleton in programming?  Think about resources that cannot be copied, but can be shared.  For example, a single GPS module is installed on the iPhone and only he is able to determine the current coordinates.  The <code>CLLocationManager</code> class from the <code>CLLocationManager</code> framework provides a single entry point to all GPS module services.  Someone might think: if you can make a copy of <code>CLLocationManager</code> , is it possible to get an additional set of GPS services for your application?  It sounds like a fantasy - you created two software GPS for the price of one hardware.  But in reality, you still get only one GPS at a time, since the iPhone has only one GPS, which creates real connections with satellites.  So, if you think you have created a super application that can manipulate two separate GPS connections at the same time, and want to brag about it to your friends, think twice. <br><br>  A singleton class in an object-oriented application always returns the same instance of itself.  It provides a global access point for the resources that the class object provides.  A pattern with this functionality is called Singleton. <br>  In this chapter, we will explore the possibilities of implementing and using the Singleton pattern in Objective-C and the Cocoa Touch framework on iOS. <br><a name="habracut"></a><br><h5>  What is the Singleton pattern? </h5><br>  The Singleton pattern is perhaps the simplest pattern.  Its purpose is to make a class object a single instance on the system.  First of all, it is necessary to prohibit the creation of more than one instance of a class.  To do this, you can use the factory method (Chapter 4), which should be static, since it does not make sense to allow an instance of a class to create another single instance.  Figure 7-1 shows the structure of a simple singleton class. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/f70/60e/3adf7060e2e64633da3beb2f23f9d8bb.png" alt="image"><br>  Figure 7-1.  The static structure of the pattern Singleton. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A static <code>uniqueInstance</code> is a single instance of the class <code>Singleton</code> , represented as a class variable that the static method <code>sharedInstance</code> returns to clients.  Normally sharedInstance will check if <code>uniqueInstance</code> is <code>uniqueInstance</code> .  If not, the method will create it before returning. <br><br>  Note.  <b>Pattern Singleton:</b> Verifies that there is only one instance of the class and provides a single point of access to it. * <br>  * Original definition provided in GoF Design Patterns (Addison-Wesley, <br>  1994). <br><br><h5>  When can I use the Singleton pattern? </h5><br>  It makes sense to think about using the pattern Singleton, if: <br><ul><li>  The system can have only one instance of a class, which should be accessible through a well-known access point, for example, a factory method. </li><li>  A single instance can be extended only by inheritance, and the client code will not lose its working capacity from using the extended object. </li></ul><br>  The Singleton pattern provides a familiar way to create a unique instance with a convenient way to access a shared resource.  The method of using a reference to a static global object does not prevent the creation of another instance of the same class.  The class method approach, although it can provide a global access point, lacks the flexibility of code separation. <br>  A static global variable contains a single reference to an instance of a class.  Another class or method that has access to it actually shares the same copy with other classes or methods that use the same variable.  It looks like what we need.  Everything looks great as long as the same global variable is used throughout the application.  Thus, in fact, the Singleton pattern is not needed.  But wait!  What if someone on your team defined the same global variable in your code as yours?  Then there will be two copies of the same global object in the same application - so the global variable does not actually solve the problem. <br><br>  A class method provides the ability to split without creating its object.  A single resource instance is supported in the class method.  However, this approach has a lack of flexibility if a class requires inheritance to provide more functionality. <br><br>  The Singleton class can guarantee a single, consistent and well-known access point for creating and accessing a single class object.  The pattern provides such flexibility that any of its subclasses can override the method of creating an instance and have full control over the creation of a class object without changing the client code.  Even better, the implementation of the instance creation method can handle the creation of an object dynamically.  The actual class type can be determined at runtime to ensure that the correct object is created.  This technique will be discussed further. <br><br>  There is also a flexible version of the Singleton pattern, in which the factory method always returns the same instance, but it is possible in addition to allocate and initialize other instances.  This less stringent version of the pattern is discussed in the section ‚ÄúUsing the NSFileManager class‚Äù later in this chapter. <br><br><h5>  Implementing Singleton in Objective-C </h5><br>  There is something to think about in order to design the Singleton class correctly.  The first question to ask is how to make sure that only one instance of the class can be created?  Clients in an application written in other object-oriented languages, such as C ++ and Java, cannot create a class object if its constructor is declared private.  And what about Objective-C? <br><br>  Any Objective-C method is open, and the language itself is dynamically typed, so any class can send a message to another (method call in C ++ and Java) without significant checks at compile time (only compiler warnings if the method is not declared).  Also, the Cocoa framework (including the Cocoa Touch) uses memory management by reference counting to maintain the lifetime of an object in memory.  All these features make the implementation of Singleton in Objective-C quite complicated. <br>  In the original example of the book ‚ÄúDesign Patterns‚Äù, the example of Singleton in C ++ looked like Listing 7-1. <br><br>  Listing 7-1.  The original C ++ pattern example Singleton from the book Design Patterns. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Singleton *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Singleton(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton *_instance; }; Singleton *Singleton::_instance = <span class="hljs-number"><span class="hljs-number">0</span></span>; Singleton *Singleton::Instance() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_instance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Singleton; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _instance; }</code> </pre><br>  As described in the book, the implementation in C ++ is simple and straightforward.  In the static method <code>Instance()</code> static variable <code>_instance</code> checked to 0 ( <code>NULL</code> ).  If so, a new object of class <code>Singleton</code> and then returned.  Some of you might think that the Objective-C version is not much different from its counterpart and should look like in listings 7-2 and 7-3. <br><br>  Listing 7‚Äì2.  Singleton class declaration in Singleton.h <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ } + (Singleton *) sharedInstance; <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  Listing 7‚Äì3.  Implementing the sharedInstance Singleton.m method <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sharedSingleton_</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nil</span></span></span><span class="hljs-class">; + (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sharedInstance</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sharedSingleton_ == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { sharedSingleton_ = [[Singleton alloc] init]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sharedSingleton_; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  If so, then this is a very simple chapter, and you have already studied one pattern implemented in Objective-C.  In fact, there are several difficulties that need to be overcome to make the implementation reliable enough to be used in a real application.  If you need a ‚Äústrict‚Äù version of the Singleton pattern, then there are two main problems that need to be solved so that it can be used in real code: <br><ul><li>  The caller cannot create a Singleton object through other means of allocation.  Otherwise, it will be possible to create multiple instances of the Singleton class. </li><li>  Restrictions on the creation of a Singleton object should be consistent with the reference counting model. </li></ul><br>  Listing 7-4 shows an implementation that is close to the one we are aiming for.  The code is quite long, so we break it into several parts for ease of discussion. <br><br>  Listing 7-4.  More suitable implementation of Singleton in Objective-C <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Singleton.h"</span></span></span><span class="hljs-meta"> @implementation Singleton static Singleton * sharedSingleton_ = nil; + (Singleton*) sharedInstance { if (sharedSingleton_ == nil) { sharedSingleton_ = [[super allocWithZone:NULL] init]; } return sharedSingleton_; }</span></span></code> </pre><br><br>  Inside the <code>sharedInstance</code> method, just as in the first example, it is first checked that a single instance of the class is created, otherwise a new one is created and returned.  But this time, it calls <code>[[super allocWithZone:NULL] init]</code> to create a new instance instead of using other methods, such as <code>alloc</code> .  Why <code>super</code> and not <code>self</code> ?  This is because the basic methods for allocating memory for an object in our class are redefined, so you need to ‚Äúborrow‚Äù this functionality from the base class, in this case from <code>NSObject</code> , to help make the low-level routine work of allocating memory for us. <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) allocWithZone:(<span class="hljs-built_in"><span class="hljs-built_in">NSZone</span></span> *)zone { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> sharedInstance] <span class="hljs-keyword"><span class="hljs-keyword">retain</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) copyWithZone:(<span class="hljs-built_in"><span class="hljs-built_in">NSZone</span></span>*)zone { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br><br>  There are several methods that relate to memory management in the <code>Singleton</code> class that you need to think about.  In the <code>allocWithZone:(NSZone *)zone</code> method, the class instance that is returned from the <code>sharedInstance</code> method <code>sharedInstance</code> .  In the Cocoa Touch framework, when calling the class <code>allocWithZone:(NSZone *)zone</code> class method, the memory for the instance will be allocated, its reference count will be set to 1, and the instance will be returned.  We have seen that the <code>alloc</code> method <code>alloc</code> used in many situations;  in fact, <code>alloc</code> <code>allocWithZone:</code> with the zone set to <code>NULL</code> to allocate memory for the instance in the default zone.  The details of creating an object and managing memory are outside of this book.  You can consult the documentation for further clarification. <br><br>  Similarly, you need to override the <code>copyWithZone:(NSZone*)zone</code> method to make sure that it does not return a copy of the instance, but returns the same one, returning <code>self</code> . <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">retain</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>) retainCount { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSUIntegerMax</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       } - (void) release { //    } - (id) autorelease { return self; } @end</span></span></code> </pre><br><br>  Other methods, such as <code>retain</code> , <code>release</code> and <code>autorelease</code> , are redefined to make sure that they do nothing (in the memory management model with reference counting), except to return <code>self</code> .  The <code>retainCount</code> method returns <code>NSUIntegerMax</code> (4,294,967,295) to prevent an instance from being deleted from memory during the life of the application. <br><br>  <b>Why call retain singleton?</b> <br>  You may have noticed that we call <code>retain</code> a Singleton object that is returned from the <code>sharedInstance</code> method in <code>allocWithZone:</code> but <code>retain</code> overridden and is actually ignored in our implementation.  Given this, we will have the opportunity to make the Singleton class less ‚Äústrict‚Äù (that is, it will be possible to allocate memory for additional instances and initialize them, but the factory <code>sharedInstance</code> method always returns the same instance or Singleton object becoming destructible).  Subclasses can override the <code>retain</code> , <code>release</code> and <code>autorelease</code> again to provide a suitable implementation of memory management. <br>  The flexible version of the Singleton pattern is discussed in the section ‚ÄúUsing the NSFileManager Class‚Äù later in this chapter. <br><br>  We have already discussed in some detail how the Singleton pattern should look like in Objective-C.  However, there is one more thing to think about before you can use it.  What if we want to inherit from the original class <code>Singleton</code> ?  Consider how to do this. <br><br><habracut><h5>  Inheritance from Singleton </h5><br>  The <code>alloc</code> call <code>alloc</code> redirected to <code>super</code> , so the <code>NSObject</code> class <code>NSObject</code> take care of allocating memory for the object.  If we inherit from the class <code>Singleton</code> without modifications, then the returned instance will always be of type <code>Singleton</code> .  Since the <code>Singleton</code> class overrides all instance-related methods, it is rather difficult to inherit from it.  But we were lucky;  You can use some Foundation functions to instantiate any object based on its class type.  One of them is <code>id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)</code> .  Therefore, if we want to instantiate an object of the class called ‚ÄúSingleton‚Äù, we can do the following: <br><br><pre> <code class="objectivec hljs">Singleton *singleton = [<span class="hljs-built_in"><span class="hljs-built_in">NSAllocateObject</span></span> ([Singleton <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) init];</code> </pre><br><br>  The first parameter is the type of the class <code>Singleton</code> .  The second parameter is intended for any number of additional bytes for indexed instance variables, which is always 0. The third parameter is the designation of the zone of allocated memory;  the default zone is almost always used (the parameter is <code>NULL</code> ).  Therefore, you can instantiate any objects using this function, knowing the class type.  What should I do to inherit from the class <code>Singleton</code> ?  Let's remember that the original version of the <code>sharedInstance</code> method looks like this: <br><br><pre> <code class="objectivec hljs">+ (Singleton*) sharedInstance { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sharedSingleton_ == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { sharedSingleton_ = [[<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> allocWithZone:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>] init]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sharedSingleton_; }</code> </pre><br><br>  If you use the trick with <code>NSAllocateObject</code> to create an instance, it will become like this: <br><br><pre> <code class="objectivec hljs">+ (Singleton *) sharedInstance { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sharedSingleton_ == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { sharedSingleton_ = [<span class="hljs-built_in"><span class="hljs-built_in">NSAllocateObject</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) init]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sharedSingleton_; }</code> </pre><br><br>  Now it doesn't matter if we instantiate the class <code>Singleton</code> or one of its subclasses, this version will do everything correctly. <br><br><h5>  Thread safety </h5><br>  The class <code>Singleton</code> in the example is only good for general use.  If you need to use a singleton object in a multi-threaded environment, then you need to make it thread-safe.  To do this, you can insert <code>@synchronized()</code> blocks or use <code>NSLock</code> instances around checking for <code>nil</code> for the <code>sharedSingleton_</code> static variable variable.  If there are any other properties that need to be protected too, then you can make them <code>atomic</code> . <br><br><h5>  Using Singltons in the Cocoa Touch framework </h5><br>  In the process of familiarization with the Cocoa Touch Framework documentation, you will meet many different classes of singletons.  We will talk about some of them in this section - <code>UIApplication</code> , <code>UIAccelerometer</code> and <code>NSFileManager</code> . <br><br><h6>  UIApplication class usage </h6><br>  One of the most commonly used singleton classes in the framework is the <code>UIApplication</code> class.  It provides a centralized point of control and coordination for iOS applications. <br><br>  Each application has a single instance of <code>UIApplication</code> .  It is created as a singleton object by the <code>UIApplicationMain</code> function when the application is started and is available at runtime via the <code>sharedApplication</code> class <code>sharedApplication</code> . <br><br>  The <code>UIApplication</code> object performs many service tasks for the program, including initial routing of incoming user messages, as well as dispatching action messages for <code>UIControl</code> objects to the corresponding target objects.  It maintains a list of all open <code>UIWindow</code> objects.  The application object is associated with the <code>UIApplicationDelegate</code> application delegate object, which is informed of any significant events during the execution of the program, such as startup, low memory warnings, application termination, and background processes.  The event handlers allow the delegate to customize the behavior of the application. <br><br><h6>  Using the UIAccelerometer class </h6><br>  Another common singleton in the Cocoa Touch framework is the <code>UIAccelerometer</code> .  The <code>UIAccelerometer</code> class allows an application to subscribe to receive acceleration-related data from the onboard accelerometer in an iOS device.  An application can use data on changes in linear acceleration along the main axes in three-dimensional space to determine both the current orientation of the device and instantaneous changes in orientation. <br>  The <code>UIAccelerometer</code> class is a singleton, so you cannot create its objects explicitly.  To access its single instance, you need to call the class method <code>sharedAccelerometer</code> .  In addition, you can set its <code>updateInterval</code> property and <code>delegate</code> property to your own delegate object to receive any reported acceleration data from a singleton instance. <br><br><h6>  Using the NSFileManager class </h6><br>  The <code>NSFileManager</code> class was once a ‚Äústrict‚Äù implementation of the Singleton pattern in front of Mac OS X 10.5 and in iOS 2.0.  Calling his <code>init</code> method does nothing, and its only instance can be created and accessed only through the <code>defaultManager</code> class <code>defaultManager</code> .  However, since the singleton implementation is not thread-safe, new <code>NSFileManager</code> instances must be created to ensure this security.  This approach is viewed as a more flexible implementation of the Singleton, in which the factory method always returns the same instance, but additional instances can also be selected and initialized. <br><br>  If you need to implement a "strict" singleton, you need an implementation similar to the example described in the previous sections.  Otherwise, do not override <code>allocWithZone:</code> and other related methods. <br><br><h5>  findings </h5><br>  The Singleton pattern is one of the most widely used patterns in almost any type of application, and not just for iOS. <br>  Singleton can be useful when a centralized class is required to coordinate application services. <br>  This chapter marks the end of this section on creating objects.  In the next part, we will see some design patterns that focus on the adaptation / consolidation of objects with different interfaces. </habracut></div><p>Source: <a href="https://habr.com/ru/post/198470/">https://habr.com/ru/post/198470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198454/index.html">Gadgets Inspired by Doctor Who</a></li>
<li><a href="../198456/index.html">Multifunctional Robot for washing windows of skyscrapers</a></li>
<li><a href="../198458/index.html">Switch to Selenium 2 + PhantomJS</a></li>
<li><a href="../198464/index.html">Algorithm to find the smallest common ancestor in the tree</a></li>
<li><a href="../198468/index.html">Setting up and using Geany with Python</a></li>
<li><a href="../198472/index.html">How I was a perfect customer</a></li>
<li><a href="../198474/index.html">Rosstat promises to open, but not for free</a></li>
<li><a href="../198478/index.html">Django Dash 2013 ended</a></li>
<li><a href="../198480/index.html">How I blackmailed the trading of game currencies</a></li>
<li><a href="../198482/index.html">Top Ten Console Commands</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>