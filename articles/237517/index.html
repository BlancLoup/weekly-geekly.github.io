<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 18: Deploying on Heroku Cloud</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the eighteenth article in the series, where I describe my experience of writing a Python web application using the Flask mic framework. 

 The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 18: Deploying on Heroku Cloud</h1><div class="post__text post__text-html js-mediator-article">  This is the eighteenth article in the series, where I describe my experience of writing a <a href="http://python.org/">Python</a> web application using the <a href="http://flask.pocoo.org/">Flask</a> mic framework. <br><br>  The purpose of this guide is to develop a fairly functional microblogging application, which I decided to call microblog due to the complete lack of originality. <br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/193242/">Part 1: Hello, World!</a> <br>  <a href="http://habrahabr.ru/post/193260/">Part 2: Templates</a> <br>  <a href="http://habrahabr.ru/post/194062/">Part 3: Forms</a> <br>  <a href="http://habrahabr.ru/post/196810/">Part 4: Database</a> <br>  <a href="http://habrahabr.ru/post/222983/">Part 5: User Login</a> <br>  <a href="http://habrahabr.ru/post/223375/">Part 6: Profile Page and Avatars</a> <br>  <a href="http://habrahabr.ru/post/223783/">Part 7: Unit Testing</a> <br>  <a href="http://habrahabr.ru/post/230643/">Part 8: Subscribers, Contacts and Friends</a> <br>  <a href="http://habrahabr.ru/post/230897/">Part 9: Pagination</a> <br>  <a href="http://habrahabr.ru/post/234613/">Part 10: Full Text Search</a> <br>  <a href="http://habrahabr.ru/post/234737/">Part 11: Email Support</a> <br>  <a href="http://habrahabr.ru/post/234785/">Part 12: Reconstruction</a> <br>  <a href="http://habrahabr.ru/post/236753/">Part 13: Date and Time</a> <br>  <a href="http://habrahabr.ru/post/236861/">Part 14: I18n and L10n</a> <br>  <a href="http://habrahabr.ru/post/237065/">Part 15: Ajax</a> <br>  <a href="http://habrahabr.ru/post/237317/">Part 16: Debugging, Testing, and Profiling</a> <br>  <a href="http://habrahabr.ru/post/237489/">Part 17: Deploying to Linux (and even to Raspberry Pi!)</a> <br>  <a href="http://habrahabr.ru/post/237517/">Part 18: Deploying to Heroku Cloud (this article)</a> <br></div></div><br><a name="habracut"></a><br>  In the previous article, we looked at the traditional hosting option.  We saw two topical examples of hosting on Linux servers, first on a regular server running CentOS, and then on the Raspberry Pi minicomputer.  Those readers who did not administer Linux systems earlier may have decided that this requires too much effort and could be implemented somehow easier. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today, we‚Äôll see if deploying to the cloud is a solution to the complexity of the process. <br><br>  But what does it mean to "deploy to the cloud"? <br><br>  Cloud hosting providers offer a platform on which our application can run.  All that is required of the developer is to provide the application, and everything else, including server hardware, the operating system, the language interpreter, and the database, assumes the service. <br><br>  Sounds too good to be true, right? <br><br>  We will look at deploying the application on the <a href="http://heroku.com/">Heroku</a> platform, one of the most popular cloud hosting platforms.  I chose Heroku not only because of its popularity, but also because it provides a free level of service, so we will deploy our application without spending a single cent.  If you want to know more about this type of service, and what other providers offer, you can familiarize yourself with the <a href="https://ru.wikipedia.org/wiki/Platform_as_a_service">PaaS</a> Wikipedia page. <br><br><h3>  <b>Hosting on Heroku</b> </h3><br>  Heroku was one of the first platforms to provide PaaS services.  At the beginning, she offered hosting services only to Ruby applications, but later support was provided for many other languages ‚Äã‚Äãsuch as Java, Node.js and our favorite, Python. <br><br>  In fact, to deploy an application to Heroku, you only need to download the application using git (you will see how it works very soon).  Heroku searches for the Procfile file in the root folder of the application for instructions on how the application should be executed.  For Python projects, Heroku also expects to see the requirements.txt file containing a list of required third-party packages. <br><br>  After downloading the application, we can assume that it is done.  Heroku will apply its magic and the application will be available online in seconds.  The amount of the invoice at the end of the period directly depends on the computing power consumed by your application, therefore the more users your application has, the more you will have to pay. <br><br>  Ready to try out Heroku?  Let's start! <br><br><h4>  <i>Create Heroku account</i> </h4><br>  Before placing the application on Heroku, you need to register there.  Therefore, click on the <a href="https://id.heroku.com/signup">link</a> and create an account. <br><br>  After logging in, you will be taken to the control panel, from where you will be able to manage all your applications.  We will not use the control panel extensively, but it does provide a good overview of your account. <br><br><h4>  <i>Installing Heroku Client</i> </h4><br>  Despite the fact that some tasks can be performed directly from the web interface, there are tasks that can be solved only from the terminal, so we will do everything in the console. <br><br>  Heroku offers the Heroku Client utility, which we will use to create and manage our application.  This utility can be run under Windows, Mac OS X and Linux.  If the <a href="https://toolbelt.heroku.com/">Heroku toolkit</a> is available for your platform, then this is the easiest way to install the Heroku client. <br><br>  The first thing we will do with the client is to log in to our account: <br><br><pre><code class="bash hljs">$ heroku login</code> </pre> <br>  Heroku will ask you for an email and password for your account.  At the first authorization, the client will send your ssh key to the Heroku server. <br><br>  Subsequent commands can be executed without authorization. <br><br><h4>  <i>Git Setup</i> </h4><br>  git is the basis for deploying applications on Heroku, so it should also be installed.  If you installed the Heroku toolkit, then git is already installed. <br><br>  To deploy an application to Heroku, it must be present in the local repository, so run the following commands in the console: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/miguelgrinberg/microblog.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> microblog</code> </pre><br><h4>  <i>Creating Heroku App</i> </h4><br>  To create a new Heroku application, just call the create command from the root folder of the application: <br><br><pre> <code class="bash hljs">$ heroku create flask-microblog Creating flask-microblog... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>, stack is cedar http://flask-microblog.herokuapp.com/ | git@heroku.com:flask-microblog.git</code> </pre><br>  In addition to setting URLs, this command adds a remote repository ( <a href="http://git-scm.com/book/ru/%25D0%2592%25D0%25B5%25D1%2582%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B2-Git-%25D0%25A3%25D0%25B4%25D0%25B0%25D0%25BB%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B5-%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BA%25D0%25B8">git remote</a> ) to our repository, which we will soon use to upload application code to the cloud. <br><br>  Naturally, the name flask-microblog is now taken by me, so think of some other name for your application. <br><br><h4>  <i>Exclude local file storage</i> </h4><br>  Some functions of our application save information in the form of files on a disk. <br><br>  And here we are faced with a difficult task.  Applications running on Heroku are not available to permanently store files on the disk, because Heroku uses a virtualization platform that does not remember the data as files, the file system is cleared of all files, except the application files, each time the instance is started.  Strictly speaking, the application can store temporary files on disk, but should be able to recover these files if they disappear.  In addition, if two instances are running, each of them uses its own virtual file system and there is no possibility to share files between them. <br><br>  This is really bad news for us.  For starters, this means that we will not be able to use sqlite as a database. <br><br>  Our full-text search database Whoosh also stops working, because it stores its data in the form of files. <br><br>  The third problem point is our logging system.  We saved our log in the / tmp folder and now, when working on Heroku, this will also stop working. <br><br>  So, we identified 3 main problems for which we need to look for solutions. <br><br>  We will solve the first problem by migrating to the database offered by Heroku, which is based on <a href="http://www.postgresql.org/">PostgreSQL</a> . <br><br>  For the functioning of full-text search, we do not have a ready-made alternative available.  We will have to implement full-text search using PostgreSQL functionality, but this will require changes to our application.  Certainly a pity, but the solution to this problem would now lead us far away from the topic of the article, therefore, for placement on Heroku, we will simply disable full-text search. <br><br>  And finally, since we cannot write our logs, we will add our logs to the logging system used by Heroku, which, by the way, is very easy to use, because it sends to the log everything that is output to stdout. <br><br><h4>  <i>Creating Heroku Database</i> </h4><br>  To create the database, we use the Heroku client: <br><br><pre> <code class="bash hljs">$ heroku addons:add heroku-postgresql:dev Adding heroku-postgresql:dev on flask-microblog... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>, v3 (free) Attached as HEROKU_POSTGRESQL_ORANGE_URL Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pgbackups:restore. Use `heroku addons:docs heroku-postgresql:dev` to view documentation.</code> </pre><br>  Note that we use the development database, as this is the only free option.  For a combat server, you will need to select another database option. <br><br>  And how does our application know the database connection settings?  Heroku puts the database URI in the $ DATABASE_URL environment variable.  If you remember, we made changes to our configuration file in the last article, including  the value of this variable will be used to connect to the database, as required. <br><br><h4>  <i>Prohibition of full-text search</i> </h4><br>  To disable full-text search, our application must be able to determine whether it is running on Heroku or not.  To do this, we will create a custom environment variable, again using the Heroku client: <br><br><pre> <code class="bash hljs">heroku config:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> HEROKU=1</code> </pre><br>  Now the HEROKU environment variable will be set to 1 when our application is running on the Heroku virtual platform. <br><br>  Now disable full-text search is quite simple.  First, let's add a variable to the configuration file (config.py file): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Whoosh does not work on Heroku WHOOSH_ENABLED = os.environ.get('HEROKU') is None</span></span></code> </pre><br>  Then, cancel the creation of the full-text search database (file app / models.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WHOOSH_ENABLED <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WHOOSH_ENABLED: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> flask.ext.whooshalchemy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> whooshalchemy whooshalchemy.whoosh_index(app, Post)</code> </pre><br>  Also add information about the full-text search in g in our before_request handler so that our templates can see it (file app / views.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WHOOSH_ENABLED @app.before_request <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">before_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> g.user = current_user <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> g.user.is_authenticated(): g.user.last_seen = datetime.utcnow() db.session.add(g.user) db.session.commit() g.search_form = SearchForm() g.locale = get_locale() g.search_enabled = WHOOSH_ENABLED</code> </pre><br>  And finally, we remove the search field in the base template (file app / templates / base.html): <br><br><pre> <code class="html hljs xml"> {% if g.user.is_authenticated() and g.search_enabled %} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"navbar-search pull-right"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{url_for('search')}}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"search"</span></span></span><span class="hljs-tag">&gt;</span></span>{{g.search_form.hidden_tag()}}{{g.search_form.search(size=20,placeholder=_('Search'),class="search-query")}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> {% endif %}</code> </pre><br><br><h4>  <i>We correct logging</i> </h4><br>  Under the control of Heroku, everything that is output to the stdout stream immediately gets into the Heroku application log.  But logs that are written to files on disk will be inaccessible.  So on this platform we need to disable logging to files and use instead a logger who writes errors directly to stdout (file app / __ init__.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> app.debug <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> os.environ.get(<span class="hljs-string"><span class="hljs-string">'HEROKU'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> logging.handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RotatingFileHandler file_handler = RotatingFileHandler(<span class="hljs-string"><span class="hljs-string">'tmp/microblog.log'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) file_handler.setLevel(logging.INFO) file_handler.setFormatter(logging.Formatter(<span class="hljs-string"><span class="hljs-string">'%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'</span></span>)) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info(<span class="hljs-string"><span class="hljs-string">'microblog startup'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.environ.get(<span class="hljs-string"><span class="hljs-string">'HEROKU'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging stream_handler = logging.StreamHandler() app.logger.addHandler(stream_handler) app.logger.setLevel(logging.INFO) app.logger.info(<span class="hljs-string"><span class="hljs-string">'microblog startup'</span></span>)</code> </pre><br><h4>  <i>Web server</i> </h4><br>  Heroku does not provide its web server.  Instead, it expects the application to launch its own server on the port, the number of which will be received from the $ PORT environment variable. <br><br>  We know that the Flask development server is not suitable for production, since it is single-process and single-threaded, so we need a better solution.  The Heroku <a href="http://gunicorn.org/">tutorial</a> for Python applications recommends <a href="http://gunicorn.org/">gunicorn</a> , which we will apply. <br><br>  In our local environment, gunicorn is installed as a regular python module: <br><br><pre> <code class="bash hljs">$ flask/bin/pip install gunicorn</code> </pre><br>  To start it, we need to pass one argument, the name of the Python module that defines the application and the application object itself, separated by a colon. <br><br>  Let's create a separate Python module for Heroku (file runp-heroku.py): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python from app import app</span></span></code> </pre><br>  Now, for example, if we want to start the gunicorn server locally, using this module, we need to execute the following command: <br><br><pre> <code class="bash hljs">$ flask/bin/gunicorn runp-heroku:app 2013-04-24 08:42:34 [31296] [INFO] Starting gunicorn 0.17.2 2013-04-24 08:42:34 [31296] [INFO] Listening at: http://127.0.0.1:8000 (31296) 2013-04-24 08:42:34 [31296] [INFO] Using worker: sync 2013-04-24 08:42:34 [31301] [INFO] Booting worker with pid: 31301</code> </pre><br><h4>  <i>File requirements.txt</i> </h4><br>  Very soon we will upload our application to Heroku, but first we need to tell the server which modules our application needs to run.  On our local PC, we managed dependencies using a virtual environment, installing modules into it using pip. <br><br>  Heroku does the same.  If the requirements.txt file is found in the root folder of the application, then Heroku installs all the modules listed in it using pip. <br><br>  To create the requirements.txt file, we must use the freeze option when calling pip: <br><br><pre> <code class="bash hljs">$ flask/bin/pip freeze &gt; requirements.txt</code> </pre><br>  The gunicorn server must be added to the list, as well as the psycopg2 driver, which SQLAlchemy requires to connect to the PostgreSQL database.  The final form of the requirements.txt file will be as follows: <br><br><pre> <code class="bash hljs">Babel==0.9.6 Flask==0.9 Flask-Babel==0.8 Flask-Login==0.1.3 Flask-Mail==0.8.2 Flask-OpenID==1.1.1 Flask-SQLAlchemy==0.16 Flask-WTF==0.8.3 git+git://github.com/miguelgrinberg/Flask-WhooshAlchemy Jinja2==2.6 MySQL-python==1.2.4 psycopg2==2.5 SQLAlchemy==0.7.9 Tempita==0.5.1 WTForms==1.0.3 Werkzeug==0.8.3 Whoosh==2.4.1 blinker==1.2 coverage==3.6 decorator==3.4.0 flup==1.0.3.dev-20110405 guess-language==0.2 gunicorn==0.17.2 python-openid==2.2.5 pytz==2013b speaklater==1.3 sqlalchemy-migrate==0.7.2</code> </pre><br>  Some of these packages will be unclaimed with the version of our application designed for Heroku, but there is nothing terrible in the presence of unused packages in the system.  And it seems to me that it is still better to have a complete list of required packages. <br><br><h4>  <i>Procfile</i> </h4><br>  The last requirement is to tell Heroku how to start the application.  This Heroku requires a Procfile file in the root folder of the application. <br><br>  This file is quite simple; it simply defines the names of the processes and the commands associated with them (the Procfile file): <br><br><pre> <code class="python hljs">web: gunicorn runp-heroku:app init: python db_create.py &amp;&amp; pybabel compile -d app/translations upgrade: python db_upgrade.py &amp;&amp; pybabel compile -d app/translations</code> </pre><br>  The web tag is associated with the web server.  Heroku requires this task to run our application. <br><br>  The other two tasks, called init and upgrade, are user tasks that we will use to work with our application.  The init task initializes our application by creating a database and compiling language files.  The upgrade task is similar to init, but instead of creating a database, it updates the database to the latest migration. <br><br><h4>  <i>Deploying the application</i> </h4><br>  Now we will proceed to the most interesting part in which we will place the application in our Heroku account.  It's pretty simple, we just use git to send the application: <br><br><pre> <code class="bash hljs">$ git push heroku master Counting objects: 307, <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Delta compression using up to 4 threads. Compressing objects: 100% (168/168), <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Writing objects: 100% (307/307), 165.57 KiB, <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Total 307 (delta 142), reused 272 (delta 122) -----&gt; Python app detected -----&gt; No runtime.txt provided; assuming python-2.7.4. -----&gt; Preparing Python runtime (python-2.7.4) -----&gt; Installing Distribute (0.6.36) -----&gt; Installing Pip (1.3.1) -----&gt; Installing dependencies using Pip (1.3.1) ... -----&gt; Discovering process types Procfile declares types -&gt; init, upgrade, web -----&gt; Compiled slug size: 29.6MB -----&gt; Launching... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>, v6 http://flask-microblog.herokuapp.com deployed to Heroku To git@heroku.com:flask-microblog.git * [new branch] master -&gt; master</code> </pre><br>  The heroku tag we use in our git push command was automatically registered in our git repository when we created our application using heroku create.  To see how this remote repository is configured, you can run git remote -v in the application folder. <br><br>  When we initially loaded the application on Heroku, we need to initialize the database and translation files, and for this we need to complete the task init, which we included in our Procfile: <br><br><pre> <code class="bash hljs">$ heroku run init Running `init` attached to terminal... up, run.7671 /app/.heroku/python/lib/python2.7/site-packages/sqlalchemy/engine/url.py:105: SADeprecationWarning: The SQLAlchemy PostgreSQL dialect has been renamed from <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> to <span class="hljs-string"><span class="hljs-string">'postgresql'</span></span>. The new URL format is postgresql[+driver]://&lt;user&gt;:&lt;pass&gt;@&lt;host&gt;/&lt;dbname&gt; module = __import__(<span class="hljs-string"><span class="hljs-string">'sqlalchemy.dialects.%s'</span></span> % (dialect, )).dialects compiling catalog <span class="hljs-string"><span class="hljs-string">'app/translations/es/LC_MESSAGES/messages.po'</span></span> to <span class="hljs-string"><span class="hljs-string">'app/translations/es/LC_MESSAGES/messages.mo'</span></span></code> </pre><br>  The warning belongs to SQLAlchemy, because it does not like URIs that begin with postgres: // instead of postgresql: //.  This URI forms Heroku through the value of the $ DATABASE_URL environment variable, so it is not in our power to change this.  It remains to hope that this URI format will work for a long time. <br><br>  Believe it or not, our application is already available online.  In my case, the application is available at <a href="http://flask-microblog.herokuapp.com/">flask-microblog.herokuapp.com</a> .  You can easily become my follower from <a href="http://flask-microblog.herokuapp.com/user/miguel.grinberg">my profile</a> page.  I do not know exactly how long the application will be available at this address, but nothing prevents you from checking whether it is available or not! <br><br><h4>  <i>App update</i> </h4><br>  Sooner or later, the time will come to update our application.  This will be similar to the initial deployment.  First of all, the application will be uploaded to the server using git: <br><br><pre> <code class="bash hljs">$ git push heroku master</code> </pre><br><br>  Then, the update script is executed: <br><br><pre> <code class="bash hljs">$ heroku run upgrade</code> </pre><br><br><h4>  <i>Logging</i> </h4><br>  If something abnormal happens to the application, it may be useful to examine the logs.  Remember that for Heroku version of the application, we write all the logs in stdout, and Heroku collects them into its own log. <br><br>  To view the logs, use the Heroku client: <br><br><pre> <code class="bash hljs">$ heroku logs</code> </pre><br>  The above command will output all logs, including the Heroku logs.  To view the logs of your application only, run the command: <br><br><pre> <code class="bash hljs">$ heroku logs --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> app</code> </pre><br>  Things like call stack and other application errors will all be in this log. <br><br><h3>  Is it worth it? </h3><br>  Now we have an idea of ‚Äã‚Äãapplication deployment to a cloud platform, and therefore we can compare this type of hosting with a traditional hosting option. <br><br>  In the matter of simplicity, victory over the clouds.  At least for Heroku, the application deployment process was very simple.  When deploying to a dedicated server or VPS, a lot of preparatory work was needed.  Heroku takes care of it and allows us to focus on our application. <br><br>  The cost issue is a controversial point.  The cost of cloud hosting services is usually more expensive than dedicated servers, because you pay not only for the server, but also for the administration services.  A typical Heroku tariff plan, which includes two instances and the cheapest production database, will cost $ 85 (this is at the time of this writing. <i>About a year ago - approx. Lane</i> ).  On the other hand, if you do a good search, you can easily find a decent VPS for about $ 40 per year. <br><br>  In the end, it seems to me, the question of choice will be reduced to the choice of what is more important for you: time or money. <br><br><h3>  The end? </h3><br>  The updated application is available, as always, on <a href="">github</a> .  Or you can download it as a zip archive by the link: <br><br>  Download <a href="">microblog 0.18</a> . <br><br>  With the deployment of our application in all possible ways, it seems that our excursion comes to an end. <br><br>  I hope these articles were a useful introduction to the development of a real web application, and that the knowledge base that I threw on you for these 18 articles motivates you to create your own project. <br><br>  However, I do not put an end, and do not deny the likelihood of articles on the microblog.  If, and when, an interesting topic comes to mind, I will write more, but I expect that the frequency of updates will now somewhat subside.  From time to time, I can make some minor fixes in the application that do not deserve a separate article in the blog, so you can <a href="https://github.com/miguelgrinberg/microblog">track</a> these changes <a href="https://github.com/miguelgrinberg/microblog">on GitHub</a> . <br><br>  In my blog, I will continue to write articles related to web development and software in general, t.ch.  I invite you to follow me on <a href="https://twitter.com/miguelgrinberg">Twitter</a> or <a href="https://www.facebook.com/miguelgrinbergblog">Facebook</a> if you have not already done so, and in this way you will be notified of my future articles. <br><br>  Thank you, once again, for being a loyal reader. <br><br>  Miguel </div><p>Source: <a href="https://habr.com/ru/post/237517/">https://habr.com/ru/post/237517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237503/index.html">Using Lua c C ++ is easier than you think. Tutorial by LuaBridge</a></li>
<li><a href="../237507/index.html">Guide to creating startups, part 1: why not start up a startup</a></li>
<li><a href="../237509/index.html">Useful books for the programmer in game dev</a></li>
<li><a href="../23751/index.html">Search Engine Editor - SearchEdit</a></li>
<li><a href="../237511/index.html">How to become managers: 4 career stories with analysis and conclusions</a></li>
<li><a href="../237519/index.html">iPhone 6 Plus is ours! Disassemble to the bottom of the largest Apple smartphone, comparing with the iPhone 6 and 5S</a></li>
<li><a href="../23752/index.html">Need help Russian open source project TraffPro.</a></li>
<li><a href="../237523/index.html">Virtualization¬π</a></li>
<li><a href="../237525/index.html">Xiaomi Mi Band Review</a></li>
<li><a href="../237529/index.html">Organized freelance. Part 3. Product</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>