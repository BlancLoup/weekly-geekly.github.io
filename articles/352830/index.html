<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part XVIII: Deploying to Heroku</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(edition 2018) 
 Miguel grinberg 



 There 


 This is the eighteenth part of a series of Flask Mega-textbooks, in which I am going to deploy a micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part XVIII: Deploying to Heroku</h1><div class="post__text post__text-html js-mediator-article"><h2 id="izdanie-2018">  (edition 2018) </h2><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/352266/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This is the eighteenth part of a series of Flask Mega-textbooks, in which I am going to deploy a microblog on the Heroku cloud platform. </p><a name="habracut"></a><br><p>  Under the spoiler is a list of all articles in this 2018 series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/topic/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> (This article) </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  Chapter 21: User Notifications (Available April 24, 2018) </li><li>  Chapter 22: Reference Tasks (Available May 1, 2018) </li><li>  Chapter 23: Application Programming Interfaces (APIs) (Available May 8, 2018) </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work, or simply do not have the patience to wait for the article for a week, I (Miguel Greenberg) offer the full version of this manual (in English) in the form of an electronic book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  In the previous article, I showed you the ‚Äútraditional‚Äù way of hosting a Python application, and presented you with two real examples of deployments on Linux servers.  If you are not on the "TYU" system with Linux, then you probably thought that the amount of effort spent on such a deployment was slightly more than expected, and certainly there should be an easier way. </p><br><p>  In this chapter, I‚Äôll show you a completely different approach in which you rely on a third-party cloud hosting provider to perform most administrative tasks, which allows you to spend more time working on the application itself. </p><br><p>  Many cloud hosting providers offer a managed platform on which to run web applications.  All you need to provide for your application to be deployed on these platforms is the actual application, because the hardware, operating system, scripting language interpreters, database, etc.  managed by the service.  This type of service is called <a href="https://en.wikipedia.org/wiki/Platform_as_a_service">Platform as a Service</a> or PaaS. </p><br><p>  Sounds too good to be true, right? </p><br><p>  I will deploy Microblog to <a href="http://heroku.com/">Heroku</a> , a popular cloud service that is also very convenient for Python applications.  I chose Heroku not only because it is popular, but also because it has a free level of service that will allow you to follow me and complete the deployment without spending any money. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="hosting-na-heroku">  Hosting on Heroku </h2><br><p>  Heroku, one of the first cloud platforms, appeared in June 2007 and initially supported only the Ruby programming language, but currently the list of supported languages ‚Äã‚Äãalso includes Java, Node.js, Scala, Clojure, Go, PHP and of course Python. </p><br><p> Deploying a web application to Heroku is done using the <code>git</code> version control tool, so the application must reside in the git repository.  Heroku searches for a file called <em>Procfile</em> in the root directory of the application for instructions on how to start the application.  For Python projects, Heroku will need a file <em>requirements.txt</em> file with a list of all module dependencies that need to be installed.  After the application is uploaded to Heroku servers via git, you basically did everything, and you just need to wait a few seconds for the application to appear on the network.  It's really that simple. </p><br><p>  Heroku offers you to choose the level of service based on the required computing power and time required for your application, as your user base grows you will need to buy more computing units, which Heroku calls "dynos". </p><br><p>  Ready to try Heroku?  Let's start! </p><br><h2 id="sozdanie-uchetnoy-zapisi-heroku">  Create a Heroku account </h2><br><p>  Before you can complete a deployment in Heroku, you need to get an account.  So visit <a href="https://id.heroku.com/signup">heroku.com</a> and create a free account.  After you register and log in to Heroku, you will have access to a dashboard where all your applications will be listed. </p><br><h2 id="ustanovka-heroku-cli">  Installing Heroku CLI </h2><br><p>  Heroku provides a command line for interacting with a service called <a href="https://devcenter.heroku.com/articles/heroku-cli">Heroku CLI</a> , available for Windows, Mac OS X and Linux.  The documentation contains installation instructions for all supported platforms.  Install it on your system if you plan to deploy an application to test the service. </p><br><p>  The first thing you need to do after installing the CLI is to log into your Heroku account: </p><br><pre> <code class="hljs pgsql">$ heroku <span class="hljs-keyword"><span class="hljs-keyword">login</span></span></code> </pre> <br><p>  Heroku CLI will ask you to enter your email address and account password.  Your authenticated status will be saved in subsequent commands. </p><br><h2 id="nastroyka-git">  Git setup </h2><br><p>  The <code>git</code> tool is the basis for deploying applications to Heroku, so you should install it on your system if you do not already have it.  If you do not have a package available for your operating system, you can visit <a href="https://git-scm.com/">the git website</a> to download the installer. </p><br><p>  There are many reasons to use <code>git</code> for your projects.  If you are planning to deploy to Heroku, then you have another one, because to deploy to Heroku, your application must be in the <code>git</code> repository.  If you are going to do a test deployment for Microblog, you can clone the application from GitHub: </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git clone https://github.com/miguelgrinberg/microblog <span class="hljs-string"><span class="hljs-string">$ </span></span>cd microblog <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout v0<span class="hljs-number"><span class="hljs-number">.18</span></span></code> </pre> <br><p>  The <code>git checkout</code> command selects a specific fixation point for an application in its history corresponding to this chapter. </p><br><p>  If you prefer to work with your own code, rather than mine, you can convert your own project to the <code>git</code> repository by running <code>git init .</code>  in the top level directory (note the point after <code>init</code> , which is the instruction for git that you want to create a repository in the current directory). </p><br><h2 id="sozdanie-prilozheniya-heroku">  Creating Heroku app </h2><br><p>  To register a new application in Heroku, use the <code>apps:create</code> command from the root directory, passing the name of the application as the only argument: </p><br><pre> <code class="hljs sql">$ heroku apps:<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> flask-microblog Creating flask-microblog... done <span class="hljs-keyword"><span class="hljs-keyword">http</span></span>://flask-microblog.herokuapp.com/ | https://git.heroku.com/flask-microblog.git</code> </pre> <br><p>  Heroku requires applications to have a unique name.  The <code>flask-microblog</code> name I used above will not be available to you, because I already use it, so you will need to choose another one for your deployment. </p><br><p>  At the output of this command, we get the URL that Heroku assigned to the application, as well as its git repository.  Your local git repository will already have an external connection setting ( <em>remote</em> ), called <code>heroku</code> .  You can verify that it exists with the <code>git remote</code> command: </p><br><pre> <code class="hljs ruby">$ git remote -v heroku <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/git.heroku.com/flask</span></span>-microblog.git (fetch) heroku <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/git.heroku.com/flask</span></span>-microblog.git (push)</code> </pre> <br><p>  Depending on how you created your git repository, the output of the above command may also include another remote source named <code>origin</code> . </p><br><h2 id="efemernaya-faylovaya-sistema">  Ephemeral file system </h2><br><p>  The Heroku platform is different from other deployment platforms in that it implements an <em>ephemeral</em> file system running on a virtual platform.  What does it mean?  This means that at any time Heroku may reset the virtual server, which will result in your server returning to a clean state.  It cannot be assumed that any data that you save in the file system will be saved, and in fact, Heroku very often recycles servers. </p><br><p>  Working under these conditions creates some problems for my application, which uses several files: </p><br><ul><li>  The SQLite database engine component by default writes data to a file on disk. </li><li>  Application logs are written to the file system. </li><li>  Compiled language translation stores are also stored in local files. </li></ul><br><p>  The following sections will address these three areas. </p><br><h2 id="rabota-s-bazoy-dannyh-heroku-postgres">  Working with the Heroku Postgres database </h2><br><p>  To solve the first problem, I will switch to a different database engine.  In <a href="https://habrahabr.ru/post/352266/">Chapter 17,</a> you saw how I use a MySQL database to increase the reliability of Ubuntu deployments.  Heroku has its own database suggestion based on Postgres, so I'm going to switch to it to avoid file-based SQLite storage problems. </p><br><p>  Databases for Heroku applications are supplied with the same CLI Heroku.  In this case, I'm going to create a database at the free (free) level: </p><br><pre> <code class="hljs vhdl">$ heroku addons:add heroku-postgresql:hobby-dev Creating heroku-postgresql:hobby-dev <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flask-microblog... free Database has been created <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> available ! This database <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> empty. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> upgrading, you can transfer ! data from another database <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> pg:copy Created postgresql-parallel-<span class="hljs-number"><span class="hljs-number">56076</span></span> as DATABASE_URL <span class="hljs-keyword"><span class="hljs-keyword">Use</span></span> heroku addons:docs heroku-postgresql <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> documentation</code> </pre> <br><p>  The URL of the newly created database is stored in the environment variable <code>DATABASE_UR</code> L, which will be available when the application starts.  This is very convenient, because the application is already looking for the database URL in this variable. </p><br><h2 id="vedenie-zhurnala-v-stdout">  Logging to stdout </h2><br><p>  Heroku expects applications to do input / output directly to <code>stdout</code> .  Everything that the application prints in the standard output is saved and returned when using the <code>heroku logs</code> command.  So I'm going to add a configuration variable that indicates whether I need to keep records in <code>stdout</code> or in a file, as I did before.  Here is the configuration change: </p><br><blockquote>  <em>config.py</em> : Logging option to stdout. </blockquote><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>): # ... LOG_TO_STDOUT = os.environ.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'LOG_TO_STDOUT'</span></span>)</code> </pre> <br><p>  Then, in the application factory function, I can check this configuration to understand how to configure the application logger: </p><br><blockquote>  <em><code>app/__init__.py</code></em> : Log to stdout or to file. </blockquote><br><pre> <code class="hljs lua">def create_app(config_class=Config): # ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> app.testing: # ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>[<span class="hljs-string"><span class="hljs-string">'LOG_TO_STDOUT'</span></span>]: stream_handler = logging.StreamHandler() stream_handler.setLevel(logging.INFO) app.logger.addHandler(stream_handler) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.exists(<span class="hljs-string"><span class="hljs-string">'logs'</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.mkdir(<span class="hljs-string"><span class="hljs-string">'logs'</span></span>) file_handler = RotatingFileHandler(<span class="hljs-string"><span class="hljs-string">'logs/microblog.log'</span></span>, maxBytes=<span class="hljs-number"><span class="hljs-number">10240</span></span>, backupCount=<span class="hljs-number"><span class="hljs-number">10</span></span>) file_handler.setFormatter(logging.Formatter( <span class="hljs-string"><span class="hljs-string">'%(asctime)s %(levelname)s: %(message)s '</span></span> <span class="hljs-string"><span class="hljs-string">'[in %(pathname)s:%(lineno)d]'</span></span>)) file_handler.setLevel(logging.INFO) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info(<span class="hljs-string"><span class="hljs-string">'Microblog startup'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app</code> </pre> <br><p>  So now I need to define the environment variable <code>LOG_TO_STDOUT</code> if the application is running in Heroku, but not in other configurations.  Heroku CLI makes this easy because it provides the ability to set environment variables to be used at runtime: </p><br><pre> <code class="hljs sql">$ heroku config:<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> LOG_TO_STDOUT=<span class="hljs-number"><span class="hljs-number">1</span></span> Setting LOG_TO_STDOUT <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> restarting flask-microblog... done, v4 LOG_TO_STDOUT: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2 id="skompilirovannye-perevody">  Compiled translations </h2><br><p>  The third aspect of microblog based on local files is compiled language translation of files.  The easiest option to ensure that these files never disappear from the ephemeral file system is to add the compiled language files to the Git repository so that they become part of the initial state of the application after it is deployed to Heroku. </p><br><p>  A more elegant option, in my opinion, is to include the <code>flask translate compile</code> command on the start up command provided by Heroku, so that each time the server restarts, these files will be compiled again.  I'm going to go this route, since I know that my startup procedure will require more than one command anyway, since I still need to start the database migration.  So now I will put this problem aside and come back to it later when I write <em>Procfile</em> . </p><br><h2 id="hosting-elasticsearch">  Elasticsearch Hosting </h2><br><p>  Elasticsearch is one of many services that can be added to the Heroku project, but unlike Postgres, this is not a service provided by Heroku, but a third party who collaborates with Heroku to provide add-ons.  Today (when I write these lines) there are three different providers of the integrated elasticsearch service. </p><br><p>  Before setting up Elasticsearch, keep in mind that Heroku requires your account to have an associated credit card before installing any third-party add-on, even if you stay within their free levels.  If you prefer not to provide your Heroku credit card details, skip this section.  You can deploy the application, but the search function will not work. </p><br><p>  From the Elasticsearch options that are available as add-ons, I decided to try <a href="https://elements.heroku.com/addons/searchbox">SearchBox</a> , which comes with a free starting plan.  To add a SearchBox to your account, you must run the following command when logging in to Heroku: </p><br><pre> <code class="hljs pgsql">$ heroku addons:<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> searchbox:starter</code> </pre> <br><p>  This command will deploy the Elasticsearch service and place the connection URL for the service in the <code>SEARCHBOX_URL</code> environment variable associated with the application.  Let me remind you once again that this command will not be executed unless you add your credit card to your Heroku account. </p><br><p>  If you recall from <a href="https://habrahabr.ru/post/351900/">Chapter 16</a> , my application looks for the Elasticsearch connection URL in the ELASTICSEARCH_URL variable, so I need to add this variable and set it to the connection URL assigned by SearchBox: </p><br><pre> <code class="hljs swift">$ heroku config:<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-type"><span class="hljs-type">SEARCHBOX_URL</span></span> &lt;your-elasticsearch-url&gt; $ heroku config:<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-type"><span class="hljs-type">ELASTICSEARCH_URL</span></span>=&lt;your-elasticsearch-url&gt;</code> </pre> <br><p>  Here, I first asked Heroku to print the <code>SEARCHBOX_URL</code> value, and then I added a new environment variable named <code>ELASTICSEARCH_URL</code> set to the same value. </p><br><h2 id="obnovlenie-requirements">  Requirements update </h2><br><p>  Heroku expects the dependencies to be in the <em>requirements.txt</em> file, just as I defined in <a href="https://habrahabr.ru/post/351218/">Chapter 15</a> .  But to run the application on Heroku, I need to add two new dependencies to this file. </p><br><p>  Heroku does not provide its own web server.  Instead, he expects the application to start his own web server at the port number specified in the <code>$PORT</code> environment variable.  Since the Flask Web Server is not reliable enough for use in work, I‚Äôm going to use <a href="http://gunicorn.org/">gunicorn</a> again, a server recommended by Heroku for Python applications. </p><br><p>  The application will also connect to the Postgres database, and for this SQLAlchemy requires the installation of the <code>psycopg2</code> package. </p><br><p>  Both <code>gunicorn</code> and <code>psycopg2</code> need to be added to the <em>requirements.txt</em> file. </p><br><h2 id="profayl">  Profile </h2><br><p>  Heroku needs to know how to run the application, and for this it uses a file called <em>Procfile</em> in the root directory of the application.  The format of this file is simple, each line contains the process name, a colon, and then the command that starts the process.  The most common type of application that runs on Heroku is the web application, and for this type of application the process name must be <code>web</code> .  Below you can see the Procfile for Microblog: </p><br><blockquote>  Procfile: Heroku Procfile. </blockquote><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">web</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">flask</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">db</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">upgrade</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">flask</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">translate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">compile</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">gunicorn</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">microblog</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:app</span></span></code> </pre> <br><p>  Here I have defined a command to launch a web application as a sequence of three commands.  First, I launch the database migration update, then compile language translations and, finally, start the server. </p><br><p>  Since the first two subcommands are based on the <code>flask</code> command, I need to add the <code>FLASK_APP</code> environment <code>FLASK_APP</code> : </p><br><pre> <code class="hljs sql">$ heroku config:<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> FLASK_APP=microblog.py Setting FLASK_APP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> restarting flask-microblog... done, v4 FLASK_APP: microblog.py</code> </pre> <br><p>  The <code>gunicorn</code> team <code>gunicorn</code> simpler than what I used to deploy Ubuntu, because this server has very good integration with the Heroku environment.  For example, the <code>$PORT</code> environment variable is taken into account by default, and instead of using the <code>-w</code> option to specify the number of processes, heroku recommends adding the <code>WEB_CONCURRENCY</code> variable that <code>gunicorn</code> uses when <code>-w</code> not provided, which gives you the flexibility to manage the number of processes unnecessarily modify the procfile. </p><br><h2 id="razvertyvanie-prilozheniya">  Deploying the application </h2><br><p>  All the preparatory steps have been completed, so it's time to launch the deployment.  To download an application to Heroku servers for deployment, use the <code>git push</code> command.  This is similar to sending changes in the local git repository to GitHub or another remote git server. </p><br><p>  And now I have reached the most interesting part, where I send the application to my hosting account Heroku.  It's actually quite simple, I just have to use <code>git</code> to push the application to the main branch of the Heroku git repository.  There are several options for how to do this, depending on how you created your git repository.  If you use my code <code>v0.18</code> , then you need to create a branch based on this tag, and send it to the remote master branch, as follows: </p><br><pre> <code class="hljs ruby">$ git checkout -b deploy $ git push heroku <span class="hljs-symbol"><span class="hljs-symbol">deploy:</span></span>master</code> </pre> <br><p>  If you still work with your own repository, then your code is most likely already in the main branch, so you first need to make sure that your changes are fixed: </p><br><pre> <code class="hljs pgsql">$ git <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span> -a -m "heroku deployment changes"</code> </pre> <br><p>  Then you can start the deployment as follows: </p><br><pre> <code class="hljs perl">$ git <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> heroku master</code> </pre> <br><p>  Regardless of how you send a branch, you should see the following output from Heroku: </p><br><pre> <code class="hljs rust">$ git push heroku deploy:master Counting objects: <span class="hljs-number"><span class="hljs-number">247</span></span>, done. Delta compression using up to <span class="hljs-number"><span class="hljs-number">8</span></span> threads. Compressing objects: <span class="hljs-number"><span class="hljs-number">100</span></span>% (<span class="hljs-number"><span class="hljs-number">238</span></span>/<span class="hljs-number"><span class="hljs-number">238</span></span>), done. Writing objects: <span class="hljs-number"><span class="hljs-number">100</span></span>% (<span class="hljs-number"><span class="hljs-number">247</span></span>/<span class="hljs-number"><span class="hljs-number">247</span></span>), <span class="hljs-number"><span class="hljs-number">53.26</span></span> KiB | <span class="hljs-number"><span class="hljs-number">3.80</span></span> MiB/s, done. Total <span class="hljs-number"><span class="hljs-number">247</span></span> (delta <span class="hljs-number"><span class="hljs-number">136</span></span>), reused <span class="hljs-number"><span class="hljs-number">3</span></span> (delta <span class="hljs-number"><span class="hljs-number">0</span></span>) remote: Compressing source files... done. remote: Building source: remote: remote: -----&gt; Python app detected remote: -----&gt; Installing python-<span class="hljs-number"><span class="hljs-number">3.6</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> remote: -----&gt; Installing pip remote: -----&gt; Installing requirements with pip ... remote: remote: -----&gt; Discovering process types remote: Procfile declares types -&gt; web remote: remote: -----&gt; Compressing... remote: Done: <span class="hljs-number"><span class="hljs-number">57</span></span>M remote: -----&gt; Launching... remote: Released v5 remote: https:<span class="hljs-comment"><span class="hljs-comment">//flask-microblog.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. To https://git.heroku.com/flask-microblog.git * [new branch] deploy -&gt; master</span></span></code> </pre> <br><p>  The <code>heroku</code> label we used in the <code>git push</code> command is a remote repository that was automatically added by HEROKU CLI when creating the application.  The <code>deploy:master</code> argument means that I move the code from the local repository referenced by the <code>deploy</code> branch to the main branch of the <code>master</code> repository Heroku.  When you work with your own projects, you will probably push changes through the <code>git push heroku master</code> , which will push (push) your local <code>master</code> branch.  Because of how this project is structured, I send a branch that is not <code>master</code> , but the destination branch on the Heroku side must always be <code>master</code> , since this is the only branch that Heroku accepts for deployment. </p><br><p>  And now the application should be deployed to the URL specified in the output of the command that created the application.  In my case, the URL was <em><a href="https://flask-microblog.herokuapp.com/">https://flask-microblog.herokuapp.com</a></em> , so this is what I need to enter in order to access the application. </p><br><p>  If you want to see log entries for a running application, use the <code>heroku logs</code> command.  This can be useful if for some reason the application does not start.  If there were any errors, they will be in the logs. </p><br><h2 id="razvertyvanie-obnovleniy-prilozheniy">  Deploying Application Updates </h2><br><p>  To deploy a new version of the application, you just need to run the <code>git push</code> command with the new code.  This will repeat the deployment process, disable the old deployment, and replace it with new code.  The commands in Procfile will run again as part of the new deployment, so any new migrations or database transfers will be updated during the process. </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/352266/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352830/">https://habr.com/ru/post/352830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352820/index.html">Avito at GopherCon Russia 2018</a></li>
<li><a href="../352822/index.html">How to expand the functionality of Zabbix and not pay for licenses</a></li>
<li><a href="../352824/index.html">Data Center for Technopark: from ‚ÄúConcrete‚Äù to Tier Facility Certification</a></li>
<li><a href="../352826/index.html">We are preparing a project in Sparx Enterprise Architect. Our recipe</a></li>
<li><a href="../352828/index.html">JavaScript Web Workers: Secure Concurrency</a></li>
<li><a href="../352832/index.html">19 years in the same language. The story of how the Olympiad from Belarus became C ++ Chief Software Architect</a></li>
<li><a href="../352834/index.html">We are programmers</a></li>
<li><a href="../352836/index.html">Why the interface should be accessible to everyone and how to do it</a></li>
<li><a href="../352838/index.html">Your first mobile app: choose a platform</a></li>
<li><a href="../352840/index.html">News from Go, or what's new in GoLand 2018.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>