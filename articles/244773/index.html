<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Micro DB for configuration on microcontroller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many software developers for microcontrollers are faced with the problem of storing configuration data. These can be calibration coefficients of the m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Micro DB for configuration on microcontroller</h1><div class="post__text post__text-html js-mediator-article">  Many software developers for microcontrollers are faced with the problem of storing configuration data.  These can be calibration coefficients of the measurement algorithm or simply the last menu item selected by the user.  For a microcontroller with the ability to write to its own flash-memory, the solution seems simple - erase the segment and write everything you need there.  However, if it is also necessary to provide fault tolerance in relation to power off at an arbitrary moment, the task becomes nontrivial - in fact, it is necessary to implement a small database with a mechanism for ensuring the atomicity of write operations and recovery after failures.  The solution of this problem for microcontrollers of the MSP430 family is under the cut.  By the amount of resources used, it is suitable even for the youngest members of this family - with a RAM size of 256 bytes and falsh memory of 8Kb.  As a bonus, there is a command line interface (via UART) for reading and writing configurations. <br><a name="habracut"></a><br><h4>  Data format </h4><br>  We restrict ourselves to storing two-byte integers and strings with a length of no more than 15 characters, which is quite enough for most applications.  If desired, this set is easy to expand by minor code modifications.  Stored data will be identified by name and possibly one or two indexes.  We will also limit the maximum index to the 15th, while the integer parameters can have 2 indexes, but only one line - the second index will be taken by the length of the line. <br><br>  The first thing that comes to mind is to store the name first, then the data.  But in our case, this approach is categorically ineffective.  The fact is that we cannot simply rewrite old data.  We will have to write a new value to a new place and only then to figure out which of them is the most recent.  This means that we may have to write down the same name many times.  Therefore, we will store the names separately by entering a new entity - the type of configuration data.  Type is a name plus a description of what can be stored under this name.  Namely, the base type is an integer or a string, and the dimension of the indices is 0, 1 or 2 for integers, 0 or 1 for strings.  In addition, the default type will be stored in the type descriptor, which we will return when reading data that has not yet been written.  The type table will be placed in flash memory at compile time and will never change.  When saving data, we simply refer to the type, indicating its index in the table, for which we will need one byte.  In another byte, we will pack 2 indexes of an instance of this type, or an index and string length.  Then the actual data will be recorded. <br><br><h4>  Memory organization </h4><br>  Before you write something in flash-memory, it must be erased.  Erasing occurs in 512 byte segments.  This means that we will need at least 2 of these segments to store data. One will store data until we erase the second.  If there is a lot of data, take 2 working areas from N segments.  While one stores data, the second can be erased.  In general, the algorithm is as follows - we write data sequentially to the workspace, after the place finishes, we delete the nonworking region, save the latest versions of all the data from the workspace (snapshot), and then change the workspace.  In this case, we are left with the only problem - how then to choose the workspace that was recorded last? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Sequence numbers </h4><br>  The standard solution to finding the latest version of an object is to assign sequence numbers to versions.  It works well if these numbers are long enough so as not to be repeated throughout the entire life of the program.  In our case, it is difficult for us to afford numbers longer than 2 bytes.  This means that the actual numbers will be placed in a circle with a circle length of 65536. If our copies of the configuration data occupy less than half of such a circle, then they can be ordered according to the degree of freshness, and if there are more, then no longer.  This means that when copying data to snapshot, we are forced to update their sequence numbers.  But then, if the copy operation is interrupted in the middle, there will be complete confusion - part of the data will have more recent copies, and some will not, and we will not be able to simply select one of the two work areas.  But this is still half the trouble.  The most annoying thing is how the power is turned off at any time. <br><br><h4>  Checksums </h4><br>  To understand the scale of the disaster, the author wrote an automatic test that implements 2 models of emergency interruption of the program - a reset from the interrupt handler and interruptions in the power circuit.  The first method did not lead to something that even a simple implementation based on sequence numbers could not handle.  This is not surprising if we consider that when performing erase and write operations in flash, the execution of the program from the same flash just stops, and we have no chance to interrupt these operations in the middle.  Therefore, a second, more radical method was implemented.  The power to the microcontroller was supplied through a resistor in the 510th, and one of the universal legs was connected to ground.  To simulate a power failure, this leg was switched on to the output, and a high level was applied to it.  As a result, the current consumption sharply increased, and the supply voltage fell below the permissible.  As a result, it turned out that the worst thing that could happen was the incomplete erasure of a segment, as a result of which its contents could become anything.  As a result, the use of checksums to detect this situation came to the fore, and it was decided to abandon the use of sequence numbers.  The CRC16 checksum is written after the data, so for each record we have 4 bytes of additional information - 2 bytes of the header and 2 bytes of the checksum.  However, checksums alone do not solve the problem of choosing a workspace after a failure. <br><br><h4>  Status tags </h4><br>  In order to mark the workspace, it was decided to simply write into it a special 'status tag'.  Its format is similar to the data format with the only difference that the data is not there, and the type index is equal to the maximum possible, i.e.  255. Since it is possible that we will have 2 labeled areas, we will introduce another label, which will be marked with an area in which we are no longer going to record anything.  We will call the first label opening, and the second closing.  When creating a snapshot, we first write the closing label to the old workspace, and then create a new snapshot in the new one and write the opening label to it.  We will complete the switching of the working area by writing the final label to the old working area.  The meaning of this action will become clear below. <br><br><h4>  Latent errors </h4><br>  In the event of a power outage during recording, latency errors may occur.  If the charge injection into the floating gate of the flash-memory element is not completed, then for some time the correct data can be read from it, and then the wrong data will be read.  The appearance of such an error in the middle of the workspace will have fatal consequences.  However, there is an easy way to avoid the continuation of the record after the data that could have been interrupted.  This is the purpose of the final label.  Since it is written last in an area that is no longer working, if we read the final label, the recording of the label that opens the working area is guaranteed not to be interrupted.  We call this combination of the opening label in the workspace and the final one in the non-working state a stable state.  If at the start we see an unstable state, then before writing new data, we create snapshots and change the workspace, thereby bringing the system into a stable state. <br><br><h4>  Using </h4><br><h5>  Create a type table with default values: </h5><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cfg_types.h"</span></span></span><span class="hljs-meta"> const struct cfg_type g_cfg_types[] = { CFG_STR(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">), CFG_INT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, 1), CFG_INT_I(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, 0), ... CFG_TYPE_END }; unsigned g_cfg_ntypes = CFG_NTYPES;</span></span></code> </pre> <br><h5>  Create a configuration repository: </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> data_alignment=FLASH_SEG_SZ static __no_init const char cfg_storage[2][CFG_BUFF_SIZE] @ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CODE"</span></span></span><span class="hljs-meta">; struct config g_cfg = {{ {cfg_storage[0]}, {cfg_storage[1]} }};</span></span></code> </pre><br><h5>  We initialize it: </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> extern struct config g_cfg; cfg_init(&amp;g_cfg);</span></span></code> </pre><br><h5>  We read data: </h5><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name = cfg_get_str(&amp;g_cfg, get_cfg_type(<span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cfg_type</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cnt_t</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_cfg_type</span></span></span><span class="hljs-class">("");</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = cfg_get_val(&amp;g_cfg, <span class="hljs-keyword"><span class="hljs-keyword">cnt_t</span></span>);</code> </pre><br><h5>  Update the data: </h5><br><pre> <code class="cpp hljs">cfg_put_val(&amp;g_cfg, <span class="hljs-keyword"><span class="hljs-keyword">cnt_t</span></span>, cnt+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br><h4>  Test results </h4><br>  Testing by recording 5 million values ‚Äã‚Äãwith a simulation of power interruptions 20,000 times did not reveal any problems, after which the experiment was stopped to avoid the full development of the flash-memory resource. <br><br><h4>  Source </h4><br>  Lies <a href="https://github.com/olegv142/micro-config">here</a> .  The project for IAR is designed for MSP430G2553, the author used the latest version of MSP-EXP430G2 LaunchPad as a hardware platform.  The project implements an automatic test, but you can easily adapt it to your own tasks.  It also has a command line interface (via UART) for accessing the configuration.  The <i>types</i> command prints the type list, the <i>cfg</i> command prints the current contents of the repository, the <i>set</i> command updates the configuration.  The <i>help</i> command prints help on commands. </div><p>Source: <a href="https://habr.com/ru/post/244773/">https://habr.com/ru/post/244773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244763/index.html">To whom should the messages of the messenger users belong: Experience Kato.im</a></li>
<li><a href="../244765/index.html">Programmer - expectation and reality</a></li>
<li><a href="../244767/index.html">1C is not bad, but 1C do not like programmers anyway</a></li>
<li><a href="../244769/index.html">Incredible Athena</a></li>
<li><a href="../244771/index.html">Oracle PL / SQL. For professionals. 6th ed</a></li>
<li><a href="../244775/index.html">Cisco Small Business Switches</a></li>
<li><a href="../244777/index.html">Search for virtual servers: VDS.menu</a></li>
<li><a href="../244779/index.html">ReCaptcha API 2.0 has been released.</a></li>
<li><a href="../244781/index.html">Internship in Norway: Opera Software</a></li>
<li><a href="../244783/index.html">The human factor in software development: psychological and mathematical aspects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>