<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android Application Architecture Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the free translation of the ‚ÄúGuide to app architecture‚Äù from JetPack . All comments on the translation please le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android Application Architecture Guide</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the free translation of the ‚ÄúGuide to app architecture‚Äù from <a href="https://developer.android.com/jetpack">JetPack</a> .  All comments on the translation please leave in the comments, and they will be corrected.  Also for all comments from those who used the presented architecture with recommendations for its use will be useful. <br><br>  This guide covers best practices and recommended architecture for building robust applications.  This page assumes a basic familiarity with the Android Framework.  If you are new to developing applications for Android, check out our <a href="https://developer.android.com/guide">developer guides</a> to get started and learn more about the concepts mentioned in this guide.  If you are interested in application architecture and would like to get acquainted with the materials of this manual from the point of view of programming in Kotlin, familiarize yourself with the Udacity course <a href="https://www.udacity.com/course/ud9012">‚ÄúDeveloping Android Applications with Kotlin‚Äù</a> . <br><br><h2>  Mobile app user experience </h2><br>  In most cases, desktop applications have a single entry point from the desktop or startup programs, and then run as a single monolithic process.  Android applications have a much more complex structure.  A typical Android application contains several <a href="https://developer.android.com/guide/components/fundamentals.html">application components</a> , including <a href="https://developer.android.com/guide/components/activities/intro-activities">Activities</a> , <a href="https://developer.android.com/guide/components/fragments">Fragments</a> , <a href="https://developer.android.com/guide/components/services">Services</a> , <a href="https://developer.android.com/guide/topics/providers/content-providers">ContentProviders,</a> and <a href="https://developer.android.com/guide/components/broadcasts">BroadcastReceivers</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You declare all or some of these application components in the application <a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html">manifest</a> .  The Android OS then uses this file to decide how to integrate your application into the device‚Äôs common user interface.  Given that a well-written Android application contains several components, and users often interact with several applications in a short period of time, applications must adapt to different types of workflows and tasks that users manage. <br><a name="habracut"></a><br>  For example, consider what happens when you share a photo in your favorite social networking app: <br><br><ol><li>  The application invokes the intent of the camera.  Android launches a camera application to process the request.  At the moment, the user has left the application for social networks, and his experience as a user is impeccable. </li><li>  A camera application may trigger other intentions, such as launching a file picker that another application can launch. </li><li>  In the end, the user returns to the social networking app and shares the photo. </li></ol><br>  At any time during the process, the user may be interrupted by a phone call or notification.  After the action associated with this interruption, the user expects to be able to return and resume this photo-sharing process.  This behavior of switching applications is common on mobile devices, so your application must correctly handle these moments (tasks). <br><br>  Remember that mobile devices are also limited in resources, so at any time the operating system can destroy some application processes in order to make room for new ones. <br><br>  Given the conditions of this environment, the components of your application can be launched separately and not in order, and the operating system or the user can destroy them at any time.  Since these events are not under your control, <b>you should not store any data or states in your application components,</b> and your application components should not depend on each other. <br><br><h2>  General architectural principles </h2><br>  If you do not need to use application components to store data and application status, how should you develop your application? <br><br><h3>  Division of responsibility </h3><br>  The most important principle to follow is <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">the division of responsibility</a> .  A common mistake is when you write all your code in an <a href="https://developer.android.com/reference/android/app/Activity.html">Activity</a> or <a href="https://developer.android.com/reference/android/app/Fragment.html">Fragment</a> .  These are user interface classes that must contain only logic, the processing interaction of the user interface and the operating system.  By sharing as much of the responsibility as possible in these classes <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D1%2582%25D0%25B2%25D0%25B5%25D1%2582%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">(SRP)</a> , you can avoid many of the problems associated with the application life cycle. <br><br><h3>  User interface control from model </h3><br>  Another important principle is that you must <b>manage your user interface from a model</b> , preferably from a permanent model.  Models are the components that are responsible for processing data for an application.  They are independent of <a href="https://developer.android.com/reference/android/view/View">View</a> objects and application components, so they are not affected by the application life cycle and its associated problems. <br><br>  The permanent model is ideal for the following reasons: <br><br><ul><li>  Your users will not lose data if Android OS destroys your application to free up resources. </li><li>  Your application continues to work in cases where the network connection is unstable or unavailable. </li></ul><br>  By organizing the foundation of your application on model classes with a clearly defined responsibility for data management, your application becomes more testable and supported. <br><br><h2>  Recommended Application Architecture </h2><br>  This section demonstrates how to structure an application using <a href="https://developer.android.com/jetpack/">architecture components</a> , working in <a href="https://stackoverflow.com/a/39994651/7609373">end-</a> to- <a href="https://stackoverflow.com/a/39994651/7609373">end usage scenarios</a> . <br><br>  <i><b>Note.</b></i>  <i>It is impossible to have one way of writing applications that is best suited for each scenario.</i>  <i>However, the recommended architecture is a good starting point for most situations and workflows.</i>  <i>If you already have a good way of writing applications for Android, corresponding to the general architectural principles, you should not change it.</i> <br><br>  Imagine that we are creating a user interface that displays a user profile.  We use a private API and REST API to retrieve profile data. <br><br><h3>  Overview </h3><br>  To begin, consider the interaction of the modules of the architecture of the finished application <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Please note that each component depends only on the component one level below it.  For example, Activity and Fragments depend only on the view model.  Repository is the only class that depends on many other classes;  in this example, the storage depends on the constant data model and the remote internal data source. <br><br>  This design pattern creates a consistent and enjoyable user experience.  Regardless of whether the user returns to the application a few minutes after it is closed or a few days later, he will instantly see the user's information that the application is stored locally.  If this data is outdated, the application storage module starts updating data in the background. <br><br><h3>  Create user interface </h3><br>  The user interface consists of the <code>UserProfileFragment</code> fragment and the corresponding <code>user_profile_layout.xml</code> layout <code>user_profile_layout.xml</code> . <br><br>  To manage the user interface, our data model must contain the following data elements: <br><br><ul><li>  <b>User ID:</b> user ID.  The best solution is to pass this information to the fragment using the fragment arguments.  If the Android OS disrupts our process, this information is saved, so the ID will be available the next time we launch our application. </li><li>  <b>User object:</b> a data class that contains user information. </li></ul><br>  We use <code>UserProfileViewModel</code> , based on the ViewModel component of the architecture, to store this information. <br><br>  <i><u>The <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> object provides data for a specific component of the user interface, such as a fragment or an Activity, and contains business processing logic to interact with the model.</u></i>  <i><u>For example, the <b>ViewModel</b> can call other components to load data and can forward user requests for data changes.</u></i>  <i><u><b>The ViewModel is</b> not aware of the components of the user interface, so it is not affected by configuration changes, such as recreating the Activity when the device is rotated.</u></i> <br><br>  Now we have defined the following files: <br><br><ul><li>  <code>user_profile.xml</code> : defined the layout of the user interface. </li><li>  <code>UserProfileFragment</code> : described the user interface controller, which is responsible for displaying information to the user. </li><li>  <code>UserProfileViewModel</code> : the class responsible for preparing the data for display in the <code>UserProfileFragment</code> and responding to user interaction. </li></ul><br>  The following code snippets show the initial contents of these files.  (Layout file omitted for simplicity.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Now that we have these code modules, how do we connect them?  After the user field is set in the UserProfileViewModel class, we need a way to inform the user interface. <br><br>  <i><b>Note.</b></i>  <i>SavedStateHandle allows the ViewModel to access the saved state and the arguments of the associated fragment or action.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Now we need to inform our Fragment when a user object is received.  This is where the LiveData architecture component appears. <br><br>  <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> is the observed data holder.  Other components in your application can track object changes using this holder, without creating explicit and hard dependencies between them.  The LiveData component also takes into account the state of the life cycle of components of your application, such as Activities, Fragments and Services, and includes cleaning logic to prevent objects from leaking and excessive memory consumption. <br><br>  <i>Note.</i>  <i>If you already use libraries such as RxJava or Agera, you can continue to use them instead of LiveData.</i>  <i>However, when using libraries and similar approaches, make sure that you handle the life cycle of your application correctly.</i>  <i>In particular, make sure that you pause your data flows when the associated LifecycleOwner is stopped, and destroy those flows when the associated LifecycleOwner has been destroyed.</i>  <i>You can also add the android.arch.lifecycle artifact: reactive streams to use LiveData with another library of reactive streams, such as RxJava2.</i> <br><br>  To include the LiveData component in our application, we change the field type in the <code>UserProfileViewModel</code> to LiveData.  Now <code>UserProfileFragment</code> informed about the updated data.  In addition, since this <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html">LiveData</a> field supports the life cycle, it automatically clears links when they are no longer needed. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Now we modify the <code>UserProfileFragment</code> to observe the data in the <code>ViewModel</code> and to update the user interface according to the changes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Each time the user profile data is updated, the <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html">onChanged ()</a> callback is called, and the user interface is updated. <br><br>  If you are familiar with other libraries that use observable callbacks, you may have realized that we did not redefine the <a href="https://developer.android.com/reference/android/app/Fragment.html">onStop ()</a> fragment method to stop monitoring data.  This step is not required for LiveData, because it supports the life cycle, it means that it will not call the <code>onChanged()</code> callback if the fragment is in an inactive state;  that is, he received the <a href="https://developer.android.com/reference/android/app/Fragment.html">onStart ()</a> call, but has not yet received <code>onStop()</code> ).  LiveData also automatically removes the observer when calling the <a href="https://developer.android.com/reference/android/app/Fragment.html">fragment onDestroy ()</a> method. <br><br>  We have not added any logic to handle configuration changes, such as rotating a device‚Äôs screen by the user.  <code>UserProfileViewModel</code> automatically restored when the configuration changes, so as soon as a new fragment is created, it receives the same <code>ViewModel</code> instance and the callback is called immediately using current data.  Given that <code>ViewModel</code> objects are designed to relive the corresponding <code>View</code> objects that they update, you should not include direct references to <code>View</code> objects in your ViewModel implementation.  For more information on the lifetime of a <code>ViewModel</code> corresponds to the life cycle of user interface components, see <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html">ViewModel Life Cycle.</a> <br><br><h3>  Data retrieval </h3><br>  Now that we used LiveData to connect a <code>UserProfileViewModel</code> to a <code>UserProfileFragment</code> , how can we get user profile data? <br><br>  In this example, we assume that our backend provides a REST API.  We use the Retrofit library to access our backend, although you can use another library that serves the same purpose. <br><br>  Here is our definition of <code>Webservice</code> , which is associated with our backend: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  The first idea for implementing a <code>ViewModel</code> may include a direct call to the <code>Webservice</code> to retrieve data and assign this data to our <code>LiveData</code> object.  This design works, but with its use, our application becomes increasingly difficult to maintain as it grows.  This gives too much responsibility to the <code>UserProfileViewModel</code> class, which violates the principle of <a href="https://developer.android.com/jetpack/docs/guide">separation of interests</a> .  In addition, the ViewModel scope is associated with an <a href="https://developer.android.com/reference/android/app/Activity.html">Activity</a> or <a href="https://developer.android.com/reference/android/app/Fragment.html">Fragment</a> life cycle, which means that the data from the <code>Webservice</code> lost when the life cycle of the associated user interface object ends.  This behavior creates an undesirable user experience. <br><br>  Instead, our <code>ViewModel</code> delegates the process of extracting data to a new module, the repository. <br><br>  <u><i><b>Repository</b> modules handle data operations.</i></u>  <u><i>They provide a clean API, so the rest of the application can easily retrieve this data.</i></u>  <u><i>They know where to get the data and what API calls to do when updating data.</i></u>  <u><i>You can view repositories as intermediaries between different data sources, such as persistent models, web services, and caches.</i></u> <br><br>  Our <code>UserRepository</code> class, shown in the following code snippet, uses an instance of the <code>WebService</code> to retrieve user data: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Although the storage module seems unnecessary, it serves an important purpose: it abstracts data sources from the rest of the application.  Now our <code>UserProfileViewModel</code> does not know how to retrieve data, so we can provide the view model with data obtained from several different implementations of data retrieval. <br><br>  <b>Note.</b>  We missed the case of network errors for simplicity.  For an alternative implementation that exposes errors and download status, see Appendix: Network Status Disclosure. <br><br>  <b>Manage dependencies between components</b> <br><br>  The <code>UserRepository</code> class above requires an instance of <code>Webservice</code> to retrieve user data.  He could just create an instance, but for that he also needs to know the dependencies of the <code>Webservice</code> class.  In addition, <code>UserRepository</code> is probably not the only class that needs a web service.  This situation requires us to duplicate the code, because every class that needs a link to the <code>Webservice</code> needs to know how to create it and its dependencies.  If each class creates a new <code>WebService</code> , our application can become very resource-intensive. <br><br>  To solve this problem, you can use the following design patterns: <br><br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Dependency Injection (DI)</a> .  Dependency injection allows classes to define their dependencies without creating them.  At run time, another class is responsible for providing these dependencies.  We recommend the <a href="https://dagger.dev/">Dagger 2</a> library for implementing dependency injection in Android applications.  Dagger 2 automatically creates objects, bypassing the dependency tree, and provides guarantees of compile time for dependencies. </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D1%2581%25D0%25BB%25D1%2583%25D0%25B6%25D0%25B1">(Service location) Service Locator: A service</a> locator template provides a registry in which classes can get their dependencies instead of building them. </li></ul><br>  Implementing the service registry is easier than using DI, so if you are not familiar with DI, use the service location instead. <br><br>  These templates allow you to scale your code because they provide clear templates for managing dependencies without duplicating or complicating the code.  In addition, these templates allow you to quickly switch between test and production data sampling implementations. <br><br>  In our sample application, <a href="https://dagger.dev/">Dagger 2 is used</a> to manage the dependencies of the <code>Webservice</code> object. <br><br><h3>  Connect the ViewModel and Vault </h3><br>  Now we modify our <code>UserProfileViewModel</code> to use the <code>UserRepository</code> object: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Caching </h3><br>  The <code>UserRepository</code> implementation abstracts the call to the <code>Webservice</code> object, but since it relies on only one data source, it is not very flexible. <br><br>  The main problem with the implementation of the <code>UserRepository</code> is that after receiving data from our backend, this data is not stored anywhere.  Therefore, if the user leaves the <code>UserProfileFragment</code> and then returns to it, our application must re-retrieve the data, even if it has not changed. <br><br>  This design is suboptimal for the following reasons: <br><br><ul><li>  It spends valuable traffic resources. </li><li>  This forces the user to wait for the completion of a new request. </li></ul><br>  To eliminate these shortcomings, we add a new data source to our <code>UserRepository</code> , which caches <code>User</code> objects in memory: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Permanent data </h3><br>  Using our current implementation, if the user rotates the device or leaves and immediately returns to the application, the existing user interface becomes visible instantly because the storage retrieves data from our cache in memory. <br><br>  However, what happens if the user leaves the app and returns a few hours after the Android OS finishes the process?  Relying on our current implementation in this situation, we need to retrieve data from the network again.  This update process is not just a bad user experience;  it is also wasteful because it consumes valuable mobile data. <br><br>  You can solve this problem by caching web requests, but this creates a key new problem: what happens if the same user data is displayed in a different type of request, for example, when you receive a list of friends?  The application will display conflicting data, which at best is confusing.  For example, our application can display two different versions of the data of the same user if the user sent a friend list request and a single user request at different times.  Our application would have to figure out how to combine these conflicting data. <br><br>  The right way to handle this situation is to use a permanent model.  We come to the aid of the library of saving permanent data (DB) <a href="https://developer.android.com/training/data-storage/room/index.html">Room</a> . <br><br>  <a href="https://developer.android.com/training/data-storage/room/index.html">Room</a> is an object-mapping library (object-mapping) that provides local data storage with minimal standard code.  At compile time, it checks every request for conformance to your data schema, so non-working SQL queries result in compile-time errors and not runtime failures.  Room abstracts from some basic details of the implementation of working with raw SQL tables and queries.  It also allows you to monitor changes in database data, including collections and connection requests, exposing such changes using LiveData objects.  It even explicitly defines execution constraints that solve common threading problems, such as access to the repository in the main thread. <br><br>  <i><b>Note.</b></i>  <i>If your application already uses another solution, such as an SQLite object-relational mapping (ORM), you do not need to replace the existing solution with Room.</i>  <i>However, if you are writing a new application or reorganizing an existing application, we recommend using Room to save your application data.</i>  <i>Thus, you can take advantage of the abstraction of the library and the verification of queries.</i> <br><br>  To use Room, we need to define our local layout.  First we add the <code><a href="https://developer.android.com/reference/android/arch/persistence/room/Entity.html">@Entity</a></code> annotation to our <code>User</code> data model class and the <code>@PrimaryKey</code> annotation in the class <code>id</code> field.  These annotations mark <code>User</code> as a table in our database, and <code>id</code> as the primary key of the table: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Then we create a database class, implementing <code>RoomDatabase</code> for our application: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Note that <code>UserDatabase</code> is abstract.  The Room library automatically provides an implementation of this.  See the <a href="https://developer.android.com/training/data-storage/room/">Room</a> documentation for details. <br><br>  Now we need a way to insert user data into the database.  For this task, we create <a href="https://en.wikipedia.org/wiki/Data_access_object">a data access object (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Notice that the <code>load</code> method returns an object of type LiveData.  Room knows when the database is changed, and automatically notifies all active observers of data changes.  Because Room uses <i>LiveData</i> , this operation is effective;  it updates data only if there is at least one active observer. <br><br>  <i><b>Note:</b> Room checks invalidation based on table modifications, which means that it can send false positive notifications.</i> <br><br>  Having defined our <code>UserDao</code> class, we then refer to the DAO from our database class: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Now we can change our <code>UserRepository</code> to enable the Room data source: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Note that even if we changed the data source in the <code>UserRepository</code> , we did not need to change our <code>UserProfileViewModel</code> or <code>UserProfileFragment</code> .  This minor update demonstrates the flexibility that our application architecture provides.  It is also great for testing, because we can provide a fake <code>UserRepository</code> and at the same time test our production <code>UserProfileViewModel</code> . <br><br>  If users return in a few days, the application using this architecture is likely to show outdated information until the repository receives updated information.  Depending on your use case, you may not display outdated information.  Instead, you can display <i>placeholder</i> data that shows dummy values ‚Äã‚Äãand indicates that your application is currently loading and loading up-to-date information. <br><br>  <b>The only source of truth</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typically, different REST API endpoints return the same data. For example, if our backend has another endpoint that returns a list of friends, the same user object can come from two different API endpoints, perhaps even using different levels of detail. If it </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returned the response from the query </font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as is, without consistency checking, our user interfaces might show confusing information, because the version and format of the data from the repository would depend on the last called endpoint. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this reason, our implementation </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stores web service responses in a database. The database changes then callbacks for the active </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects </font><font style="vertical-align: inherit;">. Using this model,</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The database serves as the only source of truth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and other parts of the application access it through ours </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Regardless of whether you use disk cache, we recommend that your repository identify the data source as the only source of truth for the rest of your application.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Show the progress of the operation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some use cases, such as pull-to-refresh, it is important that the user interface shows the user that a network operation is currently being performed. </font><font style="vertical-align: inherit;">It is recommended to separate the user interface action from the actual data, since the data can be updated for various reasons. </font><font style="vertical-align: inherit;">For example, if we received a list of friends, the same user can be selected again programmatically, which will lead to updating LiveData. </font><font style="vertical-align: inherit;">From the point of view of the user interface, the fact of having a request in flight is just another data point, similar to any other part of the data in the object itself </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can use one of the following strategies to display the consistent update status of the data in the user interface, regardless of where the update request came from: </font></font><br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the section on division of interests, we mentioned that testability is one of the key benefits of following this principle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following list shows how to test each module code from our advanced example:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User interface and interaction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : use the </font></font><a href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android UI test toolkit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The best way to create this test is to use the </font></font><a href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can create a snippet and provide it with a layout </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since the fragment is associated only with </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mocking </font></font><a href="https://ru.wikipedia.org/wiki/Mock-%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(imitation) of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> only this class is sufficient to fully test the user interface of your application.</font></font></li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://developer.android.com/training/testing/unit-testing/local-unit-tests.html">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        ‚Ä¶ <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://developer.android.com/reference/android/arch/persistence/db/SupportSQLiteOpenHelper.html">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="http/tree/master/mockwebserver">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://developer.android.com/training/testing/espresso/idling-resource"> </a> . </li></ul><br></li></ul><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programming is a creative field, and the creation of Android applications is no exception. There are many ways to solve a problem, be it transferring data between multiple actions or fragments, retrieving remote data and storing it offline when offline, or any number of other common scenarios that non-trivial applications encounter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the following recommendations are optional, our experience shows that implementing them makes your codebase more reliable, tested and supported in the long term: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid designating entry points for your application ‚Äî such as actions, services, and broadcast receivers ‚Äî as data sources.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, they should coordinate only with other components in order to obtain a subset of the data related to this entry point. Each component of the application is rather short-lived, depending on the interaction of the user with his device and the overall current state of the system. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create clear boundaries of responsibility between the various modules of your application.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, do not distribute code that downloads data from the network, across several classes or packages in your codebase. Similarly, do not define multiple unrelated responsibilities ‚Äî such as data caching and data binding ‚Äî in the same class. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expose as little as possible from each module.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not be tempted to create a ‚Äújust one‚Äù label that reveals the details of the internal implementation of a single module. You may gain a little time in the short term, but then you will incur technical debt many times as your code base develops. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think about how to make each module testable in isolation.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, having a well-defined API for retrieving data from the network makes it easier to test a module that stores this data in a local database. If instead you mix the logic of these two modules in one place or distribute your network code across the entire code base, testing becomes much more difficult - in some cases not even impossible. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Focus on the unique core of your application so that it stands out among other applications.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not reinvent the wheel by writing the same template over and over again. Instead, focus your time and energy on what makes your application unique, and allow the components of the Android architecture and other recommended libraries to cope with a repetitive pattern. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save as much up-to-date and up-to-date data as possible.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, users can enjoy the functionality of your application, even if their device is offline. Remember that not all your users enjoy a permanent high-speed connection. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assign one data source to a single source that is true.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Whenever your application needs access to this piece of data, it should always come from this one source of truth.</font></font><br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: network status disclosure</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above recommended application architecture section, we missed network errors and boot states to simplify code snippets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This section shows how to display network status using the Resource class, which encapsulates both data and its status. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code fragment provides an example implementation.</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since downloading data from the network when displaying a copy of this data is common practice, it is useful to create an auxiliary class that can be reused in several places. For this example, we create a class named </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following diagram shows the decision tree for </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It begins by observing the database for the resource. When a record is loaded from the database for the first time, it </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checks whether the result is good enough to be sent, or whether it needs to be retrieved from the network again. Please note that both of these situations can occur at the same time, given that you probably want to show cached data when you update it from the network.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the network call succeeds, it stores the response in the database and reinitializes the stream. In the event of a failure, the network request </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sends the failure directly. </font></font><br><br> <code><b>.</b>             .       ,       .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep in mind that relying on a database to submit changes involves using the associated side effects, which is not very good, because the unspecified behavior of these side effects can occur if the database does not send the changes, because the data has not changed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, do not send the results obtained from the network, as this will violate the principle of a single source of truth. </font><font style="vertical-align: inherit;">In the end, perhaps the database contains triggers that change data values ‚Äã‚Äãduring a save operation. </font><font style="vertical-align: inherit;">Similarly, do not send `SUCCESS` without new data, because then the client will receive the wrong version of the data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code snippet shows the public API provided by the class </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for its subclasses:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note the following important details of class definition: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It defines two type parameters, </font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">since the data type returned from the API may not match the data type used locally.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It uses the class </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for network requests. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a simple wrapper for a class </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that converts the answers into instances </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full implementation of the class </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appears as part of the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub android-Architecture-components</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once created, </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can use it to write our disk-attached and network implementations </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the class </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/456256/">https://habr.com/ru/post/456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456240/index.html">Chat bot development (laravel + botman)</a></li>
<li><a href="../456242/index.html">A little more about multitasking in microcontrollers</a></li>
<li><a href="../456246/index.html">Item size zero</a></li>
<li><a href="../456248/index.html">How I caught the styles: before for the focus element</a></li>
<li><a href="../456250/index.html">Localization of the application and support for RTL. Report Yandex.Taxi</a></li>
<li><a href="../456258/index.html">Free as wind and free as beer translation of "Free as in Freedom" into Russian under the license GNU FDL 1.3</a></li>
<li><a href="../45626/index.html">jQuery and ContextMenu plugin - right click in Opera</a></li>
<li><a href="../456260/index.html">Talk about a fair economy</a></li>
<li><a href="../456262/index.html">Software Defined Radio - how does it work? Part 9</a></li>
<li><a href="../456266/index.html">The digest of interesting materials for the mobile developer # 302 (June 10 - 16)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>