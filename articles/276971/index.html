<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RxSwift in action - we write reactive application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="According to the latest trends, the FRP is gaining momentum and is not going to stop. Not so long ago, I was faced with a project dedicated to FRP - R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RxSwift in action - we write reactive application</h1><div class="post__text post__text-html js-mediator-article">  According to the latest trends, the FRP is gaining momentum and is not going to stop.  Not so long ago, I was faced with a project dedicated to FRP - <a href="http://reactivex.io/">ReactiveX</a> , and its implementation for Swift - <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> .  On Habr√© already there was a small <a href="https://habrahabr.ru/post/273455/">article</a> which will be useful for initial understanding of RxSwift.  I would like to develop this topic, so if you are interested - welcome under the cat! <br><br><h4>  Down and Out trouble started </h4><br>  And indeed it is.  The most difficult thing I had to deal with was a completely different construction of the program code.  With my experience of imperative programming it was hard to rebuild in a new way.  But her instinct told me that it was worth finding out;  It took me 2 weeks of <s>panic</s> to get to the core of ReactiveX and I do not regret the time spent.  Therefore, I would immediately like to warn you - the article requires an understanding of the terms ReactiveX, such as Observable, Subscriber, etc. <br><br>  So, let's begin. <a name="habracut"></a>  We will write a simple reader of our wall with Facebook.  For this we need <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> , <a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a> for data mapping, <a href="https://github.com/facebook/facebook-ios-sdk">Facebook iOS SDK</a> and <a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> for load indication.  Create a project in XCode, connect the above libraries to it (I use <a href="https://cocoapods.org/">CocoaPods</a> ), set up a bunch with Facebook according to the <a href="https://developers.facebook.com/docs/ios/getting-started">instructions</a> and go to coding. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Login screen </h4><br>  We will not invent a bicycle, we will simply place a ready-made button from Facebook - FBSDKLoginButton in the center of the screen: <br><br><pre><code class="objectivec hljs">let loginButton = FBSDKLoginButton() loginButton.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.center loginButton.readPermissions = [<span class="hljs-string"><span class="hljs-string">"user_posts"</span></span>] loginButton.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Do not forget to add the FBSDKLoginButtonDelegate delegate for the login button, and also implement the delegate methods: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: Facebook Delegate Methods func loginButton(loginButton: FBSDKLoginButton!, didCompleteWithResult result: FBSDKLoginManagerLoginResult!, error: NSError!) { if ((error) != nil) { // Process error let alert = UIAlertController(title: "", message: error.localizedDescription, preferredStyle: .Alert) alert.addAction(UIAlertAction(title: "OK", style: .Cancel, handler: nil)) self.presentViewController(alert, animated: true, completion: nil) } else if result.isCancelled { let alert = UIAlertController(title: "", message: "Result is cancelled", preferredStyle: .Alert) alert.addAction(UIAlertAction(title: "OK", style: .Cancel, handler: nil)) self.presentViewController(alert, animated: true, completion: nil) } else { let storyboard = UIStoryboard(name: "Main", bundle: nil) let vc = storyboard.instantiateViewControllerWithIdentifier("navController") as! UINavigationController self.presentViewController(vc, animated: true, completion: nil) } } func loginButtonDidLogOut(loginButton: FBSDKLoginButton!) { print("User Logged Out") }</span></span></code> </pre><br>  Everything is simple - if the login error or the user presses the ‚ÄúCancel‚Äù button on the Facebook authorization screen, we display a message about this in the form of an alert, and if everything is OK, send it to the next screen with a list of news.  I did not touch the logout function.  As we see, so far everything is rather trivial and there is no question of any reactivity.  Here, too, is a rather subtle point - <s>do not stick reactivity into all the gaps to</s> remember about the <a href="https://ru.wikipedia.org/wiki/KISS_(%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF)">KISS</a> principle. <br><br><h4>  News screen </h4><br>  Let's write the function of getting the list of news from the Facebook wall, the return type of which will be Observable: <br><br><pre> <code class="objectivec hljs">func getFeeds() -&gt; Observable&lt;GetFeedsResponse&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create { observer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let parameters = [<span class="hljs-string"><span class="hljs-string">"fields"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>] let friendsRequest = FBSDKGraphRequest.init(graphPath: <span class="hljs-string"><span class="hljs-string">"me/feed"</span></span>, parameters: parameters, HTTPMethod: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>) friendsRequest.startWithCompletionHandler { (connection, result, error) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { observer.on(.Error(error!)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let getFeedsResponse = Mapper&lt;GetFeedsResponse&gt;().map(result)! observer.on(.Next(getFeedsResponse)) observer.on(.Completed) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnonymousDisposable { } } }</code> </pre><br>  What happens in this code?  A FBSDKGraphRequest network request for receiving ‚Äúme / feed‚Äù news is formed, after which we give the command to execute the request and monitor the status in the completition block;  in case of an error, we transfer it to Observable; in case of success, we transmit it to Observable. <br><br>  <b>Note:</b> I am passing a variable to FBSDKGraphRequest <pre> <code class="objectivec hljs">let parameters = [<span class="hljs-string"><span class="hljs-string">"fields"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>]</code> </pre>  with an empty parameter set.  This is necessary so that Facebook does not <s>cry,</s> displaying warnings in the logs that the fields in the parameters is mandatory.  In principle, everything works without this parameter, but I sleep so calmly. <br><br>  A little away from the process of writing an application and talk about data mapping.  I solve this problem with the help of ObjectMapper, it allows you to do it rather quickly and simply: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GetFeedsResponse: Mappable { var data = [Feed]() var paging: Paging! required init?(_ map: Map){ } <span class="hljs-comment"><span class="hljs-comment">// Mappable func mapping(map: Map) { data &lt;- map["data"] paging &lt;- map["paging"] } } class Feed: Mappable { var createdTime: String! var id: String! var story: String? var message: String? required init?(_ map: Map){ } // Mappable func mapping(map: Map) { createdTime &lt;- map["created_time"] id &lt;- map["id"] story &lt;- map["story"] message &lt;- map["message"] } } class Paging: Mappable { var next: String! var previous: String! required init?(_ map: Map){ } // Mappable func mapping(map: Map) { next &lt;- map["next"] previous &lt;- map["previous"] } }</span></span></code> </pre><br>  I suggest to immediately write a network request for detailed information about the news: <br><br><pre> <code class="objectivec hljs">func getFeedInfo(feedId: String) -&gt; Observable&lt;GetFeedInfoResponse&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create { observer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let parameters = [<span class="hljs-string"><span class="hljs-string">"fields"</span></span> : <span class="hljs-string"><span class="hljs-string">"id,admin_creator,application,call_to_action,caption,created_time,description,feed_targeting,from,icon,is_hidden,is_published,link,message,message_tags,name,object_id,picture,place,privacy,properties,shares,source,status_type,story,story_tags,targeting,to,type,updated_time,with_tags"</span></span>] let friendsRequest = FBSDKGraphRequest.init(graphPath: <span class="hljs-string"><span class="hljs-string">""</span></span> + feedId, parameters: parameters, HTTPMethod: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>) friendsRequest.startWithCompletionHandler { (connection, result, error) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { observer.on(.Error(error!)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { print(result) let getFeedInfoResponse = Mapper&lt;GetFeedInfoResponse&gt;().map(result)! observer.on(.Next(getFeedInfoResponse)) observer.on(.Completed) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnonymousDisposable { } } }</code> </pre><br>  As we see, I passed a bunch of fields in the parameters variable ‚Äî these are all fields that were in the documentation.  I will not disassemble them all, only a part.  Here is the data mapping: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GetFeedInfoResponse: Mappable { var createdTime: String! var from: IdName! var <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: String! var isHidden: Bool! var isPublished: Bool! var message: String? var name: String? var statusType: String? var story: String? var to = [IdName]() var type: String! var updatedTime: String! required init?(_ map: Map){ } <span class="hljs-comment"><span class="hljs-comment">// Mappable func mapping(map: Map) { createdTime &lt;- map["created_time"] from &lt;- map["from"] id &lt;- map["from"] isHidden &lt;- map["is_hidden"] isPublished &lt;- map["is_published"] message &lt;- map["message"] name &lt;- map["name"] statusType &lt;- map["status_type"] story &lt;- map["story"] // It necessary that Facebook API have a bad structure // buffer%varname% is a temporary variable var bufferTo = NSDictionary() bufferTo &lt;- map["to"] if let bufferData = bufferTo["data"] as? NSArray { for bufferDataElement in bufferData { let bufferToElement = Mapper&lt;IdName&gt;().map(bufferDataElement) to.append(bufferToElement!) } } type &lt;- map["type"] updatedTime &lt;- map["updated_time"] } } class IdName: Mappable { var id: String! var name: String! required init?(_ map: Map){ } // Mappable func mapping(map: Map) { id &lt;- map["id"] name &lt;- map["name"] } }</span></span></code> </pre><br>  As you can see, there was also some tar in the ointment.  For example, when parsing the ‚Äúto‚Äù json object, which contains one ‚Äúdata‚Äù field, which in turn is a json array, I had to dodge as follows: <br><br><pre> <code class="objectivec hljs">var bufferTo = <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>() bufferTo &lt;- map[<span class="hljs-string"><span class="hljs-string">"to"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let bufferData = bufferTo[<span class="hljs-string"><span class="hljs-string">"data"</span></span>] as? <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bufferDataElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bufferData { let bufferToElement = Mapper&lt;IdName&gt;().map(bufferDataElement) to.append(bufferToElement!) } }</code> </pre><br>  In principle, I could create a file with a single ‚Äúdata‚Äù field and quietly un-mars the object there, but the idea to create a new file for mapping one field seemed silly to me.  If any of you have a more elegant solution to this problem - I will <s>drink for joy</s> I will be glad to learn about it. <br><br>  Let's return to our sheep.  We contacted Facebook, got a list of news in the form of Observable, now we need to display this data.  For this purpose I will use the <a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel">MVVM</a> template.  My free interpretation of this template with regard to the use of ReactiveX sounds like this: in the ViewModel there is an Observable that generates events, and the View subscribes to these events and processes them.  That is, the ViewModel does not depend on who subscribes to it - if there are subscribers, the Observable generates data, if there are no subscribers, the Observable does not generate anything (this statement is true for ‚Äúcold‚Äù Observable, because ‚Äúhot‚Äù Observable always generate data).  Let's write the ViewModel for the news screen: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FeedsViewModel { let feedsObservable: Observable&lt;[Feed]&gt; let clickObservable: Observable&lt;GetFeedInfoResponse&gt; <span class="hljs-comment"><span class="hljs-comment">// If some process in progress let indicator: Observable&lt;Bool&gt; init(input: ( UITableView ), dependency: ( API: APIManager, wireframe: Wireframe ) ) { let API = dependency.API let wireframe = dependency.wireframe let indicator = ViewIndicator() self.indicator = indicator.asObservable() feedsObservable = API.getFeeds() .trackView(indicator) .map { getFeedResponse in return getFeedResponse.data } .catchError { error in return wireframe.promptFor(String(error), cancelAction: "OK", actions: []) .map { _ in return error } .flatMap { error in return Observable.error(error) } } .shareReplay(1) clickObservable = input .rx_modelSelected(Feed) .flatMap { feed in return API.getFeedInfo(feed.id).trackView(indicator) } .catchError { error in return wireframe.promptFor(String(error), cancelAction: "OK", actions: []) .map { _ in return error } .flatMap { error in return Observable.error(error) } } // If error when click uitableview - set retry() if you want to click cell again .retry() .shareReplay(1) } }</span></span></code> </pre><br>  Let's break the code down.  In the input field we transfer the table from View, in the dependency field - the API class and Wireframe.  There are 3 variables in the class: feedsObservable returns Observable with a news list, clickObservable is a handler for clicking on a table cell, and indicator is a boolean variable that determines whether the load indicator should be displayed on the screen.  There are 2 interesting classes in the code at once - Wireframe and ViewIndicator, let's dwell on them in more detail.  Wireframe is nothing more than a ‚Äúreactive‚Äù implementation of alert.  I took this implementation from the examples in the RxSwift repository.  ViewIndicator is a tracking, and the trackView function from this class is executed until at least one sequence is executed in the chain, so it is convenient to use trackView to show the loading indicator.  I will not give the code in this article - you can find it in the project repository, the link is at the bottom of the article. <br><br>  Let's touch the logic of our Observable.  The first one - feedsObservable - gets a response from Facebook, then in the map block the list of news is retrieved and returned, then there is an error handling, well, and a trackView to display the download.  The second, clickObservable, monitors clicking on a cell in a table, after which it triggers a network request to receive detailed information about the news.  Super, with the model finished, go directly to the View. <br><br>  I will immediately provide the View code, after which we will analyze it: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FeedsViewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UITableViewDelegate</span></span> { @IBOutlet <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> var feedsTableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>! var disposeBag = DisposeBag() override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() let viewModel = FeedsViewModel( input:feedsTableView, dependency: ( API: APIManager.sharedAPI, wireframe: DefaultWireframe.sharedInstance ) ) let progress = MBProgressHUD() progress.mode = MBProgressHUDMode.Indeterminate progress.labelText = <span class="hljs-string"><span class="hljs-string">" ..."</span></span> progress.dimBackground = <span class="hljs-literal"><span class="hljs-literal">true</span></span> viewModel.indicator .bindTo(progress.rx_mbprogresshud_animating) .addDisposableTo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.disposeBag) feedsTableView.rx_setDelegate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) viewModel.feedsObservable .bindTo(feedsTableView.rx_itemsWithCellFactory) { tableView, row, feed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let cell = tableView.dequeueReusableCellWithIdentifier(<span class="hljs-string"><span class="hljs-string">"feedTableViewCell"</span></span>) as! FeedTableViewCell cell.feedCreatedTime.text = <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>().convertFacebookTime(feed.createdTime) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let story = feed.story { cell.feedInfo.text = story } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let message = feed.message { cell.feedInfo.text = message } cell.layoutMargins = <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsZero</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } .addDisposableTo(disposeBag) viewModel.clickObservable .subscribeNext { feed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let storyboard = <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboard</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Main"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) let feedInfoViewController = storyboard.instantiateViewControllerWithIdentifier(<span class="hljs-string"><span class="hljs-string">"feedInfoViewController"</span></span>) as! FeedInfoViewController feedInfoViewController.feedInfo = feed <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController?.pushViewController(feedInfoViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } .addDisposableTo(disposeBag) } override func didReceiveMemoryWarning() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.didReceiveMemoryWarning() } <span class="hljs-comment"><span class="hljs-comment">// Deselect tableView row after click func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { tableView.deselectRowAtIndexPath(indexPath, animated: true) } }</span></span></code> </pre><br>  First of all, create a viewModel.  Next you need to create a download indicator and somehow link it with the ViewIndicator.  To do this, we need to write an Extension for MBProgressHUD: <br><br><pre> <code class="objectivec hljs">extension MBProgressHUD { <span class="hljs-comment"><span class="hljs-comment">/** Bindable sink for MBProgressHUD show/hide methods. */</span></span> public var rx_mbprogresshud_animating: AnyObserver&lt;Bool&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnyObserver {event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MainScheduler.ensureExecutingOnScheduler() <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (event) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Next(let value): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value { let loadingNotification = MBProgressHUD.showHUDAddedTo(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>.sharedApplication().keyWindow?.subviews.last, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) loadingNotification.mode = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mode loadingNotification.labelText = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.labelText loadingNotification.dimBackground = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dimBackground } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MBProgressHUD.hideHUDForView(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>.sharedApplication().keyWindow?.subviews.last, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Error(let error): let error = <span class="hljs-string"><span class="hljs-string">"Binding error to UI: \(error)"</span></span> <span class="hljs-meta"><span class="hljs-meta">#if DEBUG rxFatalError(error) #else print(error) #endif case .Completed: break } } } }</span></span></code> </pre><br>  If any value is supplied to MBProgressHUD, then we display the indicator.  If no value is given - hide it.  Now we need to set up a binding between our MBProgressHUD and ViewIndicator.  This is done like this: <br><br><pre> <code class="objectivec hljs">viewModel.indicator .bindTo(progress.rx_mbprogresshud_animating) .addDisposableTo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.disposeBag)</code> </pre><br>  Then we set the binding between UITableView and data acquisition, as well as between clicking on the UITableView element and switching to a new screen.  I also made a detailed information screen about the post without ‚Äúreactivity‚Äù: <br><br><pre> <code class="objectivec hljs">override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() var feedDetail = <span class="hljs-string"><span class="hljs-string">"From: "</span></span> + feedInfo.from.name <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> feedInfo.to.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nTo: "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> feedInfo.to { feedDetail += to.name + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let date = feedInfo.createdTime { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nDate: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>().convertFacebookTime(date) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let story = feedInfo.story { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nStory: "</span></span> + story } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let message = feedInfo.message { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nMessage: "</span></span> + message } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let name = feedInfo.name { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nName: "</span></span> + name } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let type = feedInfo.type { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nType: "</span></span> + type } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let updatedTime = feedInfo.updatedTime { feedDetail += <span class="hljs-string"><span class="hljs-string">"\nupdatedTime: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>().convertFacebookTime(updatedTime) } feedTextView.text = feedDetail <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController?.navigationBar.tintColor = <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.whiteColor() }</code> </pre><br>  I have it all.  The source code of the project on Github can be downloaded from this <a href="https://github.com/svyatoslav-reshetnikov/ReactiveApp">link</a> .  If you liked my article, then I‚Äôll <s>burst of happiness</s> with pleasure and continue to write about RxSwift and try to uncover its potential in more trivial tasks. </div><p>Source: <a href="https://habr.com/ru/post/276971/">https://habr.com/ru/post/276971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276955/index.html">Rumors confirmed - Opera Software is sold to China</a></li>
<li><a href="../276957/index.html">Carefully about counting single bits</a></li>
<li><a href="../276961/index.html">Nginx 1.9.11 released with support for dynamic modules</a></li>
<li><a href="../276967/index.html">Hardware password manager or how to stop entering passwords and start living</a></li>
<li><a href="../276969/index.html">Dash opened source code for vending machine with InstantX</a></li>
<li><a href="../276973/index.html">Explaining the inexplicable. Part 2</a></li>
<li><a href="../276975/index.html">FRUSDR update for optimal server performance (INTEL platform)</a></li>
<li><a href="../276977/index.html">Domain telephony</a></li>
<li><a href="../276979/index.html">PRIMEFLEX vShape - turnkey solution for the implementation of virtualization</a></li>
<li><a href="../276981/index.html">Crash course on interfaces in go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>