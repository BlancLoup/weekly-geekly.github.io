<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Physical design of storage structures in Teradata DBMS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the physical design of storage structures? 
 The main goal pursued during the development of a physical data model is the creation of such obj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Physical design of storage structures in Teradata DBMS</h1><div class="post__text post__text-html js-mediator-article"><h4>  What is the physical design of storage structures? </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/c3d/564/c02/c3d564c02007c0125719293d6d4e9b45.gif" align="left">  The main goal pursued during the development of a physical data model is the creation of such objects for a specific platform / DBMS, which will achieve maximum performance of queries / applications that create the main load, while reducing additional costs, such as the need to maintain additional indices, to materialize derivatives. data, etc., to a minimum. <br>  All relational databases are built on the same principles, but each platform has unique features in the form of the presence of various types of objects and features of their implementation.  For this reason, the process of physical modeling is platform-specific, in contrast to logical modeling, the main purpose of which is to reliably describe data and business processes. <br><a name="habracut"></a><br><br><h4>  Data Storage in Teradata DBMS </h4><br>  Speaking about the physical design of databases on the Teradata platform, among other things, it is necessary to mention that this is a MPP (Massive Parallel Processing) platform in which all data is distributed among the system components (AMPs) and processed by them when executing user queries in parallel (see our <a href="http://habrahabr.ru/company/teradata/blog/160821/">first article</a> ).  This architecture, as well as the even distribution of the data, make their processing efficient and in the absence of additional performance elements.  This feature allows Teradata to cope perfectly with Ad-Hoc requests not provided for by the developers of the physical model. <br>  But for mixed loads, when both tactical (OLTP-like) and strategic (OLAP, DSS, Data Mining) requests are executed simultaneously on the system, this is not enough.  This especially applies to tactical requests that have sufficiently high requirements for response time and throughput.  The main technique of physical design to improve the performance of tactical queries is the creation of indexes ‚Äî data access paths that can be used by queries to quickly find the right rows of a table without having to look at it completely.  The use of indexes allows you to drastically reduce the number of I / O operations during query execution, which reduces response time and, as a result, increases system throughput.  Let's take a look at how the indexes are arranged in Teradata, taking into account the parallel architecture. <br><br><h4>  Ways to access data </h4><br>  DBMS Teradata supports various ways to access rows of tables: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Access by the primary index (what the primary index is, was discussed in our <a href="http://habrahabr.ru/company/teradata/blog/160821/">first article</a> ) </h5><br>  This is the fastest and least expensive way to access data in Teradata. <br>  Recall that the data in the Teradata DBMS is distributed using the result of hashing the value of the column of the primary index.  Rows with the same values ‚Äã‚Äãof the column of the primary index ALWAYS fall on the same AMP. <br><img src="https://habrastorage.org/getpro/habr/post_images/1f0/811/256/1f0811256f60f436b8d9fa48b11b1897.jpg"><br>  The algorithm used to determine AMP, on which a row should be placed when it is inserted into a table, is equally well used to search for a row with a known value of the column of the primary index. <br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/cc7/fb4/c6ccc7fb49e5e2cbe8cfc31c71d44af7.jpg"><br>  When the AMP on which the search string is located is defined, Teradata uses index structures to find the required data block.  Sequentially viewed: <ul><li>  Master Index (always loaded into AMP memory) to search for a cylinder containing the required data block; </li><li>  Cylinder Index (almost always loaded into AMP memory) to search for the desired data block. </li></ul><br>  After the required data block is found, it is read and then the string is searched using an array of row pointers (Row Reference Array). <br><br>  This algorithm works equally for both unique (Unique Primary Index - UPI) and non-unique (Non-unique Primary Index - NUPI) primary indexes - with the only difference that when accessing via UPI, only one data block is always read and no more single line, while accessing by NUPI these values ‚Äã‚Äãdepend on the degree of nonuniqueness of the index. <br><br>  <b>Base table row format</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/174/7cc/179/1747cc1792764d6d6232ceea6151cba1.jpg"><br><br>  The peculiarity of data storage in Teradata is that on each AMP, the rows of the tables are not stored in an arbitrary order, but are sorted by the hash values ‚Äã‚Äãof the primary index.  Such an approach requires additional efforts when inserting data, since new rows should be inserted not into the ‚Äúend of the table‚Äù, but so as to preserve sorting by hashes.  In this case, we get two advantages: <ul><li>  When joining the primary index column, you can immediately apply the effective MERGE JOIN join, since the rows are already ordered. </li><li> Automatic indexing of the primary index column.  The internal file system indexes (master index and cylinder index), mentioned above, contain within the range of hash values ‚Äã‚Äãfor the data stored in data blocks.  Due to the fact that the rows are ordered, these ranges do not overlap.  As a result, by creating disk space markup for data blocks, we actually get not only this markup itself, but also the indexing of the primary index column ‚Äî the classic B-tree index by the hash values ‚Äã‚Äãof the primary index.  We sometimes even say that the primary index does not occupy disk space and does not require maintenance, bearing in mind that it is part of the master index and cylinder index structure for storing data on the AMP disk system. </li></ul><br>  The features of this algorithm also determine the limitations inherent in it, namely, access by the primary index is possible only under the following conditions: <ul><li>  using the condition "equal" in the query to filter on the column of the primary index; </li><li>  inclusion in the search conditions of ALL columns constituting the primary index. </li></ul><br><h5>  Access by secondary index </h5><br>  Secondary indexes are alternative data access paths.  Implemented in the form of index sub-tables, which allow identifying the corresponding identifiers of rows of the base table by the value of the indexing column. <br><br>  The implementation of the index sub-tables of the unique (Unique Secondary Index - USI) and non-unique (Non-unique Secondary Index - NUSI) secondary indexes differ. <br><br>  <b>USI index sub-table row format</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/741/2e4/36d/7412e436db651f763b035f2909750324.jpg"><br><br>  The rows of the USI index sub-table are distributed across the AMPs using the index hashing result.  With high probability, the row of the index table will be on a different one with respect to the corresponding row of the base table AMP.  Each row in the base table corresponds to a row in the index sub-table.  Access to data using USI requires the involvement of two AMPs (the first to search for the row in the index, the second to read the row of the base table by its identifier).  Data access using USI can be considered as effective as using a primary index.  The main purpose of USI is data access by index column value.  In the same way, as for the primary index, in the expression "WHERE" ALL columns should be specified that make up the index with the condition "EQUAL". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25c/e20/27d/25ce2027dab1f49be85cda6a766a42ed.jpg"><br><br>  <b>NUSI index sub-table row format</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9a/977/143/f9a977143b8700fe1b20ab8d648cd927.jpg"><br><br>  The rows of the index sub-table NUSI are located locally (on the same AMPs) with respect to the rows of the base table and are logically sorted by default by the hash value of the secondary index column.  Such storage means that the rows with the same value of the index column can be found on any of the AMPs of the system, and, therefore, all AMPs will be involved in the search for the required rows in the index subtable.  Further, to select rows from the base table, only those AMPs will be used, on which the rows of the index sub-table are selected.  Whether the optimizer will use NUSI for data access depends on the selectivity of the index.  As a value, above which the optimizer chooses a full table scan, you can rely on 1% (if, when executing the query, less than 1% of the table rows are selected, the index will be used).  The rule from this follows: collect statistics on NUSI, without them the optimizer will select FTS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c3/c2a/17a/5c3c2a17a37f42bc24f8285529f8db88.jpg"><br><br>  As in the case of PI and USI, by default NUSI is used to access rows by value (the ‚ÄúEQUAL‚Äù condition on all NUSI columns in the ‚ÄúWHERE‚Äù expression).  But besides this, NUSI can also be used for queries with range access to rows of a table, for which there is an option ‚ÄúORDER BY VALUES‚Äù, which logically sorts the rows of the index sub-table by the value of the index column.  The index created in such a way allows to increase the performance with the conditions on the index column different from "EQUAL": &lt;,&gt;,&gt; =, &lt;=, BETWEEN. <br><br>  Also, as you can see from the format of the row of the index sub-table, there can be more than one RowID of the base table per index column value.  This makes the index sub-table NUSI automatically compressible, which minimizes the used disk space. <br><br>  <b>Full table scan (Full Table Scan, or FTS)</b> <br>  There is nothing to say about this access method.  Teradata uses it in cases where other data access paths, from the point of view of the optimizer, are inefficient.  I just want to note that the search for strings through a full scan in Teradata is very effective thanks to the MPP architecture, since many AMPs simultaneously scan distributed table fragments.  Often, a complete reading of tables containing millions of rows requires each AMP to perform only a few I / O operations. <br><br>  Concluding this review of access to the data of the primary / secondary index tables, we would like to note that Teradata, in the presence of alternatives, will always prefer the primary index to the secondary and unique to the non-unique one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/941/fc4/e1e/941fc4e1e5ec71f0f31c75cf726b81db.jpg"><br><br>  1. The optimizer prefers the primary index to the secondary index, and the unique indexes - non-unique.  NUPI will be given preference only if one data block (1 I / O) is requested. <br>  2. Depending on the selectivity, the optimizer may use NUSI, NUSI Bit Mapping or FTS. <br>  3. It all depends on the selectivity of the index. <br><br><h5>  Access with join of tables </h5><br>  Another way to access data is to join two or more tables.  This process has one very important feature specific to MPP platforms.  It lies in the fact that the connection tables are AMP'ami, and the data involved in the connection must be on the corresponding AMP'ah. <br>  As you remember, the distribution of rows of the table by AMPs depends on the primary index, and the rows of the joined tables with the same values ‚Äã‚Äãof the connection column are not always located on the same AMPs.  Therefore, it is not always, but often, a table join is preceded by a preparatory operation.  An exception is the combination of two tables on the primary index column, since in this case the rows with the same values ‚Äã‚Äãof the primary index columns are already on the same AMP.  Joining tables by PI column is the fastest. <br><br>  In all other cases, to perform a table join, Teradata can ensure that there are rows on the same AMP with the same value of the join column in the following ways (important: all derived data sets are materialized in SPOOL - the temporary storage area for intermediate query results): <ul><li>  duplication of rows of a small table for all amps; </li><li>  reallocation of rows of one / both tables of a join step by a connection column (change of PI).  In this case, the table itself remains in place, and a temporary copy of the rows that participate in the query (not necessarily the entire table) is created, with a different primary index. <br>  Which of the above methods will be chosen by the optimizer depends on the data demographics, the availability of collected statistics and indexes (Teradata may use certain types of indices, for example, NUSI, to improve the performance of the compounds). </li></ul><br>  When the availability of the necessary data on the AMPs is assured, Teradata can use traditional table join strategies such as: <ul><li>  MERGE JOIN: <ul><li>  Row Hash; </li><li>  Inclusion; </li><li>  Exclusion; </li></ul></li><li>  PRODUCT JOIN; </li><li>  NESTED JOIN; </li><li>  HASH JOIN. </li></ul><br><br><h4>  What you need to have to perform high-quality physical design </h4><br><h5>  Logical model </h5><br>  Directly physical modeling is traditionally preceded by the creation of a logical model, which later serves as a template for creating database objects.  The structure of a good logical model can be implemented in a one-to-one database. <br>  For corporate data warehouses, the logical model is a description of all the business processes of an organization.  It should be implemented in such a way as to not only solve existing business problems, but also support its further development.  Creating such a model from scratch is a very nontrivial and time-consuming task, requiring excellent knowledge of the subject area and modeling techniques.  In this article, we will not discuss issues of logical modeling; we only note that in our projects we try to use the industry-specific Teradata logical models tested by time and numerous implementations.  To those who consider Western models unsuitable for use on the Russian market, we can say that in practice the scope of localization (or, better to say, the adaptation of the model to customer processes, since organizations with identical processes are rarely found) is small and often reduces to the expansion of the attribute structure entities already in the model. <br><br><h5>  Data </h5><br>  No, you can, of course, model ‚Äúin vacuum‚Äù, but for the physical model it is extremely important to have data before your eyes that will later be loaded into the model.  This allows you to make decisions about how to move from a logical model to a physical one.  Some believe that the one-to-one physical model corresponds to the logical one, but this is far from always the case.  For example, as a result of data analysis, it may be decided to implement several entities of the logical data model in the form of a single table in a physical table.  And this is just one example. <br><br><h5>  Demographics </h5><br>  No matter how good the logical model may be, it is not enough just a set of entities and relationships to perform a high-quality physical design ‚Äî an understanding of the specifics of the data and the nature of their use is necessary.  Usually we analyze several demographics: <ul><li>  data demographics ‚Äî data volumes, frequency diagrams, etc .; </li><li>  demography of variability - how often data changes in a particular column of the table; </li><li>  Usage demographics ‚Äî whether columns are used to access data by value (single or range of values) or by connection. </li></ul><br>  Knowledge of the above demographics allows the creator of a physical model to make a choice consciously. <br>  Obviously, not all of these demographics are known before using the model.  In particular, the methods of accessing data and the frequency of accessing one or another column of the model at 100% 99% can only be learned after a long period of storage operation.  But a fairly large number of access methods can be thought out in advance, based on the implementation logic of the model itself. <br><br><h5>  Patience and attentiveness </h5><br>  Physical modeling is a fascinating process, but not always clearly algorithmic.  Paraphrasing the character of a famous Soviet cartoon: "Physical modeling is not an exact science."  On the one hand, this provides opportunities for creativity, on the other hand, it takes time, care and, often, an iterative approach, so attention to detail and patience when working with large data models play a key role in physical modeling. <br><br><h4>  Index selection </h4><br>  Indices are often used as one of the main ways to optimize the physical model for certain patterns of use.  Sometimes the choice of indexes may seem obvious.  Let's look at an example where the obvious is not always true. <br>  Imagine the following table: ACCOUNT (1,000,000 lines) <br><table border="1"><tbody><tr><td>  <b>Acct_id</b> </td><td>  <b>Acct_num</b> </td><td>  <b>Acct_open_dt</b> </td><td>  <b>Acct_close_dt</b> </td><td>  <b>Acct_pty_id</b> </td></tr><tr><td>  PK </td><td>  NOT NULL, UNIQUE </td><td>  NOT NULL </td><td></td><td>  NOT NULL, FK </td></tr><tr><td>  UPI </td><td>  USI </td><td>  Nusi </td><td>  NUSI? </td><td>  Nusi </td></tr></tbody></table><br>  The third line contains the intended choice of indexes. <br>  Legend: <ul><li>  UPI (Unique Primary Index) </li><li>  NUPI (Non-Unique Primary Index) </li><li>  USI (Unique Secondary Index) </li><li>  NUSI (Non-Unique Secondary Index) </li></ul><br>  Can you say with certainty that this choice is the right one?  I think that the experience of creating physical models for a particular DBMS can suggest the right choice, but in the general case it cannot be said that the choice made is correct.  Speaking about the example presented above, you can, for example, ask yourself whether a search is performed in this table by account identifier?  If the answer is no, you can exclude the Acct_id column from the candidates for the primary index. <br>  A simple example shows that even the best logical model is not enough to create a physical model.  An understanding of the data demographics is required (see above).  Let's add the demographics to the example above and see if this makes it easier. <br>  Same ACCOUNT table (1,000,000 rows) <br><table border="1"><tbody><tr><td rowspan="2"></td><td>  <b>Acct_id</b> </td><td>  <b>Acct_num</b> </td><td>  <b>Acct_open_dt</b> </td><td>  <b>Acct_close_dt</b> </td><td>  <b>Acct_pty_id</b> </td></tr><tr><td>  PK </td><td>  NOT NULL, UNIQUE </td><td>  NOT NULL </td><td></td><td>  NOT NULL, FK </td></tr><tr><td>  Frequency of access by value </td><td>  800 </td><td>  10K </td><td>  1K </td><td>  500 </td><td>  1K </td></tr><tr><td>  Connection Frequency </td><td>  3K </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  5K </td></tr><tr><td>  Number of unique lines </td><td>  1000K </td><td>  1000K </td><td>  731 </td><td>  256 </td><td>  400K </td></tr><tr><td>  Max.  number of lines per value (non-NULL) </td><td>  one </td><td>  one </td><td>  2056 </td><td>  1K </td><td>  7 </td></tr><tr><td>  Typical number of lines per value </td><td>  one </td><td>  one </td><td>  1235 </td><td>  400 </td><td>  2 </td></tr><tr><td>  Number of lines with NULL </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  900K </td><td>  0 </td></tr><tr><td>  Intended choice </td><td>  <s>UPI</s> </td><td>  USI </td><td>  Nusi </td><td>  Nusi </td><td>  <s>Nusi</s> </td></tr><tr><td>  Select based on demographics </td><td>  Nusi </td><td>  USI </td><td>  Nusi </td><td>  NUSI? </td><td>  NUPI </td></tr></tbody></table><br>  As you can see, the initial selection of indexes has been changed.  There are quite objective reasons for this: <ul><li>  For Acct_pty_id column <br>  Access by primary index is the most effective method of accessing data in Teradata.  As we see from the example, access by the value of this column occurs frequently.  In addition, the same column is most often used to connect to another table.  Joining two tables along primary index columns is also most preferable for Teradata. </li><li>  For Acct_id column <br>  This column is also used for access quite often.  Since the choice of the primary index has already been made, we can create a non-unique secondary index for the most efficient reading of the rows of the table by value and improving the performance of the connections. </li><li>  For Acct_close_dt column <br>  The choice of the index is questioned due to the fact that at certain values ‚Äã‚Äã(NULL) Teradata will not use it due to insufficient selectivity. </li></ul><br><h4>  Partitioning tables in Teradata </h4><br>  If the table is large in size, then the natural desire is to break it into parts (partitions) and scan only these partitions instead of a full view of the table. <br>  In Teradata, the following two mechanisms ‚Äî distribution across AMPs and partitioning ‚Äî effectively complement each other.  Partitioned tables are distributed by AMPs in the same way as nonpartitioned tables.  Further, on each AMP, the lines are ordered first by partitions, and the part numbers are written into the master index and cylinder index for addressing data blocks.  And then, within the partitions, the rows are already sorted by the hash values ‚Äã‚Äãof the primary index, as well as for nonpartitioned tables. <br>  Thus, if we launch a query of the form ‚ÄúBETWEEN value_1 AND value2‚Äù of the column_partitioning, then all AMPs work in parallel and scan each fragment of the table, but not completely, but only the necessary partitions. <br>  There is also a multi-level partitioning, when there are several columns, and subpartitions are created inside the partitions. <br>  All large tables are usually partitioned.  This physical design technique can improve the performance of certain queries that have filtering by partitioning fields. <br><br><h4>  Conclusion </h4><br>  In this article, we decided to limit ourselves to the description of the basic principles and elements used in the implementation of the physical database design for the Teradata DBMS.  Using only these practices in the work will allow those who are just starting to work with massively parallel DBMSs not to step on the ‚Äúrake‚Äù at the very beginning of the journey. <br>  In the next article, ‚ÄúAdditional Physical Modeling Techniques in Teradata,‚Äù we plan to tell you about additional features for indexing and compressing data in Teradata. <br>  We are waiting for your questions. </div><p>Source: <a href="https://habr.com/ru/post/209208/">https://habr.com/ru/post/209208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209196/index.html">To implement an ERP system in production</a></li>
<li><a href="../209198/index.html">How I did a tester optimizer for finding profitable strategies on the stock exchange</a></li>
<li><a href="../209202/index.html">Scaling is simple</a></li>
<li><a href="../209204/index.html">Blackphone: the first smartphone, protected from listening</a></li>
<li><a href="../209206/index.html">Build Android under Ubuntu Linux</a></li>
<li><a href="../209210/index.html"><Extended until February 27!> We are announcing a competition to develop a layout for a 3d kidney print.</a></li>
<li><a href="../209212/index.html">Migrating virtual machines on the fly without vMotion with Veeam Backup & Replication</a></li>
<li><a href="../209214/index.html">Today is the last day when you can use free coupons on COLT</a></li>
<li><a href="../209216/index.html">Additional physical modeling techniques in Teradata</a></li>
<li><a href="../209218/index.html">The best time to learn microcontrollers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>