<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Evaluation of the possibility of post-processing video in the browser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, video post-processing in runtime is becoming increasingly important - thanks to the power of modern PCs, almost every user can skip a video ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Evaluation of the possibility of post-processing video in the browser</h1><div class="post__text post__text-html js-mediator-article">  Recently, video post-processing in runtime is becoming increasingly important - thanks to the power of modern PCs, almost every user can skip a video sequence through a complex chain of filters while watching, thereby eliminating the need for full video encoding, often produced using <a href="http://avisynth.nl/index.php/Main_Page">slow and overcomplicated tools</a> . <br><br>  This area is pretty well covered in the desktop environment - filters like the <a href="http://sourceforge.net/projects/ffdshow-tryout/">ffdshow raw video filter</a> and <a href="http://forum.doom9.org/showthread.php%3Ft%3D146228">madVR</a> allow you to do almost everything that you may need for a pleasant viewing.  Unfortunately, the web cannot boast a similar toolkit, and you either enjoy all the shortcomings of the next video on YouTube, or open it in an external application like <a href="http://sourceforge.net/projects/mpcbe/">MPC-BE</a> , which is not very convenient.  And it would be nice to have one magic button that activates filtering in the place where it should be - in your browser. <br><br>  This post is a brief report on my research in this area, where the ultimate goal was to assess the possibility of filtering in real time at a resolution of at least 1920x1080. <br><a name="habracut"></a><br><h4>  Remarks </h4><br>  While reading the article should be considered: <br><ol><li>  All these demonstrations are based on html5 video with the loop attribute set.  This video can terribly twitch and lag during switching to the beginning of the video sequence in some browsers, <a href="https://stackoverflow.com/questions/17930964/video-element-with-looping-does-not-loop-videos-seamlessly-in-chrome-or-firefo">due to the fault of these browsers</a> .  I did not over-complicate the code for the sake of possibly correcting this problem. </li><li>  If the repeated video annoys you, you can add loop = false to the GET parameters of the request. </li><li>  Demos were tested only in chrome, fox and IE11, in other browsers may not work. </li><li>  The source code of all the demos is shown right inside the corresponding html pages, without dependencies. </li><li>  The text has many warped English words and clumsy translations.  I am not well versed in Russian terminology, corrections are welcome. </li><li>  We turn a blind eye to possible problems with CORS, sites using Flash-video, etc.  Only spherical tests in a vacuum. </li><li>  In JavaScript, I'm passing through, so do not trust too much the text below.  For more confidence, you can divide the given time by 2. I hope to see fixes and tips in the comments. </li></ol><br><h4>  Principles of implementation </h4><br>  The only option that would allow one core for all target browsers (Chrome and Firefox in the first place) is a browser extension.  The alternative in the form of <a href="https://developer.chrome.com/native-client">Google Chrome Native Client</a> , suddenly, only works in Chrome, and Mozilla is not currently going to support NaCl in Firefox.  In addition, I have not studied the possibility of accessing NaCl to elements on the page - it may well turn out that for our purposes it will not work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The basic algorithm of the (theoretical) expansion is quite simple: look for the video element on the page, hide it, and create a canvas above, on which the filtered frames of the video stream are rendered.  So far, everything is simple. <br><br>  The real problem with an extension is the implementation language ‚Äî interpreted JavaScript, and as we know, interpreted languages ‚Äã‚Äãare poorly suited for serious calculations.  But this does not matter!  JavaScript recently receives a lot of love and optimizations, and there are quite a large number of programmers who consider that JS is a language suitable for writing any applications and that everything should move on the web.  Moreover, many new technologies are available, such as asm.js, SIMD.js, WebGL and WebCL, which, in theory, allow you to implement everything your heart desires, with a speed that is only slightly less than native.  So we shouldn't have any major problems with writing a filter set in the browser, right? <br><br>  Not really. <br><br><h4>  Clean javascript </h4><br>  Filtering in pure JS works as follows: <br><ol><li>  We get both necessary elements - hidden video and canvas, located on top of it. </li><li> We draw a frame from the video on the canvas via <code>context.drawImage(video, 0, 0)</code> , where context is the 2d context obtained from the canvas. </li><li>  Get the frame buffer (array of color bytes) via <code>context.getImageData(0, 0, width, height)</code> . </li><li>  We process the buffer with the required filters. </li><li>  We put the processed array back through <code>context.putImageData(imageData, 0, 0)</code> . </li></ol><br>  This algorithm works and allows real video filtering in pure JavaScript with a minimal amount of code very similar to C.  This is the basic (non-optimized) implementation of an invert filter that inverts RGB bytes in each pixel of a frame: <br><pre> <code class="javascript hljs">outputContext.drawImage(video, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageData = outputContext.getImageData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = imageData.data; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = source.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { source[i ] = <span class="hljs-number"><span class="hljs-number">255</span></span> - source[i]; source[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span> - source[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; source[i+<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span> - source[i+<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//   } outputContext.putImageData(imageData, 0, 0);</span></span></code> </pre><br>  And although this method works for demos and simple images, it is very quickly ‚Äúblown away‚Äù at high resolutions.  Although the call to <code>drawImage</code> is <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dnone">pretty fast even at 1080p</a> , after adding <code>getImageData</code> and <code>putImageData</code> <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dcopy">, the execution time rises to 20-30 milliseconds per iteration</a> .  The full code given above is <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dinvert">executed in 35-40ms already</a> , which is the speed limit for PAL video (25 frames per second, 40ms per frame).  All measurements obtained at 4770k, which is one of the most powerful home processors at the moment.  This means that the implementation of any more or less complex filter on previous generations of processors is impossible <strong>, regardless of the performance of JavaScript</strong> .  Any, even very fast code, will rest on the terrible performance of the canvas itself. <br><br>  But JavaScript is not very fast on its own.  Although normal operations like inverting or running through LUT can be performed in a reasonable time, any more or less complex filter causes terrible lags.  <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dnoise">A simple implementation of the filter for adding noise</a> (Math.random () * 10 to each pixel) requires 55 milliseconds, and the <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dblur">3x3 core for blur</a> , implemented in the code below, takes 400ms, or 2.5 frames per second. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blur</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blur_core</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ptr, offset, stride</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ptr[offset - stride - <span class="hljs-number"><span class="hljs-number">4</span></span>] + ptr[offset - stride] + ptr[offset - stride + <span class="hljs-number"><span class="hljs-number">4</span></span>] + ptr[offset - <span class="hljs-number"><span class="hljs-number">4</span></span>] + ptr[offset] + ptr[offset + <span class="hljs-number"><span class="hljs-number">4</span></span>] + ptr[offset + stride - <span class="hljs-number"><span class="hljs-number">4</span></span>] + ptr[offset + stride] + ptr[offset + stride + <span class="hljs-number"><span class="hljs-number">4</span></span>] ) / <span class="hljs-number"><span class="hljs-number">9</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stride = width * <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>; y &lt; (height - <span class="hljs-number"><span class="hljs-number">1</span></span>); ++y) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offset = y * stride; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x &lt; stride - <span class="hljs-number"><span class="hljs-number">4</span></span>; x += <span class="hljs-number"><span class="hljs-number">4</span></span>) { source[offset] = blur_core(source, offset, stride); source[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] = blur_core(source, offset + <span class="hljs-number"><span class="hljs-number">1</span></span>, stride); source[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] = blur_core(source, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>, stride); offset += <span class="hljs-number"><span class="hljs-number">4</span></span>; } } }</code> </pre> <br>  Firefox shows even more depressing results with 800 ms / pass.  Interestingly, IE11 is even ahead of Chrome, and twice (but the canvas itself is slow, so it does not save).  In any case, it becomes clear that pure JavaScript is the wrong tool for implementing filters. <br><br><h4>  asm.js </h4><br>  Modern <a href="http://asmjs.org/">asm.js</a> is a tool from Mozilla to optimize the execution of JavaScript code.  The generated code will still work in chrome, but it‚Äôs not worth hoping for a serious performance increase, since <a href="https://code.google.com/p/v8/issues/detail%3Fid%3D2599">support for asm.js does not seem to have been added yet</a> . <br><br>  Unfortunately, I could not find a simple way to compile selected functions in asm.js-optimized code.  <a href="https://github.com/kripken/emscripten">Emscripten</a> generates about 4.5 thousand lines of code when compiling a simple two-line function, and I did not understand how you can get out of it only the necessary code in a reasonable time.  Writing asm.js with your hands is <a href="http://habrahabr.ru/post/193642/">still a pleasure</a> .  In any case, asm.js will rest on the performance of the 2d context of the canvas, similar to pure JavaScript. <br><br><h4>  SIMD.js </h4><br>  <a href="https://01.org/blogs/tlcounts/2014/bringing-simd-javascript">SIMD.js</a> is a very new technology of manual optimization of JS applications, which is currently ‚Äúsupported‚Äù only in <a href="https://nightly.mozilla.org/">Firefox Nightly</a> , but very soon it <a href="http://www.phoronix.com/scan.php%3Fpage%3Dnews_item%26px%3DMTY0ODE">can get support from all target browsers</a> .  Unfortunately, the API now <a href="http://www.2ality.com/2013/12/simd-js.html">works with only two data types</a> , float32x4 and uint32x4, which makes the whole project useless for most real 8-bit filters.  Moreover, the Int32x4Array type is not yet implemented even in Nightly, so any recording and reading of data from memory will be slow and scary (when implemented <a href="">in this way</a> ).  However, I‚Äôll give the implementation code for the normal invert filter (this time working through XOR): <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert_frame_simd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fff = SIMD.int32x4.splat(<span class="hljs-number"><span class="hljs-number">0x00FFFFFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = source.length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> int32 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint32Array</span></span>(source.buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src = SIMD.int32x4(int32[i], int32[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], int32[i+<span class="hljs-number"><span class="hljs-number">2</span></span>], int32[i+<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = SIMD.int32x4.xor(src, fff); int32[i+<span class="hljs-number"><span class="hljs-number">0</span></span>] = dst.x; int32[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = dst.y; int32[i+<span class="hljs-number"><span class="hljs-number">2</span></span>] = dst.z; int32[i+<span class="hljs-number"><span class="hljs-number">3</span></span>] = dst.w; } }</code> </pre> <br>  At the moment, the code above is running much slower than pure JS - 1600ms / pass (Nighly users can try the next <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3Dsimd">demo</a> ).  It looks like you have to wait a sufficient amount of time before you can do anything useful with this technology.  Unfortunately, it is not clear how support for 256-bit YMM registers will be implemented (int32x4 is the usual 128-bit xmm from SSE2), and whether instructions from newer technologies like SSSE3 will be available.  Well, SIMD.js does not save from slow canvas.  But SIMD fans can already get some <a href="http://tp7.github.io/articles/javascript-video-filtering/pure.html%3Ffilter%3DbuggySimd">familiar bugs</a> right now in the browser! <br><br><h4>  Webgl </h4><br>  A completely different way to implement filters is <a href="https://en.wikipedia.org/wiki/WebGL">WebGL</a> .  In the most basic sense, WebGL is a JS interface for native OpenGL technology, which allows you to execute various code on the GPU.  It is usually used for programming graphics in games, etc., but no one bothers to process <a href="http://www.html5rocks.com/en/tutorials/webgl/webgl_fundamentals/">pictures</a> or even <a href="http://seriouslyjs.org/">video</a> with it.  WebGL also does not require calls to getImageData, which in theory makes it possible to avoid a typical 20ms lag. <br><br>  But nothing is free - WebGL is not a general-purpose tool and using this API for abstract non-graphic code is a terrible pain.  You will need to define useless vertices (which will always cover the entire frame), correctly position the texture (which will cover the entire frame), and then <a href="https://developer.mozilla.org/en-US/docs/Web/WebGL/Animating_textures_in_WebGL">use the video as a texture</a> .  Fortunately, WebGL is smart enough to request the necessary frames from the video machine.  At least in chrome and fox.  IE11 will be <code>WEBGL11072: INVALID_VALUE: texImage2D: This texture source is not supported</code> error <code>WEBGL11072: INVALID_VALUE: texImage2D: This texture source is not supported</code> . <br><br>  Finally, writing filters will have to use shaders implemented in the <a href="">slightly flawed</a> GLSL language, which (at least in the WebGL variant) does <a href="https://stackoverflow.com/questions/15262729/const-float-array-in-webgl-shader">not</a> even <a href="https://stackoverflow.com/questions/15262729/const-float-array-in-webgl-shader">support the installation of constant arrays</a> , so any arrays will either have to be passed using uniforms (such global variables) or use the Indian method: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> core1[<span class="hljs-number"><span class="hljs-number">9</span></span>]; core1[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; core1[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>;</code> </pre> <br>  It also requires that the pixel shader return a single value ‚Äî the color of the current pixel, which makes it impossible for a typical implementation of some filters to process several pixels per iteration (the same blocking suppression).  Such filters will have to be rethought and implemented differently. <br><br>  In general, technologies like CUDA and OpenCL were not invented from a good life. <br><br>  As a WebGL excuse, it has performance <a href="https://stackoverflow.com/questions/20798294/is-it-possible-to-measure-rendering-time-in-webgl-using-gl-finish">that</a> is truly amazing for the web ( <a href="https://stackoverflow.com/questions/20798294/is-it-possible-to-measure-rendering-time-in-webgl-using-gl-finish">which you cannot measure</a> ).  At the very least, it can process the prewitt filter from <a href="http://manao4.free.fr/mt_masktools.html">masktools</a> (the choice of the maximum value from four 3x3 cores) in real time <a href="http://tp7.github.io/articles/javascript-video-filtering/webgl.html">at 1080p</a> and higher.  If you hate yourself and are not afraid to get a little unsupported code, WebGL allows you to do quite interesting things with the video.  It may be more reasonable to use the library <a href="http://seriouslyjs.org/">seriously.js</a> , which hides part of the template WebGL code, but may not be sufficiently advanced to handle changes in the video resolution or implement temporary filters. <br><br>  If you love yourself, then most likely you will want to use something like WebCL. <br><br><h4>  Webcl </h4><br>  But it will not work.  Wikipedia <a href="https://en.wikipedia.org/wiki/WebCL">says</a> that WebCL 1.0 was finalized on March 19th of this year, which makes technology the youngest of the entire list, even younger than SIMD.js.  And, unlike SIMD.js, it <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D664147">will not be supported in Firefox in the near future</a> .  I read somewhere about a similar solution for Chrome, but lost the link.  So WebCL is currently dead technology with no clear future. <br><br><h4>  Conclusion </h4><br>  Processing real-time video in a browser is possible, but the only working option now is to use WebGL, where video filter programming is an exercise worthy of real masochists.  All other methods rest on the terrible performance of 2d context of canvas, and they themselves do not shine with execution speed.  Such sad things. </div><p>Source: <a href="https://habr.com/ru/post/221619/">https://habr.com/ru/post/221619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221609/index.html">"My Tetris - werewolf 2" or investigating Tetris from another series</a></li>
<li><a href="../221611/index.html">Where to go with your Indie-project and show it to the people?</a></li>
<li><a href="../221613/index.html">What is the IT community?</a></li>
<li><a href="../221615/index.html">To hide the pregnancy from marketing companies, a woman used Tor</a></li>
<li><a href="../221617/index.html">50 years of BASIC!</a></li>
<li><a href="../221621/index.html">The smallest pen for 3D drawing</a></li>
<li><a href="../221623/index.html">L√°zaro Campos became a member of the Payoneer Advisory Committee</a></li>
<li><a href="../221639/index.html">Computer of 10,000 Domino Bones</a></li>
<li><a href="../221645/index.html">Headphone Overview Marshall Major</a></li>
<li><a href="../221647/index.html">Selling apps on Google Play from Ukraine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>