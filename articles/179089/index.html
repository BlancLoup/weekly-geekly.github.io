<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Something more complicated factorial</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time, when the grass was greener and the trees above, there lived a troll named Xenocephal. He lived, in principle, in many places, but I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Something more complicated factorial</h1><div class="post__text post__text-html js-mediator-article">  Once upon a time, when the grass was greener and the trees above, there lived a troll named Xenocephal.  He lived, in principle, in many places, but I was lucky to meet him in one <a href="http://www.sql.ru/forum/afsearch.aspx%3Fs%3DXenocephal">forum</a> , where I, at that time, had gained a mind-mind.  I don‚Äôt remember the topic in which the conversation took place, but its essence was that Xenocephal tried to convince everyone around him that Lisp (with its macros) was a head, and C ++, with its templates, was a pitifully similar to the left hand.  It was also argued that it was impossible to program in it something more complex than the scabbling <a href="http://www.solarix.ru/for_developers/cpp/snippets/factorial.shtml">factorial</a> . <br><a name="habracut"></a><br>  In principle, I did not have any objections that Lisp macros are incredibly cool and, at that time, I had nothing to answer, but the phrase about C ++ templates and factorial went deep into my fragile brain and continued to torment me from the inside.  And on one terrible day, I thought, ‚ÄúWhat the hell ???  Let's pometaprogram! ‚Äù <br><br>  Another source of inspiration was the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580%25D1%258B:_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF%25D1%258B,_%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B8_%25D0%25B8_%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B">Book of the Dragon</a> .  The task was found quickly.  I found that the transformation of the Non-deterministic State Machine ( <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">NCA</a> ) to the Deterministic State Machine ( <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">DCA</a> ) is nontrivial enough to try to implement it using C ++ templates.  The imperishable <a href="http://www.proklondike.com/books/cpp/alexandresku_cpp_modern_design.html">work of</a> Alexandrescu allowed him to gain a critical mass ... <br><br>  I began, of course, with primitives.  I needed to somehow represent the graphs: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Src</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dst</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chr</span></span></span><span class="hljs-class"> = 0&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Edge</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Source = Src, Dest = Dst, Char = Chr }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T Next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%3d -%c-&gt; %3d\n"</span></span>,Src,Chr,Dst);T::Dump();} };</code> </pre> <br>  The arc of the graph was specified by indices of the initial (Src) and final (Dst) vertices and could be named with the symbol (Chr).  Non-named arcs (used by the transformation algorithm) are, by default, marked with a null symbol.  The type Next defined in this template turned it into a type list.  The addition of an arc to this list was implemented in the following recursive manner: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>);}}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddEdge</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddEdge</span></span></span><span class="hljs-class">&lt;S,D,C,NullType,R&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;R,S,D,C&gt; Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddEdge</span></span></span><span class="hljs-class">&lt;S,D,C,Edge&lt;T,S,D,C&gt;,R&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddEdge&lt;S,D,C,T,R&gt;::Result Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddEdge</span></span></span><span class="hljs-class">&lt;S,D,C,Edge&lt;T,s,d,c&gt;,R&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddEdge&lt;S,D,C,T,Edge&lt;R,s,d,c&gt; &gt;::Result Result; };</code> </pre><br>  Similarly, the merging of lists was organized (thanks to duck typing, any, and not just those that represent columns): <br><br><div class="spoiler">  <b class="spoiler_title">Append</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class">&lt;NullType,T&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Append</span></span></span><span class="hljs-class">&lt;Edge&lt;T,S,D,C&gt;,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;T,Edge&lt;B,S,D,C&gt; &gt;::Result Result; };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Join</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">&lt;NullType,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> B Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">&lt;Set&lt;N,T&gt;,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Join&lt;T,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddSet&lt;N,B,NullType&gt;::Result&gt;::Result Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> D, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">&lt;Edge&lt;T,S,D,C&gt;,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Join&lt;T,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddEdge&lt;S,D,C,B,NullType&gt;::Result&gt;::Result Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">&lt;StateList&lt;N,S,T&gt;,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Join&lt;T,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddState&lt;N,S,B,NullType&gt;::Result&gt;::Result Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Src, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Dst, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Join</span></span></span><span class="hljs-class">&lt;StateListEx&lt;Src,Dst,a,S,T&gt;,B&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Join&lt;T,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddState&lt;Dst,S,B,NullType&gt;::Result&gt;::Result Result; };</code> </pre><br></div></div><br>  ... and applying an arbitrary functor to each element of the list: <br><br><div class="spoiler">  <b class="spoiler_title">Map</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> &lt;int,int&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> V, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> &lt;int,int&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;NullType,V,R,F&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> R Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> &lt;int,int&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;Set&lt;N,T&gt;,V,R,F&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;T,V,Set&lt;F&lt;N,V&gt;::Result,R&gt;,F&gt;::Result Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> &lt;int,int&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;Edge&lt;T,S,D,C&gt;,V,R,F&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;T,V,Edge&lt;R,F&lt;S,V&gt;::Result,F&lt;D,V&gt;::Result,C&gt;,F&gt;::Result Result; };</code> </pre><br></div></div><br>  Now, it was required to implement the construction of an NCA based on a regular expression.  The very method of this construction is well described in the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580%25D1%258B:_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF%25D1%258B,_%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B8_%25D0%25B8_%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B">book</a> mentioned above and boils down to the fact that the elements of the regular expression are replaced by some basic constructs connected by unnamed arcs. <br><br>  A named arc is created elementarily: <br><br><div class="spoiler">  <b class="spoiler_title">C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Chr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;NullType,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,Chr&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = <span class="hljs-number"><span class="hljs-number">2</span></span>}; };</code> </pre><br></div></div><br>  The initial and final vertices are indices 0 and 1, respectively. <br><br>  Two graphs can be connected to the construction of alternatives / A | B / as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3a/24e/a15/b3a24ea1579290fff5301a212f7bed24.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">D</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Result = X+N }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A::Result, <span class="hljs-number"><span class="hljs-number">2</span></span>, NullType, Add&gt;::Result, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> B::Result, A::Count+<span class="hljs-number"><span class="hljs-number">2</span></span>, NullType, Add&gt;::Result &gt;::Result N0; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N0,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; N1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N1,<span class="hljs-number"><span class="hljs-number">0</span></span>,A::Count+<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; N2; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N2,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; N3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N3,A::Count+<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = A::Count+B::Count+<span class="hljs-number"><span class="hljs-number">2</span></span>}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DImpl&lt;T1, D&lt;T2,T3,T4,T5&gt; &gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&lt;T1,T2,NullType,NullType,NullType&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DImpl&lt;T1,T2&gt; {};</code> </pre><br></div></div><br>  Here, we ‚Äúmerge‚Äù two input graphs (A and B) (while their vertices are renumbered), after which, we connect them with unnamed arcs, according to the scheme given above.  The initial and final vertices still have indices 0 and 1, respectively. <br><br>  The implementation of the following / AB / was somewhat more difficult to understand: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0d/c49/c21/d0dc49c212c30951d572b092fda0dddf.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">E</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConvA</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Result = (X==<span class="hljs-number"><span class="hljs-number">1</span></span>) ? (X+N<span class="hljs-number"><span class="hljs-number">-1</span></span>) : X }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConvB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Result = (X==<span class="hljs-number"><span class="hljs-number">1</span></span>) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : (X+N) }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A::Result, A::Count, NullType, ConvA&gt;::Result A1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> B::Result, A::Count, NullType, ConvB&gt;::Result B1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;A1,B1&gt;::Result Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = A::Count+B::Count}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EImpl&lt;T1, E&lt;T2,T3,T4,T5&gt; &gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&lt;T1,T2,NullType,NullType,NullType&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EImpl&lt;T1,T2&gt; {};</code> </pre><br></div></div><br>  Here, additional arcs are not constructed, and the graphs are connected by a common vertex (starting at B and ending at A). <br><br>  The implementation of the quantifier / T * / turned out to be the most difficult: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/c9f/bc9/8ccc9fbc9324547cbafb5a6a9d0a1fc5.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Q</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Min</span></span></span><span class="hljs-class"> = 0, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> = 0&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class"> {</span></span> Q() {STATIC_ASSERT(Min&lt;=Max, Q_Spec);} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::Result, T::Count, NullType, ConvA&gt;::Result A1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Q&lt;T,Min,Max<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::Result,T::Count,NullType,ConvB&gt;::Result B1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;A1,B1&gt;::Result,<span class="hljs-number"><span class="hljs-number">0</span></span>,T::Count&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = T::Count+Q&lt;T,Min,Max<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::Count}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&lt;T,N,N&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::Result, T::Count, NullType, ConvA&gt;::Result A1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Q&lt;T,N<span class="hljs-number"><span class="hljs-number">-1</span></span>,N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::Result, T::Count, NullType, ConvB&gt;::Result B1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Append&lt;A1,B1&gt;::Result Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = T::Count+Q&lt;T,N<span class="hljs-number"><span class="hljs-number">-1</span></span>,N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::Count}; };</code> </pre><br></div></div><br>  Since the quantifiers / T * / and / T + / are quite common, their optimized implementations were overloaded: <br><br><div class="spoiler">  <b class="spoiler_title">Q</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&lt;T,1,1&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&lt;T,0,0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::Result,<span class="hljs-number"><span class="hljs-number">2</span></span>,NullType,Add&gt;::Result,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; N0; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N0,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; N1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N1,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; N2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;N2,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = T::Count+<span class="hljs-number"><span class="hljs-number">2</span></span>}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&lt;T,1,0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::Result,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = T::Count}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&lt;T,0,1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Edge&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::Result,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; Result; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> {Count = T::Count}; };</code> </pre><br></div></div><br>  Now, it was possible to assemble an NCA representing the regular expression / (a ‚Äã‚Äã| b) * abb / described in the book: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> E&lt; Q&lt; D&lt; C&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt; &gt; &gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt; &gt;::Result G;</code> </pre><br><br>  It remains to convert it to DKA: <br><br><div class="spoiler">  <b class="spoiler_title">DFA</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CONSTS { MAX_FIN_STATE = <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Graph</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DFAImpl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Src</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dst</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DFAImpl</span></span></span><span class="hljs-class">&lt;Edge&lt;T,Src,Dst,Chr&gt; &gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DFAImpl&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DFAImpl&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt;::ResultType ResultType; <span class="hljs-function"><span class="hljs-function">ResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((State==Src)&amp;&amp;(C==Chr)) { State = Dst; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (State&lt;MAX_FIN_STATE) { State = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtSucceed; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtNotCompleted; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DFAImpl&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt;::Parse(C); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{T::Dump();} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DFAImpl</span></span></span><span class="hljs-class">&lt;NullType&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: DFAImpl(): State(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ResultType { rtNotCompleted = <span class="hljs-number"><span class="hljs-number">0</span></span>, rtSucceed = <span class="hljs-number"><span class="hljs-number">1</span></span>, rtFailed = <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-function"><span class="hljs-function">ResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C)</span></span></span><span class="hljs-function"> </span></span>{ State = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtFailed; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> State; }; <span class="hljs-comment"><span class="hljs-comment">//   ( )   ( a==0 - e-) // N -  // T -  // R -   // a -   template &lt;int N, class T, class R, int a = 0&gt; struct Move; template &lt;int N, class R, int a&gt; struct Move&lt;N,NullType,R,a&gt; {typedef R Result;}; template &lt;int N, class T, int D, class R, int a&gt; struct Move&lt;N,Edge&lt;T,N,D,a&gt;,R,a&gt; { typedef typename Move&lt;N,T,typename AddSet&lt;D,R,NullType&gt;::Result,a&gt;::Result Result; }; template &lt;int N, int M, class T, int D, class R, int a, int b&gt; struct Move&lt;N,Edge&lt;T,M,D,b&gt;,R,a&gt; { typedef typename Move&lt;N,T,R,a&gt;::Result Result; }; //     F // T -   (Set, StateListEx) //  -    F // R -   (Set, StateListEx) // F -  (Exist, NotExist, Important) template &lt;class T, class C, class R, template &lt;int,class&gt; class F&gt; struct Filter; template &lt;class C, class R, template &lt;int,class&gt; class F&gt; struct Filter&lt;NullType,C,R,F&gt; {typedef R Result;}; template &lt;int N, class T, class C, class R, template &lt;int,class&gt; class F&gt; struct Filter&lt;Set&lt;N,T&gt;,C,R,F&gt; { typedef typename If&lt;F&lt;N,C&gt;::Result, typename Filter&lt;T,C,typename Set&lt;N,R&gt;,F&gt;::Result, typename Filter&lt;T,C,R,F&gt;::Result &gt;::Result Result; }; template &lt;int Src, int Dst, int a, class S, class T, class C, class R, template &lt;int,class&gt; class F&gt; struct Filter&lt;StateListEx&lt;Src,Dst,a,S,T&gt;,C,R,F&gt; { typedef typename If&lt;F&lt;Dst,C&gt;::Result, typename Filter&lt;T,C,typename StateListEx&lt;Src,Dst,a,S,R&gt;,F&gt;::Result, typename Filter&lt;T,C,R,F&gt;::Result &gt;::Result Result; }; //  e- // T -    // G -  // R -    template &lt;class T, class G, class R&gt; struct EClos; template &lt;class G, class R&gt; struct EClos&lt;NullType,G,R&gt; {typedef R Result;}; template &lt;int N, class T, class G, class R&gt; struct EClos&lt;Set&lt;N,T&gt;,G,R&gt; { private: typedef typename Move&lt;N,G,NullType&gt;::Result L; typedef typename Filter&lt;L,typename Append&lt;T,R&gt;::Result,NullType,NotExist&gt;::Result F; public: typedef typename EClos&lt;typename Append&lt;T,F&gt;::Result,G, typename Set&lt;N,R&gt; &gt;::Result Result; }; //      // T -  // G -  // R -   // a -   template &lt;class T, class G, class R, int a&gt; struct MoveSet; template &lt;class G, class R, int a&gt; struct MoveSet&lt;NullType,G,R,a&gt; {typedef R Result;}; template &lt;int N, class T, class G, class R, int a&gt; struct MoveSet&lt;Set&lt;N,T&gt;,G,R,a&gt; { typedef typename MoveSet&lt;T,G,typename Join&lt;R,typename Move&lt;N,G,NullType,a&gt;::Result&gt;::Result,a&gt;::Result Result; }; //   ,      // N -    // K -     // T -  // n -   // S -   (Set) // G -  // R -     template &lt;int N, int K, class T, int n, class S, class G, class R&gt; struct MoveList; template &lt;int N, int K, int n, class S, class G, class R&gt; struct MoveList&lt;N,K,NullType,n,S,G,R&gt; {typedef R Result;}; template &lt;int N, int K, int a, class T, int n, class S, class G, class R&gt; struct MoveList&lt;N,K,Set&lt;a,T&gt;,n,S,G,R&gt; { private: typedef typename MoveSet&lt;S,G,NullType,a&gt;::Result S0; typedef typename EClos&lt;S0,G,NullType&gt;::Result S1; enum { N1 = (NotExist&lt;1,S1&gt;::Result)?K:N }; public: typedef typename MoveList&lt;(N==N1)?(N+1):N, (K==N1)?(K+1):K, T,n,S,G, StateListEx&lt;n,N1,a,S1,R&gt; &gt;::Result Result; }; //      NFA (    ) // T -  // R -   template &lt;class T, class R&gt; struct Alf; template &lt;class R&gt; struct Alf&lt;NullType,R&gt; {typedef R Result;}; template &lt;class T, int S, int D, class R&gt; struct Alf&lt;Edge&lt;T,S,D,0&gt;,R&gt; { typedef typename Alf&lt;T,R&gt;::Result Result; }; template &lt;class T, int S, int D, int a, class R&gt; struct Alf&lt;Edge&lt;T,S,D,a&gt;,R&gt;{ typedef typename Alf&lt;T, typename AddSet&lt;a,R,NullType&gt;::Result&gt;::Result Result; }; //    // T -   (StateListEx) // R -    // F -  (Exist, NotExist) template &lt;class T, int R, template &lt;int,class&gt; class F&gt; struct Incr; template &lt;int R, template &lt;int,class&gt; class F&gt; struct Incr&lt;NullType,R,F&gt; {enum {Result = R};}; template &lt;int Src, int N, int a, class S, class T, int R, template &lt;int,class&gt; class F&gt; struct Incr&lt;StateListEx&lt;Src,N,a,S,T&gt;,R,F&gt; { enum { Result = Incr&lt;T, (F&lt;1,S&gt;::Result)?((N&gt;=R)?(N+1):R):R, F&gt;::Result}; }; //    // N -  // G -  template &lt;int N, class G&gt; struct Important; template &lt;int N&gt; struct Important&lt;N,NullType&gt; {enum {Result = (N==1)};}; template &lt;int N, class T, int D&gt; struct Important&lt;N,Edge&lt;T,N,D,0&gt; &gt; { enum { Result = Important&lt;N,T&gt;::Result }; }; template &lt;int N, class T, int D, int C&gt; struct Important&lt;N,Edge&lt;T,N,D,C&gt; &gt; { enum {Result = true}; }; template &lt;int N, class T, int S, int D, int C&gt; struct Important&lt;N,Edge&lt;T,S,D,C&gt; &gt; { enum { Result = Important&lt;N,T&gt;::Result }; }; //      // T -  // R -   template &lt;class T, class R&gt; struct ImportantOpt; template &lt;class R&gt; struct ImportantOpt&lt;NullType,R&gt; { typedef typename AddSet&lt;1,R,NullType&gt;::Result Result; }; template &lt;class T, int S, int D, class R&gt; struct ImportantOpt&lt;Edge&lt;T,S,D,0&gt;,R&gt;{ typedef typename ImportantOpt&lt;T,R&gt;::Result Result; }; template &lt;class T, int S, int D, int C, class R&gt; struct ImportantOpt&lt;Edge&lt;T,S,D,C&gt;,R&gt; { typedef typename ImportantOpt&lt;T,typename AddSet&lt;S,R,NullType&gt;::Result&gt;::Result Result; }; //       // A -   (Set) // B -   (Set) // G -  // I -    (    ) template &lt;class A, class B, class G&gt; struct EquEx { private: typedef typename Filter&lt;A,G,NullType,Important&gt;::Result A1; typedef typename Filter&lt;B,G,NullType,Important&gt;::Result B1; public: enum { Result = Equ&lt;A1,B1&gt;::Result }; }; template &lt;class A, class B, class I&gt; struct EquExOpt { private: typedef typename Filter&lt;A,I,NullType,Exist&gt;::Result A1; typedef typename Filter&lt;B,I,NullType,Exist&gt;::Result B1; public: enum { Result = Equ&lt;A1,B1&gt;::Result }; }; //    // G -  // R -   template &lt;class T, class R&gt; struct EdgeList; template &lt;class R&gt; struct EdgeList&lt;NullType,R&gt; {typedef R Result;}; template &lt;class T, int S, int D, int C, class R&gt; struct EdgeList&lt;Edge&lt;T,S,D,C&gt;,R&gt; { private: typedef typename AddSet&lt;S,R, NullType&gt;::Result R0; typedef typename AddSet&lt;D,R0,NullType&gt;::Result R1; public: typedef typename EdgeList&lt;T,R1&gt;::Result Result; }; //   (  ) // T -   (StateList) // S -   (Set) // I -    template &lt;class T, class S, class I&gt; struct ExistS; template &lt;class S, class I&gt; struct ExistS&lt;NullType,S,I&gt; {enum {Result = false};}; template &lt;int N, class s, class T, class S, class I&gt; struct ExistS&lt;StateList&lt;N,s,T&gt;,S,I&gt; { enum { Result = (Equ&lt;s,S&gt;::Result) ? // EquExOpt&lt;s,S,I&gt;::Result true : ExistS&lt;T,S,I&gt;::Result }; }; //     // T -   (StateListEx) //  -   (StateList) // I -    (Set) // R -   (StateListEx) template &lt;class T, class C, class I, class R&gt; struct FilterT; template &lt;class C, class I, class R&gt; struct FilterT&lt;NullType,C,I,R&gt; {typedef R Result;}; template &lt;int Src, int Dst, int a, class S, class T, class C, class I, class R&gt; struct FilterT&lt;StateListEx&lt;Src,Dst,a,S,T&gt;,C,I,R&gt; { typedef typename If&lt;ExistS&lt;C,S,I&gt;::Result, typename FilterT&lt;T,C,I,R&gt;::Result, typename FilterT&lt;T,C,I,StateListEx&lt;Src,Dst,a,S,R&gt; &gt;::Result &gt;::Result Result; }; //    // T -     (StateList) // a -      // S -   (Set) // I -    // R -   template &lt;class T, int Src, int Dst, int a, class S, class I, class R&gt; struct GenImpl; template &lt;int Src, int Dst, int a, class S, class I, class R&gt; struct GenImpl&lt;NullType,Src,Dst,a,S,I,R&gt; {typedef R Result;}; template &lt;int n, class s, class T, int Src, int Dst, int a, class S, class I, class R&gt; struct GenImpl&lt;StateList&lt;n,s,T&gt;,Src,Dst,a,S,I,R&gt; { typedef typename If&lt;Equ&lt;s,S&gt;::Result, // EquExOpt&lt;s,S,I&gt; Edge&lt;R,Src,n,a&gt;, typename GenImpl&lt;T,Src,Dst,a,S,I,R&gt;::Result &gt;::Result Result; }; //    // T -    //  -    // I -    // R -   template &lt;class T, class C, class I, class R&gt; struct Gen; template &lt;class C, class I, class R&gt; struct Gen&lt;NullType,C,I,R&gt; {typedef R Result;}; template &lt;int Src, int Dst, int a,class S, class T, class C, class I, class R&gt; struct Gen&lt;StateListEx&lt;Src,Dst,a,S,T&gt;,C,I,R&gt; { typedef typename Gen&lt;T,C,I,typename GenImpl&lt;C,Src,Dst,a,S,I,R&gt;::Result&gt;::Result Result; }; //   // N -     // K -     // G -  (NFA) // A -  (Set) // I -    (Set) // R -   (DFA) // M -    (StateList) // D -    (StateListEx) template &lt;int N, int K, class G, class A, class I, class R, class M, class D&gt; struct ConvertImpl; template &lt;int N, int K, class G, class A, class I, class R, class M&gt; struct ConvertImpl&lt;N,K,G,A,I,R,M,NullType&gt; {typedef R Result;}; template &lt;int N, int K, class G, class A, class I, class R, class M, int Src, int Dst, int a, class S, class D&gt; struct ConvertImpl&lt;N,K,G,A,I,R,M,StateListEx&lt;Src,Dst,a,S,D&gt; &gt; { private: typedef typename MoveList&lt;N,K,A,Dst,S,G,NullType&gt;::Result T; typedef typename StateList&lt;Dst,S,M&gt; M1; typedef typename Append&lt;D,M1&gt;::Result MD; typedef typename FilterT&lt;T,MD,I,NullType&gt;::Result T1; typedef typename AppendSafe&lt;T1,D&gt;::Result D1; typedef typename Gen&lt;T,typename Append&lt;T1,MD&gt;::Result,I,R&gt;::Result R1; enum { N1 = Incr&lt;T1,N,Exist&gt;::Result, K1 = Incr&lt;T1,K,NotExist&gt;::Result }; public: typedef typename ConvertImpl&lt;N1,K1,G,A,I,R1,M1,D1&gt;::Result Result; }; //  NFA -&gt; DFA // G -  // R -   template &lt;class G, class R&gt; struct Convert { private: typedef typename Alf&lt;G,NullType&gt;::Result A; typedef typename ImportantOpt&lt;G,NullType&gt;::Result I; public: typedef typename ConvertImpl&lt;1,MAX_FIN_STATE+1,G,A,I,NullType,NullType, StateListEx&lt;0,0,0,typename EClos&lt;Set&lt;0,NullType&gt;,G,NullType&gt;::Result,NullType&gt; &gt;::Result Result; }; template &lt;class T&gt; class DFA: public DFAImpl&lt;typename Convert&lt;typename T::Result,NullType&gt;::Result&gt; {};</span></span></code> </pre><br></div></div><br>  I will not describe in detail all the ordeals associated with debugging this code (which only kilometer listings with compilation error messages cost), I note only that the front-end implementation of the algorithm hung the compiler completely, as a result of which the optimized ImportantOpt template had to be implemented. <br><br>  Now you can run the following code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> E&lt; Q&lt; D&lt; C&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt; &gt; &gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt;, C&lt;<span class="hljs-string"><span class="hljs-string">'b'</span></span>&gt; &gt;::Result G; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Convert&lt;G,NullType&gt;::Result R; R::Dump();</code> </pre><br>  ... and make sure that the result is: <br><br><pre> <code class="hljs erlang-repl"> <span class="hljs-number"><span class="hljs-number">1</span></span> -a-&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -b-&gt; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> -a-&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> -b-&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> -a-&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> -b-&gt; <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -a-&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -b-&gt; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> -a-&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> -b-&gt; <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre><br>  Corresponds to the desired DFA graph: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/951/049/11695104965008698f0620c47f87d3fb.png" alt="image"><br><br>  As usual, the sources are uploaded to <a href="https://github.com/GlukKazan/ConvertToDFA">GitHub</a> . <br></div><p>Source: <a href="https://habr.com/ru/post/179089/">https://habr.com/ru/post/179089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../179075/index.html">Processing pcntl signals in PHP</a></li>
<li><a href="../179077/index.html">Why the "Great Gatsby" is still not in the public domain</a></li>
<li><a href="../179081/index.html">Speed ‚Äã‚Äãup your code and find a needle in a haystack</a></li>
<li><a href="../179083/index.html">Unicorn is again ready to communicate with C ++ programmers</a></li>
<li><a href="../179087/index.html">Turkish company captured top-level domain?</a></li>
<li><a href="../179091/index.html">Are you still using Google Reader?</a></li>
<li><a href="../179095/index.html">Terms, jargon, and definitions of Android</a></li>
<li><a href="../179101/index.html">Mobile conference # MBLT13 in a week!</a></li>
<li><a href="../179105/index.html">Runetology (197): Kirill Grodinsky, CEO, E5.ru</a></li>
<li><a href="../179109/index.html">Moving a cat in time and space</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>