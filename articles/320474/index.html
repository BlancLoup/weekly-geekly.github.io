<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: evolution instead of revolution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this world of what we would like NO! 
 We believe in the power to change it YES! 

 Yuri Shevchuk 



 Those of you who have read my articles shoul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: evolution instead of revolution</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <i><b>In this world of what we would like NO!</b></i> <i><b><br></b></i>  <i><b>We believe in the power to change it YES!</b></i> <i><b><br><br></b></i>  <i><b>Yuri Shevchuk</b></i> <br><br>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Those of you who have read my articles should be aware that I have been studying the <a href="http://www.zillions-of-games.com/">Zillions of Games</a> metagame system for quite some time.  For all this time, I developed a little less than fifty <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D498">games</a> and learned this platform up and down.  My goal is to develop a similar (and preferably more functional) open source system.  On the progress of this work and I want to tell. <br><a name="habracut"></a><br><h2>  <b>In the image and likeness</b> </h2><br>  As I said, I understand very well how Zillions of Games works.  The absence of its source codes does not bother me, since I am not going to engage in the porting of this product.  We are talking about the development of a new system from scratch, taking into account the merits (and even more deficiencies) of all the metagame platforms that I know at the moment.  I will list them: <br><br><ul><li>  <a href="http://www.zillions-of-games.com/">Zillions of Games</a> - the most famous metagame system, about which I wrote a lot </li><li>  <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom Development Kit</a> is a rather interesting project, implemented as a Zillions of Games expansion module, but also capable of operating autonomously. </li><li>  <a href="http://www.di.fc.ul.pt/~jpn/ludae/index.htm">The LUD√Ü project</a> - A fun system designed for the automated development of new board games. </li><li>  <a href="https://www.jocly.com/">Jocly</a> - Modern and very interesting development (unfortunately, the quality of the games implemented for it leaves much to be desired) </li></ul><br>  All these products work and do exactly what they are intended for - they help, with the expenditure of more or less effort, to create computer implementations of various board games.  It's not just about Checkers and Chess!  The number and (most importantly) the variety of games already created exceeds all expectations.  This is the main advantage of metagame systems - a working prototype of a new and rather complicated board game can be created in just a couple of hours! <br><br><div class="spoiler">  <b class="spoiler_title">A spoon of tar</b> <div class="spoiler_text">  Their main drawback is also obvious.  No one universal game "engine" will ever be equal (in performance) to programs specialized, focused on one and only one board game.  The ‚Äúintelligence‚Äù of bots that are designed to make a company to a human player who is alone is directly related to this.  All universal gaming systems play very poorly, but since we are usually talking about rather exotic games, this is not a very big problem.  It is unlikely that the program will be lucky to meet with a person playing, for example, in <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%258E_%25D1%2581%25D1%2591%25D0%25B3%25D0%25B8">Chu Shogi</a> at the level of a grandmaster. <br><br>  In addition to this common flaw (as well as the fatal flaw associated with the closeness of the source code), each of these projects has individual features.  For <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">example</a> , Zillions of Games uses a <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">lispo-like</a> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">DSL</a> , which greatly simplifies the process of describing board games, but somewhat limits the functionality available to the developer.  With it, you can <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1001">really</a> implement <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D10">a</a> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D244">lot</a> , but not everything.  Some games, such as <a href="https://habrahabr.ru/post/234587/">Ritmomachia</a> or <a href="http://www.iggamecenter.com/info/ru/kauri.html">Kauri</a> , are absolutely impossible to develop on pure <a href="https://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> .  Others, like " <a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a> " or " <a href="https://en.wikipedia.org/wiki/Janggi_variants">Gwangsanghui</a> ", can be done, but in such a complex way that their performance (and, consequently, the AI's "intelligence") is significantly affected. <br><br>  The Axiom Development Kit extension emerged as an attempt to improve the Zillions of Games.  Since this library operates with numbers (and not just boolean flags, like Zillions of Games), games such as Ritmochia become <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2282">realizable</a> , but the development process itself resembles a nightmare in places (I <a href="https://habrahabr.ru/post/276329/">wrote a</a> little about this).  As a DSL, Axiom uses Forth Script (a subset of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D1%2582_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Fort</a> language) and this language (and most importantly debugging programs on it) is <b>indeed</b> much more complex than a warm and lamp ZRF.  In addition, you can do with it, not all.  The development of such games as <a href="http://cyclowiki.org/wiki/%25D0%25A0%25D1%2583%25D1%2581%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Tavreli</a> or Kauri mentioned above is still not possible. <br><br>  I can tell little about LUD (since I have never seen this product live), and as for Jocly, the disadvantage of this system (in my opinion) is the complete rejection of using any DSL to describe games.  In fact, this is an <a href="https://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a> framework for developing JavaScript board games.  Even the introduction of rather trivial changes to already developed games becomes a very laborious <a href="https://habrahabr.ru/post/280334/">process</a> .  Games created by the authors themselves are also not without serious mistakes (I associate this with the complexity of the development process).  For example, in <a href="https://www.jocly.com/">Alquerque</a> , situations arise in which the same figures are ‚Äútaken‚Äù several times per turn, and in <a href="https://www.jocly.com/">Turkish Checkers</a> , the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2583%25D0%25B4%25D0%25B0%25D1%2580">Turkish Strike</a> rule is wrong, the main thing that distinguishes this game from other <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">checkers systems</a> . <br></div></div><br>  Acquaintance with Jocly prompted me to revise some decisions.  For further development, I firmly decided to use JavaScript, since this is obviously the easiest way to create an extensible and cross-platform system with a modern interface.  The single-threading is a bit scary, but in fact this moment is important only for AI (and it‚Äôs not easy to use multithreading), and we have (for ourselves) found out that AI is not the strongest side of metagame systems. <br><br>  On the other hand, the need for a certain DSL to describe the most routine moments of board games is quite obvious to me.  Directly using JavaScript to develop the entire gaming model gives the process unprecedented flexibility, but requires diligence and concentration (and, as experience has shown, even their presence does not help much).  Ideally, I would like to ensure compatibility with the base ZRF, in order to be able to run in the new system, if not all <a href="http://www.zillions-of-games.com/games/index.html">two and a half thousand games</a> , then at least a significant part of them.  Here is what Jocly developers <a href="http://wiki.jocly.com/index.php/Comparison_with_Zillions_of_Games">write</a> about it: <br><br><blockquote>  <i>In ZoG, games are described in a lisp-based language called ZRF.</i>  <i>This is where the ZRF has been defined.</i>  <i>The Jocly Approach</i>  <i>It is a good idea.</i> <i><br><br></i>  <i>In theory, it would be possible to write a ZRF interpreter in Javascript.</i>  <i>If you are willing to develop that kind of tool, let us know.</i> </blockquote><br>  I decided to move along this path, concentrating, however, not on interpretation, but on a kind of ‚Äúcompilation‚Äù of the ZRF file in the game description for Jocly.  Constant parsing of a text file, even if it contains a very simple description of the game, in a language resembling Lisp is not a task that I would like to engage in JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">Details</b> <div class="spoiler_text">  I decided to create an <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src/java">application</a> that turns the original <a href="">zrf file</a> containing the game description into a <a href="">form</a> suitable for loading into the Jocly model.  For example, instead of <a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dcheckersbase-model.js">this</a> file (you can use the <a href="http://embed.jocly.net/jocly/plazza/inspector">Jocly Inspector</a> to view all open texts of the Jocly platform).  Of course, an <a href="">interlayer was</a> needed that could ‚Äúglue‚Äù this description with the Jocly model.  Z2J-translator once performs the work that I would not want to engage in a JavaScript application all the time.  For example: <br><br><div class="spoiler"> <b class="spoiler_title">The following description of the game board</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 50)) ; ranks ) (directions (n 0 -1) (s 0 1) (e 1 0) (w -1 0)) )</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Turns into ...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> design.addDirection(<span class="hljs-string"><span class="hljs-string">"w"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"e"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"s"</span></span>); design.addDirection(<span class="hljs-string"><span class="hljs-string">"n"</span></span>); design.addPosition(<span class="hljs-string"><span class="hljs-string">"a8"</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]); design.addPosition(<span class="hljs-string"><span class="hljs-string">"b8"</span></span>, [<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]); ...</code> </pre></div></div><br>  In fact, this is a description of the graph, the vertices of which are the individual positions on the board, and the arcs (oriented) are the directions in which the figures can move.  The integers specified in the arrays associated with the vertices of the graph represent offsets within the linear array of all positions used in the game (a zero offset value indicates the absence of an arc).  When using this approach, navigation in any direction is reduced to one arithmetic addition: <br><br><div class="spoiler">  <b class="spoiler_title">ZrfDesign.navigate</b> <div class="spoiler_text"><pre> <code class="javascript hljs">ZrfDesign.prototype.navigate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">aPlayer, aPos, aDir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = aDir; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.players[aPlayer] !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { dir = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.players[aPlayer][aDir]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.positions[aPos][dir] !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aPos + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.positions[aPos][dir]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre></div></div><br>  Well, there is still an optional change in the direction of movement, depending on the player performing the move (the so-called "symmetry"), which allows, for example, to describe the movement of all pawns (both black and white) as moving "north".  If the move will be black, the direction will be changed to ‚Äúsouthern‚Äù automatically.  "Zero symmetry" allows you to describe "opposed" movement for each direction (in many games this is useful): <br><pre> <code class="javascript hljs">design.addPlayer(<span class="hljs-string"><span class="hljs-string">"White"</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre>  The rules for moving figures are more complicated. <br><br><div class="spoiler">  <b class="spoiler_title">Move checkers</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-shift ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion) (<span class="hljs-name"><span class="hljs-name">add</span></span> King) else add ) ))</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Turns into ...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> design.addCommand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ZRF.FUNCTION, <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-comment"><span class="hljs-comment">// from design.addCommand(1, ZRF.PARAM, 0); // $1 design.addCommand(1, ZRF.FUNCTION, 22); // navigate design.addCommand(1, ZRF.FUNCTION, 1); // empty? design.addCommand(1, ZRF.FUNCTION, 20); // verify design.addCommand(1, ZRF.IN_ZONE, 0); // promotion design.addCommand(1, ZRF.FUNCTION, 0); // not design.addCommand(1, ZRF.IF, 4); design.addCommand(1, ZRF.PROMOTE, 1); // King design.addCommand(1, ZRF.FUNCTION, 25); // to design.addCommand(1, ZRF.JUMP, 2); design.addCommand(1, ZRF.FUNCTION, 25); // to design.addCommand(1, ZRF.FUNCTION, 28); // end</span></span></code> </pre></div></div><br>  These are the commands of the stack machine, each of which is very simple.  For example, the <b>PARAM</b> command gets a numeric value from an array of parameters attached to the move pattern (set of commands) and pushes it onto the stack.  It allows you to parameterize stroke patterns, passing the direction of movement in the parameters: <br><br><div class="spoiler">  <b class="spoiler_title">Description of the figure</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> design.addPiece(<span class="hljs-string"><span class="hljs-string">"Man"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); design.addMove(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre></div></div><br>  The third parameter is the ‚Äúmode‚Äù of the move - a numerical value that allows, among other things, to separate the ‚Äúquiet‚Äù moves (in checkers) from the taking of the moves.  The whole triple (pattern + parameters + move mode) is a <b>complete</b> description of one of the possible moves performed by the figure. <br></div></div><br>  Jocly is built according to the classic <a href="https://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a> scheme.  To develop a new game, you need to write its model and presentation.  The model determines the rules of the game, and the presentation - how the game will be shown to the user.  The controller, written by the developers, takes care of the rest (including the bots wired into it). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b8c/958/9e0/b8c9589e0d7f4a7bb13babe05148c6d8.PNG"></div><br>  The architecture of the universal model implemented by <b>Z2J is</b> also not very complicated.  The basis is the <b>Design</b> component, which contains an immutable description of the rules of the game.  The state of the game (placement of pieces on the board) is stored in instances of the <b>Board</b> class.  The data of these components also do not change.  By executing a move (applying the <b>Move</b> object to the <b>Board</b> ), we create a new state.  The old remains the same! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/db6/d21/e9d/db6d21e9d485452682cea190633bb5d0.PNG"></div><br>  To generate a move (create a <b>Move</b> object), the current state of the <b>Board is used</b> , but it alone is not enough to realize all the capabilities of the ZRF.  In the process of generating a turn, ZRF can use variables (flags and position flags) that are not part of the game state.  All this, as well as the logic of the execution of the stack machine commands, is handled by the <b>Move Generator</b> .  In short, this is the architecture of the <a href="">zrf-model.js module</a> . <br><br><h2>  <b>The devil is in the details</b> </h2><br>  So, I was going to embed my model (zrf-model.js), configured <a href="">by the compilation of</a> <a href="">Turkish Checkers</a> , instead of <a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dcheckersbase-model.js">the</a> Jocly <a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dcheckersbase-model.js">model</a> , and try to run all this without making any changes to <a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dcheckers-xd-view.js">the</a> game <a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dcheckers-xd-view.js">view</a> .  Looking back, I understand that the idea was adventurous (why - I‚Äôll tell you below), but that‚Äôs what I started from.  It was required a little from the model: <br><br><ol><li>  Keeping the current state of the game </li><li>  Generation of all moves allowed for the current game state </li><li>  Changing the state of the game by applying one of the generated moves to it </li></ol><br>  The difficulty was that the move, far from always, boils down to a simple movement of one of the pieces on the board.  In the most general form, a move consists of a sequence of the following elementary actions: <br><br><ul><li>  <b>move</b> - Moving a shape from one position to another </li><li>  <b>capture</b> - Deleting a piece from one of the positions on the board </li><li>  <b>drop</b> - Add (reset) a new piece to the board </li></ul><br>  For example, taking a piece in checkers consists of one moving one's own figure and taking an opponent's piece (in this case, the taking is not ‚Äúchess‚Äù, since the position with which it is performed does not coincide with the final position of the piece's movement), but moves in such games as " <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%258D%25D0%25BD%25D0%25B4%25D0%25B7%25D1%258E">Renju</a> "consist of single drops of figures on the board.  One should not think that when performing a move only one figure can move!  So, when <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">casting</a> in chess, the rook and the king move simultaneously, within the same indivisible move. <br><br><div class="spoiler">  <b class="spoiler_title">How it works</b> <div class="spoiler_text">  Generating a move comes down to forming a list of elementary actions that are performed in the correct sequence.  This is simply a sequential interpretation of the commands of the stack machine: <br><br><div class="spoiler">  <b class="spoiler_title">ZrfMoveGenerator.generate</b> <div class="spoiler_text"><pre> <code class="javascript hljs">ZrfMoveGenerator.prototype.generate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cmd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cmd &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.template.commands.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.template.commands[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cmd++])(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cmd += r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cmd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre></div></div><br>  If we omit the details related to the checks of the necessary conditions (not finding the fields under the check, immobility of the figures before the execution of the turn, etc.), the short castling code, expressed in ZRF, may look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Castling</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> OO ( <span class="hljs-name"><span class="hljs-name">ee</span></span> to e cascade ww add ))</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Turns into ...</b> <div class="spoiler_text"><pre> <code class="javascript hljs">design.addCommand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ZRF.FUNCTION, <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-comment"><span class="hljs-comment">// from design.addCommand(0, ZRF.PARAM, 0); // e design.addCommand(0, ZRF.FUNCTION, 22); // navigate design.addCommand(0, ZRF.PARAM, 1); // e design.addCommand(0, ZRF.FUNCTION, 22); // navigate design.addCommand(0, ZRF.FUNCTION, 25); // to design.addCommand(0, ZRF.PARAM, 2); // e design.addCommand(0, ZRF.FUNCTION, 22); // navigate design.addCommand(0, ZRF.FUNCTION, 24); // from design.addCommand(0, ZRF.PARAM, 3); // w design.addCommand(0, ZRF.FUNCTION, 22); // navigate design.addCommand(0, ZRF.PARAM, 4); // w design.addCommand(0, ZRF.FUNCTION, 22); // navigate design.addCommand(0, ZRF.FUNCTION, 25); // to design.addCommand(0, ZRF.FUNCTION, 28); // end</span></span></code> </pre></div></div><br>  In addition to parameterized navigation, it all comes down to moving figures taken <b>from the from</b> command (implicitly performed at the beginning of the turn and when executing the <b>cascade</b> command) to the field indicated by the <b>to</b> command (also generated implicitly).  The command handler itself looks elementary: <br><br><div class="spoiler">  <b class="spoiler_title">Model.Move.ZRF_TO</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Model.Game.functions[Model.Move.ZRF_TO] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">aGen</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aGen.pos === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> aGen.piece === <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } aGen.movePiece(aGen.from, aGen.pos, aGen.piece); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> aGen.from; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> aGen.piece; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } ZrfMoveGenerator.prototype.movePiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">aFrom, aTo, aPiece</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.move.movePiece(aFrom, aTo, aPiece, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.level); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aFrom !== aTo) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setPiece(aFrom, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setPiece(aTo, aPiece); } ZrfMove.prototype.movePiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">from, to, piece, part</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions.push([ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to, piece, part ]); }</code> </pre></div></div><br></div></div><br>  But all this is only part of the problem!  In checkers, the figure can (and moreover, is obliged) to perform several takes "along the chain."  Until all captures are completed, the move is not transferred to another player.  From the point of view of the model and for AI, this is one move!  With the controller and the presentation is a little more complicated.  In the user interface of the game, each checker take (partial move) must be performed separately.  The user (player) must be able to choose one or another partial move at each stage of the execution of a long composite move. <br><br><div class="spoiler">  <b class="spoiler_title">Of course, this is not the only possible approach.</b> <div class="spoiler_text">  In Zillions of Games, each partial move is considered a separate move.  This simplifies the user interface, but, on the other hand, not only complicates the life of the AI, but also leads to more serious problems. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/759/69a/a34/75969aa342a24d159fccd076e7998d08.PNG"></div><br>  It shows the sequence of positions that arise when performing a composite move in the game " <a href="https://fr.wikipedia.org/wiki/Mana_(jeu)">Mana</a> ", developed by Claude Leroy in 2005.  According to the rules of the game, white Damyo must perform three consecutive steps, horizontally or vertically, to the next empty position.  At the same time, all steps <b>must</b> be taken and the figure is <b>prohibited to return</b> to previously completed positions.  As it is easy to see, a piece can drive itself into a ‚Äúdead end‚Äù by choosing the wrong sequence of partial moves.  In Zillions of Games, this problem is insoluble! <br><br>  With Checkers, everything is also not easy.  In almost all traditional drafts games (with the exception of <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B0">Fanorona</a> ), the player <b>must</b> continue to take, while there is such a possibility.  This means that when performing a partial move containing a take, we still do not know whether it completes a <b>valid</b> composite move or not. <br><br><div class="spoiler">  <b class="spoiler_title">Of course, this can be fought ...</b> <div class="spoiler_text">  but it already reminds a lot ... <br><div class="spoiler">  <b class="spoiler_title">'' sunset sun manually ''</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-captured-find mark (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> enemy? (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">not</span></span> captured?)) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures true) ) ) back ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-captured-find mark (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> enemy? (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">not</span></span> captured?)) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures true) ) ) back ) (<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> captured?)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> captured?)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures false) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) else (<span class="hljs-name"><span class="hljs-name">checker-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">checker-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">checker-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">markit</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures)) (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> enemy? capture ) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">capture-all</span></span>) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? promotion) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King notype) ) else (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> notype) ) ) ))</code> </pre></div></div></div></div><br>  Moreover, in many checkers games, such as <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25B4%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">International Checkers</a> , there is a ‚Äúmajority rule‚Äù, according to which the player must take the maximum possible number of opponent pieces.  In some games it is specified that taking the greatest number of ladies should be considered a priority.  Considering each partial move separately, Zillions of Games is forced to resort to the "magic of options": <br><br><ul><li>  <b>(option "pass partial" true)</b> - allows interrupting the chain of captures </li><li>  <b>(option "maximal captures" true)</b> - take the maximum number of shapes </li><li>  <b>(option "maximal captures" 2)</b> - take the maximum number of queens (if the number of queens taken is the same, take the maximum number of pieces) </li></ul><br>  And now, just compare this hardcode with that ... <br><br><div class="spoiler">  <b class="spoiler_title">how Jocly performs a similar test</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(aGame.g.captureLongestLine) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moves0=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mMoves; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moves1=[]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestLength=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> moves0) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> move=moves0[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(move.pos.length==bestLength) moves1.push(move); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(move.pos.length&gt;bestLength) { moves1=[move]; bestLength=move.pos.length; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mMoves=moves1; }</code> </pre></div></div><br>  When the entire composite move is available in its entirety, nothing prevents you from simply counting the number of takes that it takes. <br></div></div><br>  Compound stroke generation is the simplest application of the ZrfMoveGenerator.  Each copy of the generator forms its partial stroke, and the partial moves themselves concatenate into a ‚Äúchain‚Äù of the composite stroke.  Unfortunately, this is not the only way ZRF can use to determine moves.  Consider a very simple case describing a piece moving through empty fields in one direction (such as <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25BD_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)">Elephant</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B0%25D0%25B4%25D1%258C%25D1%258F_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)">Rook</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B5%25D1%2580%25D0%25B7%25D1%258C">Queen</a> in <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess</a> ): <br><br><div class="spoiler">  <b class="spoiler_title">Chess Rider</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) add ))</code> </pre></div></div><br>  You can see that the <b>add</b> command, completing the formation of the move, is used in the body of the loop.  This means that the figure can stop on any empty field, on the way to the enemy figure (and this will be considered a correct move).  Of course, such a cycle can be eliminated by rewriting the definition: <br><br><div class="spoiler">  <b class="spoiler_title">In some ZRF games you have to use this method.</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide-1 ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) add )) (<span class="hljs-name"><span class="hljs-name">define</span></span> slide-2 ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) add )) (<span class="hljs-name"><span class="hljs-name">define</span></span> slide-3 ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) add )) ...</code> </pre></div></div><br>  The <b>add</b> command, executed in the body of the loop, leads to the formation of a non-deterministic move.  The figure may stop or go further.  For ZrfMoveGenerator, this means the need for cloning.  The generator creates a complete copy of its state and pushes it onto the stack for subsequent generation, after which the current copy completes the formation of the turn.  Here's what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Moving dyke</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-shift ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) ))</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">turns into ...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> design.addCommand(<span class="hljs-number"><span class="hljs-number">3</span></span>, ZRF.FUNCTION, <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-comment"><span class="hljs-comment">// from design.addCommand(3, ZRF.PARAM, 0); // $1 design.addCommand(3, ZRF.FUNCTION, 22); // navigate design.addCommand(3, ZRF.FUNCTION, 1); // empty? design.addCommand(3, ZRF.FUNCTION, 0); // not design.addCommand(3, ZRF.IF, 7); design.addCommand(3, ZRF.FORK, 3); design.addCommand(3, ZRF.FUNCTION, 25); // to design.addCommand(3, ZRF.FUNCTION, 28); // end design.addCommand(3, ZRF.PARAM, 1); // $2 design.addCommand(3, ZRF.FUNCTION, 22); // navigate design.addCommand(3, ZRF.JUMP, -8); design.addCommand(3, ZRF.FUNCTION, 28); // end</span></span></code> </pre></div></div><br>  The <b>FORK</b> command clones the progress generator along with its entire current state and works as a conditional transition.  In the generated generator, the control will go to the next command, and the parent will transfer control to the number of steps specified by the parameter (yes, this is very much like creating a process in Linux). <br><br><div class="spoiler">  <b class="spoiler_title">Burden of compatibility</b> <div class="spoiler_text">  In order for ZRF game descriptions to work after their ‚Äútranslation‚Äù in JavaScript, it is not enough just to execute similar commands in the same order.  The semantics of operations (in terms of interaction with the state of the board) must fully coincide with the one used by Zillions of Games.  In order for you to imagine the whole degree of complexity of the question, I will briefly list the main points: <br><br><ul><li>  During the course generation, the board is available in the state it was at the time of the generation start.  The moved figure is not removed from the source field and, of course, is not set to the current one.  This requirement is understandable (especially if we recall the immobility of the board), but in real life it is extremely uncomfortable. </li><li>  The state of flags (bit variables) and positional flags (bit variables attached to specific positions) is available only in the course generation process.  In the case of Zillions of Games, which treats each partial move as a separate move, this greatly reduces their usefulness, but we must provide similar semantics for everything to work. </li><li>  The storage of attributes (named bit flags attached to figures) is not limited to stroke generation.  Attributes are part of the board's status.  By the way, the figures themselves are also immutable, changing any of the attributes with it, we create a new figure. </li><li>  Since the state of the board is available at the moment of starting the generation of a move, it is possible to read the attribute only at the place of the initial location of the figure, but if we want to change the attribute, then it should be done at the position where the figure completes its movement (that is, it turns out at the moment of completion of the move).  If you change an attribute on another field (for example, on the source field), a fatal error will not occur.  The value is simply not established. </li><li>  Cascade moves are not transmitted when cloning moves.  Rather, they are transmitted, but only if the option " <b>discard cascades</b> " is <b>disabled</b> .  Never seen a game where it is used! </li><li>  Intermediate captures and drops of figures are also not transferred to the cloned move.  As a result, taking a woman in Russian Checkers turns into a real puzzle (from the point of possible completion of the move with the <b>add</b> command performed in the cycle, you must move back to take the previously jumped enemy figure. </li><li>  We cannot take a figure whose type, attribute value or owner has changed on the same turn!  It looks more like a bug, but you can't throw a word out of a song. </li><li>  If the turn ends in a position containing a piece, a ‚Äúchess take‚Äù is performed automatically.  If the <b>capture</b> command is explicitly called on the same field, the figure that performed the move will be deleted (this way you can make kamikaze figures).  Similarly, using the <b>create</b> command, you can change the type and the owner of the shape. </li><li>  If the delayed capture option is enabled, if you continue the turn, all the captures of the pieces should be moved to the last partial stroke of the compound stroke.  This option, for obvious reasons, is not in ZRF, but when it is needed, it is so lacking!  The implementation of the rule of " <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2583%25D0%25B4%25D0%25B0%25D1%2580">Turkish strike</a> " in ZRF is a form of torment!  Fortunately, we are considering a composite move entirely.  Why not implement such a useful option? </li></ul><br>  This is not a complete list.  Just the first thing that came to mind.  In addition, it is necessary to implement a loop to iterate through all of their pieces that can perform a move (in Zillions of Games, the player can move only his pieces), as well as all the empty fields to which the piece can be ‚Äúreset‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">All together it looks something like this</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CompleteMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, gen</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Model.Game.passPartial === <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { t = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.pieces) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.pieces[pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece.player === board.player) || (Model.Game.sharedPieces === <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> move <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Model.Game.design.pieces[piece.type]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((move.type === <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (move.mode === gen.mode)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = f.copy(move.template, move.params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { g.moveType = t; g.generate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g.moveType === <span class="hljs-number"><span class="hljs-number">0</span></span>) { CompleteMove(board, g); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.addFork(g); } t = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } } ZrfBoard.prototype.generateInternal = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback, cont</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forks = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (Model.Game.design.failed !== <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mx = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pieces) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pieces[pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece.player === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.player) || (Model.Game.sharedPieces === <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> move <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Model.Game.design.pieces[piece.type]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.type === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = Model.Game.createGen(move.template, move.params); g.init(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, pos); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addFork(g); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Model.Game.design.modes.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ix = Model.find(Model.Game.design.modes, move.mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ix &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mx === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (ix &lt; mx)) { mx = ix; } } } } } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Model.Game.design.pieces) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Model.Game.design.positions) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> move <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Model.Game.design.pieces[tp]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.type === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = Model.Game.createGen(move.template, move.params); g.init(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, pos); g.piece = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZrfPiece(tp, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.player); g.from = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; g.mode = move.mode; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addFork(g); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Model.Game.design.modes.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ix = Model.find(Model.Game.design.modes, move.mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ix &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mx === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (ix &lt; mx)) { mx = ix; } } } } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forks.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (callback.checkContinue() === <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forks.shift(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((mx === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (Model.Game.design.modes[mx] === f.mode)) { f.generate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cont === <span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; (f.moveType === <span class="hljs-number"><span class="hljs-number">0</span></span>)) { CompleteMove(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cont === <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Model.Game.CheckInvariants(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Model.Game.PostActions(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Model.Game.passTurn === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZrfMove()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Model.Game.passTurn === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZrfMove()); } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.player = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves; }</code> </pre></div></div><br>  The algorithm is constructed in such a way that the continuations of moves ‚Äúoverwrite‚Äù their shorter ‚Äúprefixes‚Äù (of course, if the " <b>pass partial</b> " option is not enabled). <br></div></div><br>  Using these two methods (alignment of move generators into a ‚Äúchain‚Äù and cloning), you can implement any constructions of the ZRF language.  Of course, the implementation is not simple and, due to the need to ensure compatibility with the ZRF semantics, is rather confusing.  This is not a big problem if the code works.  The problem is that ZRF itself is far from perfect! <br><br><h2>  <b>Open your fingers</b> </h2><br>  This year began with disappointments.  To begin with, I was stumped by my <a href="https://habrahabr.ru/post/309096/">attempts to</a> create a universal <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">DSL</a> suitable for the simple description of all the board games I know.  Universally, in principle, it turned out, ‚Äúunderstandable‚Äù - no.  Even relatively simple games, such as <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B0">Fanoron</a> , were keen to write about in some kind of horror. <br><br><div class="spoiler">  <b class="spoiler_title">Like this</b> <div class="spoiler_text">  (*) [p] | ((\ 1 [ex]) *; ~ 1 (~ 1 [ex]) *) <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Even on ZRF it looks clearer.</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> approach-capture ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) to $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> capture) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> capturing) )) (<span class="hljs-name"><span class="hljs-name">define</span></span> withdrawl-capture ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) to back (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) capture) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> capturing) ))</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With Jocly, the matter also somehow didn‚Äôt immediately set. I did not like her architecture. Let's start with the fact that to store the state of the board it uses a mutable Model.Board singleton. How to work with this AI-bot - I'll never know. But the main thing is not even that. </font></font><a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Denglish-draughts%26file%3Dcheckersbase-model.js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model in it is completely different from the </font></font><a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3D3dchess%26file%3Dbase-model.js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (just has nothing to do). At the same time, ‚Äúmagical‚Äù members, like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mWho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mMoves</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , are actively used </font><font style="vertical-align: inherit;">, and the presentation should ‚Äúknow‚Äù how the model </font><b><font style="vertical-align: inherit;">works</font></b><font style="vertical-align: inherit;"> , since it uses it on a par with the controller! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My hopes to ‚Äúreplace‚Äù the model were doomed to failure in advance! That is, it is quite possible for me and it will be possible to replace the </font></font><a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dturkish-model.js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turkish drafts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"so that the appropriate </font></font><a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Dturkish-draughts%26file%3Dturkish-xd-view.js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> worked with her </font><font style="vertical-align: inherit;">, but for any other game (even for </font></font><a href="http://embed.jocly.net/jocly/plazza/file-access%3Fgame%3Denglish-draughts%26file%3Ddraughts-model.js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">English Drafts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) you would have to start everything from the beginning, because her model differs very significantly from Turkish Drafts. I realized that I was not ready, in addition to the model, engage in more and developing presentation and was in a deep depression. and then, the work involved </font></font><a href="https://habrahabr.ru/users/jonic/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jonic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and on the horizon a little brightened. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We decided to give up trying to integrate with Jocly and elaborate missing controllers (for network and local games, as well as utility autoplay ), presenter Supports (2D and 3D), as well as bots (in stock) independently. Moreover, he agreed to do all this work </font></font><a href="https://habrahabr.ru/users/jonic/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jonic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so I can focus on working on the model. </font><font style="vertical-align: inherit;">First, I got rid of Jocly's stupid inherited restrictions. </font><font style="vertical-align: inherit;">Yes, now the model supports games for more than two players! </font><font style="vertical-align: inherit;">And then I got a taste ...</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a list of options I have planned.</font></font></b> <div class="spoiler_text"><ul><li> <b>maximal-captures = true</b> ‚Äî   (  ¬´ ¬ª) </li><li> <b>pass-partial = true</b> ‚Äî     (  ¬´¬ª) </li><li> <b>pass-turn = true</b> ‚Äî    </li><li> <b>pass-turn = forced</b> ‚Äî        </li><li> <b>discard-cascades = true</b> ‚Äî        </li><li> <b>include-off-pieces = true</b> ‚Äî        </li><li> <b>recycle-captures = true</b> ‚Äî        </li><li> <b>smart-moves = true</b> ‚Äî  ¬´¬ª UI (   ) </li><li> <b>smart-moves = from</b> ‚Äî       </li><li> <b>smart-moves = to</b> ‚Äî       </li></ul><br><ul><li> <b>zrf-advanced = true</b> ‚Äî   zrf-advanced </li><li> <b>zrf-advanced = simple</b> ‚Äî        </li><li> <b>zrf-advanced = fork</b> ‚Äî      ZRF_FORK </li><li> <b>zrf-advanced = composite</b> ‚Äî       </li><li> <b>zrf-advanced = mark</b> ‚Äî    mark/back </li><li> <b>zrf-advanced = delayed</b> ‚Äî   ¬´ ¬ª (  ,  ) </li><li> <b>zrf-advanced = last</b> ‚Äî   last-from  last-to     </li><li> <b>zrf-advanced = shared</b> ‚Äî     (  ¬´ ¬ª) </li><li> <b>zrf-advanced = partial</b> ‚Äî       ,    </li><li> <b>zrf-advanced = numeric</b> ‚Äî      (  ¬´¬ª) </li><li> <b>zrf-advanced = foreach</b> ‚Äî   foreach      </li><li> <b>zrf-advanced = repeat</b> ‚Äî     (   ) </li><li> <b>zrf-advanced = player ‚Äî</b>      , ,   </li><li> <b>zrf-advanced = global</b> ‚Äî     (  Axiom) </li></ul><br><ul><li> <b>board-model = heap</b> ‚Äî       (  ) </li><li> <b>board-model = stack</b> ‚Äî       (  ¬´ ¬ª) </li><li> <b>board-model = quantum</b> ‚Äî   (     ) </li></ul></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I told you that I don‚Äôt like the restrictions of ZRF either? </font><font style="vertical-align: inherit;">A smaller part of these options are the inherited Zillions of Games settings, which must be supported. </font><font style="vertical-align: inherit;">The rest is extensions that have not been seen in ZRF before. </font><font style="vertical-align: inherit;">So all the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zrf-advanced</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> options </font><font style="vertical-align: inherit;">(you can enable them all together, with one team) expand the ZRF semantics, making it more convenient (I tried to accommodate the </font></font><a href="http://www.frontiernet.net/~alcove/chess/zogfeedback.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wishes of</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zillions of Games </font></font><a href="http://zillionsofgames.com/discus/messages/5/174.html%3F1079204040"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">users</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">board-model</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> options </font><font style="vertical-align: inherit;">introduce new types of boards.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is worth saying more</font></font></b> <div class="spoiler_text">     , Zillions of Games   .  ,           .      ¬´ ¬ª (    <b>capture</b>      ). ,      .   <a href="http://www.di.fc.ul.pt/~jpn/gv/towers.htm"></a>  (  " <a href="https://fr.wikipedia.org/wiki/Puluc"></a> "  " <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25BE%25D0%25BB%25D0%25B1%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8"> </a> "),      ¬´¬ª ,    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7cz8B2Zu-Qs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>   ,  ¬´¬ª     ,  ,    <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25BC%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5"></a>    .     ‚Äî  ,  .       6 ,   ,     ,   Zillions of Games.     ,      ,          () . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0NRdY6p7xic" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2587%25D0%25B5%25D1%2582%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5"></a>     . <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BD%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B0"></a>          .       ,             (   ZRF ,   ),   ,   <a href="http://mancala.wikia.com/wiki/Kauri"></a>  <a href="http://mancala.wikia.com/wiki/10_Mighty_Men"></a> .     (  <a href="https://en.wikipedia.org/wiki/Rithmomachy"></a> ),         . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QVmppOuYUCE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>   ‚Äî   .   ,    <b></b>      (  ).   ,      ,  ,     ,  <a href="https://arxiv.org/pdf/1603.04751v2.pdf"></a> . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The options themselves are implemented as loadable JavaScript modules. </font><font style="vertical-align: inherit;">For example, if the game (as in ‚ÄúInternational checkers‚Äù) requires you to take the maximum number of pieces, you need to load the corresponding </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after loading the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zrf-model</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Module connection is performed by the checkVersion function:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In zrf file</font></font></b> <div class="spoiler_text"><pre> <code class="lisp hljs">... (<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true) ...</code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In javascript file</font></font></b> <div class="spoiler_text"><pre> <code class="javascript hljs">... design.checkVersion(<span class="hljs-string"><span class="hljs-string">"z2j"</span></span>, <span class="hljs-string"><span class="hljs-string">"1"</span></span>); design.checkVersion(<span class="hljs-string"><span class="hljs-string">"zrf"</span></span>, <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>); design.checkVersion(<span class="hljs-string"><span class="hljs-string">"maximal-captures"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); ...</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model will check the compatibility of versions of the requested modules and enable the appropriate options. </font><font style="vertical-align: inherit;">This expanding mechanism gave me an interesting thought. </font><font style="vertical-align: inherit;">In some games, there are rules that are devilishly difficult to implement using only ZRF. </font><font style="vertical-align: inherit;">In most cases, these rules are reduced to additional checks that affect the ability to perform a particular move. </font><font style="vertical-align: inherit;">Putting checks into loadable options will relieve me of the need to extend the base language to implement them (which would not be easy at all).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that the developers Zillions of Games went the same way</font></font></b> <div class="spoiler_text">   ,      ( )      ZRF ( ),     AI,   Zillions of Games,    .      ¬´¬ª , <a href="http://www.zillions-of-games.com/progsample.html"></a>   DLL-.  API           AI,        <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D14">  </a> . <br><br>           <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom Development Kit</a> ‚Äî  ,   ,    ,    ForthScript.     Zillions of Games,       .  JavaScript,      .   ,      ! <br></div></div><br>  Let me explain by example.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a kind of "Turkish drafts", which I learned about recently. </font><font style="vertical-align: inherit;">The only difference between the ‚ÄúBahraini checkers‚Äù and the Turkish ones is that they are not allowed to respond with an attack on an enemy attack. </font><font style="vertical-align: inherit;">You can eat the attacked figure or get out from under the blow, but you can not attack another figure in return! </font><font style="vertical-align: inherit;">Taking into account the fact that the rule also applies to ladies, the implementation of this game on ZRF turned out to be quite </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and, most importantly, not very ‚Äútransparent‚Äù. </font><font style="vertical-align: inherit;">But if I use extensible options, I have no need to complicate the code in ZRF!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahrain Dama</font></font></b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">variant</span></span> (<span class="hljs-name"><span class="hljs-name">title</span></span> <span class="hljs-string"><span class="hljs-string">"Bahrain Dama"</span></span>) (<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"bahrain dama extension"</span></span> true) )</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I can take the " </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turkish checkers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " and connect the option that performs the necessary checks. </font><font style="vertical-align: inherit;">The loadable module replaces the method of post-processing a move and, if necessary, can prohibit a previously generated move! </font><font style="vertical-align: inherit;">The </font><font style="vertical-align: inherit;">verification </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itself </font><font style="vertical-align: inherit;">can be arbitrarily complex, it will still be more understandable than a similar implementation on ZRF! </font><font style="vertical-align: inherit;">The case is not limited to the additional validation of already generated moves. </font><font style="vertical-align: inherit;">The option can "enrich" the course! </font><font style="vertical-align: inherit;">For example, performing a move in ‚Äú </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù, you must do the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check 4 adjacent stones (3 at the border of the board or 2 in the corner). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the neighboring stone belongs to the enemy, build a "connected" group of stones into which it enters, and count the number of its dame (free points with which the group borders). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the enemy group does not border on free points - remove all its stones. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If none of the enemy groups are removed, build a group containing the stone you just added. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the constructed group does not have a dame, prohibit the move (Strictly speaking, not always. </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%2598%25D0%25BD%25D0%25B3%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inga rules allow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suicide for groups consisting of more than one stone).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this can be ‚Äúhidden‚Äù in a </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript extension</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">It not only performs the necessary checks, but also completes the course by removing enemy stones. </font><font style="vertical-align: inherit;">ZRF-description of the game becomes </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Moreover, the extension is also suitable for other games! </font><font style="vertical-align: inherit;">For example, for " </font></font><a href="http://senseis.xmp.net/%3FMultiColorGo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicolor Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More than one move ...</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expandable options allowed me to look at the project in a new way, but one small task still haunted me. </font><font style="vertical-align: inherit;">In some games, under certain conditions, it is allowed to take </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opponent's piece </font><font style="vertical-align: inherit;">from the board </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, in " </font></font><a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mill</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Players put on the board and move their pieces, trying to put 3 pieces in a row. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If this succeeds, the player gets the right to remove any opponent from the board. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the same time, preference should be given to figures not standing "in a row" (figures constituting a number are taken as the last). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a player has 3 pieces left, he gets the opportunity to move them to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> place on the board (not only along the marked lines).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loses a player who has less than 3 pieces left. </font></font></li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/csy39T5G220" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D428"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is not to say</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that this is unrealizable on ZRF, but the code is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> complicated. Well, in general, generating a set of moves that are the same in almost everything except for the piece to be taken is a rather dull decision. I thought it would be much more convenient if you could use </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arrays of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> positions </font><font style="vertical-align: inherit;">in the actions of the moves </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="diff hljs">ZrfMove.prototype.capturePiece = function(pos, part) { - this.actions.push([ pos, null, null, part]); + this.actions.push([ [pos], null, null, part]); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was quite a global </font></font><a href="https://github.com/GlukKazan/JoclyGames/commit/5ddcd5cf5edb17757127eb242a77da297c48292d"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alteration of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code, but </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unit tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , once again, helped. </font><font style="vertical-align: inherit;">So far, such non-deterministic moves are planned to be generated only from JavaScript extensions, as part of the ‚Äúenrichment‚Äù of the moves generated by the simplest ZRF description of the game. </font><font style="vertical-align: inherit;">If we talk about the " </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mill</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", then we are talking about all the same addition to the course of taking the pieces. </font><font style="vertical-align: inherit;">Just instead of a set of single takes, one non-deterministic is added:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Magic of non-determinism</font></font></b> <div class="spoiler_text"><pre> <code class="javascript hljs">Model.Game.CheckInvariants = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.design; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cnt = getPieceCount(board); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = board.moves[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = board.apply(m); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> m.actions) { fp = m.actions[j][<span class="hljs-number"><span class="hljs-number">0</span></span>]; tp = m.actions[j][<span class="hljs-number"><span class="hljs-number">1</span></span>]; pn = m.actions[j][<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (tp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkLine(b, tp[<span class="hljs-number"><span class="hljs-number">0</span></span>], board.player) === <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> captured = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = design.positions.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; len; p++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = b.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player !== board.player) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((checkLine)(b, p, b.player) === <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { captured.push(p); } all.push(p); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (captured.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { captured = all; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (captured.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { captured.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); m.actions.push([captured, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, pn]); } } ... break; } } } CheckInvariants(board); }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is a broader concept. </font><font style="vertical-align: inherit;">Not only taking can be non-deterministic! </font><font style="vertical-align: inherit;">Remember that in the "Mill" there is a rule according to which the three remaining pieces of the player can jump "anywhere." </font><font style="vertical-align: inherit;">In fact, this is a non-deterministic move to any free position:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some more magic</font></font></b> <div class="spoiler_text"><pre> <code class="javascript hljs"> ... if (cnt === <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = design.positions.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; len; p++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p !== tp[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tp.push(p); } } } } ...</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The moving figure can also be an array! </font><font style="vertical-align: inherit;">According to the rules of transformation in Chess, a pawn, reaching the last rank, can turn into any of 4 pieces (Knight, Elephant, Rook, Queen), at the player‚Äôs choice. </font><font style="vertical-align: inherit;">This is nothing more than a non-deterministic transformation performed when the figure is moved. </font><font style="vertical-align: inherit;">In the ZRF code, the pawn can be turned into a queen, for example, and in a </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript extension</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... enrich this transformation</font></font></b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promote = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, name, player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.design; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = design.getPieceType(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { arr.push(design.createPiece(t, player)); } } Model.Game.CheckInvariants = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> design = Model.Game.design; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> board.moves) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = board.moves[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> m.actions) { fp = m.actions[j][<span class="hljs-number"><span class="hljs-number">0</span></span>]; tp = m.actions[j][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (tp !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(fp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.getType() === <span class="hljs-string"><span class="hljs-string">"Pawn"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = design.navigate(board.player, tp[<span class="hljs-number"><span class="hljs-number">0</span></span>], design.getDirection(<span class="hljs-string"><span class="hljs-string">"n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promoted = []; promote(promoted, <span class="hljs-string"><span class="hljs-string">"Queen"</span></span>, board.player); promote(promoted, <span class="hljs-string"><span class="hljs-string">"Rook"</span></span>, board.player); promote(promoted, <span class="hljs-string"><span class="hljs-string">"Knight"</span></span>, board.player); promote(promoted, <span class="hljs-string"><span class="hljs-string">"Bishop"</span></span>, board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (promoted.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { m.actions[j][<span class="hljs-number"><span class="hljs-number">2</span></span>] = promoted; } } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } CheckInvariants(board); }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the controller changes a little. </font><font style="vertical-align: inherit;">Having received a move from the model that is valid for the current state of the board, he must check the size of the arrays in each of the actions. </font><font style="vertical-align: inherit;">If more than one element is transmitted, the controller must go through all possible options, forming deterministic moves. </font><font style="vertical-align: inherit;">I think it is not necessary to say that one should be careful with such non-determinism. </font><font style="vertical-align: inherit;">The Cartesian product of several independent positions is capable of generating an incredible number of different moves!</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtotals</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, I can say that I like the direction of the project development. </font><font style="vertical-align: inherit;">I abandoned the idea of ‚Äã‚Äãcreating something revolutionary new (although it was not easy) and focused on achievable, but not less interesting goals. </font><font style="vertical-align: inherit;">It can be said that of the two famous birds, I prefer the ‚Äúcrane in hand‚Äù. </font><font style="vertical-align: inherit;">Work on the project helps to master a new language for me, and joining a new, more experienced developer to the project carries the hope that the work will still be crowned with success. </font><font style="vertical-align: inherit;">I refused the ‚Äúrevolution‚Äù, but the project continues to evolve!</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/320474/">https://habr.com/ru/post/320474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320460/index.html">Exploit Exercises: Introducing binary vulnerabilities using the example of Protostar</a></li>
<li><a href="../320462/index.html">SystemJS 0.20 - Combining with browser modules</a></li>
<li><a href="../320464/index.html">OpenJDK 10 development begins</a></li>
<li><a href="../320470/index.html">Why did you need to develop a "Russian dropbox"</a></li>
<li><a href="../320472/index.html">Connect Xmega to FRAM over SPI</a></li>
<li><a href="../320476/index.html">High Definition TK</a></li>
<li><a href="../320478/index.html">Entry into international markets: attracting investment abroad</a></li>
<li><a href="../320480/index.html">Simple MVC Applications</a></li>
<li><a href="../320482/index.html">How to debug machine learning models</a></li>
<li><a href="../320484/index.html">7 entry levels that all game developers need to learn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>