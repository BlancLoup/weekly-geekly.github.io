<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a webpack plugin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About webpack have already been written on Habr√©, told on moscowjs and there are several articles on other resources that describe the overall capabil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a webpack plugin</h1><div class="post__text post__text-html js-mediator-article">  About webpack have already been written on Habr√©, told on moscowjs and there are several articles on other resources that describe the overall capabilities of the webpack, its advantages and disadvantages. <br><br>  Therefore, in this article we will talk about the webpack itself only briefly and in more detail about the development of a plug-in for it. <br><br> <a href="http://habrahabr.ru/company/rambler-co/blog/265165/"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/7a2/a6b/4e97a2a6bd39584f972c81f6ff1d03f0.jpg" alt="image"></a> <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>1. Webpack in brief</b> <br><br>  For build systems like popular <a href="https://github.com/gruntjs/grunt">grunt</a> or <a href="https://github.com/gulpjs/gulp">gulp</a> , a large number of auxiliary libraries are written, but webpack currently cannot boast of such abundance and it would be great to be able to use the necessary library.  If you decide to implement a webpack in your project, but there is no ready solution, then the only way out is to write it yourself. <br><br>  And so, what is a webpack, what is its feature and how does it work? <br><br>  Webpack is a module bundler, as the developers themselves are positioning ( <a href="http://webpack.github.io/">http://webpack.github.io</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ca/965/a2c/5ca965a2ca42ecd31a4698329c50d517.png" alt="image"><br><br>  Out of the box, it supports AMD, CommonJS and ES6 modules, there is the possibility of live reload'a, implemented in addition webpack-dev-server and working through socket.io.  This means that you do not need every time after making changes to the source files - run the assembly commands again. <br><br>  Also, webpack has a fairly simple config, not as transparent as gulp, but much more concise and neat. <br><br>  Terminology: <br><br>  <b>2. Loaders &amp; Plugins</b> <br><br>  <b>Loader</b> is a powerful tool used to upload, process and convert files.  Those.  if our project uses such technologies as, for example, jade, sass, coffee, es6, or our svg are too big and need to be pressed, all similar processing, transformation and minification tasks will be solved by just loaders.  They have already been written quite a large number, you can find it <a href="http://webpack.github.io/docs/list-of-loaders.html">here</a> . <br><br>  Write your loader is simple.  To do this, on the official website of the project there is a separate section - <a href="http://webpack.github.io/docs/how-to-write-a-loader.html">How to write a loader</a> and, in general, by the first lines of the code, you can immediately understand how simple it is: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Identity loader module.exports = function(source) { return source; };</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Identity loader with SourceMap support module.exports = function(source, map) { this.callback(null, source, map); };</span></span></code> </pre><br>  Loader is a module.exports function, which accepts the contents of a file as input and returns the result of processing, and can also return a sourcemap if the necessary attribute is present in the configuration. <br><br>  Returning the current context, it is possible to use chaining.  Accordingly, each of them should perform only one, their own task, the developers of webpack call us to write a separate loader for each step.  In general, this is a general modular ideology, when each module is encapsulated, due to which it is much easier to work with it and debug it. <br><br>  <b>A plugin</b> is an object that has a apply method with just one parameter - compiler.  Through it, you can communicate with the various stages of compilation webpack'a.  To perform the necessary transformations, there are also various types of plug-in interfaces, the following code is given as an example on the official website: <br><br><pre> <code class="javascript hljs">compiler.plugin(<span class="hljs-string"><span class="hljs-string">"compile"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Just print a text console.log("Compiling..."); });</span></span></code> </pre><br><br>  When you run a task to build a project, in the terminal you will see a message about the current build process, either an error caused by missing the required library or a problem with the syntax of the code. <br><br>  When we started the build process using webpack, the code will work and in the terminal we will see: ‚ÄúCompiling ...‚Äù <br><br>  Outwardly, this is a clear mechanic, but there are few examples of such work, and there are practically no examples in the documentation. <br><br>  In part, this prompted us to write an article, because  The <i><b>How to write a loader</b></i> section has a lot of examples of loaders, but the <i><b>How to write a plugin</b></i> section is hidden (and possibly removed altogether) from the official site for an indefinite period.  By and large, we only have a list and a text description of the work of the so-called <i>interface types</i> ( <b>upd</b> : now this section is hidden) and the opportunity to examine the code of already written plugins, see how it is used and works. <br><br>  Of course, we have no doubt that the developers of the webpack will soon provide us with this section, but we will try to sort out this topic now to solve current problems, and when the section is opened, we will find something new for ourselves, and maybe even rethink working with plugins. <br><br>  <b>3. An example of solving a problem - gluing together svg sprites.</b> <br><br>  Webpack has been around for several years, but many still do not dare to use it as the main tool for working with a project, its capabilities are great and it can replace a number of tools at once for both assembling and working with modules. <br><br>  And rewriting a project that is going to grunt'om or gulp'om along with all the tasks and plug-ins on the mechanics of the webpack is not 15 minutes.  Especially considering that so far under the webpack there are not that many libraries that older and running assembly systems can boast of. <br><br>  Suppose that we decided on this and began to update our project.  And just in the process, you can stumble upon the problem that was described above - the webpack may not have a tool that duplicates or performs the same mechanics of the task that we previously had in the project and worked fine. <br><br>  It happened with <a href="https://github.com/FWeinb/grunt-svgstore">grunt-svgstore</a> - a library that collects all svg from the directory we need into one sprite, putting a prefix to connect the necessary svg in the right places of the page via <i>use xlink: href = ‚Äú# logo‚Äù</i> . <br><br>  This is a very convenient mechanism for working with svg through the sprite and really would not want to lose this functionality in the transition process. <br>  There is a similar solution under gulp, but under webpack it was not possible to find it. <br>  This is a problem and a way out of it - write your own plug-in under the webpack, save the general mechanics on gluing svg sprites and, perhaps, add some new features and capabilities to it. <br><br>  <b>4. The process of writing code</b> <br><br>  In order to start writing, it is important to understand that our goal is not to steal someone else‚Äôs code and pass it off as your own, but you don‚Äôt want to reinvent the wheel either, especially considering the limited time that is always tight. <br><br>  Therefore, here we will go this way: let's take the grunt-svgstore library code as a basis, change it a bit to start working as a plug-in for webpack and add some new features, while at the very top of the plug-in code we‚Äôll point out the whole truth: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Webpack SVGstore plugin based on grunt-svg-store * @see https://github.com/FWeinb/grunt-svgstore/blob/master/tasks/svgstore.js */</span></span></code> </pre><br>  Thus, we will not deceive anyone and will not offend the developer who wrote the svgstore under grunt.  In general, we undertook this plugin not for one-time use in a specific project, but to put it on npm with a successful outcome, thus making our contribution to the open source community. <br><br>  To convert the task code into a plugin, we actually remove the entire grunt from the code, saving only the ready-made mechanism for directly assembling and gluing the svg to the sprite.  But then we come across a number of problems that need to be fixed: <br><br>  <b>5. Unexpected problems</b> <br><br>  1) The sprite is too big, and we need to add a minification. <br><br>  The first thing that was found is that under the webpack there is a ready-made svg loader (https://github.com/rpominov/svgo-loader) under the hood of which there is a svgo, through which you can drive all our svg'shki. <br><br>  We connect in the plugin module svgo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SVGO = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'svgo'</span></span>);</code> </pre><br>  And add the minification function of our svg: <br><br><pre> <code class="javascript hljs">SvgStore.prototype.svgMin = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, loop</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> svgo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SVGO(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = file; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">svgoCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ source = result.data; } <span class="hljs-comment"><span class="hljs-comment">// optimize loop for (i = 1; i &lt;= loop; i++) { svgo.optimize(source, svgoCallback); } return source; };</span></span></code> </pre><br>  It happens that minification can spoil some svg, we also strive to ensure that the process of adding a new svg is minimal in terms of labor costs.  We can achieve this by adding an option to the <i>min: true / false</i> plugin, by which we understand whether we will minify certain svg's, or we will assemble all svg exactly as it is. <br><br>  The size of the sprite is important, and the smaller it will be, the naturally better.  But to completely abandon all minification is not very correct, so we decide to add an internal directory for svg that will be minified, i.e.  for example, the path to our directory with svg: <br>  <i>/ app / assets / svg</i> <br>  And those svg, which we want to minimize, we put in a nested directory: <br>  <i>/ app / assets / svg / min</i> <br>  Thus, we will only have svg lying in the internal min directory minified, and we don‚Äôt need to refuse all minification if it breaks several icons. <br><br>  Still there is a nuance because of which the function we have takes 2 parameters, one of which is the contents of svg, and the second is loop. <br>  The fact is that one of the advantages of svg is that we can control the styles of our image through css, change the color, width of lines, etc. <br><br>  But after the 1st run, svgo does not delete inline styles, because of which we cannot redefine them via css, i.e.  if we need to change the color for example on a hover, this will not work in some cases.  But after 2 runs, these attributes are erased and the override starts to work. <br><br>  Naturally, not everyone needs this, so the default of the loop option is one (1 run), but we can specify any number of runs through svgo. <br><br>  2) It is necessary with the help of the plugin to collect a few sprites.  This was implemented using prefixes rather primitive and not very nice (but working) code, the option was called filter and works as follows: <br><br>  1. 'except-name' - if the value begins with the words except-, then all the svg will be collected in the sprite, except for those that in this case begin with the name <br>  2. 'name' - svg will be compiled into the sprite, starting with the specified string, in this case with the name <br><br><pre> <code class="javascript hljs">output: [ { <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: <span class="hljs-string"><span class="hljs-string">'Logo-'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-string"><span class="hljs-string">'svg/[hash].logo_sprite.svg'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: <span class="hljs-string"><span class="hljs-string">'except-Logo-'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-string"><span class="hljs-string">'svg/[hash].sprite.svg'</span></span> } ]</code> </pre><br>  3. 'all' - if we do not need to divide anything and we want to get at the output only 1 sprite, which will contain all the svg. <br><br><pre> <code class="javascript hljs">output: [ { <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: <span class="hljs-string"><span class="hljs-string">'all'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-string"><span class="hljs-string">'svg/[hash].sprite.svg'</span></span> } ]</code> </pre><br>  In addition to the filter, we also specify the directory where all our assets are going, and the [hash] option has also been added.  In the hashing method itself, we again did not reinvent the wheel, but took the most standard method of hashing that the crypto module uses: <br><br><pre> <code class="javascript hljs">Name.replace(<span class="hljs-string"><span class="hljs-string">'[hash]'</span></span>, crypto.createHash(<span class="hljs-string"><span class="hljs-string">'md5'</span></span>).update(source).digest(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>))</code> </pre><br>  Initially, it was not planned to add a hash to the collected sprites, because it seems like webpack should do such things and our task is only to slip the assembled sprite during the compilation process prior to adding hashes, and the collector will do the rest.  But, alas, it wasn‚Äôt possible to make it work that way, so we add the hash inside the plugin ourselves. <br><br>  3) Another big problem is the addition of collected sprites to the manifest. <br><br>  The manifest is json in which the correspondence with the name of the assets to the collected names with hashes and paths is indicated.  This is done to connect assets, since we do not know what hash each assembly will have.  With the help of the manifest, we get a convenient table of links.  For this we use the <a href="https://github.com/nickjj/manifest-revision-webpack-plugin">manifest</a> for webpack. <br><br>  With the help of this manifesto the back of our project understands what needs to be connected after the new assembly. <br>  And here there is another problem that we encountered: the compiler gives up 2 objects, in one of which an array of assets, in the second - modules. <br>  And after adding an asset inside the plugin <br><br><pre> <code class="javascript hljs">compiler.plugin(<span class="hljs-string"><span class="hljs-string">'emit'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation, callback</span></span></span><span class="hljs-function">) </span></span>{ compilation.assets[key.sprite] = { <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(source); }, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer.byteLength(source, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); } }; callback(); });</code> </pre><br>  it appears in the compiler.assets array, but this array does not give us a match between the file name - and its path with the hash. <br><br>  That is why the developer who wrote the manifest-webpack plugin uses compiler.modules, not comiler.assets, inside his plugin, although the latter would be much more logical. <br><br>  Those.  after we added a new asset, following the example of the code that <a href="https://github.com/sokra">Tobias</a> (one of the webpack developers) <a href="https://github.com/webpack/webpack/issues/1175">suggested to</a> us, this asset appears in the assets array, but this array does not contain the original name or path, so we cannot use it. <br><br>  We tried to insert a name field via <a href="https://github.com/webpack/webpack/pull/1291">pull request</a> so that we could use the assets array to build a manifest, but it was not accepted.  And in general, this idea was rejected. <br><br>  This gave rise to the problem of adding our newly created sprites to the manifest, and at this stage it is necessary to manually manipulate the plugin at the final stage: <br><br><pre> <code class="javascript hljs">compiler.plugin(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// code })</span></span></code> </pre><br>  And add sprites via <i>fs.readFile / fs.writeFile to the manifest</i> , which is not good. <br><br>  <b>6. Examples and prospects of use</b> <br><br>  You can poke and try the resulting plugin in your webpack project by following the <a href="https://github.com/mrsum/webpack-svgstore-plugin">link</a> . <br><br>  In the future, it is planned to make the plug-in the most universal, to refactor the code, remove all unnecessary and cover its work with tests - generally leave as little of what is necessary and make it as stable as possible. <br><br>  <b>7. References</b> <br><br>  Demo with the result of the plug-in - all icons on the site <a href="http://motor.ru/">motor.ru</a> <br>  Plugin repository (waiting for your issue and pull requests) - <a href="https://github.com/lgordey/webpack-svgstore-plugin">github.com/lgordey/webpack-svgstore-plugin</a> <br>  Plugin in NPM - <a href="https://www.npmjs.com/package/webpack-svgstore-plugin">www.npmjs.com/package/webpack-svgstore-plugin</a> <br>  Webpack documentation - <a href="http://webpack.github.io/docs/">webpack.github.io/docs</a> <br>  Webpack repository - <a href="https://github.com/webpack/webpack">github.com/webpack/webpack</a> </div><p>Source: <a href="https://habr.com/ru/post/265165/">https://habr.com/ru/post/265165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265155/index.html">Stabilization of time-lapse video on a calculator (IPython + OpenCV)</a></li>
<li><a href="../265157/index.html">About false posts in the VC or how many operations per second the human brain performs</a></li>
<li><a href="../265159/index.html">Our Service is both dangerous and difficult or some aspects of the survival of services in Android</a></li>
<li><a href="../265161/index.html">Another serious Android vulnerability found</a></li>
<li><a href="../265163/index.html">Google does not forgive mistakes: confrontation with Google Play</a></li>
<li><a href="../265167/index.html">Deep Learning Hardware</a></li>
<li><a href="../265169/index.html">Hekslet: new courses + webinars about VIM, programming, English</a></li>
<li><a href="../265171/index.html">Customizing the manual sorting of UITableView on Xamarin</a></li>
<li><a href="../265173/index.html">I invite you to meet with Vadim Makeev from Opera</a></li>
<li><a href="../265175/index.html">Property Attributes in Objective-C. Instructions for beginners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>