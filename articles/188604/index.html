<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why UML</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vsevolod Leonov - product manager, Embarcadero. 
 Alexander Lyulin - Lead Developer, "Garant" 
 Maxim Krylov - Project Manager, Garant 

 Attention, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why UML</h1><div class="post__text post__text-html js-mediator-article">  <b>Vsevolod Leonov</b> - product manager, Embarcadero. <br>  <b>Alexander Lyulin</b> - Lead Developer, "Garant" <br>  <b>Maxim Krylov</b> - Project Manager, Garant <br><br>  <i>Attention, the information in the next paragraph is absolutely <u>not advertising</u> .</i>  <i>None of the authors will discuss and even mention any software products in the context of their properties, functions, competitive advantages, emotional perception, appearing in the head from repeated pronouncing of names, etc.</i>  <i>Below is a reference to the product and the company to determine the qualifications of invited experts.</i>  <i>Simply put, who is interested in reading the opinion about the UML of a certain ‚Äúwashi puppkin‚Äù who developed the ‚Äúbest-xxx-dauloader-iksploit‚Äù program?</i> <br><br>  The company <a href="http://www.garant.ru/">"Garant" is</a> known to many Russian IT-specialists due to its key product - the IPO system GARANT.  Most of the company's employees are engaged in software production, and the system itself has a 23-year history of development and has tens of millions of lines of code written in various programming languages.  With such a scale, linguistic and technological heterogeneity, high production rates, very strict stability requirements, only the use of the most advanced technologies can ensure the quality of the evolving system.  UML as a modeling tool is undoubtedly one of these ‚Äúadvanced‚Äù approaches, the use of which in Garant is characterized by a high level of automation with a significant share of strengthening its systemic role.  Today, the leading developer of the GARANT system Alexander Lyulin and the project manager Maxim Krylov share their experience. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>The proof of the lack of advertising - let's look at what is written above.</i>  <i>We have just defined:</i> <i><br></i> <ul><li>  the name of the company whose employees are experts; </li><li>  The site of the company; </li><li>  Company Profile; </li><li>  what product the company produces; </li><li>  technical parameters of the product (quantitative and qualitative), allowing to assess the scale of development; </li><li>  the degree of "penetration" of UML into the software production process. </li></ul><br><br>  <i>The site of the company is given again not for advertising reasons.</i>  <i>So does even wikipedia, which is the benchmark of "ad-free".</i>  <i>The above paragraph serves to add publication a) completeness;</i>  <i>b) responsibility to the readers.</i> <i><br><br></i>  <i>If you (in a broad sense - people, companies, specialists, experts) do not agree with the authors, we will be glad to see references to your publications on a subject.</i>  <i>If you need help with this, contact vsevolod.leonov@embarcadero.com.</i> <br><br>  <i><b>Vsevolod</b> : Tell us, was the use of UML originally adopted as one of the components of the development process?</i> <br><br>  <b>Maxim</b> : No, of course, when we came to Garant, it was simply not there yet.  But, it seems, already in the 97th year, our young and talented colleague (although at that time we were all young) brought a floppy disk with one of the first UML modeling tools.  From about this point, we can assume that the introduction of UML within the walls of the ‚ÄúGuarantor‚Äù has begun.  However, before its use in our main projects, so to speak on an industrial scale, more years passed. <br><br>  <b>Alexander</b> : Moreover, the use of UML has been introduced for a long time and in several stages.  With the growth of our development and understanding that without this tool there is a risk of not coping with the increasingly complex structure of the code and the internal architecture of projects. <br><br>  <i><b>Vsevolod</b> : Were there ‚Äúideological differences‚Äù?</i>  <i>There are different coding styles, did it not turn out that ‚Äúeveryone has their own UML‚Äù?</i>  <i>Or does the UML ‚Äúcomb all one size fits all‚Äù?</i> <i><br></i> <br>  <b>Alexander</b> : Of course, there were differences.  And it was precisely in the ideological basis of the introduction that there was a desire to "comb" everything and unify the existing approaches. <br><br>  <b>Maxim</b> : By the time when the use of UML from the experiments of one or two enthusiasts passed into the design implementation stage, we already had a fairly clear understanding of what it is and why and how to make it so that there are no ‚Äúdifferent UMLs‚Äù. <br><br>  <i><b>Vsevolod</b> : At what point was it decided to look towards UML?</i> <br><br>  <b>Alexander</b> : When it came to the realization that projects are complex.  That many people are involved in them.  What you need to somehow "negotiate".  And that it is necessary to somehow "see" the overall architecture of the projects. <br><br>  <b>Maxim</b> : For a long time, its use was limited to personal sketches for consumption by a narrow group of "initiates."  At some point, they tried to start generating CORBA IDL from it.  As a result, they came to the conclusion that this is almost impossible and they wrote their own simple generator.  Actually, this was the point of no return.  After that, UML was used in most projects, and most importantly, it was reborn into something much more than just a set of pictures, we will tell you more about this later.  But at the beginning, yes - just as an opportunity to reach an agreement faster and more efficiently. <br><br><a name="habracut"></a><br><br>  <i><b>Vsevolod</b> : Were there cases when it was not possible to agree even with the UML?</i> <br><br>  <b>Maxim</b> : In any team, there are situations when someone loses the desire to negotiate.  Neither UML nor anything else will help here.  But when people take a constructive position, having a universal language makes life much easier. <br><br>  <b>Alexander</b> : UML is not a dogma and not a ‚Äúuniversal pill‚Äù, but a means.  But work has become really better.  Because it became possible to simply ‚Äúglance‚Äù throughout the system, quickly changing the scope of the review.  Then we look at UseCase, then in 5 minutes we have already gone down "to bytes".  Scaling is done very quickly.  Let's say, like in Google Earth. <br><br>  <i><b>Vsevolod</b> : Is the use of such techniques and just the need to "negotiate" an indicator that there are problems in the distribution of "areas of responsibility" in the code?</i>  <i>Why negotiate and harmonize, if you can clearly distinguish between who develops what classes / methods and who uses them?</i>  <i>I make the bolts, Vasya - nuts, and Zhora screw them two parts.</i>  <i>What details?</i>  <i>Yes, no matter what, we clearly divided the areas of responsibility.</i>  <i>Why is this in software development not working?</i> <br><br>  <b>Alexander</b> : Up to a certain point, such a scheme worked with us.  But I had to change roles.  Replace others.  And the complexity of the projects has increased. <br><br>  <i><b>Vsevolod</b> : And how to understand that the project has already become "difficult"?</i> <br><br>  <b>Maxim</b> : It all depends on the number of bolt-nut-part chains, on the versatility of each nut, on the variability of the bolts and their manipulations.  To write ‚Äúhello, world‚Äù you do not need to negotiate with anyone and share areas of responsibility.  No need for UML and OOP, SOAP, XML and ‚Äúflexible‚Äù methodologies.  It all starts with the growth of the project.  At some point, it turns out that Vasya changed the thread diameter of his nuts, and Zhora can no longer screw them onto your bolt, and even worse, they jump off of them themselves, already somewhere later on.  Or suddenly it turns out that at the end of the chain there is a new Masha, who with incredible difficulty spins back your nuts with bolts, and changes them to rivets that come from the next shop.  These are all primitive examples, but accumulating, mixing, forming bizarre combinations, they create complexity, it is because of them that we lose the quality of both the process and the result. <br><br>  The use of any notation, understandable to all participants in the process, reduces the number of such surprises.  A hypothetical production with bolts and nuts would be impossible without drawings and documentation.  But this is not enough either.  To build an efficient conveyor you need machines, CNC robots.  They unequivocally and without liberties interpret input documentation and issue a guaranteed result.  Therefore, one UML does not bring as much benefit as the UML that you can feed to the ‚Äúmachine‚Äù and get 100% valid, debugged code at the output, which then in manual mode turn into the final product. <br><br>  <i><b>Vsevolod</b> : How is the modeling process?</i>  <i>Is this how the group of ‚Äúinterested comrades‚Äù is going to come together and are they all at the same time ‚Äúpointing fingers at the diagram‚Äù and drawing it?</i>  <i>Or there is a clear distinction - master-slave.</i>  <i>Those.</i>  <i>one draws - the rest take note?</i> <br><br>  <b>Alexander</b> : It happens and that.  And going, and poked.  Master-slave separation also happens.  But these are rather ‚Äúroles‚Äù rather than positions.  The ‚Äúcircle of specialists‚Äù is the initial one.  We first communicate verbally.  Then we read the requirements.  Then ask questions about them.  We get answers to them.  We draw a prototype.  Somewhere we immediately determine the ‚Äúcircle of specialists‚Äù.  More narrow.  Or wider.  We run solutions.  We find "pitfalls in the TK" or contradictions with the "existing architecture."  Further, the process is generally cyclical. <br><br>  <b>Maxim</b> : We, as a rule, draw everything, or almost everything.  Depends on the project and specifics, of course.  But theoretically, the ‚Äúleading‚Äù model (namely, ‚Äúno‚Äù) is ‚Äúdriven‚Äù, it seems to me more correct and viable, since  allows you to best use the strengths of some and level the shortcomings of others.  Those who are better "sharpened" to design, draw a model.  Those who feel more confident in the implementation of algorithms generate code from them and fill it with business logic. <br><br>  <i><b>Vsevolod</b> : What problems did you initially want to solve with UML?</i> <br><br>  <b>Maxim</b> : Initially, at the level of experimentation, just as a way to structure your thoughts.  The very first experiments included only drawing classes and connections, there was no clearly articulated practical use, rather we liked it aesthetically, it was great and interesting, as if we were drawing illustrations to the books of the "classics."  But by the time of the actual implementation, the main problem that I wanted to solve was the insufficient speed and quality of the manual coding of the ‚Äúroutine‚Äù code.  Those.  at the head of the corner was code generation. <br><br>  <b>Alexander</b> : The complexity of taking connections.  Their "imperceptibility" in the "bare" code.  Design and coding rules.  Using template solutions.  Again, UML was seen as an opportunity to ‚Äúagree‚Äù more formally. <br><br>  <i><b>Vsevolod</b> : And why exactly UML?</i> <br><br>  <b>Maxim</b> : At that time, there simply was no alternative, UML was the only universal graphic notation that rather comprehensively described the subject area and had instrumental support, even with some kind of code generation.  Therefore, we can say that it happened historically.  And later, when we realized that it was not so important ‚Äúhow‚Äù to draw, how much ‚Äúwhat and why‚Äù, then there was simply no point in changing the UML to something else (for example, DOT).  By and large, UML for us is only a specific notation familiar to the majority, ‚Äúthe shape of arrows and small squares‚Äù, it is not important, but the principle of action, i.e.  what we do with it and how. <br><br>  <b>Vsevolod</b> : Classics are not deceived?  Or did you have your own vision of the place and role of UML? <br><br>  <b>Maxim</b> : The classics set the basis, and we used it.  And they used it as the classics implied, as it seems to us, but they did not fully formulate it.  First, the penetration of the model was not determined.  Yes, everyone heard about MDA, but how many have seen it?  We ‚Äúfixed‚Äù this, for example, one of our versions of the metamodel implied the beginning of the system design from the description of the ‚Äúproblems‚Äù in the UML that it had to solve, of which the ‚Äúpossibilities‚Äù were born, of them the ‚Äúprecedents‚Äù, etc.  to "servants", to "bytes".  All this was one holistic model in which it was possible to say about each ‚Äúbyte‚Äù which user problem it solves.  And for each "problem" - get all the source code associated with it. <br><br>  <b>Alexander</b> : This is a similarity to the "dolls" and "assembly drawings."  And at different levels, which can be arbitrarily many, and not just Class View, Deployment View, like the "classics".  Drawing "enterprise level" and drawing "level containers in the style of STL."  UML allows you to "logarithm" the complexity of the problem.  For me personally, designing / coding / debugging / testing a fairly large UseCase is not much more complicated than debugging a "list of integers".  Another thing is that debugging the ‚Äúlist of integers‚Äù can sometimes take months. <br>  And so - "assembly drawings", matryoshka and "nomenclature of chips".  These are the cornerstones.  On the one hand, they ‚Äúlogarithmize‚Äù the complexity, and on the other hand, they allow the system to ‚Äúquickly change the scale‚Äù. <br>  And yet, the ‚Äúclassics‚Äù did not pay enough attention to stereotypes.  And here it is - the cornerstone.  &lt;&lt; Stereotype &gt;&gt; is just an element of architecture and meta-model.  The stereotype affects code generation methods and the final code. <br><br>  <i><b>Vsevolod</b> : Let's discuss the concept of "stereotype"?</i> <br><br>  <b>Maxim</b> : The main problem of using UML in ‚Äúclassical‚Äù tools is that code generation is rigidly connected with a predefined static metamodel.  You cannot change one or the other.  Neither change, nor expand, nor change the rules or set new specific ones.  The main thing is that the classics did not reveal to the public, and the ‚Äúclassical tools‚Äù did not realize, this is the potential of UML precisely from the point of view of meta-design.  Creating your own metamodels with their own specific code generation.  And here the concept of ‚Äústereotype‚Äù, which Alexander speaks of, begins to play a key role.  The stereotype allows us to define a group of specific metaclasses with arbitrary code generation associated with them.  In fact, with the help of stereotypes, you create an arbitrary meta-model, which automatically becomes your own DSL, transforming squares into code, according to any rules you implement.  It is this aspect that allowed UML to become for us not only a tool for drawing pictures, but something that really simplifies the development process, sometimes making truly impossible things possible.  And as it seems to us, the absence of this or a similar mechanism in commercial tools, and now leads to the fact that UML cease to use and look at it as the "fifth leg". <br><br>  <b>Alexander</b> : I will add that UML has its own ‚Äúmeta-model,‚Äù drawn on UML itself.  It has the concept of "class element".  These are Class, Category, Operation, Attribute, Dependency, Port, UseCase, Actor, etc.  From these classes are constructed "final diagrams."  And code generation is usually tied in time for a class.  But this is where the ‚Äúclassics‚Äù mistake is - there is neither flexibility nor extensibility.  We have risen to a higher level.  Actually, the UML describes our meta-meta-model, i.e.  rules of formation of rules.  Next, we define the meta-model, introducing into it any concepts we need.  For example, we can determine for Delphi the possibility of multiple inheritance.  Then we attach to this metamodel the rules for converting its elements into code (or any other artifacts, for example, into documentation, auxiliary files, etc.).  In the example with multiple inheritance, this may be a transformation into a single inheritance plus aggregation, but at the same time, so that from the programmer‚Äôs point of view it will look like 100% inheritance.  Finally, we create real models of our subject domain, but already by operating not with the fact that we were initially offered ‚Äúclassics‚Äù, but with all that arsenal that we ourselves invented at the meta level and we get from them ready-made code of arbitrary complexity. <br><br>  <i><b>Vsevolod</b> : Tell me in detail, how did all this develop in your country - stepwise?</i> <br><br>  <b>Maxim</b> : At the beginning of work on the new version of ‚ÄúGuarantor‚Äù (‚ÄúPlatform F1‚Äù), we faced a problem: the server was developed in C ++ / CORBA, and the client was a shell in Delphi.  For some reason, we couldn‚Äôt use it on a shell that is native to Delphi, VisiBroker, and we did not see the server side of the sane alternative.  Then a solution was proposed to start an ‚Äúadapter‚Äù (dll in C ++) on the client, which would work with the server using CORBA, additionally performing some internal transformations, caching and even containing some part of the client logic, while giving everything that is needed shell on Delphi in a clear and convenient form.  I think it‚Äôs not worth saying that such a system as ‚ÄúGarant‚Äù, the range of interfaces through which the adapter and the shell interacted, quickly became rampant.  Now imagine what is any object interface, between dll in C ++ and delphi?  In short, this is ‚Äúhell‚Äù: different type transfer rules, different memory management, lack of description control in the exported header and in Delphi, when absolutely any discrepancy leads to completely unpredictable results and super-nontrivial debugging, etc. <br><br>  Taking into account, the number of interfaces that were and still promised to be, as well as the degree of their variability, we quickly realized that the task is in fact not feasible.  That's actually at this moment for the first time and we used the UML "by purpose".  We already had our own generator for CORBA IDL, and it has already been built on the principle of patterns describing a metamodel and code generation based on it.  Actually, all that was needed was to define a new metamodel for adapter interfaces and, on its basis, describe code generation, which would yield 100% consistent descriptions for both C ++ and Delphi, taking into account all the features and subtleties. <br><br>  In the end, everything was done fairly quickly, and it began to bring results.  C ++ programmers who wrote the adapter no longer thought at all that something, Delphi programmers had to export somewhere, worked with the adapter as if it were written entirely in Delphi, according to their usual principles before naming methods and properties.  Everyone simply drew the necessary interfaces on the model, generated the code and worked in a ‚Äúnative‚Äù way for both languages.  By and large, this was the first success story, after which we actively began to develop the idea of ‚Äã‚Äãpattern generation and metamodeling.  And in many directions (though not in all) achieved impressive results. <br><br>  <i><b>Vsevolod</b> : How does a new person get involved in the development team?</i>  <i>Is he given a heap of diagrams "under his breath?"</i>  <i>Or does he begin with elementary operations that do not require ‚Äúto see the system as a whole‚Äù?</i> <br><br>  <b>Alexander</b> : There is a list of non-key or secondary features.  For starters - give them.  But not very much.  In order not to "discourage" routine.  We look, as is involved.  Along the way, we talk about the "infrastructure" and its own components.  We consult orally and in writing.  There is also a set of documentation that we recommend reading.  Then, gradually, ‚Äúreal‚Äù tasks, model and everything else.  Something like this.  If there are ‚Äúseparate large tasks‚Äù on the agenda, then we start with them. <br><br>  <i><b>Vsevolod</b> : Everyone knows that new approaches and methods are not always positively perceived by all team members.</i>  <i>Were there any cases of active or passive opposition?</i> <br><br>  <b>Maxim</b> : Many people perceived ‚Äúour UML‚Äù as an invasion of their privacy, a restriction on their freedom of action.  After all, before that, everyone programmed as he wanted.  There appeared some rules and restrictions even at the design level of implementation, and not just interfaces.  Probably, we bent the stick a little and introduced too many restrictions.  But this is a very powerful tool, you do not just define the metamodel and code generation, you can also describe arbitrary ‚Äúconstraints‚Äù associated with it.  For example, from ‚Äúit is impossible to transfer collections as a result by reference‚Äù, or ‚Äúa method should not have more than 5 parameters‚Äù, to control architectural layers, and ‚Äútraceability‚Äù to requirements.  Of course, not all were in agreement with all the restrictions, and this frightened and repelled many of them. <br><br>  <i><b>Vsevolod</b> : How did the implementation process go - was the reverse design carried out?</i> <br><br>  <b>Alexander</b> : Not implemented.  At that moment there simply were no good tools.  And now I have come to the deep conviction that this is not necessary.  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the process of ‚Äúdrawing an existing code‚Äù, it is rethought, ideas and ways of its refactoring appear (you shouldn‚Äôt just do refactoring in the process of drawing, it should go a separate step), and design / coding patterns are applied. No ‚Äúautomaton‚Äù will do this. All attempts to transfer something to the model of all kinds of ‚Äúautomata‚Äù looked depressing. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Already at the stage of creating a template generator, it became clear to us: automatic reverse engineering is ‚Äúevil‚Äù. And not because it is practically impossible to conduct it at a sufficiently high level, even if you have a primitive basic metamodel containing only native abstractions for the language, not to mention more complex specific metamodels for which, I think, it is impossible to make an automatic reverse even theoretically. The key point was another - the presence of a reverse breaks the very idea of ‚Äã‚Äãusing UML for code generation. Our task was to learn ourselves and to teach others to think not in codes, but in abstractions, if possible to code not attached. This is a separate complex topic, and it was extremely important for us. Therefore, our generator by its architecture and by the way it generated the code, eliminated and at the same time made unnecessary the possibility of reverse,as such.</font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : We will take a step "back" to the PLO. Can you say that UML helps refactor? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Yes. Promotes. But, I can say that you should not mix refactoring with the ‚Äúimplementation of requirements‚Äù. They need to "spread in time." And think about tests.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Again, looking at "what" UML. If you just draw "dead" diagrams, it will not help much, although it may give a small positive effect. If you have a metamodel and patterned code generation, as in our case, then the refactoring capabilities are at a completely new level.</font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Why do you have to refactor object code? Is it a lack of experience? Or are there objective reasons for the evolution of the system as a whole? Or just the natural "growth in width and depth" of the system? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : I think that all of the reasons listed take place here. Refactoring is a separate big topic. But refactoring helps couple - model + tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model restricts the developer "from above", allowing you to remain "within the framework of the Architecture" (those metamodels) or to correctly modify it. And tests limit the developer ‚Äúfrom below‚Äù allowing him to remain within the framework of the TK and regressing the errors already found.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the model, let's say, is the ‚Äútutor‚Äù, and the tests are the ‚Äúvalidator‚Äù. Although there are colleagues to whom I said this phrase, and they took it with skepticism. Saying something like ‚Äúno one will forbid a Krivoruk programmer to make business logic in View, and to make View elements in business logic‚Äù. And they are right. And usually the skeptics are just "straight-handed" programmers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why do you need refactoring? It is not a secret for anyone that the entire IT industry in the whole world has not learned how to plan development terms ‚Äúin the sense of responsibility‚Äù. And if so, the dates begin to tighten. No matter how competent analysis at the initial stage was made, life is more difficult. And then decisions begin to be made "in the style of XP." What in my opinion, in general, is correct. ‚ÄúI will think about it tomorrow,‚Äù said one heroine. And for the time being, these decisions "have the right to life." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It often happens that the requirements for an already existing system change ‚Äúexplosively‚Äù or ‚Äúavalanche-like‚Äù. And it becomes ‚Äúcramped‚Äù within the framework of the architecture, which, although ‚Äúflexible‚Äù, but not ‚Äúrubber‚Äù. Here too - it is necessary to do refactoring. That the architecture "did not collapse". </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b> :      ¬´¬ª,     UML, DSL, ?</i> <br><br> <b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Here is a real life example. We have defined interface factories on the metamodel - a method on an interface with a special stereotype that turns the code into a set of other interfaces and classes that implement several different patterns, which ultimately allows you to quite flexibly manage the implementation of interfaces with interfaces in a runtime. displace them, etc. I repeat, all this is one method, drawn on the model. At some point, when it has been used for a couple of years, and there were not a dozen or two of such factories, we suddenly realized that there is a nonoptimality in the code that affects performance. But to eliminate it, you need to change the structure of these generated classes. It is not easy to replace ‚Äúa‚Äù with ‚Äúb‚Äù with a search for the entire project, namely, to change the structure. In our case, it took a few hours toto rewrite the generation pattern and rewrite all projects. And if all this was written by hand, then in a hundred different places the implementation of these several patterns would be ‚Äúpushed away‚Äù, a little different everywhere, and to change, and then debug it all - it would not be real in two hours or two months .</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In addition, it is easier for me to ‚Äúrefactor‚Äù the diagram, and not the code. It is easier to move ‚Äúsquares‚Äù from one place to another on models rather than pieces of code and files between folders. At the same time, it is still necessary to ‚Äúproperly maintain the architectural layers‚Äù with ‚Äúhands‚Äù. And the model - ‚Äúthinks for me.‚Äù She is a tutor. She will not let me make a "knowingly wrong decision." Or this decision will be at least deliberate. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Is it possible to measure the quality of refactoring? No need to re-refactor? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: I'm afraid this is not a criterion. Although if, of course, we managed to achieve the absence of such a need, then refactoring is probably perfect. Another thing is that I did not see the code / architecture that would be perfect. If something is perfect ‚Äúfrom above,‚Äù then it is imperfect ‚Äúfrom below.‚Äù Or vice versa, ‚Äúfrom below‚Äù is an ideal code, and ‚Äúfrom above‚Äù - imperfect architectural solutions. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : We often talk about refactoring, and many perceive it negatively. For example, "everything worked, but then we did refactoring." Can we say that when using UML-modeling codes initially became a ray, and refactoring became less common? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: If everything works, and no external changes occur, then you do not need to do refactoring. Refactoring is not an end in itself, it is a way to achieve the goal more quickly and accurately, not allowing the code to turn into a ‚ÄúRussian salad‚Äù. The use of UML with code generation, even in the simplest version, automatically structures the code immediately. So, of course, yes. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : A painful question is the synchronization of UML diagrams and program code. Is 100% compliance achieved? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Achieved. Due to the fact that there is 100% code generation from model to code. While it was not, I myself was a great opponent of modeling. I considered drawing diagrams as ‚Äúmonkey labor‚Äù. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A: Yes, due to the fact that there is no reverse, synchronization is always one way. And past it you will not pass. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ie Is code generation an essential condition for the effective implementation of UML in the development process? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Of course. Moreover, if there is no code generation, and there is no constant generation, then at some point the diagram starts to be ‚Äújust a picture‚Äù. She "foul." She is about nothing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And of course, as we have said, code generation allows you to "encode" the code, I apologize for the tautology - much faster. Believe me, the above examples have already been cited, and I still have a million of them. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: I would say categorically, code generation is the key point of using UML. At least for us. Understand what the thing is, I will now say a strange thing that runs counter to the topic of our discussion: we do not use UML at all in the classical sense. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Well, ‚Äúarrived‚Äù, explain what you mean? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Do not worry, I certainly exaggerate a little. </font><font style="vertical-align: inherit;">As I have already hinted above, UML for us is only a form of ‚Äúsquares‚Äù, a specific graphical notation and nothing more. </font><font style="vertical-align: inherit;">We took it as a set of primitives in a graphic editor, and built something substantially larger from them. </font><font style="vertical-align: inherit;">The templates we talked about above allow us to describe any metamodel in terms of these UML primitives, Alexander already listed them above, ‚ÄúClass‚Äù, ‚ÄúCategory‚Äù, ‚ÄúCommunication‚Äù, etc. </font><font style="vertical-align: inherit;">And as a result, to get new terms, new primitives, already a level higher and, moreover, recursively, if necessary, using which, a specific designer or programmer will create a specific model and receive code from it.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in fact, templates are what form a particular DSL and compile a model drawn on it into code, and UML is just a way of drawing this model. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a person, even well acquainted with the classic UML, may not immediately "enter" what he sees drawn with us. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Are the ‚Äútime lost‚Äù justifications for creating code in graphic notation increasing its quality? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : From my point of view, they are justified. Due to the possibility of stereotypes of a higher level. As soon as we see that the design decisions begin to repeat. Moreover, the model affects the development framework, and the framework affects the model. Well, in the presence of a model (and tests), refactoring moves to a completely different level of quality, as mentioned above. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Alexander said about high-level stereotypes, this is a separate very important topic, and this is the most powerful mechanism that we now know. This is what allows turning atoms into mollecules, mollecules into alloys, parts, aggregates and, finally, into a finished product. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : You mentioned tests in the context of refactoring. Does this mean that in general, without tests, there is nothing to think about refactoring, and without refactoring and modeling is not particularly necessary? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: In my opinion, it is better, of course, first to test, and then UML, modeling, code generation. But here it has historically been the opposite. But I would certainly now prefer tests first. We are not "just thinking about tests." We know what they are. That they "will show errors tomorrow." And show. But of course - ‚Äúwe are thinking about tests.‚Äù We are writing "proactive" tests. We have ‚Äúregression tests‚Äù. There are tests that test requirements. And they allow refactoring without much damage to quality. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : I do not agree with Alexander, it seems to me that these are complementary things, and where to begin is not so important. Rather, it should be determined by the internal culture and preferences of the team. I would have started all the same with modeling, in the end, tests can and should also be generated and not written by hand.</font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alexander, as I understood, initially you were an opponent of UML? Looking back (perhaps with a smile), is it possible to say that you thought this way: ‚Äúwhy do I need UML, do I control my code anyway?‚Äù </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : It was just me personally who, long ago, realized that ‚Äúthere are problems‚Äù . But without code generation and constant synchronization with the model, I did not understand how UML can personally help me. Now, I understand and use it every day, although it is certainly not easy for UML, as we have said above.</font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Has ‚Äúyour UML‚Äù become another way to document software code? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Yes, of course. Moreover, all our models are integrated into a common hypertext knowledge base. It also contains bug-tracking and requirements.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... and much more, that is our know-how. By the way, the integration is also built on the same templates: the html for the base is generated from the model, like the source code, and automatically placed on the server. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In what form are UML models integrated? Not in the form of the same pictures! </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In the form of pictures with hyperlinks and explanatory documentation. But from the picture you can always go to the real diagram in the tool to work with UML. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : and vice versa, and also the changing tasks and commits to the repository are attached to them automatically. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Are UML diagrams used to interact with non-programmers? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A: At the beginning of implementation, we tried to use UML for interaction. All requirements were designed as UseCase and Sequence diagrams. In the most understandable, as it seemed to us, for a non-specialist form. The first version of the F1 system, our colleagues, lawyers and marketers who set the task, honestly tried to read from the diagrams, and they even got it. But ..., let's say, the practice has not taken root. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Still, not techies (not by education, but by vocation), do not really like all sorts of formal languages. They subconsciously easier in Russian literary, not UML. This is from the category of psychology. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : What UML-diagrams and in what volume are used? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : First of all, class diagrams and UseCases. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Do you find other charts less useful? For example, are there enough ‚Äúbrains‚Äù of programmers to do without the diagram of ‚Äúobjects‚Äù? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : No. Sometimes we use state diagrams, describe them, and generate state machine code.</font></font> But it is very rare.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of finite automata, at the formal level, also requires a certain sharpening of the brain. In some places, sequence is used, but only as an illustration, i.e. as a ‚Äúdead chart‚Äù, now nothing is generated from them, which means, as Alexander said above, her life time is very short. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Perhaps, the Sequence is even more useful, just until you reach out to do the appropriate code generation for them. A diagram of "objects" is just those very chains of SAX-filters. When we operate not with classes, but with their instances. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The classic RAD approach clamps the programmer into a fairly narrow frame. Database, interface, form, components, events, response procedures. How did you manage to expand this framework with UML? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: UML "pinches" in the framework of the "meta-model", which is developed. But this is partly sought. Compared to RAD, impurities and AOP elements are used much more actively. As well as a declarative, rather than an imperative approach to some parts of the projects.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the model, a ‚Äúdata model‚Äù is drawn to the maximum divorced from what it should physically turn into, and it is transformed into an ‚Äúactive code‚Äù with the help of a code generator. For example, the "scheme of the document" or a set of "settings" of the project. All sorts of SAX filter chains, etc. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : It is important that he pinches where you decide. The metamadel does not impose any rules on its author; it imposes them only on the model and on the one who will create it. In one place you pinch, and in the other - give the unique flexibility and speed of the lego-designer. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : How does the use of models affect the architecture of the application and the structure of the program code? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: It's certainly not just models. The point is "brain hygiene." But the correct use of modeling enhances it. And, yes, the model is an assistant. I will make a reservation, if there is no desire to improve, then no models will help. As, however, and any other practice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the UML architecture and modeling have a positive effect :-) Logical layers appear. Parasitic cyclic dependences disappear, and so on. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : We will work in the "blitz" mode. When do you think you do not need to apply UML and modeling? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : For research and other studies. For the project "for two or three months," which then most likely will not have to be supported. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: If UML is used only for drawing, I agree with Alexander, but if for metamodeling and code generation, then I think that it is possible and necessary to use it always, especially if you are used to doing it. Of course, if this is not "hello world". Although it will probably be easier for me to generate ‚Äúhello world‚Äù, at least I don‚Äôt need to remember how to make a new project in IDE :), because projects are also generated here. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : At what point of development and on what grounds can we say that the way you use UML is effective? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : It is enough to compare the time of writing some functionality "manually" or your way. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: The only thing is that there are still technical limitations of a specific instrument; sometimes they can have a very negative effect. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : How to gradually begin to introduce modeling into the production process? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : You can start at any time. The main thing is not to immediately try to ‚Äúembrace the immense‚Äù. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : What part of the tasks can be closely integrated with UML and code generation, and what can be left "as is"? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : you can leave some not very structured, unique algorithms, something, in which there is no template, reuse, some kind of system that can be formalized and reproduced. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: I have not all the most transferred to the model. I first of all translate either new classes / entities. Or those that affect the process of alterations. Or those that "refactor." </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Probably, other approaches were tried. Is there an alternative to UML in the modern world of software development? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : For us, in the form in which we use it, it is not. But I have already said above that it is generally not very important in what concrete way to draw arrows with squares. The main thing that we do with it, and not what it looks like. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: I will clarify that in fact there are many alternatives to UML, and precisely because for us this is simply a way of describing a model. You can take any other graphical notation that has in the basis of the concepts we need, and use it. You can describe your own. It is possible in general, and I actively think about it, go to the text description of the model, i.e. create another DSL. There are many options and they can be combined. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Are there any limits to the possibilities of your approach? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : as soon as you start to create your own meta-models, any restrictions disappear, you may lack only imagination and the ability to see the private in general. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Is everything so wonderful, and there are no problems whatsoever? I want to shout in the best theatrical traditions: ‚ÄúI do not believe‚Äù!</font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Of course, there is. First of all, the limitations of the tool. Insufficient generation rate on large models. Non-optimal UML interface editor, etc. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : the problem is not ideological, but technological. We gradually grow out of the tools that have been made for a long time and for many years retained their relevance. The generator requires updating, making modifications. But this is probably not a ‚Äúproblem‚Äù, but a ‚Äútask‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also use a separate package as a UML scoop. Yes, it is already part of our "pipeline", but it would not hurt him to improve, update. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : your plans? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Write your entire tool - model editor. So to say, to do "work on the bugs" in existing ones.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : And with that - cross-platform. In general, in this direction there are also a lot of ideas on how to make the modeling process even more efficient. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In the next article we will discuss DSL? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Yes, of course. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : With pleasure! </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vsevolod</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : As an employee of Embarcadero, using my official position, I ask ... Do you use Delphi? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Yes, I use Delphi in development. I know about the contradictions between RAD and UML, and I try to use the strengths of each technology and achieve significant synergy. I do not use Delphi as a pure RAD tool for placing buttons on forms. This is one of the components of a rather complex technological chain. Now we are in the process of transition to Delphi XE4. There is a need for 64-bits. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maksim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: I grew up in C ++, but in a highly heterogeneous environment, in the projects in which I participated, Delphi, C ++, python, java, etc. were used at the same time, so I never supported holivars what is ‚Äúbetter‚Äù - every time you wear a buckle. As a project manager, the main thing for me is the effectiveness of the solution as a whole. Our company uses Delphi for a long time and intensively, the main thing is to know the strengths and weaknesses of each tool, its potential, to correctly make on the basis of this decision, to build a technological cycle, to select professionals so that they would most closely match the tool. In this sense, Delphi is quite suitable for us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Alexander and Maxim will respond under the Vsevolod account, adding their names to the top of the comment.</font></font></div><p>Source: <a href="https://habr.com/ru/post/188604/">https://habr.com/ru/post/188604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188586/index.html">The last day of the 21st century or the end of the oil toad?</a></li>
<li><a href="../188590/index.html">Roskomnadzor announced the introduction of the registry of sites with "pirated" movies</a></li>
<li><a href="../188592/index.html">Test automation of Android applications using Robotium and Spoon</a></li>
<li><a href="../188594/index.html">As I wrote fix widescreen permissions for FlatOut</a></li>
<li><a href="../188598/index.html">Own simple DynDNS server</a></li>
<li><a href="../188606/index.html">ORANGEMAN: news about the distribution of servers. Initiative Development</a></li>
<li><a href="../188608/index.html">Cloud networking and network connectivity with the cloud</a></li>
<li><a href="../188612/index.html">Home 3D printer pays off in 1 year</a></li>
<li><a href="../188614/index.html">Landing Page: Experiment Results</a></li>
<li><a href="../188616/index.html">Dell Latitude E6420 ATG - frame laptop for those who understand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>