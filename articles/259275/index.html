<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Problems caused by defining tuples as functors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Very surprising (I would even say - all at once!), But a tuple-pair in GHC is a functor. It is difficult to understand, because the functor must have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Problems caused by defining tuples as functors</h1><div class="post__text post__text-html js-mediator-article"> Very surprising (I would even say - all at once!), But a tuple-pair in GHC is a functor.  It is difficult to understand, because the functor must have only one parameter, and the pair has two of them.  One can admire how the developers of the standard GHC library have managed to provide such an abstraction, but it seems to me that the resulting solution should be considered unsuccessful. <br><br>  To begin with, it is intuitively incomprehensible.  Say, try to calculate manually, without using the GHC tools, the expression <code>(1+) `fmap` (2, 3)</code> .  And after that, check the result obtained, for example, in <code>ghci</code> .  For many, did the result of a manual calculation coincide with the one that the system issued?  And if your results still coincided, I would really like to hear a good explanation of how you did it. <br><a name="habracut"></a><br>  Suppose we define an <code>Incable</code> class of incremental types: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc :: t -&gt; t</code> </pre><br>  Of course, it would be simpler and more logical to define instances of this class for any numeric types: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc = (<span class="hljs-number"><span class="hljs-number">1</span></span>+)</code> </pre><br>  However, such a definition would require us to include an extension of the <code>UndecidableInstances</code> language, and then completely confuse the situation.  Therefore, we confine ourselves to the definitions only for the most basic representatives of the class <code>Num</code> - types <code>Integer</code> and <code>Double</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc = (<span class="hljs-number"><span class="hljs-number">1</span></span>+) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Incable</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> inc = (<span class="hljs-number"><span class="hljs-number">1</span></span>+)</code> </pre><br>  Obviously, for any functor, you can define an instance of the class <code>Incable</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ft</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc = fmap inc</code> </pre><br>  This is a pretty good general definition.  It allows us to work with lists, arrays, <code>Maybe</code> structures and another set of types for which instances of the <code>Functor</code> class are defined.  Among all this diversity will be a pair of incremental values.  However, suppose (even if we have found a convincing explanation for the current behavior of pairs as functors) that in our case it is desirable that both values ‚Äã‚Äãin a pair increase at once.  It would be great to define an instance of the class <code>Incable</code> for pairs as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc (x1, x2) = (inc x1, inc x2)</code> </pre><br>  Alas, it is impossible.  Of course, the compilation of this fragment will be successful, but when we try to use this definition, we will receive a message about overlapping instances: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; inc (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;interactive&gt;:<span class="hljs-number"><span class="hljs-number">105</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-type"><span class="hljs-type">Overlapping</span></span> instances for <span class="hljs-type"><span class="hljs-type">Incable</span></span> (t0, t1) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `inc' <span class="hljs-type"><span class="hljs-type">Matching</span></span> instances: <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> (<span class="hljs-type"><span class="hljs-type">Functor</span></span> f, <span class="hljs-type"><span class="hljs-type">Incable</span></span> t) =&gt; <span class="hljs-type"><span class="hljs-type">Incable</span></span> (ft) <span class="hljs-comment"><span class="hljs-comment">-- Defined at src/Main.hs:16:10 instance (Incable t1, Incable t2) =&gt; Incable (t1, t2) -- Defined at src/Main.hs:18:10 In the expression: inc (1, 2) In an equation for `it': it = inc (1, 2)</span></span></code> </pre><br>  Having defined instances of the class <code>Incable</code> for all functors, we immediately defined it for pairs.  Add to this that in GHC the definition of a class instance cannot be hidden during import.  That is, we get unnecessary behavior of the pair as a functor into the load to those capabilities that we really need. <br><br>  The situation becomes even more complicated if we consider tuples in which there are more than two elements, for example, triples.  What if we need to calculate something like <code>inc (1.0, 2, 3)</code> ?  It would seem that here we definitely should have no problems - the triples were not defined as functors, which means we can implement instances of the <code>Incable</code> class for them as we see fit: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t3</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Incable</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t3</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> inc (x1, x2, x3) = (inc x1, inc x2, inc x3)</code> </pre><br>  Again, the compilation is successful, and an error occurs during execution: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; inc (<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) &lt;interactive&gt;:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-type"><span class="hljs-type">Overlapping</span></span> instances for <span class="hljs-type"><span class="hljs-type">Incable</span></span> (t0, t1, t2) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `inc' <span class="hljs-type"><span class="hljs-type">Matching</span></span> instances: <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> (<span class="hljs-type"><span class="hljs-type">Functor</span></span> f, <span class="hljs-type"><span class="hljs-type">Incable</span></span> t) =&gt; <span class="hljs-type"><span class="hljs-type">Incable</span></span> (ft) <span class="hljs-comment"><span class="hljs-comment">-- Defined at src/Main.hs:18:10 instance (Incable t1, Incable t2, Incable t3) =&gt; Incable (t1, t2, t3) -- Defined at src/Main.hs:20:10 In the expression: inc (1.0, 2, 3) In an equation for `it': it = inc (1.0, 2, 3)</span></span></code> </pre><br>  Well, it turns out that the triples, too, cannot be defined separately - they, like couples, are considered a kind of functors.  Maybe our definition of an incremental triple is not needed?  No matter how wrong!  Remove this definition and try again: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; inc (<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) &lt;interactive&gt;:<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">Functor</span></span> ((,,) t0 t1)) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `inc' <span class="hljs-type"><span class="hljs-type">Possible</span></span> fix: add an <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> declaration for (<span class="hljs-type"><span class="hljs-type">Functor</span></span> ((,,) t0 t1)) <span class="hljs-type"><span class="hljs-type">In</span></span> the expression: inc (<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-type"><span class="hljs-type">In</span></span> an equation for `it': it = inc (<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Now we are asked to define a triple as a functor.  Maybe we can <code>Functor</code> to define an instance of the class <code>Functor</code> for the troika as we need it? <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> ((,,) t1 t2) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (x1, x2, x3) = (fmap f x1, fmap f x2, fmap f x3)</code> </pre><br>  In no way, we cannot even compile such a definition: <br><br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">Main</span></span> ( src/<span class="hljs-type"><span class="hljs-type">Main</span></span>.hs, interpreted ) src/<span class="hljs-type"><span class="hljs-type">Main</span></span>.hs:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span>: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match expected <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `b' with actual </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `f0 b' `b' is a rigid </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> variable bound by the </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> signature for fmap :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) at src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:5 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the return </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> of a call of `fmap' </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: fmap f x3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x3</span></span></span><span class="hljs-class">) src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:43: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Couldn't</span></span></span><span class="hljs-class"> match expected </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `a' with actual </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `f0 a' `a' is a rigid </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> variable bound by the </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> signature for fmap :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) at src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:5 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the second argument of `fmap', namely `x3' </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: fmap f x3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x3</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Failed</span></span></span><span class="hljs-class">, modules loaded: none.</span></span></code> </pre><br>  As a last chance, let's try to define a triple as a functor by analogy with a pair: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> ((,,) t1 t2) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (x1, x2, x3) = (x1, x2, fmap f x3)</code> </pre><br>  Alas, this definition is not compiled for the same reason as the previous one: <br><br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">Main</span></span> ( src/<span class="hljs-type"><span class="hljs-type">Main</span></span>.hs, interpreted ) src/<span class="hljs-type"><span class="hljs-type">Main</span></span>.hs:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span>: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match expected <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `b' with actual </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `f0 b' `b' is a rigid </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> variable bound by the </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> signature for fmap :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) at src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:5 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the return </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> of a call of `fmap' </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: fmap f x3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x3</span></span></span><span class="hljs-class">) src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:43: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Couldn't</span></span></span><span class="hljs-class"> match expected </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `a' with actual </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `f0 a' `a' is a rigid </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> variable bound by the </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> signature for fmap :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) at src/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Main</span></span></span><span class="hljs-class">.hs:19:5 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the second argument of `fmap', namely `x3' </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: fmap f x3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">In</span></span></span><span class="hljs-class"> the expression: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x3</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Failed</span></span></span><span class="hljs-class">, modules loaded: none.</span></span></code> </pre><br><h3>  Discussion </h3><br>  Generally speaking, we can say that the definition of a tuple-pair as a functor was not an entirely successful solution.  In some cases, this creates serious difficulties that prevent us from using the abstraction of the functor.  It is very important to answer two basic questions.  First, why did you even need to define an instance of the class <code>Functor</code> for couples?  Secondly, how is it possible (and is it even possible) to give a similar definition for tuples with more than two elements (for example, for a triple)? <br><br>  In addition, the definition of a pair as a variety of functors is not entirely logical.  It is considered that a functor is always a type that has only one parameter.  At the same time, even the simplest tuple (pair) already has two parameters.  At the same time, it is completely unclear why in the definition of an instance of the class <code>Functor</code> for a pair, only one parameter is indicated, and not two? <br><br>  Of course, it would be logical (and even justified) to confine ourselves to defining instances of the class <code>Functor</code> for tuples of the same type, that is, tuples of the type <code>(t, t)</code> , <code>(t, t, t)</code> , etc. At first glance, such Tuples are no different from lists, but their important feature is that they are tough, at the compilation stage, they specify the number of their elements.  Such types can represent, for example, pairs and triples of integers that must be processed simultaneously and in the same way.  In the general case, it would be more correct to use <i>multiparameter</i> functors. <br><br>  A multiparameter functor is a kind of generalization of the ordinary functor, but for types with several parameters.  For example, a two-parameter functor can be defined as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor2</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap2 :: (a1 -&gt; b1) -&gt; (a2 -&gt; b2) -&gt; f a1 a2 -&gt; f b1 b2</code> </pre><br>  The logic here is that we use not one function, but two, and each of them is applied to its own parameter of the functor.  In this case, the pair could be defined as a two-parameter instance, and the triple could be defined as an instance of a three-parameter functor.  Now, if we accept this definition, we will have a clear idea of ‚Äã‚Äãhow each element of the tuple is processed, and we can even change this behavior if necessary.  However, it is unclear how useful such abstractions are, and whether there are other useful types in these classes besides tuples. <br><br>  It remains only to say that this is not exactly what we wanted to receive.  In fact, we began by using the functor as a good model for homogeneous calculations.  In our case, even though the elements of the pair are of different types, they all belong to the same class (incremental types, with a more abstract approach, numerical types in general), and the function we use is polymorphic.  Therefore, we could well do the usual functor, if we could tell the compiler these features of our subject area.  Alas, at the present time I do not quite imagine how this can be done. <br><br><h3>  findings </h3><br>  As a result of the discussion (thanks to him to all the readers who immediately responded to my problems) I managed to formulate certain results.  As the author, I decided to slightly correct the article so that it does not leave the impression of incompleteness. <br><br>  First of all, I want to apologize for a very annoying mistake that I made when defining triples as functors.  Of course, the correct code should look like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> ((,,) t1 t2) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (x1, x2, x3) = (x1, x2, f x3)</code> </pre><br>  This code is compiled and works as expected - the changes concern only the last element.  Similarly, in our case, I would like to implement a code of the form: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> ((,,) t1 t2) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (x1, x2, x3) = (f x1, f x2, f x3)</code> </pre><br>  But it does not compile, although for a slightly different reason: <br><br><pre>  [1 of 1] Compiling Main (src / Main.hs, interpreted)<font></font>
<font></font>
 src / Main.hs: 19: 28:
     Couldn't match type `b 'with` t2'
       `b 'is a rigid type variable bound by
           the type signature for
             fmap :: (a -&gt; b) -&gt; (t1, t2, a) -&gt; (t1, t2, b)
           at src / Main.hs: 19: 5
       `t2 'is a rigid type variable bound by
            the instance declaration at src / Main.hs: 18: 10
     Expected type: t1
       Actual type: b
     In the return type of a call of `f '
     In the expression: f x1
     In the expression: (f x1, f x2, f x3)<font></font>
<font></font>
 src / Main.hs: 19: 30:
     Couldn't match type `t1 'with` t2'
       `t1 'is a rigid type variable bound by
            the instance declaration at src / Main.hs: 18: 10
       `t2 'is a rigid type variable bound by
            the instance declaration at src / Main.hs: 18: 10
     Expected type: a
       Actual type: t1
     In the first argument of `f ', namely` x1'
     In the expression: f x1
     In the expression: (f x1, f x2, f x3)<font></font>
<font></font>
 src / Main.hs: 19: 34:
     Couldn't match type `a 'with` t2'
       `a 'is a rigid type variable bound by
           the type signature for
             fmap :: (a -&gt; b) -&gt; (t1, t2, a) -&gt; (t1, t2, b)
           at src / Main.hs: 19: 5
       `t2 'is a rigid type variable bound by
            the instance declaration at src / Main.hs: 18: 10
     Expected type: t2
       Actual type: b
     In the return type of a call of `f '
     In the expression: f x2
     In the expression: (f x1, f x2, f x3)
 Failed, modules loaded: none.
</pre><br>  Now I understand exactly how the pairing trick was done.  In fact, any multiparameter type can be transformed into a one-parameter one by partial application, and then a functor can be realized for it. <br><br>  Nevertheless, I still insist that the definition of a pair as a functor at the system library level was a bad decision.  This is supported by the fact that for other multiparameter types (for example, higher-order tuples, maps, etc.), instances of the <code>Functor</code> class are not provided in the system library.  I suspect that the developers simply needed the behavior of the functor for pairs somewhere "in place", and then they found it useful to raise it to the system level.  To test this version, the easiest way is to rebuild the system library without defining pairs as functors, but I don‚Äôt have time for such an experiment right now. <br><br>  Obviously, at the system level, it is reasonable to leave only the definition of pairs as <a href="https://hackage.haskell.org/package/bifunctors-5">bifunctors</a> , and even generalize this approach for <a href="https://hackage.haskell.org/package/genifunctors-0.3/docs/Data-Generics-Genifunctors.html">higher order</a> functors.  Of course, it always remains possible, by partial application, to obtain a simplified definition of a functor of a lower order than the type order.  In this case, the structure elements excluded by the partial application of types can no longer be processed.  It is more logical to describe the same behavior by a partial application of the mapping function, in which the first arguments are the identical function of <code>id</code> .  Unlike globally defined instances, such reduced display functions are easily hidden when necessary when importing the corresponding module. </div><p>Source: <a href="https://habr.com/ru/post/259275/">https://habr.com/ru/post/259275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259263/index.html">Questions to meet with Opera Software in Petersburg</a></li>
<li><a href="../259265/index.html">Lua, OOP and nothing more</a></li>
<li><a href="../259269/index.html">[UPD] Programming 1986E91T microcontrollers in Qt Creator</a></li>
<li><a href="../259271/index.html">PVS-Studio - we invite you to listen and watch</a></li>
<li><a href="../259273/index.html">Sales funnel in CRM: do not be gadgets, analyze losses</a></li>
<li><a href="../259277/index.html">Eight different types of programmers</a></li>
<li><a href="../259279/index.html">Looking for the perfect javascript framework</a></li>
<li><a href="../259281/index.html">Node.JS Loading modules on demand</a></li>
<li><a href="../259283/index.html">Understanding UEFI and GPT: Installing Windows and Kubuntu on a single disk</a></li>
<li><a href="../259285/index.html">Bolts in tea, or a webinar on probability theory in practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>