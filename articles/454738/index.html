<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visual Studio 2019 support in PVS-Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The support of Visual Studio 2019 in PVS-Studio affected several different components at once: the plug-in for the IDE itself, the command line analys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visual Studio 2019 support in PVS-Studio</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  The support of Visual Studio 2019 in PVS-Studio affected several different components at once: the plug-in for the IDE itself, the command line analysis application, the C ++ core and the C # analyzers, as well as several utilities.  About what problems we encountered during the support of the new version of the IDE and how they were solved, I will briefly describe in this article. <br><a name="habracut"></a><br>  Before you start, you want to look back a little to trace the history of support for past versions of Visual Studio, which will give a better understanding of our vision of the problem and the decisions made in certain situations. <br><br>  Starting from the first version of the PVS-Studio analyzer, in which the plug-in for Visual Studio appeared (then it was Visual Studio 2005), support for new versions of Visual Studio was quite a simple task for us - basically it was about updating the plug-in project file and dependencies of various Visual Studio extensions APIs.  Sometimes it was required to additionally support new features of the C ++ language, which the Visual C ++ compiler gradually learned, but this also usually did not cause problems immediately before the release of the next edition of Visual Studio.  And then there was only one analyzer in PVS-Studio - for C and C ++ languages. <br><br>  Everything changed for the release of Visual Studio 2017. In addition to the fact that many APIs for expanding this IDE were very significantly changed in this version, after the upgrade we faced problems ensuring the backward compatibility of the new C # analyzer that appeared at that time (as well as our new C ++ layer). analyzer for MSBuild projects) with older versions of MSBuild \ Visual Studio. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, before reading this article, I strongly recommend that you read the related article about Visual Studio 2017 support: " <a href="https://www.viva64.com/ru/b/0503/">Support for Visual Studio 2017 and Roslyn 2.0 in PVS-Studio: sometimes using ready-made solutions is not as easy as it seems at first glance</a> ."  The article mentioned above describes the problems that we encountered last time, as well as the interaction patterns of various components (for example, PVS-Studio, MSBuild, Roslyn).  Understanding this interaction will be useful when reading this article. <br><br>  Ultimately, the solution of these problems introduced significant changes to our analyzer, and, as we hoped, new approaches that we applied then will make it possible in the future to support updated versions of Visual Studio \ MSBuild much easier and faster.  In part, this assumption has already been confirmed when numerous Visual Studio 2017 updates were released. Did this new approach help us with the support of Visual Studio 2019?  About this below. <br><br><h2>  PVS-Studio plugin for Visual Studio 2019 </h2><br>  It all started, it would seem, not bad.  It was quite easy to port the plugin to Visual Studio 2019, where it started and worked fine.  Despite this, 2 problems were immediately revealed, which promised trouble in the future. <br><br>  The first is the <i>IVsSolutionWorkspaceService</i> interface used to support the Lightweight Solution Load mode, which, by the way, was disabled in one of the previous updates in Visual Studio 2017, was decorated with the <i>Deprecated</i> attribute, which was only a warning when building, but in the future promised more Problems.  Quickly, Microsoft introduced this mode and abandoned it ... They figured out this problem quite simply - they refused to use the corresponding interface. <br><br>  The second is that when loading Visual Studio with the plugin, the following message appears: <br><br>  Viewing the launch logs of Visual Studio (ActivityLog file) finally dot the 'i': <br><br>  <i>Warning: Extension 'PVS-Studio' uses the 'synchronous auto-load' feature of Visual Studio.</i>  <i>This feature will not be supported.</i>  <i>Please contact the extension vendor to get an update.</i> <br><br>  For us, this meant one thing - changing the way the plugin was loaded into asynchronous mode.  I hope you will not be upset if I do not overload you with details on the interaction with COM interfaces of Visual Studio, and I‚Äôll go over the changes briefly. <br><br>  Microsoft has an article on <a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-use-asyncpackage-to-load-vspackages-in-the-background%3Fview%3Dvs-2019">how to</a> create asynchronously loaded plugins: " <a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/how-to-use-asyncpackage-to-load-vspackages-in-the-background%3Fview%3Dvs-2019">How to: Use AsyncPackage to load VSPackages in the background</a> ".  At the same time it was obvious to everyone that the matter would not be limited to these changes. <br><br>  One of the main changes is the method of loading, or rather, initialization.  Previously, the necessary initialization took place in two methods - the overrided <i>Initialize</i> method of our class-descendant <i>Package,</i> and the <i>OnShellPropertyChange</i> method.  The need to remove part of the logic into the <i>OnShellPropertyChange</i> method is due to the fact that during synchronous loading of the plug-in, Visual Studio may not be fully loaded and initialized, and as a result, not all the necessary actions could be performed at the initialization stage of the plug-in.  The solution to this problem is to wait for Visual Studio to exit the 'zombie' state and defer the execution of these actions.  This is the logic that was rendered in <i>OnShellPropertyChange</i> with the status 'zombie' checked. <br><br>  In the abstract class <i>AsyncPackage</i> , from which asynchronously loaded plugins inherit, the <i>Initialize</i> method has the <i>sealed</i> modifier, so initialization needs to be done in the redefined <i>InitializeAsync</i> method, which was done.  The logic with the zombie tracking of the state of Visual Studio also had to be changed, since we stopped receiving this information in the plugin.  However, a number of actions that had to be performed after initializing the plug-in did not go anywhere.  The <i>solution</i> was to use the <i>OnsPackageLoaded</i> method of the <i>IVsPackageLoadEvents</i> interface, where actions that require pending execution were performed. <br><br>  Another problem logically stemming from the fact of asynchronous loading of the plug-in is the absence of the PVS-Studio plug-in commands when Visual Studio starts.  When you open the analyzer's double-click log from the file manager (if you need to open it through Visual Studio), the required version of devenv.exe was launched with the command to open the analyzer report.  The startup team looked like this: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  The "/ command" flag here is used to invoke a command registered in Visual Studio.  Now this approach did not work, since the commands were not available until the plug-in was loaded.  As a result, I had to stop at the ‚Äúcrutch‚Äù with parsing the devenv.exe launch line after loading the plug-in, and if there is a string representation of the command for opening the log, the log download itself.  Thus, having refused in this case to use the ‚Äúcorrect‚Äù interface for working with commands, we managed to preserve the necessary functionality, postponing the loading of the log until the full load of the plug-in. <br><br>  Fuh, it seems to have figured out and everything works - everything loads and opens correctly, there are no warnings at last. <br><br>  And here comes the unexpected - Paul (hello!) Installs a plugin for himself, and then asks why we didn‚Äôt do asynchronous loading? <br><br>  To say that we were surprised - to say nothing - like that?  No, really - here is a new version of the plug-in installed, here's a message stating that the package is synchronously downloadable.  We install the same version of the plug-in on our cars with Alexander (and you, too, hello) - all is well.  Nothing is clear - we decided to see which versions of the PVS-Studio libraries are loaded into Visual Studio.  And suddenly it turns out that the versions of the PVS-Studio libraries for Visual Studio 2017 are being used, despite the fact that the VSIX package contains the correct versions of the libraries - for Visual Studio 2019. <br><br>  Fumbling with VSIXInstaller, we managed to find the cause of the problem - the package cache.  The theory was also confirmed by the fact that when the access rights to the package in the cache were restricted (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages), VSIXInstaller wrote error information to the log.  What is surprising, if there is no error, no information about the fact that the package is installed from the cache is not written to the log. <br><br>  <b>Note</b>  Studying the behavior of VSIXInstaller and related libraries, I noted to myself that it is very great that Roslyn and MSBuild have open source code that makes it convenient to read, debug, and track the logic of work. <br><br>  As a result, the following happened - when installing the VSIXInstaller plug-in, I saw that the corresponding package was already in the cache (there was a .vsix package for Visual Studio 2017), and during installation it used it, rather than the package being actually installed.  Why it does not take into account the restrictions / requirements described in .vsixmanifest (for example, the version of Visual Studio for which the extension can be installed) is an open question.  Because of this, it turned out that, although .vsixmanifest contained the necessary restrictions, the plug-in designed for Visual Studio 2017 was installed on Visual Studio 2019. <br><br>  The worst thing is that such a setup broke the dependency graph of Visual Studio, and although outwardly it might even seem that the development environment was working fine, in fact, everything was very bad.  It was impossible to install and remove extensions, make updates, and so on.  The process of 'recovery' was also quite unpleasant, because  it was necessary to manually remove the extension (the corresponding files), as well as manually edit the configuration files that store information about the installed package.  In general - pleasant enough. <br><br>  To solve this problem and avoid similar situations in the future, it was decided to create a GUID for the new package in order to completely separate the Visual Studio 2017 and Visual Studio 2019 packages (with older packages there is no such problem, and they always used a common GUID). <br><br>  And since it was about unpleasant surprises, I‚Äôll mention one more - after updating to Preview 2, the 'moved' menu item under the 'Extensions' tab.  It would seem - nothing terrible, but access to the functions of the plugin has become less convenient.  On subsequent versions of Visual Studio 2019, including the release version, this behavior is preserved.  I did not find any mention of this 'feature' at the time of its release in the documentation or blog. <br><br>  Now, it would seem, everything works, and with the support of the plugin for Visual Studio 2019 is over.  The next day after the release of PVS-Studio 7.02 with Visual Studio 2019 support, it turned out that this was not the case - another problem with an asynchronous plugin was found.  For a user, this could look like this: when opening a window with analysis results (or launching an analysis), our window was sometimes displayed ‚Äúempty‚Äù - there was no content in it: buttons, a table with analyzer warnings, etc. <br><br>  In fact, this problem was sometimes repeated in the course of work.  However, it was repeated only on one machine, and began to appear only after updating Visual Studio in one of the first versions of 'Preview' - there were suspicions that something broke during installation / upgrade.  Over time, the problem, however, ceased to repeat even on this machine, and we decided that it ‚Äúfixed itself‚Äù.  It turned out that no - just so lucky.  More precisely, no luck. <br><br>  The case turned out to be in the order of initialization of the environment window itself (the successor of the <i>ToolWindowPane</i> class) and its contents (in fact, our control with a grid and buttons).  Under certain conditions, the initialization of the control occurred before the initialization of the pane, and, despite the fact that everything worked without errors, the <i>FindToolWindowAsync</i> method (creating the window during the first access) correctly worked, but the control remained invisible.  We fixed this by adding lazy initialization for our control to the pane fill code. <br><br><h2>  C # 8.0 support </h2><br>  Using Roslyn as a basis for the analyzer has a significant advantage - there is no need to manually support new language constructs.  All this is supported and implemented in the framework of the Microsoft.CodeAnalysis libraries - we use the already-made results.  Thus, support for new syntax is implemented by updating the libraries. <br><br>  Of course, with regard to static analysis directly, here you have to do everything yourself, in particular, to process new language constructs.  Yes, we get the new syntactic tree automatically by using a more recent version of Roslyn, but we need to teach the analyzer how to perceive and process new / modified tree nodes. <br><br>  I think the most discussed innovation of C # 8 are nullable reference types.  I will not write about them here - this is a big enough topic worthy of a separate article (which is already in the process of writing).  In general, we have so far stopped at ignoring nullable annotations in our dataflow mechanism (that is, we understand them, parse and skip them).  The fact is that despite the non-nullable reference type of a variable, you can still quite simply (or by mistake) write the value <i>null</i> , which can lead to NRE when dereferencing the corresponding reference.  In this case, our analyzer may see a similar error and issue a warning to use a potentially null reference (of course, if it sees such an assignment in the code) despite the non-nullable reference type of the variable. <br><br>  I want to note that the use of nullable reference types and the accompanying syntax opens up the possibility of writing very interesting code.  For ourselves, we called it 'emotional syntax'.  The code below compiles itself quite well: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  By the way, in the course of the work, I found a couple of ways to 'fill up' with Visual Studio using the new syntax.  The fact is that you can not limit the number of characters to one when you put '!'.  That is, you can write not only the code of the form: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  but also: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  You can pervert, go ahead and write like this: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  This code is successfully compiled.  But if you request information about the syntax tree using the Syntax Visualizer from the .NET Compiler Platform SDK, Visual Studio will crash. <br><br>  From the Event Viewer, you can pull information about the problem: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  If you go further and increase the number of exclamation marks several times, Visual Studio will fall by itself - the help of Syntax Visualizer will not be needed for this.  The Microsoft.CodeAnalysis libraries and the csc.exe compiler also do not digest this code. <br><br>  Of course, these are synthetic examples, but still this fact seemed funny to me. <br><br><h2>  Toolset </h2><br>  <b>Note</b>  Again I face the problem of translating the word 'evaluation' in the context of a conversation about MSBuild projects.  The translation, which seemed to be the closest in meaning and at the same time sounding normal - ‚Äúbuilding a model of the project‚Äù.  If you have alternative translation options - you can write to me, it will be interesting to read. <br><br>  It was obvious that updating the toolset would be the most time consuming task.  More precisely, it seemed so initially, but now I am inclined to think that the plug-in support was the most problematic.  In particular, this was related to the already existing toolset and the mechanism for building the model of MSBuild projects, which was still working successfully now, although it required expansion.  The lack of need to write algorithms from scratch greatly simplified the task.  Our bet on ‚Äúour‚Äù toolset, made at the stage of support for Visual Studio 2017, has once again been justified. <br><br>  Traditionally, it all starts with updating NuGet packages.  On the management tab of the NuGet packages, there is an 'Update' button for the solution ... which does not work.  When updating all packages, multiple version conflicts arose, and resolving them all didn‚Äôt seem to be the right way.  A more painful, but, it seems, more reliable way is the 'piecewise' update of target Microsoft.Build / Microsoft.CodeAnalysis packages. <br><br>  One of the differences was immediately revealed by tests of diagnostic rules - the structure of the syntactic tree for an already existing node has changed.  It's okay, corrected quickly. <br><br>  Let me remind you that during the work we test analyzers (C #, C ++, Java) on open source projects.  This allows a good test of diagnostic rules ‚Äî to find, for example, false positives, or to get an idea of ‚Äã‚Äãwhich other cases have not been considered (reduce the number of false negatives).  These tests also help to track possible regression in the initial update of the toolset libraries.  And this time was no exception, since a number of problems surfaced. <br><br>  One of the problems was the deterioration of behavior within CodeAnalysis libraries.  More specifically, on a number of projects in the code of libraries, exceptions began to arise during various operations - obtaining semantic information, opening projects, etc. <br><br>  Attentive readers of the article about support for Visual Studio 2017 will remember that our distribution contains a stub - the MSBuild.exe file, 0 bytes in size. <br><br>  This time I had to go further - now the distribution kit also contains empty compiler stubs - csc.exe, vbc.exe, VBCSCompiler.exe.  What for?  The path to this began with the analysis of one of the projects in the test database, on which the "diffs" of reports appeared - a number of warnings were absent when using the new version of the analyzer. <br><br>  The problem turned out to be in conditional compilation symbols - when analyzing a project using the new version of the analyzer, some of the characters were extracted incorrectly.  In order to better understand why this problem arose, we had to plunge into the Roslyn libraries. <br><br>  To parse conditional compilation characters, use the <i>GetDefineConstantsSwitch</i> method of the <i>Csc</i> class from the <i>Microsoft.Build.Tasks.CodeAnalysis</i> library.  Parsing is performed using the <i>String.Split</i> method on a number of delimiters: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  This parsing method works fine, all the necessary conditional compilation characters are retrieved successfully.  We dig further. <br><br>  The next key point is calling the <i>ToolTask</i> class's <i>ComputePathToTool method</i> .  This method builds the path to the executable file ( <i>csc.exe</i> ) and checks its presence.  If the file exists, the path to it is returned, otherwise <i>null is</i> returned. <br><br>  Calling code: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Since there is no <i>csc.exe</i> file (it would seem, why do we need it?), <i>PathToTool is null</i> at this stage, and the current method ( <i>ToolTask.Execute</i> ) completes its execution with a <i>false</i> result.  As a consequence, the results of the task, including the resulting conditional compilation characters, are ignored. <br><br>  Well, let's see what happens if you put the <i>csc.exe</i> file in the expected place. <br><br>  In this case, <i>pathToTool</i> indicates the actual location of the existing file, and execution of the <i>ToolTask.Execute</i> method continues.  The next key point is the call to the <i>ManagedCompiler.ExecuteTool</i> method.  And it begins as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  The <i>SkipCompilerExecution</i> property is <i>true</i> (logically, we are not performing the actual compilation).  As a result, the calling method (already mentioned <i>ToolTask.Execute</i> ) checks that the return code of the <i>ExecuteTool</i> method is 0, and, if so, ends its execution with the value <i>true</i> .  What you have there for <i>csc.exe</i> lay - a real compiler or Leo Tolstoy's 'War and Peace' in textual presentation - it does not matter. <br><br>  As a result, the main problem stems from the fact that the sequence of steps is determined in the following order: <br><br><ul><li>  check the existence of the compiler; </li><li>  check the need to run the compiler; </li></ul><br>  and not vice versa.  Compiler stubs successfully solve this problem. <br><br>  Well, how did you get successful compilation symbols, if the csc.exe file was not detected (and the result of the task was ignored)? <br><br>  There is a method in such a case - <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> from the library <i>Microsoft.CodeAnalysis.CSharp</i> .  Parsing is also performed by the <i>String.Split</i> method with a number of delimiters: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Notice the difference with the delimiter set from the <i>Csc.GetDefineConstantsSwitch</i> method?  In this case, the whitespace character is not a separator.  Thus, if the conditional compilation characters were space-separated, this method will parse them incorrectly. <br><br>  Such a situation arose on problematic projects - in them, conditional compilation characters were spaced apart, and successfully parsed with the <i>GetDefineConstantsSwitch</i> method, but not with <i>ParseConditionalCompilationSymbols</i> . <br><br>  Another problem that found itself after updating the libraries was the deterioration of behavior in some cases, in particular - on projects that were not going to.  Problems arose in the Microsoft.CodeAnalysis libraries and were returned to us in the form of various exceptions - <i>ArgumentNullException</i> (some internal logger was not initialized), <i>NullReferenceException,</i> and others. <br><br>  I want to tell about one of these problems below - it seemed to me quite interesting. <br><br>  We encountered this problem when checking the latest version of the Roslyn project - a <i>NullReferenceException was</i> thrown from the code of one of the libraries.  Due to the sufficiently detailed information about the location of the problem, we quickly found the problem code and, for the sake of interest, decided to try whether the problem recurs when working from Visual Studio. <br><br>  Well - it was possible to reproduce it in Visual Studio (the experiment was conducted on Visual Studio 16.0.3).  To do this, we need a class definition of the following form: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  We also need the Syntax Visualizer (included in the .NET Compiler Platform SDK component).  You must request a <i>TypeSymbol</i> (menu item ‚ÄúView TypeSymbol (if any)‚Äù) from the node of the syntax tree of the <i>ConstantPatternSyntax</i> type ( <i>null</i> ).  After this, Visual Studio will restart, and in the Event Viewer you can view information about the problem, in particular, find the stack trace: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  As you can see, the cause of the problem is dereference of the zero reference. <br><br>  As I mentioned earlier, we encountered the same problem during the testing of the analyzer.  If you use the Microsoft.CodeAnalysis debugging libraries to build the analyzer, you can come to the exact problem location by debugging, by requesting <i>TypeSymbol</i> from the necessary syntax tree node. <br><br>  As a result, we arrive at the <i>ClassifyImplicitBuiltInConversionSlow</i> method mentioned in the above trace trace method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  The problem is that the <i>destination</i> parameter in this case is <i>null</i> .  Accordingly, when accessing <i>destination.SpecialType, a</i> <i>NullReferenceException is thrown</i> . ,     <i>Debug.Assert</i> ,   ,           ‚Äî        .   . <br><br><h3>    C++  </h3><br>       ‚Äî     -  ,      . , ,  ,     . <br><br>  ‚Äî   ,   ,   ToolsVersion     .     ‚Äî   ,    toolset'  , ,    .  , ,     .    ,  ToolsVersion,    MSBuild / Visual Studio,   16.0.    ‚Ä¶    ,         Visual Studio: <br><div class="scrollable-table"><table><tbody><tr><td> Visual Studio product name <br></td><td> Visual Studio version number <br></td><td> Tools Version <br></td><td> PlatformToolset version <br></td></tr><tr><td> Visual Studio 2010 <br></td><td> 10.0 <br></td><td>  4.0 <br></td><td>  100 <br></td></tr><tr><td> Visual Studio 2012 <br></td><td> 11.0 <br></td><td>  4.0 <br></td><td>  110 <br></td></tr><tr><td> Visual Studio 2013 <br></td><td>  12.0 <br></td><td>  12.0 <br></td><td>  120 <br></td></tr><tr><td> Visual Studio 2015 <br></td><td>  14.0 <br></td><td>  14.0 <br></td><td>  140 <br></td></tr><tr><td> Visual Studio 2017 <br></td><td> 15.0 <br></td><td> 15.0 <br></td><td>  141 <br></td></tr><tr><td> Visual Studio 2019 <br></td><td> 16.0 <br></td><td> Current <br></td><td>  142 <br></td></tr></tbody></table></div><br> , , ,        Windows  Xbox,  ,     (,   ‚Äî , ),   Microsoft ‚Äî  .  :) <br><br>     ‚Äî   toolset' (   ). <br><br>   ‚Äî     Visual Studio 2017    (,    <i>VisualStudioVersion</i> ).   ,   ,     C++  ‚Äî   ,     .NET .    .NET    toolset     ToolsVersion.    C++     ,       toolset'.   Build Tools   Visual Studio 2017 toolset'    <i>MSBuild.exe.config</i> ,    . ,         toolset' (,  <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> ),     toolset',     ( &lt;= Visual Studio 2015). <br><br>     ‚Äî     ,  <i>ToolsVersion 15.0</i> ,        toolset'a.   toolset ‚Äî <i>Current</i> ‚Äî    ,      toolset, ,  Visual Studio 2019   .       ,        ‚Äì     toolset'  <i>Current</i>   ‚Äî <i>15.0</i> . <br><br><h3>    C# .NET Core  </h3><br>       2 ,     : <br><br><ul><li>   'Current' toolset'a    .NET Core   Visual Studio 2017; </li><li>    .NET Core   ,        Visual Studio. </li></ul><br>       ‚Äî    .targets / .props      .    ,          toolset'. <br><br>   Visual Studio      (   toolset'a ‚Äì <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>    C# .NET Core   Visual Studio 2017      (   toolset' ‚Äî <i>Current</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>    (    ),       . <br><br>   ,     ,     .    (   C# .NET Core ,        toolset'e)       . ,      ,   ,        .  :) <br><br> ,      ?      toolset'a    .targets / .props   .NET Core SDK ( <i>Sdk.props</i> , <i>Sdk.targets</i> ).       ,     ,      .NET Core   . ,  toolset   ,            .NET Core  ,  ,    . <br><br>       .NET Core   :     ,        MSBuild. <br><br>  ,        ,    : <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preparing the environment necessary to build a model. NET Core projects; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model building: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> start building using .targets / .props files from our toolset; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continue building using external files. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From the steps described above, it is obvious that setting the necessary environment has two main objectives: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initiate building a model using .targets / .props files from your own toolset; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redirect further operations to external .targets / .props files. </font></font></li></ul><br>   .targets / .props ,     .NET Core ,    ‚Äî Microsoft.DotNet.MSBuildSdkResolver.        toolset'a        ,    ‚Äî  ,      (  toolset').        ,   ,       , . <br><br>    Sdk    toolset',        ,         . ,    ,      .      Microsoft.Common.props.          toolset'       . <br><br>  ,       ,         .NET Core SDK,      . <br><br><h2>  Conclusion </h2><br>    Visual Studio 2019  ,   Visual Studio 2017, ,   ,   .  ‚Äî Microsoft     ,   Visual Studio 2015  Visual Studio 2017. ,   toolset'a,     Visual Studio  ,    .  ‚Äî         toolset'     ‚Äî      ,      .     .NET Core     (      ,     Visual Studio)             ,     ,       . <br><br>     ,      ,     ‚Äî       ,      . <br><br><p> <a href="https://habr.com/ru/company/pvs-studio/blog/454736/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>        ,      : Sergey Vasiliev. <a href="https://habr.com/ru/company/pvs-studio/blog/454736/">Support of Visual Studio 2019 in PVS-Studio</a> </div><p>Source: <a href="https://habr.com/ru/post/454738/">https://habr.com/ru/post/454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454720/index.html">How to revive the documentation?</a></li>
<li><a href="../454728/index.html">Internet access is open: LUWRAIN technology helps blind users</a></li>
<li><a href="../45473/index.html">Multiplication table</a></li>
<li><a href="../454730/index.html">Allure Server meetup: video reports</a></li>
<li><a href="../454734/index.html">Backup, part 4: zbackup, restic, borgbackup review and testing</a></li>
<li><a href="../454742/index.html">At least one trick of Vim, about which you did not know</a></li>
<li><a href="../454744/index.html">Overview of Java track reports from the RigaDevDays conference</a></li>
<li><a href="../454748/index.html">MongoDB Survival Guide</a></li>
<li><a href="../45475/index.html">PostgreSQL horizontal scaling using PL / Proxy.</a></li>
<li><a href="../454750/index.html">Swift UI - at a gallop across Europe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>