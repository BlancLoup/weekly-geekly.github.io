<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PDA (Pocket Travel Computer): GPS Logger Circuitry</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My hobby project is GPS logger . In the comments they even suggested calling it ‚ÄúTravel Computer‚Äù, since logging is only a small part of all device ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PDA (Pocket Travel Computer): GPS Logger Circuitry</h1><div class="post__text post__text-html js-mediator-article">  My hobby project is <a href="https://habr.com/ru/post/401899/">GPS logger</a> .  In the comments they even suggested calling it ‚ÄúTravel Computer‚Äù, since  logging is only a small part of all device capabilities.  Much has already been implemented, but much of it remains to be done. <br><br>  In previous articles, I described the <a href="https://habr.com/ru/post/370337/">transition from arduino to STM32</a> , <a href="https://habr.com/ru/post/357920/">STMCube / HAL</a> , <a href="https://habr.com/ru/post/328010/">talked a little about the build system</a> , <a href="https://habr.com/ru/post/403007/">bootloader</a> , <a href="https://habr.com/ru/post/335018/">built a composite USB device</a> and <a href="https://habr.com/ru/post/336968/">pumped its speed</a> .  All this was done on a breadboard based on <a href="https://wiki.stm32duino.com/index.php%3Ftitle%3DBlue_Pill">a Blue Pill STM32F103CB board</a> and a hedgehog made from wires.  It is time for the device to take shape, both electronic (circuit) and physical (body). <br><br><img src="https://habrastorage.org/webt/0g/et/tj/0gettjt59u77r2mjpz73hyfn7sc.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The issues that I had to solve at this stage are very interrelated.  Choosing the components for the project you need to roughly represent in which body they can be shoved.  Conversely, the body must be made for the components that are available and the board, which, again, must be done with an eye to the body.  In general, a tangle of interrelated issues.  You can, of course, take a bigger box and push anything there, but you want something compact and light. <br><br>  Before I start right away, I want to note that this is not the final version of the device.  Most likely, there will be errors in the scheme, something will not work as planned, they will indicate more correct solutions in the comments, some approaches will be rethought.  I think that the second or even the third version of the device can not be avoided.  Therefore, I will be glad to your constructive comments. <br><br>  Under the cat mnogabukav, but it will be interesting. <br><a name="habracut"></a><br><h2>  What and why </h2><br>  The Holux M241 GPS logger is my faithful companion on all trips.  He is with me for many thousands of kilometers.  The track that the logger writes is primarily used for geotagging photos, but the route itself is also of interest.  It's fun to find out how fast you went skiing, which route your plane flew, what sight just flashed past the bus window.  <a href="https://grafalexphoto.livejournal.com/10901.html">Here</a> I did a little review of this device. <br><br>  Unfortunately, the capabilities of this device have long ceased to suit me: tired of fiddling with batteries, which always sit at the most inopportune moment.  Also, a very small USB speed, a small amount of internal flash, an inconvenient mechanism for merging tracks, little information is available on the display, little accuracy, a very primitive odometer, no information about satellites, and a lot more on the little things. <br><br>  Yes, it would be possible to look for what modern trackers offer - for sure there is already a device on sale that meets my requirements.  But this is a hobby, I want to try myself to do something complicated, interesting, useful and necessary.  Let it be even if I will be the only one to use it. <br><br>  The goal of the project as a whole is to make a similar device in something, only stuffed with my Wishlist.  <a href="https://habr.com/ru/post/401899/">In the first article</a> of the cycle, I described in detail my device requirements.  In short, I would like to do the following: <br><br><ul><li>  recycle power system, convert to lithium battery </li><li>  put a more informative display </li><li>  more accurate GPS </li><li>  expand flash using sd card </li><li>  add compass and accelerometer </li><li> I also want to rework the logging system to spit out the tracks in the format I need. </li></ul><br>  In addition to technical requirements and there is also a non-technical hotelok (non-functional).  So I would like to improve the creation of complex devices from scratch, to understand how various electronic components work, how to program them, how to make a motherboard and design a case. <br><br>  Why do you need a separate device if all modern phones have GPS, a big screen and a lot of memory?  Well, first of all, I'm not sure that a phone with GPS enabled in track recording mode can withstand the whole day.  I would not really like to stay in an unfamiliar country without a phone.  Also, I personally use a separate device simply more comfortable. <br><br>  Perhaps over time, the concept of the device will change.  So, for example, now the idea of ‚Äã‚Äãabandoning the screen and connecting to the phone via bluetooth is becoming more and more logical, and doing all the tricky logic already in the phone.  This idea is very sensible and tempting.  But at this stage, I would still like to have a display - I always have time to give it up. <br><br>  For the first year and a half, I developed a device on various debugging boards (first arduino nano, then STM32F103 blue pill, then STM32F407VE).  It was necessary to connect the periphery on postings and purchased modules.  As a result, a hedgehog from the wires was obtained on the table, which could not be tested on the GPS reception; it was impossible to even move the wires without breaking the connection somewhere.  And then happy debugging. <br><br>  Every time I sat down to write useful functionality, I rested on the fact that some other part of the system stopped working normally and I had to spend hours debugging something completely unrelated.  For example, the most important component of the system, the GPS receiver, turned out to be the least developed, since  I had to go headlong into debugging USB, SD cards, setting up libraries and such. <br><br>  Finally I got tired of it and I decided to make my debug board - this will be the topic of today's article.  The goals that I set myself in this part of the project were: <br><br><ul><li>  Make a debugging board that will not have problems with non-contact components </li><li>  Decide on basic technical and schematic solutions. </li><li>  Approximately decide on the components that I will use next </li><li>  Approximately decide on the layout and body </li><li>  The scheme should be general enough so that you can experiment with different components and their modes. </li></ul><br>  And although the ultimate goal is a compact battery device, today I will not do such things as <br><br><ul><li>  fine tuning of power modes </li><li>  consumption setting </li><li>  sleep modes </li></ul><br><br>  I will deal with the consumption setting when the board and the main code are ready.  By the way, about the code today, too, will not, but I will definitely return to this issue as there will be quite interesting material. <br><br><h2>  Components </h2><br>  Let's start with the components and peripherals.  On the way, let us estimate the number of microcontroller legs that will be needed to connect this zoo, as well as the power options.  Because  This is a hobby project, that I chose the components from the fact that I really bought in the shops / ebay / ali, as well as the fact that you can solder at home (well, and also from what was already in personal stocks).  Perhaps some specific chips could solve the problem better, but the issue of accessibility and price is important to me. <br><br><ul><li>  The main component of the GPS logger, of course, will be a <b>GPS receiver</b> .  In my case, this is a pretty <a href="https://www.banggood.com/UBLOX-NEO-M8N-BN-880-Flight-Control-GPS-Module-Dual-Module-Compass-p-971082.html%3Futm_source%3Dgoogle%26utm_medium%3Dcpc_ods%26utm_content%3Dysq%26utm_campaign%3DRC-Sds-Feed%26gclid%3DCjwKCAjw9qfZBRA5EiwAiq0Abbede7QmuZktKXGmbaPcx2VBhi2RFD7sX_bbpVjxEKyXrV3kpiEQERoCQYUQAvD_BwE%26cur_warehouse%3DCN">tricked Beitian BN-880</a> based on the UBlox M8N chip.  The module also has a compass on the HMC5883L chip. <br><br>  Connection: 2 UART pins for GPS and 2 I2C pins for compass <br>  Power supply: from 2.7V <br>  Consumption: 50mA <br><br><ul><li>  Also ordered the module <a href="https://ru.aliexpress.com/item/32853587391.html%3Fspm%3Da2g0v.search0604.3.1.7d0ca884kxVHvQ%26ws_ab_test%3Dsearchweb0_0%252Csearchweb201602_5_10065_10068_319_10059_10884_317_10887_10696_321_322_10084_453_10083_454_10103_10618_10307_537_536%252Csearchweb201603_52%252CppcSwitch_0%26algo_expid%3D2a68669d-212b-4fea-a6fe-1bdf59934d46-0%26algo_pvid%3D2a68669d-212b-4fea-a6fe-1bdf59934d46%26transAbTest%3Dae803_5">Beitial BN-220</a> .  It does not have a compass, but the antenna is more compact (20x20mm vs. 30x30).  The truth is still unclear how this will affect the quality of the reception.  Need to test.  But, judging by the datasheet, this module can work from 1.4V, which should have a positive impact on the operation time of the device. </li><li>  Here, in fact, everything is somehow dull.  It seems that the BN-880 is based on the UBlox M8N, while the BN-220 is based on the U-blox M8030-KT.  But in some sources it skips that it seems to be the same thing.  More precisely, the M8N is a module, and the M8030-KT is a chipset inside.  In this confusion, I am worried about the issue of power supply - the M8N is declared from 2.7V, while the M8030-KT is from 1.4V. </li><li>  Alternatively, I also have a <a href="https://www.aliexpress.com/item/SIM868-GSM-GPRS-GPS-BT-CELLULAR-MODULE-MINI-SIM868-board-SIM868-breakout-board-instead-of-SIM808/32827367795.html">SIM868</a> module lying <a href="https://www.aliexpress.com/item/SIM868-GSM-GPRS-GPS-BT-CELLULAR-MODULE-MINI-SIM868-board-SIM868-breakout-board-instead-of-SIM808/32827367795.html">around</a> .  in which on board, in addition to GPS, there is also a GSM / GPRS module and Bluetooth.  So far, it is frightening with its cleverness and complexity of connection.  You will need to play first with the debug board. </li></ul></li><li>  The main difference between the device and ‚Äújust a black box‚Äù is the presence of a <b>display</b> .  In the first prototypes I connected the display via I2C, but the bus load was about 25%.  But the matter is not even a percentage, but the fact that the screen buffer transfer takes about 25 ms, during which you cannot communicate with other devices on the bus.  This can be a problem, so you need to either take out the display on a separate I2C bus, or consider connecting to SPI <br><br>  Connection: 2 I2C wires or 3 SPI wires (display is write-only, so the MISO line is not used, but a separate Data / Command signal is used) <br>  Power: from 3V <br>  Consumption: 25mA <br></li><li>  To control the device, I will use <b>2 buttons</b> that take up 2 legs of the processor, respectively <br></li><li>  In the original device (Holux M241, from which I originally copied functionality) it was impossible to watch the track at an arbitrary point in time.  It was necessary to connect the device to a computer and merge the data with a special program.  As it seems to me, the opportunity to watch the track on a mobile phone or tablet at any time will be very much in demand.  For this, I purchased a <b>Bluetooth</b> module <a href="https://www.aliexpress.com/item/HM-13-Bluetooth-V4-0-BLE-SPP-Double-Module-Transceiver-Master-Host-Slave-Board-Transparent-Transmission/32788502328.html%3Fspm%3Da2g0s.9042311.0.0.27424c4d6MzpIX">HM-13</a> .  This module is chosen because it can do SPP in addition to BLE. <br><br>  Connection: 2 UART wires, 1 status wire (connected / not connected) <br>  Power supply: 2.5V - 3.9V <br>  Consumption: 50mA (although there is a 13mA figure next to it in the datasheet. Perhaps this is the peak and average value) <br></li><li>  As I was told, it makes no sense to keep the receiver on, if you just sat down to rest or went to dinner at a cafe.  Therefore, I decided to add the <b>accelerometer</b> MMA8452 and determine from it whether the device is at rest or we are moving somewhere. <br><br>  Connection: 2 I2C wires, 1 interrupt wire <br>  Power supply from 2V to 3.6V with some kind of microscopic consumption <br></li><li>  GPS track will be recorded on the <b>SD card</b> .  I have already tried using the card in SPI mode and this, to put it mildly, is slow.  Especially on record.  The correct mode for the SD card is SDIO <br><br>  Connection: 6 wires <br>  Power supply: from 1.8V <br>  Consumption is unknown, but I think no more than 20mA <br></li><li>  To save electricity, it makes sense to turn off the power of those devices that are not currently in use.  So next to each consumer I will put on the <b>transistor</b> , which I will manage a separate signal of the microcontroller <br><br>  Connection: 5 signals, one foot per consumer (GPS, Bluetooth, accelerometer, SD card, display) <br></li><li>  <b>Two-color LED</b> to display status (as without a blinking LED?).  It would be possible to put a tricolor, but for now I see no need. <br><br>  Connection: 2 pins <br>  Consumption: 10mA <br></li><li>  In addition to Bluetooth, a more classic track-merging mechanism will be implemented via <b>USB</b> .  For this, 4 lines will be used - a differential pair for data, 1 pin for detecting that the device was plugged into USB, and one more pin for logical connection (I will tell you about these 2 pins below) <br></li><li>  Appetite comes with eating.  Since I started shoving everything into my dream device, why not add a <b>squeaker</b> ?  Well, or <b>vibromotor</b> .  Not yet invented yuzkeys. <br><br>  Connection: 1 wire <br></li><li>  The device will still need to be powered.  While the PT1502 chip is looking at me as a lithium battery charger and <b>power controller</b> .  To communicate with the microcircuit, you will need to use 2 wires: one for power management, the other for a signal about a dead battery.  For the sake of interest, it will be possible to measure the voltage of the battery with the help of another line. <br></li><li>  Of course, the charge of a lithium battery is incorrect to measure on the basis of voltage.  Therefore, I added a special <b>microcircuit power meter INA219</b> <br><br>  Power supply: 3-5V, recommended 3.3V <br>  Connection: 2 wires I2C <br><br>  As will be seen below, the supply voltage in 3V creates some discomfort in the connection.  I would prefer the IC chip to be powered by 2.7V or lower.  But sorting through several options based on the price / housing / availability, I did not find anything on 2.7V.  I would be grateful for the hint. <br></li><li>  It remains only to provide a debugging interface <b>SWD</b> (3 wires) and a <b>debugging UART</b> (2 more wires) <br></li></ul><br>  I was always interested in the question of why we need controllers with a large number of ports, and I myself easily counted 39 paws needed for my functionality.  And that's not counting quartz, reset, and power.  And there are ideas about what to do with a dozen more (for example, the display could be connected via a parallel interface of the Intel 8080 or Motorola 6800). <br><br>  You can, of course, fasten the I2C port externders to reduce the number of feet used.  But firstly, these are additional components on the board, secondly, the software part is very complicated, and thirdly, there is still little memory in small microcontrollers, and where there is enough memory, there are also enough ports.  So I do not see the point of complicating everything - let it be 39 lines. <br><br><h2>  Nutrition </h2><br>  With the supply voltage is not so clear.  You can probably power all devices from 3.3V and calm down on this.  But we, all the same, are going to do a mobile device, which means we need to think about saving energy.  So you need to try to choose a smaller supply voltage.  Below, I will figure out what kind of savings you can try to achieve. <br><br>  Here is the data for all devices on the plate - in this form it is more convenient to choose the power domain to which to connect this or that device. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Device</b> </td><td>  <b>Power range</b> </td><td>  <b>Power Domain</b> </td><td>  <b>communication</b> </td></tr><tr><td>  CPU </td><td>  2 - 3.6V </td><td>  2V </td></tr><tr><td>  Accelerometer </td><td>  2 - 3.6V </td><td>  2V </td><td>  I2C </td></tr><tr><td>  Sd card </td><td>  1.8V or 3.6V </td><td>  2V </td><td>  Sdio </td></tr><tr><td>  Display </td><td>  1.65 - 3.3V <br>  or 3 - 5V </td><td>  2V </td><td>  I2C or SPI </td></tr><tr><td>  GPS </td><td>  2.7 - 5.5V <br>  or from 1.4V </td><td>  2.7V </td><td>  UART </td></tr><tr><td>  Bluetooth </td><td>  2.5 - 3.9V </td><td>  2.7V </td><td>  UART </td></tr><tr><td>  Power Meter (INA219) </td><td>  3 - 5.5V </td><td>  3V </td><td>  I2C </td></tr><tr><td>  Buzzer </td><td>  3V - 5V </td><td>  Vbat </td></tr></tbody></table></div><br>  From the plate it is easy to see that some devices can operate on sufficiently low voltages (from 1.8V).  Others can comfortably work from 2.7V.  Finally, the remaining devices below 3V cannot work.  A squeaker, for good, generally needs 5V, but for me it will be powered by the highest voltage - from the battery, no matter how much it is. <br><br>  With the power of the display is not yet fully understood.  In the description of display modules with ali, a range of 3 - 5V is indicated, whereas in the datasheet on the matrix controller SSD1309 a range of 1.65 - 3.3V is indicated.  I assume that 3V is needed to shake the boost converter on the display module board, whereas logic is 1.65V.  As will be seen from the reasoning about the layout, it makes sense to abandon the display module and connect the display directly, which will power the display from domain 2B. <br><br>  I have about the same reasoning about GPS - different sources indicate different supply voltages.  So far I have no idea which module I will use as a result, so let the receiver talk in the domain 2.7B. <br><br>  With an SD card is not at all clear.  The specification says dimly that, in general, the card should be powered from 3.3V, but modern cards are smart enough and can understand that they have been plugged into a low-voltage device and can switch to 1.8V.  But the mechanism of food selection is not very clear.  I will power the card from 2B and see what happens.  It will not work - it will work from 3B. <br><br>  So, 4 power buses emerge - 2V, 2.7V, 3V and a battery.  I would like to put all the hungry and constantly working consumers (and this is the controller and GPS) onto the lowest volt bus, but at the moment I have not yet decided on the GPS module (and therefore its power supply - 2 or 2.7V), which means it will be necessary some kind of universal solution.  I will try to dissolve the board so that it is easy to apply either one or the other. <br><br>  Where do we get so many different voltages?  Even in the early stages of the project, I looked at the PT1502 microcircuit even <a href="https://habr.com/ru/post/435198/">managed to try it in another project</a> .  In addition to charging for a lithium battery in this chip, there are already 3 power sources - one pulse and 2 linear lowers.  True, on one of them the voltage is not regulated and amounts to 3V - I will try to power the INA219 from it.  The remaining 2 power sources are not a problem, because  there voltage can be chosen. <br><br>  Estimate consumption is not very successful.  The datasheets indicate peak consumption - this is enough to calculate the power of the key transistors, but not enough to estimate the required battery capacity.  So while the battery will be selected on the basis of available space in the case, and there I‚Äôll measure the actual consumption. <br><br>  The question may arise, but how to co-ordinate devices with different operating voltages?  Let's figure it out. <br><br><ul><li>  All the communication legs of the microcontrollers are marked as Five Volt Tolerant (except for UART2 on the legs of PA2 / PA3), which means that if there appears 3.3V from the highest-voltage device, nothing bad will happen </li><li>  The accelerometer, although powered by 2V, can potentially be connected in parallel with high-voltage devices on the bus.  This problem is easily solved - the MMA8452Q chip can be used to separately power the communication pins from the other power supply (via the ‚Äúhigh-voltage‚Äù device itself on the bus) </li><li>  I will try to power the SD card from the same voltage as the microcontroller, which means that nothing needs to be coordinated. </li><li>  GPS and Bluetooth should easily eat the ‚Äúlow‚Äù voltage from the microcontroller.  The same applies to other ‚Äúhigh-voltage‚Äù devices. </li></ul><br>  Finally, a few words about why I am so struggling to lower the supply voltage.  The chip in a pulsed DC-DC converter that can exchange volts for amps (if you do not take into account the loss of the converter itself, of course).  To be more precise, exchange higher voltage with low current for low voltage and higher current.  In this case, we are more interested in reverse reasoning - if we power the low-voltage load through DC-DC, then the consumed current of this entire structure together with the converter will be lower than the consumed current of the load itself.  Well, since battery capacity is measured in mAh, a decrease in current consumption will lead to an increase in battery life. <br><br><div class="spoiler">  <b class="spoiler_title">Calculate?</b> <div class="spoiler_text">  One friend suggested that since the efficiency of the converter is usually about 90%, it is quite possible that the complexity of the circuit in the form of DC-DC does not pay for itself and you can get by with the usual KRENKA.  Let's estimate.  I spent a couple of sooo rough calculations to see if the DC-DC converter is really appropriate here. <br><br>  Here is a <a href="https://docs.google.com/spreadsheets/d/1Idw92jFgOWNqe95PV6QkekGmQ1CElfyVdRBss6dlUc4/edit">plate with calculations</a> .  Let the 900 mAh battery linearly discharge from 4.1 to 3.5V (which is generally not true).  The efficiency of the DC-DC converter, I put 90% (the average value of the datasheet).  Discharge will be 100mA current.  I wanted to compare the operating time of the device from a linear power supply with a pulse. <br><br>  Obviously, the line source will discharge the 900mAh battery with 100mA current in 9 hours.  But with a pulse source, the device will last much longer - 9.3 hours at a target voltage of 3.3V, 11.4 hours at 2.7V, and a full 15 hours at a voltage of 2V.  Of course, the calculations are, well, sooooo rough, but even so it is clear that with a pulsed source, the long life of the battery increases significantly. <br></div></div><br><h2>  Microcontroller </h2><br>  I approached the question of choosing a microcontroller thoughtfully - I played for a long time with the configurator, weighing all the pros and cons of each of the options.  I really liked the STM32 microcontrollers, so I don‚Äôt see any point in looking towards other controllers without much need.  Moreover, the STM32 line has controllers for every taste and for any periphery.  The experience gained in the previous stages of my project allows us to narrow down the choice of controller based on the list of peripherals, the software already written, and the features that I would like to realize in the future. <br><br>  So, it‚Äôs absolutely obvious that 20kb of my memory of my STM32F103CB is definitely not enough - there are not enough decent-sized buffers for communication between an SD card and USB.  I haven't even started implementing much of the conceived functionality yet, and more than 19k are already taken.  But with the power for processing, as it turned out, it is not particularly necessary.  If all communication with the periphery is pushed into the DMA, then the share of the central processor remains only a couple of percent. <br><br>  Having estimated the list of what I need from the controller, I counted the following: <br><br><ul><li>  &gt; = 128kb flash (about 50k is currently occupied) </li><li>  &gt; = 40 kb of memory (19k currently occupied) </li><li>  &gt; = 40 feet GPIO (see the reasoning above) </li><li>  &gt; = 40 MHz (I don‚Äôt need much, the main thing is to have less consumption) </li><li>  DMA (I really liked it) </li><li>  &gt; = 2x I2C,&gt; = 3x UART,&gt; = 1 SPI </li><li>  SDIO (flash drive via SPI is very slow) </li><li>  Honest USB Full Speed, Better High Speed </li><li>  Availability (the ability to buy a couple of pieces for an adequate price) </li><li>  From the wishes of the still native support for parallel LCD interfaces (usually implemented as an external memory access module FSMC) </li></ul><br>  STMicroelectornics microcontrollers are just a dime a dozen for every taste, color and wallet.  At first I tried to proceed from the series when choosing a controller.  The L0 and F0 lines are too weak and little memory, S7 and H7, on the contrary, are too sophisticated, L4 does not have SDIO (UPD: SDIO is, they just did not mention it on the title page of the series).  Among the rest of the series, you can choose something based on my needs, since I have no particularly specific requirements. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The STM32WB series impresses with the presence of Bluetooth, but the VFQFPN68 case somewhat cools the desire to use it in hobby projects. And I did not find such controllers in retail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I aimed at the body of the LQFP64 - sufficient for the number of legs, but it is not very big and can be soldered at home. It's good that there is a CubeMX configurator in which you can choose what you need by filters.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I chose the STM32F103RB controller for three reasons. Firstly, I have already studied the F103 series well using the example of the Blue Pill board. In general, the STM32F103CB controller completely suited me, but the memory was not enough. Secondly, I already have a bootloader and low-level code for this controller, while others will have to be redone. And thirdly, about a year ago, I already bought 3pcs of STM32F103RB for joy. Then I did not do a detailed study of the available controllers, but simply picked up a thicker controller from the F103 line. Do not throw it away now :)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have already noted, I do not have particularly specific requirements for peripherals or performance. </font><font style="vertical-align: inherit;">But if I put something into something, then I already have controllers from the F4 line (if I need something more powerful), or L152RD, if I need to solve something with consumption (UPD: I looked after L433RC). </font><font style="vertical-align: inherit;">What is good, with the STM32 almost all pin-to-pin controllers are compatible, and F4 and L1 / L4 can be soldered practically without reworking the board. </font><font style="vertical-align: inherit;">You can even several boards with different MK to collect and compare consumption.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few words about the body and layout </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determined with the details. </font><font style="vertical-align: inherit;">It's time to draw a diagram, then trace the board, and then try to fit it into the case.</font></font> Or not?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frankly, at first I just went this way, but then I came to the conclusion that everything must be done in the reverse order. Well, or at least at the same time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like to get a compact device. And for this you need to accurately understand the size of the available space, in turn, to understand where to place the board and its size, what size battery can fit, where to place the buttons, screen, USB connector and other external components, and also figure out how to fix the components and you can Is it convenient to lay wires between them? Starting to make a fee without an understanding of all these pieces is simply meaningless. So it turns out that you need to first do the body and layout, and then go to the scheme.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also in the process of drawing the case, I had to revise the choice of components several times. So initially I thought of using a </font></font><a href="https://www.aliexpress.com/af/oled-0.96-lcd-128x64.html%3FSearchText%3Doled%2B0.96%2Blcd%2B128x64%26d%3Dy%26initiative_id%3DSB_20190408121432%26origin%3Dn%26catId%3D0%26isViewCP%3Dy%26jump%3Dafs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cheap 128x64 display with a size of 0.96 ‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the size of the work area was 21.7 x 11.2mm), but this display looked completely microscopic against the background of a much larger case. Then </font></font><a href="https://ru.aliexpress.com/item/32657594621.html%3Fspm%3Da2g0v.search0604.3.9.95422789jVCckJ%26s%3Dp%26ws_ab_test%3Dsearchweb0_0%252Csearchweb201602_5_10065_10068_319_10059_10884_317_10887_10696_321_322_10084_453_10083_454_10103_10618_10307_537_536%252Csearchweb201603_52%252CppcSwitch_0%26algo_expid%3Deb0fb90b-eb5b-4365-b0c8-7d6a61e1dabc-1%26algo_pvid%3Deb0fb90b-eb5b-4365-b0c8-7d6a61e1dabc%26transAbTest%3Dae803_5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 1.3 ‚Äùdisplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was ordered </font><font style="vertical-align: inherit;">(working area 29.4 x 14.7 mm), but it didn‚Äôt get much better. Then I got </font></font><a href="https://www.ebay.com/sch/i.html%3F_from%3DR40%26_trksid%3Dm570.l1313%26_nkw%3D1.54%2Blcd%26_sacat%3D0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 1.54 ‚Äùdisplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (35 x 17.5 mm) - it looks more or less normal with it. At the moment this is the main working version.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By estimation, a 1.8 ‚Äù-2‚Äù display would look better, but these are already color and more resolution, and accordingly the screen buffer will be large enough for my controller (35kb instead of 1kb). Well, with the pushing of large displays into the case there can also be problems, because The landing attachments for such modules are substantially larger than the active area of ‚Äã‚Äãthe display. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While I was writing this article on Ali, </font></font><a href="https://ru.aliexpress.com/item/32950562791.html%3Fspm%3Da2g0v.search0604.3.165.67b67b7288kRJm%26ws_ab_test%3Dsearchweb0_0%252Csearchweb201602_5_10065_10068_319_10059_10884_317_10887_10696_321_322_10084_453_10083_454_10103_10618_10307_537_536%252Csearchweb201603_52%252CppcSwitch_0%26algo_expid%3Dc9a5639d-31dc-4309-a365-ee84ce5a6f66-25%26algo_pvid%3Dc9a5639d-31dc-4309-a365-ee84ce5a6f66%26transAbTest%3Dae803_5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monochrome 2.42 ‚Äùdisplays</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appeared </font><font style="vertical-align: inherit;">with the same resolution (128x64) and the exact same strapping as the 1.54‚Äù. I ordered myself a sample of this - there is a chance to stick it in my case without a significant increase in the device.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important point at the stage of working on the case was the understanding that the purchased display module takes up too much space and significantly reduces the space for the main board. So I decided to abandon the finished display module, and instead put the display and its strapping on my board. The number of parts in the scheme has increased slightly, but the design as a whole has become much simpler and more compact. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have similar thoughts on the GPS module. It is not that big, but no matter how you put it, it either interferes, or the antenna is closed with some kind of battery. It may be a good idea to place the module stuffing on your board, and place the antenna somewhere else.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work on the case also allowed to determine the size and capacity of the battery. The 900mAh battery was found in the available volume - we will be guided by it. I would like my device to run on a 15-20 hour battery, which means that the consumption should be at the level of 45-60mA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment I can not call the work on the body finished. First, the question of choice for some components (display, GPS) is still open. Secondly, it is not clear whether my scheme will start in principle or whether it will be necessary to change something cardinally. Well, thirdly, the board turns out to be too compact - I'm not sure that I can dissolve it, solder it and debug it. Therefore, in this article, I will nevertheless focus on the issues of circuitry, I will move with simpler and more understandable steps, and I will tell you about the case next time. Here's a couple of renderings and photos for starters.</font></font><br><br><img src="https://habrastorage.org/webt/4j/ff/l-/4jffl-arvuselp1d93s5muqazqy.png"><br><br><img src="https://habrastorage.org/webt/o2/a9/ve/o2a9vejujirpcxe634dzikwqc0e.png"><br><br><img src="https://habrastorage.org/webt/a9/hu/ka/a9huka9xfxi-g0wegdzhb8ezonm.jpeg"><br><br><img src="https://habrastorage.org/webt/az/nl/b2/aznlb21azpqtsfgoaim0occrvgc.jpeg"><br><br><h2>  Scheme </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can do electronics. I will describe in detail enough circuit solutions. First of all, for the same beginners in electronics as me, and also as a synopsis to myself. Experienced electronics engineers can skim through the diagrams and rewind to the next section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with food. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The device will be powered by a lithium battery, which means you need a charge controller. Also, some components have an upper limit on the voltage of about 3.6V, while the battery can easily be greater than 4V. So you need a step-down power source. As we already found out, we will need several different voltages.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have already mentioned that I will use the PT1502 chip. It fits well, because implements a charge controller, 3 power sources, as well as a device wiring diagram with a button. There are several functional blocks in the microcircuit, which I have divided for clarity in the diagram. The scheme itself is a slightly reworked datasheet scheme. Here is the lithium battery charge controller. </font></font><br><br><img src="https://habrastorage.org/webt/7y/p7/sk/7yp7skuez7vcdpdzr33f6rhtfk4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resistor R3 sets the charge current. By default, this corresponds to 470mA. Perhaps by the results of the tests, I will reduce the value of this resistor to 510 ohms, which will give a charge current of about 900mA (1C).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The controller can report the current charge mode with the foot CHG_STAT. Moreover, he can give signals as much as 3 ‚Äî he charges, does not charge, and is already charged, but still connected to the outlet. In the first embodiment, the internal transistor presses the foot to the ground and this can be easily recognized by the controller. In the second variant, the transistor closes completely and the leg goes into a high-impedance state. With the help of power-ups, such a signal is also easy to read as a controller. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But with the third state is not so simple. There, the transistor is ajar and a current of 20 ŒºA flows through it. In order to consider such a state, I was prompted to choose a suspender in such a way that about half of the nutrition was on my leg. Then it will be possible to detect such a state with the help of an ADC. Using Ohm's law we get R5 = 1V / 20¬µA = 50k.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, the PT1502 chip is not just a charger, but also a clever controller of the entire power supply. The microcircuit monitors the voltages on the circuit and with the help of the RESET signal can control the main processor (they say it's too early for you to start, the power has not stabilized yet). </font></font><br><br><img src="https://habrastorage.org/webt/21/z3/f1/21z3f1tkkpvqsph462qukz0_anu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, the microcircuit can start the device by pressing a button (BTN1), as well as by a signal from the microcontroller (PWR_HOLD) to shut down and turn off the power. Well, in order to signal the processor that the battery is running out, the BAT_LOW signal is provided. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is the main power source. </font></font><br><br><img src="https://habrastorage.org/webt/nb/5x/tc/nb5xtc2txxl98wz1pfwgmzsr49u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output voltage is set by the voltage at the BUCKFB pin and is set to 2V with battery power. But with two-volt power, one problem was discovered - USB will not work.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The battery will be charged, and the data will not be transferred - the microcontroller simply will not be able to output signals to the USB bus of sufficient amplitude. Datashit recommends a voltage of at least 2.7V, better than 3.3V. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to fence another power source and think about how to switch between them, I decided to simply adjust the ratio of the divider R1 / R4 + R7. With this switch on, the impulse operates continuously. As soon as the device is plugged into USB, the transistor opens and shuns the R7. The ratio of the setting resistors changes and we get 3.16V at the output (it will be possible to play with the nominal values ‚Äã‚Äãand finish it to 3.3V). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the PT1502 chip, there are also 2 linear regulators.</font></font><br><br><img src="https://habrastorage.org/webt/1c/s0/tj/1cs0tjf8eerkuske4_dyqithygm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will have either little consuming components (INA219) or short-lived ones (bluetooth) connected to these regulators, so the efficiency of these sources will not be a problem. The LDO2 supply voltage can be configured using the LDO2_SETx signals. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since I still have open-ended questions on power supply voltages, I decided to separate the jumpers to select the LDO2_SETx mode. Also, to be able to measure the actual consumption of the corresponding tire, I will also scout the jumpers JP1 / JP2 / JP3 per comb.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finishing the topic of power supplies you need to mention the power of the display. </font><font style="vertical-align: inherit;">Just above, I wrote that in the name of compactness, I had to abandon the purchased display module and pick up the display with strapping to my board. </font><font style="vertical-align: inherit;">This display requires a special up-converter for 7-16V. </font><font style="vertical-align: inherit;">Conveniently, this source can be turned on and off using the EN signal. </font><font style="vertical-align: inherit;">The circuit itself is copied from the datasheet of the elevator, exactly the same used in display modules with Ali.</font></font><br><br><img src="https://habrastorage.org/webt/oi/bd/zm/oibdzmvkie49fxcjamxcvszh9gw.png"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PT1505</font></font></b> <div class="spoiler_text">        PT1502       ‚Äî  PT1505.      ,    .           .    PT1505    . <br><br> ,           . <br></div></div><br>  Now a little about the power of the microcontroller.  The microcircuit is large and has 6 power lines - 4 for the digital part, 1 analog power supply and one for the clock.  According to the datasheet on STM32F103 on all power lines (maybe, except for the clock), there should be a 100nF capacitor, and one more common at 4.7¬µF. <br><br>  But in the datasheet on the STM32F4 it is said that although microcontrollers are practically compatible with the conclusions, the power circuits of them are somewhat different.  So the two terminals should have 2.2 mkF capacitors between the output and the ground (and not between the ground and the power, as in F1).  Therefore, it was necessary to take into account both options and for a specific microcontroller to solder only part of the capacitors. <br><br><img src="https://habrastorage.org/webt/vv/ai/a4/vvaia45dk-cjpdj9jrypfecczug.png"><br><br>  Continuing the theme of nutrition, you need to figure out how to measure it.  You can rely on the signal BAT_LOW and ask the user to quickly round out if the battery is low.  But this is exactly what I did not like in the original Holux M-241, because  this signal appeared too late and it was easy to miss it.  I need some more informative indicator of battery charge. <br><br><img src="https://habrastorage.org/webt/2r/6l/0g/2r6l0gd1bdyewq--m8zij_nugxs.png"><br><br>  Just in case, I put the most common divider to measure the voltage of the battery.  But in the case of lithium batteries, this is only an informative indicator and it is not worth relying on it.  For more honest testimony on the battery on the Internet offer to use the ‚Äúpendant‚Äù. <br><br><img src="https://habrastorage.org/webt/an/3u/nc/an3uncm2tjzd-pu3n6ns8vqnhz0.png"><br><br>  This little microcircuit counts the amount of energy that has passed through to or from the battery.  Measurements are made on the shunt R10.  Chip readings can be read through I2C.  The microcircuit is able to measure the voltage on the battery, the current passing through the resistor, and also to multiply one another.  Unfortunately, it does not know how to accumulate the value of watches running past * Hours, so you will have to do a constant survey. <br><br>  We turn to the digital part.  The heart of the whole system is the STM32F103RB microcontroller. <br><br><img src="https://habrastorage.org/webt/hm/ws/ma/hmwsma-hii28gwjrskmvmfsytl4.png"><br><br>  The binding in the form of two quartz is taken from other schemes found on the Internet (rechecked in datasheet).  I do not need to load from RAM, but because the signal BOOT1 pulled to the ground.  BOOT0 can be selected with a jumper for loading from the main flash memory or the built-in UART bootloader (for example, for the initial firmware of the device) <br><br>  Next LED. <br><br><img src="https://habrastorage.org/webt/ja/bg/ah/jabgahdeoppmxzipfiqu5mpd9dq.png"><br><br>  Since the main supply voltage will vary from 2 to 3.3V, it is not necessary to connect the LEDs to it - the brightness and current consumption will vary greatly.  Therefore, my LEDs will be connected to the 2.7V bus, the current-limiting resistors are calculated accordingly.  Since the microcontroller will not be able to issue more than 2V on its leg when powered by battery, the push-pull GPIO mode cannot be used.  Only open-drain. <br><br>  About the reset button to tell nothing special. <br><br><img src="https://habrastorage.org/webt/6x/eq/is/6xeqise0ghoatscub44uzcykfoq.png"><br><br>  Since on the I2C bus there will be a three-volt device (INA219), then you also need to do suspenders for three volts <br><br><img src="https://habrastorage.org/webt/xj/yi/n7/xjyin76yz6g_sg7vo9t2s4eqrms.png"><br><br>  SWD connector is also standard.  A diode is needed to switch power between the battery and external power from the programmer. <br><br><img src="https://habrastorage.org/webt/vl/s7/pw/vls7pw9grlfznf3gfo1_yglclqw.png"><br><br>  Anticipating exclamations that do not do so and that such a connection does not actually turn off the battery.  Yes, do not turn off, but the diode is not here for this.  This thing is needed to be able to power the device from the programmer if the battery is not connected.  And if it is connected, then let it work from it.  Well, if the battery is connected, then you need to protect the programmer from 4.2V on the battery. <br><br>  But the buttons should stop in more detail. <br><br><img src="https://habrastorage.org/webt/gg/du/gi/ggdugivqqx7iqjimaqwkbsiehru.png"><br><br>  The fact is that the first button will not only be a button, but will also work as a device switch - the signal BTN1 is connected to the chip of the power controller PT1502.  When the device is powered off, the microcontroller and other consumers are not supplied.  That is why the button is not connected to the power supply (VCC) but to the battery (BAT).  By pressing this button, the PT1502 will turn on all power sources and start the microcontroller.  After that, the button can work as a normal button.  In order for the microcontroller not to burn with the high voltage of the battery, I built a small voltage divider that will drive the BTN1 signal into the required frames (however, it is possible without it - the microcontroller has 5V tolerant inputs) <br><br>  The second button is unremarkable.  Inside the processor, a pull up to the ground will be turned on, and the button will feed the unit to the line ... <br><br>  Smoothly go to the heavy periphery.  USB <br><br><img src="https://habrastorage.org/webt/hj/vn/tg/hjvntgq_-3sjzwjv03t0dqd--gg.png"><br><br>  The USB connector will stick out of the device, and static electricity can walk there.  It turns out there are special chips (such as STF202-22), which protect microcontrollers from external influence. <br><br>  But there is another interesting.  A 1.5k resistor is hidden inside the STF202 chip, which is connected between the VBUS foot and the D + line.  This resistor is required by the USB specification - the host will know from it that something has been plugged into it.  In many circuits, this resistor is always connected between the power supply and the D + line.  As soon as the host sees such a resistor on the D + line, it immediately starts communicating with the device.  This is not always appropriate, since  Some devices may not be immediately ready for communication. <br><br>  This is just my case.  For this there is a simple trick (peeped over <a href="http://we.easyelectronics.ru/Shematech/diskonnekt-i-zaschita-usb-v-odnom-flakone.html">here</a> ).  You can turn this resistor on and off with a transistor: we want communication ‚Äî we turn on the resistor, we just want to be powered from USB ‚Äî we turn it off.  When you plug your cell phone into USB, he usually asks ‚Äúwhat shall we do?  Data to merge or only to be charged? ‚Äù- in terms of electronics, this is precisely the point of connecting a pull-up resistor. <br><br>  But how do you know if the device is plugged into USB?  For this, I provided a USB_PLUGGED signal, which is removed from the simplest divider. <br><br><img src="https://habrastorage.org/webt/hx/lr/u5/hxlru5qf7wv13uxeseybbyhhpdi.png"><br><br>  5V from USB could be sent directly to the leg of the microcontroller - they are still tolerant to 5V.  But let it be through the divider. <br><br>  Now accelerometer <br><br><img src="https://habrastorage.org/webt/-g/t1/5j/-gt15jf_cub3nubnrpsbr5hiusa.png"><br><br>  The circuit is taken from datasheet.  The module is connected via I2C, but to signal the microcontroller that there is news, the interrupt line is also used.  Also, since the three-volt INA219 still hangs on the same I2C bus, to match the levels, the communication feet of the accelerometer are also powered from the 3V bus. <br><br>  I already mentioned that I would like to save electricity and disconnect unused appliances.  So the power of the accelerometer is switched on by the transistor. <br><br>  By the way, I really liked the so-called.  digital transistors - a transistor complete with two resistors.  This saves a bit of board space.  The only pity is that with a two-volt power supply I could not pick up a digital transistor with at least some decent current - 20-30 mA maximum.  So the more voracious consumers had to connect MOSFET'ami. <br><br>  Go ahead, GPS <br><br><img src="https://habrastorage.org/webt/vr/l-/hm/vrl-hm0a27os6lit3ont256xd1g.png"><br><br>  GPS is located on a separate board and is connected via cable.  Since I have not yet decided on the GPS module, I have provided 2 different power supplies.  In addition to the power transistor on the side of the processor board there is nothing more interesting. <br><br>  I can only say a few words about UARTs.  Initially, I planned to use all 3 - one for uploading firmware and debugging, the second for GPS and the third for Bluetooth.  But it turned out that UART3 is on the same pins as I2C No. 2, which I originally planned to use for the display.  I had to choose.  As a result, I came to the conclusion that I can upload firmware and debug through the same UART that is reserved for GPS (of course, GPS will have to be disabled).  Well, if you need to debug the GPS itself, then there is also a USB CDC (in which you can upload logs) and SWD.  Later, I abandoned the idea of ‚Äã‚Äãusing I2C # 2, so the UART3 was released, but in the name of saving the battery, I decided to stop at two UARTs. <br><br>  Bluetooth <br><br><img src="https://habrastorage.org/webt/r2/m6/zt/r2m6ztztpabt1_2yprjrdava5nq.png"><br><br>  Bluetooth connects according to the scheme of datasheet.  PIO1 output can operate in two modes.  In the first, an LED is connected to it and the module is blinking with this LED.  Different winking means different status.  In another mode, this output works as digital ‚Äî a unit when the connection is established, and 0 if not.  Modes are switched by AT commands during module initialization. <br><br>  SD card <br><br>  Although the SD card connection scheme is standard, but for some reason it was very difficult for me.  There are too many different connection options on the Internet and it‚Äôs hard to understand what‚Äôs right. <br><br><img src="https://habrastorage.org/webt/9g/mi/xh/9gmixhnhcfhlo0s98wcmfz1dubk.png"><br><br>  For the most part, I had questions in pass-through resistors.  Occasionally there are circuits where 1k resistors are installed.  Some circuits put resistors of 22 Ohms, apparently as a protection against static.  Nevertheless, most of the circuits do not offer pass-through resistors, and I, perhaps, will go the same way.  I also will not have statics.  The flash drive will live inside the case. <br><br>  The power transistor, as it seems to me, will also not be claimed, I think the card will always work - it's a logger.  But since this is a test fee, then let it be.  The same is true about the coil - apparently this inclusion was made paranoid in the original, or the card was used in an environment with poor power or noise.  I think to solder the zero resistor there and try without a coil. <br><br>  Display <br><br>  I had the opportunity to connect one of the display modules with Ali via SPI and compare it with the connection via I2C.  There were no particular difficulties, and the code only needed to be squandered.  At the same time, the SPI speed is much higher than that of the I2C.  Having added data from the datasheet on consumption (4 mA for SPI versus 10 mA for I2C), the need for pull-up resistors for I2C, I decided to connect the display via SPI. <br><br><img src="https://habrastorage.org/webt/zn/zx/yh/znzxyhs4tcmv4fyyhb-hfxzihns.png"><br><br>  Unfortunately, the BS0 signal is not displayed on the display loop, and therefore it is impossible to select the 3-Wire SPI mode, only 4-Wire SPI is possible.  The difference is in the additional D / C line (data / command), which in the case of the 3-Wire mode are transmitted by the ninth bit of the SPI data.  However, maybe 4-Wire mode is for the better, because  SPI in STM32 can only transmit 8 bits. <br><br>  The rest of the scheme corresponds to the datasheet. <br><br>  And finally, the squeaker.  Nothing special - just turn on through the transistor. <br><br><img src="https://habrastorage.org/webt/b9/nk/9u/b9nk9uzbod6oeswokssk4nhfvsq.png"><br><br>  In case there is a vibration motor instead of a tweeter, I provided a protective diode.  However, I heard the opinion that a protective diode also does not interfere with a beeper. <br><br><h2>  In the gland </h2><br>  Above, I described my thoughts on the subject of the hull.  In fact, I even tried to dilute the board for this case.  Unfortunately, the fee was too close.  I had to use double-sided mounting, to switch from components 1206 to 0805, but still the components on the board were very tight.  Moreover, every change in the scheme was a pain, because  I had to re-distribute almost half the fee. <br><br>  So I fussed with it for several weeks, but the board won me over and the project I abandoned for almost a year.  <a href="https://habr.com/ru/post/445036/">This article</a> has become a kick.  But indeed, this is only a prototype, with the first of several.  Why bother with a super-compact board, where you can‚Äôt get a soldering iron or an oscilloscope, if you can debug everything on a large board? <br><br>  Well, it is not necessary to do such a huge fee like an iPhone, but it‚Äôs quite possible to get into the promotional 100x100mm 2 layers of JLCPCB.  You can hardly limit yourself.  So the board has a huge 2.42 ‚Äùdisplay, jumpers measuring consumption across all power lines, power capacitors where necessary and not needed, and in general a lot of parts that could not be installed.  There is also a place left. <br><br><img src="https://habrastorage.org/webt/nm/ig/vr/nmigvrrichuyvfy4vddfogpnquu.png"><br><br><img src="https://habrastorage.org/webt/sr/cy/ed/srcyeditmbixylghywsn15j-qas.png"><br><br><div class="spoiler">  <b class="spoiler_title">It's in Photo View</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d-/co/ru/d-coru_uwsrkpvz44tirfmisedg.png"><br><br><img src="https://habrastorage.org/webt/5w/pq/xk/5wpqxktdsgqt1auvgeh4wnhbaz4.png"><br></div></div><br>  There is nothing to tell about the layout.  I bred most of the signal and power lines on the upper layer, whereas the lower part was almost completely put under the ground.  Unfortunately, the layout still turned out to be quite dense and some signal lines had to be dragged along the bottom layer through the half board.  Because of this, the land in some places is ‚Äútorn‚Äù on several weakly connected islands.  I hope this will not be a problem. <br><br>  I didn‚Äôt do the ground under the bluetooth antenna, but I still had to drag one of the signal lines through this zone.  However, this is the BT_ON line, along which the signals often do not run (there it is either on or off), which means it should not influence the signal particularly strongly. <br><br>  Summer was coming and I was planning to take a fee with me on vacation.  So that the maids in hotels are not afraid of the bare debug board with a fan of wires, it would be nice to hide it in the case.  I could not deny myself the pleasure and developed the case and the board at the same time.  So there were mounting the board in the case, mounting the display holder. <br><br>  The GPS module is a sandwich of several boards and an antenna 12mm thick.  I decided not to cling to the board from above, but to place it on the same level.  This reduced the thickness of the case, but one corner of the board bit off. <br><br>  A couple of photos of the board and the final (at this stage of the project) device. <br><br><img src="https://habrastorage.org/webt/sr/yk/-g/sryk-gs6dpsw3cjk4mx7fhj4khw.jpeg"><br><br><img src="https://habrastorage.org/webt/i7/hm/im/i7hmimruqywcfpkw9q5qudxkyog.jpeg"><br><br><img src="https://habrastorage.org/webt/r_/wo/bj/r_wobjeewfmg8fohrp_nmehi1c4.jpeg"><br><br>  The battery is well placed under the display, but I had to make a small box in order to lift the display closer to the top cover. <br><br>  A few words on the assembly board.  I soldered everything for about 3 evenings, and about a week more in the evenings I spent on slow debugging and checking by the program part.  To my surprise, there were no fundamental difficulties with setting up the board, and almost everything went right. <br><br>  Loose 0805 was not much more difficult to solder than 1206, it is quite edible at home with a magnifying glass.  You can even swing at 0603.  But with the soldering of the microcontroller and the display connector (they have a 0.5mm pin pitch) I had to tinker.  On people in YouTube, it somehow just looks - I spent it once with a soldering iron and that's it, but all my conclusions stuck instantly. <br><br>  Not without minor problems.  In some places there was not drunk, somewhere there was a ‚Äúsnot‚Äù.  The footprint for the USB connector turned out to be wrong - he had a smaller lead pitch than necessary (so believe after that footprints from the Internet!).  I had to bend the findings a bit so that they became on the tracks.  <a href="https://ru.aliexpress.com/item/32850399481.html%3Fspm%3Da2g0s.9042311.0.0.274233edefU7Wz">The FPC</a> display <a href="https://ru.aliexpress.com/item/32850399481.html%3Fspm%3Da2g0s.9042311.0.0.274233edefU7Wz">connector</a> bought on Ali turned out to be with contacts from below, while I needed it with contacts from above (I had never been aware of such a difference before).  I had to ‚Äúblow off‚Äù the connector from the standard display board. <br><br>  After stuffing the board into the case, it turned out that it was impossible to disconnect the battery simply by pulling out the connector, but I didn‚Äôt want to leave the unresolved board under voltage.  I had to hit the switch. <br><br>  When setting up the board, it turned out that there was no earth contact anywhere where the oscilloscope probe could be attached.  I had to cling to the crocodile for the USB connector.  It will be necessary to provide test sites in the next version of the board. <br><br>  The circuitry also revealed problems.  So a completely unexpected fact turned out that the PT1502 chip at the RESET pin generates a voltage of 3V (I was absolutely sure that there was something like an open collector).  As a result, these 3B flowed to the power line, even though I planned to have only 2B there. <br><br>  Here is a simplified diagram of what happened. <br><img src="https://habrastorage.org/webt/ag/rw/tg/agrwtgjika-hvgzl_die2gokf4c.png"><br><br>  Thanks to the great reason and the guys from easyelectronics.com, this joint was decided to add one diode.  After a small surgical procedure, this part worked as it should. <br><br>  Next, the bluetooth module (powered by 2.5V) I inadvertently connected to the main power supply (2B), instead of the fixed 3V.  Now my bluetooth can only work when USB is connected, when the main power supply voltage rises to 3.3V. <br><br>  In principle, it would be possible to wave the scalpel and solder the bluetooth to proper nutrition, but the UART2 to which the bluetooth is connected is not tolerant to 5B (he himself read it in the datasheet at the analysis stage, he himself noted this in the text above, and eventually forgot ).  Therefore, connecting the bluetooth to the power supply is higher than the power of the microcontroller is fraught ... In the next version of the board, I will simply connect the bluetooth to some other UART. <br><br>  The DC-DC converter with variable voltage also worked as planned - when powered from the battery, it produces 2V regularly, and when you plug in the USB it rises to 3.16V (you need to play with the nominal values ‚Äã‚Äãand drag it to 3.3V).  But then another flaw of the circuit came out: you also need to be able to raise the voltage when powered by the programmer.  I think it is treated by adding another diode.  I'll try to play a little later. <br><br>  Finally, during the work on the board, I still didn‚Äôt understand how to properly power the SD card from undervoltage.  A short googling led to nothing.  Apparently, you need to dive into reading specifications of specifications (which, in addition, are partially closed).  In the meantime, I short-circuited R7 and the board is now powered by fixed 3.16V (3.3V).  I will leave it so far for the next couple of months while I work on the program part. <br><br>  Speaking of software.  Surprisingly (although it is quite expected), but in general, everything went without problems.  Since I was switching between one series of microcontrollers (from F103CB to F103RC), there was no need to rework the software part.  Only pin numbers corrected, but added the inclusion of transistors.  Nevertheless, there were 2 nontrivial moments with which I had to tinker. <br><br>  The first is battery power.  I debugged the board when powered by USB and everything worked well overall.  But the board did not want to switch on from the battery.  Those.  It can work (if you turn it on when USB is connected, and then pull out the cord), but it does not work on a cold one. <br><br>  According to the design of the PT1502 chip, the board should start like this.  The user presses the BTN1 button and after a third of a second the chip turns on all power supplies.  When everything is good with power, the PT1502 ‚Äúreleases‚Äù the RESET signal, thus starting the microcontroller.  The processor, in turn, sets the PWR_HOLD signal to one, signaling that it has started.  After that, PT1502 regularly supplies electricity to the circuit until the microcontroller lowers the PWR_HOLD signal to zero. <br><br>  But it is in theory.  In fact, as soon as the processor set the PWR_HOLD signal, the board was instantly turned off.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I shoveled the entire power supply circuit, watched the oscillograms of the main signals, shuffled the code in the bootloader back and forth, but the problem could not be understood. I also sinned in the absence of a pull-down resistor on the PWR_HOLD line, which I forgot to install, but it is recommended by the datasheet (and most likely it is needed). But adding it to the canopy did not solve the problem. And only when I borrowed a four-channel oscilloscope everything became clear.</font></font><br><br><img src="https://habrastorage.org/webt/ix/ie/xf/ixiexf-lau1vggfbwu9ta4ys_hq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the user presses the button (orange line), the PT1502 chip turns on the power (purple line). All this takes place long (300ms) before the events on this oscillogram. And then something interesting happens. PT1502 releases RESET (blue line), the processor starts up and for some reason lowers the button line to zero. Even though the microcontroller is still trying to raise the POWER_HOLD line (green line) - it's too late, PT1502 has already turned off all power supplies. Then there are a few more convulsions, but the scheme still quietly dies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question is where did the zero on the button come from? The whole thing is an </font></font><a href="https://github.com/rogerclarkmelbourne/STM32duino-bootloader/pull/70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inconspicuous error in the bootloader</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because of which the output mode was set up on the BTN1's foot (perhaps miracles happened on other legs at that moment) and a low signal appeared there.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What else I had to face off with was an SD card. In the old microcontroller, the SDIO module simply did not exist, so this piece had to be studied from scratch. I spent almost the whole day trying to get a map, copying pieces of code from examples on the Internet and what CubeMX generated. Although the map was perfectly readable in the computer, I did not want to wind up in my scheme. I sinned on a bad solder, incorrectly chosen pull-up resistors, a clumsy circuit and a wrongly interpreted datasheet. But to my surprise, another card with the same code and on the same board started up without problems. It will be necessary to study this question in more detail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There was another problem with the card. Having poked the oscilloscope in different lines, I saw activity only on the D0 line, while there was silence on D1-D3 - the card worked in one-bit mode. The HAL even showed up a HAL_SD_ConfigWideBusOperation () function that can enable 4-bit transfer mode. Unfortunately, when the card was transferred to 4-bit mode, the SDIO peripherals went to a deep RX FIFO Overrun and stopped working.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem turned out to be very interesting. </font><font style="vertical-align: inherit;">It turned out that inside the HAL_SD_ReadBlocks () function there is a certain loop that polls the SDIO flags. </font><font style="vertical-align: inherit;">As new data is received from the card, this code transfers the bytes from the internal FIFO buffer to the user memory. </font><font style="vertical-align: inherit;">So the map transferred the bytes so fast that the code in HAL_SD_ReadBlocks () simply did not have time to shift the data. </font><font style="vertical-align: inherit;">I had to temporarily lower the card clock frequency. </font><font style="vertical-align: inherit;">Well, in the future I will use DMA and this problem should not arise in principle.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion and further steps </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Those who are in this place expected to see the finished device I have to upset - only the test board is finished, and even then only the iron part. Now you need to breathe life into it, do software strapping, fine-tuning modes and consumption. Well, actually write the logging code - for the sake of what the whole project was started. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nevertheless, for me personally, this stage is a very big and important achievement. Electronics is not my specialty and I am very glad that the device has started up at all. I managed to get quite strong in designing circuits, coordinating several devices, wiring a board, choosing components and much more than that.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will tell you about the program part another time. </font><font style="vertical-align: inherit;">As well as about the nuances of customization. </font><font style="vertical-align: inherit;">The fact is that this entire filling must first be revived and tested. </font><font style="vertical-align: inherit;">At the moment, it was possible to launch all the devices on the board (well, except for the tweeter), but only in the volume ‚Äúit started and somehow responds‚Äù. </font><font style="vertical-align: inherit;">No processing logic has been written yet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plans for the near future:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drive electronics in different modes, check that the circuit still works. </font><font style="vertical-align: inherit;">Fix the jambs in the second version of the board</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Measure consumption of all peripherals and find ways to optimize consumption. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collect several board options on different microcontrollers (for example, on L152 or L433) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thoughtfully read the SD specification and figure out how to properly connect the card in the Low Voltage Signaling mode (1.8V) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Try different GPS modules and, finally, decide on how I will go further </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Order a separate compass chip (for example HMC5883L or HSCDTD008A) and try to use them somehow </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To do internal code refactoring, upgrade all major libraries, starting with HAL </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start, finally, write features. </font><font style="vertical-align: inherit;">Actually implement what the device was intended for</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this, let me take a bow. </font><font style="vertical-align: inherit;">I would be grateful for constructive comments, ideas and advice on circuit design and PCB layout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources:</font></font><br><br>  <a href="https://github.com/grafalex82/GPSLogger">Code</a> <br> <a href="https://github.com/grafalex82/STM32duino-bootloader/tree/gpslogger_bootloader"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code bootloader </font></font></a> <br> <a href="https://easyeda.com/editor"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fee</font></font></a> <br>  <a href="https://cad.onshape.com/documents/8092a5e633174f005b156d23/w/b48f920e9dbda410343914c6/e/c9718a9053bda2a2bb7ed4da">Housing</a> </div><p>Source: <a href="https://habr.com/ru/post/454434/">https://habr.com/ru/post/454434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454422/index.html">On the perverted interpretation of Newton's First Law in modern physics</a></li>
<li><a href="../454426/index.html">ARTificial: at the dawn of artificial intelligence</a></li>
<li><a href="../454428/index.html">What Apple introduced at WWDC, and what do iOS developers think about it</a></li>
<li><a href="../454430/index.html">Life on 3D particles</a></li>
<li><a href="../454432/index.html">Interesting archeology: R style guide under a magnifying glass</a></li>
<li><a href="../454436/index.html">Small python joy # 1: loguru</a></li>
<li><a href="../454440/index.html">Little Python Joy # 2: Starlette</a></li>
<li><a href="../454442/index.html">How to choose a proxy network for business: 3 practical advice</a></li>
<li><a href="../454444/index.html">We profile Habr's download or how 189 requests for render pages affect</a></li>
<li><a href="../454446/index.html">What's new in C # 8?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>