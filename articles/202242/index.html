<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Process memory card</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever thought about exactly how the memory available to your program is used, and in general, what exactly is located in these two or three gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Process memory card</h1><div class="post__text post__text-html js-mediator-article">  Have you ever thought about exactly how the memory available to your program is used, and in general, what exactly is located in these two or three gigabytes of virtual memory with which your software works? <br><br>  Ask why? <br>  Well, for a 32-bit application, 2-3 gigabytes is your limit beyond which you cannot get out without AWE, but it‚Äôs still desirable to control your own resources.  But even without it, just to figure it out ... <br><br>  In previous articles, I described the work of the debugger, where modifications were made to the application being debugged.  This article is a continuation of this material.  And although it will have no relation to the debugger, the debugging process itself is the most direct ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's see exactly how a programmer works with memory when debugging (especially when debugging a third-party application, in other words, when reversing): <br><br>  1. As a rule, the most frequent operation will be to search for a value in the application's memory, and unfortunately, this functionality is for some reason not provided in the Delphi debugger (in fact, as in MS VC ++). <br>  2. Modification of system structures (PEB / TEB / SEHChain / Unwind / directories of PE files, etc ...) will be much easier when the structure fields are mapped to the addresses they occupy and are presented in a readable form. <br>  3. Tracking changes in the process memory (almost no one provides functionality implemented as plug-ins for popular debuggers).  Indeed, why trace to blue in the face when it is enough to compare two snapshots of a memory card in order to understand whether the necessary data modification is happening here or not? <br><br>  Yes, actually, there are many use cases. <br><br>  However, if without lyrics, there are very few utilities that display more or less imputed information about the process memory card that can be used for debugging. <br><a name="habracut"></a><br>  The most convenient implementation from OllyDebug 2, but unfortunately, it does not display data on 64 bits (still waiting). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/810/74c/cdf81074c083b6b582b9e00a12a3928f.png"></div><br>  VMMap from Mark Russinovich performs purely decorative properties, yes it is beautiful, but signed by Microsoft, but it‚Äôs hard to practically use the data it displays. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94f/f8f/9cb/94ff8f9cbf74b8c5c95e8f253c7bec37.png"></div><br>  ProcessHacker is a good tool, but its author did not set himself the task of working with the output of memory data, so the information he displays can be said to be the simplest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/fd6/456/b20fd6456c4b6026411ede17b98aa97f.png"></div><br>  Well, for so many years of working with it, I was not used to the memory card from IDA Pro (I'm not comfortable) :) <br><br>  However, debugging is not everything where a valid memory card can be useful.  In particular, for work, I use a memory card when analyzing the error log sent to us by users along with a dump of critical areas, integrating information about it into EurekaLog. <br><br>  In this article I will try to tell you in steps how to create a process memory card on your own and place information about the data needed for debugging and analysis in it. <br><br><h4>  1. Get a list of available regions </h4><br>  The entire virtual memory of the process is presented in the form of pages. <br>  Pages are small (4096 bytes) and large.  ( <a href="http://msdn.microsoft.com/en-us/library/aa366543(VS.85).aspx">More details can be found in MSDN</a> ) <br>  In most cases, consecutive pages have the same attributes. <br><br>  What is the region? <br>  Roughly ( <a href="http://msdn.microsoft.com/en-us/library/aa366775(v%3Dvs.85).aspx">based on MSDN</a> ) is a set of all pages with the same attributes that begin with the address passed to the VirtualQuery function. <br><br>  In the simplest form, you can get a list of regions of our process with this code: <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> Project1; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MBI: TMemoryBasicInformation; dwLength: NativeUInt; Address: PByte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Address := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; dwLength := SizeOf(TMemoryBasicInformation); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> VirtualQuery(Address, MBI, dwLength) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln( <span class="hljs-string"><span class="hljs-string">'AllocationBase: '</span></span>, IntToHex(NativeUInt(MBI.AllocationBase), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">', BaseAddress: '</span></span>, IntToHex(NativeUInt(MBI.BaseAddress), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">', RegionSize: '</span></span>, MBI.RegionSize); Inc(Address, MBI.RegionSize); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  For example, initially we passed the address nil as the first parameter.  After calling the function, the MBI variable will take the following values: <br><br><ul><li>  BaseAddress = nil </li><li>  AllocationBase = nil </li><li>  AllocationProtect = 0 </li><li>  RegionSize = $ 10,000 </li><li>  State = $ 10,000 </li><li>  Protect = 1 </li><li>  Type_9 = 0 </li></ul><br>  The region size is $ 10,000 (64 kb), this corresponds to 16 pages running in a row, starting with the address zero, the state of which (State) is MEM_FREE ($ 10,000) and the security attribute PAGE_NO_ACCESS (1) is set in the Protect parameter. <br><br>  If you rewrite the code like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtractAccessString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAGE_WRITECOMBINE = $<span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-string"><span class="hljs-string">'Unknown access'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_EXECUTE) = PAGE_EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'E'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_EXECUTE_READ) = PAGE_EXECUTE_READ <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'RE'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_EXECUTE_READWRITE) = PAGE_EXECUTE_READWRITE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'RWE'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_EXECUTE_WRITECOPY) = PAGE_EXECUTE_WRITECOPY <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'RE, Write copy'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_NOACCESS) = PAGE_NOACCESS <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'No access'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_READONLY) = PAGE_READONLY <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'R'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_READWRITE) = PAGE_READWRITE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'RW'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_WRITECOPY) = PAGE_WRITECOPY <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'Write copy'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_GUARD) = PAGE_GUARD <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">', Guarded'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_NOCACHE) = PAGE_NOCACHE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">', No cache'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> PAGE_WRITECOMBINE) = PAGE_WRITECOMBINE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">', Write Combine'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtractRegionTypeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TMemoryBasicInformation)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Value.State <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MEM_FREE: Result := <span class="hljs-string"><span class="hljs-string">'Free'</span></span>; MEM_RESERVE: Result := <span class="hljs-string"><span class="hljs-string">'Reserved'</span></span>; MEM_COMMIT: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Value.Type_9 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MEM_IMAGE: Result := <span class="hljs-string"><span class="hljs-string">'Image'</span></span>; MEM_MAPPED: Result := <span class="hljs-string"><span class="hljs-string">'Mapped'</span></span>; MEM_PRIVATE: Result := <span class="hljs-string"><span class="hljs-string">'Private'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := Result + <span class="hljs-string"><span class="hljs-string">', '</span></span> + ExtractAccessString(Value.Protect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MBI: TMemoryBasicInformation; dwLength: NativeUInt; Address: PByte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Address := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; dwLength := SizeOf(TMemoryBasicInformation); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> VirtualQuery(Address, MBI, dwLength) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln( <span class="hljs-string"><span class="hljs-string">'AllocationBase: '</span></span>, IntToHex(NativeUInt(MBI.AllocationBase), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">', BaseAddress: '</span></span>, IntToHex(NativeUInt(MBI.BaseAddress), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">' - '</span></span>, ExtractRegionTypeString(MBI)); Inc(Address, MBI.RegionSize); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  ... then we can clearly see the principle of partitioning into regions by the VirtualAlloc function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/70a/117/02b70a117f8fd5953f5550e191f55ed8.png"></div><br>  For example, the second and third regions have the same access attributes (read entry), but different AllocationBase.  AllocationBase is assigned to pages when allocating memory through VirtualAlloc, thus combining them into a separate region. <br><br><h4>  2. Collect flow data </h4><br>  The time has come to start filling in the regions we received with information about what they store, and we will start with the flows (the threads - to someone as convenient). <br><br>  The code for getting the list of threads is simple - via CreateToolhelp32Snapshot. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> THREAD_GET_CONTEXT = <span class="hljs-number"><span class="hljs-number">8</span></span>; THREAD_SUSPEND_RESUME = <span class="hljs-number"><span class="hljs-number">2</span></span>; THREAD_QUERY_INFORMATION = $<span class="hljs-number"><span class="hljs-number">40</span></span>; ThreadBasicInformation = <span class="hljs-number"><span class="hljs-number">0</span></span>; ThreadQuerySetWin32StartAddress = <span class="hljs-number"><span class="hljs-number">9</span></span>; STATUS_SUCCESS = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hSnap, hThread: THandle; ThreadEntry: TThreadEntry32; TBI: TThreadBasicInformation; TIB: NT_TIB; lpNumberOfBytesRead: NativeUInt; ThreadStartAddress: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      hSnap := CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId); if hSnap &lt;&gt; INVALID_HANDLE_VALUE then try ThreadEntry.dwSize := SizeOf(TThreadEntry32); if Thread32First(hSnap, ThreadEntry) then repeat if ThreadEntry.th32OwnerProcessID &lt;&gt; GetCurrentProcessId then Continue; Writeln('ThreadID: ', ThreadEntry.th32ThreadID); //   hThread := OpenThread(THREAD_GET_CONTEXT or THREAD_SUSPEND_RESUME or THREAD_QUERY_INFORMATION, False, ThreadEntry.th32ThreadID); if hThread &lt;&gt; 0 then try //   ThreadProc() if NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, @ThreadStartAddress, SizeOf(ThreadStartAddress), nil) = STATUS_SUCCESS then Writeln('ThreadProcAddr: ', IntToHex(NativeUInt(ThreadStartAddress), 1)); //     if NtQueryInformationThread(hThread, ThreadBasicInformation, @TBI, SizeOf(TThreadBasicInformation), nil) = STATUS_SUCCESS then begin Writeln('Thread Environment Block (TEB) Addr: ', IntToHex(NativeUInt(TBI.TebBaseAddress), 1)); //      // TIB (Thread Information Block)   if ReadProcessMemory(GetCurrentProcess, TBI.TebBaseAddress, @TIB, SizeOf(NT_TIB), lpNumberOfBytesRead) then begin Writeln('Thread StackBase Addr: ', IntToHex(NativeUInt(TIB.StackBase), 1)); Writeln('Thread StackLimit Addr: ', IntToHex(NativeUInt(TIB.StackLimit), 1)); end; end; finally CloseHandle(hThread); end; until not Thread32Next(hSnap, ThreadEntry); finally CloseHandle(hSnap); end; Readln; end.</span></span></code> </pre><br>  Steps: <br><br><ol><li>  Using CreateToolhelp32Snapshot / Thread32First / Thread32Next we get a list of active threads in our application. </li><li>  For more detailed information, you will need the handle of the thread, which is obtained by calling OpenThread. </li><li>  With the help of NtQueryInformationThread, we get the address of the flow procedure with which it started, and basic information about the flow in the form of a TThreadBasicInformation structure. </li><li>  From this structure, we are interested in only one field - TebBaseAddress, which contains the address of the flow environment block, the so-called.  TEB (Thread Environment Block). </li><li>  By calling ReadProcessMemory (although this is redundant for your application), we read the data at the TEB address, namely, its very first parameter, which is the NT_TIB structure. </li></ol><br>  The NT_TIB declaration looks like this: <br><br><pre> <code class="delphi hljs"> PNT_TIB = ^_NT_TIB; _NT_TIB = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ExceptionList: Pointer; StackBase, StackLimit, SubSystemTib: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ( FiberData: Pointer ); <span class="hljs-number"><span class="hljs-number">1</span></span>: ( Version: ULONG; ArbitraryUserPointer: Pointer; Self: PNT_TIB; ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; NT_TIB = _NT_TIB; PPNT_TIB = ^PNT_TIB;</code> </pre><br>  Well, or so, if you describe a little more: <br><br><ul><li>  ExceptionList - in a 32-bit process, a pointer to the address of the current SEH frame (EXCEPTION_REGISTRATION structure).  Based on this information, we will unwind the entire chain of SEH frames. </li><li>  If the TEB belongs to a 64-bit stream running in a 32-bit application, then this field will point to the ExceptionList field of its 32-bit counterpart. </li><li>  In a 64-bit process, this field is always enclosed, since  for 64 bits, instead of the SEH mechanism, a slightly different mechanism works. </li><li>  StackBase - base stack.  The address from which the stack begins to grow in the direction of StackLimit. </li><li>  StackLimit is the current top of the stack. </li><li>  ArbitraryUserPointer is something like a free TLS slot.  Roughly speaking, a variable belongs to a thread, the value of which can be arbitrarily changed by the programmer himself for his own needs. </li><li>  Self - the parameter containing the address of the TEB (i.e. itself) </li></ul><br>  The remaining fields are not needed. <br><br>  Well, however, how - not needed? <br>  We need, of course, but for now they are redundant for us. <br>  By the way, here is a link where you can see a slightly outdated description of this structure: <a href="http://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Environment Block</a> . <br><br>  This code will display the following image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/caa/b34/8eacaab3474045dc04757c0a85ad47ee.png"></div><br>  This is how it will be seen in VMMap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c12/23a/808/c1223a808e42c63ae8792eff3d5b88d6.png"></div><br>  The picture shows that VMMap did not display information about the TEB. <br><br>  By the way, some of the functions and structures from the above code are not declared in the standard Delphi source code; you can see their declaration in the <a href="">demo examples</a> included in this article.  But this does not mean that they are undocumented in MSDN :) <br><br>  If we want to work with the TEB of our thread, the code will be greatly simplified due to the fact that you do not need to use the ToolHelp32.dll functions, but rather using the segment register FS (or GS for x64). <br>  For example, this function is very often found to get the address of a TEB: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentTEB</span></span></span><span class="hljs-function">:</span></span> NativeUInt; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF WIN64}</span></span> <span class="hljs-comment"><span class="hljs-comment">// mov RAX, qword ptr GS:[30h] //   ,      64-  DB $65, $48, $8B, $04, $25, $30, 0, 0, 0 //    ,    mov RAX, qword ptr GS:[abs $30] {$ELSE} mov EAX, FS:[18h] {$ENDIF} end;</span></span></code> </pre><br>  In this case, the NtTIB.Self parameter of the TEB structure is accessed, which is located at offset 0x18 (or 0x30 in the case of 64-bit TEB) from its beginning. <br><br>  But let's continue ... <br>  Part of the data received, but this is not all the information available to us. <br><br>  On the stack of each thread there are SEH frames, which are generated by the machine at the entrance to the try..finally / except block, as well as a stack of procedure calls.  It would be nice to have these data on hand and display them in a more visual form - with reference to the region. <br><br>  The promotion of SEH frames will be dealt with here is such a simple procedure: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetThreadSEHFrames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitialAddr: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EXCEPTION_REGISTRATION = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> prev, handler: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ER: EXCEPTION_REGISTRATION; lpNumberOfBytesRead: NativeUInt; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ReadProcessMemory(GetCurrentProcess, InitialAddr, @ER, SizeOf(EXCEPTION_REGISTRATION), lpNumberOfBytesRead) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'SEH Frame at Addr: '</span></span>, IntToHex(NativeUInt(InitialAddr), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">', handler at addr: '</span></span>, IntToHex(NativeUInt(ER.handler), <span class="hljs-number"><span class="hljs-number">1</span></span>)); InitialAddr := ER.prev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DWORD(InitialAddr) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Having received the value of TEB.TIB.ExceptionList as a parameter, which points to the first EXCEPTION_REGISTRATION structure, it runs along the data chain of the structures, focusing on the prev value of this structure, which contains the address of the previous EXCEPTION_REGISTRATION structure.  And the handler parameter contains the address of the exception handler if it happens. <br><br>  It looks like this: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/abb/152/03a/abb15203a3e0fc3587d49949a13f4ab3.png"></div><br>  Well, CallStack will receive the following procedure: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetThreadCallStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hThread: THandle)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StackFrame: TStackFrame; ThreadContext: PContext; MachineType: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// ThreadContext   ,   VirtualAlloc //         //     ERROR_NOACCESS (998) ThreadContext := VirtualAlloc(nil, SizeOf(TContext), MEM_COMMIT, PAGE_READWRITE); try ThreadContext^.ContextFlags := CONTEXT_FULL; if not GetThreadContext(hThread, ThreadContext^) then Exit; ZeroMemory(@StackFrame, SizeOf(TStackFrame)); StackFrame.AddrPC.Mode := AddrModeFlat; StackFrame.AddrStack.Mode := AddrModeFlat; StackFrame.AddrFrame.Mode := AddrModeFlat; StackFrame.AddrPC.Offset := ThreadContext.Eip; StackFrame.AddrStack.Offset := ThreadContext.Esp; StackFrame.AddrFrame.Offset := ThreadContext.Ebp; MachineType := IMAGE_FILE_MACHINE_I386; while True do begin if not StackWalk(MachineType, GetCurrentProcess, hThread, @StackFrame, ThreadContext, nil, nil, nil, nil) then Break; if StackFrame.AddrPC.Offset &lt;= 0 then Break; Writeln('CallStack Frame Addr: ', IntToHex(NativeUInt(StackFrame.AddrFrame.Offset), 1)); Writeln('CallStack Handler: ', IntToHex(NativeUInt(StackFrame.AddrPC.Offset), 1)); Writeln('CallStack Stack: ', IntToHex(NativeUInt(StackFrame.AddrStack.Offset), 1)); Writeln('CallStack Return: ', IntToHex(NativeUInt(StackFrame.AddrReturn.Offset), 1)); end; finally VirtualFree(ThreadContext, SizeOf(TContext), MEM_FREE); end; end;</span></span></code> </pre><br>  However, unlike the Delphi debugger, it will output data about the procedures for which the stack frame is generated, it will skip the rest. <br>  The StackWalk (or StackWalk64) function is responsible for listing information about stack frames. <br><br>  Now a caveat: if we apply this code to ourselves, then it will only be able to ottrassirovat one stack frame, after which the output will occur (you can check on the <a href="">demo application</a> ). <br><br>  This will happen for the following reason: to correctly trace the StackWalk function, you must specify the parameters of the current stack frame (EBP and ESP / RBP and RSP for x64) and, in fact, the current code address (EIP or RIP register for x64).  If we take this data from ourselves, this will happen at the moment when we call the GetThreadContext function, and we will begin to unwind the stack after exiting this function, where all three parameters become, to put it mildly, not valid.  For this reason, tracing yourself by calling this function will not work. <br>  This moment is desirable to take into account ... <br><br>  I will dwell on getting information about 32-bit process streams under a 64-bit OS including 32 and 64-bit variants a little later, and now ... <br><br><h4>  3. Collect Heap Data </h4><br>  By itself, a Delphi application, as a rule, does not use heaps, it is more a prerogative of C ++ applications, but still, heaps are present here.  Usually they are created and used by various third-party libraries for their needs. <br><br>  The nuance in obtaining data about the heaps is that the HeapEntry elements of which each heap consists may be several thousand, and the second nuance is that the Heap32Next function re-rebuilds the entire list with each call, creating a rather sensitive delay (up to tens of seconds). <br><br>  <a href="http://habrahabr.ru/post/181588/">I already wrote</a> about this unpleasant feature. <br>  True, in that article, the code was rather approximate, just to demonstrate the principle itself, and it will not suit us, but a more combed version would be fine with it: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RTL_HEAP_BUSY = <span class="hljs-number"><span class="hljs-number">1</span></span>; RTL_HEAP_SEGMENT = <span class="hljs-number"><span class="hljs-number">2</span></span>; RTL_HEAP_SETTABLE_VALUE = $<span class="hljs-number"><span class="hljs-number">10</span></span>; RTL_HEAP_SETTABLE_FLAG1 = $<span class="hljs-number"><span class="hljs-number">20</span></span>; RTL_HEAP_SETTABLE_FLAG2 = $<span class="hljs-number"><span class="hljs-number">40</span></span>; RTL_HEAP_SETTABLE_FLAG3 = $<span class="hljs-number"><span class="hljs-number">80</span></span>; RTL_HEAP_SETTABLE_FLAGS = $E0; RTL_HEAP_UNCOMMITTED_RANGE = $<span class="hljs-number"><span class="hljs-number">100</span></span>; RTL_HEAP_PROTECTED_ENTRY = $<span class="hljs-number"><span class="hljs-number">200</span></span>; RTL_HEAP_FIXED = (RTL_HEAP_BUSY <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> RTL_HEAP_SETTABLE_VALUE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> RTL_HEAP_SETTABLE_FLAG2 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> RTL_HEAP_SETTABLE_FLAG3 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> RTL_HEAP_SETTABLE_FLAGS <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> RTL_HEAP_PROTECTED_ENTRY); STATUS_SUCCESS = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSmallBuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STATUS_NO_MEMORY = $C0000017; STATUS_BUFFER_TOO_SMALL = $C0000023; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (Value = STATUS_NO_MEMORY) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Value = STATUS_BUFFER_TOO_SMALL); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlagToStr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> LF32_FIXED: Result := <span class="hljs-string"><span class="hljs-string">'LF32_FIXED'</span></span>; LF32_FREE: Result := <span class="hljs-string"><span class="hljs-string">'LF32_FREE'</span></span>; LF32_MOVEABLE: Result := <span class="hljs-string"><span class="hljs-string">'LF32_MOVEABLE'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, A: Integer; pDbgBuffer: PRtlDebugInformation; pHeapInformation: PRtlHeapInformation; pHeapEntry: PRtrHeapEntry; dwAddr, dwLastSize: ULONG_PTR; hit_seg_count: Integer; BuffSize: NativeUInt; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// ..  Heap32ListFirst, Heap32ListNext, Heap32First, Heap32Next //   , -   // RtlQueryProcessDebugInformation   ,     //      //    BuffSize := $400000; pDbgBuffer := RtlCreateQueryDebugBuffer(BuffSize, False); //       while CheckSmallBuff(RtlQueryProcessDebugInformation(GetCurrentProcessId, RTL_QUERY_PROCESS_HEAP_SUMMARY or RTL_QUERY_PROCESS_HEAP_ENTRIES, pDbgBuffer)) do begin //     , ... RtlDestroyQueryDebugBuffer(pDbgBuffer); BuffSize := BuffSize shl 1; pDbgBuffer := RtlCreateQueryDebugBuffer(BuffSize, False); end; if pDbgBuffer &lt;&gt; nil then try //       if RtlQueryProcessDebugInformation(GetCurrentProcessId, RTL_QUERY_PROCESS_HEAP_SUMMARY or RTL_QUERY_PROCESS_HEAP_ENTRIES, pDbgBuffer) = STATUS_SUCCESS then begin //       pHeapInformation := @pDbgBuffer^.Heaps^.Heaps[0]; //    ... for I := 0 to pDbgBuffer^.Heaps^.NumberOfHeaps - 1 do begin //     pHeapEntry := pHeapInformation^.Entries; dwAddr := DWORD(pHeapEntry^.u.s2.FirstBlock) + pHeapInformation^.EntryOverhead; dwLastSize := 0; A := 0; while A &lt; Integer(pHeapInformation^.NumberOfEntries) do try hit_seg_count := 0; while (pHeapEntry^.Flags and RTL_HEAP_SEGMENT) = RTL_HEAP_SEGMENT do begin //     RTL_HEAP_SEGMENT, //       EntryOverhead dwAddr := DWORD(pHeapEntry^.u.s2.FirstBlock) + pHeapInformation^.EntryOverhead; Inc(pHeapEntry); Inc(A); Inc(hit_seg_count); //      if A + hit_seg_count &gt;= Integer(pHeapInformation^.NumberOfEntries - 1) then Continue; end; //       ,     , //    +    if hit_seg_count = 0 then Inc(dwAddr, dwLastSize); //   if pHeapEntry^.Flags and RTL_HEAP_FIXED &lt;&gt; 0 then pHeapEntry^.Flags := LF32_FIXED else if pHeapEntry^.Flags and RTL_HEAP_SETTABLE_FLAG1 &lt;&gt; 0 then pHeapEntry^.Flags := LF32_MOVEABLE else if pHeapEntry^.Flags and RTL_HEAP_UNCOMMITTED_RANGE &lt;&gt; 0 then pHeapEntry^.Flags := LF32_FREE; if pHeapEntry^.Flags = 0 then pHeapEntry^.Flags := LF32_FIXED; //   Writeln('HeapID: ', I, ', entry addr: ', IntToHex(dwAddr, 8), ', size: ', IntToHex(pHeapEntry^.Size, 8), ' ', FlagToStr(pHeapEntry^.Flags)); //     dwLastSize := pHeapEntry^.Size; //     Inc(pHeapEntry); finally Inc(A); end; //     Inc(pHeapInformation); end; end; finally RtlDestroyQueryDebugBuffer(pDbgBuffer); end; Readln; end.</span></span></code> </pre><br>  In short, using the RtlQueryProcessDebugInformation function call, RtlCreateQueryDebugBuffer and RtlQueryProcessDebugInformation creates a buffer containing information about the current process heaps.  Then, knowing the structure of the data stored in it, we obtain this data in a cycle. <br>  pDbgBuffer ^ .Heaps - stores lists of heaps (similar to THeapList32), and the records themselves are stored in pDbgBuffer ^ .Heaps ^ .Heaps [N] .Entries (analogue of THeapEntry32). <br><br>  This code will display the following information: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/bcb/f1c/6e0/bcbf1c6e0d2dc852d20d651ec0241317.png"></div><br>  In principle, I use heaps rarely for debugging, but sometimes this information may be useful. <br><br><h4>  4. Collect data on downloaded PE files </h4><br>  Now it's time to get information about executable files and libraries loaded into the process address space.  There are several ways to do this (for example, by analyzing PEB.LoaderData), but we will proceed more simply. <br><br>  As a rule, a separate region is allocated for the PE file (well, at least I have not met such that the PE image is loaded without alignment on the top of the region), therefore, using the code from the first chapter and checking the data of the first page of the region to match the PE file, we get a list of all loaded libraries and executable files. <br><br>  The following code detects the presence of a valid PE file at the specified address: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckPEImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hProcess: THandle; ImageBase: Pointer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IsPEImage64: Boolean)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ReturnLength: NativeUInt; IDH: TImageDosHeader; NT: TImageNtHeaders; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; IsPEImage64 := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ReadProcessMemory(hProcess, ImageBase, @IDH, SizeOf(TImageDosHeader), ReturnLength) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IDH.e_magic &lt;&gt; IMAGE_DOS_SIGNATURE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; ImageBase := Pointer(NativeInt(ImageBase) + IDH._lfanew); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ReadProcessMemory(hProcess, ImageBase, @NT, SizeOf(TImageNtHeaders), ReturnLength) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Result := NT.Signature = IMAGE_NT_SIGNATURE; IsPEImage64 := (NT.FileHeader.Machine = IMAGE_FILE_MACHINE_IA64) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (NT.FileHeader.Machine = IMAGE_FILE_MACHINE_ALPHA64) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (NT.FileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Well, more precisely, as he simply checks for the presence of ImageDosHeader and ImageNTHeader, focusing on their signatures.  In principle, for 99% of cases this is enough. <br><br>  The third parameter is simply informational, it shows whether the PE file is 64-bit. <br><br>  You can get the path to the downloaded file by calling the function GetMappedFileName: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFileAtAddr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hProcess: THandle; ImageBase: Pointer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(Result, MAX_PATH); SetLength(Result, GetMappedFileName(hProcess, ImageBase, @Result[<span class="hljs-number"><span class="hljs-number">1</span></span>], MAX_PATH)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  And now let's try to see what is being loaded into a regular console application: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MBI: TMemoryBasicInformation; dwLength: NativeUInt; Address: PByte; IsPEImage64: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Address := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; dwLength := SizeOf(TMemoryBasicInformation); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> VirtualQuery(Address, MBI, dwLength) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CheckPEImage(GetCurrentProcess, MBI.BaseAddress, IsPEImage64) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(IntToHex(NativeUInt(MBI.BaseAddress), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">': '</span></span>, GetFileAtAddr(GetCurrentProcess, MBI.BaseAddress)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsPEImage64 <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">' (x64)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">' (x32)'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Inc(Address, MBI.RegionSize); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  It turns out this picture: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/1ca/cd4/36d/1cacd436dcf75fac7d1bacfbd959c626.png"></div><br>  64-bit library in a 32-bit application?  Yes, easier simple :) <br><br>  My application is 32-bit, Windows 7 x64 operating system.  Judging by what is shown in the picture, four 64-bit libraries live and work in our 32-bit process, however, nothing unusual here is the so-called Wow64 ( <a href="http://modernlib.ru/books/russinovich_mark/1vnutrennee_ustroystvo_windows_gl_14/read_14/">Win32 emulation on 64-bit Windows</a> ). <br><br>  But at once it becomes clear where 64-bit analogs of 32-bit streams and heaps come from. <br><br>  Now, in a good way, you need to get the addresses of sections of each PE file so that you can show them more clearly.  All sections are aligned to the address of the beginning of the page and do not overlap with each other. <br><br>  Let's do this with this code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInfoFromImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FileName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; ImageBase: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ImageInfo: TLoadedImage; ImageSectionHeader: PImageSectionHeader; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MapAndLoad(PAnsiChar(AnsiString(FileName)), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, @ImageInfo, True, True) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ImageSectionHeader := ImageInfo.Sections; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Integer(ImageInfo.NumberOfSections) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>( IntToHex((NativeUInt(ImageBase) + ImageSectionHeader^.VirtualAddress), <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">': '</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(PAnsiChar(@ImageSectionHeader^.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsExecute(ImageSectionHeader^.Characteristics) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(<span class="hljs-string"><span class="hljs-string">' Execute'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsWrite(ImageSectionHeader^.Characteristics) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(<span class="hljs-string"><span class="hljs-string">' Writable'</span></span>); Writeln; Inc(ImageSectionHeader); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> UnMapAndLoad(@ImageInfo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Writeln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  It uses the call to the MapAndLoad function, which, in addition to loading the file and checking its headers, also performs section alignment by calling NtMapViewOfSection. <br><br>  For its own process, of course, the call to this function is redundant, since  The required PE file is already loaded into the address space of the process, but since  we need a more universal code to work with other processes, then we use this approach. <br><br>  MapAndLoad is also good because it allows 64-bit processes to load 32-bit PE files (although this does not work for 32-bit processes), and in the future this feature will come in handy. <br><br>  The essence of the code is as follows: after running MapAndLoad, we will have in our hands a filled TLoadedImage structure, the Sections parameter of which points to an array of TImageSectionHeader structures.  Each of these structures has a VirtualAddress field, which is an offset from the library loading address.  By adding the value of this field to the library hInstance, we get the address of the section. <br><br>  The functions IsExecute and IsWrite check the characteristics of the section and return True if the section contains executable code (IsExecute) or data that can be modified (IsWrite).  They look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> IMAGE_SCN_CNT_CODE) = IMAGE_SCN_CNT_CODE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> IMAGE_SCN_MEM_EXECUTE) = IMAGE_SCN_MEM_EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> IMAGE_SCN_CNT_UNINITIALIZED_DATA) = IMAGE_SCN_CNT_UNINITIALIZED_DATA <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> IMAGE_SCN_MEM_WRITE) = IMAGE_SCN_MEM_WRITE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  As a result of this code, we will see the following: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/54d/4b6/afe/54d4b6afebc0f1d62cda12194cecbb5e.png"></div><br>  True, with this code there is another small nuance. <br>  As you can see in the previous picture, the GetMappedFileName function returns the path to the downloaded file in the following form: "\ Device \ HarddiskVolume2 \ Windows \ System32 \ wow64cpu.dll", and the MapAndLoad function requires a normalized path like "C: \ Windows \ System32 \ wow64cpu. dll ". <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following code is responsible for bringing the path to the usual view: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NormalizePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OBJ_CASE_INSENSITIVE = $<span class="hljs-number"><span class="hljs-number">00000040</span></span>; STATUS_SUCCESS = <span class="hljs-number"><span class="hljs-number">0</span></span>; FILE_SYNCHRONOUS_IO_NONALERT = $<span class="hljs-number"><span class="hljs-number">00000020</span></span>; FILE_READ_DATA = <span class="hljs-number"><span class="hljs-number">1</span></span>; ObjectNameInformation = <span class="hljs-number"><span class="hljs-number">1</span></span>; DriveNameSize = <span class="hljs-number"><span class="hljs-number">4</span></span>; VolumeCount = <span class="hljs-number"><span class="hljs-number">26</span></span>; DriveTotalSize = DriveNameSize * VolumeCount; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> US: UNICODE_STRING; OA: OBJECT_ATTRIBUTES; IO: IO_STATUS_BLOCK; hFile: THandle; NTSTAT, dwReturn: DWORD; ObjectNameInfo: TOBJECT_NAME_INFORMATION; Buff, Volume: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; I, Count, dwQueryLength: Integer; lpQuery: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..MAX_PATH - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Char; AnsiResult: AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Value; <span class="hljs-comment"><span class="hljs-comment">//     ZwOpenFile RtlInitUnicodeString(@US, StringToOleStr(Value)); //   InitializeObjectAttributes FillChar(OA, SizeOf(OBJECT_ATTRIBUTES), #0); OA.Length := SizeOf(OBJECT_ATTRIBUTES); OA.ObjectName := @US; OA.Attributes := OBJ_CASE_INSENSITIVE; //  ZwOpenFile   ,     //    , : // \SystemRoot\System32\ntdll.dll // \??\C:\Windows\System32\ntdll.dll // \Device\HarddiskVolume1\WINDOWS\system32\ntdll.dll //        NTSTAT := ZwOpenFile(@hFile, FILE_READ_DATA or SYNCHRONIZE, @OA, @IO, FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT); if NTSTAT = STATUS_SUCCESS then try //  ,      NTSTAT := NtQueryObject(hFile, ObjectNameInformation, @ObjectNameInfo, MAX_PATH * 2, @dwReturn); if NTSTAT = STATUS_SUCCESS then begin SetLength(AnsiResult, MAX_PATH); WideCharToMultiByte(CP_ACP, 0, @ObjectNameInfo.Name.Buffer[ObjectNameInfo.Name.MaximumLength - ObjectNameInfo.Name.Length {$IFDEF WIN64} + 4{$ENDIF}], ObjectNameInfo.Name.Length, @AnsiResult[1], MAX_PATH, nil, nil); Result := string(PAnsiChar(AnsiResult)); //     ZwOpenFile  //    \Device\HarddiskVolume\- //        SetLength(Buff, DriveTotalSize); Count := GetLogicalDriveStrings(DriveTotalSize, @Buff[1]) div DriveNameSize; for I := 0 to Count - 1 do begin Volume := PChar(@Buff[(I * DriveNameSize) + 1]); Volume[3] := #0; //         //     QueryDosDevice(PChar(Volume), @lpQuery[0], MAX_PATH); dwQueryLength := Length(string(lpQuery)); if Copy(Result, 1, dwQueryLength) = string(lpQuery) then begin Volume[3] := '\'; if lpQuery[dwQueryLength - 1] &lt;&gt; '\' then Inc(dwQueryLength); Delete(Result, 1, dwQueryLength); Result := Volume + Result; Break; end; end; end; finally ZwClose(hFile); end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is already quite an old code, constantly used by me to bring it to a normal path. </font><font style="vertical-align: inherit;">Its essence is that of the paths of the following types:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> \ SystemRoot \ System32 \ ntdll.dll </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> \ ?? \ C: \ Windows \ System32 \ ntdll.dll </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> \ Device \ HarddiskVolume1 \ WINDOWS \ system32 \ ntdll.dll </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... get fixed "\ Device \ HarddiskVolume1 \ WINDOWS \ system32 \ ntdll.dll". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done by calling ZwOpenFile + NtQueryObject, after which all the disks in the system are simply searched and for each one QueryDosDevice is called, which returns a path in the same format. After that, the paths are compared and (if they match) the corresponding disk label is substituted to the transmitted path. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is the lyrics. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To be completely satisfied with yourself, it is advisable to output the same file directory as the PE file so that it is immediately clear where to look, for example, the import table, where UNWIND is sitting, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done in fairly simple code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumDirectoryes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImageBase: Pointer; ImageInfo: TLoadedImage; AddrStart, AddrEnd: NativeUInt)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DirectoryStr: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">14</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = (<span class="hljs-string"><span class="hljs-string">'export'</span></span>, <span class="hljs-string"><span class="hljs-string">'import'</span></span>, <span class="hljs-string"><span class="hljs-string">'resource'</span></span>, <span class="hljs-string"><span class="hljs-string">'exception'</span></span>, <span class="hljs-string"><span class="hljs-string">'security'</span></span>, <span class="hljs-string"><span class="hljs-string">'basereloc'</span></span>, <span class="hljs-string"><span class="hljs-string">'debug'</span></span>, <span class="hljs-string"><span class="hljs-string">'copyright'</span></span>, <span class="hljs-string"><span class="hljs-string">'globalptr'</span></span>, <span class="hljs-string"><span class="hljs-string">'tls'</span></span>, <span class="hljs-string"><span class="hljs-string">'load_config'</span></span>, <span class="hljs-string"><span class="hljs-string">'bound_import'</span></span>, <span class="hljs-string"><span class="hljs-string">'iat'</span></span>, <span class="hljs-string"><span class="hljs-string">'delay_import'</span></span>, <span class="hljs-string"><span class="hljs-string">'com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; dwDirSize: DWORD; DirAddr: Pointer; ReadlDirAddr: NativeUInt; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DirAddr := ImageDirectoryEntryToData(ImageInfo.MappedAddress, True, I, dwDirSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DirAddr = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; ReadlDirAddr := NativeUint(ImageBase) + NativeUint(DirAddr) - NativeUint(ImageInfo.MappedAddress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReadlDirAddr &gt;= AddrStart) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (ReadlDirAddr &lt; AddrEnd) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln( IntToHex(ReadlDirAddr, <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-string"><span class="hljs-string">': directory "'</span></span>, DirectoryStr[I], <span class="hljs-string"><span class="hljs-string">'"'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having the TLoadedImage structure in hand, we can simply simply call the ImageDirectoryEntryToData function to get its address, although it will be tied to the address where the PE file is displayed. To translate it into real, you need to subtract the address from which the image is displayed from the current address, thus obtaining the offset from the beginning of the file, and add it to the ImageBase library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, you get this picture:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/3d0/e35/98c/3d0e3598c05886055d5be943c9f82b28.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is immediately obvious that, for example, the import / export / deferred import directories, etc., are located in the ".text" section of the msctf.dll library. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resource directory sits in the ".rsrc" section, and relocs are also where they should be, but the "bound_import" directory falls out of the scheme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, indeed, this directory is not located directly in any of the sections of the library, such is its peculiarity. It usually goes right behind the PE header (although it can sometimes occur between sections). This directory is used to provide the mechanism of "bound imports", which is found mainly only in programs and libraries running in the OS.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its essence is that all the addresses of imported functions are stitched into an executable file at the compilation stage, thus it is not necessary to perform unnecessary gestures, running around the normal import table in search of a function address. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the overhead is also relevant, because as soon as any of the libraries declared in the bound import section changes, the application must be recompiled.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Process Environment Block (PEB) + KUSER_SHARED_DATA </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having data about threads, heaps and executable files, you can make a small utility right now that will display information in a readable form, but what else can you add? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At a minimum, it is highly desirable to receive and display information from the process environment block. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be accessed by calling the NtQueryInformationProcess function with the ProcessBasicInformation flag (a constant equal to zero). In this case, the hands will have a PROCESS_BASIC_INFORMATION structure, in which the PebBaseAddress field will contain the address PEB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this will be relevant only if the bits of the processes (the requester and of which the requested information) match. If we call this function from a 64-bit application as applied to a 32-bit one, we get the address of a 64-bit PEB, rather than a native 32-bit one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get access to Wow64PEB from a 64-bit application (let's call it that way), you need to call the NtQueryInformationProcess function with the ProcessWow64Information parameter (constant 26) and the size of the buffer equal to SizeOf (ULONG_PTR). In this case, instead of the PROCESS_BASIC_INFORMATION structure, the function will return a pointer to a 32-bit PEB, from which we will read out the information we need by means of ReadProcessMemory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is PEB?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roughly speaking, this is not a strongly documented structure, most of which is intended for storing data used directly by the system. But this does not mean that it is not interesting to the developer of a conventional application. In particular, this structure contains a number of interesting fields, such as: the BeingDebugged flag, indicating whether the debugger is connected to the process; a pointer to PEB_LDR_DATA, which contains information about the modules loaded in the process; and a lot of the rest is quite useful information for a programmer, especially for someone who knows how to use it for their own purposes :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This structure looks like this (declaration for Windows7 x86 / 64):</font></font><br><br><pre> <code class="delphi hljs"> PPEB = ^TPEB; TPEB = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> InheritedAddressSpace: BOOLEAN; ReadImageFileExecOptions: BOOLEAN; BeingDebugged: BOOLEAN; BitField: BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">{ BOOLEAN ImageUsesLargePages : 1; BOOLEAN IsProtectedProcess : 1; BOOLEAN IsLegacyProcess : 1; BOOLEAN IsImageDynamicallyRelocated : 1; BOOLEAN SkipPatchingUser32Forwarders : 1; BOOLEAN IsPackagedProcess : 1; BOOLEAN IsAppContainer : 1; BOOLEAN SpareBits : 1; }</span></span> Mutant: HANDLE; ImageBaseAddress: PVOID; LoaderData: PVOID; ProcessParameters: PRTL_USER_PROCESS_PARAMETERS; SubSystemData: PVOID; ProcessHeap: PVOID; FastPebLock: PRTLCriticalSection; AtlThunkSListPtr: PVOID; IFEOKey: PVOID; EnvironmentUpdateCount: ULONG; UserSharedInfoPtr: PVOID; SystemReserved: ULONG; AtlThunkSListPtr32: ULONG; ApiSetMap: PVOID; TlsExpansionCounter: ULONG; TlsBitmap: PVOID; TlsBitmapBits: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG; ReadOnlySharedMemoryBase: PVOID; HotpatchInformation: PVOID; ReadOnlyStaticServerData: PPVOID; AnsiCodePageData: PVOID; OemCodePageData: PVOID; UnicodeCaseTableData: PVOID; KeNumberOfProcessors: ULONG; NtGlobalFlag: ULONG; CriticalSectionTimeout: LARGE_INTEGER; HeapSegmentReserve: SIZE_T; HeapSegmentCommit: SIZE_T; HeapDeCommitTotalFreeThreshold: SIZE_T; HeapDeCommitFreeBlockThreshold: SIZE_T; NumberOfHeaps: ULONG; MaximumNumberOfHeaps: ULONG; ProcessHeaps: PPVOID; GdiSharedHandleTable: PVOID; ProcessStarterHelper: PVOID; GdiDCAttributeList: ULONG; LoaderLock: PRTLCriticalSection; NtMajorVersion: ULONG; NtMinorVersion: ULONG; NtBuildNumber: USHORT; NtCSDVersion: USHORT; PlatformId: ULONG; Subsystem: ULONG; MajorSubsystemVersion: ULONG; MinorSubsystemVersion: ULONG; AffinityMask: ULONG_PTR; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF WIN32}</span></span> GdiHandleBuffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">33</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG; <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> GdiHandleBuffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">59</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> PostProcessInitRoutine: PVOID; TlsExpansionBitmap: PVOID; TlsExpansionBitmapBits: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">31</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG; SessionId: ULONG; AppCompatFlags: ULARGE_INTEGER; AppCompatFlagsUser: ULARGE_INTEGER; pShimData: PVOID; AppCompatInfo: PVOID; CSDVersion: UNICODE_STRING; ActivationContextData: PVOID; ProcessAssemblyStorageMap: PVOID; SystemDefaultActivationContextData: PVOID; SystemAssemblyStorageMap: PVOID; MinimumStackCommit: SIZE_T; FlsCallback: PPVOID; FlsListHead: LIST_ENTRY; FlsBitmap: PVOID; FlsBitmapBits: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..FLS_MAXIMUM_AVAILABLE <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> SizeOf(ULONG) * <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG; FlsHighIndex: ULONG; WerRegistrationData: PVOID; WerShipAssertPtr: PVOID; pContextData: PVOID; pImageHeaderHash: PVOID; TracingFlags: ULONG; <span class="hljs-comment"><span class="hljs-comment">{ ULONG HeapTracingEnabled : 1; ULONG CritSecTracingEnabled : 1; ULONG LibLoaderTracingEnabled : 1; ULONG SpareTracingBits : 29; }</span></span> CsrServerReadOnlySharedMemoryBase: ULONGLONG; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, compare this structure with the one that is </font></font><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v%3Dvs.85).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">officially available in MSDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Window 2000 / XP / 2003 there will be small changes, but not very critical ones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not paint each field, those who work with PEB and so know? </font><font style="vertical-align: inherit;">what exactly they need, but in some fields I will focus your attention.</font></font><br><br>  So: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The BeingDebugged field - </font></font><a href="http://habrahabr.ru/post/178183/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the third part of the article about the debugger,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I showed one of the ways to bypass this detection by means of an application memory patch. </font><font style="vertical-align: inherit;">The essence of the approach was just to determine the address of the PEB and change the value of the BeingDebugged parameter to zero, after which the IsDebuggerPresent function, which is oriented on this field, began to return False, saying that? </font><font style="vertical-align: inherit;">that she did not find the debugger.</font></font></li><li>  ImageBaseAddress ‚Äî   hInstance  (      ImageBase  PE ). </li><li> LoaderData ‚Äî      ,        ,     , ,  ,        .       ,           :) </li><li> ProcessParameters ‚Äî    ParamStr/GetCurrentDir  .. ?  .      . </li><li>       ,   ,      CSDVersion. , ,  NtMajorVersion/NtMinorVersion/NtBuildNumber    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, and so on - you can continue for a long time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of these fields occupy their pages in the address space of the process. For example, ProcessParameters usually sits in one of the heaps created by the loader, environment variables are also located somewhere in that area. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we want to visualize all of this (and I am leading to this), we must have this data on hand in order to have something to display in the final application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agree, it is much more pleasant to have on your hands, instead of a certain block of binary data, something like this:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/074/f6e/f94/074f6ef947c187f786cea3ed3b6abf0b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is also KUSER_SHARED_DATA. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is also the structure used by the system, and you constantly encounter it by calling the same GetTickCount or IsProcessorFeaturePresent. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, NtSystemRoot sits exactly in it, and, again, why list everything, it's easier to see:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/b4c/e0c/033/b4ce0c033e1f51c903272fde21855dd6.png"></div><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Want to know what process is active without calling GetForegroundWindow ‚Äî read ConsoleSessionForegroundProcessId. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Are you trying to slip the left version of Win to turn off part of the security system that was not designed for the previous OS? </font><font style="vertical-align: inherit;">Read current values ‚Äã‚Äãfrom the NtMajorVersion / NtMinorVersion fields ...</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, perhaps, here we will stop for now ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. TRegionData </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the theoretical part ended and it was time to put it all into practice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, you need to decide how to store information about the regions. </font><font style="vertical-align: inherit;">Preparing for the article, I wrote a set of classes allocated to the common namespace "MemoryMap", you can find them in </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the demo examples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMPORTANT!!! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This set of classes was developed taking into account the innovations that are present in the Delphi XE4, under older versions of Delphi, its performance has not been tested and is not guaranteed.</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The information for each region will be stored in the TRegionData class, implemented in the ‚ÄúMemoryMap.RegionData.pas‚Äù module. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks something like this (in the process of developing a project, the class declaration may change).</font></font><br><br><pre> <code class="delphi hljs"> TRegionData = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FParent: TRegionData; FRegionType: TRegionType; FMBI: TMemoryBasicInformation; FDetails: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FRegionVisible: Boolean; FHiddenRegionCount: Integer; FTotalRegionSize: NativeUInt; FHeap: THeapData; FThread: TThreadData; FPEBData: TSystemData; FSection: TSection; FContains: TList; FDirectories: TList; FShared: Boolean; FSharedCount: Integer; FFiltered: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> RegionType: TRegionType <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FRegionType; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> MBI: TMemoryBasicInformation <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FMBI; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Details: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FDetails; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> RegionVisible: Boolean <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FRegionVisible; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> HiddenRegionCount: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FHiddenRegionCount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Parent: TRegionData <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FParent; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> TotalRegionSize: NativeUInt <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FTotalRegionSize; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Heap: THeapData <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FHeap; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Thread: TThreadData <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FThread; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> SystemData: TSystemData <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FPEBData; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Section: TSection <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FSection; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Directory: TList <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FDirectories; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Contains: TList <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FContains; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In order: <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each region, as a rule, stores in itself the data of one type. </font></font><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for heaps, stream stacks, PE files, its own page region is allocated. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The RegionType property is responsible for storing the region type. </font><font style="vertical-align: inherit;">This is an enumeration type, declared as follows:</font></font><br><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//   TRegionType = ( rtDefault, rtHeap, //     rtThread, //      TEB rtSystem, //     (PEB/KUSER_SHARED_DATA  ..) rtExecutableImage //     PE  );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The region parameters obtained by calling VirtualQueryEx are stored in the MBI field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A brief description of the region is stored in Details. Anything can be stored in it, for example, the path to the displayed PE file, if present, a string description of the stream ID, etc ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following three parameters are used to organize the tree structure. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the regions is the root node (root), the rest are subsidiaries. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The RegionVisible flag indicates whether a region is a root node. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The HiddenRegionCount property contains the number of subregions (the AllocationBase of which is equal to the BaseAddress of the root). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the parameter Parent stores a link to the root.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The work was not entirely optimal, it would be possible to organize a classic tree, but at the current time there is simply no time to redo it, maybe someday later :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TotalRegionSize contains the total size of all subregions, including the root one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In case the region contains a heap, the data on its first element is placed in the Heap parameter, which is the following structure:</font></font><br><br><pre> <code class="delphi hljs"> THeapEntry = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Address: ULONG_PTR; Size: SIZE_T; Flags: ULONG; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; THeapData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ID: DWORD; Wow64: Boolean; Entry: THeapEntry; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The remaining heap items located within the region are placed in the Contains field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the Contains field may contain data of many types.</font></font><br><br><pre> <code class="delphi hljs"> TContainItemType = (itHeapBlock, itThreadData, itStackFrame, itSEHFrame, itSystem); TContainItem = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ItemType: TContainItemType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hash</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: (Heap: THeapData); <span class="hljs-number"><span class="hljs-number">1</span></span>: (ThreadData: TThreadData); <span class="hljs-number"><span class="hljs-number">2</span></span>: (StackFrame: TThreadStackEntry); <span class="hljs-number"><span class="hljs-number">3</span></span>: (SEH: TSEHEntry); <span class="hljs-number"><span class="hljs-number">4</span></span>: (System: TSystemData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next comes the Thread field, which stores information about the stream that the region uses to store its own data. </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TThreadInfo = (tiNoData, tiExceptionList, tiStackBase, tiStackLimit, tiTEB, tiThreadProc); <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TThreadData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Flag: TThreadInfo; ThreadID: Integer; Address: Pointer; Wow64: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are a lot of stream data within a region (for example, a list of SEH frames or a CallStack stream), they are also placed in the Contains field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data from system structures (fields of PEB / TEB structures, etc.) are placed in the SystemData field, which is an entry from the data address and their descriptions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also this data can be placed in the Contains field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the region belongs to one of the sections of the PE file, the section data is placed in the Section parameter. </font><font style="vertical-align: inherit;">Well, the list of file directories is located in the Directory field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That somehow so briefly. </font><font style="vertical-align: inherit;">Now, to present the data on the process memory card, we need to obtain a list of regions, create an instance of the TRegionData class for each of them, and initialize the fields of the created object with the required information.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The TMemoryMap class is responsible for this ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. TMemoryMap </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This class is implemented in the "MemoryMap.Core.pas" module. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its task is literally reduced to three main stages:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retrieving a list of all selected regions in the memory of the specified application, data on threads / heaps / loaded images, etc. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating a TRegionData list and filling its fields with the received information. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saving / loading data, filtering data. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In practice, everything looks more complicated. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic procedure for collecting information looks like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMemoryMap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitFromProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PID: Cardinal; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ProcessName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ProcessLock: TProcessLockHandleList; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; FRegions.Clear; FModules.Clear; FFilter := fiNone; ProcessLock := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     FProcess := OpenProcess( PROCESS_QUERY_INFORMATION or PROCESS_VM_READ, False, PID); if FProcess = 0 then RaiseLastOSError; try FPID := PID; FProcessName := ProcessName; //    FProcess64 := False; {$IFDEF WIN64} if not IsWow64(FProcess) then FProcess64 := True; {$ELSE} //    32 ,    64- //   if Is64OS and not IsWow64(FProcess) then raise Exception.Create('Can''t scan process.'); {$ENDIF} //     if SuspendProcessBeforeScan then ProcessLock := SuspendProcess(PID); try FSymbols := TSymbols.Create(FProcess); try FPEImage := TPEImage.Create; try FWorkset := TWorkset.Create(FProcess);; try //        GetAllRegions; finally FWorkset.Free; end; {$IFDEF WIN64} //       32   AddWow64HeapsData; {$ENDIF} //     AddThreadsData; //     AddHeapsData; //    Process Environment Block AddPEBData; //     PE  AddImagesData; finally FPEImage.Free; end; finally FSymbols.Free; end; finally if SuspendProcessBeforeScan then ResumeProcess(ProcessLock); end; //  SortAllContainsBlocks; //      CalcTotal; //    UpdateRegionFilters; finally CloseHandle(FProcess); end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I gave the approximate code of the GetAllRegions / AddThreadsData / AddHeapsData and AddImagesData procedures in the first four chapters and I will not focus on it, but it is advisable to deal with the rest. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The very first step after opening the process is determining the bit depth of the process. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is necessary for the reason that if the bits of the processes (current and for which we receive information) do not match, some additional actions need to be taken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The general scheme is as follows:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A 32-bit process can receive data on a 32-bit under a 32-bit OS in full. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A 64-bit process can receive data on a 64-bit one in full. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A 32-bit process </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAY NOT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> get 64-bit data.</font></font></li><li> 32-      32-  64- , <b> </b> . </li><li> 64-      32-, <b> </b> . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If everything is clear with the first two points, then the other three will be discussed in more detail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason that the 32-bit process will not be able to get data on the 64-bit is simple: the pointer size will not allow, plus ReadProcessMemory will periodically generate an ERROR_PARTIAL_COPY error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But getting data from a 32-bit process in a 64-bit OS is much more cunning. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said earlier, in a 32-bit application, four 64-bit libraries are loaded that create their heaps / streams. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we get a list of heaps and streams from a 32-bit application, we will only see data related to 32 bits, data on 64-bit analogues cannot be obtained.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same will happen in the case of requesting data on a 32-bit process from a 64-bit one, only data related to 64 bits will be returned. </font><font style="vertical-align: inherit;">Although in this case there is an option to get them in part. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, access to 32-bit PEB is made by calling such a function:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ProcessWow64Information = <span class="hljs-number"><span class="hljs-number">26</span></span>; ... NtQueryInformationProcess(FProcess, ProcessWow64Information, @FPebWow64BaseAddress, SizeOf(ULONG_PTR), @ReturnLength)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to 32-bit TEB can be obtained by reading the address from 64-bit TEB, which is stored in the NtTIB.ExceptionList parameter. </font></font><br><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//  64  TEB  TIB.ExceptionList    Wow64TEB if not ReadProcessMemory(hProcess, TIB.ExceptionList, @WOW64_NT_TIB, SizeOf(TWOW64_NT_TIB), lpNumberOfBytesRead) then Exit;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can get the context of a 32-bit stream for CallStack promotion like this: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ThreadWow64Context = <span class="hljs-number"><span class="hljs-number">29</span></span>; ... ThreadContext^.ContextFlags := CONTEXT_FULL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NtQueryInformationThread(hThread, ThreadWow64Context, ThreadContext, SizeOf(TWow64Context), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) &lt;&gt; STATUS_SUCCESS <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or by calling the Wow64GetThreadContext function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But I don‚Äôt know how to get data about 32-bit heaps from a 64-bit process in a legal way. The only option that I use now is to send a command to a 32-bit process, which collects data on 32-bit heaps and gives them back to the 64-bit one (the handler in the AddWow64HeapsData function does about that). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when we have figured out the process bit definition and why we need it, let's go further, namely, the SuspendProcess function call.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In an amicable way, this is only necessary so that the data in the remote process does not change to irrelevant at the time of their reading. </font><font style="vertical-align: inherit;">However, I usually use this set of classes in two cases, for my own application or for an application under debugger. </font><font style="vertical-align: inherit;">In both cases, it is not necessary to freeze the threads, but if some third-party application is being analyzed, then why not? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After freezing the remote process, three auxiliary classes are created.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TSymbols - I'll talk about him in the next chapter. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPEImage - this class contains methods that allow you to get information about the PE file, described in the fourth chapter. </font><font style="vertical-align: inherit;">Made exclusively for convenience.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TWorkset is another auxiliary class whose task is to obtain information about shared memory. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, TWorkset stores a list of structures of the form: </font></font><br><br><pre> <code class="delphi hljs"> TShareInfo = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Shared: Boolean; SharedCount: Byte; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These structures are stored in the dictionary and each is associated with a specific page address. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters are simple:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shared - is the page public? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SharedCount - how many links are on the page </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This data is obtained in the following way, in which everything comes down to calling the QueryWorkingSet function: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWorkset</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitWorksetData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hProcess: THandle)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF WIN64}</span></span> AddrMask = $FFFFFFFFFFFFF000; <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> AddrMask = $FFFFF000; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> SharedBitMask = $<span class="hljs-number"><span class="hljs-number">100</span></span>; SharedCountMask = $E0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSharedCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: ULONG_PTR)</span></span></span><span class="hljs-function">:</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> SharedCountMask) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WorksetBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ULONG_PTR; I: Integer; ShareInfo: TShareInfo; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(WorksetBuff, $<span class="hljs-number"><span class="hljs-number">400000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> QueryWorkingSet(hProcess, @WorksetBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], Length(WorksetBuff) * SizeOf(ULONG_PTR)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> SetLength(WorksetBuff, WorksetBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> WorksetBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShareInfo.Shared := WorksetBuff[I] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> SharedBitMask &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ShareInfo.SharedCount := GetSharedCount(WorksetBuff[I]); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> FData.Add(Pointer(WorksetBuff[I] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> AddrMask), ShareInfo); <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> E: EListError <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function returns an array of ULONG_PTR, each element of which stores data as follows: the first five bits store the security attributes of the page; </font><font style="vertical-align: inherit;">the next three bits are the number of processes by which this page is available; </font><font style="vertical-align: inherit;">another bit indicates the general availability of the page; </font><font style="vertical-align: inherit;">well, then comes the address of the page itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More details can be found here: </font></font><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684902(v%3Dvs.85).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PSAPI_WORKING_SET_BLOCK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this is just an information class, no more, no less. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, back to our code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next steps are:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetAllRegions - analogue of the code from the first chapter. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddThreadsData - analogue of the code from the second chapter. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddHeapsData - analogue of the code from the third chapter. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddPEBData - output data on the structure of the fifth chapter. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddImagesData - analogue code from the fourth chapter. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, I have already told all the interesting (well, almost) :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The remaining steps are not interesting, except for the call to UpdateRegionFilters. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It performs a utilitarian function, namely, it excludes regions from the list that are currently unnecessary (well, for example, removes regions with unallocated memory, etc.). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This procedure will be invoked continuously when the filter is changed through the Filter property. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, all this you can, if you want to see from the code of the class itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with him is quite simple:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AMemoryMap: TMemoryMap; M: TMemoryStream; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//   AMemoryMap := TMemoryMap.Create; try //     AMemoryMap.InitFromProcess(GetCurrentProcessId, ''); //  , AMemoryMap.SaveToStream(M); //           finally AMemoryMap.Free; end; //     -,      M.Position := 0; //   AMemoryMap := TMemoryMap.Create; try //   AMemoryMap.LoadFromStream(M); //     AMemoryMap.Filter := fiNone; //   //       AMemoryMap.ShowEmpty := True; //    for I := 0 to AMemoryMap.Count - 1 do Writeln(NativeUInt(AMemoryMap[I].MBI.BaseAddress)); finally AMemoryMap.Free; end; finally M.Free; end; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; Readln; end.</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As they say, he wrote for himself, therefore, working with this class is easy :) </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. TSymbols - working with characters </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of this class is to obtain more detailed information about the address in the process. </font><font style="vertical-align: inherit;">Well, for example, in the second chapter we received the CallStack flow (or handlers of SEH frames) and these were just some kind of addresses. </font><font style="vertical-align: inherit;">But it‚Äôs much more interesting to see something like this image instead of dry numbers:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/e34/b7d/c32/e34b7dc3242438be28250b4521296663.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done very simply - just call the function SymGetSymFromAddr, but there are a few nuances. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's first look at the code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSymbols</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDescriptionAtAddr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Address, BaseAddress: ULONG_PTR; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ModuleName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BuffSize = $<span class="hljs-number"><span class="hljs-number">7</span></span>FF; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF WIN64}</span></span> SizeOfStruct = SizeOf(TImagehlpSymbol64); MaxNameLength = BuffSize - SizeOfStruct; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Symbol: PImagehlpSymbol64; Displacement: DWORD64; <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> SizeOfStruct = SizeOf(TImagehlpSymbol); MaxNameLength = BuffSize - SizeOfStruct; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Symbol: PImagehlpSymbol; Displacement: DWORD; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FInited <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; GetMem(Symbol, BuffSize); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Symbol^.SizeOfStruct := SizeOfStruct; Symbol^.MaxNameLength := MaxNameLength; Symbol^.Size := <span class="hljs-number"><span class="hljs-number">0</span></span>; SymLoadModule(FProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>, PAnsiChar(AnsiString(ModuleName)), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, BaseAddress, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SymGetSymFromAddr(FProcess, Address, @Displacement, Symbol) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(PAnsiChar(@(Symbol^).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + <span class="hljs-string"><span class="hljs-string">' + 0x'</span></span> + IntToHex(Displacement, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//        SymLoadModule(FProcess, 0, PAnsiChar(AnsiString(ModuleName)), nil, BaseAddress, 0); if SymGetSymFromAddr(FProcess, Address, @Displacement, Symbol) then Result := string(PAnsiChar(@(Symbol^).Name[0])) + ' + 0x' + IntToHex(Displacement, 4); end; finally SymUnloadModule(FProcess, BaseAddress); end; finally FreeMem(Symbol); end; if Result = '' then Result := ExtractFileName(ModuleName) + ' + 0x' + IntToHex(Address - BaseAddress, 1); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To correctly obtain the description of the name of the function that owns the address, you need to know the path to the library that owns the function, or the address to which this library is loaded (the code uses both parameters). These parameters are required for the SymLoadModule function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second caveat is that the call to the SymGetSymFromAddr function can sometimes fail. The reason is not clear to me, but on the Internet they periodically describe this situation and how to solve it is to call the SymLoadModule function again without calling the SymUnloadModule. In such a strange behavior did not understand - but really helps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last of the nuances is that this function will return a valid description of the address only when this information is present (characters are loaded from an external file or they are included in the required module). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This information is not very important when debugging, but it simplifies it a little. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is, for example, the standard stack of the Chrome browser stream (CallStack + SEH frames):</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/66f/e23/966/66fe23966c7f628284944a21f0dfafdb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More useful information that symbols can provide is a list of library functions exported and their current addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the TSymbols class, this information is obtained by calling the GetExportFuncList procedure and looks like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SymEnumsymbolsCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SymbolName: LPSTR; SymbolAddress: ULONG_PTR; SymbolSize: ULONG; UserContext: Pointer)</span></span></span><span class="hljs-function">:</span></span> Bool; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> List: TStringList; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> List := UserContext; List.AddObject(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(SymbolName), Pointer(SymbolAddress)); Result := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSymbols</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetExportFuncList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ModuleName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; BaseAddress: ULONG_PTR; Value: TStringList)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SymLoadModule(FProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>, PAnsiChar(AnsiString(ModuleName)), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, BaseAddress, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> SymEnumerateSymbols(FProcess, BaseAddress, @SymEnumsymbolsCallback, Value) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SymLoadModule(FProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>, PAnsiChar(AnsiString(ModuleName)), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, BaseAddress, <span class="hljs-number"><span class="hljs-number">0</span></span>); SymEnumerateSymbols(FProcess, BaseAddress, @SymEnumsymbolsCallback, Value) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> SymUnloadModule(FProcess, BaseAddress); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It all comes down to calling SymEnumerateSymbols, which is passed the address of the callback function. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you call it, the SymbolName parameter will contain the name of the exported function, and SymbolAddress will contain its address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is quite enough to display the following label to the user:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/b22/b8c/882/b22b8c8825a7253da07af80d884a5fcd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In more detail the implementation of this class, including omitted calls SymSetOptions and SymInitialize, you can see in the module "MemoryMap.Symbols.pas". </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. ProcessMemoryMap </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, here we come to the final part of the article. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said earlier, I use the MemoryMap class set in two versions: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Integrating it into the output of EurekaLog by overlapping its OnAttachedFilesRequest handler, where I add the current process map that is relevant at the time of the exception, and dumps of all Private Regions (pages not associated with certain data with the MEM_PRIVATE flag) and thread stacks, plus some of the information from PEB. Usually this is enough to analyze the causes of the error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. I use it as an alternative tool for analyzing the application being debugged. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the second option, a separate utility was implemented, which works directly with the MemoryMap classes, plus adds some additional functionality.</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/aba/6d8/5a5/aba6d85a5483f480c65bd4d5102eeb26.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not describe its source code, I‚Äôll just go over a bit of functionality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the interface, it is almost one to one reminds VMMap. </font><font style="vertical-align: inherit;">However, this was originally planned, because such an interface is most convenient for analysis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the top is a list with general information by region, grouped by type, it is also a filter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, it represents the following functionality: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. View the contents of the memory at the specified address (Ctrl + Q).</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/c86/c9f/7d3/c86c9f7d31f7a0dfec05c190db8bd83a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This functionality, in principle, is present in the Delphi debugger in the CPU View window, but the features of this mode are much greater. </font><font style="vertical-align: inherit;">For example, in the case of viewing the PEB field, data will be displayed in a different form:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/bcc/a90/19e/bcca9019ec5478eef734de0892ee9007.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is how the process parameter block will look like: </font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/579/4cc/e22/5794cce22a5638afad720e93cf256821.png"></div><br>  Well, and so on.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In total, at this point, the utility can display mapped data in the following structures: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PEB - Process Environment Block (32/64) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TEB - Thread Environment Block (32/64) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> KUSER_SHARED_DATA </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE Header (IMAGE_DOS_HEADER / IMAGE_NT_HEADER / IMAGE_FILE_HEADER / IMAGE_OPTIONAL_HEADER (32/64) / IMAGE_DATA_DIRECTORY / IMAGE_SECTION_HEADERS) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Process Parameters (32/64) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This list is not final, periodically new structures will be added to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Search for data in the process memory (Ctrl + F):</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/d14/cd4/85f/d14cd485fbf8f7c66ccd971af0c61492.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This functionality in the Delphi debugger, unfortunately, is missing. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The search can be performed either by Ansi or by Unicode string, or simply by abstract HEX buffer. </font><font style="vertical-align: inherit;">When searching, you can specify the address of the beginning of the search, as well as a flag indicating the need to search in pages that are accessible only for reading. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result is displayed as a window with the memory dump shown above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Comparator of two memory cards. </font><font style="vertical-align: inherit;">Included in the settings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allows you to find differences between two memory cards and displays them as text.</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/260/07a/68a/26007a68a634790a227303ae671ffd5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only the maps themselves are compared, not the data. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if at some address 4 bytes have changed, this change will not be displayed. But in the event that the size of the region has changed, the heap has been deleted, the file has been downloaded / downloaded, etc. - all this will be displayed in the comparison results. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is possible to compare both the current map snapshot with the previously saved one, and when updating the snapshot using the F5 hot key. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Dump of memory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also missing in the Delphi debugger functionality. Allows you to save to disk the contents of the memory of the specified region or data from the specified address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Output of all available exported functions from all libraries loaded in the analyzed process (Ctrl + E).</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/e5b/761/7fb/e5b7617fbc4aafcd1a614fbcf0d3f346.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As well as a quick search for a function by its name or address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far, the current functionality is enough for me personally, and I haven‚Äôt added a new one, but in the future this utility will be developed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessMemoryMap is an open source project. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Her latest stable release is always available at the link: </font></font><a href="http://rouse.drkb.ru/winapi.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://rouse.drkb.ru/winapi.php#pmm2</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GitHub repository with the latest code changes can be found here: </font></font><a href="https://github.com/AlexanderBagel/ProcessMemoryMap"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/AlexanderBagel/ProcessMemoryMap</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direct link to the source code : </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/AlexanderBagel/ProcessMemoryMap/archive/master.zip</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direct link to the latest build: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://rouse.drkb.ru/files/processmm_bin.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For self-assembly, you will need the installed package of components Virtual TreeView version 5 and higher: </font></font><a href="http://www.soft-gems.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.soft-gems.net/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The build is carried out using Delphi XE4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and higher in the ‚ÄúWin32 / Release‚Äù mode, and the 64-bit version of this utility will be automatically assembled and connected (as a resource). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under older versions of Delphi, the health of ProcessMemoryMap has not been tested.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. As a conclusion </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, I hope this material will be useful for you. I, of course, passed only at the very top, for if you disclose all the material in more detail, the volume of the article will increase enormously. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, here are some links where you can find out a little more information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Information on system structures of TEB / PEB, etc. can be found here: </font></font><br> <a href="http://processhacker.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://processhacker.sourceforge.net/ </font></font></a> <br> <a href="http://redplait.blogspot.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://redplait.blogspot.ru/ </font></font></a> <br> <a href="http://www.reactos.org/ru"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.reactos.org/ru</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Information about PE files: </font></font><br> <a href="http://msdn.microsoft.com/en-us/magazine/ms809762.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/ en-us / magazine / ms809762.aspx</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SEH Information: </font></font><br> <a href="http://msdn.microsoft.com/en-us/library/ms680657(v%3DVS.85).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://msdn.microsoft.com/en-us/library/ms680657(v=VS.85).aspx </font></font></a> <br> <a href="http://www.microsoft.com/msj/0197/exception/exception.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.microsoft.com/msj /0197/exception/exception.aspx </font></font></a> <br> <a href="http://qxov.narod.ru/articles/seh/seh.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://qxov.narod.ru/articles/seh/seh.html</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of all demo examples can be picked up </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at this link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Many thanks to the </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forum </font></font><a href="http://www.delphimaster.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúMasters of Delphi‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for their repeated assistance in the preparation of the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personal thanks for reading the material to Dmitry aka "Ptiburdukov's brother", Andrey Vasilyev aka "Inovet", and also to Sergey aka "Cartman".</font></font><br><br>  Good luck. </div><p>Source: <a href="https://habr.com/ru/post/202242/">https://habr.com/ru/post/202242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202232/index.html">Communication on the Internet: before and now</a></li>
<li><a href="../202234/index.html">Event Manager with Template Filtering</a></li>
<li><a href="../202236/index.html">Raspberry Pi - HD media player, HDTV player</a></li>
<li><a href="../202238/index.html">[POLL] How do you feel about the selection of Q & A in a separate project?</a></li>
<li><a href="../202240/index.html">Do you also have 50% of marketing shares playing a minus in sales?</a></li>
<li><a href="../202246/index.html">WPCC 3.5 - plugin for creating calculators in WordPress</a></li>
<li><a href="../202248/index.html">Off the coast of Northern Ireland, a power station has been launched that receives energy from sea currents.</a></li>
<li><a href="../202252/index.html">aIs Tips</a></li>
<li><a href="../202254/index.html">Google BBS Terminal - how google could look like in the 80s</a></li>
<li><a href="../202258/index.html">How to invest $ 100,000 in your own karma (part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>