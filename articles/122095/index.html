<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go Web Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is based on codelab from Go, but is not limited to it. In the course of reading the article, it will be possible to learn about Go data st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go Web Development</h1><div class="post__text post__text-html js-mediator-article">  The article is based on <a href="http://golang.org/doc/codelab/wiki/">codelab</a> from Go, but is not limited to it.  In the course of reading the article, it will be possible to learn about Go data structures, dynamic arrays, using http, template, regexp libraries to create a web application, templating and filtering input, respectively. <br><img src="http://golang.org/doc/logo.png" alt="image"><br>  To understand the article, you need to be able to program a little bit, not be afraid of the words unix and the web.  The basics of the language will be described in the article. <br><a name="habracut"></a><br><h4>  Go installation </h4><br>  So, the first thing that is needed to work with Go is Linux, FreeBSD (OS X), although <a href="http://code.google.com/p/gomingw/downloads/list">MinGW</a> for Windows also comes down. <br>  Go needs to be installed, for this you need to do something like the following (instructions are for systems with dpkg): <br><pre> $ sudo apt-get install bison ed gawk gcc libc6-dev make # build tools
 $ sudo apt-get install python-setuptools python-dev build-essential # tools for building and installing
 $ sudo easy_install mercurial # if suddenly it is not there yet, it is better not to install from the repository (via apt)
 $ hg clone -r release https://go.googlecode.com/hg/ go
 $ cd go / src
 $ ./all.bash
</pre><br>  If all is well, you can add the following to <b>~ / .bashrc</b> or <b>~ / .profile</b> : <br><pre> export GOROOT = $ HOME / go
 export GOARCH = 386 # or amd64, depending on the OS architecture
 export GOOS = linux
 export GOBIN = $ GOROOT / bin
 PATH = $ PATH: $ GOBIN
</pre><br>  When you re-enter the shell and call the compiler ( <b>8g</b> for i386 or <b>6g</b> for amd64, then it will be <b>8g</b> ) we will receive a help message: <br><pre> gc: usage 8g [flags] file.go ...
</pre><br>  This means that Go is installed and running, you can go directly to the application. <br><br><h4>  Start.  Data structures </h4><br>  Create an application directory: <br><pre>  $ mkdir ~ / gowiki
 $ cd ~ / gowiki
</pre><br>  Create a text editor ( <a href="https://github.com/nsf/gocode">bindings for vim and emacs</a> ) file <b>wiki.go</b> with the following contents: <br><pre>  package main
 import (
	 fmt
	 "io / ioutil"
	 "os"
 )
</pre><br>  By name it is clear that our application will allow us to edit and save pages. <br>  This code imports the <i>fmt, ioutil,</i> and <i>os</i> libraries from the standard Go library.  Later we will add some other libraries. <br><br>  Define several data structures.  A wiki is a collection of related pages that have a body and a title.  The corresponding data structure will have two fields: <br><pre>  type page struct {
	 title string
	 body [] byte
 } </pre><br>  The data type <i>[] byte</i> is a slice of the type byte, an analogue of a dynamic array (more: <a href="http://golang.org/doc/effective_go.html">Effective Go</a> ) The body of the article is saved in <i>[] byte</i> , and not in <i>string</i> for convenience of working with standard libraries. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The data structure describes how data is stored in memory.  But what if you need to save data for a long time?  Implement the <i>save</i> method to save to disk: <br><pre>  func (p * page) save () os.Error {
	 filename: = p.title + ".txt"
	 return ioutil.WriteFile (filename, p.body, 0600)
 } </pre><br>  The signature of this function reads: ‚ÄúThis is a <i>save</i> method, applicable to a pointer to page, without parameters, and returning a value of type <i>os.Error</i> .‚Äù <br><br>  This method will save the text to a file.  For simplicity, we assume that the header is the file name.  If this seems to be not safe enough, you can import <i>crypto / md5</i> and use the <i>md5.New (filename)</i> call. <br><br>  The return value will be of the <i>os.Error</i> type, corresponding to the return value of the <i>WriteFile</i> call (standard library function for writing a slice to a file).  This is done so that in the future you can handle the save to file error.  If there are no problems, <i>page.save ()</i> returns us <i>nil</i> (zero for pointers, interfaces, and some other types). <br><br>  The octal constant 0600, the third parameter of the <i>WriteFile</i> call, indicates that the file is saved with read and write rights only for the current user. <br><br>  It would also be interesting to download the page: <br><pre>  func loadPage (title string) * page {
	 filename: = title + ".txt"
	 body, _: = ioutil.ReadFile (filename)
	 return &amp; page {title: title, body: body}
 } </pre><br>  This function gets the file name from the header, reads the contents into a variable of type page, and returns a pointer to it. <br><br>  Functions in Go can return multiple values.  The standard library function <i>io.ReadFile</i> returns <i>[] byte</i> and <i>os.Error</i> .  In the <i>loadPage</i> function <i>,</i> errors are not yet processed: the underscore symbol means ‚Äúdo not save this value‚Äù. <br><br>  What happens if <i>ReadFile</i> returns an error?  For example, there is no page with this title.  This is a significant error, it can not be ignored.  Let our function also return two values: <i>* page</i> and <i>os.Error</i> . <br><pre>  func loadPage (title string) (* page, os.Error) {
	 filename: = title + ".txt"
	 body, err: = ioutil.ReadFile (filename)
	 if err! = nil {
		 return nil, err
	 }
	 return &amp; page {title: title, body: body}, nil
 } </pre><br>  Now you can check the value of the second parameter: if it is <i>nil</i> , then the page has successfully loaded.  Otherwise, it will be a value of type <i>os.Error</i> . <br><br>  So, we have a data structure and methods of loading and unloading.  It's time to check how it works: <br><pre>  func main () {
	 p1: = &amp; page {title: "TestPage", body: [] byte ("Test page.")}
	 p1.save ()
	 p2, _: = loadPage ("TestPage")
	 fmt.Println (string (p2.body))
 } </pre><br>  After compiling and executing this code, the <b>TestPage.txt</b> file will contain the value <i>p1-&gt; body</i> .  After that, this value is loaded into the variable <i>p2</i> and displayed on the screen. <br><br>  To build and run the program, do the following: <br><pre>  $ 8g wiki.go
 $ 8l wiki.8
 $ ./8.out
 This is a sample page.
</pre><br><br><h4>  <i>Http</i> library </h4><br>  The easiest web server on Go is: <br><pre>  package main
 import (
	 fmt
	 "http"
 )
 func handler (w http.ResponseWriter, r * http.Request) {
	 fmt.Fprintf (w, "Hi% s!", r.URL.Path [1:])
 }
 func main () {
	 http.HandleFunc ("/", handler)
	 http.ListenAndServe (": 8080", nil)
 } </pre><br>  The main function calls <i>http.HandleFunc</i> , which tells the <i>http</i> library that all sorts of requests ( <b>"/"</b> ) are handled by the <i>handler</i> function. <br><br>  The next call to <i>http.ListenAndServe</i> , we define that we want to handle requests on all interfaces on port 8080 ( <b>": 8080"</b> ).  The second parameter is not required yet.  The program will work in this mode until forced termination. <br><br>  The handler function is of type <i>http.HandlerFunc</i> .  It takes <i>http.ResponseWriter</i> and a pointer to <i>http.Request</i> as parameters. <br><br>  A value of type <i>http.ResponseWriter</i> generates an <i>http</i> response;  writing data there (by calling <i>Fprintf</i> ) we return the contents of the page to the user. <br><br>  The <i>http.Request</i> data <i>structure</i> is a user request.  The string <i>r.URL.Path</i> is the path.  The suffix <i>[1:]</i> means ‚Äúget the <i>Path</i> slice (substring) from the first character to the end,‚Äù that is, delete the leading slash. <br><br>  Starting the browser and opening the URL <a href="http://localhost:8080/habrahabr">http: // localhost: 8080 / habrahabr</a> , we will see on the page desired: <br><pre>  Hi, habrahabr! </pre><br><br><h4>  Using <i>http</i> to render pages </h4><br>  Import the <i>http</i> library: <br><pre>  import (
	 fmt
	 "http"
	 "io / ioutil"
	 "os"
 )
</pre><br>  Create a handler to display the article: <br><pre> const lenPath = len ("/ view /")

 func viewHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, _: = loadPage (title)
	 fmt.Fprintf (w, "&lt;h1&gt;% s &lt;/ h1&gt; &lt;div&gt;% s &lt;/ div&gt;", p.title, p.body)
 } </pre><br>  First, this function retrieves the header from <i>r.URL.Path</i> , the path components of the specified URL.  The global constant <i>lenPath</i> is the length of the <b>"/ view /"</b> prefix in the path denoting the viewing of the text of the article in our system.  <i>Substring [lenPath:] is</i> allocated, i.e., the title of the article, the prefix is ‚Äã‚Äãexcluded. <br><br>  The function loads data, complementing it with simple html-tags and writes in <i>w</i> , a parameter of the type <i>http.ResponseWriter</i> . <br><br>  _ <i>Is</i> again used to ignore a return value of type <i>os.Error.</i>  This is done for simplicity and in general it is not good to do so.  Below will be described how to handle such errors correctly. <br><br>  To call this handler, we write a function <i>main</i> , initializing <i>http</i> with the appropriate <i>viewHandler</i> for processing requests along the path <b>/ view /</b> . <br><br><pre>  func main () {
	 http.HandleFunc ("/ view /", viewHandler)
	 http.ListenAndServe (": 8080", nil)
 } </pre><br>  Let's create a test page (in the <b>test.txt</b> file), compile the code and try to <b>display the</b> page: <br><pre>  $ echo "Hello world"&gt; test.txt
 $ 8g wiki.go
 $ 8l wiki.8
 $ ./8.out </pre><br>  While our server is running, a page with the title ‚Äútest‚Äù containing the words ‚ÄúHello world‚Äù will be available at <a href="http://localhost:8080/view/test">http: // localhost: 8080 / view / test</a> . <br><br><h4>  Change pages </h4><br>  What are these wikis without editing pages?  Create two new handlers: <i>editHandler</i> to display the edit form and <i>saveHandler</i> to save the received data. <br><br>  First, add them to <i>main ()</i> : <br><pre>  func main () {
	 http.HandleFunc ("/ view /", viewHandler)
	 http.HandleFunc ("/ edit /", editHandler)
	 http.HandleFunc ("/ save /", saveHandler)
	 http.ListenAndServe (": 8080", nil)
 } </pre><br>  The <i>editHandler</i> function loads the page (or creates an empty structure if there is no such page), and displays the form: <br><pre>  func editHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, err: = loadPage (title)
	 if err! = nil {
		 p = &amp; page {title: title}
	 }
	 fmt.Fprintf (w, "&lt;h1&gt; Editing% s &lt;/ h1&gt;" +
		 "&lt;form action = \" / save /% s \ "method = \" POST \ "&gt;" +
		 "&lt;text area name = \" body \ "&gt;% s &lt;/ text area&gt;" +
		 "&lt;input type = \" submit \ "value = \" Save \ "&gt;" +
		 "&lt;/ form&gt;",
		 p.title, p.title, p.body)
 } </pre><br>  The function works well and correctly, but it looks ugly.  The reason is in the hardcode html, but it is fixable. <br><br><h4>  Library <i>template</i> </h4><br>  The <i>template</i> library is included in the standard Go library.  We can use templates to store html markup outside the code so that we can change the markup without recompiling. <br><br>  First, import the <i>template</i> : <br><br><pre>  import (
	 "http"
	 "io / ioutil"
	 "os"
	 "template"
 ) </pre><br>  Create a form template in the <b>edit.html</b> file, with the following content: <br><br><pre>  &lt;h1&gt; Editing {title} &lt;/ h1&gt;

 &lt;form action = "/ save / {title}" method = "POST"&gt;
 &lt;div&gt; &lt;text area name = "body" rows = "20" cols = "80"&gt; {body | html} &lt;/ text area&gt; &lt;/ div&gt;
 &lt;div&gt; &lt;input type = "submit" value = "Save"&gt; &lt;/ div&gt;
 &lt;/ form&gt; </pre><br>  <i>Edit the editHandler</i> to use the template: <br><pre>  func editHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, err: = loadPage (title)
	 if err! = nil {
		 p = &amp; page {title: title}
	 }
	 t, _: = template.ParseFile ("edit.html", nil)
	 t.Execute (p, w)
 } </pre><br>  The <i>template.ParseFile</i> method will read the <b>edit.html</b> file and display the value of the <i>* template.Template</i> type. <br><br>  The <i>t.Execute</i> method replaces all <i>{title}</i> and <i>{body}</i> entries with the values ‚Äã‚Äãof <i>p.title</i> and <i>p.body</i> , and outputs the resulting html to a variable of type http.ResponseWriter. <br><br>  Notice that the <i>{body | html}</i> construct was found in the template.  It means that the parameter will be formatted for output in html, i.e.  will be escaped and, for example, <b>&gt;</b> replaced <b>&amp; gt;</b>  .  This will correctly display the data in the form. <br><br>  Now there is no <i>fmt.Sprintf</i> call in the program, you can remove <i>fmt</i> from import. <br><br>  Create a template to display the page, <b>view.html</b> : <br><pre> &lt;h1&gt; {title} &lt;/ h1&gt; &lt;p&gt; [&lt;a href="/edit/{title}"&gt; edit &lt;/a&gt;] &lt;/ p&gt; &lt;div&gt; {body} &lt;/ div&gt; </pre><br>  Change the <i>viewHandler</i> accordingly: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, _: = loadPage (title)
	 t, _: = template.ParseFile ("view.html", nil)
	 t.Execute (p, w)
 } </pre><br>  Note that the code for calling templates is almost the same in both cases.  We will get rid of duplication by bringing this code into a separate function: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, _: = loadPage (title)
	 renderTemplate (w, "view", p)
 }
 func editHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 p, err: = loadPage (title)
	 if err! = nil {
		 p = &amp; page {title: title}
	 }
	 renderTemplate (w, "edit", p)
 }
 func renderTemplate (w http.ResponseWriter, tmpl string, p * page) {
	 t, _: = template.ParseFile (tmpl + ". html", nil)
	 t.Execute (p, w)
 } </pre><br>  Now the handlers are shorter and simpler. <br><br><h4>  Handling Missing Pages </h4><br>  What happens when I go to <a href="http://localhost:8080/view/APageThatDoesntExist">/ view / APageThatDoesntExist</a> ?  The program will fall.  And all because we have not processed the second value returned by <i>loadPage</i> .  If the page does not exist, we will redirect the user to the page for creating a new article: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request, title string) {
	 p, err: = loadPage (title)
	 if err! = nil {
		 http.Redirect (w, r, "/ edit /" + title, http.StatusFound)
		 return
	 }
	 renderTemplate (w, "view", p)
 } </pre><br>  The <i>http.Redirect</i> function adds the HTTP status <i>http.StatusFound (302)</i> and the <i>Location</i> header to the HTTP response. <br><br><h4>  Saving pages </h4><br>  The <i>saveHandler</i> function processes data from the form. <br><pre>  func saveHandler (w http.ResponseWriter, r * http.Request) {
	 title: = r.URL.Path [lenPath:]
	 body: = r.FormValue ("body")
	 p: = &amp; page {title: title, body: [] byte (body)}
	 p.save ()
	 http.Redirect (w, r, "/ view /" + title, http.StatusFound)
 } </pre><br>  A new page is created with the selected voice and body.  The <i>save ()</i> method saves the data to a file, the client is redirected to the <b>/ view /</b> page. <br><br>  The value returned by <i>FormValue</i> is of type <i>string</i> .  To save to the page structure, we convert it to <i>[] byte by</i> writing <i>[] byte (body)</i> . <br><br><h4>  Error processing </h4><br>  We ignore errors in our program in several places.  This causes the program to crash when an error occurs, so it‚Äôs best to return an error message to the user, and the server will continue to work. <br><br>  First, add error handling to the <i>renderTemplate</i> : <br><pre>  func renderTemplate (w http.ResponseWriter, tmpl string, p * page) {
	 t, err: = template.ParseFile (tmpl + ". html", nil)
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
		 return
	 }
	 err = t.Execute (p, w)
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
	 }
 } </pre><br>  The <i>http.Error</i> function sends the selected HTTP status (in this case, ‚ÄúInternal Server Error‚Äù) and returns an error message. <br><br>  Make a similar edit to <i>saveHandler</i> : <br><pre>  func saveHandler (w http.ResponseWriter, r * http.Request, title string) {
	 body: = r.FormValue ("body")
	 p: = &amp; page {title: title, body: [] byte (body)}
	 err: = p.save ()
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
		 return
	 }
	 http.Redirect (w, r, "/ view /" + title, http.StatusFound)
 } </pre><br>  Any errors occurring in <i>p.save ()</i> will be passed to the user. <br><br><h4>  Pattern caching </h4><br>  Our code is not efficient enough: <i>renderTemplate</i> calls <i>ParseFile</i> on every rendering page.  It is much better to call <i>ParseFile</i> once for each template when starting the program, saving the resulting values ‚Äã‚Äãof type <i>* Template</i> into the structure for further use. <br><br>  First, create a <i>templates</i> map in which we save the <i>* Template</i> values, the key in the map is the name of the template: <br><pre>  var templates = make (map [string] * template.Template) </pre><br>  Next, we will create an initialization function that we will call in front of <i>main ()</i> .  The function <i>template.MustParseFile</i> is a wrapper for <i>ParseFile</i> that does not return an error code; instead, it panics.  Indeed, this behavior is valid for the program, because it is not known how to handle an incorrect template. <br><pre>  func init () {for _, tmpl: = range [] string {"edit", "view"} {templates [tmpl] = template.MustParseFile (tmpl + ". html", nil)}} </pre><br>  The <i>for</i> loop is used with the <i>range</i> construct and processes the specified patterns. <br><br>  Next, change the <i>renderTemplate</i> function so that it <i>calls the</i> <i>Execute</i> method of the corresponding template: <br><pre>  func renderTemplate (w http.ResponseWriter, tmpl string, p * page) {
	 err: = templates [tmpl] .Execute (p, w)
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
	 }
 } </pre><br><br><h4>  Validation </h4><br>  As already noted, our program has serious security bugs.  Instead of the name, you can pass an arbitrary path.  Add a check to a regular expression. <br><br>  Import the <i>regexp</i> library.  Create a global variable in which to save our RV: <br><pre>  var titleValidator = regexp.MustCompile ("^ [a-zA-Z0-9] + $") </pre><br>  The regexp.MustCompile <i>function will</i> compile a regular expression and return <i>regexp.Regexp</i> .  <i>MustCompile</i> , like <i>template.MustParseFile</i> , differs from <i>Compile</i> in that it panics in case of an error, while <i>Compile</i> returns an error code. <br><br>  Now, we will build a function that extracts the title from the URL, and checks its PB <i>titleValidator</i> : <br><pre>  func getTitle (w http.ResponseWriter, r * http.Request) (title string, err os.Error) {
	 title = r.URL.Path [lenPath:]
	 if! titleValidator.MatchString (title) {
		 http.notfound (w, r)
		 err = os.NewError ("Invalid Page Title")
	 }
	 return
 } </pre><br>  If the header is correct, the value <i>nil</i> will be returned with it.  Otherwise, ‚Äú404 Not Found‚Äù will be displayed to the user, and an error will be returned to the handler. <br><br>  Add a <i>getTitle</i> call to each of the handlers: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request) {
	 title, err: = getTitle (w, r)
	 if err! = nil {
		 return
	 }
	 p, err: = loadPage (title)
	 if err! = nil {
		 http.Redirect (w, r, "/ edit /" + title, http.StatusFound)
		 return
	 }
	 renderTemplate (w, "view", p)
 }
 func editHandler (w http.ResponseWriter, r * http.Request) {
	 title, err: = getTitle (w, r)
	 if err! = nil {
		 return
	 }
	 p, err: = loadPage (title)
	 if err! = nil {
		 p = &amp; page {title: title}
	 }
	 renderTemplate (w, "edit", p)
 }
 func saveHandler (w http.ResponseWriter, r * http.Request) {
	 title, err: = getTitle (w, r)
	 if err! = nil {
		 return
	 }
	 body: = r.FormValue ("body")
	 p: = &amp; page {title: title, body: [] byte (body)}
	 err = p.save ()
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
		 return
	 }
	 http.Redirect (w, r, "/ view /" + title, http.StatusFound)
 } </pre><br><br><h4>  Functional types and closures </h4><br>  Error checking and returns generates a rather monotonous code, it would be nice to write it only once.  This is possible, for example, if you wrap the functions that return errors into the corresponding call, functional types will help us with this. <br><br>  Rewrite handlers by adding the <i>title</i> parameter: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request, title string)
 func editHandler (w http.ResponseWriter, r * http.Request, title string)
 func saveHandler (w http.ResponseWriter, r * http.Request, title string) </pre><br>  We now define a wrapper function that accepts the type of function defined above and returns <i>http.HandlerFunc</i> (to transfer it to <i>http.HandleFunc</i> ): <br><pre>  func makeHandler (fn func (http.ResponseWriter, * http.Request, string)) http.HandlerFunc {
	 return func (w http.ResponseWriter, r * http.Request) {
		 // Here we will extract the page title from the Request,
		 // and call the provided handler 'fn'
	 }
 } </pre><br>  The function returned is a closure because  uses values ‚Äã‚Äãdefined outside of it (in this case it is the <i>fn</i> variable, the handler). <br><br>  Now let's transfer the code from <i>getTitle</i> : <br><pre>  func makeHandler (fn func (http.ResponseWriter, * http.Request, string)) http.HandlerFunc {
	 return func (w http.ResponseWriter, r * http.Request) {
		 title: = r.URL.Path [lenPath:]
		 if! titleValidator.MatchString (title) {
			 http.notfound (w, r)
			 return
		 }
		 fn (w, r, title)
	 }
 } </pre><br>  The closure returned by <i>makeHandler</i> is a function that accepts parameters like <i>http.ResponseWriter</i> and <i>http.Request</i> (that is, a function like http.HandlerFunc).  This closure extracts the title from the URL and checks its PB <i>titleValidator</i> .  If the header is incorrect, an error will be sent to the <i>ResponseWriter</i> (call <i>http.NotFound</i> ).  Otherwise, the corresponding handler <i>fn</i> will be called. <br><br>  Add a wrapper call to the <i>main ()</i> function: <br><pre>  func main () {
	 http.HandleFunc ("/ view /", makeHandler (viewHandler))
	 http.HandleFunc ("/ edit /", makeHandler (editHandler))
	 http.HandleFunc ("/ save /", makeHandler (saveHandler))
	 http.ListenAndServe (": 8080", nil)
 } </pre><br>  Finally, it‚Äôs possible to make them much simpler: <br><pre>  func viewHandler (w http.ResponseWriter, r * http.Request, title string) {
	 p, err: = loadPage (title)
	 if err! = nil {
		 http.Redirect (w, r, "/ edit /" + title, http.StatusFound)
		 return
	 }
	 renderTemplate (w, "view", p)
 }

 func editHandler (w http.ResponseWriter, r * http.Request, title string) {
	 p, err: = loadPage (title)
	 if err! = nil {
		 p = &amp; page {title: title}
	 }
	 renderTemplate (w, "edit", p)
 }

 func saveHandler (w http.ResponseWriter, r * http.Request, title string) {
	 body: = r.FormValue ("body")
	 p: = &amp; page {title: title, body: [] byte (body)}
	 err: = p.save ()
	 if err! = nil {
		 http.Error (w, err.String (), http.StatusInternalServerError)
		 return
	 }
	 http.Redirect (w, r, "/ view /" + title, http.StatusFound)
 } </pre><br>  <a href="">This is what should end up</a> <br><br>  Re-compile the code and run our application: <br><pre> $ 8g wiki.go
 $ 8l wiki.8
 $ ./8.out
</pre><br>  At <a href="http://localhost:8080/view/ANewPage">http: // localhost: 8080 / view / ANewPage there</a> will be a page with a form.  You can save the page and go to it. <br><br>  <i>Note</i>  The textarea in the code had to be broken in order not to wreak habraparser. </div><p>Source: <a href="https://habr.com/ru/post/122095/">https://habr.com/ru/post/122095/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122089/index.html">By adding one thing you always take something else away.</a></li>
<li><a href="../122090/index.html">15th issue of PROGRAMIST</a></li>
<li><a href="../122091/index.html">The role of techir in Agile - Tetris game</a></li>
<li><a href="../122093/index.html">A look into the future of the profession. What should a programmer have to do besides programming?</a></li>
<li><a href="../122094/index.html">Simple additional control of memcached data status</a></li>
<li><a href="../122097/index.html">NetScaler: Video Balancing</a></li>
<li><a href="../122100/index.html">10 Oatmeal Fonts</a></li>
<li><a href="../122101/index.html">Interview with Nigel Cunningham, TuxOnIce developer</a></li>
<li><a href="../122102/index.html">Apple patent - infrared transmitters and anti-bootleg</a></li>
<li><a href="../122103/index.html">kedDroid - S03E07. Video review software for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>