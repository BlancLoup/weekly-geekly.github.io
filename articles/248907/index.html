<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software routing with VyOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The stability and efficiency of business processes of a modern organization largely depends on the smooth functioning of the IT infrastructure. The ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software routing with VyOS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b1a/ff4/c4d/b1aff4c4df924746b3228d8ee36fce11.png" alt="image"><br><br>  The stability and efficiency of business processes of a modern organization largely depends on the smooth functioning of the IT infrastructure.  The maintenance of IT infrastructure in many cases is expensive, especially for small and medium-sized companies. <br><br>  In order to optimize costs, many organizations today resort to the practice of IT outsourcing: instead of purchasing equipment, the company rents it in a third-party data center, and attracts third-party specialists to service it. <br>  In order for this practice to be profitable from an organizational and financial point of view, you need to carefully consider the technical side of the issue. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When planning to transfer part of the IT infrastructure to a third-party data center, you should decide exactly how all the information resources of the organization will be combined into a single network.  Solutions from leading manufacturers (Juniper, Cisco and others) are often expensive;  small and medium-sized companies may not afford them.  In this regard, it is quite natural and explainable that the increased interest in free open source products, many of which are as good as paid counterparts, and sometimes even surpass them. <br><br>  An important element of a corporate network is a <b>router</b> - a specialized network device designed to unite network segments and forward packets between them.  Routers are both hardware and software.  In the case when it is necessary to build an IT infrastructure with minimal expenses, the use of a software router may be quite a suitable option. <br><br>  In this article, we will talk about the <a href="http://vyos.net/">VyOS</a> router, an interesting and promising product, which is also distributed under a free license for free, and we will show how it can be used to solve practical problems. <br><a name="habracut"></a><br><h2>  VyOS: general information </h2><br>  VyOS is a fork of the well-known network operating system <a href="http://www.brocade.com/launch/vyatta/">Vyatta</a> .  His first release codenamed Hydrogen was introduced in December 2013. <br><br>  The latest release to date - Helium - was released in September 2014.  The command line interface (CLI) in VyOS is similar to CLI devices from Juniper Networks. <br><br>  The possibilities of VyOS are really wide.  This is not a complete list: <br><ul><li>  firewall for IPv4 and IPv6, including filtering p2p traffic; <br>  Network Address Translation (NAT); </li><li>  DHCP server for IPv4 and IPv6; </li><li>  intrusion detection system; </li><li>  load balancing and channel redundancy; </li><li>  reservation of routers with synchronization of the connection state table; </li><li>  virtual private networks (IPsec, L2TP / IPsec, PPTP, OpenVPN); </li><li>  traffic accounting (Netflow and sFlow); </li><li>  web proxy and URL filtering. </li></ul><br>  Like Vyatta, VyOS is based on Debian.  This allows you to extend the functionality by installing additional deb-packages. <br><br><h2>  Installation </h2><br>  We will not give a detailed installation guide for VyOS, and there is no need for it: everything is detailed <a href="http://vyos.net/wiki/User_Guide">here</a> .  There are two types of VyOS installation: install system and install image.  The first type (install system) implies a standard OS installation on disk.  When installing using install image, each version of VyOS will be in a separate directory, which makes it possible to roll back to a previous release in case of problems (recommended installation method). <br><br>  So: boot from the disk, log in (login - vyos, password - vyos), execute the install image command.  The installation begins, during which you will need to answer standard Linux installer questions.  Upon completion, run the reboot command and log in again and log in with the login and password specified during installation. <br><br><h2>  Practical example </h2><br>  Consider the features of the VyOS on a specific practical example.  Conditions of the problem: the organization consists of three geographically distant units: one in Moscow, the second in St. Petersburg, and the third in Khabarovsk.  In St. Petersburg there are four servers installed in the data center.  You need to make sure that only one of them needs to be connected to the Internet directly.  The rest must be connected to the local network and access the Internet through a router.  We will use different types of connections for branch offices - L2TP / IPsec, PPTP and OpenVPN. <br><br>  Our network will look like this: <br><br><img src="https://habrastorage.org/files/3f8/5bc/f64/3f85bcf643734a3b93e15509324eb72e.png" alt="image"><br><br><h2>  Gateway configuration </h2><br>  After installing the network yet, so we will first configure it through the KVM console. <br><br>  To begin with we will configure the first network interface (external), which will have the address 95.213.170.75.  We switch to the configuration mode with the configure command ‚Äî yes, yes, everything is like that of the ‚Äúolder‚Äù iron counterparts. <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth0 address 95.213.170.75/29 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth0 description <span class="hljs-string"><span class="hljs-string">"WAN"</span></span></code> </pre> <br>  In this case, we assigned the address to the interface eth0 and specified the port description in order not to get confused in the future. <br><br>  We also indicate the default gateway addresses and the DNS server: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> system gateway-address 95.213.170.73 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> system name-server 188.93.16.19</code> </pre><br>  Here we use the St. Petersburg Selektel DNS server, but you, of course, can specify any other. <br>  We will configure the SSH service, with which we will further configure the gateway: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service ssh port <span class="hljs-string"><span class="hljs-string">"22"</span></span></code> </pre><br>  The logic of VyOS is almost the same as that of Juniper Networks devices.  To apply the changes, you need to execute the commit command.  In order for the changes to remain in force after a reboot, they must be saved using the save command.  This vyOS command differs in terms of logic from JunOS: in a network operating system, after Juniper, commit does not need to save changes after commit. <br><br>  Connect to the router via SSH.  To enter the system, enter the username and password specified during installation.  Then we configure the eth1 internal network interface.  This is the local network interface to which the servers in the data center are connected.  Assign it the address 10.0.10.1 with the network mask / 24 and add a description: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth1 address 10.0.10.1/24 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth1 description <span class="hljs-string"><span class="hljs-string">"LAN"</span></span></code> </pre><br>  In order for our machines to recognize the names of network resources, you need to configure DNS.  We will configure the DNS forwarder, which will redirect requests for resolving names to the servers specified by the configuration.  The setup procedure for this component is simple: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service dns forwarding cache-size <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service dns forwarding listen-on <span class="hljs-string"><span class="hljs-string">"eth1"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service dns forwarding name-server <span class="hljs-string"><span class="hljs-string">"188.93.16.19"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service dns forwarding name-server <span class="hljs-string"><span class="hljs-string">"188.93.17.19"</span></span></code> </pre><br>  The first command specifies the cache size that the DNS forwarder will use to store the records.  We set the cache size to zero, since in our case the storage of DNS records does not make much sense.  The second command sets the interface on which the DNS forwarder will ‚Äúlisten‚Äù.  We specifically use only the internal interface on which the DNS forwarder will ‚Äúlisten‚Äù to requests, in order not to make the DNS forwarder accessible to the entire Internet.  In the third and fourth command addresses are indicated, where requests will be sent.  In our example, the selector DNS servers are used, but instead of them, of course, you can specify any others. <br><br>  All components necessary for the functioning of the local network are ready for operation.  Go to the firewall setup. <br><br>  In VyOS, we can use firewall rules sets, calling them by any name.  In our example, the external network uses a set of rules under the name OUTSIDE, for the internal, respectively, INSIDE. <br><br>  For the external interface, we will allow all the connections "from the inside to the outside", for the internal interface - all from the "inside to the outside" and access to SSH. <br><br>  Create rules for the external interface: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name OUTSIDE default-action <span class="hljs-string"><span class="hljs-string">"drop"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name OUTSIDE rule 1 action <span class="hljs-string"><span class="hljs-string">"accept"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name OUTSIDE rule 1 state established <span class="hljs-string"><span class="hljs-string">"enable"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name OUTSIDE rule 1 state related <span class="hljs-string"><span class="hljs-string">"enable"</span></span></code> </pre><br>  By the above commands, we resolve the previously established (established) and related (related) compounds. <br><br>  Then we define the firewall rules: <br><div class="spoiler">  <b class="spoiler_title">See the rules</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE default-action <span class="hljs-string"><span class="hljs-string">'drop'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 1 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 1 state established <span class="hljs-string"><span class="hljs-string">'enable'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 1 state related <span class="hljs-string"><span class="hljs-string">'enable'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 2 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 2 icmp <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-name <span class="hljs-string"><span class="hljs-string">'echo-request'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 2 protocol <span class="hljs-string"><span class="hljs-string">'icmp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 2 state new <span class="hljs-string"><span class="hljs-string">'enable'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 action <span class="hljs-string"><span class="hljs-string">'drop'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 destination port <span class="hljs-string"><span class="hljs-string">'22'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 protocol <span class="hljs-string"><span class="hljs-string">'tcp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 recent count <span class="hljs-string"><span class="hljs-string">'4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 recent time <span class="hljs-string"><span class="hljs-string">'60'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 3 state new <span class="hljs-string"><span class="hljs-string">'enable'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 31 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 31 destination port <span class="hljs-string"><span class="hljs-string">'22'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 31 protocol <span class="hljs-string"><span class="hljs-string">'tcp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 31 state new <span class="hljs-string"><span class="hljs-string">'enable'</span></span></code> </pre></div></div><br>  In the first rule, we set the default action - in our case it is ‚Äúdrop‚Äù (all packets that do not fall under the established rules will be dropped by the firewall).  In the second, we allow the passage of ICMP packets;  First of all, this is necessary so that in the event of a failure, we can ‚Äúping‚Äù our router.  The third rule is responsible for SSH connections: we allow TCP traffic coming on port 22. <br><br>  Let's apply the created rules to the corresponding interfaces - external and local: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth0 firewall <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> name <span class="hljs-string"><span class="hljs-string">'OUTSIDE'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ethernet eth1 firewall out name <span class="hljs-string"><span class="hljs-string">'INSIDE'</span></span></code> </pre><br>  It is worth paying attention to the in and out parameters - they specify the type of traffic inbound or outbound relative to the router and are not associated with the names of the firewall rule sets. <br><br>  Do not forget to apply and save the configuration using the commit and save commands. <br><br><h2>  VPN configuration </h2><br>  As mentioned above, in branches we will use different types of VPN connections.  Let's start with setting up L2TP / IPSec (see <a href="https://ru.wikipedia.org/wiki/L2TP">here</a> for more details): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn ipsec ipsec-interfaces interface eth0 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn ipsec nat-traversal <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn ipsec nat-networks allowed-network 0.0.0.0/0 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access outside-address 95.213.170.75 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access client-ip-pool start 10.0.10.20 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access client-ip-pool stop 10.0.10.30 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access ipsec-settings authentication mode pre-shared-secret <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access ipsec-settings authentication pre-shared-secret &lt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote- access authentication mode <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn l2tp remote-access authentication <span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-users username &lt;&gt; password &lt;_&gt;</code> </pre><br>  Using the first three, we set the IPSec configuration: specify the interface to which the packets will go, enable NAT traversal and enable NAT for all networks.  Next come the commands responsible for L2TP.  In general, it is not difficult to guess from the writing of the teams what they are responsible for, let us pay attention only to some parameters. <br><ul><li>  <b>outside-address</b> - specifies the external address of the VPN server; </li><li>  <b>pre-shared-secret &lt;password&gt;</b> - sets the password for the connection, which will later be used to configure VPN on client devices; </li><li>  <b>authentication mode local</b> - sets the authentication type.  In our example, local authentication is used, but a RADIUS server can also be used for centralized account management. </li></ul><br>  In the last line, we create a user and set a password for it. <br>  After that, we will make adjustments to the firewall rules and allow L2TP / IPSec traffic. <br><div class="spoiler">  <b class="spoiler_title">See the rules</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 4 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 4 protocol <span class="hljs-string"><span class="hljs-string">'esp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 41 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 41 destination port <span class="hljs-string"><span class="hljs-string">'500'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 41 protocol <span class="hljs-string"><span class="hljs-string">'udp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 42 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 42 destination port <span class="hljs-string"><span class="hljs-string">'4500'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 42 protocol <span class="hljs-string"><span class="hljs-string">'udp'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 43 action <span class="hljs-string"><span class="hljs-string">'accept'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 43 destination port <span class="hljs-string"><span class="hljs-string">'1701'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 43 ipsec <span class="hljs-string"><span class="hljs-string">'match-ipsec'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> firewall name INSIDE rule 43 protocol <span class="hljs-string"><span class="hljs-string">'udp'</span></span> commit save</code> </pre></div></div><br>  Rule 4 allows ESP protocol traffic on which the established IPSEC tunnel works, 42 - NAT traversal, 43 - port 1701, on which L2TP is running. <br><br>  Now let's move on to setting up the second type of VPN connection and ‚Äúraise‚Äù the OpenVPN server. <br>  First, copy the easy-rsa files to the / config / easy-rsa2 directory, so as not to lose them when updating the system: <br><br><pre> <code class="bash hljs">cp -rv /usr/share/doc/openvpn/examples/easy-rsa/2.0/ /config/easy-rsa2</code> </pre><br>  If necessary, you can change the variables specified by default in certificates, for example: <br><br><pre> <code class="bash hljs">nano /config/easy-rsa2/vars <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KEY_COUNTRY=<span class="hljs-string"><span class="hljs-string">"RU"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KEY_CITY=<span class="hljs-string"><span class="hljs-string">"Saint-Petersburg"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KEY_ORG=<span class="hljs-string"><span class="hljs-string">"Selectel"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KEY_EMAIL=<span class="hljs-string"><span class="hljs-string">"t-rex@selectel.ru"</span></span></code> </pre><br>  This data will be indicated in the fields of certificates that we will generate.  Go to the / config / easy-rsa2 / directory and load the variables: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /config/easy-rsa2/ <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ./vars</code> </pre><br>  Delete all keys: <br><br><pre> <code class="bash hljs">./clean-all</code> </pre><br>  Then we generate the certificate authority files: <br><pre> <code class="bash hljs">./build-ca ./build-dh</code> </pre><br>  and server certificate: <br><br><pre> <code class="bash hljs">./build-key-server t-rex-server</code> </pre><br>  After that, copy the keys to the appropriate directories: <br><br><pre> <code class="bash hljs">cp /config/easy-rsa2/keys/ca.crt /config/auth/ cp /config/easy-rsa2/keys/dh1024.pem /config/auth/ cp /config/easy-rsa2/keys/t-rex-server.key /config/auth/ cp /config/easy-rsa2/keys/t-rex-server.crt /config/auth/</code> </pre><br>  Next, prepare the client files for connecting to the server: <br><pre> <code class="bash hljs">./build-key branch-msk</code> </pre><br>  and immediately copy them to a separate folder: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /config/easy-rsa2/keys mkdir branch-msk cp branch-msk* branch-msk/ cp ca.crt branch-msk/</code> </pre><br>  The generated files will be needed to connect clients to the server, so they will need to be transferred to the client side.  This can be done using any SCP client: WinSCP for Windows or the standard scp console client for Linux. <br><br>  Next, go to the server configuration: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 mode <span class="hljs-string"><span class="hljs-string">'server'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 server name-server <span class="hljs-string"><span class="hljs-string">'10.0.10.1'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 server push-route <span class="hljs-string"><span class="hljs-string">'10.0.10.0/24'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 server subnet <span class="hljs-string"><span class="hljs-string">'10.1.10.0/24'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 tls ca-cert-file <span class="hljs-string"><span class="hljs-string">'/config/auth/ca.crt'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 tls cert-file <span class="hljs-string"><span class="hljs-string">'/config/auth/t-rex-server.crt'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 tls dh-file <span class="hljs-string"><span class="hljs-string">'/config/auth/dh1024.pem'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces openvpn vtun0 tls key-file <span class="hljs-string"><span class="hljs-string">'/config/auth/t-rex-server.key'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> service dns forwarding listen-on vtun0 commit save</code> </pre><br>  Let's pay attention to the last command: in it we redirect the name resolution requests to the DNS forwarder configured earlier.  We also note that in the case of OpenVPN, we first used a separate network to build the tunnel itself, and then we routed it to the local network where our servers are located.  This is due to the features of the protocol.  In more detail we will tell about it in the following publication. <br><br><h2>  PPTP server setup </h2><br>  Configure the last type of VPN connection - PPTP.  Of course, PPTP is weakly protected and therefore can hardly be used to transmit confidential information, but it is widely used to provide remote access.  PPTP client is present in almost any device that has a network connection. <br><br>  From the above example, you can see that PPTP is configured in much the same way as L2TP: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access authentication mode <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access authentication <span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-users username &lt;_&gt; password &lt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access client-ip-pool start 10.0.10.31 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access client-ip-pool stop 10.0.10.40 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access dns-server server-1 188.93.17.19 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vpn pptp remote-access outside-address 95.213.170.75</code> </pre><br>  In the first command, we set the local user authentication mode.  If you have a RADIUS server, you can select the radius authentication mode: with its help, it is much more convenient to manage user accounts. <br><br>  Then we create local users, specify the range of IP addresses and DNS server data issued to clients.  The last command sets the address of the interface on which our server will ‚Äúlisten‚Äù. <br><br>  Apply and save the settings: <br><br><pre> <code class="bash hljs">commit save</code> </pre><br>  The server is ready to connect clients. <br><br>  It remains only to allow the passage of traffic from the local network to the outside.  Thus, we will provide Internet access to servers connected to the local network, as well as users connecting to our router from the branches: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nat <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> rule 1 outbound-interface <span class="hljs-string"><span class="hljs-string">'eth0'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nat <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> rule 1 <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> address <span class="hljs-string"><span class="hljs-string">'10.0.10.0/24'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nat <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> rule 1 translation address masquerade</code> </pre><br><h2>  Conclusion </h2><br>  So, that's it: we have built a network in accordance with the conditions of the task.  One of the servers (located in St. Petersburg) acts as a router, the other three servers are connected to it via a local network.  Routers in branch offices have access to local network resources through secure VPN connections. <br><br>  In this small review we described only the basics of building a small corporate network.  In the next post, we‚Äôll talk about VyOS‚Äôs capabilities in more detail and learn how to more flexibly manage firewall rules, forward ports, allow traffic of various protocols frequently used in company networks, and also consider the following questions: <br><ul><li>  GRE tunnel organization; </li><li>  work with L2TPv3 protocol; </li><li>  QoS; </li><li>  zone-based firewall; </li><li>  performance tuning of the network interface; </li><li>  VRRP. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/248907/">https://habr.com/ru/post/248907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248895/index.html">Buttons do not happen much</a></li>
<li><a href="../248897/index.html">C ++ 11 variadic templates and long arithmetic at compile time</a></li>
<li><a href="../248899/index.html">We write extensions with Roslyn by 2015 studios (part 1)</a></li>
<li><a href="../248901/index.html">Annotation to "Effective Modern C ++" by Scott Myers. Part 2</a></li>
<li><a href="../248903/index.html">Launch Linux in Microsoft Azure</a></li>
<li><a href="../248909/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</a></li>
<li><a href="../248911/index.html">CSS Report 2014: Testing the use of CSS in the ‚Äúfield‚Äù</a></li>
<li><a href="../248913/index.html">We write extensions with Roslyn by 2015 studios (part 2)</a></li>
<li><a href="../248917/index.html">CSRF in my home router and how I closed it</a></li>
<li><a href="../248919/index.html">Keyboard layout indicator with taskbar color and window title in modern versions of Windows using DWM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>