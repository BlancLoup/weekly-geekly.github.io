<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to train your dragon. Short example on clang-c</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, sitting in the evening in front of a computer and indulging in melancholy and thoughts about the frailty of everything, I thoughtfully typed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to train your dragon. Short example on clang-c</h1><div class="post__text post__text-html js-mediator-article">  One day, sitting in the evening in front of a computer and indulging in melancholy and thoughts about the frailty of everything, I thoughtfully typed in the search for one large job search site the abbreviation LLVM, not hoping, however, to see something special there, and began to look at the poor, right let's say a catch. <br><br>  As expected, almost nothing was found, but one ad interested me.  It had the following lines: <br><br>  <i>"Whom we take" without looking "or the level of tasks performed:</i> <i><br></i>  <i>You downloaded any open source project compiled with gcc (source code volume is more than 10 megabytes) and for the largest cpp file you could build an AST tree using clang with ‚Äìfsyntax-only;</i> <i><br></i>  <i>You downloaded any open source project compiled using Visual C ++ (source code volume is more than 10 megabytes) and for the largest cpp file you could build an AST tree using clang with ‚Äìfsyntax-only;</i> <i><br></i>  <i>You were able to write a utility that will allocate all the places for declarations and the use of local variables, as well as all functions not defined in this file</i> . ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, I thought, some kind of entertainment for the evening. <br><br><img src="https://habrastorage.org/files/40a/2a4/14a/40a2a414a89a4eb7980f162b1be3c55d.jpg"><br><a name="habracut"></a><br>  We will take a brief look at the first two points; everything is very simple there. <br><br><h3>  How to build AST </h3><br>  We take any project in c ++, you can clang itself (it is built on both gcc and VC ++). <br><br><pre><code class="bash hljs">clang -std=c++11 -Xclang -ast-dump ////cpp -I/////include/ -D_ -fsyntax-only</code> </pre> <br>  We get AST in text form.  For a large AST file has a huge size, I will not give the whole ast-dump here, but for clarity I will give a small piece: <br><br><div class="spoiler">  <b class="spoiler_title">AST fragment of the clang itself</b> <div class="spoiler_text"> <code>TranslationUnitDecl 0x576e190 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; <br> |-TypedefDecl 0x576e718 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128' <br> | `-BuiltinType 0x576e400 '__int128' <br> |-TypedefDecl 0x576e778 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128' <br> | `-BuiltinType 0x576e420 'unsigned __int128' <br> |-TypedefDecl 0x576eaa8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString 'struct __NSConstantString_tag' <br> | `-RecordType 0x576e860 'struct __NSConstantString_tag' <br> |   `-CXXRecord 0x576e7c8 '__NSConstantString_tag' <br> |-TypedefDecl 0x576eb38 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list 'char *' <br> | `-PointerType 0x576eb00 'char *' <br> |   `-BuiltinType 0x576e220 'char' <br> |-TypedefDecl 0x576ee58 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit referenced __builtin_va_list 'struct __va_list_tag [1]' <br> | `-ConstantArrayType 0x576ee00 'struct __va_list_tag [1]' 1 <br> |   `-RecordType 0x576ec20 'struct __va_list_tag' <br> |     `-CXXRecord 0x576eb88 '__va_list_tag' <br> |-NamespaceDecl 0x57cc578 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:18:1, line:31:1&gt; line:18:11 clang <br> | |-CXXRecordDecl 0x57cc5e0 &lt;line:20:1, col:7&gt; col:7 class Decl <br> | |-CXXRecordDecl 0x57cc6a0 &lt;line:21:29, &lt;scratch space&gt;:2:1&gt; col:1 referenced class AccessSpecDecl <br> | |-CXXRecordDecl 0x57cc760 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:3:1&gt; col:1 class BlockDecl <br> | |-CXXRecordDecl 0x57cc820 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:4:1&gt; col:1 class CapturedDecl <br> | |-CXXRecordDecl 0x57cc8e0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:5:1&gt; col:1 referenced class ClassScopeFunctionSpecializationDecl <br> | |-CXXRecordDecl 0x57cc9a0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:6:1&gt; col:1 class EmptyDecl <br> | |-CXXRecordDecl 0x57cca60 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:7:1&gt; col:1 class ExternCContextDecl <br> | |-CXXRecordDecl 0x57ccb20 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:8:1&gt; col:1 class FileScopeAsmDecl <br> | |-CXXRecordDecl 0x57ccbe0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:9:1&gt; col:1 referenced class FriendDecl <br> | |-CXXRecordDecl 0x57ccca0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:10:1&gt; col:1 referenced class FriendTemplateDecl <br> | |-CXXRecordDecl 0x57ccd60 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:11:1&gt; col:1 class ImportDecl <br> | |-CXXRecordDecl 0x57cce20 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:12:1&gt; col:1 class LinkageSpecDecl <br> | |-CXXRecordDecl 0x57ccee0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:13:1&gt; col:1 class NamedDecl <br> | |-CXXRecordDecl 0x57ccfa0 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:14:1&gt; col:1 class LabelDecl <br> | |-CXXRecordDecl 0x57cd060 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:15:1&gt; col:1 class NamespaceDecl <br> | |-CXXRecordDecl 0x57cd120 &lt;/home/user/LLVM/llvm-3.7.1.src/tools/cfe-3.7.1.src/include/clang/AST/ASTFwd.h:21:29, &lt;scratch space&gt;:16:1&gt; col:1 class NamespaceAliasDecl <br></code> <br></div></div><br>  You can also get a tree with another option: -ast-print.  It will also be text and huge, and I will not give it either. <br><br>  Finally, you can get a graphical representation of the tree in Graphviz (widely used for debugging in LLVM).  This is done using the -ast-view option.  Of course, this should set up Graphviz and set the paths to the 'dot' and 'gv' files.  In this case, many windows will open, each of which will have a small section of AST, for example, like this: <br><br><img src="https://habrastorage.org/files/b21/70d/887/b2170d887fc54f8a9e9267fb8ad649ab.jpg"><br><br>  However, before continuing, I would like to briefly tell you what AST is and why it is needed.  Readers with a degree in Computer Science can safely browse through the next section, and others may be interested. <br><br><h3>  Abstract Syntax Tree </h3><br>  Strict definitions you can see in Wikipedia, and I will try to explain "on the fingers." <br>  An abstract syntax tree is a structure with which the compiler presents the source code of a program in a form convenient for further compilation.  There are variables in the leaves of the tree (to be exact, references to variable declarations) and constants, in other vertices - operators, data type declarations, etc.  The root of the tree is the ‚Äútranslation unit‚Äù of the program. <br><br>  For example, a simple program: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file foo.h void foo(int x, int y); // file main.c #include "foo.h" typedef struct { int x, y; } st_coord; int main() { st_coord coord; foo(coord.x, coord.y); }</span></span></code> </pre> <br>  It generates an AST: <br><br><div class="spoiler">  <b class="spoiler_title">Many letters</b> <div class="spoiler_text">  TranslationUnitDecl 0x4e64ad0 &lt;&lt; invalid sloc &gt;&gt; &lt;invalid sloc&gt; <br>  | -TypedefDecl 0x4e65018 &lt;&lt; invalid sloc &gt;&gt; implicit __int128_t '__int128' <br>  |  `-BuiltinType 0x4e64d40 '__int128' <br>  | -TypedefDecl 0x4e65078 &lt;&lt; invalid sloc &gt;&gt; implicit __uint128_t 'unsigned __int128' <br>  |  `-BuiltinType 0x4e64d60 'unsigned __int128' <br>  | -TypedefDecl 0x4e65338 &lt;&lt; invalid sloc &gt;&gt; implicit __NSConstantString 'struct __NSConstantString_tag' <br>  |  `-RecordType 0x4e65150 'struct __NSConstantString_tag' <br>  |  `-Record 0x4e650c8 '__NSConstantString_tag' <br>  | -TypedefDecl 0x4e653c8 &lt;&lt; invalid sloc &gt;&gt; implicit __builtin_ms_va_list 'char *' <br>  |  `-PointerType 0x4e65390 'char *' <br>  |  `-BuiltinType 0x4e64b60 'char' <br>  | -TypedefDecl 0x4e65678 &lt;&lt; invalid sloc &gt;&gt; implicit __builtin_va_list 'struct __va_list_tag [1]' <br>  |  `-ConstantArrayType 0x4e65620 'struct __va_list_tag [1]' 1 <br>  |  `-RecordType 0x4e654a0 'struct __va_list_tag' <br>  |  `-Record 0x4e65418 '__va_list_tag' <br>  | -FunctionDecl 0x4ebc390 &lt;/home/user/llvm3.9/foo.h:1:1, col: 22&gt; col: 6 used foo 'void (int, int)' <br>  |  | -ParmVarDecl 0x4e656d8 &lt;col: 10, col: 14&gt; col: 14 x 'int' <br>  |  `-ParmVarDecl 0x4e65748 &lt;col: 17, col: 21&gt; col: 21 y 'int' <br>  | -RecordDecl 0x4ebc488 &lt;/home/user/llvm3.9/test.c.06:9, line: 5: 1&gt; line: 3: 9 struct definition <br>  |  | -FieldDecl 0x4ebc540 &lt;line: 4: 2, col: 6&gt; col: 6 referenced x 'int' <br>  |  `-FieldDecl 0x4ebc598 &lt;col: 2, col: 9&gt; col: 9 referenced y 'int' <br>  | -TypedefDecl 0x4ebc630 &lt;line: 3: 1, line: 5: 3&gt; col: 3 referenced st_coord 'struct st_coord': 'st_coord' <br>  |  `-ElaboratedType 0x4ebc5e0 'struct st_coord' sugar <br>  |  `-RecordType 0x4ebc510 'st_coord' <br>  |  `-Record 0x4ebc488 '' <br>  `-FunctionDecl 0x4ebc6e8 &lt;line: 7: 1, line: 10: 1&gt; line: 7: 5 main 'int ()' <br>  `-CompoundStmt 0x4ebc9c8 &lt;col: 12, line: 10: 1&gt; <br>  | -DeclStmt 0x4ebc820 &lt;line: 8: 2, col: 16&gt; <br>  |  `-VarDecl 0x4ebc7c0 &lt;col: 2, col: 11&gt; col: 11 used coord 'st_coord': 'st_coord' <br>  `-CallExpr 0x4ebc960 &lt;line: 9: 2, col: 22&gt; 'void' <br>  | -ImplicitCastExpr 0x4ebc948 &lt;col: 2&gt; 'void (*) (int, int)' &lt;FunctionToPointerDecay&gt; <br>  |  `-DeclRefExpr 0x4ebc838 &lt;col: 2&gt; 'void (int, int)' Function 0x4ebc390 'foo' 'void (int, int)' <br>  | -ImplicitCastExpr 0x4ebc998 &lt;col: 6, col: 12&gt; 'int' &lt;LValueToRValue&gt; <br>  |  `-MemberExpr 0x4ebc888 &lt;col: 6, col: 12&gt; 'int' lvalue .x 0x4ebc540 <br>  |  `-DeclRefExpr 0x4ebc860 &lt;col: 6&gt; 'st_coord': 'st_coord' lvalue Var 0x4ebc7c0 'coord' 'st_coord': 'st_coord' <br>  `-ImplicitCastExpr 0x4ebc9b0 &lt;col: 15, col: 21&gt; 'int' &lt;LValueToRValue&gt; <br>  `-MemberExpr 0x4ebc8e8 &lt;col: 15, col: 21&gt; 'int' lvalue .y 0x4ebc598 <br>  `-DeclRefExpr 0x4ebc8c0 &lt;col: 15&gt; 'st_coord': 'st_coord' lvalue Var 0x4ebc7c0 'coord' 'st_coord': 'st_coord' <br></div></div><br><h3>  We use clang-c API </h3><br>  In the clang compiler, each AST node is represented by an object of a particular class, with only three base classes: clang :: Decl (declaration class), clang :: Stmt, which includes all operators, and the clang :: Type class, the data type class. <br><br>  So, clang is written in C ++ and has an object-oriented API.  You can use it to write various utilities and tools using clang.  However, knowledgeable people prefer another API, clang-c, which is a wrapper over the clang API, written in pure C. The meaning is simple: first, it is simpler, and secondly, the clang-c API is stable, unlike the clang API, which changes with each release.  Finally, the use of clang-c does not exclude the use of the clang API, which we will see shortly. <br><br><img src="https://habrastorage.org/files/4a1/e93/971/4a1e939716b049e6a211775a2d3b8b68.jpg"><br><br><h3>  AST tree traversal </h3><br>  The first thing to do is to write a deep tree traversal.  This is a completely standard operation: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;clang-c/Index.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace clang; void printCursor(CXCursor cursor) { CXString displayName = clang_getCursorDisplayName(cursor); std::cout &lt;&lt; clang_getCString(displayName) &lt;&lt; "\n"; clang_disposeString(displayName); } CXChildVisitResult visitor( CXCursor cursor, CXCursor /* parent */, CXClientData /*clientData*/ ) { CXSourceLocation location = clang_getCursorLocation( cursor ); if( clang_Location_isFromMainFile( location ) == 0 ) return CXChildVisit_Continue; printCursor(cursor); clang_visitChildren( cursor, visitor, nullptr ); return CXChildVisit_Continue; } int main (int argc, char** argv) { CXIndex index = clang_createIndex ( 0, // excludeDeclarationFromPCH 1 // displayDiagnostics ); CXTranslationUnit unit = clang_parseTranslationUnit ( index, // CIdx 0, // source_filename argv, // command_line_args argc, // num_command_line_args 0, // unsave_files 0, // num_unsaved_files CXTranslationUnit_None // options ); if (!unit) { std::cout &lt;&lt; "Translation unit was not created\n"; } else { CXCursor root = clang_getTranslationUnitCursor(unit); clang_visitChildren(root, visitor, nullptr); } clang_disposeTranslationUnit(unit); clang_disposeIndex(index); }</span></span></span></span></code> </pre> <br>  Here, everything is very clear: clang_parseTranslationUnit is a function that performs all compilation steps before building an AST inclusive.  Any compilation options can be passed to it.  In this case, the file name can be passed either in arguments or directly (source_filename).  The source text can be transferred not only as a file, but also as a CXUnsavedFile structure representing the text in memory.  After the parsing, the tree is traversed in depth. For each vertex, the visitor function is called, to which CXCursor is passed - a structure representing the top of the tree.  Also, a visitor parameter CXClientData representing arbitrary user data may be passed to the visitor function. <br><br><h3>  We write the visitor function </h3><br>  Let's try to find all the local variables of the program. <br><pre> <code class="cpp hljs"> CXCursorKind cursorKind = clang_getCursorKind( cursor ); <span class="hljs-comment"><span class="hljs-comment">// finding local variables if(clang_getCursorKind(cursor) == CXCursor_VarDecl) { if(const VarDecl* VD = dyn_cast_or_null&lt;const VarDecl&gt;(getCursorDecl(cursor))) { if( VD-&gt;isLocalVarDecl()) { std::cout &lt;&lt; "local variable: "; printCursor(cursor); } } }</span></span></code> </pre> <br>  Here, too, everything is simple: CXCursor_VarDecl - the cursor points to a variable.  dyn_cast_or_null - type conversion pattern in LLVM. <br><br><div class="spoiler">  <b class="spoiler_title">LLVM and RTTI</b> <div class="spoiler_text">  LLVM does not use RTTI and the usual dynamic_cast will not work. <br>  The following patterns are used for type casting in LLVM: <br>  isa &lt;B&gt; (A) - check that the object A is of type B. <br>  cast &lt;B&gt; (A) - conversion of object A to type B. Verification of the belonging of type A to type B is not performed.  A check for nullptr is not performed. <br>  cast_or_null &lt;B&gt; (A) - the conversion of object A to type B. Verification of type A belonging to type B is not performed.  If A == nullptr, the result will be nullptr. <br>  dyn_cast &lt;B&gt; (A) - conversion of object A to type B with type checking.  A check for nullptr is not performed. <br>  dyn_cast_or_null &lt;B&gt; (A) - conversion of object A to type B with type checking.  If A == nullptr, the result will be nullptr. <br>  How to use the RTL LLVM implementation in your classes is written <a href="http://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html">here.</a> <br></div></div><br>  Next, we convert the cursor to an instance of the VarDecl class, and check whether the variable is local.  If so, we display the name of the cursor and its location in the source code, using auxiliary functions for this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//logging functions std::string getLocationString(CXSourceLocation Loc) { CXFile File; unsigned Line, Column; clang_getFileLocation(Loc, &amp;File, &amp;Line, &amp;Column, nullptr); CXString FileName = clang_getFileName(File); std::ostringstream ostr; ostr &lt;&lt; clang_getCString(FileName) &lt;&lt; ":" &lt;&lt; Line &lt;&lt; ":" &lt;&lt; Column; clang_disposeString(FileName); return ostr.str(); } void printCursor(CXCursor cursor) { CXString displayName = clang_getCursorDisplayName(cursor); std::cout &lt;&lt; clang_getCString(displayName) &lt;&lt; "@" &lt;&lt; getLocationString(clang_getCursorLocation(cursor)) &lt;&lt; "\n"; clang_disposeString(displayName); }</span></span></code> </pre><br>  To find the Decl, Expr and Stmt values, we use auxiliary functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// extracted from CXCursor.cpp const Decl *getCursorDecl(CXCursor Cursor) { return static_cast&lt;const Decl *&gt;(Cursor.data[0]); } const Stmt *getCursorStmt(CXCursor Cursor) { if (Cursor.kind == CXCursor_ObjCSuperClassRef || Cursor.kind == CXCursor_ObjCProtocolRef || Cursor.kind == CXCursor_ObjCClassRef) return nullptr; return static_cast&lt;const Stmt *&gt;(Cursor.data[1]); } const Expr *getCursorExpr(CXCursor Cursor) { return dyn_cast_or_null&lt;Expr&gt;(getCursorStmt(Cursor)); }</span></span></code> </pre> <br>  Further we look for all uses of local variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// finding referenced variables if(cursorKind == CXCursor_DeclRefExpr) { if(const DeclRefExpr* DRE = dyn_cast_or_null&lt;const DeclRefExpr&gt;(getCursorExpr(cursor))) { if(const VarDecl* VD = dyn_cast_or_null&lt;const VarDecl&gt;(DRE-&gt;getDecl())) { if(VD-&gt;isLocalVarDecl()) { std::cout &lt;&lt; "reference to local variable: "; printCursor(cursor); } } } }</span></span></code> </pre> <br>  And finally, we find all calls to functions that are not defined in this file: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// finding functions not defined in the module if(cursorKind == CXCursor_CallExpr) { if (const Expr *E = getCursorExpr(cursor)) { if(isa&lt;const CallExpr&gt;(E)) { CXCursor Definition = clang_getCursorDefinition(cursor); if (clang_equalCursors(Definition, clang_getNullCursor())) { std::cout &lt;&lt; "function is not defined here: "; printCursor(cursor); } } } }</span></span></code> </pre> <br>  Here we check whether the cursor is a function call (CXCursor_CallExpr).  However, it should be noted that CXCursor_CallExpr is not only a function call, it is also a call to the constructor, destructor and method, so additional check (isa) is needed.  After that, we look for the definition of the function (clang_getCursorDefinition), and if we do not find (clang_equalCursors (Definition, clang_getNullCursor ())), then we have found a function that is not defined in this file. <br><img src="https://habrastorage.org/files/103/301/553/103301553c414455a5dea3e2b20c1e65.jpg"><br><br><h3>  Test </h3><br>  For the test, we will write two simple programs, one for C, one for C ++. <br>  So, the C program: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//file func.h void foo_ext(int x); //file simple.c #include "func.h" int global1; int foo(int x) { return x; } int global2; int main(int arg) { int local; local = arg; foo_ext(arg); return foo(local); }</span></span></code> </pre> <br>  Run our utility, we get at the output: <br><br><pre> <code class="cpp hljs">local variable: local@simple.c:<span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> reference to local variable: local@simple.c:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> function is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined here: foo_ext@simple.c:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> reference to local variable: local@simple.c:<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  It seems that's right.  Now let's check on the file in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> class MyClass { public: MyClass() { int SomeLocal_1; } void foo() { int SomeLocal_2; } ~MyClass() { int SomeLocal_3; } }; MyClass myClass_global; int foo(int x) {return 0;} int main(int argc, char** argv) { int local; MyClass myClass_local; foo(argc); foo_ext(local); return 1; }</span></span></code> </pre> <br>  We get at the output: <br><br><pre> <code class="cpp hljs">local variable: SomeLocal_1@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> local variable: SomeLocal_2@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> local variable: SomeLocal_3@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> local variable: local@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> local variable: myClass_local@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">23</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> function is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined here: foo_ext@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">25</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> reference to local variable: local@cpptest.cpp:<span class="hljs-number"><span class="hljs-number">25</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span></code> </pre> <br>  OK, it seems it works. <br><br><h3>  How can this be used? </h3><br>  The wide range of clang features can be used for various purposes, which include analyzing and converting source code in C, C ++ and Objective C. <br><br><div class="spoiler">  <b class="spoiler_title">Still</b> <div class="spoiler_text">  You can also use it to search for work, but while I was writing all this, the ad disappeared from the site.  Alas. <br></div></div><br><h3>  Literature </h3><br>  List of sources on the topic: <br><br>  1. <a href="https://github.com/arktur04/llvm-clang-c-util-example">Project code on Gihub</a> . <br>  2. <a href="http://bastian.rieck.ru/blog/posts/2015/baby_steps_libclang_ast/">http://bastian.rieck.ru/blog/posts/2015/baby_steps_libclang_ast/</a> <br>  3. <a href="http://bastian.rieck.ru/blog/posts/2016/baby_steps_libclang_function_extents/">http://bastian.rieck.ru/blog/posts/2016/baby_steps_libclang_function_extents/</a> <br>  4. <a href="https://jonasdevlieghere.com/understanding-the-clang-ast/">https://jonasdevlieghere.com/understanding-the-clang-ast/</a> <br>  5. <a href="https://habrahabr.ru/post/148508/">https://habrahabr.ru/post/148508/</a> </div><p>Source: <a href="https://habr.com/ru/post/320074/">https://habr.com/ru/post/320074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320062/index.html">Where to move with Parse Push?</a></li>
<li><a href="../320064/index.html">Angular 2: why on TypeScript?</a></li>
<li><a href="../320066/index.html">ERP CRM Consultant ‚Äî Eternal Negotiator</a></li>
<li><a href="../320070/index.html">Finite Difference Programming</a></li>
<li><a href="../320072/index.html">Writing a universal UICollectionViewLayout</a></li>
<li><a href="../320076/index.html">Zones / circles / spheres of influence, control and interest - a model of personal development strategy</a></li>
<li><a href="../320078/index.html">How to create a temporary file in PHP when the tmpfile () function does not work</a></li>
<li><a href="../320080/index.html">Card game on JavaScript and Canvas, or personal Las Vegas. Part 1</a></li>
<li><a href="../320082/index.html">Forums: engines, servers and all-all-all</a></li>
<li><a href="../320084/index.html">Pure javascript. Testing. Formatting Comments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>