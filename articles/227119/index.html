<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lisp's mini-interpreter in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reading the ‚ÄúBinary trees‚Äù chapter from John Mongan‚Äôs Programming Interviews Exposed book, I thought about how recursion is often explained to novice ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lisp's mini-interpreter in Python</h1><div class="post__text post__text-html js-mediator-article">  Reading the ‚ÄúBinary trees‚Äù chapter from John Mongan‚Äôs <a href="http://www.piexposed.com/">Programming Interviews Exposed</a> book, I thought about how recursion is often explained to novice programmers: through sorting, bypassing a binary tree, building a Fibonacci sequence, etc.  Is it really impossible to find an example more interesting?  Lisp, which by its nature is inseparable from the concept of recursion, escaped from the nooks of consciousness.  Moreover, a small Lisp interpreter is a great example for the study of recursion. <br><br>  What will be the minimal Lisp interpreter written in Python?  To my surprise, the decision went in seven lines!  Both the expressiveness of Python and the beauty and uncomplicated nature of Lisp played a role in this. <br><a name="habracut"></a><br>  First, you need to decide on the grammar and the method of calculating expressions: <br><br><pre><code class="hljs go">list := (item0, item1, ...) item := list | atom atom := stringliteral | numliteral</code> </pre> <br>  The calculation rules are the same as in any other Lisp dialect: the first element of the list is the function, the rest are the function arguments: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs php">fn = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] args = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>:]</code> </pre><br>  Note that the list is written in the form of a tuple of Python.  This cheat allows you to transfer the tasks of lexical and tactical analysis on the shoulders of Python himself.  In addition, the interpreter itself does not contain built-in operators and special forms.  All this can be added as extensions. <br><br>  Let's give a few examples before moving on to the interpreter code and its expanding functions: <br><br><pre> <code class="python hljs"> (quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment"># &gt;&gt;&gt; (1, 2, 3) (plus, 1, 2, 3) # &gt;&gt;&gt; 6 (inc, 10) # &gt;&gt;&gt; 11</span></span></code> </pre><br>  All right, enough of the lyrics, let's move on to programming! <br><br><h5>  Tiny Lisp Interpreter </h5><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list_or_atom)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(list_or_atom, tuple): <span class="hljs-comment"><span class="hljs-comment">#  ,   StreetStrider  Amper fn, *fn_args = [eval(item) for item in list_or_atom] return fn(*fn_args) else: return list_or_atom</span></span></code> </pre><br>  That's all!  And it works like this: <br><ol><li>  First we check the type of input data: is it an atom, or a list (in our case, a tuple)?  If it is an atom, its value is returned unchanged.  Those.  for example, <code>eval(1)</code> returns <code>1</code> . </li><li>  If the argument is a tuple, then we denote the first element of the list as a function, and all other elements of the list as function arguments.  In this case, each argument is computed in place using the recursive call to <code>eval()</code> . </li></ol><br>  With a naked interpreter you will not go far.  Let's expand it a little bit. <br><br><h5>  plus </h5><br>  Let's start with a simple mathematical addition function.  In various Lisp dialects, addition is denoted by the <code>+</code> sign (and what did you think?) However, due to the limitations of the Python syntax, we cannot write <code>(+, 2, 3)</code> .  Therefore, we call the addition operation the word <code>plus</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Sums up the input arguments."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(args) eval((plus, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-comment"><span class="hljs-comment">#   eval((plus, 3, (plus, 2, 10), 5)) &gt;&gt; 20</span></span></code> </pre><br><br><h5>  quote </h5><br>  To separate the code from the data in Lisp, a special form of data ‚Äúciting‚Äù is used - <code>quote</code> .  For example, in Emacs-Lisp: <code>(quote 1 2 3)</code> .  This record can be abbreviated by writing quote with a single quote before the data: <code>'(1 2 3)</code> .  Without "quoting", Lisp will regard this expression as: <code>1</code> is the name of the function, <code>2 3</code> are the arguments of the function, which will certainly cause an execution error.  Since  Python syntax will not allow writing data with a single quote, you will have to use <code>quote</code> as a function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Returns a list without evaluating it."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple(args) eval((quote, <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>)) &gt;&gt;&gt; (<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>) eval((quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (quote, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>))) &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre><br><br>  <b>UPD:</b> <a href="https://habrahabr.ru/users/kmeaw/" class="user_link">kmeaw</a> quite correctly noted that in a full Lisp quote should work differently: not one element of the list is calculated.  For example in Elisp: <br><br><pre> <code class="lisp hljs">'(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> '(<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>)) &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">quote</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre><br><br>  The comments on the article discuss various options for correcting this flaw. <br><br><h5>  apply </h5><br>  Suppose that the input of a function is supplied data in the form of a list, for example <code>(plus, (quote, 1, 2, 3))</code> .  Our interpreter will not survive this, because inside it all ends with a call to <code>sum([(1,2,3), ])</code> .  To resolve this situation in Lisp, there is a function <code>apply</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Applies a function to a list of arguments."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(*args) eval((apply, plus, (quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><br><h5>  map and inc </h5><br>  Where without the classic <code>map</code> function!  Map applies this function to each of the elements of this list and returns the result as a new list.  For example: <code>(map, inc, (quote, 1, 2, 3))</code> returns <code>(2, 3, 4)</code> .  Here, <code>inc</code> is an increment function, for example <code>(inc 10)</code> returns 11. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, lst)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Applies the function to each element of the list and returns the results in a new list."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple(fn(item) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lst) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Increases the argument by 1."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg + <span class="hljs-number"><span class="hljs-number">1</span></span> eval((map, inc, (quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br><br><h5>  Lambda </h5><br>  The tale ends in lambda expressions.  Using Python syntax, you cannot automatically call <code>eval()</code> inside the body of a lambda function: <br><br><pre> <code class="python hljs">eval((map, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: (plus, x, <span class="hljs-number"><span class="hljs-number">1</span></span>), (quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)))</code> </pre><br>  does not work, because  expression <code>(plus, x, 1)</code> not calculated.  To get the desired result, the body of the lambda function can be rewritten as follows: <br><br><pre> <code class="python hljs">eval((map, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: eval(plus, x, <span class="hljs-number"><span class="hljs-number">1</span></span>), (quote, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)))</code> </pre><br>  which of course violates the syntax sequence. <br><br>  This interpreter can be expanded with a dozen or so other useful functions.  But whatever one may say, it is limited to the syntax of Python and full-fledged Lips with this approach not to squeeze out. <br><br>  I hope that you have learned something new and useful for yourself, and that habravchane who considered Lisp a complex set of brackets, will reconsider their opinion :) </div><p>Source: <a href="https://habr.com/ru/post/227119/">https://habr.com/ru/post/227119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227103/index.html">RPG JS v2 framework for creating 2D browser-based online games</a></li>
<li><a href="../227105/index.html">Google Play Movies become available in Belarus</a></li>
<li><a href="../227109/index.html">Useful materials for mobile developer # 58 (June 16-22)</a></li>
<li><a href="../227111/index.html">HP Vertica, Data Warehouse, Big Data Design</a></li>
<li><a href="../227117/index.html">Amazon attracts application developers for Fire Phone</a></li>
<li><a href="../227127/index.html">The mapping of the gravitational forces of the solar system</a></li>
<li><a href="../227129/index.html">Using Caching Infrastructure in ASP.NET</a></li>
<li><a href="../227131/index.html">ElasticSearch - data aggregation</a></li>
<li><a href="../227133/index.html">In Syktyvkar pizza delivered oktokopterami</a></li>
<li><a href="../227135/index.html">Digest of articles on data analysis No. 3 (June 09, 2014 ‚Äî June 22, 2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>