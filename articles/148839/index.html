<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experimental Determination of Cache Memory Characteristics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Due to what we see a constant increase in the performance of single-threaded programs? At the moment we are at that stage of development of microproce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experimental Determination of Cache Memory Characteristics</h1><div class="post__text post__text-html js-mediator-article">  Due to what we see a constant increase in the performance of single-threaded programs?  At the moment we are at that stage of development of microprocessor technologies, when the increase in the speed of single-threaded applications depends only on memory.  The number of cores is growing, but the frequency is fixed within 4 GHz and does not give a performance boost. <br><br>  The speed and frequency of the memory is the main reason why we get ‚Äúour own piece of free cake‚Äù (link).  That is why it is important to use memory as efficiently as we can, and even more so as fast as a cache.  To optimize the program for a specific computer, it is useful to know the characteristics of the processor's cache memory: the number of levels, size, line length.  This is especially important in high-performance code - kernel systems, math libraries. <br><br>  How to determine the characteristics of the cache automatically?  (Naturally, cpuinfo is not considered parsing, though, if only because, ultimately, we would like to get an algorithm that can be easily implemented in other OSes. Convenient, isn't it?) This is what we are going to do now. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  A bit of theory </h4><br>  At the moment, there are three widely used types of cache memory: direct mapping cache, associative cache, and multiple associative cache. <br><a name="habracut"></a><br><h5>  Direct mapping cache </h5>  - a given RAM line can be mapped to a single cache line, but many possible RAM lines can be mapped to each cache line. <br><br> <a href="http://hostingkartinok.com/" title="place photo"><img src="https://habrastorage.org/getpro/habr/post_images/ede/b1c/75c/edeb1c75c4412f1b526c46feb5bb2c81.png"></a> <br><br><h5>  Associative cache (fully associative cache) </h5>  - any line of RAM can be mapped to any cache line. <br><br> <a href="http://hostingkartinok.com/" title="free image hosting"><img src="https://habrastorage.org/getpro/habr/post_images/765/c65/14b/765c6514bf94ecd09c0cd0b02bb0ab51.png"></a> <br><br><h5>  Multiple associative cache </h5>  - the cache memory is divided into several ‚Äúbanks‚Äù, each of which functions as a cache with direct mapping, so the line of RAM can be mapped not to the only possible cache entry (as it would be in the case of direct mapping), but to one of several banks ;  Bank selection is based on LRU or another mechanism for each cache line. <br><br> <a href="http://hostingkartinok.com/" title="photo hosting"><img src="https://habrastorage.org/getpro/habr/post_images/916/5d6/acb/9165d6acb9ddd7182b6ac88968af4632.png"></a> <br><br>  LRU - crowding out the ‚Äúlong unused‚Äù line, the memory cache. <br><br><h4>  Idea </h4><br>  To determine the number of cache levels, you need to consider the order of memory accesses, in which the transition is clearly visible.  Different cache levels differ primarily in memory responsiveness.  In the case of ‚Äúcache miss‚Äù for the L1 cache, data will be searched in the following memory levels, while if the data size is greater than L1 and less than L2, then the speed of the memory response will be the speed of the L2 response.  The previous statement is also true in general cases. <br><br>  It is clear that you need to pick up a test on which, we will clearly see the cache misses and test it on various data sizes. <br><br>  Knowing the logic of multiple-associative caches using the LRU algorithm, it is not difficult to come up with an algorithm on which the cache ‚Äúcrashes‚Äù, nothing tricky - passing through the line.  The criterion of effectiveness will be considered the time of one memory access.  Naturally you need to consistently refer to all elements of the line, repeating repeatedly to averaging the result.  For example, there may be cases when the string fits in the cache, but for the first pass we load the string from the RAM and therefore we get completely inadequate time. <br><br>  I want to see something like steps, passing through rows of different lengths.  To determine the character of the steps, consider the example of a row pass for the forward and associative cache, the case with the multiply associative cache will be the average between the forward mapping cache and the associative cache. <br><br>  Associative cache <br><br>  As soon as the data size exceeds the cache size, <br>  fully associative cache ‚Äúmisses‚Äù every time memory is accessed. <br><br> <a href="http://hostingkartinok.com/" title="imagehost"><img src="https://habrastorage.org/getpro/habr/post_images/ce9/18e/120/ce918e12042809a8201c21660905ed23.png"></a> <br><br>  Direct cache <br><br>  Consider different row sizes.  - shows the maximum number of misses that the processor will spend to access the elements of the array during the next pass through the line. <br><br> <a href="http://hostingkartinok.com/" title="Upload a photo"><img src="https://habrastorage.org/getpro/habr/post_images/458/0ab/a54/4580aba5481bf6e70e4d0f47635a62f2.jpg"></a> <br><br> <a href="http://hostingkartinok.com/" title="upload picture"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/44f/f38/d6b44ff380939aadae05777032f8a6e8.jpg"></a> <br><br> <a href="http://hostingkartinok.com/" title="image hosting"><img src="https://habrastorage.org/getpro/habr/post_images/e05/011/caa/e05011caad7142f76d042114ebcd6372.jpg"></a> <br><br> <a href="http://hostingkartinok.com/" title="place photo"><img src="https://habrastorage.org/getpro/habr/post_images/89d/a38/708/89da387081ec85ed400377160f59cf57.jpg"></a> <br><br>  As you can see, the memory access time does not increase dramatically, but as the amount of data increases.  As soon as the size of the data exceeds the size of the cache, then there will be misses with each memory access. <br><br>  Therefore, the associative cache will have a vertical step, while the direct cache will gradually increase up to double the cache size.  A multiple associative cache would be a middle case, a ‚Äúbump‚Äù, if only because access time cannot be better than a direct one. <br><br>  If we talk about memory, the fastest is cache, followed by operational, the slowest is swap, we will not talk about it in the future.  In turn, different cache levels (as a rule, processors today have 2-3 cache levels) have different memory response rates: the higher the level, the slower the response speed.  And therefore, if the line is placed in the first level of the cache (which is by the way fully associative), the response time will be less than that of the line significantly larger than the sizes of the first level cache.  Therefore, on the graph of memory response time from the size of the line there will be several plateaus - a plateau * of memory response, and a plateau caused by different levels of cache. <br><br>  * The function plateau is {i: x, f (xi) - f (xi + 1) &lt;eps: eps ‚Üí 0} <br><br><h4>  Let's start the implementation </h4><br>  For implementation we will use C (ANSI C99). <br><br>  Quickly written code, the usual passage through the rows of different lengths, less than 10mb, performed many times.  (We will give small pieces of the program that carry the meaning). <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; L_STR; j++) A[j]++; }</code> </pre> <br><br>  We look at the chart - and we see one big step.  But after all, in theory everything turns out, just wonderful.  So you need to understand: why is this happening?  And how to fix it? <br><br> <a href="http://hostingkartinok.com/" title="photo hosting"><img src="http://s2.hostingkartinok.com/uploads/images/2012/07/3b749b18438ed3a3bed0c53db7766aaa.png"></a> <br><br>  Obviously, this can happen for two reasons: either there is no memory cache in the processor, or the processor guesses memory references so well.  Since the first option is closer to fiction, the reason for all is a good prediction of addresses. <br><br>  The fact is that today far from the top processors, in addition to the principle of spatial locality, they also predict an arithmetic progression in the order of memory access.  Therefore, you need to randomize memory accesses. <br><br>  The length of a randomized array should be comparable to the length of the main line in order to get rid of the large granularity of calls, just the length of the array should not be a power of two, because of this there were ‚Äúoverlaps‚Äù - which can result in outliers.  It is best to set the constant granularity, including, if the granularity is a prime number, then the effects of overlays can be avoided.  And the length of the randomized array is a function of the length of the string. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; j; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; L; m++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; M; x++){ v = A[ random[x] + m ]; } } }</code> </pre><br><br>  Then we surprised so long-awaited ‚Äúpicture‚Äù, which was spoken about at the beginning. <br><br> <a href="http://hostingkartinok.com/" title="image hosting"><img src="http://s2.hostingkartinok.com/uploads/images/2012/07/d0e1d89e8e1c822317043ae3605f7728.png"></a> <br><br> <a href="http://hostingkartinok.com/" title="picture hosting"><img src="http://s2.hostingkartinok.com/uploads/images/2012/07/8a2580f87386004778a702b7c3c0686d.png"></a> <br><br>  The program is divided into 2 parts - test and data processing.  Write a script in 3 lines to run or 2 times to start handles decide for yourself. <br><br>  Listing file size. With Linux <br><habracut><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #define T char #define MAX_S 0x1000000 #define L 101 volatile TA[MAX_S]; int m_rand[0xFFFFFF]; int main (){ static struct timespec t1, t2; memset ((void*)A, 0, sizeof (A)); srand(time(NULL)); int v, M; register int i, j, k, m, x; for (k = 1024; k &lt; MAX_S;) { M = k / L; printf("%g\t", (k+M*4)/(1024.*1024)); for (i = 0; i &lt; M; i++) m_rand[i] = L * i; for (i = 0; i &lt; M/4; i++) { j = rand() % M; x = rand() % M; m = m_rand[j]; m_rand[j] = m_rand[i]; m_rand[i] = m; } if (k &lt; 100*1024) j = 1024; else if (k &lt; 300*1024) j = 128; else j = 32; clock_gettime (CLOCK_PROCESS_CPUTIME_ID, &amp;t1); for (i = 0; i &lt; j; i++) { for (m = 0; m &lt; L; m++) { for (x = 0; x &lt; M; x++){ v = A[ m_rand[x] + m ]; } } } clock_gettime (CLOCK_PROCESS_CPUTIME_ID, &amp;t2); printf ("%g\n",1000000000. * (((t2.tv_sec + t2.tv_nsec * 1.e-9) - (t1.tv_sec + t1.tv_nsec * 1.e-9)))/(double)(L*M*j)); if (k &gt; 100*1024) k += k/16; else k += 4*1024; } return 0; }</span></span></span></span></code> </pre><br><br><br>  Listing file size.with Windows <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; using namespace std; #define T char #define MAX_S 0x1000000 #define L 101 volatile TA[MAX_S]; int m_rand[0xFFFFFF]; int main (){ LARGE_INTEGER freq; LARGE_INTEGER time1; LARGE_INTEGER time2; QueryPerformanceFrequency(&amp;freq); memset ((void*)A, 0, sizeof (A)); srand(time(NULL)); int v, M; register int i, j, k, m, x; for (k = 1024; k &lt; MAX_S;) { M = k / L; printf("%g\t", (k+M*4)/(1024.*1024)); for (i = 0; i &lt; M; i++) m_rand[i] = L * i; for (i = 0; i &lt; M/4; i++) { j = rand() % M; x = rand() % M; m = m_rand[j]; m_rand[j] = m_rand[i]; m_rand[i] = m; } if (k &lt; 100*1024) j = 1024; else if (k &lt; 300*1024) j = 128; else j = 32; QueryPerformanceCounter(&amp;time1); for (i = 0; i &lt; j; i++) { for (m = 0; m &lt; L; m++) { for (x = 0; x &lt; M; x++){ v = A[ m_rand[x] + m ]; } } } QueryPerformanceCounter(&amp;time2); time2.QuadPart -= time1.QuadPart; double span = (double) time2.QuadPart / freq.QuadPart; printf ("%g\n",1000000000. * span/(double)(L*M*j)); if (k &gt; 100*1024) k += k/16; else k += 4*1024; } return 0; }</span></span></span></span></code> </pre> <br><br><br>  In general, I think everything is clear, but I would like to discuss a few points. <br><br>  Array A is declared as volatile - this directive guarantees that there will always be references to array A, that is, neither the optimizer nor the compiler will ‚Äúcut out‚Äù them.  It is also worthwhile to stipulate that the entire computational load is performed before the time measurement, which allows us to reduce the background effect. <br><br>  The file is translated into assembler on Ubuntu 12.04 and the gcc 4.6 compiler - the cycles are preserved. <br><br><h4>  Data processing </h4><br>  For data processing it is logical to use derivatives.  And despite the fact that with an increase in the order of differentiation, the noise increases, the second derivative and its properties will be used.  No matter how the second derivative is noisy, we are only interested in the sign of the second derivative. <br><br>  We find all points where the second derivative is greater than zero (with some error because the second derivative, besides being considered numerically, is very noisy).  We set the function of dependence of the sign of the second derivative of the function on the size of the cache.  The function takes the value 1 at the points where the sign of the second derivative is greater than zero, and zero if the sign of the second derivative is less than or equal to zero. <br><br>  Points of "take-off" - the beginning of each step.  Also, before processing the data, it is necessary to remove single outliers, which do not change the semantic load of the data, but create noticeable noise. <br><br>  Listing of the data_pr.c file <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; double round (double x) { int mul = 100; if (x &gt; 0) return floor(x * mul + .5) / mul; else return ceil(x * mul - .5) / mul; } float size[112], time[112], der_1[112], der_2[112]; int main(){ size[0] = 0; time[0] = 0; der_1[0] = 0; der_2[0] = 0; int i, z = 110; for (i = 1; i &lt; 110; i++) scanf("%g%g", &amp;size[i], &amp;time[i]); for (i = 1; i &lt; z; i++) der_1[i] = (time[i]-time[i-1])/(size[i]-size[i-1]); for (i = 1; i &lt; z; i++) if ((time[i]-time[i-1])/(size[i]-size[i-1]) &gt; 2) der_2[i] = 1; else der_2[i] = 0; //comb for (i = 0; i &lt; z; i++) if (der_2[i] == der_2[i+2] &amp;&amp; der_2[i+1] != der_2[i]) der_2[i+1] = der_2[i]; for (i = 0; i &lt; z-4; i++) if (der_2[i] == der_2[i+3] &amp;&amp; der_2[i] != der_2[i+1] &amp;&amp; der_2[i] != der_2[i+2]) { der_2[i+1] = der_2[i]; der_2[i+2] = der_2[i]; } for (i = 0; i &lt; z-4; i++) if (der_2[i] == der_2[i+4] &amp;&amp; der_2[i] != der_2[i+1] &amp;&amp; der_2[i] != der_2[i+2] &amp;&amp; der_2[i] != der_2[i+3]) { der_2[i+1] = der_2[i]; der_2[i+2] = der_2[i]; der_2[i+3] = der_2[i]; } // int k = 1; for (i = 0; i &lt; z-4; i++){ if (der_2[i] == 1) printf("L%d = %g\tMb\n", k++, size[i]); while (der_2[i] == 1) i++; } return 0; }</span></span></span></span></code> </pre><br><br><h4>  Tests </h4><br>  CPU / OS / kernel version / compiler / compilation keys - will be listed for each test. <br><br><ul><li><br>  Intel Pentium CPU P6100 @ 2.00GHz / Ubuntu 12.04 / 3.2.0-27-generic / gcc -Wall -O3 size.c -lrt <br><br>  L1 = 0.05 Mb <br>  L2 = 0.2 Mb <br>  L3 = 2.7 Mb <br></li><li>  I will not give all the good tests, let's talk about the "Rake" <br></li></ul><br><br><h4>  Let's talk about "rakes" </h4><br>  A rake was discovered when processing data on an Intel Xeon 2.4 / L2 server processor = 512 kb / Windows Server 2008 <br><br> <a href="http://hostingkartinok.com/" title="upload picture"><img src="http://s2.hostingkartinok.com/uploads/images/2012/07/1139cbb1d2120e6cf3df8780318da694.png"></a> <br><br>  The problem lies in the small number of points falling on the plateau interval, respectively, the jump of the second derivative is imperceptible and is taken as noise. <br><br>  It is possible to solve this problem using the least squares method, or to run tests in the course of determining the plateau zones. <br><br>  I would like to hear your suggestions on how to solve this problem. <br><br><h4>  Bibliography </h4><br><ul><li>  Makarov A.V.  Computer Architecture and Low Level Programming. </li><li>  Ulrich Drepper What every programmer should know about memory </li></ul></habracut></div><p>Source: <a href="https://habr.com/ru/post/148839/">https://habr.com/ru/post/148839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148833/index.html">Dropbox: Base with email addresses was stolen from employee account</a></li>
<li><a href="../148835/index.html">Sony Xperia go review</a></li>
<li><a href="../148836/index.html">Polymer VS bacteria. Who will win?</a></li>
<li><a href="../148837/index.html">UIImage, EXIF ‚Äã‚Äãand a bit of runtime</a></li>
<li><a href="../148838/index.html">I retrain people to java programmers</a></li>
<li><a href="../148840/index.html">Font for registration number plates (license plates)</a></li>
<li><a href="../148841/index.html">Apache Maven - web application</a></li>
<li><a href="../148842/index.html">Simplify your life with Sublime Text 2</a></li>
<li><a href="../148843/index.html">Database Migration in Zend Framework: Akrabat_Db_Schema_Manager</a></li>
<li><a href="../148844/index.html">The first experience of writing plugins for Autocad in C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>