<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do it yourself search on the site</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably many have ever wondered how to do a search on the site? Of course, for large sites with a large amount of content, search is simply an indisp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do it yourself search on the site</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a19/0af/f04/a190aff046d545b58baacc9601b77f2f.jpg"><br><br>  Probably many have ever wondered how to do a search on the site?  Of course, for large sites with a large amount of content, search is simply an indispensable thing.  In most cases, the user, having visited your site for the first time in search of something important, will not understand the navigation bars, drop-down menus and other navigation elements, and in a hurry will try to find something similar to the search bar.  And if there is no such luxury on the site, or it does not cope with the search query, then the visitor will simply close the tab.  But the article is not about the meaning of the search for the site and not about the psychology of visitors.  I'll tell you how to implement a small full-text search algorithm, which I hope will save novice developers from headaches. <br><a name="habracut"></a><br>  The reader may ask: why write everything from scratch, if everything has been written for a long time?  Yes, major search engines have an API, there are some cool projects like Sphinx and Apache Solr.  But each of these solutions has its advantages and disadvantages.  Using the services of search engines, such as Google and Yandex, you will receive a lot of buns, such as a powerful morphological analysis, correction of typos and errors in the query, the recognition of an incorrect keyboard layout, but there will not do without a spoon of tar.  Firstly, such a search does not integrate into the structure of the site - it is external, and you cannot tell it which data is most important and which is not very.  Secondly, the site content is indexed only at a certain interval, which depends on the selected search engine, so that if something is updated on the site, you will have to wait for the moment when these changes get into the index and become available in the search.  Sphinx and Apache Solr do much better with integration and indexing, but not every hosting will allow you to run from. <br><br>  Nothing prevents you from writing a search engine yourself.  It is assumed that the site runs on PHP in conjunction with some database server, such as MySQL.  Let's first define what is required from the search on the site? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Search based on language morphology.</b>  Regardless of the case, ending and <br>  other delights of the great and mighty language search must find what you need <br>  to the user.  In other words, "apples", "apples", "apples" are the forms of one and the same <br>  same words "apple" that need to be considered in the search algorithm.  One way <br>  achieving this goal is to bring each word search query and words <br>  site content to the basic form. <br></li><li>  <b>Ability to specify the search context.</b>  That is, the ability to choose <br>  the content of the site, within which the search algorithm will work, and also determine <br>  significance for each of the limits.  For example, consider an online store.  Supposed to <br>  that the search query will most often contain the name of the desired product, so a search by <br>  product names will have the highest priority.  As a next priority, you can <br>  select a search by product properties, then search by description. <br></li><li>  <b>Indexing site content.</b>  Imagine the situation: at the same time about 30 people <br>  perform search queries.  Server accepts every connection, flow control <br>  passed to PHP interpreter.  With each request, the search is reinitialized. <br>  engine, re-breaks the contents of the site ... It is difficult to say how much time and <br>  resources will be required to handle all these requests.  It is in order not to <br>  to do the same job a hundred times, an indexing technology was invented. <br>  Indexing is performed only when changing or adding content to the site. <br>  and the search is done by index, not by content. <br></li><li>  <b>Ranking mechanism.</b>  Ranking search results is the sorting of search results based on an assessment of the significance of the data found.  For example, in some blog, the search query "space" is executed.  This word is contained in two articles: the first 16 times, the second - 5 times.  Most likely, the first article will be of greater importance for the initiator of the search.  Also, for each type of site content during indexing, a certain coefficient is set, which will affect its position in the search results. <br></li></ul><br><br>  Now a few words about what we have to implement: <br><ul><li>  morphological analyzer, </li><li>  ranking algorithm </li><li>  indexing algorithm </li><li>  search algorithm. </li></ul><br><br>  At the end of the article, an example of the search implementation will be shown on the example of a simple online store.  Those who are too lazy to study all this and just need a ready-made search engine, you can safely take the engine from the GitHub <a href="https://github.com/axilirator/firewind">FireWind</a> repository. <br><br><h4>  Principle of operation </h4><br>  From the back end, the search works like this: <br><ul><li>  site content is indexed, </li><li>  the user sends a request </li><li>  service parts of speech are excluded from the request, </li><li>  the resulting string is broken down into an array of words translated into a basic form, </li><li>  search for each word of the resulting array is carried out in the index, </li><li>  search results are ranked, sorted and given to the user. </li></ul><br><br><h4>  Training </h4><br>  The task is set, now you can go to the point.  I use Linux as a working OS, but I will try not to use its exotic features so that Windows lovers can ‚Äúbuild‚Äù the search engine by analogy.  All you need is knowledge of the basics of PHP and the ability to handle MySQL.  Go! <br><br>  Our project will consist of a core where all vital functions will be collected, as well as a module for morphological analysis and text processing.  To begin with, we will create the root folder of the firewind project, and in it we will create the core.php file - it will be the core. <br><pre><code class="bash hljs">$ mkdir firewind $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> firewind $ touch core.php</code> </pre> <br><br>  Now we arm ourselves with our favorite text editor and prepare the frame: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firewind</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $VERSION = <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  // } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  Here we have created a main class that can be used on your sites.  At this preparatory part ends, it's time to move on. <br><br><h4>  Morphological analyzer </h4><br>  Russian language is a rather complicated thing, which pleases with its diversity and shocks foreigners with constructions, such as ‚Äúyes no, probably‚Äù.  Teaching a car to understand it, and any other language, is a rather difficult task.  The most successful in this regard are search companies, such as Google and Yandex, which constantly improve their algorithms and keep them secret.  We'll have to do something different, simpler.  Fortunately, there is no need to reinvent the wheel - everything has already been done for us.  Meet, <a href="http://sourceforge.net/projects/phpmorphy/">phpMorphy</a> is a morphological analyzer that supports Russian, English and German.  More detailed information can be obtained <a href="http://phpmorphy.sourceforge.net/dokuwiki/">here</a> , but we are only interested in its two possibilities: lemmatization, that is, obtaining the basic form of a word, and obtaining grammatical information about a word (gender, number, case, part of speech, etc.). <br><br>  Need a library and a dictionary for it.  All this stuff can be found <a href="http://sourceforge.net/projects/phpmorphy/files/">here</a> .  The library is located in the eponymous folder "phpmorphy", dictionaries are located in "phpmorphy-dictionaries".  Download the latest version of the project in the root folder and unpack: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   $ unzip phpmorphy-0.3.7.zip $ mv phpmorphy-0.3.7 phpmorphy #    phpmorphy/dicts $ unzip morphy-0.3.x-ru_RU-withjo-utf-8.zip -d phpmorphy/dicts/ #    $ rm phpmorphy-0.3.7.zip morphy-0.3.x-ru_RU-withjo-utf-8.zip</span></span></code> </pre><br><br>  Fine!  The library is ready to use.  It's time to write a "shell", which abstracts the work with phpMorphy.  To do this, create another morphyus.php file in the root directory: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>.<span class="hljs-string"><span class="hljs-string">'/phpmorphy/src/common.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">morphyus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $phpmorphy = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $regexp_word = <span class="hljs-string"><span class="hljs-string">'/([a-z-0-9]+)/ui'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $regexp_entity = <span class="hljs-string"><span class="hljs-string">'/&amp;([a-zA-Z0-9]+);/'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $directory = <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>.<span class="hljs-string"><span class="hljs-string">'/phpmorphy/dicts'</span></span>; $language = <span class="hljs-string"><span class="hljs-string">'ru_RU'</span></span>; $options[ <span class="hljs-string"><span class="hljs-string">'storage'</span></span> ] = PHPMORPHY_STORAGE_FILE; <span class="hljs-comment"><span class="hljs-comment">//   // $this-&gt;phpmorphy = new phpMorphy( $directory, $language, $options ); } /** *      * * @param {string} content      * @param {boolean} filter   HTML-   * @return {array}   */ public function get_words( $content, $filter=true ) { //  HTML-  HTML- // if ( $filter ) { $content = strip_tags( $content ); $content = preg_replace( $this-&gt;regexp_entity, ' ', $content ); } //     // $content = mb_strtoupper( $content, 'UTF-8' ); //     // $content = str_ireplace( '', '', $content ); //     // preg_match_all( $this-&gt;regexp_word, $content, $words_src ); return $words_src[ 1 ]; } /** *    * * @param {string} word   * @param {array|boolean}    ,  false */ public function lemmatize( $word ) { //     // $lemmas = $this-&gt;phpmorphy-&gt;lemmatize( $word ); return $lemmas; } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  So far, only two methods have been implemented.  get_words breaks the text into an array of words, while filtering HTML tags and entities like "&amp; nbsp;".  The lemmatize method returns an array of lemmas of the word, or false, if none were found. <br><br><h4>  The mechanism of ranking at the level of morphology </h4><br>  Let's look at a language unit like a sentence.  The most important part of the sentence is the basis in the form of the subject and / or predicate.  Most often the subject is expressed by the noun, and the predicate is a verb.  Secondary members are mainly used to clarify the meaning of the base.  In different sentences, the same parts of speech sometimes have completely different meanings, and today only a person can most accurately assess this meaning in the context of a text.  However, it is still possible to programmatically evaluate the meaning of a word, although not so accurately.  In this case, the ranking algorithm should be based on the so-called text profile, which is determined by its author.  A profile is an associative array, the keys of which are parts of speech, and the values, respectively, are the rank (or weight) of each of them.  I will show an example of the profile in the conclusion, but for now we will try to translate these reflections into the PHP language, adding another method to the morphyus class: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>.<span class="hljs-string"><span class="hljs-string">'/phpmorphy/src/common.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">morphyus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $phpmorphy = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $regexp_word = <span class="hljs-string"><span class="hljs-string">'/([a-z-0-9]+)/ui'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $regexp_entity = <span class="hljs-string"><span class="hljs-string">'/&amp;([a-zA-Z0-9]+);/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... // /** *    * * @param {string} word   * @param {array} profile   * @return {integer}    0  5 */ public function weigh( $word, $profile=false ) { //     // $partsOfSpeech = $this-&gt;phpmorphy-&gt;getPartOfSpeech( $word ); //    // if ( !$profile ) { $profile = [ //    // '' =&gt; 0, '' =&gt; 0, '' =&gt; 0, '' =&gt; 0, '' =&gt; 0, '' =&gt; 0, //     // '' =&gt; 5, '' =&gt; 5, '' =&gt; 3, '' =&gt; 3, //    // 'DEFAULT' =&gt; 1 ]; } //        // if ( !$partsOfSpeech ) { return $profile[ 'DEFAULT' ]; } //   // for ( $i = 0; $i &lt; count( $partsOfSpeech ); $i++ ) { if ( isset( $profile[ $partsOfSpeech[ $i ] ] ) ) { $range[] = $profile[ $partsOfSpeech[ $i ] ]; } else { $range[] = $profile[ 'DEFAULT' ]; } } return max( $range ); } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br><h4>  Indexing site content </h4><br><img src="https://habrastorage.org/files/00d/b2b/fb5/00db2bfb5e9c4ff98c5a4b608495dfea.jpg"><br><br>  As mentioned above, indexing significantly speeds up the execution of a search query, since the search engine does not need to process the content every time ‚Äî the search is performed by index.  But what does happen when indexing?  If in order, then: <br><br><ul><li>  First, an array of words is formed from the text, and this is done using the get_words method. </li><li>  According to the profile, insignificant parts of speech are discarded from the text. </li><li>  Significant evaluated on a five-point scale, using the method of weigh. </li><li>  For each owl, a search is made for lemmas, in other words, basic forms. </li><li>  Calculate the number of repetitions of each word and the total rank. </li><li>  All data is written to the object and in the form of JSON is written to the database. </li></ul><br><br>  The result is an object of the following format: <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"range"</span></span> : <span class="hljs-string"><span class="hljs-string">"&lt;   &gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"words"</span></span> : [ <span class="hljs-comment"><span class="hljs-comment">//    // { "source" : "&lt;  &gt;", "range" : "&lt; &gt;", "count" : "&lt;     &gt;", "weight" : "&lt;    &gt;", "basic" : [ //    // ] } ] }</span></span></code> </pre><br><br>  We write the initializer and the first method of the search engine core: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'morphyus.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firewind</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $VERSION = <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $morphyus; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;morphyus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> morphyus; } <span class="hljs-comment"><span class="hljs-comment">/** *    * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> {string} content    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> {integer} [range]     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> {object}   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $content, $range=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ $index = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> stdClass; $index-&gt;range = $range; $index-&gt;words = []; <span class="hljs-comment"><span class="hljs-comment">//     // $words = $this-&gt;morphyus-&gt;get_words( $content ); foreach ( $words as $word ) { //    // $weight = $this-&gt;morphyus-&gt;weigh( $word ); if ( $weight &gt; 0 ) { //     // $length = count( $index-&gt;words ); //       // for ( $i = 0; $i &lt; $length; $i++ ) { if ( $index-&gt;words[ $i ]-&gt;source === $word ) { //       // $index-&gt;words[ $i ]-&gt;count++; $index-&gt;words[ $i ]-&gt;range = $range * $index-&gt;words[ $i ]-&gt;count * $index-&gt;words[ $i ]-&gt;weight; //    // continue 2; } } //        // $lemma = $this-&gt;morphyus-&gt;lemmatize( $word ); if ( $lemma ) { //      // for ( $i = 0; $i &lt; $length; $i++ ) { //       // if ( $index-&gt;words[ $i ]-&gt;basic ) { $difference = count( array_diff( $lemma, $index-&gt;words[ $i ]-&gt;basic ) ); //         // if ( $difference === 0 ) { $index-&gt;words[ $i ]-&gt;count++; $index-&gt;words[ $i ]-&gt;range = $range * $index-&gt;words[ $i ]-&gt;count * $index-&gt;words[ $i ]-&gt;weight; //    // continue 2; } } } } //      ,   , // //     // $node = new stdClass; $node-&gt;source = $word; $node-&gt;count = 1; $node-&gt;range = $range * $weight; $node-&gt;weight = $weight; $node-&gt;basic = $lemma; $index-&gt;words[] = $node; } } return $index; } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  Now, when adding or changing data in tables, it is enough to simply call this function to index them, but this is not necessary: ‚Äã‚Äãthe indexing may be delayed.  The first argument of the make_index method is the source text, the second is the coefficient of significance of the data being indexed.  The rank of each word, by the way, is calculated by the formula: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $range = &lt; &gt; * &lt;    &gt; * &lt; &gt;; <span class="hljs-comment"><span class="hljs-comment">//     : // $index-&gt;words[ $i ]-&gt;range = $range * $index-&gt;words[ $i ]-&gt;count * $index-&gt;words[ $i ]-&gt;weight; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br><h4>  Storage of indexed data </h4><br>  Obviously, the index must be stored somewhere, and even attached to the original data.  The most suitable place for them will be the database.  If the content of files is indexed, then you can create a separate table in the database, which will contain an index for each file, and for content that is already stored in the database, you can add another type field to the table structure.  This approach will allow you to separate content types when searching, for example, titles and description of articles in the case of a blog. <br><br>  Unresolved is only the question of the format of the indexed content, because make_index returns the object, and so simply in the database or file it is not recorded.  You can use JSON and store it in fields of type LONGTEXT, you can BSON or CBOR, using the data type LONGBLOB.  The latter two formats allow you to present data in a more compact form than the first. <br><br>  As the saying goes, ‚Äúthe master is the master,‚Äù so you decide where and how everything will be stored. <br><br><h4>  Benchmark </h4><br>  Let's check what we did.  I took the text of my favorite article <a href="http://habrahabr.ru/post/112491/">‚ÄúDark Matter of the Internet‚Äù</a> , namely the contents of the #content html_format node and saved it in a separate file. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'../src/core.php'</span></span>; $firewind = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> firewind; <span class="hljs-comment"><span class="hljs-comment">//    // $source = file_get_contents( './source.html' ); //    // $begin_time = microtime( true ); echo "Indexing started: $begin_time\n"; //  // $index = $firewind-&gt;make_index( $source ); //    // $finish_time = microtime( true ); echo "Indexing finished: $finish_time\n"; //  // $total_time = $finish_time - $begin_time; echo "Total time: $total_time\n"; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  On my configuration machine: <br>  CPU: Intel Core i7-4510U @ 2.00GHz, 4M Cache <br>  RAM: 2x4096 Mb <br>  OS: Ubuntu 14.04.1 LTS, x64 <br>  PHP: 5.5.9-1ubuntu4.5 <br><br>  Indexing took about a second: <br><pre> <code class="bash hljs">$ php benchmark.php Indexing started: 1417343592.3094 Indexing finished: 1417343593.5604 Total time: 1.2510349750519</code> </pre><br><br>  I think quite a good result. <br><br><h4>  Implementation of the search </h4><br>  There remains the last and most important method, the search method.  The method takes the search query index as the first argument, and the content index in which the search is performed as the second argument.  As a result of the execution, the total rank is calculated, calculated on the basis of the rank of the words found, or 0 if nothing was found.  This will sort the search results. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'morphyus.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firewind</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $VERSION = <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $morphyus; <span class="hljs-comment"><span class="hljs-comment">// ... // /** *         * * @param {object} target   * @param {object} source ,     * @return {integer}       */ public function search( $target, $index ) { $total_range = 0; //    // foreach ( $target-&gt;words as $target_word ) { //    // foreach ( $index-&gt;words as $index_word ) { if ( $index_word-&gt;source === $target_word-&gt;source ) { $total_range += $index_word-&gt;range; } else if ( $index_word-&gt;basic &amp;&amp; $target_word-&gt;basic ) { //         // $index_count = count( $index_word -&gt;basic ); $target_count = count( $target_word -&gt;basic ); for ( $i = 0; $i &lt; $target_count; $i++ ) { for ( $j = 0; $j &lt; $index_count; $j++ ) { if ( $index_word-&gt;basic[ $j ] === $target_word-&gt;basic[ $i ] ) { $total_range += $index_word-&gt;range; continue 2; } } } } } } return $total_range; } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  Everything!  Search engine ready for use.  But there is one thing ... In fact, this is not a genie-wizard, and just throwing it on your website you will not get anything.  It needs to be integrated, and this process largely depends on the architecture of your site.  Consider this process on the example of a small online store. <br><br><h4>  The implementation of the search on the example of an online store </h4><br>  Suppose information about the products sold is stored in the production table: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`production`</span></span> ( <span class="hljs-string"><span class="hljs-string">`uid`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-comment"><span class="hljs-comment">--   `name` VARCHAR(45) NOT NULL, --   `manufacturer` VARCHAR(45) NOT NULL, --  `price` INT NOT NULL, --   `keywords` TEXT NULL, --    PRIMARY KEY ( `uid` ) ); SHOW COLUMNS FROM `production`; +--------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------------+-------------+------+-----+---------+-------+ | uid | int(11) | NO | PRI | NULL | | | name | varchar(45) | NO | | NULL | | | manufacturer | varchar(45) | NO | | NULL | | | price | int(11) | NO | | NULL | | | keywords | text | YES | | NULL | | +--------------+-------------+------+-----+---------+-------+</span></span></code> </pre><br><br>  And the description in the description table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`description`</span></span> ( <span class="hljs-string"><span class="hljs-string">`uid`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-comment"><span class="hljs-comment">--   `fid` INT NOT NULL, --        `description` LONGTEXT NOT NULL, --   `index` TEXT NULL, --   PRIMARY KEY ( `uid` ) ); SHOW COLUMNS FROM `description`; +-------------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------------+----------+------+-----+---------+-------+ | uid | int(11) | NO | PRI | NULL | | | fid | int(11) | NO | | NULL | | | description | longtext | NO | | NULL | | | index | text | YES | | NULL | | +-------------+----------+------+-----+---------+-------+</span></span></code> </pre><br><br>  The field production.keywords will contain the index of product keywords, description.index will contain an indexed description.  And all this will be stored in JSON format. <br><br>  Here is an example of the function of adding a new product: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'firewind/core.php'</span></span>; $firewind = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> firewind; $connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mysqli( <span class="hljs-string"><span class="hljs-string">'host'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, <span class="hljs-string"><span class="hljs-string">'database'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $connection-&gt;connect_error ) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>( <span class="hljs-string"><span class="hljs-string">'Cannot connect to database.'</span></span> ); } $connection-&gt;set_charset( <span class="hljs-string"><span class="hljs-string">'UTF8'</span></span> ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $name, $manufacturer, $price, $description, $keywords )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $firewind, $connection; <span class="hljs-comment"><span class="hljs-comment">//    // $description_index = $firewind-&gt;make_index( $description ); $description_index = json_encode( $description_index ); //    // $keywords_index = $firewind-&gt;make_index( $keywords, 2 ); $keywords_index = json_encode( $keywords_index ); //   // $production_query = $connection-&gt;prepare( "INSERT INTO `production` ( `name`, `manufacturer`, `price`, `keywords` ) VALUES ( ?, ?, ?, ? )" ); $description_query = $connection-&gt;prepare( "INSERT INTO `description` ( `fid`, `description`, `index` ) VALUES ( LAST_INSERT_ID(), ?, ? )" ); if ( !$production_query || !$description_query ) { die( "Cannot prepare requests!\n" ); } if ( //   // $production_query -&gt; bind_param( 'ssis', $name, $manufacturer, $price, $keywords_index ) &amp;&amp; $description_query -&gt; bind_param( 'ss', $description, $description_index ) &amp;&amp; //   // $production_query -&gt; execute() &amp;&amp; $description_query -&gt; execute() ) { //     // echo( "Product successfully added!\n" ); //   // $production_query -&gt; close(); $description_query -&gt; close(); return true; } else { die( "An error occurred while executing query...\n" ); } } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  Here, the search engine was integrated into the function of adding a new product to the store.  And now the search request handler: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'../src/core.php'</span></span>; $firewind = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> firewind; $connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mysqli( <span class="hljs-string"><span class="hljs-string">'host'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, <span class="hljs-string"><span class="hljs-string">'database'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $connection-&gt;connect_error ) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>( <span class="hljs-string"><span class="hljs-string">'Cannot connect to database.'</span></span> ); } $connection-&gt;set_charset( <span class="hljs-string"><span class="hljs-string">'UTF8'</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//   // $query = isset( $_GET[ 'query' ] ) ? trim( $_GET[ 'query' ] ) : false; if ( $query ) { //    // $query_index = $firewind-&gt;make_index( $query ); //   // $production = $connection-&gt;query(" SELECT p.`uid`, p.`name`, p.`keywords`, d.`index` FROM `production` p, `description` d WHERE p.`uid` = d.`uid` "); if ( !$production ) { die( "Cannot get production info.\n" ); } //   // while ( $product = $production-&gt;fetch_assoc() ) { //   // $keywords = json_decode( $product[ 'keywords' ] ); $index = json_decode( $product[ 'index' ] ); $range = $firewind-&gt;search( $query_index, $keywords ); $range += $firewind-&gt;search( $query_index, $index ); if ( $range &gt; 0 ) { $result[ $product[ 'uid' ] ] = $range; } } //  -  // if ( isset( $result ) ) { //    // arsort( $result ); //   // $i = 1; foreach ( $result as $uid =&gt; $range ) { printf( "#%d. Found product with id %d and range %d.\n", $i++, $uid, $range ); } } else { echo( "Sorry, no results found.\n" ); } } else { echo( "Query cannot be empty. Try again.\n" ); } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br>  This script accepts the search query as a GET parameter query and performs a search.  As a result, the found store products are displayed. <br><br><h4>  Conclusion </h4><br>  The article described one of the options for implementing a search for the site.  This is the very first version of it, so I will only be glad to know your comments, opinions and suggestions.  Join my project on Github: <a href="https://github.com/axilirator/firewind">https://github.com/axilirator/firewind</a> .  There are plans to add a bunch of other features there, such as caching search queries, hints when entering a search query, and a letter-by-letter comparison algorithm that will help deal with typos. <br><br>  Thank you all for your attention, well, with the day of information security! </div><p>Source: <a href="https://habr.com/ru/post/244561/">https://habr.com/ru/post/244561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244545/index.html">Expressive javascript: drawing on canvas</a></li>
<li><a href="../244551/index.html">The digest of interesting materials for the mobile developer # 81 (November 24-30)</a></li>
<li><a href="../244553/index.html">How we select2 in helper wrapped</a></li>
<li><a href="../244557/index.html">A tale about how tech support Veeam introduced gamification</a></li>
<li><a href="../244559/index.html">Brief history of hacking. A story from the head of information security at Yandex</a></li>
<li><a href="../244563/index.html">"Mathematics is one of the forms of art": post to the centenary of the birth of Martin Gardner</a></li>
<li><a href="../244565/index.html">The slowest x86 instruction</a></li>
<li><a href="../244571/index.html">Consulo: ~ 1000 kommitov, or as the autumn passed</a></li>
<li><a href="../244573/index.html">Eggs.Variant - Part I</a></li>
<li><a href="../244575/index.html">Swift Error Handling - Sword and Magic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>