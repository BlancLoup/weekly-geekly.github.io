<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing proposals for Russian language patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are several parsers suitable for the Russian language. Some of them can even parse like SyntaxNet , MaltParser and AOT : 

 ... or reveal facts ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing proposals for Russian language patterns</h1><div class="post__text post__text-html js-mediator-article">  There are <a href="https://nlpub.ru/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">several parsers</a> suitable for the Russian language.  Some of them can even parse like <a href="https://habrahabr.ru/post/317564/">SyntaxNet</a> , <a href="https://habrahabr.ru/post/148124/">MaltParser</a> and <a href="http://aot.ru/cgi-bin/synan.py">AOT</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/en/qj/6t/enqj6tslz5_mer2bygbxyns_rr4.png" alt="Mom washed plastic window frame"></div><br>  ... or reveal facts like <a href="https://habrahabr.ru/company/yandex/blog/219311/">Tomita</a> . <br><br>  Looking at these parsers, I see some enormous computational complexity, memory requirements, licensing restrictions and ... the limitations of each solution, alas. <br><br>  To understand what is so complicated there, I wanted to make my own parser.  Fortunately, the weekend was long. <br><a name="habracut"></a><br><h2>  main idea </h2><br>  I thought, how do we analyze the text?  How do we separate key elements from a phrase, build relationships between words in the head? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Tomita is <a href="https://habrahabr.ru/company/yandex/blog/219311/">said</a> to be built on a GLR parser, which in turn extends an LR parser that reads the words in order, trying to build a tree of relationships between them. <br><br>  I had the idea that the text should be considered as a set of stamps, which we have a good eye on.  "A <i>white moth on a red rose</i> ", "a <i>dark sky over the blue sea</i> ", "a <i>stupid penguin shyly hides</i> " - everywhere we see a noun and the adjective relating to it.  And we understand that the "white" refers to the moth, and not to the rose.  How do we do it?  At a minimum, we see that the ‚Äúwhite‚Äù is masculine, like the ‚Äúmoth‚Äù, and the ‚Äúred‚Äù is feminine, like the rose.  In the case of "sky" and "sea", the case in which the noun is placed helps us. <br><br>  Then, finding the stamps, we combine the resulting phrase pieces into other stamps, and so, until we understand the entire phrase - ‚Äúmoth on a rose‚Äù (moth is white, rose is red), ‚Äúthe sky above the sea‚Äù (the sky is dark, the sea is blue). <br><br><h2>  Choosing the right tool. </h2><br>  That is, to search for a pattern (adjective, noun), I need to look for a couple of words in the same case, number and gender.  How?  The natural solution for characterization (gramme) in Python is to use <a href="https://pymorphy2.readthedocs.io/">pymorphy2</a> by <a href="https://habrahabr.ru/users/kmike/" class="user_link">kmike</a> <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pymorphy2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> py <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word)</span></span></span><span class="hljs-function">:</span></span> morph = py.MorphAnalyzer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> morph.parse(word) &gt;&gt;&gt; print(tags(<span class="hljs-string"><span class="hljs-string">''</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) Parse(word=<span class="hljs-string"><span class="hljs-string">''</span></span>, tag=OpencorporaTag(<span class="hljs-string"><span class="hljs-string">'ADJF,Qual femn,sing,gent'</span></span>), normal_form=<span class="hljs-string"><span class="hljs-string">''</span></span>, score=<span class="hljs-number"><span class="hljs-number">0.125</span></span>, methods_stack=((&lt;DictionaryAnalyzer&gt;, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">86</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>),)) &gt;&gt;&gt; print(tags(<span class="hljs-string"><span class="hljs-string">''</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].tag.grammemes) frozenset({<span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'ADJF'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'gent'</span></span>, <span class="hljs-string"><span class="hljs-string">'Qual'</span></span>})</code> </pre> <br>  The words 'femn', 'ADJF', 'sing', 'gent', 'Qual' are the <a href="http://pymorphy2.readthedocs.io/en/latest/user/grammemes.html">symbols for grammes adopted in pymorphy2</a> .  Designations are unique, they can be used to uniquely identify the desired characteristics of the word. <br><br><h2>  First touches on canvas </h2><br>  Now, having a tool, we create a simple template: <br><br><pre> <code class="python hljs">source = <span class="hljs-string"><span class="hljs-string">'''    #    # /  _- NOUN,nomn VERB NOUN,accs '''</span></span></code> </pre><br>  Here we are looking for a noun (NOUN) in the nominative case (nomn), followed by a verb (VERB), then a noun in the accusative case (accs).  The characteristics not described in the template are not important to us. <br><br>  Let's make it a reader: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PPattern</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__() <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nonlocal</span></span> arr, last s = s.strip() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s == <span class="hljs-string"><span class="hljs-string">''</span></span>: last = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> last <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: last = PPattern() arr.append(last) last.example = s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: last.tags = s.split() arr = [] last = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> buf = io.StringIO(src) s = buf.readline() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> s: parseLine(s) s = buf.readline() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr s = parseSource(source)</code> </pre><br>  Don't be afraid of working here through StringIO - I wanted to do streaming reading, just in case, if you need to read large texts. <br><br>  The given piece of code only reads the templates, but does nothing more.  Add the parsed text and its parsing: <br><br><pre> <code class="python hljs">source = <span class="hljs-string"><span class="hljs-string">'''    #    # /  _- NOUN,nomn VERB NOUN,accs   ADJF NOUN     #     NOUN,nomn VERB NOUN,loct '''</span></span> text = <span class="hljs-string"><span class="hljs-string">'''               '''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pymorphy2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> py <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PPattern</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkPhrase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkWordTags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tags, grams)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tags: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> grams: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkWord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tags, word)</span></span></span><span class="hljs-function">:</span></span> variants = morph.parse(word) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variants: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> checkWordTags(self.tags[nextTag].split(<span class="hljs-string"><span class="hljs-string">','</span></span>), v.tag.grammemes): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (word, v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> morph = py.MorphAnalyzer() words = text.split() nextTag = <span class="hljs-number"><span class="hljs-number">0</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words: res = checkWord(self.tags[nextTag].split(<span class="hljs-string"><span class="hljs-string">','</span></span>), w) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result.append(res) nextTag = nextTag + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextTag &gt;= len(self.tags): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pats, text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line)</span></span></span><span class="hljs-function">:</span></span> was = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pats: res = p.checkPhrase(line) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res: print(<span class="hljs-string"><span class="hljs-string">'+'</span></span>,line, p.tags, [r[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> res]) was = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> was: print(<span class="hljs-string"><span class="hljs-string">'-'</span></span>,line) buf = io.StringIO(text) s = buf.readline() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> s: s = s.strip() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s != <span class="hljs-string"><span class="hljs-string">''</span></span>: parseLine(s) s = buf.readline() patterns = parseSource(source) parseText(patterns, text)</code> </pre><br>  Pymorphy2 when analyzing a word returns an array of all possible variants, what kind of a word can it be: ‚Äúsoap‚Äù is a noun or verb.  Therefore, our task is to check all these options and choose from them such that the characteristics of the word fit the pattern.  This is done in the <b>checkWord</b> function. <br><br>  We get the result of parsing: <br><br> <code>+    ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +    ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['ADJF', 'NOUN'] ['', ''] <br> +     ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['ADJF', 'NOUN'] ['', ''] <br></code> <br>  Well, not bad for a start. <br><br><h2>  And what is all this? </h2><br>  No, of course, now it is necessary to describe the conformity of cases, childbirth, etc.  between words.  Modifying the template description: <br><br><pre> <code class="python hljs">source = <span class="hljs-string"><span class="hljs-string">''' #   ADJF NOUN -a- -b- #  ,    = a.case = b.case = a.number = b.number = a.gender = b.gender '''</span></span></code> </pre> <br>  A line for defining variables <code>-a- -b-</code> and rule lines that begin with "=" appeared.  In general, I did not bother with the syntax of templates, so each statement lives on one line, and the type of statement is determined by the first character. <br><br>  Add rule parsing to template parsing.  The rule is compiled into two lambdas - to get the value before the "=" symbol, and for to get the second value. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, names)</span></span></span><span class="hljs-function">:</span></span> dest = v.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) index = names.index(dest[<span class="hljs-number"><span class="hljs-number">0</span></span>]) dest = (eval(<span class="hljs-string"><span class="hljs-string">'lambda a: a.'</span></span> + <span class="hljs-string"><span class="hljs-string">'.'</span></span>.join(dest[<span class="hljs-number"><span class="hljs-number">1</span></span>:])), index) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dest <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   s = [x.strip('-') for x in s.split()] last.names = s elif s[0] == '=': #  s = [x for x in s[1:].split() if x != ''] dest = parseFunc(s[0],last.names) src = parseFunc(s[2],last.names) last.rules.append(((dest[1],src[1]), dest, src)) else: ...</span></span></code> </pre><br>  And we add rule checking to text parsing - just calculating lambdas and comparing their results: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>res = checkWord(self.tags[nextTag].split(<span class="hljs-string"><span class="hljs-string">','</span></span>), w) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result.append(res) usedP.add(wi) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.checkRules(usedP, result): result.remove(res) usedP.remove(wi) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: nextTag = nextTag + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextTag &gt;= len(self.tags): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result, usedP) ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, used, result)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.rules: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> max(r[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &lt; len(result): destRes = result[r[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]] destV = destRes[<span class="hljs-number"><span class="hljs-number">1</span></span>] destFunc = r[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] srcRes = result[r[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]] srcFunc = r[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] srcV = srcRes[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.checkPropRule(destFunc,destV, srcFunc, srcV): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkPropRule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, getFunc, getArgs, srcFunc, srcArgs, \ op = lambda x,y: x == y)</span></span></span><span class="hljs-function">:</span></span> v1 = getFunc(getArgs) v2 = srcFunc(srcArgs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op(v1,v2)</code> </pre><br>  Drive on classics <br><br> <code>+        ['ADJF', 'NOUN'] ['', ''] <br> +        ['ADJF', 'NOUN'] ['', ''] <br> +        ['NOUN,nomn', 'VERB', 'PREP', 'NOUN,loct'] ['', '', '', ''] <br> +        ['NOUN,nomn', 'VERB', 'PREP', 'NOUN,loct'] ['', '', '', '']</code> <br> <br>  We also introduce a rule for names: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   NOUN Name -a- -b- = a.tag.case = b.tag.case = a.tag.number = b.tag.number</span></span></code> </pre><br>  It gives analysis: <br> <code>+   -  ['NOUN', 'Name'] ['', '']</code> <br> <br><h2>  More rules, good and different </h2><br>  Everything was so good, which meant we didn't notice anything.  The parser broke down on the phrase ‚ÄúThe younger brothers Misha and Vova go to kindergarten‚Äù - he could not confirm the rule <code>= a.gender = b.gender</code> , because the ‚Äúyounger ones‚Äù have no tribal affiliation and can refer to the masculine word ‚Äúbrothers‚Äù , and to the female "sister." <br><br>  Therefore, the rule should be more complicated.  Well, since I still compile lambdas from text, you can create one instead of the two that returns the result of the check.  Then this rule can be written as an expression in pure Python-e: <br><br><pre> <code class="python hljs">= a.tag.gender <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> a.tag.gender == b.tag.gender</code> </pre> <br>  It seemed to me that Python should have a built-in tool for getting the names ‚Äúa‚Äù and ‚Äúb‚Äù involved in the expression.  The premonition was not deceived, a small reading of help and documentation led me to the AST parser, which had everything I needed, and the following code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ast <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr, names)</span></span></span><span class="hljs-function">:</span></span> m = ast.parse(expr) <span class="hljs-comment"><span class="hljs-comment">#      varList = list(set([ x.id for x in ast.walk(m) if type(x) == ast.Name])) #      indexes = [ names.index(v) for v in varList ] lam = 'lambda %s: %s' % (','.join(varList), expr) return (indexes, eval(lam), lam)</span></span></code> </pre><br>  All rules rewrote on Python expressions.  By the way, if the rule is written incorrectly, then it is not compiled even when reading the template dictionary and the program crashes by exception, so if the dictionary is read, then the rules are enforceable. <br><br>  And everything turned out: <br> <code>+          ['ADJF', 'NOUN'] ['', '']</code> <br> <div class="spoiler">  <b class="spoiler_title">All text and parsing</b> <div class="spoiler_text">  Phrases are mostly taken from the Primer.  After all, if you start to read the car, it is better to use a proven method. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ,    text = '''                                     -                      '''</span></span></code> </pre><br>  Pattern Dictionary <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   source = ''' #    #    # /  _- NOUN,nomn VERB NOUN,accs #    -a- -b- -c- = a.tag.number == b.tag.number #   :SNOUN #   ADJF NOUN -a- -b- #    = a.tag.case == b.tag.case = a.tag.number == b.tag.number = a.tag.gender is None or a.tag.gender == b.tag.gender #     #     NOUN,nomn VERB PREP NOUN,loct -a- -b- -c- -d- = a.tag.number == b.tag.number #   VERB INFN #   NOUN Name -a- -b- = a.tag.case == b.tag.case = a.tag.number == b.tag.number #    NOUN CONJ NOUN -a- -c- -b- = a.tag.case == b.tag.case # NOUN PNCT NOUN -a- -c- -b- = a.tag.case == b.tag.case = c.normal_form == '-' '''</span></span></code> </pre><br>  Parsing <br> <code>+    ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +    ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['ADJF', 'NOUN'] ['', ''] <br> +     ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['ADJF', 'NOUN'] ['', ''] <br> +   ['ADJF', 'NOUN'] ['', ''] <br> +     ['ADJF', 'NOUN'] ['', ''] <br> +        ['NOUN', 'Name'] ['', ''] <br> +        ['NOUN', 'Name'] ['', ''] <br> +        ['NOUN', 'Name'] ['', ''] <br> +        ['NOUN', 'CONJ', 'NOUN'] ['', '', ''] <br> +    ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +   -  ['NOUN', 'Name'] ['', ''] <br> +   -  ['NOUN', 'PNCT', 'NOUN'] ['', '-', ''] <br> +   -  ['NOUN', 'PNCT', 'NOUN'] ['', '-', ''] <br> +     ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +     ['NOUN,nomn', 'VERB', 'PREP', 'NOUN,loct'] ['', '', '', ''] <br> +          ['NOUN,nomn', 'VERB', 'NOUN,accs'] ['', '', ''] <br> +          ['ADJF', 'NOUN'] ['', ''] <br> +          ['ADJF', 'NOUN'] ['', ''] <br> +          ['NOUN', 'CONJ', 'NOUN'] ['', '', ''] <br> +          ['NOUN', 'CONJ', 'NOUN'] ['', '', ''] <br> +        ['ADJF', 'NOUN'] ['', ''] <br> +        ['ADJF', 'NOUN'] ['', ''] <br> +        ['NOUN,nomn', 'VERB', 'PREP', 'NOUN,loct'] ['', '', '', ''] <br> +        ['NOUN,nomn', 'VERB', 'PREP', 'NOUN,loct'] ['', '', '', ''] <br> +        ['VERB', 'INFN'] ['', ''] <br></code> <br></div></div><br><br><h2>  What's next? </h2><br>  1. As you can see, I stopped on the search for individual templates, but did not begin to parse the result of the parsing in the parse tree.  There are several reasons for this, and one of them is - I'm not sure what to do.  Each parsing option gives us a little bit of information.  Combining them into a tree, we are trying to squeeze knowledge into an artificial structure.  A child can read and understand sentences without knowing which word is subject to it, and which one is predicate.  He takes grains and creates in his head a picture of the (described) world.  Why do we need more from the machine? <br><br>  2. Obviously there is not enough rule for how one word can be removed in the text from another.  So "Dad" became "Ilya", although between them are the words "and brother." <br><br>  3. It is also obvious that you need to sort the results among themselves and discard the unlikely ones.  Determining relevance is an open question, at a minimum it is possible to measure the distance of words from each other. <br><br>  4. The rules, in addition to other parts of speech, lack punctuation.  You can enter the constant literals "NOUN '-' NOUN", and you can, as in the example with the teacher above, check the sign in the rule. <br><br>  5. Pymorphy2 can assume that words belong to parts of speech, therefore, even such options are possible: <br> <code>&gt;&gt;&gt; parseText(patterns, ' ') <br> +   ['ADJF', 'NOUN'] ['', ''] <br> +   ['NOUN', 'Name'] ['', ''] <br></code> <br>  However, the original words of Petrushevskaya had to be swapped, since  There is no template with the inverse word order.  It‚Äôs not that this is a problem, the template is not long to be entered, but the rearrangements of words in Russian happen often and not cover all of them with templates.  Therefore, it makes sense to introduce any permutation modifiers into the template descriptions. <br><br>  The code is on <a href="https://github.com/sshmakov/RLParser">github</a> . </div><p>Source: <a href="https://habr.com/ru/post/350802/">https://habr.com/ru/post/350802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350792/index.html">Goldman Sachs lured away Google‚Äôs lead engineer to develop an API for his services</a></li>
<li><a href="../350794/index.html">Hessian-Free Optimization with TensorFlow</a></li>
<li><a href="../350796/index.html">Compact varint - uniqueness and great values ‚Äã‚Äãfor the same value.</a></li>
<li><a href="../350798/index.html">FastTrack Training. "Network Basics". "The value of Cisco routers." Eddie Martin December 2012</a></li>
<li><a href="../350800/index.html">Analysis of performance tasks with JBreak (part 1)</a></li>
<li><a href="../350804/index.html">Blockchain on Go. Part 2: Proof-of-Work</a></li>
<li><a href="../350806/index.html">About machine learning, history and life with Dmitry Vetrov</a></li>
<li><a href="../350808/index.html">Task about forEach (ps :: println) from SKB Kontur</a></li>
<li><a href="../350810/index.html">Suspended fuel tanks for aircraft</a></li>
<li><a href="../350816/index.html">New API React: Suspense (ru subtitles, from Dan's speech on JS Conf)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>