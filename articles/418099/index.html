<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 3</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <a name="habracut"></a><br><br>  You can use the method of guessing the "canary" for your own purposes in order to determine the presence of "weak" bits in terms of selection.  That is, if you guessed correctly, the server will reboot, and this will serve as a signal to you that the given value is fairly easy to guess.  Thus, it is possible to defeat randomized "canaries", assuming that after rebooting the server, their value will not change.  You can also use gadgets to implement a connected sequence of multiple attacks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Next, we will look at a more productive way in which you can use all these methods to defeat data execution prevention, random address spaces, and canaries. <br><br>  Let's turn our attention to 64-bit architectures instead of 32-bit architectures.  The former are better suited for randomization, so they give you a lot more ‚Äúrandomness‚Äù to protect against a hacker.  And these systems look much more interesting in terms of the formation of attacks. <br><br>  This type of 64-bit architecture was also considered from the point of view of <b>BROP</b> , ‚Äúblind‚Äù reverse-oriented programming.  For simplicity, we assume that the only difference between 64-bit and 32-bit machines is that on a 64-bit machine, arguments are passed to the registers, and 32-bit machines to the stack. <br><br><img src="https://habrastorage.org/webt/hg/z1/jc/hgz1jcij9zzqbaqc3fiztx1ctze.jpeg"><br><br>  When a function starts execution, it is taken to ‚Äúlook in‚Äù at certain registers to find where the arguments are. <br><br>  And now we come to the essence of today's lecture - what is blind, reciprocation-oriented programming, or <b>BROP</b> .  The first thing we do is find a stop gadget.  Remember that when we say "gadget", we essentially mean return addresses.  The gadget is identified with the return address, the starting address of the sequence of instructions to which we want to go.  So what is a stop gadget? <br><br>  Essentially, it is the return address to some place in the code, and if you jump there, then just suspend the execution of the program, but not cause the program to crash.  That is why it is called a stop gadget. <br><br>  You could jump to some place in the code, which then initiates a sleeping system call, or pauses, or something like that.  It is possible that the program will somehow ‚Äúget stuck‚Äù in an infinite loop if you jump into this place.  It really doesn't matter why the shutdown happens, but you can imagine several scenarios that would lead to it. <br><br>  What is the use of a stop gadget? <br><br>  As soon as the attacker managed to defeat the canary using the interactive bit-guessing technique, he can begin to rewrite this return address <b>ret address</b> and start to ‚Äúgrope‚Äù the stop gadget.  Note that most of the random addresses that you can put on the stack are likely to just cause the server to crash.  Again, this message for you, the attacker, is an indication that what you find is not a stop gadget.  Because when the server fails, your socket is closed, and you, as an attacker, understand that you did not hit the stop gadget.  But if you guessed something and the socket after that remains open for a while, you think: ‚ÄúYeah, I found this stop gadget‚Äù!  So the main idea of ‚Äã‚Äãthe first step is to find this stop gadget. <br><br><img src="https://habrastorage.org/webt/xb/af/zx/xbafzxirvhgep_31ahp8fuzpey4.jpeg"><br><br>  Step two is that you want to find gadgets that remove stack entries using the <b>pop</b> command.  Therefore, you must use this sequence of carefully designed instructions to figure out when you grab one of these stack gadgets.  This sequence will consist of the <b>probe address of the probe address</b> , the <b>stop address of the stop address</b> and the address of the system failure of the <b>crash address</b> . <br><br>  Thus, the <b>probe address</b> is what we are going to push onto the stack.  This will be the address of the potential stack cleanup gadget, <b>stop address</b> - this is what we considered in the first step, this is the address of the stop gadget.  Then the <b>crash address</b> will simply be the address of the non-executable code.  Here you can simply put the zero address (0 x 0), and if you apply the <b>ret</b> function to this address and try to execute the code there, it will cause the program to crash. <br><br><img src="https://habrastorage.org/webt/38/fa/ba/38fabavrj2kahtqh0_ruuxiigaa.jpeg"><br><br>  So we can use these types of addresses to find out where these <b>stack popping stack</b> cleaning gadgets are located. <br><br>  I will give a simple example.  Suppose we have two different examples of <b>probe</b> , the trap <b>trap</b> and the <b>stop</b> <b>trap</b> .  Suppose using the <b>probe</b> we are going to ‚Äúfeel‚Äù some address, suppose it starts with 4, and ends with eight: 0x4 ... 8, and behind it is the following address of the form 0x4 ... C.  Hypothetically, we can assume that one of these two addresses is the address of the gadget <b>stack popping</b> . <br><br>  The <b>trap trap</b> will receive zero addresses 0x0 and 0x0, and let the <b>stop</b> gadget <b>stop</b> have arbitrary addresses like 0xS ... 0xS ..., it does not matter.  This stop gadget points to the sleep code (10), causing the program to pause. <br><br>  Let's start with the <b>probe</b> operation, which clears some register and returns in the following sequence: <b>pop rax;</b>  <b>ret</b> .  What happens?  When the system jumps to this address, the stack pointer moves to the middle of our gadget.  And what is the gadget going to do here?  Right, perform the <b>pop rax</b> operation. <br><br><img src="https://habrastorage.org/webt/i2/eu/zr/i2euzrwlujsohfb4dl-szdeasac.jpeg"><br><br>  And then follows <b>ret</b> , which will move the function to the top line of the gadget, that is, to <b>stop</b> , and the function will stop without crashing the entire program.  So, using this gadget, an attacker can say that the address of the <b>probe</b> belongs to one of these functions, which clears the stack, because the client's server connection is open. <br><br>  Now let's assume that the second <b>probe</b> address pointed to something like <b>xor rax, rax, ret</b> for some register. <br><br><img src="https://habrastorage.org/webt/kw/5t/r3/kw5tr3vdtrqedphe0onl6ec-wa0.jpeg"><br><br>  So what happens if we try to jump to this gadget?  Note that it does not clear anything in the stack; it simply changes the contents of the registers.  So, we are going to make a return to the above zero address 0x0.  And this will lead to the system failing.  The client connection to the server will break, and the hacker will understand that this is not the <b>stack popping stack</b> cleanup gadget. <br><br>  Thus, you can use a fancy series of traps and stop gadgets, for example, you can clear two items on the stack.  To do this, you just need to place another <b>trap</b> instruction here, and if this gadget does not erase two elements, you will find yourself in one of these traps, and the execution of the code will stop.  The materials for the lecture described the thing called <b>BROP gadget,</b> which is useful if you do not like to return to programming.  But today I will tell you how you can use these simple <b>pop</b> gadgets to launch a similar attack.  Once you understand this, it will be much easier to deal with the <b>BROP gadget</b> . <br><br>  But do all of you understand how we can use the <b>probe</b> function for these gadgets?  Suppose you find the location of the code fragments that allow you to clear the stack using the <b>pop</b> function, remove one element from it, but in fact you do not know in which register this <b>pop</b> function will work.  You just know that it is already ready for execution.  But you need to know in which register these <b>pop</b> gadgets work, because in the 64-bit architecture the registers control where the arguments of the function you want to call are located. <br><br>  Thus, our goal is to be able to create gadgets that will remove values ‚Äã‚Äãthat we put in certain registers of the stack, and ultimately we initiate a system call, a <b>system call</b> , which allows us to do something bad. <br>  So now we need to determine which registers are used by <b>pop</b> gadgets. <br><br><img src="https://habrastorage.org/webt/xp/w-/hw/xpw-hw9rdgd2argq0yx6xgi3ece.jpeg"><br><br>  To do this, we can take advantage of the system call pause.  If the system call is paused, the execution of the program is suspended, and it does not accept any arguments.  And this means that the system ignores everything that is in the registers. <br><br>  In fact, to find the pause instruction that we execute, you can link all these <b>pop</b> gadgets so that we can put them all on the stack, and between each of them we <b>insert a syscall number</b> to pause.  Then we will see if we can ‚Äúhang‚Äù the program this way.  Let me give you a concrete example. <br><br>  Here, in the return address line, we put a gadget that clears the <b>RDI</b> registers and applies the <b>ret</b> function to them.  Above it, we put a <b>syscall number</b> for a pause. <br><br>  Suppose that we have another gadget located above, which performs the <b>pop</b> function in another register, say <b>RSI</b> , and then executes <b>ret</b> .  And then we put the <b>syscall number</b> again for a pause.  And we do this for all the gadgets we have found, and then we end up at the top of the stack with the suggested address for <b>syscall</b> . <br><br><img src="https://habrastorage.org/webt/qd/yx/3v/qdyx3vymmlc13o-sceyeimho_ro.jpeg"><br><br>  Remember again how you use these system calls.  You must put the <b>syscall number</b> in the <b>RAX</b> register, then call the <b>syscall libc function</b> , which is about to make the requested system call. <br><br>  So what happens when we execute this code?  We will come here, in the <b>ret address</b> string, we will jump to the address of this gadget, while it should be noted that the attacker knows that this gadget, located on the right, removes something from the stack, but does not yet know in which register it is located. <br><br>  So, if we jump to the <b>ret address</b> , what happens?  It will use the <b>pop</b> function to pause <b>syscall</b> , in some register that the attacker is not aware of, and then we will continue to climb this stack of operations up the stack. <br><br>  At the same time, we hope that one of these gadgets will perform the <b>pop</b> function for the <b>syscall number</b> in the corresponding <b>RAX</b> register.  So by the time we get here, to the top of the stack, ‚Äúspoiling‚Äù all the registers that have a <b>syscall number</b> for a pause along the way, we will hope that we still have one register, which must be correct.  Because if one of our gadgets does this, and then, when we <b>execute ret</b> , after some time we return here, to the top of the stack, we will get a pause.  Once again, the pause acts as a signal to the attacker.  Because if this supposed address for <b>syscall</b> was wrong, then the program would crash. <br><br>  So what does this phase of attack allow us to do?  We still don‚Äôt know in which registers which <b>pop-</b> gadgets are located, but we know that one of them will release <b>RAX</b> , which we want to control.  And we probably know the address of <b>syscall</b> , because we managed to pause the system. <br><br>  As soon as we do this, we will be able to check these gadgets one by one and find out which of them puts the system on pause.  In other words, we will cut everything that is located between the <b>ret address</b> line and the top of the stack to go directly to <b>syscall</b> .  We will check if there is a pause or system crash.  If a failure occurs, we identify the gadget that caused it, for example, it is in the bottom line to the right, this is <b>pop rdi</b> .  Get rid of him and try the next one.  Put here, in the line above the <b>ret address, the</b> real address for <b>syscall</b> .  We were able to pause the program?  Yeah, so we learned that this <b>pop</b> gadget should free <b>RAX</b> .  It's clear? <br><br>  <b>Audience:</b> So, a way to guess the address for a system call is just a blind transfer of gadgets? <br><br>  <b>Professor:</b> yes, it is, and there are ways to optimize this process in the lecture materials when you use the <b>PLT</b> file extension and similar things.  With a simple attack that I described, you really just put in the address here, and see if it caused a pause or not.  As a result of the test, we find out the location of the <b>syscall</b> .  We find out where the instruction that performs <b>pop RAX is located</b> .  We also need gadgets that perform <b>pop</b> and in some other registers too.  You can do similar tests for them.  Therefore, instead of pausing a <b>syscall number</b> , use <b>push</b> for some other command that, for example, uses the <b>RAX</b> and <b>RDI</b> arguments. <br><br>  Thus, you can use the fact that for any particular set of registers that you want to control, there is some kind of <b>syscall</b> that will give you, the attacker, a signal to find out if you broke it successfully or not.  So, at the end of this phase you will have the address <b>syscall</b> and the address of the heap of gadgets that allow you to perform <b>pop</b> in arbitrary registers. <br><br>  Now let's move on to the 4th step, which will be called the <b>write</b> - record.  The fourth step is recording the system call.  To call <b>write</b> , we need to have the following gadgets: <br><br>  <b>pop rdi, ret;</b> <b><br></b>  <b>pop rsi, ret;</b> <b><br></b>  <b>pop rdx, ret;</b> <b><br></b>  <b>pop rax, ret;</b> <b><br></b>  <b>syscall</b> <br><br><img src="https://habrastorage.org/webt/kj/1h/ds/kj1hdsjhh1509eliv3vjxte7nw4.jpeg"><br><br>  How are these registers used by the system call?  The first is a socket, or, more generally, a file descriptor that you are going to pass to write.  The second is the buffer, the third is the length of this buffer, the fourth is the system call number and the fifth is <b>syscall</b> itself. <br><br>  So, if we find all these gadgets, then we can control the values ‚Äã‚Äãthat are embedded in the arguments, which, in turn, are placed in these registers, because we simply ‚Äúpushed‚Äù them onto the stack. <br><br>  What should be the socket?  Here we will have to do a bit of popping.  You can take advantage of the fact that Linux limits the number of simultaneous open connections for a file that reaches a value of 2024. And also that it should be the smallest of all available. <br><br>  I wonder what we are going to insert into the buffer pointer?  That's right, we intend to use a text fragment of the program here, we are going to put it in a pointer somewhere in the program code.  This allows us to read a binary file out of memory using the correct client call from a socket.  Then an attacker can take this binary file, analyze it offline offline, using <b>GDB</b> or another tool to find out where all this is located.  The attacker knows that now, every time the server ‚Äúfalls,‚Äù the same random set of things will be stored in it.  So now that the attacker can find out the addresses and offsets for the contents of the stack, he can attack these gadgets directly.  It can directly attack other vulnerabilities, figure out how to open the shell, and the like.  In other words, in the place where you provided the hacker a binary file, you were defeated. <br><br>  This is how the <b>BROP</b> attack <b>works</b> .  As I have already said, the materials of the lecture describe many ways to optimize these processes, but first you need to understand the basic material, otherwise the optimization loses its meaning.  So you can talk to me about optimizing individually or after class. <br><br>  For now, suffice it to say that these are the basics of how you can launch a <b>BROP</b> attack.  You have to find the <b>stop-</b> gadget, find those gadgets that perform the <b>pop</b> function of the stack entries, find out what registers they are in, where the <b>syscall</b> is located, and then initiate <b>write</b> , based on the information <b>retrieved</b> . <br><br><img src="https://habrastorage.org/webt/xb/-q/iq/xb-qiqqwytbciwpbxiow5i_fovi.jpeg"><br><br>  So, quickly go over the topic, how do you defend against <b>BROP</b> ?  So the most obvious thing you have is re-randomization.  Since the fact that ‚Äúfallen‚Äù servers do not respawn, do not create re-randomized versions of themselves, acts as a signal that gives an attacker the opportunity to test various hypotheses about how programs work. <br><br>  One easy way to protect is to make sure that you do <b>exec</b> instead of <b>fork</b> when you revive your process.  Because when you run a process, you create a completely new randomly located space, at least that's what happens in Linux.  On Linux, when you compile with the <b>PIE</b> , <b>Position Independent Execution</b> , location-independent executable file, when using <b>exec,</b> you only get a new random address space. <br><br>  The second way is simply to use Windows, because this OS basically does not have the equivalent of the <b>fork</b> function.  This means that when you revive a server on Windows, it will always have a new random address space. <br><br>  Someone here asked what would happen if, after a server crash, it does not break the connection?  So, if, when the server crashes, we somehow ‚Äúcatch‚Äù this error and keep the connection open for some time, we will be able to confuse the attacker so that he does not receive a signal of failure and thinks that he has found the correct address. <br><br>  In this case, your <b>BROP</b> attack will turn into a <b>DOS</b> attack.  Because you just got all the potential zombie processes that are around.  They are useless, but you cannot let them go further, otherwise you will have to delete this information. <br><br>  Another thing you might think about is the execution of the border check that we talked about before.  The lecture materials say that this method is unproductive, since it is 2 times more expensive, but you could still use it. <br><br>  This is how <b>BROP</b> works.  As for homework, a more delicate question is asked: what if you use the current time hash?  That is, the length of time during which you restart the program.  Is this enough to prevent this type of attack?  Note that hashing does not magically provide you with bits of entropy, if the data entered into the hash is easily guessed.  If your hash contains billions of bits, it doesn't matter.  But if you only have a couple of values ‚Äã‚Äãthere, the attacker will simply guess them.  Of course, using a random time hash is better than using nothing to protect against a hacker, but this does not provide you with the security you should count on. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/418099/">https://habr.com/ru/post/418099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418087/index.html">80% of self-checkout counters are at risk</a></li>
<li><a href="../418089/index.html">Overview of SolidCraft CNC Milling Machines</a></li>
<li><a href="../418091/index.html">List of articles and literature about NAS</a></li>
<li><a href="../418093/index.html">MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 2</a></li>
<li><a href="../418095/index.html">About the device built-in testing functionality in Rust (translation)</a></li>
<li><a href="../418101/index.html">Etymology of IT terms</a></li>
<li><a href="../418103/index.html">The head of Roscosmos remembered his first rocket and shared his plans for the future</a></li>
<li><a href="../418105/index.html">Why opening YouTube in Firefox or Edge can take 5 times longer than Google Chrome</a></li>
<li><a href="../418107/index.html">Setting the prefix for the MINDEO CS2190 scanner to work with 1C in keyboard break mode</a></li>
<li><a href="../418111/index.html">Modern online learning: problems and trends</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>