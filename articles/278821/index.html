<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Algorithms: development and application. Classic Computer Science ¬ª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrozhiteli! We have a new product: 

 For the first time, one of the most authoritative books on the development and use of algorithms is publis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Algorithms: development and application. Classic Computer Science ¬ª</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habrozhiteli!  We have a new product: <br><br><img src="https://habrastorage.org/files/9eb/f13/f8d/9ebf13f8dfd34b9dbdafa00279987a69.jpg" align="left" alt="image">  For the first time, one of the most authoritative books on the development and use of algorithms is published in Russian.  Algorithms are the basis of programming that determines how software will use data structures. <br><br>  You will get acquainted with the basic aspects of building algorithms, basic concepts and definitions, data structures, then go to the basic methods of constructing algorithms, undecidability and methods for solving unsolvable problems, and, finally, learn the randomization when designing algorithms.  The most complex topics are explained with clear and simple examples, so the book can be used for self-study by students, as well as by research scientists or computer technology professionals who want to get an idea of ‚Äã‚Äãthe application of certain algorithms design techniques. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Algorithmic analysis consists of two fundamental components: the allocation of a mathematically pure kernel of the problem and the identification of methods for designing a suitable algorithm based on the structure of the problem.  And the better an analyst owns the full arsenal of possible design methods, the sooner he begins to recognize the ‚Äúpure‚Äù formulations that underlie the intricate real-world tasks. <br><a name="habracut"></a><br><br>  Algorithmic problems form the core of computer science, but they rarely appear in the form of neatly packed, mathematically exact questions.  More often, they are burdened with many troublesome details tied to a specific case;  some of these details are important, others are redundant.  As a result, algorithmic analysis consists of two fundamental components: identifying a mathematically pure kernel of the problem and identifying methods for designing a suitable algorithm based on the structure of the problem.  These two components are interrelated: the better the analyst has a full arsenal of possible design methods, the faster he begins to recognize the ‚Äúpure‚Äù formulations that underlie the intricate real-world tasks.  Thus, when used with maximum efficiency, algorithmic ideas do not simply provide solutions to clearly defined tasks ‚Äî they form the language for clearly expressing the questions underlying them. <br><br>  The purpose of this book is to convey to the reader this approach to algorithms in the form of a design process that begins with tasks that occur across the entire range of computational applications, uses a good understanding of algorithm design methods, and the end result is the development of effective solutions to such problems.  We will study the role of algorithmic ideas in computer science in general and will try to connect these ideas with a range of precisely formulated problems, for the solution of which algorithms are designed and analyzed.  In other words, what reasons make us look for the solution of these problems and how do we choose concrete ways of formulating them?  How do we know which design principles are relevant in a given situation? <br><br>  Based on the above, we tried to show how to identify ‚Äúpure‚Äù formulations of algorithmic problems in complex computational areas and how to design effective algorithms based on these formulations for solving the obtained problems.  In order to understand the complex algorithm, it is often easiest to reconstruct a sequence of ideas (including unsuccessful approaches and deadlocks) that led from the original simplified methods to a solution worked out over time.  This is how the presentation style was formed, which does not lead the reader to formulate the problem directly to the algorithm and, in our opinion, better reflects how we and our colleagues approach the solution of such problems. <br><br><h5>  General information </h5><br>  The book is intended for students who have undergone a two-semester introductory course on computational technologies (standard course "CS1 / CS2"), during which they wrote programs for implementing basic algorithms, and working with data structures such as trees and graphs, as well as with basic data structures (arrays, lists, queues, and stacks).  Since the transition between this course and the first course in algorithms has not yet become standard, the book opens with a presentation to those familiar to students of some educational institutions in CS1 / CS2, but in other institutions are included in the first-year curriculum in algorithms.  Accordingly, this part can be considered either as a review or as a new material;  including it, we hope that the book can be used in a wider range of training courses and with greater flexibility regarding the basic knowledge required for the reader. <br><br>  In accordance with the described approach, we develop basic methods for designing algorithms, studying problems from many areas of computer science and related fields.  In particular, fairly detailed descriptions of possible applications from systems and networks (caching, switching, interdomain routing on the Internet), artificial intelligence (planning, games, Hopfield networks), pattern recognition (image segmentation), information extraction (point detection transition, clustering), operations research (air traffic planning) and computational biology (sequence alignment, secondary structure of RNA). <br><br>  The concept of computational undecidability and NP-completeness in particular plays a significant role in the book.  This corresponds to our approach to the overall design process of the algorithm.  Sometimes an interesting problem arising in the practical field has an effective solution, and sometimes it turns out to be provably NP-complete;  For a full-fledged approach to solving a new algorithmic problem, you should be able to explore both options with equal certainty.  Since so many natural tasks in computer science are NP-complete, the development of mechanisms for working with unsolvable problems has become a key factor in the study of algorithms, and this topic is widely presented in the book.  The conclusion that the problem is NP-complete should be taken not as the end of the study, but as an invitation to search for approximation algorithms, methods of heuristic local search or solvable special cases.  Each of these three approaches is widely considered in the book. <br><br>  In order to simplify work with such tasks, each chapter includes the section ‚ÄúExercises with solutions‚Äù, in which we take one or several tasks and describe in detail the process of finding a solution.  For this reason, the discussion of each exercise with a solution is much longer than the simple recording of a complete, correct solution (in other words, much longer than it was necessary for a complete solution if the task was given to the student for an independent solution).  As in the rest of the book, the discussions in these sections should give the reader an idea of ‚Äã‚Äãthe larger processes used to solve problems of this type and ultimately lead to an exact solution. <br><br>  It is worth mentioning two more circumstances related to the use of these tasks for independent work in training courses.  First, the tasks are ordered in an approximately increasing order of difficulty, but this is only an approximate guideline, and we are not advised to pay too much attention to it;  Since the bulk of the tasks were designed for students to work independently, large subsets of tasks in each chapter are rather closely related in terms of complexity.  Secondly, apart from the initial chapters, we will have to work on solving these problems, both in order to link the description of the problem with the algorithmic methods described in the chapter, and for the direct design of the algorithm.  In our training course, we assigned about three such tasks for a week. <br><br><h5>  Learning aspects and additions </h5><br>  In addition to the tasks and exercises with solutions, this book uses a number of other educational aspects, as well as additions that simplify its use for educational purposes. <br><br>  As mentioned earlier, many sections in the book are devoted to formulating an algorithmic problem (including its history and motivation to find a solution), designing and analyzing an algorithm for solving it.  In accordance with this style, such sections have a single structure, including a sequence of subsections: ‚ÄúTask‚Äù with a description of the task and its exact wording;  ‚ÄúAlgorithm design‚Äù using suitable methods for algorithm development;  and "Analysis of the algorithm" with the proof of the properties of the algorithm and analysis of its effectiveness.  In cases where extensions of the problem are considered or additional analysis of the algorithm is given, additional subsections are included.  The purpose of this structure is to introduce a relatively general style of presentation, which proceeds from the initial discussion of the problem arising in the computational domain, to a detailed analysis of methods for solving it. <br><br><h5>  Summary </h5><br>  Chapter 1 begins with a presentation of some typical algorithmic problems.  We begin with the problem of stable matchings, because it allows us to define the basic aspects of algorithm development more specifically and elegantly than any abstract reasoning: the search for stable matchings is conditioned by a natural, albeit complex, practical area, on the basis of which we can abstract an interesting formulation of the problem and an unexpectedly efficient algorithm for solving it.  In the remainder of chapter 1, five ‚Äútypical tasks‚Äù are considered, which predetermine the topics from the remainder of the course.  These five tasks are interrelated in the sense that all of them can be considered as variations and / or special cases of the task of searching for an independent set;  but one problem can be solved with the help of a ‚Äúgreedy‚Äù algorithm, another - by dynamic programming, the third - by finding the flow in the network, the fourth (the actual set of the independent set) is NP-complete, and the fifth - PSPACE-complete.  The fact that closely related tasks can vary considerably in complexity plays an important role in the book, and these five tasks serve as reference points, to which we repeatedly return as we present the material. <br><br>  Chapters 2 and 3 help to link the material to the CS1 / CS2 course, discussed above.  Chapter 2 introduces the key mathematical definitions and concepts used in the analysis of algorithms, as well as the motivation for their application.  The chapter begins with an informal review of what is meant by the computational solvability of a problem, as well as the concept of polynomial time as a formal criterion of efficiency.  Then questions of the growth rate of functions and asymptotic analysis are considered more formally, information is given on the functions that are often encountered in the analysis of algorithms, as well as on their standard applications.  Chapter 3 discusses the basic definitions and algorithmic primitives needed to work with graphs and which are central to many of the book‚Äôs tasks.  By the end of the CS1 / CS2 training course, students implement many basic graph theory algorithms, but it is useful to present this material in the wider context of algorithm design.  In particular, we consider basic graph definitions, graph traversal methods (width traversal and depth traversal), and basic concepts of directed graphs, including strong connectivity and topological ordering. <br><br>  Chapters 2 and 3 also present many of the basic data structures used to implement the algorithms in the book;  more complex data structures are described in subsequent chapters.  Our approach to data structures is to represent them when they are needed to implement the algorithms described in the book.  Thus, although many data structures will already be familiar to students in the CS1 / CS2 course, we will consider them in the wider context of designing and analyzing algorithms. <br><br>  Chapters 4‚Äì7 discuss four basic methods for designing algorithms: greedy algorithms, the principle of ‚Äúdivide and power-wui‚Äù, dynamic programming, and finding the flow in the network.  With greedy algorithms, it is important to understand when they are working and when not;  Our consideration of this topic is based on the classification method of the algorithms used to prove the correctness of the work of the greedy algorithms.  The chapter concludes with an overview of the main applications of greedy algorithms for finding the shortest paths, directional and non-directional spanning trees, grouping and compression.  The discussion of the ‚Äúdivide and conquer‚Äù method begins with a review of recurrence relations strategies as limits for execution time;  then we will show how knowledge of these recurrent relations can control the design of algorithms that exceed straightforward solutions of many basic problems, including comparing estimates, finding the closest pairs of points on a plane, and the fast Fourier transform.  Familiarity with dynamic programming begins with an intuitive recursion on which it is based, with the subsequent development of more and more expressive formulas through applications in which they naturally occur.  Finally, we consider the algorithms for the problems of finding a stream in the network;  Most of this chapter will be devoted to a variety of practical applications of these streams.  To the extent that online streams are covered in algorithmic training courses, students often do not sufficiently well represent the wide range of tasks to which they can be applied;  we will try to pay tribute to their flexibility and present the use of streams for load distribution, scheduling, image segmentation, and a number of other tasks. <br><br>  Chapters 8 and 9 are devoted to the concept of computational undecidability.  They focus on NP-completeness;  Basic NP-complete tasks are categorized to help students identify possible cuts when new tasks are discovered.  We will come to fairly complex proofs of NP-completeness, with recommendations on how to approach the construction of complex abbreviations.  Also, types of computational complexity beyond NP-completeness, especially in the PSPACE-completeness area, will be considered.  This useful concept emphasizes that insolvability does not end in NP-completeness;  PSPACE completeness also lays the foundation for central concepts from the field of artificial intelligence (planning and playing games), which without it would not have been reflected in the algorithmic domain under consideration. <br><br>  Chapters 10 through 12 deal with three basic methods for working with computationally intractable problems: identifying structured special cases, approximation algorithms, and local search heuristics.  The chapter on solvable special cases shows that instances of NP-complete problems encountered in practice may not be so difficult in the worst cases, because they often contain a structure that can be used to design an efficient algorithm.  We will show that NP-complete problems are often successfully solved if we confine ourselves to the input data having a tree structure.  The topic ends with a detailed discussion of the decomposition of graphs into a tree.  Although this topic is more suitable for graduation courses, it has significant practical value for which it is difficult to find more accessible material.  In the chapter devoted to approximation algorithms, the process of designing efficient algorithms and the problem of analyzing the optimal solution for constructing good estimates are considered.  As for the methods of designing approximation algorithms, we focus on greedy algorithms, linear programming and the third method, which will be called ‚Äúpricing‚Äù, using the ideas of the first two.  Finally, we consider the local search heuristics, including the Metropolis algorithm and the model quenching method.  This topic is often not considered in the middle level algorithmic courses, because very little is known about provable guarantees of such algorithms;  however, given their wide practical distribution, we believe that it will be useful for students to know about them.  Descriptions of cases for which there are demonstrable warranties are also included. <br><br>  Chapter 13 discusses the use of randomization in the design of algorithms.  Several good books have been written on this topic.  Here we will try to provide a more compact introduction to some of the methods of applying randomization methods, based on information that is usually included in training courses in discrete mathematics of the middle level. <br><br><h5>  <u>About the authors</u> </h5><br>  John Kleinberg (Jon Kleinberg) - Professor of Computer Systems Theory at Cornell University.  He received his doctorate from the Massachusetts Institute of Technology in 1996. <br><br>  Kleinberg's studies are devoted to algorithms, primarily related to the structure of networks and information, and their practical applications in the field of computer technology, optimization, data analysis and computational biology.  His work on network analysis has helped lay the foundation for the current generation of Internet search engines. <br><br>  Eva Tardos is a professor of computer systems theory at Cornell University.  Received a doctorate degree at √ñtv√∂s University in Budapest (Hungary) in 1984.  Member of the American Academy of Arts and Sciences and the Computer Engineering Association of the USA. <br><br>  The scientific interests of Tardos are related to the design and analysis of algorithms for solving problems from graph and network theory.  Her works in the field of network flow algorithms and approximating algorithms for solving network problems are best known.  Her recent work has been devoted to algorithmic game theory. <br><br>  More information about the book can be found on <a href="http://www.piter.com/collection/klassika-computer-science/product/algoritmy-razrabotka-i-primenenie-klassika-computers-science">the publisher's website.</a> <br>  <a href="http://storage.piter.com/upload/contents/978549601545/978549601545_X.pdf">Table of contents</a> <br>  <a href="http://storage.piter.com/upload/contents/978549601545/978549601545_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley a 25% discount on the coupon - <b>Algorithms</b> </div><p>Source: <a href="https://habr.com/ru/post/278821/">https://habr.com/ru/post/278821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278811/index.html">How to organize the transfer of financial data on the American stock exchange Nasdaq: ITCH and OUCH protocols</a></li>
<li><a href="../278813/index.html">Register for the webinar ‚ÄúUsing Panda SaaS Solutions to Protect and Manage Enterprise IT Assets‚Äù</a></li>
<li><a href="../278815/index.html">Android application architecture</a></li>
<li><a href="../278817/index.html">ReactiveCocoa. Concurrency. Multithreading</a></li>
<li><a href="../278819/index.html">Security in the hands of a smartphone: the first car without keys is on its way</a></li>
<li><a href="../278823/index.html">Capture and visualize! Or a histogram from a microphone using Web Audio API</a></li>
<li><a href="../278825/index.html">Spoiler: Insert SVG icons in one single way.</a></li>
<li><a href="../278827/index.html">Developer's life (in pictures)</a></li>
<li><a href="../278829/index.html">Notes localizer. The case of the problem of saving in games</a></li>
<li><a href="../278831/index.html">Notes localizer. Voice acting in games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>