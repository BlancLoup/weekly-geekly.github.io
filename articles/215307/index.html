<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hadoop, part 3: Pig, data processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a previous publication, we discussed in detail the process of collecting data using the specialized tool Flume. But in order to fully work with inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hadoop, part 3: Pig, data processing</h1><div class="post__text post__text-html js-mediator-article"><img alt="des-48-5" src="https://habrastorage.org/getpro/habr/post_images/813/a8e/e7c/813a8ee7c4d6ce2c58008a975bb4bcc8.png" width="100%"><br><br>  In a <a href="http://blog.selectel.ru/hadoop-chast-2-sbor-dannyx-cherez-flume/">previous publication,</a> we discussed in detail the process of collecting data using the specialized tool Flume.  But in order to fully work with information, it is not enough just to collect and save it: it needs to be processed and something necessary and useful is extracted from it. <br><br>  Hadoop uses MapReduce technology to process data. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  MapReduce technology </h2><br><br><h3>  Story </h3><br><br>  Data processing in Hadoop is performed using MapReduce technology.  Initially, this technology was developed by Google in 2004. <br><br>  Google developers Jeffrey Dean and Sanjay Gemavat in 2004 published an article in which they proposed the following solution for handling large amounts of raw data (indexed documents, query logs, etc.): a huge array of information is divided into parts, and the processing of each of These parts are charged to a separate server.  As a rule, data are processed on the same servers where they are stored, which allows speeding up the processing process and avoiding unnecessary data movement between servers.  After that, the results are combined into a single whole. <br><br>  The Google specialists in the article mentioned above limited themselves to a description of the basic algorithms, not stopping at the implementation details.  However, this information turned out to be enough for Hadoop developers to create their own MapReduce framework. <br><br>  Today it is used in many well-known web projects - Yahoo !, Facebook, Last.Fm, and others. <br>  Consider the architecture and operation of Hadoop MapReduse in more detail. <br><br><h3>  Architecture and working principles </h3><br><br>  The architecture of MapReduce is built on the principle of ‚Äúmaster-slave‚Äù (master-workers).  The main role is JobTracker, which distributes tasks to subordinate nodes of the cluster and monitors their execution. <br><br><img alt="Architecture and working principles" src="https://habrastorage.org/getpro/habr/post_images/f67/ea5/bda/f67ea5bdad1bf834a67c1fb0347248e6.png" width="100%"><br><br>  Data processing is divided into the following steps: <br><ol><li>  Application launch: transfer of application code to the main (master) and subordinate nodes (workers); </li><li>  The wizard assigns specific tasks (Map or Reduce) and distributes the parts of the input data to computing nodes (workers); </li><li>  Map nodes read the input data assigned to them and begin processing them; </li><li>  Map nodes locally store intermediate results: each node saves the result to local disks; </li><li>  Reduce-nodes read intermediate data from Map-nodes and perform Reduce data processing; </li><li>  Reduce-nodes save the final results in the output files, usually in HDFS. </li></ol><br><br>  Creating applications for MapReduce is quite laborious.  Writing all the functions, compiling and packaging takes a lot of time.  To facilitate the work of the company Yahoo!  developed a specialized tool called Pig, which increases the level of abstraction in data processing. <br><br><h3>  Pig </h3><br>  Pig consists of two parts: <br><ul><li>  language for describing Pig Latin streams; </li><li>  the runtime for running Pig Latin scripts (two options are available: running on a local JVM or running in a Hadoop cluster). </li></ul><br><br>  The Pig script includes a series of operations (transformations) that must be applied to the input data to get the output data.  These operations describe the data stream, which is then converted (compiled) by the Pig execution environment into an executable representation and launched for execution.  In the internal implementation, Pig transforms the transformations into a series of MapReduce tasks. <br><br>  Initially, the Pig was created to work from the console (the Grunt Shell shell).  In the implementation from Cloudera, Pig is handled via a simple and convenient web interface.  You can open it through the already familiar to us interface Hue http: // [node_in__which_installed_Hue]: 8888 / pig / <br><br><img alt="Pig" src="https://habrastorage.org/getpro/habr/post_images/216/c1a/89d/216c1a89d38554df4d214c9938045873.png" width="100%"><br><br>  The web interface includes a full-fledged editor (there is even an automatic substitution of operators) and a script manager.  With it, you can save scripts directly in Hue, run them, view a list of running tasks, results and run logs. <br><br><h3>  Test task </h3><br>  As a test task, we will process the access logs of our repository for a certain day (day).  Calculate the following parameters: <br><ul><li>  total number of requests; </li><li>  the number of requests from each unique IP; </li><li>  the number of requests for each unique URL; </li><li>  The amount of data sent to each URL. </li></ul><br>  Below is a script that solves the problem.  Immediately it should be noted that this script (like all scripts in Pig) is not executed line by line, as in interpreted languages.  The Pig compiler parses dependencies and sets up data streams.  Script compilation starts from the end, that is, from the STORE command.  For data, after processing of which there is no save command, no tasks will be created and the data itself will not even be read.  This allows you to write a script in a fairly arbitrary form, all the work on optimization, determining the order of execution and parallelization will take on Pig. <br><br>  The full listing of the script will look like this: <br><pre>  records = LOAD '/ log / flume / events / 14-02-20 /' USING PigStorage ('\ t')
 AS (
 date: chararray,
 clientip: chararray,
 clientport: chararray,
 proto: chararray,
 statuscode: int,
 bytes: int,
 sq: chararray,
 bq: chararray,
 request: chararray);

 count_total = FOREACH (GROUP records ALL) GENERATE COUNT (records);

 count_ip = FOREACH (GROUP records BY clientip) GENERATE group AS ip, COUNT (records) AS cnt;
 top_ip = ORDER count_ip BY cnt DESC;

 filtered_req = FILTER records BY statuscode == 200 OR statuscode == 206;
 count_req = FOREACH (GROUP filtered_req BY request) GENERATE group AS req, COUNT (filtered_req) AS cnt, SUM (filtered_req.bytes) AS bytes;
 top_req = ORDER count_req BY bytes DESC;

 % declare DT `date +% y% m% dT% H% M`
 STORE count_total INTO '$ DT / count_total';
 STORE top_ip INTO '$ DT / top_ip';
 STORE top_req INTO '$ DT / top_req'; </pre><br><br>  It consists of three parts: data loading, processing and saving.  This order is common to most tasks.  In some cases, solving problems may include additional steps ‚Äî for example, generating data (for example, structured artificial data for testing an algorithm) or storing intermediate results of calculations.  A detailed description of the syntax, data types and operators can be found in the official documentation. <br><br>  Consider each stage in more detail. <br><br><h4>  Loading </h4><br><pre>  records = LOAD '/ log / flume / events / 14-02-20 /' USING PigStorage ('\ t')
 AS (
 date: chararray,
 clientip: chararray,
 clientport: chararray,
 proto: chararray,
 statuscode: int,
 bytes: int,
 sq: chararray,
 bq: chararray,
 request: chararray); </pre><br><br>  We use web server logs as input.  For a better understanding of further processing, we give an example of input data: <br><br><pre>  07 / Dec / 2013: 20: 05: 13 95.153.193.56 37877 http 200 1492030 0 0 GET /745dbda3-894e-43aa-9146-607f19fe4428.mp3 HTTP / 1.1
 08 / Dec / 2013: 15: 00: 28 178.88.91.180 13600 http 200 4798 0 0 GET /public/cars/bmw7l/down.png HTTP / 1.1
 08 / Dec / 2013: 15: 00: 29 193.110.115.45 64318 http 200 1594 0 0 GET /K1/img/top-nav-bg-default.jpg HTTP / 1.1 </pre><br><br>  First, consider the data model and terminology.  The main object in Pig Latin is the ‚Äú <em>relation</em> ‚Äù.  It is with relationships that all language operators work.  In the form of relationships are input and output. <br><br>  Each relation is a collection of similar objects - ‚Äú <em>tuples</em> ‚Äù (tuples).  Analogs in the database: a tuple is a string, a relation is a table. <br><br>  Tuples, respectively, consist of numbered or named objects - " <em>fields</em> ", arbitrary base types (number, string, Boolean, etc.). <br><br>  So, in Pig Latin, the result of any operator is a relation, which is a collection of tuples. <br>  The LOAD statement creates a records relationship from files in HDFS from the '/ log / flume / events / 14-02-20 /' directory, using the standard PigStorage interface (also note that the separator in the files is the tab character '\ t').  Each line of the files will appear in a tuple relation.  The AS section assigns to the fields in the tuple the types and names by which it will be more convenient for us to refer to them. <br><br><h4>  Treatment </h4><br>  Calculate the total number of entries in the logs using the COUNT operator.  Before this, it is necessary to combine all the rows in records into one group with FOREACH and GROUP operators. <br><br><pre>  count_total = FOREACH (GROUP records ALL) GENERATE COUNT (records);
 count_ip = FOREACH (GROUP records BY clientip) GENERATE group AS ip, COUNT (records) AS cnt;
 top_ip = ORDER count_ip BY cnt DESC; </pre><br><br>  Translated from Pig Latin into a natural language, the following script looks like this: for each record (FOREACH), from records grouped together (GROUP ALL), count records in records (GENERATE COUNT). <br><br>  Now count the number of requests from unique addresses.  In our tuples with respect to records, the clientip field contains the IP addresses from which requests were made.  Group the tuples in records by the clientip field and define a new relation consisting of two fields: <br><ul><li>  the ip field, the value of which is taken from the group name in relation to records; </li><li>  The number of entries in the group is cnt, counted by the COUNT operator, that is, the number of entries corresponding to a specific IP address in the IP field. </li></ul><br><br>  Next, we define another top_ip relation consisting of the same data as count_ip, but sorted by the cnt field by the ORDER operator.  Thus, in top_ip we will have a list of client IP addresses from which requests most often occurred.  In the future, we can bind this data to GEO-IP and see in which cities and countries our storage is most popular =) <br><br><pre>  filtered_req = FILTER records BY statuscode == 200 OR statuscode == 206;
 count_req = FOREACH (GROUP filtered_req BY request) GENERATE group AS req, COUNT (filtered_req) AS cnt, SUM (filtered_req.bytes) AS bytes;
 top_req = ORDER count_req BY bytes DESC; </pre><br><br>  After that, we calculate the number of successful requests for each URL, as well as the total amount of data downloaded for each URL.  To do this, we first use the filter operator FILTER, selecting only successful requests with HTTP codes 200 OK and 206 Partial Content.  This statement defines the new filtered_req from the records relationship by filtering it across the statuscode field. <br><br>  Further, similarly to the calculation of IP addresses, we count the number of unique URLs, grouping the records for requests by the request field.  We are also interested in the transferred data volume for each URL: it can be calculated using the SUM operator, which adds the bytes fields in the grouped records of the filtered_req relationship. <br><br>  Now we will sort by the field bytes, defining a new relation top_req. <br><br><h4>  Saving results </h4><br><br><pre>  % declare DT `date +% y% m% dT% H% M`
 STORE count_total INTO '$ DT / count_total';
 STORE top_ip INTO '$ DT / top_ip';
 STORE top_req INTO '$ DT / top_req'; </pre><br><br>  It is preferable to save the results of each script execution to a separate directory, the name of which includes the date and time of execution.  To do this, you can use the function to call an arbitrary shell command directly from the Pig script (you need to write it in backquotes).  In the example, the result of the date command is entered in the variable DT, which is then substituted in the data storage path.  Save the results with the STORE command: each relationship is in its own directory. <br><br>  You can view the output through the file manager in Hue;  By default, the path in HDFS is relative to the home directory of the user running the script. <br><br><img alt="File browser" src="https://habrastorage.org/getpro/habr/post_images/f1c/d47/50b/f1cd4750b79ee026b67fb09e6e24fb48.png" width="715"><br><br>  Information on the results of the tasks will be displayed in the Pig logs as follows: <br><pre>  http: // cdh3: 8888 / pig / # logs / 1100715
 Input (s):
 Successfully read 184442722 records (32427523128 bytes) from: "/ log / flume / events / 14-02-20"

 Output (s):
 Successfully stored 1 records (10 bytes) in: "hdfs: // cdh3: 8020 / user / admin / 140225T1205 / count_total"
 Successfully stored 8168550 records (1406880284 bytes) in: "hdfs: // cdh3: 8020 / user / admin / 140225T1205 / top_req"
 Successfully stored 2944212 records (49039769 bytes) in: "hdfs: // cdh3: 8020 / user / admin / 140225T1205 / top_ip"

 Counters:
 Total records written: 11112763
 Total bytes written: 1455920063 </pre><br><br>  Report from Oozie: <br><br><pre>  Last Modified Tue, Feb 25, 2014 00:22:00
 Start Time Tue, Feb 25, 2014 00:05:16
 Created Time Tue, Feb 25, 2014 00:05:15
 End Time Tue, Feb 25, 2014 00:22:00 </pre><br><br>  From the above logs, it is clear that during the execution of the test task, more than 180 million records were processed with a total volume of more than 32 GB.  The whole processing procedure took about 15 minutes. <br><br>  During the active phase of the Map, 22 processor cores and 91GB of RAM were used.  For a small cluster consisting of three servers five years ago, this result can be considered quite good. <br><br>  As mentioned above, Pig creates MapReduce tasks during script execution and sends them to the MR cluster for execution.  This process is graphically shown in the statistics graphs in the Cloudera Manager control panel: <br><br><img alt="Home - Cloudera Manager 1" src="https://habrastorage.org/getpro/habr/post_images/ed5/6e2/5a1/ed56e25a1f508213613913909caf3e52.png" width="715"><br><br><img alt="Activities: mapreduce1" src="https://habrastorage.org/getpro/habr/post_images/9c2/130/b14/9c2130b14987c556f5220560d6232502.png" width="715"><br><br><ol><li>  Stage Map: The processors and disks at each node are busy processing their pieces of data. </li><li>  Stage Reduce: the results obtained in the first stage are transmitted over the network and merged. </li><li> At the third stage, the results are saved in the file system (a jump in HDFS is visible on the graph). </li></ol><br><br>  On the graphs you can see that the solution of the problem included two passes of MapReduc.  During the first pass, unique records were counted, and during the second, sorting.  These procedures cannot be parallelized and executed in a single pass, since the second procedure works with the results of the first. <br><br><h2>  Conclusion </h2><br>  In this article, we talked about the architecture of MapReduce, and also discussed the features of its work using the Pig tool.  Writing programs for MapReduce is a very difficult task that requires a special approach.  All the difficulties, however, are compensated by power, scalability and high speed processing of huge amounts of arbitrary data. <br><br>  In the near future we plan to continue the cycle of articles on Hadoop.  The next post will be about working with the Impala database. <br><br>  Readers who are not able to comment on posts on Habr√©, we invite to our <a href="http://slc.tl/nu46d">blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/215307/">https://habr.com/ru/post/215307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215291/index.html">2048</a></li>
<li><a href="../215295/index.html">Calculation of statistics of downloads in Google Analytics</a></li>
<li><a href="../215299/index.html">Wi-Fi Network: Single-Channel Architecture vs Multi-Channel Architecture</a></li>
<li><a href="../215303/index.html">How to build high-rise buildings in 2 months, and cities per 100,000 inhabitants in 2 years</a></li>
<li><a href="../215305/index.html">Tyvskvotting contrary</a></li>
<li><a href="../215313/index.html">Interaction of vulnerability scanners with Metasploit. Part 1</a></li>
<li><a href="../215315/index.html">From regional to intercontinental CodeFest 2014</a></li>
<li><a href="../215319/index.html">Payler - go ahead!</a></li>
<li><a href="../215321/index.html">WCF RIA Services. Implement the Model-View-ViewModel (MVVM) pattern. Part 4</a></li>
<li><a href="../215323/index.html">1World Online: the very first post about who we are and why we are here?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>