<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>H #, create your programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 
 In this article I want to review one of the main innovations in Visual Studio 2010, namely, the functional programming language F #. 

 We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>H #, create your programming language</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/927/acc/7ae/927acc7ae470108b7b9de50242cb76a6.jpg" alt="image" align="right"><br>  Good day. <br>  In this article I want to review one of the main innovations in Visual Studio 2010, namely, the functional programming language F #. <br><br>  We will consider the syntax and potential of F # using the example of creating our own interpreter for the programming language invented by us (After all, it is always more interesting to talk about something with examples). <br><a name="habracut"></a><br>  We describe the task that we are going to solve, namely the syntax of our programming language, it will be quite simple, here‚Äôs something that we want to see: <br><blockquote> <code>function Summ(a,b,c) <br> { <br> val d = a+b+c; <br> print d; <br> return d; <br> } <br> <br> function MyEvaluations(a,b,c) <br> { <br> val in = Summ(a,b,1); <br> val out = Summ(b,c,1); <br> val d = in*out; <br> return d; <br> } <br> <br> function Program() <br> { <br> print(MyEvaluations(1,2,3)); <br> } <br></code> </blockquote><br>  So, we have support for functions with parameter passing and return value, printing, arithmetic operations, and local variables. <br>  We will start to implement it, for this we need to install the additional package F # Power Pack <a href="http://fsharppowerpack.codeplex.com/releases/view/45593">from here</a> <br><br><h4>  Vocabulary </h4>  Now we create a new F # project from the online F # Parsed Language Starter template and clear all files except lexer.fsl <br>  In order to deal with the contents of this file, let's first analyze our language by bone.  Under the word "lexeme", we will understand the minimum building blocks of which a programming language consists. <br>  The lexemes include keywords, brackets, commas, names, in general, everything that the source code of the program consists of.  At the level of tokens, we do not have functions and other <b>logical</b> units. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Open the lexer.fsl file <br>  In F #, the analogue of the namespace is the module keyword, the using analogue is the open keyword, so the first thing we will write now is the definition of the area in which we work: <br><blockquote> <code>{ <br> <font color="blue">module</font> Lexer <br> <font color="blue">open</font> System <br> <font color="blue">open</font> Parser <br> <font color="blue">open</font> Microsoft.FSharp.Text.Lexing <br> <br> <font color="blue">let</font> lexeme lexbuf = <br> LexBuffer&lt;char&gt;.LexemeString lexbuf <br> } <br> <font color="blue">let</font> digit = [ <font color="maroon">'0'</font> - <font color="maroon">'9'</font> ] <br> <font color="blue">let</font> whitespace = [ <font color="maroon">' '</font> <font color="maroon">'\t'</font> ] <br> <font color="blue">let</font> newline = ( <font color="maroon">'\n'</font> | <font color="maroon">'\r'</font> <font color="maroon">'\n'</font> ) <br> <font color="blue">let</font> symbol = [ <font color="maroon">'a'</font> - <font color="maroon">'z''A'</font> - <font color="maroon">'Z'</font> ]</code> </blockquote> <br>  Variables in F # are declared using the let keyword, also, we can use regular expressions here. <br>  So, delete all the code below the line. <br><blockquote> <code>rule tokenize = parse</code> </blockquote> <br>  which is a service marker, denoting that the description of our language goes below, and insert the following code: <br><blockquote> <code>| whitespace { tokenize lexbuf } <br> | newline     { tokenize lexbuf } <br> <br> <font color="green">// Operators</font> <br> | <font color="maroon">"+"</font> { PLUS } <br> | <font color="maroon">"-"</font> { MINUS } <br> | <font color="maroon">"*"</font> { MULTIPLE } <br> | <font color="maroon">"/"</font> { DIVIDE } <br> | <font color="maroon">"="</font> { EQUALS } <br> <br> <font color="green">// Misc</font> <br> | <font color="maroon">"("</font> { LPAREN } <br> | <font color="maroon">")"</font> { RPAREN } <br> | <font color="maroon">","</font> { COMMA } <br> | <font color="maroon">";"</font> { ENDOFLINE } <br> | <font color="maroon">"{"</font> { BEGIN } <br> | <font color="maroon">"}"</font> { END } <br> <br> <font color="green">// Keywords</font> <br> | <font color="maroon">"function"</font> { FUNCTIONKW } <br> | <font color="maroon">"return"</font> { RETURN } <br> | <font color="maroon">"var"</font> { VARIABLE } <br></code> </blockquote><br>  Since this file will be processed by additional means of the PowerPack library, the F # code in this file is immediately surrounded by the first block of curly braces. <br>  This is the simplest part, here we simply write string constants or regular expressions that are present in our language, we will have a few of them: arithmetic operators, brackets, three keywords, a comma and a semicolon. <br>  Further, using regular expressions, we will teach our interpreter to ‚Äúpull out‚Äù the numbers and the names of variables / functions from the code.  In fact, at this stage we turned our plain text code into such a sequence of objects: <br><blockquote> <code>FUNCTIONKEYWORD NAME LPAREN NAME COMMA NAME COMMA NAME RPAREN <br> BEGIN <br> VARIABLE NAME EQUALS NAME PLUS NAME PLUS NAME ENDOFLINE <br> ‚Ä¶.. <br></code> </blockquote><br>  Each object has its own type, which is specified in the example above. <br>  However, the DECIMAL and NAME objects must also have a value. <br>  To do this, we write the following lines: <br><blockquote> <code>| digit+( <font color="maroon">'.'</font> digit+)? { DECIMAL(Double.Parse(lexeme lexbuf)) } <br> | symbol+ { VARNAME(String.Copy(lexeme lexbuf)) } <br> <br> | eof { EOF }</code> </blockquote> <br>  It can be interpreted as a constructor call.  All that is in curly brackets is our data types.  After processing, the program text will be a sequence of objects of these types. <br>  eof - service lexeme, signaling the end of parsed text <br><br><h4>  Syntax parsing </h4>  To make it a little clearer where data types come from, and why NAME has string content, and DECIMAL is numeric - open the Parser.fsy file and paste the following code into it: <br><blockquote> <code>%{ <br> open ParserLibrary <br> open System <br> %} <br> <br> %start start <br> <br> %token &lt;Double&gt; DECIMAL <br> %token PLUS MINUS MULTIPLE DIVIDE <br> %token LPAREN RPAREN <br> %token FUNCTIONKW RETURN VARIABLE <br> %token BEGIN END <br> %token EQUALS <br> %token &lt;String&gt; VARNAME <br> %token ENDOFLINE <br> %token COMMA <br> %token EOF <br> %type &lt;WholeProgram&gt; start <br> <br> %% <br></code> </blockquote><br>  All our data types are listed here, if our type must have a value, then the type of this value is written in angle brackets. <br>  start is the so-called ‚Äúgrammar axiom‚Äù, something that we will try to ‚Äúassemble‚Äù when interpreting our code. <br><br>  A grammar is written in the following form: <br><blockquote> <code>: |     |     | ‚Ä¶ | ‚Ä¶</code> </blockquote> <br>  The first line will look like this: <br><blockquote> <code>start: | WholeProgram</code> </blockquote> <br>  This suggests that the purpose of our analysis is to get "the whole program" <br>  "The whole program" in the closer look we have is just a list of functions <br>  Therefore, we write this fact: <br><blockquote> <code>WholeProgram: <br> | FunctionDescription <br> | WholeProgram FunctionDescription</code> </blockquote> <br>  It is worth noting a rather unusual type of formation of lists in this form of record, the fact is that the number of ‚Äúcomponents‚Äù for each element must be fixed, and in order not to limit the number of possible functions in our language, we go to this trick.  When the system finds the first function - it creates a WholeProgram object from it, when it sees the second function - we have the WholeProgram (from the first function) and FunctionDescription (the second function) next to us, and the system collapses both of these objects into a new WholeProgram, thus removing the restriction on the total number of functions in the program text. <br>  If we illustrate the grammar, we will get something like the following image: <br><img src="https://habrastorage.org/storage/habraeffect/af/4c/af4caf59730449b8bb054f7568dd1358.png"><br>  We now write what the function is: <br><blockquote> <code>FunctionDescription: <br> | FunctionKeyWord FunctionTitle Begin End <br> | FunctionKeyWord FunctionTitle Begin OperatorsList End</code> </blockquote> <br>  We could confine ourselves to the second variant of the presentation, but in this case empty functions would lead to an error in the interpreter, as can be seen from the code, the function consists of a keyword, a title, curly brackets and, possibly, a set of statements inside the function - its body. <br>  The function header consists of its name, parentheses and, possibly, a list of parameters: <br><blockquote> <code>FunctionTitle: <br> | VarName LParen RParen <font color="green">//   </font> <br> | VarName LParen VarName RParen <font color="green">//    .     ,         </font> <br> | VarName LParen VarName AdditionParametersList RParen <font color="green">//    </font></code> </blockquote> <br>  The AdditionParametersList and OperatorsList objects are lists and therefore are defined in the same way as the WholeProgram: <br><blockquote> <code>OperatorsList: <br> | Operator <br> | OperatorsList Operator <br> <br> AdditionParametersList: <br> | Comma VarName <br> | AdditionParametersList Comma VarName</code> </blockquote> <br>  The operator is one line of our program inside the function body, let there be two options in our language: <br><blockquote> <code>Operator: <br> | VaribaleKeyWord VarName Equals Expression EndOfLine <br> | ReturnKeyWord Expression EndOfLine</code> </blockquote> <br>  For example, what corresponds to the lines: <br><blockquote> <code>val d = in*out; <br> return d;</code> </blockquote> <br>  Initially, we had 4 arithmetic operations defined, we take into account that multiplication and division are higher-priority operations than addition and subtraction: <br><blockquote> <code>Expression: <br> | Expression PLUS HighExpression <br> | Expression MINUS HighExpression <br> | HighExpression <font color="green">//     "Operator"'     Expresson,         ""   .</font> <br> HighExpression: <br> | HighExpression MULTIPLY Operand <br> | HighExpression DIVIDE Operand <br> | Operand <font color="green">// ,       -    .</font></code> </blockquote> <br>  This separation allows you to parse the expression 2 + 2 * 2 as Expression Plus HighExpression, and then expand HighExpression into a separate subtree: Expression Plus (HighExpression MULTIPLY Operand), which will allow you to correctly process the priority of operations. <br>  At the lower level, with an operand, we can have either a number, the name of an existing variable, the name of a function, or (if we want) an expression in brackets. <br><blockquote> <code>Operand: <br> | DECIMAL <br> | VarName <br> | FunctionTitle <br> | LParen Expression RParen <font color="green">//   Expression     ,     .</font></code> </blockquote> <br>  Let's return to our F # (now in its pure form) and consider this possibility as constructors with pattern matching, namely, we will describe the data types we just used <br><blockquote> <code><font color="blue">namespace</font> ParserLibrary <br> <font color="blue">open</font> System <br> <br> <font color="blue">type</font> Operator = <br> | VarOperator <font color="blue">of</font> string * Expression <br> | ReturnOperator <font color="blue">of</font> Expression <br> <br> <font color="blue">and</font> Operand = <br> | DECIMALOP <font color="blue">of</font> Double <br> | SUBEXPROP <font color="blue">of</font> Expression <br> | VARNAMEOP <font color="blue">of</font> String <br> | FUNCOP <font color="blue">of</font> FunctionTitle <br> <br> <font color="blue">and</font> HighExpression = <br> | MULTIPLY <font color="blue">of</font> HighExpression * Operand <br> | DIVIDEOP <font color="blue">of</font> HighExpression * Operand <br> | VAR <font color="blue">of</font> Operand <br> <br> <font color="blue">and</font> Expression = <br> | SUMM <font color="blue">of</font> Expression * HighExpression <br> | SUB <font color="blue">of</font> Expression * HighExpression <br> | HighExpression <font color="blue">of</font> HighExpression <br> <br> <font color="blue">and</font> FunctionTitle = String * List&lt;String&gt; <br> <font color="blue">and</font> FunctionDescription = FunctionTitle * OperatorsList <br> <font color="blue">and</font> OperatorsList = List&lt;Operator&gt; <br> <font color="blue">and</font> AdditionParamsList = List&lt;String&gt; <br> <font color="blue">and</font> WholeProgram = List&lt;FunctionDescription&gt;</code> </blockquote> <br>  In fact, we declared 9 objects, each of which has several <b>named</b> constructors with different parameters (in fact, such a set of constructors is similar to a union in C ++) <br>  Note that the asterisk "*" in this context is not a multiplication, but a parameter separator, i.e.  a constructor with the name <b>VarOperator</b> for the <b>Operator</b> type accepts a string (string) and an expression (expression) <br>  All that remains to be done to complete the first part of the writing of our interpreter is to link these data types in the Parser.fsy file; for this, we write the corresponding constructor in front of each condition in curly braces. <br>  It will look like this: <br><blockquote> <code>start: WholeProgram { $1 } <br> <br> WholeProgram: <br> | FunctionDescription { $1 :: [] } <br> | WholeProgram FunctionDescription { $1 @ ($2 :: []) } <br> <br> FunctionTitle: <br> | VARNAME LPAREN RPAREN { $1, [] } <br> | VARNAME LPAREN VARNAME RPAREN { $1, $3 :: [] } <br> | VARNAME LPAREN VARNAME AdditionParamsList RPAREN { $1, $3 :: $4 } <br> <br> AdditionParamsList: <br> | COMMA VARNAME { $2 :: [] } <br> | AdditionParamsList COMMA VARNAME { $1 @ ($3 :: []) } <br> <br> OperatorsList: <br> | Operator { $1 :: [] } <br> | OperatorsList Operator { $1 @ ($2 :: []) } <br> <br> FunctionDescription: <br> | FUNCTIONKW FunctionTitle BEGIN END { $2, [] } <br> | FUNCTIONKW FunctionTitle BEGIN OperatorsList END { $2, $4 } <br> <br> Operator: <br> | VARIABLE VARNAME EQUALS Expression ENDOFLINE { VarOperator($2, $4) } <br> | RETURN Expression ENDOFLINE { ReturnOperator($2) } <br> <br> Expression: <br> | Expression PLUS HighExpression { SUMM($1, $3) } <br> | Expression MINUS HighExpression { SUB($1, $3) } <br> | HighExpression { HighExpression $1 } <br> <br> HighExpression: <br> | HighExpression MULTIPLE Operand { MULTIPLY($1, $3) } <br> | HighExpression DIVIDE Operand { DIVIDEOP($1, $3) } <br> | Operand { VAR $1 } <br> <br> Operand: <br> | DECIMAL { DECIMALOP($1) } <br> | VARNAME { VARNAMEOP($1) } <br> | FunctionTitle { FUNCOP($1) } <br> | LPAREN Expression RPAREN { SUBEXPROP($2) }</code> </blockquote> <br>  $ 1, $ 2, etc.  Is the number of the variable in the condition <br>  Using this code as an example, let's take a look at another great feature of F # - working with lists. <br>  The expression A :: B means creating and returning a new list based on the list B with the addition of the element A <br>  [] - empty list <br>  We can also set lists in code directly or from ranges, for example: <br>  [1,2,3,4,5] or [1..5] <br>  In this case, 100 :: [1..5] will return this list to us: [100,1,2,3,4,5] <br>  The @ operator is the creation of a new list from the union of two existing ones. <br>  For example: [1..5] @ [6..10] returns [1..10] <br><br>  Note that in the case of a choice by template - we specify a named constructor, for the same types that are simply synonymous with any tuples (FunctionDescription, OperatorsList, etc.) - we simply list the parameters in the order we declared in tuple. <br>  So, this is all that is necessary for us to make a parse tree from simple F # text, the second part is interpretation. <br>  Open the Program.fs file and write open for the namespaces that we will use: <br><blockquote> <code><font color="blue">open</font> System <br> <font color="blue">open</font> Microsoft.FSharp.Text.Lexing <br> <font color="blue">open</font> System.Collections.Generic; <br> <font color="blue">open</font> ParserLibrary <br> <font color="blue">open</font> Lexer <br> <font color="blue">open</font> Parser <br></code> </blockquote><br><h4>  Interpretation </h4>  Further, for interpretation, we will need to have a list of functions (or better, a dictionary), named stacks for each function (so that there are no conflicts of variable names) and the name of the function currently being executed. <br>  To do this, we declare variables using the let keyword we already know: <br><blockquote> <code><font color="blue">let</font> stack = Dictionary&lt;String, Dictionary&lt;String,Double&gt;&gt;() <br> <font color="blue">let</font> functionsList = Dictionary&lt;String, FunctionDescription&gt;() <br> <font color="blue">let</font> <font color="blue">mutable</font> currentFunctionName = <font color="maroon">"Program"</font> ; <br></code> </blockquote><br>  In classical functional programming, all objects are immutable, this can be seen in the example of working with lists, when instead of adding an element to the list, we create a new one based on existing ones.  This allows you to safely parallelize the program, because  no need to have complex synchronization to write. <br>  F #, being a functional language, perfectly supports the entire .NET library, allowing you to work with mutable objects.  Full copying of data in this case does not occur, only references to objects are copied, this allows you to reach a compromise on speed without breaking the ability to parallelize data beautifully, a kind of copy on write if you want. <br><br>  So, let's interpret: <br>  Start by parsing the expression. <br>  We declare a function with a choice by template, let rec are keywords, EvaluateExpression is a name, expression is a parameter. <br>  Recall that by declaring types we created constructors with a choice on a template, we use the same templates when choosing a branch for executing a function.  For example: if the passed expression parameter was created using the SUMM constructor (expression, highExpression), then we perform the branch of addition, etc. <br>  It can be noted that this function almost repeats the constructors created earlier, assigning to each of them a specific action. <br><blockquote> <code><font color="blue">let</font> <font color="blue">rec</font> evaluateExpression expression = <br> <font color="blue">match</font> expression <font color="blue">with</font> <br> | SUMM (expr, hexpr) <font color="blue">-&gt;</font> (evaluateExpression expr) + (evaluateHighExpression hexpr) <br> | SUB (expr, hexpr) <font color="blue">-&gt;</font> (evaluateExpression expr) - (evaluateHighExpression hexpr) <br> | HighExpression hexpr <font color="blue">-&gt;</font> evaluateHighExpression hexpr <br> <br> <font color="blue">and</font> evaluateHighExpression highExpression = <br> <font color="blue">match</font> highExpression <font color="blue">with</font> <br> | MULTIPLY (hexpr, oper) <font color="blue">-&gt;</font> (evaluateHighExpression hexpr) * (EvaluateOperand oper) <br> | DIVIDEOP (hexpr, oper) <font color="blue">-&gt;</font> (evaluateHighExpression hexpr) / (EvaluateOperand oper) <br> | VAR oper <font color="blue">-&gt;</font> EvaluateOperand oper <br> <br> <font color="blue">and</font> EvaluateOperand oper = <br> <font color="blue">match</font> oper <font color="blue">with</font> <br> | DECIMALOP x <font color="blue">-&gt;</font> x <br> | VARNAMEOP x <font color="blue">-&gt;</font> stack.Item(currentFunctionName).Item(x) <br> | FUNCOP x <font color="blue">-&gt;</font> evaluateFunction x <br> | SUBEXPROP x <font color="blue">-&gt;</font> evaluateExpression x</code> </blockquote> <br>  Since we have introduced support for variables and functions, we need to write handlers for this case.  In the case of variables, everything is more or less simple, we go to a dictionary containing the values ‚Äã‚Äãof the variables of the current function and get the value by the name of the variable (remember that VARNAMEOP is associated with the String type) <br><br>  In the case of hitting a function, we need to copy the parameters from the calling function in accordance with the function header and start its execution. <br>  To do this, we add the following code: <br><blockquote> <code><font color="blue">and</font> evaluateFunction(f:FunctionTitle) = <br> <font color="blue">let</font> caller = currentFunctionName; <br> <font color="blue">let</font> newStack = Dictionary&lt;String, Double&gt;() <br> <font color="blue">let</font> realParams = functionsList.Item (f |&gt; GetFunctionName) |&gt; GetFormalParamsListDecription <br> <br> <font color="blue">let</font> formalParams = GetFormalParamsListTitle(f) <br> ignore &lt;| List.mapi2 ( <font color="blue">fun</font> i x y <font color="blue">-&gt;</font> newStack.Add(x, stack.Item(caller).Item(y))) realParams formalParams <br> <br> currentFunctionName &lt;- GetFunctionName(f) <br> stack.Add(currentFunctionName, newStack) <br> <br> <font color="blue">let</font> operatorsList = functionsList.Item(GetFunctionName f) |&gt; GetOperatorsList <br> <br> <font color="blue">let</font> result =  RunFunction operatorsList <br> <br> ignore &lt;| stack.Remove(currentFunctionName) <br> <br> currentFunctionName &lt;- caller <br> result <br> <font color="green">//        </font></code> </blockquote> <br>  This is also a function, but no longer with a choice on the basis of a template, but in a more familiar form. <br><br>  Let's sort the operator of the pipeline (pipeline) ‚Äú|&gt;‚Äù, in fact, it is a more understandable way to call chains of functions, if earlier we had to write OuterFunction (InnerFunction (Validate (data))), then in F # you can ‚Äúexpand‚Äù this chain: data |&gt; Validate |&gt; InnerFunction |&gt; OuterFunction <br>  Both entries lead to the same result, but when using the ‚Äú|&gt;‚Äù operator, we use functions from left to right, in the case of long chains, this is more convenient. <br>  A feature of these functions is that we do not need to write return, for example, the function <br>  test (a) = a * 10 <br>  returns a * 10, this is partly convenient, but we need to take care not to return any value "by chance" (by the way, VS will emphasize all unintended returns), for this we use the ignore method, which does nothing and nothing returns that we have all ignore at the beginning of the line - we use the inverse pipelined operator "&lt;|", it does the same as ‚Äú|&gt;‚Äù, only in the opposite direction, now the functions are applied from right to left. <br>  In the case of simple assignment, to avoid returning the value, instead of ‚Äú=‚Äù, the ‚Äú&lt;-‚Äú operator is used. <br><br>  Let's analyze the line in more detail: <br><blockquote> <code>ignore &lt;| List.mapi2 ( <font color="blue">fun</font> i x y <font color="blue">-&gt;</font> newStack.Add(x, stack.Item(caller).Item(y))) realParams formalParams</code> </blockquote> <br>  The List class contains a set of mapi * methods (for different numbers of lists), the essence of these methods is that they process several lists (in our case 2) in parallel, passing the element number in both lists and the elements themselves to the handler function, assuming that they are lists are equal.  The mapi2 method takes 3 parameters, a handler function and two lists to be processed. <br>  For example, as a result of executing the following code: <br><blockquote> <code><font color="blue">let</font> firstList = [1..5] <br> <font color="blue">let</font> secondList = [6..10] <br> ignore &lt;| List.mapi2 ( <font color="blue">fun</font> i x y <font color="blue">-&gt;</font> Console.WriteLine(10*x+y)) firstList secondList</code> </blockquote>  We will get the result: 16 27 38 49 60 <br><br>  Since the order of the parameters in brackets when calling a function and when describing it in our language is the same, we simply process the elements from the lists of the call and the function declaration in pairs. <br>  The fun keyword defines a new function (you can draw an analogy with lambdas in C #), which we will use to process lists, our function takes 3 parameters, i is the number of the current element in both lists, x and y are the elements from the first and second lists respectively . <br>  So here we are copying to our new stack a variable from the stack of the calling function. <br><br>  After preparing the parameters, we call the function, memorize the result, delete the dictionary (stack), and restore the name of the calling function. <br><blockquote> <code><font color="blue">let</font> result =  RunFunction operatorsList <br> <br> ignore &lt;| stack.Remove(currentFunctionName) <br> <br> currentFunctionName &lt;- caller <br> result</code> </blockquote> <br>  Because  no need to write return, to return the value, just write the name of the variable that we want to return. <br><br>  Now we write the runFunction method: <br><blockquote> <code><font color="blue">and</font> RunFunction(o:OperatorsList) = <br> ignore &lt;| List.map ( <font color="blue">fun</font> x <font color="blue">-&gt;</font> EvaluateOperator x) o <br> stack.Item(currentFunctionName).Item( <font color="maroon">"return"</font> )</code> </blockquote> <br>  The List.map method iterates over all elements of the list, then we simply return the resulting variable from our current stack. <br><blockquote> <code><font color="blue">and</font> EvaluateOperator operator = <br> <font color="blue">match</font> operator <font color="blue">with</font> <br> | VarOperator (name, expr) <font color="blue">-&gt;</font> stack.Item(currentFunctionName).Add(name, evaluateExpression expr) <br> | ReturnOperator expr <font color="blue">-&gt;</font> stack.Item(currentFunctionName).Add( <font color="maroon">"return"</font> , evaluateExpression expr)</code> </blockquote> <br>  In our language, there are only 2 types of operators, this is either a declaration of a variable or a return value, in both cases we calculate the value and add it to the dictionary (stack), in the case of return we use the fact that return in our language is a key word and we can safely use it for their own purposes, without fear of conflict with an already declared variable. <br>  Since we want to use a couple of predefined functions in our language, for I / O, we add a few checks: <br><blockquote> <code><font color="blue">and</font> RunFunction(o:OperatorsList) = <br> <font color="blue">if</font> currentFunctionName.Equals <font color="maroon">"print"</font> <font color="blue">then</font> <br> stack.Item(currentFunctionName).Add( <font color="maroon">"return"</font> , 0.0) <br> Console.WriteLine(stack.Item(currentFunctionName).Item( <font color="maroon">"toPrint"</font> ).ToString()) <br> <font color="blue">if</font> currentFunctionName.Equals <font color="maroon">"get"</font> <font color="blue">then</font> <br> Console.Write( <font color="maroon">"Input: "</font> ); <br> stack.Item(currentFunctionName).Add( <font color="maroon">"return"</font> , Double.Parse(Console.ReadLine())) <br> <font color="blue">if</font> currentFunctionName.Equals <font color="maroon">"Program"</font> <font color="blue">then</font> <br> stack.Item(currentFunctionName).Add( <font color="maroon">"return"</font> , 1.0) <br> <br> ignore &lt;| List.map ( <font color="blue">fun</font> x <font color="blue">-&gt;</font> EvaluateOperator x) o <br> stack.Item(currentFunctionName).Item( <font color="maroon">"return"</font> )</code> </blockquote> <br>  We check the name of the function and, depending on the result, execute or print the value of the variable, or read the value from the keyboard. <br>  In order not to write in the main method return - we define the spec.  variable before the execution of the function body. <br><br>  F # uses meaningful padding, in particular, to select the body of if blocks. <br>  The last thing left to do is to identify the missing functions that we used and write a shell that our parser will use: <br><blockquote> <code><font color="blue">let</font> GetFunctionName f = <font color="blue">match</font> f <font color="blue">with</font> name, foo <font color="blue">-&gt;</font> name <br> <font color="blue">let</font> GetFunctionNameDescription f = <font color="blue">match</font> f <font color="blue">with</font> t, foo <font color="blue">-&gt;</font> GetFunctionName t <br> <font color="blue">let</font> GetFormalParamsListTitle t = <font color="blue">match</font> t <font color="blue">with</font> foo, paramerers <font color="blue">-&gt;</font> paramerers <br> <font color="blue">let</font> GetFormalParamsListDecription f = <font color="blue">match</font> f <font color="blue">with</font> t, foo <font color="blue">-&gt;</font> GetFormalParamsListTitle t <br> <font color="blue">let</font> GetOperatorsList f = <font color="blue">match</font> f <font color="blue">with</font> foo, o <font color="blue">-&gt;</font> o <br> <font color="blue">let</font> GetTitle f = <font color="blue">match</font> f <font color="blue">with</font> t, too <font color="blue">-&gt;</font> t</code> </blockquote> <br>  Since we declared some types simply synonyms, after the word with does not come the name of the constructor, there is just an enumeration of all parameters, after the arrow comes the body of the function, in this case we just write the name of the variable to be returned. <br>  If writing a function call without parentheses is unusual for you, F # allows you to write code like this: <br><blockquote> <code><font color="blue">let</font> GetFunctionName(f) = <font color="blue">match</font> f <font color="blue">with</font> name, foo <font color="blue">-&gt;</font> name <br> <font color="blue">let</font> GetFunctionNameDescription(f) = <font color="blue">match</font> f <font color="blue">with</font> t, foo <font color="blue">-&gt;</font> GetFunctionName(t) <br> <font color="blue">let</font> GetFormalParamsListTitle(t) = <font color="blue">match</font> t <font color="blue">with</font> foo, paramerers <font color="blue">-&gt;</font> paramerers <br> <font color="blue">let</font> GetFormalParamsListDecription(f) = <font color="blue">match</font> f <font color="blue">with</font> t, foo <font color="blue">-&gt;</font> GetFormalParamsListTitle(t) <br> <font color="blue">let</font> GetOperatorsList(f) = <font color="blue">match</font> f <font color="blue">with</font> foo, o <font color="blue">-&gt;</font> o <br> <font color="blue">let</font> GetTitle(f) = <font color="blue">match</font> f <font color="blue">with</font> t, too <font color="blue">-&gt;</font> t</code> </blockquote> <br>  These entries are absolutely equivalent. <br><br><h4>  Finishing touches </h4>  And finally the last: <br><blockquote> <code>printfn <font color="maroon">"H#"</font> <br> <br> <font color="blue">let</font> <font color="blue">mutable</font> source = <font color="maroon">""</font> ; <br> <font color="blue">let</font> <font color="blue">rec</font> readAndProcess() = <br> printf <font color="maroon">":"</font> <br> <font color="blue">match</font> Console.ReadLine() <font color="blue">with</font> <br> | <font color="maroon">"quit"</font> <font color="blue">-&gt;</font> () <br> | <font color="maroon">"GO"</font> <font color="blue">-&gt;</font> <br> <font color="blue">try</font> <br> printfn <font color="maroon">"Lexing..."</font> <br> <font color="blue">let</font> lexbuff = LexBuffer&lt;char&gt;.FromString(source) <br> <br> printfn <font color="maroon">"Parsing..."</font> <br> <font color="blue">let</font> program = Parser.start Lexer.tokenize lexbuff <br> ignore &lt;| List.map ( <font color="blue">fun</font> x <font color="blue">-&gt;</font> functionsList.Add(GetFunctionNameDescription(x),x)) program <br> functionsList.Add( <font color="maroon">"print"</font> ,(( <font color="maroon">"print"</font> , [ <font color="maroon">"toPrint"</font> ]), [])) <br> functionsList.Add( <font color="maroon">"get"</font> ,(( <font color="maroon">"get"</font> , []), [])) <br> printfn <font color="maroon">"Running..."</font> <br> ignore &lt;| (functionsList.Item( <font color="maroon">"Program"</font> ) |&gt; GetTitle |&gt; evaluateFunction) <br> <br> <font color="blue">with</font> ex <font color="blue">-&gt;</font> <br> printfn <font color="maroon">"Unhandled Exception: %s"</font> ex.Message <br> <br> readAndProcess() <br> | expr <font color="blue">-&gt;</font> <br> source &lt;- source + expr <br> readAndProcess() <br> <br> readAndProcess()</code> </blockquote> <br>  We define a new function in which we will try to parse the string entered from the keyboard, if the parsing is completed successfully, we add all the functions from the resulting list (program) to our variable functionsList. <br>  To call a function at the beginning of the program, simply write its name without indents at the end of the file. <br>  Since we have two predefined functions in our language (get and print), we add them, then we perform a function with the name Program. <br><br>  The last thing that can be described in this example is an interesting way to construct objects for which we have not defined constructors through match. <br><blockquote> <code><font color="blue">and</font> FunctionTitle = String * List&lt;String&gt; <br> <font color="blue">and</font> FunctionDescription = FunctionTitle * OperatorsList <br> <font color="blue">and</font> OperatorsList = List&lt;Operator&gt; <br> <font color="blue">and</font> AdditionParamsList = List&lt;String&gt; <br> <font color="blue">and</font> WholeProgram = List&lt;FunctionDescription&gt;</code> </blockquote> <br>  If we expect the FunctionTitle object, to create it, it is enough to enclose its parameters (String and &lt;ListString&gt;) in parentheses, there is no need to specify the data type. <br><blockquote> <code>( <font color="maroon">"print"</font> ,(( <font color="maroon">"print"</font> , [ <font color="maroon">"toPrint"</font> ]), []))</code> </blockquote> <br><h4>  Launch </h4>  Well, let's run our interpreter: <br><img alt="i" src="https://habrastorage.org/storage/habraeffect/22/67/22673e7552595d810e5e7dc98ffd5715.png"><br><br>  After pressing Enter we will see an invitation to enter the value of the variable: <br><img alt="i" src="https://habrastorage.org/storage/habraeffect/52/1b/521bdf81bbe85dbdd397d2920ed68da9.png"><br><br>  And after that: <br><img alt="i" src="https://habrastorage.org/storage/habraeffect/f1/bb/f1bbad4b5dcbc3714b418312673b501c.png"><br><br>  Well, the program really works. <br>  The source code with binaries can be downloaded <a href="http://slil.ru/29414182">here</a> . <br><br>  If you now look at the F # code once more, you can see that we wrote a minimum, just describing what we want to do, it allowed us to write our own interpreter and fit only ~ 200 lines of code, F # allows us to get rid of the routine writing work code that does not answer the question ‚Äúwhat‚Äù, but answers the question ‚Äúhow‚Äù.  Of course, programming in this language seems difficult at first, but in some cases it is worth it, as it allows you to write flexible code that is easy to maintain. <br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/97861/">https://habr.com/ru/post/97861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../97854/index.html">What is a good software manual?</a></li>
<li><a href="../97855/index.html">Software Asset Management - How to maintain once-established order?</a></li>
<li><a href="../97857/index.html">30 years of programming in faces</a></li>
<li><a href="../97859/index.html">Archivist - save your interests from Twitter</a></li>
<li><a href="../97860/index.html">"Mouse King" WarMouse Meta went on sale</a></li>
<li><a href="../97863/index.html">How to return the evacuated car without getting up from the chair</a></li>
<li><a href="../97864/index.html">The problem with the iPhone 4 antenna will not be fixed by software update.</a></li>
<li><a href="../97866/index.html">Opera 10.60 RC3</a></li>
<li><a href="../97870/index.html">The founders of Parallels, Acronis and Almaz have created a seed investment fund.</a></li>
<li><a href="../97871/index.html">Newspaper ¬´FOSS News¬ª ‚Ññ6 (18) 2010</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>