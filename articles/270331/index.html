<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to do almost no exceptions, replacing them with notifications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. 

 Sometimes you come across articles that you want to translate just for the name. Even more interesting, when such an article can be us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to do almost no exceptions, replacing them with notifications</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr. <br><br>  Sometimes you come across articles that you want to translate just for the name.  Even more interesting, when such an article can be useful for specialists in different languages, but contains examples in Java.  Very soon, we hope to share with you our newest idea about the publication of a large book on Java, but for now we offer you to get acquainted with the publication of Martin Fowler from December 2014, which has not yet been translated into Russian.  The translation is made with small abbreviations. <br><a name="habracut"></a><br>  <i>If you are validating certain data, you usually should not use exceptions as a signal that validation has failed.</i>  <i>Here I will describe refactoring of a similar code using the ‚ÄúNotification‚Äù pattern.</i> <br><br>  Recently, I caught the eye of code that performed the simplest validation of JSON messages.  He looked like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); }</code> </pre> <br><br>  This is usually how validation is performed.  You apply several validation options to the data (the above are just a few fields of the whole class).  If at least one verification step fails, an exception is thrown with an error message. <br><br>  I had some problems with this approach.  First, I do not like to use exceptions in such cases.  An exception is a signal of some extraordinary event in the code in question.  But if you subject some external input to verification, then you assume that the entered messages may contain errors - that is, errors are expected, and it is wrong to use exceptions in this case. <br><br>  The second problem with such a code is that if it crashes after the first error detected, it is better to report all errors that occurred in the input data, and not just the first one.  In this case, the client will be able to display all errors to the user at once, so that he corrects them in one operation, and not force the user to play cat and mouse with the computer. <br><br>  In such cases, I prefer to organize the reporting of validation errors using the ‚ÄúNotification‚Äù pattern.  A notification is an object that collects errors; for each failed validation act, a regular error is added to the notification.  The validation method returns a notification, which you can then parse for additional information.  A simple example is the following code to perform checks. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateNumberOfSeats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  You can then make a simple call like aNotification.hasErrors () to respond to errors, if any.  Other methods in the notification can get to the details of errors. <br><br><img src="https://habrastorage.org/files/3b1/b8b/c24/3b1b8bc24ab94f2ba1f16cd309669aa5.png"><br><br>  <b>When to apply such refactoring</b> <br><br>  Here I note that I do not urge to get rid of exceptions in your entire code base.  Exceptions are a very convenient way to handle abnormal situations and remove them from the main logical flow.  The proposed refactoring is relevant only in cases where the result reported by means of an exception is not really exceptional, which means it must be processed by the main logic of the program.  The validation considered here is just such a case. <br><br>  Convenient "iron rule", which is to use when implementing exceptions, we find in Pragmatic Programmers: <br><br><blockquote>  We believe that exceptions should only be used sporadically in the normal course of a program;  it is necessary to resort to them at exceptional events.  Suppose that an uncaught exception completes your program, and ask yourself: "Will this code continue to function if you remove exception handlers from it?"  If the answer is no, then exceptions are likely to apply in non-exclusive situations. </blockquote><br><br>  - Dave Thomas and Andy Hunt <br><br>  Hence the important consequence: the decision whether to use exceptions for a specific task depends on its context.  So, continue with Dave and Andy, reading from a file not found in different contexts may or may not be an exceptional situation.  If you are trying to read a file from a well-known location, for example / etc / hosts on a Unix system, it is logical to assume that the file should be there, and otherwise it is advisable to throw an exception.  On the other hand, if you try to read a file located along the path entered by the user on the command line, you must assume that the file will not be there, and use another mechanism ‚Äî one that signals the non-exclusive nature of the error. <br><br>  There is a case in which it would be wise to use exceptions for validation errors.  The situation is implied: there is data that should have already been validated at an earlier stage of processing, but you want to re-do such a check in order to be safe from program errors that could cause some unacceptable data to slip. <br><br>  This article talks about replacing exceptions with notifications in the context of validating raw input.  This technique will be useful to you in those cases where notification is a more expedient option than an exception, but here we will focus on the option with validation as the most common. <br><br>  <b>Start</b> <br><br>  So far I have not mentioned the subject area, since I have described only the most general structure of the code.  But further with the development of this example, it will be necessary to more precisely outline the subject area.  It will be a question of the code accepting in the JSON format messages on booking seats in the theater.  The code is a booking request class that is populated based on JSON information using the gson library. <br><br><pre> <code class="java hljs">gson.fromJson(jsonString, BookingRequest.class)</code> </pre><br>  Gson takes a class, searches for any fields that satisfy the key in a JSON document, and then fills in such fields. <br><br>  This booking request contains only two elements that we will validate: the date of the event and the number of reserved seats <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer numberOfSeats; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String date;   ‚Äî ,     <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookingRequest</span></span></span><span class="hljs-class">‚Ä¶ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); }</code> </pre><br>  <b>Create notification</b> <br><br>  To use a notification, you need to create a special object for it.  The notification can be very simple, sometimes it consists of just a list of strings. <br><br>  Notification accumulates errors <br><br><pre> <code class="java hljs">List&lt;String&gt; notification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) notification.add(<span class="hljs-string"><span class="hljs-string">"number of seats too small"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     // ‚Ä¶ if ( ! notification.isEmpty()) //   </span></span></code> </pre><br>  Although the simple list idiom provides a lightweight implementation of the pattern, I prefer not to be limited to this and write a simple class. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Notification</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt; errors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message)</span></span></span><span class="hljs-function"> </span></span>{ errors.add(message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ! errors.isEmpty(); } ‚Ä¶</code> </pre><br><br>  Using the real class, I express my intention more clearly - the reader of the code does not have to mentally correlate the idiom and its full meaning. <br><br>  <b>We decompose the verification method into pieces.</b> <br><br>  First, I will divide the verification method into two parts.  The interior will eventually work only with notifications and will not issue any exceptions.  The external part will retain the actual behavior of the verification method ‚Äî that is, it will throw an exception if the validation fails. <br><br>  To do this, I first of all use the method selection in an unusual way: I move the whole body of the verification method into the validation method. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ validation(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); }</code> </pre><br><br>  Then I will correct the validation method so that it creates and returns a notification. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; }</code> </pre><br><br>  Now I can check the notification and throw an exception if it contains errors. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (validation().hasErrors()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(validation().errorMessage()); }</code> </pre><br>  I made the validation method public because I expect that most callers in the future will prefer to use this method rather than the verification method. <br><br>  By splitting the original method into two parts, I delimit the validation check from deciding how to respond to an error. <br><br>  At this stage, I have not touched the behavior of the code at all.  The notification will not contain any errors, and any failed validation checks will continue to throw exceptions, ignoring any new machinery I add here.  But I am preparing the ground to replace the issuance of exceptions to work with notifications. <br><br>  Before you begin this, you need to say something about error messages.  When refactoring, there is a rule: to avoid changes in the observed behavior.  In situations like this, this rule immediately poses the question: what behavior is observable?  Obviously, issuing a correct exception will be noticeable to a certain extent for an external program - but to what extent is the error message relevant for it?  As a result, the notification accumulates a lot of errors and can summarize them into a single message, like this: <br><br>  <i>class Notification ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.stream() .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); }</code> </pre><br>  But a problem will arise here, if at a higher level, the program‚Äôs execution is tied to receiving a message about the first error detected, and then you need something like: <br><br>  <i>class Notification ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  It is necessary to pay attention not only to the calling function, but also to all exception handlers in order to determine an adequate response to this situation. <br><br>  Although here I could not in any way provoke any problems, I will compile and test this code before making new changes. <br><br>  <b>Validation number</b> <br><br>  The most obvious step in this case is to replace the first validation. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; }</code> </pre><br>  The obvious step, but bad because it will break the code.  If you pass an empty date to the function, the code adds an error to the notification, but then immediately tries to parse it and throws a null pointer exception ‚Äî and we are not interested in this exception. <br><br>  Therefore, in this case it is better to do a less rectilinear, but more effective thing - a step backwards. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; }</code> </pre><br>  The previous check is a zero check, so we need a conditional construct that would allow us not to create an exception of the null pointer. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; }</code> </pre><br>  I see that the next check affects a different field.  Not only that at the previous stage of refactoring I would have to introduce a conditional construction - now it seems to me that the validation method becomes too complicated and could be expanded.  So, we select the parts responsible for the validation of numbers. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); validateNumberOfSeats(note); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateNumberOfSeats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); }</code> </pre><br>  I look at the highlighted number validation, and I don‚Äôt like its structure.  I don‚Äôt like to use if-then-else blocks during validation, because it can easily turn out code with an excessive number of attachments.  I prefer linear code, which stops working immediately, as soon as program execution becomes impossible - such a point can be determined using a boundary condition.  So I implement the replacement of nested conditional constructions with boundary conditions. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateNumberOfSeats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats cannot be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfSeats &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) note.addError(<span class="hljs-string"><span class="hljs-string">"number of seats must be positive"</span></span>); }</code> </pre><br><br>  When refactoring, you should always try to take minimal steps to preserve the existing behavior. <br><br>  My decision to take a step back plays a key role in refactoring.  The essence of refactoring is to change the structure of the code, but in such a way that the transformations performed do not change its behavior.  Therefore, refactoring should always be done in small steps.  So we are safe from the occurrence of errors that can overtake us in the debugger. <br><br>  <b>Date validation</b> <br><br>  When validating a date, I start again with <a href="http://refactoring.com/catalog/extractMethod.html">highlighting the method</a> : <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification note = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification(); validateDate(note); validateNumberOfSeats(note); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> note; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); }</code> </pre><br>  When I used automated method highlighting in my IDE, the resulting code did not include the notification argument.  So I tried to add it manually. <br><br>  Now let's go back to date validation: <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) note.addError(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); }</code> </pre><br>  At the second stage, there is a complication with error handling, since there is a conditional exception in the thrown exception.  To process it, you will need to change the notification so that it can accept such exceptions.  Since I'm halfway there: I refuse to throw exceptions and go to work with notifications - my code is red.  So, I roll back to leave the validateDate method as above, and prepare a notification to accept a conditional exception. <br><br>  Starting to change the notification, I add the addError method that accepts the condition, and then I change the original method so that it can call the new method. <br><br>  <i>class Notification ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message)</span></span></span><span class="hljs-function"> </span></span>{ addError(message, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Exception e)</span></span></span><span class="hljs-function"> </span></span>{ errors.add(message); }</code> </pre><br>  Thus, we accept a conditional exception, but ignore it.  To place it somewhere, I need to turn an error record from a simple string into a slightly more complex object. <br><br>  <i>class Notification ...</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ String message; Exception cause; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Exception cause)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cause = cause; } }</code> </pre><br><br>  I do not like non-private fields in Java, however, since here we are dealing with a private inner class, everything suits me.  If I was going to open access to this class of error somewhere outside the notification, I would encapsulate these fields. <br><br>  So, I have a class.  Now you need to modify the notification to use it, not a string. <br><br>  <i>class Notification ...</i> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Error&gt; errors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Exception e)</span></span></span><span class="hljs-function"> </span></span>{ errors.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(message, e)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.stream() .map(e -&gt; e.message) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); }</code> </pre><br><br>  Having a new notice, I can make changes to the request for booking <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { note.addError(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) note.addError(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>);</code> </pre><br>  Since I am already in the selected method, it is easy to cancel the remaining validation using the return command. <br><br>  The last change is quite simple. <br><br>  <i>class BookingRequest ...</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Notification note)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (date == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { note.addError(<span class="hljs-string"><span class="hljs-string">"date is missing"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LocalDate parsedDate; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parsedDate = LocalDate.parse(date); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (DateTimeParseException e) { note.addError(<span class="hljs-string"><span class="hljs-string">"Invalid format for date"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedDate.isBefore(LocalDate.now())) note.addError(<span class="hljs-string"><span class="hljs-string">"date cannot be before today"</span></span>); }</code> </pre><br><br>  <b>Up stack</b> <br><br>  Now that we have a new method, the next task is to see who is calling the original verification method and correct these elements so that they use the new validation method in the future.  Here we will have to consider in a broader context how this structure fits into the general logic of the application, so this problem goes beyond the scope of refactoring considered here.  But our medium-term task is to get rid of the use of exceptions, which are indiscriminately applied in all cases of possible failure to validate. <br><br>  In many situations, this will allow to get rid of the verification method altogether - then all tests related to it will have to be rewritten so that they work with the validation method.  In addition, correction of tests may be needed to check whether errors in the notification are accumulated correctly. <br><br>  <b>Frameworks</b> <br><br>  A number of frameworks provide the ability to validate using a notification pattern.  In Java, this is <a href="https://en.wikipedia.org/wiki/Bean_Validation">Java Bean Validation</a> and <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html">Spring validation</a> .  These frameworks serve as original interfaces that initiate validation and use a notification to collect errors ( <code><code>Set    Errors <br>   Spring). <br> <br>        ,     ,  .       ,       .</code></code> <code><code>Set    Errors <br></code>   Spring). <br> <br>        ,     ,  .       ,       .</code> </div><p>Source: <a href="https://habr.com/ru/post/270331/">https://habr.com/ru/post/270331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270321/index.html">Workflow automation for a small development team (Part 2)</a></li>
<li><a href="../270323/index.html">Microsoft cloud-based prescription services: the practice of Russian service providers</a></li>
<li><a href="../270325/index.html">Next, in search of palindromes</a></li>
<li><a href="../270327/index.html">Call Tracking Paying Lead, Not Numbers</a></li>
<li><a href="../270329/index.html">Correctly parsim logs from 3CX</a></li>
<li><a href="../270333/index.html">Unofficial Firebird 3.0 Release Candidate 1 Installer</a></li>
<li><a href="../270335/index.html">SAP ERP / ABAP useful resources</a></li>
<li><a href="../270337/index.html">MagOS in industrial application</a></li>
<li><a href="../270339/index.html">Observer vs Pub-Sub</a></li>
<li><a href="../270343/index.html">Building native applications in ExtJS 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>