<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Instructions: How to create bots in Telegram</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="June 24 Telegram developers have opened a platform for creating bots. The news has bypassed Habr, but many have already begun to develop quizzes. At t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Instructions: How to create bots in Telegram</h1><div class="post__text post__text-html js-mediator-article">  June 24 Telegram developers <a href="https://core.telegram.org/bots">have opened a</a> platform for creating bots.  The news has bypassed Habr, but many have already begun to develop quizzes.  At the same time, at least some examples of working bots are indicated. <br><a name="habracut"></a><br>  First of all, the Telegram bot is still an application running on your side and making requests to the <a href="https://core.telegram.org/bots/api">Telegram Bot API</a> .  Moreover, the API is a simple content - the bot accesses a specific URL with parameters, and Telegram responds with a JSON object. <br><br>  Consider the API on the example of creating a trivial bot: <br><br><h3>  1. Registration </h3><br>  Before starting development, a bot must register and receive its unique id, which is also a token.  For this, there is a special bot in Telegram - <a href="https://telegram.me/botfather">@BotFather</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We write him / start and get a list of all his commands. <br>  The first and main - / newbot - is sent to him and the bot asks to invent a name for our new bot.  The only restriction on the name - in the end it must end in ¬´bot¬ª.  If successful, BotFather returns the bot token and a link to quickly add the bot to the contacts, otherwise you will have to break your head over the name. <br><br>  To get started, this is enough.  Particularly pedantic can assign a bot avatar, a description and a welcome message here. <br><br>  Do not forget to check the received token using the <a href="https://api.telegram.org/bot%253CTOKEN%253E/getMe">api.telegram.org/bot&lt;TOKEN&gt;/getMe</a> link, they say, it does not always work the first time. <br><br><h3>  2. Programming </h3><br>  I will create a bot on Python3, however, due to the adequacy of this language, algorithms are easily transferred to any other. <br><br>  Telegram allows you not to upload messages manually, but to put webHook, and then they will send each message themselves.  For Python, in order not to bother with cgi and threads, it is convenient to use some kind of reactor, so I chose tornado.web for implementation.  (for GAE it is convenient to use a bunch of Python2 + Flask) <br><br>  Bot frame: <br><br><pre><code class="python hljs">URL = <span class="hljs-string"><span class="hljs-string">"https://api.telegram.org/bot%s/"</span></span> % BOT_TOKEN MyURL = <span class="hljs-string"><span class="hljs-string">"https://example.com/hook"</span></span> api = requests.Session() application = tornado.web.Application([ (<span class="hljs-string"><span class="hljs-string">r"/"</span></span>, Handler), ]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: signal.signal(signal.SIGTERM, signal_term_handler) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: set_hook = api.get(URL + <span class="hljs-string"><span class="hljs-string">"setWebhook?url=%s"</span></span> % MyURL) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> set_hook.status_code != <span class="hljs-number"><span class="hljs-number">200</span></span>: logging.error(<span class="hljs-string"><span class="hljs-string">"Can't set hook: %s. Quit."</span></span> % set_hook.text) exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) application.listen(<span class="hljs-number"><span class="hljs-number">8888</span></span>) tornado.ioloop.IOLoop.current().start() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: signal_term_handler(signal.SIGTERM, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br>  Here, when we start the bot, we install a webhost to our address and catch the exit signal to return the behavior with manual event upload. <br><br>  The tornado application for processing requests takes the class tornado.web.RequestHandler, in which will be the logic of the bot. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tornado.web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: logging.debug(<span class="hljs-string"><span class="hljs-string">"Got request: %s"</span></span> % self.request.body) update = tornado.escape.json_decode(self.request.body) message = update[<span class="hljs-string"><span class="hljs-string">'message'</span></span>] text = message.get(<span class="hljs-string"><span class="hljs-string">'text'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text: logging.info(<span class="hljs-string"><span class="hljs-string">"MESSAGE\t%s\t%s"</span></span> % (message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>], text)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'/'</span></span>: command, *arguments = text.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) response = CMD.get(command, not_found)(arguments, message) logging.info(<span class="hljs-string"><span class="hljs-string">"REPLY\t%s\t%s"</span></span> % (message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>], response)) send_reply(response) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: logging.warning(str(e))</code> </pre><br>  Here CMD is a dictionary of available commands, and send_reply is the function of sending a response, which accepts an already created <a href="https://core.telegram.org/bots/api">Message</a> object as input. <br><br>  Actually, its code is quite simple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: api.post(URL + <span class="hljs-string"><span class="hljs-string">"sendMessage"</span></span>, data=response)</code> </pre><br><br>  Now that the entire logic of the bot has been described, you can start inventing commands for it. <br><br><h3>  3. Teams </h3><br>  First of all, it is necessary to observe the Telegram agreement and teach the bot to two commands: / start and / help: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">help_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arguments, message)</span></span></span><span class="hljs-function">:</span></span> response = {<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>: message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>]} result = [<span class="hljs-string"><span class="hljs-string">"Hey, %s!"</span></span> % message[<span class="hljs-string"><span class="hljs-string">"from"</span></span>].get(<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>), <span class="hljs-string"><span class="hljs-string">"\rI can accept only these commands:"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> command <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CMD: result.append(command) response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] = <span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>.join(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response</code> </pre><br><br>  The message ['from'] structure is an object of type <a href="https://core.telegram.org/bots/api">User</a> , it provides the bot with information about both the user's id and the name of the user.  For answers, it is more useful to use message ['chat'] ['id'] - in the case of personal communication there will be a User, and in the case of a chat - a chat id.  Otherwise, you can get a situation where the user writes in the chat, and the bot responds in lichku. <br><br>  The / start command without parameters is used to display information about the bot, and with parameters it is used for identification.  It is useful to use it for actions that require authorization. <br><br>  After that, you can add some of your own command, for example, / base64: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arguments, message)</span></span></span><span class="hljs-function">:</span></span> response = {<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>: message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] = b64decode(<span class="hljs-string"><span class="hljs-string">" "</span></span>.join(arguments).encode(<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] = <span class="hljs-string"><span class="hljs-string">"Can't decode it"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response</code> </pre><br><br>  For users of Mobile Telegram, it will be useful to tell @BotFather which commands our bot accepts: <br> <code>I: /setcommands <br> BotFather : Choose a bot to change the list of commands. <br> I: @******_bot <br> BotFather: OK. Send me a list of commands for your bot. Please use this format: <br> <br> command1 - Description <br> command2 - Another description <br> I: <br> whoisyourdaddy - Information about author <br> base64 - Base64 decode <br> BotFather: Success! Command list updated. /help <br></code> <br><br>  With such a description, if the user dials /, Telegram will helpfully show a list of all available commands. <br><br><h3>  4. Freedom </h3><br>  As you can see, Telegram sends the entire message, not a broken one, and the restriction that commands begin with a slash is for the convenience of mobile users only.  Thanks to this, you can teach the bot to speak a little humanly. <br><br>  <b>UPD:</b> As correctly suggested, this will take place only in person.  In chat rooms only messages that start with the command (/ &lt;command&gt;) are delivered to the bot (https://core.telegram.org/bots#privacy-mode) <br><blockquote><ul><li>  All messages that start with a slash '/' (see Commands above) </li><li>  Messages that <a href="https://habrahabr.ru/users/mention/" class="user_link">mention</a> the bot by username </li><li>  Replies to the bot's own messages </li><li>  Service messages (people added or removed from the group, etc.) </li></ul><br></blockquote><br><br>  In order for the bot to receive all the messages in the groups, we write the @BotFather command <b>/ setprivacy</b> and turn off privacy. <br><br>  First, add a handler to the Handler: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'/'</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: response = CMD[<span class="hljs-string"><span class="hljs-string">"&lt;speech&gt;"</span></span>](message) logging.info(<span class="hljs-string"><span class="hljs-string">"REPLY\t%s\t%s"</span></span> % (message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>], response)) send_reply(response)</code> </pre><br>  And then we add pseudo-speech to the list of commands: <br><br><pre> <code class="python hljs">RESPONSES = { <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Welcome!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, {name}!"</span></span>], <span class="hljs-string"><span class="hljs-string">"Hi there"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, {name}!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Welcome!"</span></span>], <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, {name}!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Welcome!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>], <span class="hljs-string"><span class="hljs-string">"Welcome"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, {name}!"</span></span>,], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">human_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> leven = fuzzywuzzy.process.extract(message.get(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>), RESPONSES.keys(), limit=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] response = {<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>: message[<span class="hljs-string"><span class="hljs-string">'chat'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> leven[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">75</span></span>: response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] = <span class="hljs-string"><span class="hljs-string">"I can not understand you"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] = random.choice(RESPONSES.get(leven[<span class="hljs-number"><span class="hljs-number">0</span></span>])).format_map( {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: message[<span class="hljs-string"><span class="hljs-string">"from"</span></span>].get(<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)} ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response</code> </pre><br>  Here, the empirical constant 75 reflects relatively well the probability that the user still wanted to say.  And format_map is convenient for the same description of strings as requiring substitution, and without it.  Now the bot will respond to greetings and sometimes even address by name. <br><br><h3>  5. Not text. </h3><br>  Bots, like any normal Telegram user, can not only write messages, but also share pictures, music, stickers. <br><br>  For example, expand the RESPONSES dictionary: <br><br><pre> <code class="python hljs">RESPONSES[<span class="hljs-string"><span class="hljs-string">"What time is it?"</span></span>] = [<span class="hljs-string"><span class="hljs-string">"&lt;at_sticker&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"{date} UTC"</span></span>]</code> </pre><br>  And we will catch the text &lt;at_sticker&gt;: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] == <span class="hljs-string"><span class="hljs-string">"&lt;at_sticker&gt;"</span></span>: response[<span class="hljs-string"><span class="hljs-string">'sticker'</span></span>] = <span class="hljs-string"><span class="hljs-string">"BQADAgADeAcAAlOx9wOjY2jpAAHq9DUC"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> response[<span class="hljs-string"><span class="hljs-string">'text'</span></span>]</code> </pre><br>  You can see that the Message structure now no longer contains text, so you need to modify send_reply: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'sticker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: api.post(URL + <span class="hljs-string"><span class="hljs-string">"sendSticker"</span></span>, data=response) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: api.post(URL + <span class="hljs-string"><span class="hljs-string">"sendMessage"</span></span>, data=response)</code> </pre><br>  And that's all, now the bot will occasionally send a sticker instead of time: <br><br><img src="https://habrastorage.org/files/565/6eb/bfc/5656ebbfc8cd4e97b7c0fe2495fae6b3.png"><br><br><h3>  6. Opportunities </h3><br>  Thanks to the convenience of the API and a quick start, Telegram bots can be a good platform for automating their actions, setting up notifications, creating quizzes and task-based competitions (CTF, DozoR and others). <br><br>  Recalling the <a href="http://habrahabr.ru/post/249265/">article about the smart home</a> , I can say that now there are fewer perversions, and the work is more transparent. <br><br><h3>  7. Limitations </h3><br>  Unfortunately, at the moment there is a restriction on the use of webHook - it works only on https and only with a valid certificate, which, for example, is still critical for me due to the lack of support from certification centers for dynamic DNS. <br><br>  Fortunately, Telegram is also able to work on manual update, so without changing the code, you can create another service Puller, which will download them and send to the local address: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: r = requests.get(URL + <span class="hljs-string"><span class="hljs-string">"?offset=%s"</span></span> % (last + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.status_code == <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r.json()[<span class="hljs-string"><span class="hljs-string">"result"</span></span>]: last = int(message[<span class="hljs-string"><span class="hljs-string">"update_id"</span></span>]) requests.post(<span class="hljs-string"><span class="hljs-string">"http://localhost:8888/"</span></span>, data=json.dumps(message), headers={<span class="hljs-string"><span class="hljs-string">'Content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'Accept'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: logging.warning(<span class="hljs-string"><span class="hljs-string">"FAIL "</span></span> + r.text) time.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br><br>  PS Under paragraph 7, I found a convenient solution - placing the bot is not at home, but on heroku, since all names of the form * .herokuapp.com are protected by their own certificate. <br><br>  UPD: Telegram improved Bot Api, which is why it is not necessary now to have a separate function to send messages when the webhuk is set, and in response to a POST request, you can respond with the same generated JSON with a response message, where one of the fields is set as h ':' sendMessage '(or any other method used by the bot). </div><p>Source: <a href="https://habr.com/ru/post/262247/">https://habr.com/ru/post/262247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262235/index.html">We write our simplified OpenGL on Rust - part 3 (rasterizer)</a></li>
<li><a href="../262239/index.html">Critical way of rendering web pages</a></li>
<li><a href="../262241/index.html">Raspberry Pi as Steam Idle Machine</a></li>
<li><a href="../262243/index.html">Data Access Object (DAO). Class level</a></li>
<li><a href="../262245/index.html">Side View: IEEE754 Standard</a></li>
<li><a href="../262249/index.html">How Microsoft is friends with Arduino and other companies because of IoT</a></li>
<li><a href="../262251/index.html">A bit about protecting web session identifiers</a></li>
<li><a href="../262253/index.html">Intel IoT Roadshow, the second "pancake" Edison</a></li>
<li><a href="../262255/index.html">The first 90nm product from Micron under the microscope - 16 Mibit SRAM</a></li>
<li><a href="../262257/index.html">SSDs have slack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>