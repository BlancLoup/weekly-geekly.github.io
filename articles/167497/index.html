<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full-text search: how it is done in Mail.Ru Mail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Historically, Mail.Ru used a mechanism from the ‚Äúlarge‚Äù Search (go.mail.ru); however, this option was not optimal for mailbox search tasks due to the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full-text search: how it is done in Mail.Ru Mail</h1><div class="post__text post__text-html js-mediator-article">  Historically, Mail.Ru used a mechanism from the ‚Äúlarge‚Äù Search (go.mail.ru);  however, this option was not optimal for mailbox search tasks due to the large resource consumption and relative difficulty in servicing.  About 3% of mailbox owners use mail search;  However, although this figure seems relatively small, the boxes of these people are usually quite bulky and they really need to search.  Therefore, we have decided to write a specialized search daemon, which will be engaged in the search by mail.  The main requirements for it were restrictions on consumed resources (index size - no more than 3% of the mailbox size, average RAM consumption - no more than 100 MB, average CPU utilization - no more than 3%) and speed of execution of requests (average time - not more than 200 ms).  How it was organized, I will tell below. <a name="habracut"></a><br><br>  The two main processes that are performed as part of the solution to the problem of searching by mail are the indexing of mailboxes and the execution of search queries.  At the time of receipt of the new letter, it is necessary to replenish the search index by entering this letter into it.  Obviously, the data in the index should be streamlined and as compact as possible;  however, in this case, it is most likely that you will need to insert into the middle of the file, which will generate a very "heavy" recording on the disk.  Given that the arrival of a new letter occurs many times more often than the execution of any search query, the use of such a heavy operation to keep the search index up to date is doubtful. <br><br>  We decided to make an index of two files: snapshot, which contains a full-text index (sorted data), and xlog, which contains a list of consecutive transactions applied to the index.  Any operation on the index (for example, receiving a new letter) causes one record to disk - this is the record at the end of the xlog file.  Upon execution of a search query, in fact, there are two search operations ‚Äî a binary search on a snapshot and a sequential search on xlog ‚Äî the results of which are combined.  At that moment, when the xlog search speed stops satisfying us, we perform a snapshot rebuild - we make all changes to it from xlog, and we begin to save xlog again.  This moment is determined automatically by one of two possible policies: when the time of execution of the next request exceeds the set threshold, or when the set threshold is exceeded by the size of the xlog file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Indexing a new letter begins with tokenization.  Tokenization is the splitting of a letter into separate words (full-text search works up to a whole word and is not able to search for an arbitrary substring).  It is worth noting that tokenization is not the most trivial task.  Take, for example, an email address <br><br>  <b>d.kalugin-balashov@corp.mail.ru</b> <br><br>  Obviously, he is a whole word.  It is reasonable to make it possible to search also by the word d.kalugin (a study of user search queries has shown that they often try to search by email part).  However, it is impossible to support all the substrings of a given word, since this will lead to a sharp increase in the size of the index, and, as a consequence, a loss in the speed of execution of queries.  It is very reasonable to break a word into substrings only by punctuation marks.  Accordingly, we get the following subwords: <br><br>  <b>d.kalugin-balashov@corp.mail.ru</b> <b><br></b>  <b>d.kalugin-balashov@corp.mail</b> <b><br></b>  <b>d.kalugin-balashov@corp</b> <b><br></b>  <b>d.kalugin-balashov</b> <b><br></b>  <b>d.kalugin</b> <b><br></b>  <b>d</b> <b><br></b>  <b>kalugin-balashov@corp.mail.ru</b> <b><br></b>  <b>kalugin-balashov@corp.mail</b> <b><br></b>  <b>kalugin-balashov @ corp</b> <b><br></b>  <b>kalugin-balashov</b> <b><br></b>  <b>kalugin</b> <b><br></b>  <b>balashov@corp.mail.ru</b> <b><br></b>  <b>balashov@corp.mail</b> <b><br></b>  <b>balashov @ corp</b> <b><br></b>  <b>balashov</b> <b><br></b>  <b>corp.mail.ru</b> <b><br></b>  <b>corp.mail</b> <b><br></b>  <b>mail.ru</b> <b><br></b>  <b>mail</b> <b><br></b>  <b>ru</b> <br><br>  All these words will be included in the index. <br>  Note that such a recursive word break has some problems.  For example, system administrators often receive service letters that contain various paths (/usr/local/something/libexec/libany.so), often very long.  Such words can cause a greater depth of recursion.  Therefore, words that have a length greater than that specified in the configuration file of the tokenizer are not recursively divided into tokens, but broken into subwords of minimal length (the original word itself, however, also falls into the index). <br>  For example, take the word: <br><br>  <b>/usr/local/something/libexec/libany.so</b> <br><br>  Provided that its length is greater than the length allowed for recursive tokenization, it is divided into the following subwords: <br><br>  <b>/usr/local/something/libexec/libany.so</b> <b><br></b>  <b>usr</b> <b><br></b>  <b>local</b> <b><br></b>  <b>something</b> <b><br></b>  <b>libexec</b> <b><br></b>  <b>libany</b> <b><br></b>  <b>so</b> <br><br>  Such a breakdown gives less qualitative search results, but is a compromise option in terms of quality / resources ratio. <br>  The final stage of tokenization is to obtain the first form of the word (for the search of all word forms, the lemmatizer from the ‚Äúbig search‚Äù is used) and the taking of the CRC32 from it.  All words in the index are just these 32-bit integers. <br><br>  A letter has a specific set of numeric (folder, date, size, checkbox, presence of attachments, etc.) and text (subject, sender, text, etc.) zones.  The list of zones is configured in a special file and can be supplemented during the operation of the search engine. <br><br>  Snapshot consists of two parts - a dictionary (a list of all the words found in letters and pointers (offsets)) and the actual lists of documents (and zones) referenced by pointers from the dictionary.  When searching, the dictionary is read, which contains the words contained in the search query, after which the lists of documents are read by pointers from the dictionary;  results are combined.  On average, a search query (using only snapshot) for one word requires two disk hits ‚Äî to read the dictionary and read the list of documents. <br><br><img src="https://habrastorage.org/storage2/52b/a9f/2b2/52ba9f2b23f64c98cfd3f44177e5a610.png"><br><br>  Xlog consists of sequentially recorded transactions.  The integrity of each transaction is guaranteed by the checksum (CRC32) of its contents.  When reading xlog, all transactions for which the checksum has not converged are skipped (however, the reading process is not interrupted until the number of errors exceeds a certain number set in the configuration file).  A transaction, as a rule, consists of several commands and always describes exactly one letter.  The main role is played by the team that describes the list of words that are present in this letter, and the numbers of text zones in which they occur.  Execution of a search query on xlog requires reading the entire file into memory and analyzing all transactions, so the size of xlog is very limited.  The results of executing queries over xlog and snapshot are combined into one common result. <br><br><img src="https://habrastorage.org/storage2/b0d/1dc/c1b/b0d1dcc1b04cdea543e1889df6538f3d.png"><br><br>  After the list of letters in which words from the query are found is generated, the values ‚Äã‚Äãof all numerical zones for them are obtained.  The values ‚Äã‚Äãof the numerical zones are stored in the nzdata file.  The file structure is similar to the snapshot structure - it is a dictionary containing all the numbers of letters and pointers that refer to the list of values ‚Äã‚Äãof the numerical zones of the letter.  However, this file is read into memory entirely because the number of accesses to the data inside it, unlike the snapshot, is large, and the file itself is much smaller.  Note that nzdata does not contain all the actual values ‚Äã‚Äãof numeric zones.  He, like snapshot, contains the values ‚Äã‚Äãof the numerical zones at a certain point, and all their subsequent changes are contained in xlog.  Rebuilding nzdata is done at the same time as the snapshot.  After loading all numerical zones, a second reading of xlog occurs and all commands that describe changes in numeric zones are applied to the loaded results.  Also note that the search daemon, before accessing nzdata, tries to get numeric zones from the daemon, which provides work with postal codes (which are cached in memory while actively working with the box).  This method is many times faster and ensures data consistency.  Getting numerical zones from nzdata occurs, in fact, only in emergency situations. <br><br><img src="https://habrastorage.org/storage2/707/159/981/70715998174b4bf2185f80027249f82b.png"><br><br>  After receiving the numeric zones, the search daemon begins to apply the filters specified in the request.  Filters are restrictions of numerical zones: ‚Äúequal‚Äù, ‚Äúnot equal‚Äù, ‚Äúmore‚Äù, etc. The most popular filters are the limitation for a date (‚Äúyesterday‚Äù, ‚Äúweek‚Äù), a folder (‚ÄúInbox‚Äù , "Sent", "not in Spam"), on any flag ("Unread", "Checked", "With attachments").  Filters are applied sequentially to each letter from the list of results and exclude part of the letters from there. <br><br><img src="https://habrastorage.org/storage2/b8f/fdc/ee8/b8ffdcee8ad31c169822574b80fe866d.png"><br><br>  At the same stage, groupers are used, which calculate ‚Äúhow many results would there be if such a filter were applied‚Äù. <br><br><img src="https://habrastorage.org/storage2/190/ed2/4ac/190ed24acae5f20fc55886c4bdb02fb7.png"><br><br>  The next step is the ranking.  In the case of a mail search, unlike other full-text search tasks, the most relevant ranking function is obvious and simple ‚Äî sorting by the date of the letter.  The ranking ends with clipping of letters that do not fall into the current page (analog of the LIMIT operation in SQL). <br>  For the formation of the search result some numerical zones are few.  Since after ranking most often no more than 25 letters remain (the standard number of letters displayed on one page), heavy loading and processing of text zones occur at this stage.  After loading, each text zone is divided into words, among which are those present in the search query (including word forms and case insensitive).  These words are ‚Äúhighlighted‚Äù by the tags &lt;b&gt; and &lt;/ b&gt;, and the text area itself is clipped to the left and right to a certain size, which is guaranteed to include the first selected word. <br><br><img src="https://habrastorage.org/storage2/7f0/ba0/4d6/7f0ba04d6200e29a8d9f5ab81d5d88a5.png"><br><br><img src="https://habrastorage.org/storage2/427/4d9/250/4274d9250c6a4039122af8b410af0344.png"><br><br>  The index of sadzhestov is under construction at the moment of reorganization of xlog in snapshot.  The expectation of the query length is 6 characters. <br><br><img src="https://habrastorage.org/storage2/0c4/1d4/559/0c41d45593f481079806f3baad55c351.png"><br><br>  In the index of sadzhestv stored words that are not reduced to the first form, in the register, which are in the letter.  The index of sadzhestov consists of two parts: <br><br>  1. Dictionary consisting of prefixes of words (up to 6 characters long).  For words longer than 6 characters, references to lists of postfixes are stored in the dictionary. <br>  2. The set of lists of postfixes (of arbitrary length). <br><br><img src="https://habrastorage.org/storage2/aa3/e0a/2ed/aa3e0a2ed720e19fb03c431c043f0357.png"><br><br>  It was experimentally established that building an index of sadzhest with prefixes of exactly 6 characters in length minimizes its size.  The index of sadzhestov, in contrast to the search index, makes sense to cache, but to keep in memory relatively short-lived, because users tend to enter several letters in a row until the issuance of sajestov does not suit them.  The list of prefixes is cached (completely) and all lists of postfixes read so far from the disk.  The data from the xlog is not used when generating the event, since reading the xlog can take quite a long time.  Therefore, the sadzhest index always lags behind the real state of the box.  The index of sadzhestv updated with data from xlog during the next rebuild snapshot. <br><br>  If you have questions on implementation or have experience in solving such a problem, let us share the best practices. <br><br>  <i>Dmitry Kalugin-Balashov,</i> <i><br></i>  <i>Mail.Ru Mail Team Programmer</i> </div><p>Source: <a href="https://habr.com/ru/post/167497/">https://habr.com/ru/post/167497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167487/index.html">Notification Hubs - cloud notification service for millions of iOS and Windows users</a></li>
<li><a href="../167489/index.html">In the rhythm of modern life</a></li>
<li><a href="../167491/index.html">Critical Rails vulnerability. Again</a></li>
<li><a href="../167493/index.html">Amazon Elastic Transcoder</a></li>
<li><a href="../167495/index.html">Google added North Korea and its "sights" to Maps</a></li>
<li><a href="../167499/index.html">Sublime text 3 beta released</a></li>
<li><a href="../167501/index.html">Google glasses are banned in Ukraine</a></li>
<li><a href="../167503/index.html">Parallel programming in Python using multiprocessing and shared array</a></li>
<li><a href="../167507/index.html">Automatic calculation of column width</a></li>
<li><a href="../167509/index.html">Making a simple game with buttons, drawers and doors on Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>