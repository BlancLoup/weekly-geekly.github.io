<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An attempt to classify and analyze existing approaches to inheritance in Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, I got around to the topic, which has long been unnerving for me. This topic is inheritance in javascript. 

 There are many articles on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An attempt to classify and analyze existing approaches to inheritance in Javascript</h1><div class="post__text post__text-html js-mediator-article"><br>  Some time ago, I got around to the topic, which has long been <s>unnerving</s> for me.  This topic is inheritance in javascript. <br><br>  There are many articles on this topic on the web, but I did not manage to find a synthesis analysis that would satisfy me with its completeness and logic.  Why did you want to find a synthesis analysis?  The fact is that the special, I would say, unique complexity of object-oriented programming in JS consists in the shocking (in any case, me) diversity of its possible implementations.  After a rather lengthy unsuccessful search, I decided to try to figure this out on my own. <br><br>  I want to say at once that I do not pretend to have a deep understanding of OOP in JavaScript, and I do not even pretend to have a deep understanding of OOP at all.  I will be glad if my analysis attempt will be useful to someone, but the main purpose of the publication is, in a sense, the opposite - I would like to use the comments of people who are better oriented to the topic to clarify it for myself. <br><a name="habracut"></a><br><h4>  General reasoning </h4><br>  There is an opinion that JS is a very powerful and flexible language.  On the other hand, it is believed that JS - well, let's say softly, the language is unfinished.  Well, when it comes to OOP, JavaScript shows everything that it is capable of - on both points. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From this paradox, in particular, it follows that each javascript has a motive and it is possible to invent its own <s>bicycle with a variable geometry of the wing</s> approach to the inheritance of objects in JS.  And, actually, the question that interested me personally: how to structure this diversity. <br><br>  At first, I calculated that it would be possible to divide all the decisions into two large groups: class-based and <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype</a> (‚Äúclassless‚Äù).  Such a division seemed natural, given the fact that JavaScript itself seemed to be ‚Äústuck‚Äù between the classical OOP style and the prototype one.  However, I decided to refuse such a classification, due to the fact that in the overwhelming majority of cases, OOP in JavaScript is exactly the reproduction of a classic OOP by means of a prototype language. <br><br><h4>  Questions </h4><br>  Instead, I decided to use the following three questions, which seem to help ‚Äúfocus the eyes‚Äù on inheritance in JS: <br><br>  1) How classes are implemented <br>  2) How do instances get properties of their class? <br>  3) How class inheritance is implemented <br><br>  <em>(Note: hereinafter, by properties, I understand both the actual properties and the methods of the objects - in fact, in prototype programming there is a suitable term ‚Äúslot‚Äù, but it is rarely used in this context in JS)</em> <br><br><h4>  How do we organize classes? </h4><br>  There are two fundamentally different answers to this question: <br><br><ol><li>  Classes are organized using constructor functions. <br>  At the same time, instance objects are created using the new operator, and the designers themselves, in the JS style, combine several roles at the same time ‚Äî simultaneously functions, and class, and object constructor. </li><li>  Classes are organized using object factory functions. <br>  In this case, instances are directly returned by factory functions. </li></ol><br>  The simplest example of class organization using a constructor might look like this: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  1 -  (   ) function Class() { this.value = 'some value'; //  this.some_method = function() { //  console.log('some_method invoked'); } } var obj1 = new Class(); //   var obj2 = new Class(); //   </span></span></code> </pre> <br>  And here is a similar class organized with the help of a factory of objects: <br><br><pre> <code class="hljs pgsql"> //  <span class="hljs-number"><span class="hljs-number">2</span></span> -  (   ) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>() { var obj = {}; obj.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'some value'</span></span>; //  obj.some_method = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> () { //  console.log(<span class="hljs-string"><span class="hljs-string">'some_method invoked'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } var obj1 = <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //  ( ,       <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>) var obj2 = <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //  </code> </pre><br>  <em>(You may notice that the presence of the special keyword <strong>new</strong> hints that it is the constructor functions that are the mainstream language)</em> <br><br><h4>  How do we store properties? </h4><br>  We turn to the second question: how do instances get the properties of their class? <br><br>  Here, first of all, it is necessary to clarify what is meant by ‚Äúobtaining class properties‚Äù.  We are accustomed to thinking that objects automatically ‚Äúpossess‚Äù the properties and methods defined in their class.  The fact of this "possession" we perceive as something given.  But in JS it is not.  Here we can <em>choose</em> how our objects will receive properties from their (pseudo) classes.  We again have two possibilities: either objects receive properties of their class in the prototype, or they contain them directly. <br><br>  As for the first option, we just observed it - the two previous examples implement direct storage of properties in an instance for constructor functions (example 1) and for factories of objects (example 2). <br><br>  So what is the acquisition of properties from the prototype?  That's how: <br><br><pre> <code class="hljs pgsql"> //  <span class="hljs-number"><span class="hljs-number">3</span></span> - -,    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'some value'</span></span>; //  <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.prototype.some_method = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { //  console.log(<span class="hljs-string"><span class="hljs-string">'some_method invoked'</span></span>); } var obj1 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //   var obj2 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //  </code> </pre><br>  Please note that the constructor function itself is completely empty in our example, and all properties and methods are specified in the prototype.  Of course, in reality, the constructor will most likely be used for something useful (for example, to set the initial parameters). <br><br>  As you can see, prototypes are combined quite naturally with designers.  And what about the factories?  The situation with them is more complicated, since, according to the standard, the prototype of an object is specified using its constructor function.  In other words, we cannot work with the prototype of an object unless we use constructors.  So we have to use the trick: <br><br><pre> <code class="hljs pgsql"> //  <span class="hljs-number"><span class="hljs-number">4</span></span> - ,    //     , //    ,     . <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> derivate(o) { <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> F() {} F.prototype = o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> F(); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> derivate(<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.obj); } //  ,         <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.obj.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'some value'</span></span>; //  <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>.obj.some_method = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> () { //  console.log(<span class="hljs-string"><span class="hljs-string">'some_method invoked'</span></span>); } var obj1 = <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //  var obj2 = <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>(); //  </code> </pre><br>  This example is somewhat more complicated than the previous ones.  Is there any sense in this difficulty?  Well, at a minimum, the example is interesting because the derivate () function expands exactly the <em>prototypical</em> capabilities of the language (well, or compensates for the <em>lack of</em> these capabilities).  On the other hand, it is interesting that the code responsible for creating the class turned out to be very similar to the similar code from the previous example.  In fact, instead of the built-in Class.prototype, we created our own Class.obj property, while we had to do something of what JavaScript provided us in the previous example.  I want to note that with all its similarities, two examples are completely different in essence. <br><br>  Why do we need to put the properties of the class in the prototype of the instance?  At a minimum, this way we can save resources, since the properties of the same name of all instances of a class will physically occupy the same place in memory. <br><br><h4>  Constructors.  How to inherit? </h4><br>  Finally, we come to the most interesting.  <strong>The third question</strong> is inheritance. <br><br>  Fundamentally, in a prototype language, the inheritance of properties can be implemented in one of two ways: by copying or delegating. <br><br>  JavaScript itself implements <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">delegation inheritance</a> - in short, this means that the missing property of an object is searched for among the properties of its prototype. <br><br>  Copy inheritance follows the concept of prototype <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">concatenation</a> .  In this case, the properties from the parent object are simply copied to the child object.  Prototype concatenation is not part of JavaScript, but does not mean that it cannot be implemented. <br><br><h5>  Solution with call / apply </h5><br>  Let's see how copying inheritance can be implemented.  Theoretically, for this one could create an auxiliary function copyMethods: <br><br><pre> <code class="hljs pgsql"> //  ,       <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> copyMethods(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(m <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) { //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>[m] != "function") <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //  ,     <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>[m] = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>[m]; //   } }</code> </pre><br>  However, it can be made much easier if you use a small focus with the apply method. <br><br><pre> <code class="hljs lua"> //  <span class="hljs-number"><span class="hljs-number">5</span></span> -  +    +   //    //       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { //        this.value = val; this.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Class(id = "</span></span> + this.getId() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } this.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { //    ,     : // copyMethods(new Class(arguments[<span class="hljs-number"><span class="hljs-number">0</span></span>]), this); //    : Class.apply(this, arguments); //  Class()   this      var super_getName = this.getName; //     ,    this.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SubClass(id = "</span></span> + this.getId() + <span class="hljs-string"><span class="hljs-string">") extends "</span></span> + super_getName.call(this); } this.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } } //  o = new SubClass(<span class="hljs-number"><span class="hljs-number">5</span></span>); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.value); // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.getName()); // <span class="hljs-string"><span class="hljs-string">"SubClass(id = 2) extends Class (id = 2)"</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o instanceof Class); // <span class="hljs-literal"><span class="hljs-literal">false</span></span> [   instanceof]</code> </pre><br>  This example is the first one to answer all three proposed questions, and in fact it is a ready-made solution, so I made it slightly less schematic than the previous ones.  He completes what he started in Example 1. <br><br>  Given the completeness of this solution, it makes sense to evaluate its pros and cons.  So, <br><br>  <strong>Than this is good:</strong> <br><br>  - concise and simple implementation <br>  - there is no need to repeat class names with each method definition ( <a href="http://en.wikipedia.org/wiki/DRY">DRY principle</a> ) <br>  - automatic inheritance of constructors <br>  - does not affect the global context of the program (no global support functions, etc.) <br>  - easy to implement private properties <br><br>  <strong>What is bad:</strong> <br><br>  - memory is not effectively used (all identical properties of all objects are stored as copies) <br>  - it is not convenient to call parent methods <br>  - incompatible with instanceof operator <br>  - not compatible with native classes (you cannot create a descendant of a built-in class like Date) <br><br><h5>  Almost standard approach </h5><br>  Of course, example 1 (constructors + class properties inside an instance) can be developed in a different direction, in accordance with the second answer option to the question about the mode of inheritance. <br><br><pre> <code class="hljs lua"> //  <span class="hljs-number"><span class="hljs-number">6</span></span> -  +    +   //    //       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { //        this.value = val; this.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Class(id = "</span></span> + this.getId() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } this.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var super_getName = this.getName; //    this.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SubClass(id = "</span></span> + this.getId() + <span class="hljs-string"><span class="hljs-string">") extends "</span></span> + super_getName.call(this); } this.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } } SubClass.prototype = new Class(); //     //  o = new SubClass(<span class="hljs-number"><span class="hljs-number">5</span></span>); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.value); // undefined [  ] console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.getName()); // <span class="hljs-string"><span class="hljs-string">"SubClass(id = 2) extends Class (id = 2)"</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o instanceof Class); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> [  instanceof]</code> </pre><br>  Note that the child class does not know how to set the initial parameters.  Are there any advantages to this approach compared to the previous one?  Well, inheritance through prototypes is more energy efficient.  On the other hand, this solution is obviously halfway - we still create class properties for each instance independently of each other. <br><br><h5>  Very standard approach </h5><br>  Finally, we come to a solution that probably was conceived as standard for JavaScript.  From the point of view of our three questions, its ‚Äúformula‚Äù looks like this: constructors + class properties in the prototype + inheritance by delegation. <br><br><pre> <code class="hljs lua"> //  <span class="hljs-number"><span class="hljs-number">7</span></span> -  +    +   //    //       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { this.init(val); } Class.prototype.init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { this.value = val; } Class.prototype.value = <span class="hljs-number"><span class="hljs-number">5</span></span>; //    Class.prototype.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Class(id = "</span></span> + this.getId() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } Class.prototype.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { this.init(val); } SubClass.prototype = new Class(); //   SubClass.prototype.class_getName = SubClass.prototype.getName; //    SubClass.prototype.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SubClass(id = "</span></span> + SubClass.prototype.getId() + <span class="hljs-string"><span class="hljs-string">") extends "</span></span> + SubClass.prototype.class_getName(); } SubClass.prototype.getId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubSubClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span></span> { this.init(val); } SubSubClass.prototype = new SubClass(); SubSubClass.prototype.subclass_getName = SubSubClass.prototype.getName; //    SubClass.prototype.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SubSubClass(id = "</span></span> + SubSubClass.prototype.getId() + <span class="hljs-string"><span class="hljs-string">") extends "</span></span> + SubSubClass.prototype.subclass_getName(); } //  o = new SubSubClass(<span class="hljs-number"><span class="hljs-number">5</span></span>); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.value); // <span class="hljs-number"><span class="hljs-number">5</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o.getName()); // <span class="hljs-string"><span class="hljs-string">"SubSubClass(id = 2) extends SubClass(id = 2) extends Class(id = 2))"</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(o instanceof Class); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> [  instanceof]</code> </pre><br>  I so wanted to emphasize the inconvenience of this example, that I described in it three whole classes.  It seems that the whole example consists of repeating the same names, the same verbose constructs.  But this is not enough, the very method of inheriting a prototype contains fundamental inefficiency: in order to <em>describe the</em> hierarchy we must create and <em>initialize</em> (that is, call the init method) prototype objects.  This is bad, if only because the initialization can be resource-intensive. <br><br>  Oddly enough, despite the shortcomings, this approach is very popular.  Why?  In fact, there is no riddle here: the shortcomings of the method are compensated with the help of all kinds of add-ins, but its ‚Äúnativeness‚Äù, embeddedness in the syntax of the language, cannot be guaranteed with any add-on. <br><br>  Well, we still have the last option from the four solutions with constructors: constructors + properties in prototypes + inheritance by copying.  I will leave it as an independent exercise for those who want to experience what it means to program against the wind;) I can only say that theoretically this approach is possible, and even sometimes used for <s>grinding</s> (in any case, I have met it online), but it is extremely inconvenient (using with call / apply is impossible, and inheriting properties by copying after you saved them in the prototype is simply not logical) <br><br>  Thus, we have finished with designers, about factories of objects - in continuation. <br><br>  <i>Update: unfortunately, after more than a year after writing the first part of the article, I have to admit that there is no time for the second part - and, apparently, it won't be.</i>  <i>I apologize to all interested parties :)</i> </div><p>Source: <a href="https://habr.com/ru/post/64746/">https://habr.com/ru/post/64746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../64740/index.html">Color design comments on sites</a></li>
<li><a href="../64741/index.html">Military robot feeds on biomass</a></li>
<li><a href="../64743/index.html">TEDxRU - index of the future came to Russia</a></li>
<li><a href="../64744/index.html">Memo Evangelist II</a></li>
<li><a href="../64745/index.html">What working conditions to choose?</a></li>
<li><a href="../64747/index.html">Comic contest for serious programmers - "Explain on fingers v2.0"</a></li>
<li><a href="../64748/index.html">UTF-8 + FreeBSD 8</a></li>
<li><a href="../64749/index.html">Each class has its own file.</a></li>
<li><a href="../64750/index.html">What desktop do you mostly use? Why? (in comments)</a></li>
<li><a href="../64755/index.html">Robots - implementers of virus code began to spoil sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>