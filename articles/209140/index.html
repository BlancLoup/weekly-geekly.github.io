<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About creating an improved JavaScript library for working with the DOM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently, jQuery is the de facto library for working with the DOM. It can be used with popular MV * frameworks (such as Backbone), has many plug-ins ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About creating an improved JavaScript library for working with the DOM</h1><div class="post__text post__text-html js-mediator-article">  Currently, jQuery is the de facto library for working with the DOM.  It can be used with popular MV * frameworks (such as Backbone), has many plug-ins and a very large community.  On the other hand, JavaScript is becoming more popular and many developers are beginning to wonder how standard APIs work and when you can simply use them without adding an additional library. <br><br>  In the late days of working with jQuery, I began to notice various problems with this library.  Most of them are fundamental, therefore they cannot be fixed without losing backward compatibility, which, of course, is important.  I, like many others, continued to use the library for a while, meeting annoying quirks every day. <br><a name="habracut"></a><br>  Then <a href="https://twitter.com/csuwildcat">Daniel Buchner</a> created <a href="https://github.com/csuwildcat/SelectorListener">SelectorListener</a> , and the idea of ‚Äã‚Äãlive extensions was born.  I started thinking about creating a set of functions that would allow the creation of unobtrusive and independent DOM components using the best approach.  The task was to review the existing solutions and create a more understandable, testable, small, but at the same time self-sufficient library. <br><br><h4>  Adding useful functions to the library </h4><br>  The idea of <b>live extensions</b> contributed to the development <a href="https://github.com/chemerisuk/better-dom">of the better-dom project</a> , although besides it there are other interesting features that make the library unique.  Let's do a quick review of them: <br><ul><li>  live extensions </li><li>  native animations </li><li>  embedded template engine </li><li>  internationalization support </li></ul><br><h5>  Live extensions </h5><br>  In jQuery, there is the concept of live events.  Behind the scenes, they use event delegation to handle existing and future elements.  However, in many cases, greater flexibility is required.  For example, if the widget is supposed to add additional elements to the document tree during initialization that should interact or replace existing ones, live events do not work.  To solve the problem I am introducing the live extension. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The goal is to declare an extension once, and after that it should work for future content regardless of the complexity of the widget.  This is an important feature because it allows you to create web pages declaratively, so it is well suited for AJAX applications. <br><br>  Consider a simple example.  Let's say our task is to implement a fully customizable tooltip.  Pseudo-selector <code>:hover</code> does not match, because the position of the tooltip changes depending on the mouse cursor.  Event delegation is also not suitable - it is too expensive to listen to <code>mouseover</code> and <code>mouseleave</code> for all elements on the page.  This is where live extensions come into play. <br><pre> <code class="javascript hljs">DOM.extend(<span class="hljs-string"><span class="hljs-string">"[title]"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tooltip = DOM.create(<span class="hljs-string"><span class="hljs-string">"span.custom-title"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  textContent     // title       tooltip.set("textContent", this.get("title")).hide(); this //   tooltip .set("title", null) //       .data("tooltip", tooltip) //    .on("mouseenter", this.onMouseEnter, ["clientX", "clientY"]) .on("mouseleave", this.onMouseLeave) //     DOM .append(tooltip); }, onMouseEnter: function(x, y) { this.data("tooltip").style({left: x, top: y}).show(); }, onMouseLeave: function() { this.data("tooltip").hide(); } });</span></span></code> </pre><br>  Our tooltip can now be styled using the <code>.custom-title</code> selector in CSS: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.custom-title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">position</span></span>: fixed; <span class="hljs-attribute"><span class="hljs-attribute">border</span></span>: <span class="hljs-number"><span class="hljs-number">1px</span></span> solid <span class="hljs-number"><span class="hljs-number">#faebcc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#faf8f0</span></span>; }</code> </pre><br>  However, the fun begins when new elements with the <code>title</code> attribute are added to the page.  They will be picked up by the extension <b>without calling any initializing function</b> . <br><br>  Live extensions are self-sufficient, so they do not need to jerk a particular function in order to work with future content.  This means that <b>they can be combined with any existing library for DOM</b> and simplify the application logic by dividing the UI code into many small independent parts. <br><br>  In conclusion, a few words about <a href="http://www.w3.org/TR/components-intro/">Web components</a> .  One of the sections of the specification, called " <a href="http://www.w3.org/TR/components-intro/">Decorators</a> ", is designed to solve a similar problem.  He currently uses markup and special syntax to put listeners on children.  But this is still a very early draft: <br><blockquote>  Decorators, unlike other sections of Web Components, do not yet have a specification. </blockquote><br><h5>  Native animations </h5><br>  <a href="http://www.apple.com/html5/showcase/transitions/">Thanks to Apple</a> , CSS now has <a href="http://caniuse.com/">good animation support</a> .  In the past, animations were implemented in JavaScript using <code>setInterval</code> and <code>setTimeout</code> .  It was a cool thing, but now ... something like a bad practice.  Native animations will always be smoother: they are usually faster, require less energy and simply do not appear in browsers that do not support them. <br><br>  There is no <code>animate</code> method in better-dom: only <code>show</code> , <code>hide</code> and <code>toggle</code> .  To capture the state of a hidden item in the CSS library uses the standardized attribute <code>aria-hidden</code> . <br><br>  To illustrate the approach, let's add a simple animation to the tooltip we wrote earlier: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.custom-title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">position</span></span>: fixed; <span class="hljs-attribute"><span class="hljs-attribute">border</span></span>: <span class="hljs-number"><span class="hljs-number">1px</span></span> solid <span class="hljs-number"><span class="hljs-number">#faebcc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#faf8f0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-webkit-transition</span></span>: opacity <span class="hljs-number"><span class="hljs-number">0.5s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">transition</span></span>: opacity <span class="hljs-number"><span class="hljs-number">0.5s</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.custom-title</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[aria-hidden=true]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Inside the <code>show</code> and <code>hide</code> attribute, <code>aria-hidden</code> changes its value to <code>false</code> or <code>true</code> .  This is enough to show the animation means CSS. <br><br>  <a href="http://jsfiddle.net/C3WeM/5/">More examples of animations using better-dom.</a> <br><br><h5>  Built-in template engine </h5><br>  HTML lines are bulky.  When I started looking for a replacement, I found an excellent <a href="http://emmet.io/">Emmet</a> project.  Currently, it is quite popular as a plug-in for text editors and has a clean and compact syntax.  Compare: <br><pre> <code class="javascript hljs">body.append(<span class="hljs-string"><span class="hljs-string">"&lt;ul&gt;&lt;li class='list-item'&gt;&lt;/li&gt;&lt;li class='list-item'&gt;&lt;/li&gt;&lt;li class='list-item'&gt;&lt;/li&gt;&lt;/ul&gt;"</span></span>);</code> </pre><br>  which is equivalent to <br><pre> <code class="javascript hljs">body.append(<span class="hljs-string"><span class="hljs-string">"ul&gt;li.list-item*3"</span></span>);</code> </pre><br>  In better-dom, methods that accept HTML strings as arguments also support emmet abbreviations.  <a href="http://jsperf.com/dom-create-vs-jquery/18">The abbreviation parser is fast</a> , so you can not think about losses in performance.  There is also a <a href="https://github.com/chemerisuk/better-dom/wiki/Microtemplating">function for precompiling templates</a> , which can be used as needed. <br><br><h5>  Internationalization support </h5><br>  Developing a UI widget often requires localization, which is not always an easy task.  Many have solved this problem in their own way.  With better-dom, I hope that <b>changing the language will be as easy as changing the state of the CSS selector</b> . <br><br>  From an ideological point of view, language switching is like changing the ‚Äúpresentation‚Äù of content.  There are several pseudo-selectors in CSS2 that help describe this model <code>:lang</code> and <code>:before</code> .  Take a look at the code below: <br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-i18n="hello"]</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:before</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">content</span></span>: <span class="hljs-string"><span class="hljs-string">"Hello Maksim!"</span></span>; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-i18n="hello"]</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:lang(ru)</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:before</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">content</span></span>: <span class="hljs-string"><span class="hljs-string">" !"</span></span>; }</code> </pre><br>  The trick is that the <code>content</code> property changes according to the current language, which is determined by the value of the <code>lang</code> attribute for the <code>html</code> element.  Using the <code>data-i18n</code> attribute, we can use a more general entry: <br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-i18n]</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:before</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">content</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">attr</span></span>(data-i18n); } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-i18n="Hello Maksim!"]</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:lang(ru)</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:before</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">content</span></span>: <span class="hljs-string"><span class="hljs-string">" !"</span></span>; }</code> </pre><br>  Of course, such CSS code does not look attractive, so in better-dom there are two helpers: <code>i18n</code> and <code>DOM.importStrings</code> .  The first is used to update the <code>data-i18n</code> attribute with the corresponding value, and the second locates strings for a particular language. <br><pre> <code class="javascript hljs">label.i18n(<span class="hljs-string"><span class="hljs-string">"Hello Maksim!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// label  "Hello Maksim!" DOM.importStrings("ru", "Hello Maksim!", " !"); //     "ru",  label   " !" label.set("lang", "ru"); //  label  " !"    </span></span></code> </pre><br>  Parameterized strings are also supported: just add <code>${param}</code> variables to the key string: <br><pre> <code class="javascript hljs">label.i18n(<span class="hljs-string"><span class="hljs-string">"Hello ${user}!"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">"Maksim"</span></span>}); <span class="hljs-comment"><span class="hljs-comment">// label  "Hello Maksim!"</span></span></code> </pre><br><h4>  Improved Native APIs </h4><br>  Usually we want to adhere to standards.  But sometimes the standards are not entirely friendly.  The DOM is very confusing and to make it enjoyable, you need to wrap it in a convenient API.  Despite the many improvements made by different libraries, some things can be done better: <br><ul><li>  getter and setter </li><li>  improved event handling </li><li>  functional support </li></ul><br><h5>  Getter and setter </h5><br>  A native DOM <b>has notions of attributes and properties of an element</b> that can behave differently.  Suppose there is a markup on the page: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/chemerisuk/better-dom"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-test</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test"</span></span></span><span class="hljs-tag">&gt;</span></span>better-dom<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  To explain the unfriendliness of the native DOM, let's work with it a bit: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> link = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); link.href; <span class="hljs-comment"><span class="hljs-comment">// =&gt; "https://github.com/chemerisuk/better-dom" link.getAttribute("href"); // =&gt; "/chemerisuk/better-dom" link["data-test"]; // =&gt; undefined link.getAttribute("data-test"); // =&gt; "test" link.href = "abc"; link.href; // =&gt; "https://github.com/abc" link.getAttribute("href"); // =&gt; "abc"</span></span></code> </pre><br>  So, <i>the attribute value is</i> equal to the corresponding string in HTML, while a <i>property of an element</i> with the same name may have special behavior, for example, generating the full URL in the example above.  This difference can sometimes confuse. <br><br>  In practice, it is difficult to imagine when such a division may be useful.  Moreover, the developer must always keep track of what value he works with, which adds unnecessary complexity. <br><br>  In better-dom, things are simpler: <b>each element has only smart getter and setter</b> . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> link = DOM.find(<span class="hljs-string"><span class="hljs-string">"#foo"</span></span>); link.get(<span class="hljs-string"><span class="hljs-string">"href"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt; "https://github.com/chemerisuk/better-dom" link.set("href", "abc"); link.get("href"); // =&gt; "https://github.com/abc" link.get("data-attr"); // =&gt; "test"</span></span></code> </pre><br>  In the first step, the methods do a search for the properties of the element and, if defined, use it for operations.  Otherwise, work with the corresponding attribute.  For bulenovsky attributes ( <code>checked</code> , <code>selected</code> , etc.) you can simply use <code>true</code> or <code>false</code> .  Changing these properties on the element updates the corresponding attribute (native behavior). <br><br><h5>  Improved event handling </h5><br>  Event handling is a significant part of the coding for the DOM.  One fundamental problem that I discovered is that having an event object in the element listeners forces developers who like the code under test to measure the first argument or create an additional function that accepts event properties used in this handler. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> button = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); button.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ handleButtonClick(e.button); }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  It really bothers and adds an extra function call.  What if we select the changing part as an argument: this will get rid of the closure: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> button = DOM.find(<span class="hljs-string"><span class="hljs-string">"#foo"</span></span>); button.on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, handleButtonClick, [<span class="hljs-string"><span class="hljs-string">"button"</span></span>]);</code> </pre><br>  By default, the event handler accepts an array of <code>["target", "defaultPrevented"]</code> , so there is no need to add the last argument to read these properties: <br><pre> <code class="javascript hljs">button.on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, canceled</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre><br>  <b>Later linking is also supported</b> (I recommend reading the <a href="http://michaux.ca/articles/our-backwards-dom-event-libraries">article from Peter Michaux on the topic</a> ).  This is a more flexible alternative to conventional event handlers, which, by the way, is <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">present in the standard</a> .  It can be useful in cases when you need to make frequent calls to the <code>on</code> and <code>off</code> methods. <br><pre> <code class="javascript hljs">button._handleButtonClick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"click!"</span></span>); }; button.on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-string"><span class="hljs-string">"_handleButtonClick"</span></span>); button.fire(<span class="hljs-string"><span class="hljs-string">"click"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   "clicked" button._handleButtonClick = null; button.fire("click"); //   </span></span></code> </pre><br>  In conclusion, it is worth mentioning that in better-dom there are no methods like <code>click()</code> , <code>focus()</code> , <code>submit()</code> etc., which are present in the standard and have different behavior in browsers.  The only way to call them is to use the <code>fire</code> method, which executes the default behavior when none of the handlers returned <code>false</code> : <br><pre> <code class="javascript hljs">link.fire(<span class="hljs-string"><span class="hljs-string">"click"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    link.on("click", function() { return false; }); link.fire("click"); //        </span></span></code> </pre><br><h5>  Functional support </h5><br>  ES5 has standardized several useful methods for arrays, such as <code>map</code> , <code>filter</code> , <code>some</code> , etc.  They allow you to conduct operations on collections in a standardized form.  As a result, there are today projects like <a href="http://underscorejs.org/">Underscore</a> or <a href="http://lodash.com/">Lo-Dash</a> , which allow you to use these methods in older browsers. <br><br>  Each element (or collection) in better-dom has the methods below out of the box: <br><ul><li>  <code>each</code> (differs from <code>forEach</code> in that it returns <code>this</code> instead of <code>undefined</code> ) </li><li> <code>some</code> </li> <li> <code>every</code> </li> <li> <code>map</code> </li> <li> <code>filter</code> </li> <li> <code>reduce[Right]</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urls, activeLi, linkText; urls = menu.findAll(<span class="hljs-string"><span class="hljs-string">"a"</span></span>).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.get(<span class="hljs-string"><span class="hljs-string">"href"</span></span>); }); activeLi = menu.children().filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.hasClass(<span class="hljs-string"><span class="hljs-string">"active"</span></span>); }); linkText = menu.children().reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">memo, el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memo || el.hasClass(<span class="hljs-string"><span class="hljs-string">"active"</span></span>) &amp;&amp; el.find(<span class="hljs-string"><span class="hljs-string">"a"</span></span>).get() }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h4>  Some jQuery issues </h4><br>  Most of the problems below cannot be fixed in jQuery without losing backward compatibility.  Another reason why it was decided to create a new library. <br><ul><li>  "Magic" function <code>$</code> </li><li>  value of the operator of square brackets </li><li>  problems with <code>return false</code> </li><li>  <code>find</code> and <code>findAll</code> </li></ul><br><h5>  "Magic" function $ </h5><br>  Everyone has ever heard that the function <code>$</code> (dollar) is ‚Äúmagic‚Äù.  The name consisting of only one character is not very clear; the function looks like an operator built into the language.  That is why inexperienced developers simply call it wherever it is needed. <br><br>  Behind the scenes <b><code>$</code> is a rather complicated function</b> .  Its frequent execution, especially inside events such as <code>mousemove</code> or <code>scroll</code> , can be the cause of poor UI responsiveness. <br><br>  Despite numerous articles that promote caching of jQuery objects, developers continue to embed <code>$</code> .  This is because the library syntax contributes to this coding style. <br><br>  Another problem with this function is that it is responsible for two <u>completely different</u> tasks.  People have become accustomed to this syntax, but this is not a good practice of function design in general: <br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   ,    ‚Äúa‚Äù $("&lt;a&gt;"); // =&gt;   &lt;a&gt;  jQuery </span></span></code> </pre><br>  <b>In better-dom, the responsibility of the $ -functions covers several methods</b> : <code>find[All]</code> and <code>DOM.create</code> .  The <code>find[All]</code> methods are used to search for elements by a CSS selector.  <code>DOM.create</code> creates new elements in memory.  Function names clearly state what these functions do. <br><br><h5>  The value of the square bracket operator </h5><br>  Another reason for the problem with too frequent calls to the dollar function is the square bracket operator.  When a new jQuery object is created, all related elements are stored in numeric properties.  It is important to note that the value of this property contains an instance of the <u>native element</u> (not a jQuery wrapper): <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> links = $(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); links[<span class="hljs-number"><span class="hljs-number">0</span></span>].on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... }); <span class="hljs-comment"><span class="hljs-comment">// ! $(links[0]).on("click", function() { ... }); //   </span></span></code> </pre><br>  Because of this feature, each functional method in jQuery or another library (like Underscore) requires the current element to be wrapped in <code>$()</code> within an iteration function.  Therefore, the developer must always remember with what object he works: native or a wrapper, despite the fact that the library is used to work with the DOM. <br><br>  In better-dom, the square bracket operator returns a library object, so <b>you can forget about native elements</b> .  The only legal way to access them is to use a special <code>legacy</code> method. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = DOM.find(<span class="hljs-string"><span class="hljs-string">"#foo"</span></span>); foo.legacy(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Hammer   swipe Hammer(node).on("swipe", function(e) { //   swipe }); });</span></span></code> </pre><br>  But in reality, it is needed in very rare cases, for example, when compatibility with a native function or another DOM library is needed (like <a href="http://eightmedia.github.io/hammer.js/">Hammer</a> from the example above). <br><br><h5>  Problems with return false </h5><br>  One thing that really blew my mind is the weird handling of <code>return false</code> in event listeners.  In accordance with W3C standards, this value should, <a href="http://www.w3.org/TR/DOM-Level-3-Events/">in most cases,</a> override the default behavior.  In jQuery, <code>return false</code> additionally <a href="http://api.jquery.com/on/">stops event delegation</a> ! <br><br>  There are several problems here: <br><ol><li>  The <code>stopPropagation()</code> call itself can create compatibility problems, since  he breaks the possibility of other listeners to do their work in the occurrence of such an event </li><li>  most developers (even experienced) do not expect such behavior </li></ol><br>  It's not clear why the jQuery community decided to go against standards.  And better-dom doesn't intend to repeat this error: <code>return false</code> inside an event handler <i>only</i> causes <code>preventDefault()</code> , as expected. <br><br><h5>  find and findAll </h5><br>  Search for items is <b>one of the most expensive operations</b> in the browser.  Two native functions can be used to implement it: <code>querySelector</code> and <code>querySelectorAll</code> .  The difference between them is that the first one stops the search after the first match. <br><br>  This feature can significantly reduce the number of iterations in appropriate cases.  In my tests <a href="http://jsperf.com/dom-find-all-vs-jquery-find/3">, the speed gain can be up to 20 times</a> .  You can also expect the gap to increase depending on the size of the document tree. <br><br>  jQuery has a <code>find</code> method that uses <code>querySelectorAll</code> in general.  To date, there is no method here that would use <code>querySelector</code> to find only the first matching element. <br><br>  There are two different methods in better-dom: <code>find</code> and <code>findAll</code> .  They allow you to use <code>querySelector</code> optimization above.  To estimate the potential gain, I made a sample by the number of entries in the source code of the last commercial project: <br><ul><li>  <code>find</code> - 103 matches in 11 files </li><li>  <code>findAll</code> - 14 matches in 4 files </li></ul><br>  Definitely the <code>find</code> method is much more popular.  This means that <code>querySelector</code> optimization takes place in most cases, so it can give a tangible gain in code performance on the client. <br><br><h4>  Conclusion </h4><br>  Developing with live extensions really makes life easier on the front-end.  Separating the UI into many small parts helps to create more independent (= reliable) solutions.  But, as seen above, better-dom is not only about them (although this was the original main goal). <br><br>  During development, I realized one important thing: if the current standards are not completely satisfied or there are ideas on how to do it better, <b>just implement and prove that they work</b> .  And it is very fun! <br><br>  More information about <i>the better-dom library</i> <a href="https://github.com/chemerisuk/better-dom">can</a> always <a href="https://github.com/chemerisuk/better-dom">be found on GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/209140/">https://habr.com/ru/post/209140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209126/index.html">MathML or Latex - how we implemented a changing salary in calculating salary using MathJax</a></li>
<li><a href="../209128/index.html">But how does multithreading work? Part II: memory ordering</a></li>
<li><a href="../209130/index.html">Terminal multiplexer overview: tmux and dvtm</a></li>
<li><a href="../209132/index.html">How did the authors of the book and application developers find each other?</a></li>
<li><a href="../209138/index.html">Calculating intersecting intervals in linear and closed namespaces</a></li>
<li><a href="../209144/index.html">Network programming for game developers. Part 1: UDP vs. Tcp</a></li>
<li><a href="../209148/index.html">8 key advantages of a localizer (actually not)</a></li>
<li><a href="../209152/index.html">The contest "Native Speech 2014": at the start, attention, march!</a></li>
<li><a href="../209154/index.html">Sha512 support in wsse-authentication-bundle from Escape Studios, Symfony2</a></li>
<li><a href="../209156/index.html">Customs moved to action</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>