<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Even faster acceleration of WebAssembly: new streaming and layered compiler in Firefox</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Both authors: Lin Clark is a developer in the Mozilla Developer Relations group. Engaged in JavaScript, WebAssembly, Rust and Servo, and also draws co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Even faster acceleration of WebAssembly: new streaming and layered compiler in Firefox</h1><div class="post__text post__text-html js-mediator-article">  <i><font color="gray">Both authors: Lin Clark is a developer in the Mozilla Developer Relations group.</font></i>  <i><font color="gray">Engaged in JavaScript, WebAssembly, Rust and Servo, and also draws comics about the code.</font></i> <br><br>  People call WebAssembly a factor that changes the rules of the game, because this technology speeds up code execution on the web.  Some of the accelerations are <a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/">already implemented</a> , while others will appear later. <br><br>  One of the techniques is stream compilation, when the browser compiles code while it is being loaded.  Until now, this technology was considered only as a potential acceleration option.  But with the release of Firefox 58, it will become a reality. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Firefox 58 also includes a two-level compiler.  The new base compiler compiles code 10‚Äì15 times faster than the optimizing compiler. <br><br>  Together, these two changes mean that we compile the code faster than it comes from the network. <br><br><img src="https://habrastorage.org/webt/dn/e7/nu/dne7nu4wxa9vr6t4dkfp4m9v_fu.gif"><br><br>  On the desktop, we compile 30-60 MB of WebAssembly code per second.  This is <a href="http://www.speedtest.net/global-index">faster than the network delivering packets</a> . <br><a name="habracut"></a><br>  If you have Firefox Nightly or Beta, you <a href="https://lukewagner.github.io/test-tanks-compile-time/">can try out the</a> technology on your own device.  Even on an average mobile device, compilation is performed at 8 MB / s - this is faster than the download speed in most mobile networks. <br><br>  In other words, the execution of the code begins immediately after the download is completed. <br><br><h3>  Why is it important? </h3><br>  Web productivity lawyers are critical of a large number of javascript sites, because it slows down the loading of web pages. <br><br>  One of the main reasons for this slowdown is the parse and compile time.  As <a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">Steve Sauders observed</a> , the bottleneck of web productivity used to be a network, and now a CPU, namely the main thread of execution. <br><br><img src="https://habrastorage.org/webt/rw/_q/_r/rw_q_r3jzprpy9gabxnuznm_b_s.png"><br><br>  So we want to take out as much work as possible from the main thread.  We also want to ensure the interactivity of the page as early as possible, so we use the CPU all the time.  And it is better to reduce the load on the CPU. <br><br>  Some of these goals are achievable with JavaScript.  You can parse files outside the main stream after receiving them.  But they still have to disassemble, and this is a lot of work.  And you need to wait until the end of the parsing before starting the compilation.  And for compilation, you return to the main thread, because it usually happens <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">lazy</a> JS <a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">compilation</a> on the fly. <br><br><img src="https://habrastorage.org/webt/vh/qh/lz/vhqhlzxy2prd7vqgyjrts5uot2i.png"><br><br>  When using WebAssembly from the very beginning less work.  Decoding WebAssembly is much simpler and faster than parsing JavaScript.  And these decoding and compilation can be broken down into several streams. <br><br>  This means that several threads will perform a basic compilation, significantly speeding it up.  At the end of the process, the precompiled code starts to run in the main thread.  No need to stop waiting for compilation, as in the case of JS. <br><br><img src="https://habrastorage.org/webt/nc/p-/a-/ncp-a-brrfqo2en6ibjdedkbty8.png"><br><br>  Although the precompiled code runs in the main thread, other threads are currently working on an optimized version.  When an optimized version is ready, it replaces the preliminary version - and the code runs even faster. <br><br>  This makes loading WebAssembly more like decoding an image than loading a JavaScript.  Think about it ... lawyers of productivity are hostile to the scripts that meet more than 150 KB, but images of this size are not satisfactory. <br><br><img src="https://habrastorage.org/webt/oa/vb/ok/oavbokplm323t9xt5xswys6jvz0.png"><br><br>  This is because loading images is much faster, as Eddie Osmani explained in the article ‚ÄúThe <a href="https://habrahabr.ru/post/343562/">Price of JavaScript</a> .‚Äù  And decoding an image does not block the main stream, as Alex Russell explained in the article ‚Äú <a href="https://habrahabr.ru/post/345212/">Can you afford it?</a>  <a href="https://habrahabr.ru/post/345212/">A budget for web productivity in the real world</a> . ‚Äù <br><br>  This does not mean that WebAssembly files will be as big as the images.  Although the first versions of WebAssembly tools do create large files, but this is because a significant portion of the runtime has to be included there.  Now there is an active work to reduce their size.  For example, in the Emscripten there is a ‚Äú <a href="https://github.com/kripken/emscripten/issues/5836">squeeze initiative</a> ‚Äù.  In Rust, you can still get quite small files by applying the target wasm32-unknown-unknown.  And there are tools like <a href="https://github.com/alexcrichton/wasm-gc">wasm-gc</a> and <a href="https://github.com/fitzgen/wasm-snip">wasm-snip</a> for even more optimization. <br><br>  This means that WebAssembly files will load much faster than equivalent JavaScript. <br><br>  It is very important.  As <a href="https://twitter.com/wycats/status/942908325775077376">Yehuda Katz noted</a> , this is a factor that really changes the rules of the game. <br><br>  So let's see how the new compiler works. <br><br><h3>  Stream Compilation: Early Start of Compilation </h3><br>  The sooner you start compiling the code, the sooner you finish it.  This is what streaming compilation does ... starting compiling a .wasm file as early as possible. <br><br>  When you download a file, it does not come in one piece.  Instead, it comes in a series of packages. <br><br>  Previously, you had to download all the packages of the .wasm file, then the browser‚Äôs network layer placed it in ArrayBuffer. <br><br><img src="https://habrastorage.org/webt/2h/2o/fk/2h2ofkvzncrsqfvgkvwu3erfivi.png"><br><br>  Then this ArrayBuffer was transferred to the Web VM (aka JS engine).  At this point, the WebAssembly compiler would start compiling. <br><br><img src="https://habrastorage.org/webt/1s/wl/jk/1swljkj1xbzsygg6juxag18yjm4.png"><br><br>  But there is no good reason to leave the compiler on hold.  It is technically possible to compile WebAssembly line by line.  This means that the process can be started after the arrival of the first fragment. <br><br>  This is exactly what our compiler does, which takes advantage of the streaming WebAssembly programming interfaces. <br><br><img src="https://habrastorage.org/webt/be/1-/bv/be1-bvi45trpcy1g-wvoiaxgso0.png"><br><br>  If you pass the Response object to <code>WebAssembly.instantiateStreaming</code> , new code fragments will be sent to the WebAssembly engine immediately after downloading.  Then the compiler can start working on the first fragment while the next one is still being downloaded. <br><br><img src="https://habrastorage.org/webt/ll/vc/p3/llvcp3ihrttyhnoth4_dpofy-jy.png"><br><br>  In addition to simultaneously loading and compiling code, there is another advantage. <br><br>  The code section of the .wasm module comes at the very beginning, before the rest of the data (which is placed in the module's memory object).  So in the case of streaming compilation, the code is compiled while the module data has not yet been fully downloaded.  If your module requires a lot of data, then the memory object can be several megabytes in size, and streaming compilation will give a significant performance increase. <br><br><img src="https://habrastorage.org/webt/cl/01/vl/cl01vllrf1t83rdj-ielk-yvud4.png"><br><br>  With streaming compilation, the compilation process starts earlier.  But we can also make it faster. <br><br><h3>  Basic compiler level 1: compile acceleration </h3><br>  If you want fast code work, then you need to optimize it.  But it takes time to perform these optimizations during compilation, which slows down the compilation itself.  So this is a definite compromise. <br><br>  But if you use two compilers, you can get the benefits of both quick compilation and optimized code.  The first one quickly compiles without any special optimizations, and the second one works more slowly, but produces more optimized code. <br><br>  This is called a multi-level compiler.  When the code initially arrives, it is compiled by a Level 1 compiler (or the base compiler).  After the code compiled by the base compiler starts up, the Level 2 compiler processes the code again and prepares a more optimized version in the background. <br><br>  Upon completion of the process, the basic version of the code is replaced by an optimized version.  This speeds up code execution. <br><br><img src="https://habrastorage.org/webt/rd/kk/av/rdkkavsmlpfnf_izh59lfd9esg4.png"><br><br>  JavaScript engines have long used multi-level compilers.  However, the JS engines use a Level 2 compiler (i.e., optimizing) only for hot code ... which is often called for execution. <br><br>  In contrast, in WebAssembly, a Level 2 compiler will eagerly perform a complete recompilation, optimizing all module code.  In the future, we can add more options to control how greedy or lazy optimization should be. <br><br>  The base compiler saves a lot of time on loading.  It works 10‚Äì15 times faster than an optimizing compiler.  And the compiled code in our case works only two times slower. <br><br>  This means that your code will work quickly enough even in the first moments when only the basic non-optimized version works. <br><br><h3>  Parallelization: even faster acceleration </h3><br>  In an <a href="https://hacks.mozilla.org/2017/11/entering-the-quantum-era-how-firefox-got-fast-again-and-where-its-going-to-get-faster/">article on Firefox Quantum,</a> I explained the options for coarse and fine-tuned parallelization.  We use both types to compile WebAssembly. <br><br>  I mentioned earlier that the optimizing compiler runs in the background, freeing the main thread for code execution.  The basic compiled version can work while the optimizing compiler performs its own recompilation. <br><br>  But on most computers, in this case, most of the cores will remain unloaded.  In order to optimally use all cores, both compilers use fine-tuned parallelization to separate work. <br><br>  The unit of parallelization is a function.  Each function can be compiled independently, on a separate core.  In fact, it is so finely tuned that in reality we have to group these functions into larger groups of functions.  These groups are sent to different kernels. <br><br><h3>  ... and then skipping all this work due to full caching (in the future) </h3><br>  Currently, decoding and compilation are repeated every time you reload the page.  But if you have the same .wasm file, then it must be compiled into the same machine code. <br><br>  So almost always this work can be skipped.  That is what we will do in the future.  Decoding and compilation will be performed when the page is first loaded, and the resulting machine code will be stored in the HTTP cache.  Then, when requesting this URL, the precompiled machine code will be issued immediately. <br><br>  So the load time will disappear altogether on subsequent page loads. <br><br><img src="https://habrastorage.org/webt/pt/90/42/pt904211tb5bryi0jaenomctzym.png"><br><br>  The foundation for this feature has already been laid.  In Firefox 58, we thus cache JavaScript bytecode.  You only need to extend this feature to support .wasm files. </div><p>Source: <a href="https://habr.com/ru/post/347158/">https://habr.com/ru/post/347158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347144/index.html">CoffeeMiner: hacking WiFi to embed a crypto miner in HTML pages</a></li>
<li><a href="../347146/index.html">Query Profiler in Phoenix. And a little bit about how stacktrace works in Elixir / Erlang</a></li>
<li><a href="../347148/index.html">The digest of interesting materials for the mobile # 237 developer (January 15-21)</a></li>
<li><a href="../347152/index.html">Account Manager: accounts, tokens and all-all-all. Yandex lecture</a></li>
<li><a href="../347154/index.html">Service control panel. Part 2. On the way to the frontend</a></li>
<li><a href="../347160/index.html">Quantum race: 2017 developments</a></li>
<li><a href="../347162/index.html">Sales experience for recruiting in IT</a></li>
<li><a href="../347166/index.html">Why experienced developers write a stupid code and how to recognize a beginner per kilometer</a></li>
<li><a href="../347168/index.html">Routing in socks. Another way</a></li>
<li><a href="../347170/index.html">Making games in Python 3 and Pygame: Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>