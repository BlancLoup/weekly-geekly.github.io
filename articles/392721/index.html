<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to embrace the immensity: the assembly system. NET Micro Framework Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most developers have long been accustomed to using this or that IDE and do not think about how their source code turns into an executable module. Mode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to embrace the immensity: the assembly system. NET Micro Framework Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/147/683/616/1476836161574ab6a8d5129088e89c85.png" align="left"><br><p>  Most developers have long been accustomed to using this or that <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0_%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B8">IDE</a> and do not think about how their source code turns into an executable module.  Modern development tools include <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25B9%25D1%2581_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258F">UI</a> and build automation for a huge number of project types for all occasions.  And this is very cool, as it allows not to think about things that are not directly related to the problem being solved.  But sometimes the task is so complicated that it is no longer possible to use standard types of projects.  And then the "Project Build System" appears. </p><br><p>  A striking example of this type of project is the <a href="https://ru.wikipedia.org/wiki/.NET_Micro_Framework">.NET Micro Framework</a> , an implementation of the Microsoft .NET microcontroller platform.  This article will provide an overview of its build system and features of its implementation. </p><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br><p>  Before we talk about how the project is organized and how it is assembled, you need to understand what goals the project has and what requirements follow from it. </p><br><p>  The idea of ‚Äã‚Äã.Net Micro Framewok is to develop .Net applications for the smallest devices controlled by microcontrollers.  Such devices have several hundred kilobytes of Flash and several tens of kilobytes of RAM.  Due to limited resources, they cannot use full-fledged operating systems, including IoT editions. </p><br><p>  Usually development for such devices is carried out on C \ C ++ with inserts in assembler and is closely connected with a specific microcontroller.  All management of "iron" occurs through writing and reading a set of registers.  In this case, compilers and linkers from the specialized <a href="https://en.wikipedia.org/wiki/Toolchain">toolchain</a> platform set are <a href="https://en.wikipedia.org/wiki/Toolchain">used</a> . </p><br><blockquote>  Previously, many <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580">architectures</a> were represented on the market. <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580"><br></a>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580">microcontrollers</a> .  Each manufacturer had several families of devices and any of them could have their own register scheme.  In addition, there were many different toolchain.  Therefore, the choice of a microcontroller was an extremely important milestone of the project, since then it was very difficult to switch to another device. <br>  Now the world of microcontrollers is ruled by <a href="https://ru.wikipedia.org/wiki/ARM_%2528%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0%2529">ARM</a> .  Many manufacturers abandoned their own cores and switched to this architecture.  This greatly unified the development and facilitated the migration from one device to another.  In addition, <a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a> is developing <a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">at a</a> tremendous pace - a <a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">vendor</a> -independent set of standard software interfaces for working with ARM microcontrollers.  Each organization supplies the CMSIS implementation for its devices, which allows, theoretically, to abstract from the implementation features of one or another microcontroller. <br>  But nevertheless, there are still quite a number of devices on the market, both with an architecture different from ARM and with no implementation of CMSIS. </blockquote><br><p>  .Net Micro Framework is an attempt to raise the development for microcontrollers to a higher level of abstraction.  If CMSIS unifies devices with ARM architecture, then .NetMF tries to unify work with microcontrollers in principle.  And at the same time allows you to use the power of managed code and the convenience of Visual Studio when developing for embedded systems.  At the same time, no one limits the use of .NetMF to microcontrollers only.  For example, there is its implementation for Windows, which is used in the <a href="https://geektimes.ru/post/265986/">emulator</a> . </p><br><p>  Thus, the main requirement for .NetMF is the ability to run on any microcontroller that has enough memory (the documentation lists the minimum requirements for 256KB RAM and 512K Flash / ROM).  Based on this, compilation must be performed by different toolchain, depending on the device selected.  The system architecture must take into account that work at a low level, with hardware, can be carried out either by means of one of the CMSIS implementations, or by any other library or operating system (as in the case of an emulator for Windows). </p><br><p>  Other requirements associated with the implementation of .Net, security systems, debugging, etc., I will not consider, since they do not affect the project build system. </p><br><h2>  Solution Architecture </h2><br><p>  So, the system has three basic requirements: </p><br><ol><li>  Ability to run on any microcontroller with the necessary memory. </li><li>  Ability to use different toolchain. </li><li>  The ability to use both the operating system API, and a wide range of libraries to work with hardware. </li></ol><br><p>  Moreover, paragraphs 2 and 3 are a consequence of the first paragraph. </p><br><p>  The .Net Micro Framework has the following architecture: </p><br><p><img src="https://habrastorage.org/files/47a/b5b/8bf/47ab5b8bf34e47eca2298cd2adbd20d0.jpg" alt="enter image description here"></p><br><p>  The system is divided into several layers: </p><br><p>  The top two layers (user applications and system libraries) are written in manageable code.  This is what we see in Visual Studio.  The hardware layer is the hardware itself, on which .NetMF is running.  The TinyCLR layer is the code execution environment. </p><br><p>  TinyCLR is divided into 3 parts: </p><br><ol><li>  CLR - everything that concerns the execution of managed code, typing, garbage collection, etc. </li><li>  PAL (Platform Abstraction Layer) - classes and functions for working with common abstractions, such as counters, timers, input-output.  These classes are the same for all hardware platforms. </li><li>  HAL (Hardware Abstraction Layer) - classes and functions of the day working directly with the "iron". </li></ol><br><p>  The division into PAL and HAL fulfills requirement number three (the ability to use both the operating system API and a wide range of libraries for working with hardware). </p><br><p>  HAL Abstraction is a set of interfaces that PAL works with and higher levels.  This allows you to make many implementations for different platforms and use any libraries or APIs. </p><br><p>  Thus, developers divide the code into the following layers: </p><br><p><img src="https://github.com/NETMF/netmf-interpreter/wiki/images/NetMFLayerDiagram.png" alt="enter image description here"></p><br><p>  The part designated in the diagram as Native Code is written in C / C ++.  Managed Code is written in C #.  Accordingly, different parts of the repository are compiled by different compilers. </p><br><p>  To implement the ability to compile different toolchain and at the same time preserve the integrity of the project, you need a powerful build system that allows you to customize the entire process.  The build system of the first versions of .NetMF was based on <a href="https://habrahabr.ru/post/155201/">MAKEFILE</a> .  Then there was a transition to <a href="https://ru.wikipedia.org/wiki/MSBuild">MSBuild</a> .  And at that time, the build of Visual C ++ projects in Visual Studio did not use MSBuild (and most of NetMF was written in C \ C ++), so I had to do a ‚Äúnon-standard‚Äù project.  The result is a copy of the build system based on MAKEFILE converted to MSBuild format. </p><br><p>  As a result, this made it possible to fulfill all the requirements related to the multiplatform .NetMF. </p><br><h2>  Features of the implementation </h2><br><p>  Recently an <a href="https://github.com/NETMF/netmf-interpreter/wiki/BuildSystemRequirements">article</a> about the .NetMF build system was published.  The author describes the problems faced by the project. </p><br><p>  There are several scenarios: </p><br><ol><li>  Build the components needed to build the rest of the repository.  Namely, any extensions that are required for the assembly, but are not included in the standard set of MSBuild. </li><li>  Build and configure utilities required for building the project.  This item is important to distinguish from the previous one.  If in the first paragraph extensions of the assembly system were assembled, in the second, additional utilities are collected.  For example, digital signature software. </li><li>  Build an SDK that developers will use when creating an application for .NetMF in Visual Studio.  These include VSIX Palagin and the necessary libraries included in the project. </li><li>  The assembly of "ports" for hardware is TinyCLR for a specific board. </li></ol><br><p>  Before examining each scenario, you need to remind once again that the .Net Micro Framework is ‚Äúarchitecturally neutral‚Äù and includes both big-endian and little-endian systems.  Therefore, many different toolchains can be used for assembly.  To do this, use the complex script for MSBuild.  Moreover, when creating this script, the developers proceeded from a very interesting interpretation of requirement number two: the ability to use different toolchains.  For them, it was important, firstly, to be able to add new toolchain, without "breaking" the existing solution.  And, secondly, to give the user a choice of toolchain.  For example, now compilation can be done using <a href="https://launchpad.net/gcc-arm-embedded">GCC ARM</a> , as well as using <a href="http://www2.keil.com/mdk5/">MDK</a> . </p><br><h3>  Assembly of components for assembly </h3><br><p>  At this stage, extensions are used from the source code that are used by MSBuild to build the rest of the repository.  The reasons why this scenario is separated from the rest are in particular the implementation of MSBuild.  The fact is that before starting the build process, MSBuild immediately loads all the necessary components.  This means that they should already exist by this point.  In addition, MSBuild has a caching system, due to which the assembled components may be inaccessible if you try to assemble the rest of the repository immediately after assembling the preliminary components. </p><br><p>  Therefore, you must first build the extensions, then completely unload MSBuild and only then build the rest of the repository. </p><br><h3>  Build and configure utilities </h3><br><p>  A lot of utilities are involved in the .NetMF build process.  Some of them are involved in signing modules, others in compression, others in format conversion, etc.  These utilities are mainly Windows console applications.  They participate in the assembly of "ports" for devices, and in the assembly of the SDK.  Therefore, they must be collected in advance.  In MSBuild, they are used with the help of wrappers. </p><br><h3>  Build SDK </h3><br><p>  The process of creating an infrastructure for developing an application for .NetMF involves many steps: </p><br><ol><li>  Assembly of preliminary parts.  This stage includes 1 and 2 points of the previous list. </li><li>  Compile source code into a DLL. </li><li>  Conversion of DLL to PE files containing debug information for both big-endian and little-endian systems. </li><li>  Building components for integration with Visual Studio. </li><li>  Signing all components before packaging. </li><li>  Build VSIX packages for supported versions of Visual Studio. </li><li>  Signing VSIX packages. </li><li>  Build SDK MSI packages. </li><li>  Signing SDK MSI packages. </li></ol><br><p>  It is worth noting that the packages need to write several times at different stages.  And here the problem described above also manifests itself (pre-assembly).  The SDK includes the asseblies required for building the SDK.  This is solved by the implementation of the first paragraph. </p><br><h3>  Build "ports" </h3><br><p>  Firmware for a specific device also appears as a result of a large number of steps: </p><br><ol><li>  Compiling native code into .obj files. </li><li>  Compile native code in .lib files. </li><li>  Link native .obj and .lib files to a binary file. </li><li>  Link / Locate on a binary file to get a flash <a href="https://ru.wikipedia.org/wiki/Execute_in_place">XIP</a> image. </li><li>  Signing binary images to support secure downloads. </li><li>  Creating a custom compressed and signed package that can be used by the MFUpdate program. </li><li>  Generate a configuration section image for a Flash device. </li><li>  Compiling managed code into managed assemblies. </li><li>  Generation of necessary components for interaction between native and managed code. </li><li>  Generation of PE files that are executed in .NetMF and corresponding debug information files for big-endian and little-endian systems. </li><li>  Generate DAT files from managed assemblies that will be loaded into the flash device. </li></ol><br><p>  All this is done using scripts for MSBuild. </p><br><h3>  Dependency resolution </h3><br><p>  This point follows from the requirement to use a wide range of libraries for working with hardware. </p><br><p>  Any project somehow encounters dependencies between its component parts.  These can be either links between files, or links between software modules, such as .exe and .dll.  In general, there are two types of dependencies that need to be resolved: </p><br><ol><li>  <em>Hard dependencies</em> . <br>  This type appears when one part of the program is clearly dependent on the other.  For example, application A uses the xyz library.  Such dependencies can easily be resolved automatically.  In this case, the build system understands that you first need to build the xyz library, and then Appendix A. In more modern build systems, xyz and A can be built in parallel in different threads, but linking will still occur after all the components have been assembled. </li><li>  <em>Soft dependencies</em> . <br>  This type occurs when one part of a program references an interface or API that can have many equivalent implementations.  In this case, the build system cannot automatically determine which implementation to use.  An exception is the case when there is only one implementation: the build system will be able to determine what to use.  If there are several implementations, then it needs to explicitly indicate in one way or another what needs to be taken. </li></ol><br><p>  NetMF has both hard and soft dependencies.  And if hard dependencies are resolved automatically, then the problem of soft dependencies is one of the most difficult.  Now it is solved by specifying certain values ‚Äã‚Äãin environment variables and specifying references to implementations in MSBuild scripts.  This is not the best solution, although it works.  Scripts are so complex and full of links to each other that it is very difficult to understand exactly where to change the links. </p><br><h2>  Conclusion </h2><br><p>  Summarizing, we can say that .NetMF because of its "architectural neutrality" has a very complex structure.  The consequence of this is a very difficult project assembly system.  We reviewed the main tasks, their general solutions and some features of the .NetMF build system.  In the next article I will discuss the details of the implementation of this system using scripts for MSBuild. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/392721/">https://habr.com/ru/post/392721/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../392711/index.html">The story of one project. Promo</a></li>
<li><a href="../392713/index.html">Feedback on cashback with Aliexpress or 5 main criteria for evaluating cashback service</a></li>
<li><a href="../392715/index.html">The open Doom beta version will be released on April 15</a></li>
<li><a href="../392717/index.html">Inflatable module MKS</a></li>
<li><a href="../392719/index.html">Choosing the current action camera with a resolution of 2-4k for $ 100</a></li>
<li><a href="../392723/index.html">Modern designers LEGO Education: from simple to complex</a></li>
<li><a href="../392725/index.html">Cello - living cell programming language</a></li>
<li><a href="../392727/index.html">Petya cryptographer will not receive money: we generate the hard drive unlock key ourselves</a></li>
<li><a href="../392729/index.html">Creating a cheap, versatile, gaming controller for mobile devices</a></li>
<li><a href="../392733/index.html">Project "Eye" Part 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>