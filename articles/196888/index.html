<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 6: - other features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". 

 Content: 


- Chapter 1: Getting Started with Boost....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 6: - other features</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <b>Chapter 6: Boost.Asio - Other Features</b> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  In this chapter, we will look at some of the not very well-known features of Boost.Asio.  The std streams and streambuf objects are sometimes a bit more difficult to use, but, as you will see for yourself, they have their advantages.  Finally, you will see quite a late addition to Boost. Asio is co-routines, which will allow you to have asynchronous code, but easy to read (as if it were synchronous).  This is a pretty amazing feature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  std streams and std I / O buffers </h4><br><br>  You should be familiar with objects such as STL streams and STL streambuf in order to understand the things written in this section. <br>  Boost.Asio has two types of I / O buffers: <br><ul><li>  boost :: asio :: buffer () </li><li>  boost :: asio :: streambuf </li></ul><br>  Throughout the book, you basically saw something like the following: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(boost::system::error_code, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes){ ... } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; read(sock, buffer(buff), read_complete); write(sock, buffer(<span class="hljs-string"><span class="hljs-string">"echo\n"</span></span>));</code> </pre> <br>  Usually this will be enough for you.  But, if you want more flexibility, you can use <code>streambuf</code> .  Here is the simplest and worst thing you can do with the <code>streambuf</code> object: <br><br><pre> <code class="cpp hljs">streambuf buf; read(sock, buf);</code> </pre><br>  This reading will go on until the <code>streambuf</code> object is <code>streambuf</code> , and since the streambuf object can redistribute itself to accommodate more space, it will basically read until the connection is closed.  You can use the <code>read_until</code> function to read to the last character: <br><br><pre> <code class="cpp hljs">streambuf buf; read_until(sock, buf, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre><br>  Here, the reading will go to the '\ n' character, then what is read and exits the reading function is added to the buffer.  To write something to the <code>streambuf</code> object you will do something similar to the following: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"echo"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; write(sock, buf);</code> </pre><br>  It's quite simple, you need to create an STL stream, put a streambuf object there during construction, write the message you want to send, and then use the <code>write</code> function to send the contents of the buffer. <br><br><h4>  Boost.Asio and STL streams </h4><br><br>  C Boost.Asio did a great job integrating STL streams and networks.  Namely, if you already use STL extensively, then you should already have a lot of classes with overloaded operators &gt;&gt; and &lt;&lt;.  Reading and writing to the sockets you like more than a walk through the park. <br>  Let's say you have the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> first_name, last_name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person &amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out &lt;&lt; p.first_name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; p.last_name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; p.age; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; in, person &amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> in &gt;&gt; p.first_name &gt;&gt; p.last_name &gt;&gt; p.age; }</code> </pre><br>  Sending a person‚Äôs data over the network is as easy as below: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; person p; <span class="hljs-comment"><span class="hljs-comment">// ... initialize p out &lt;&lt; p &lt;&lt; std::endl; write(sock, buf);</span></span></code> </pre><br>  The other side can just read it: <br><br><pre> <code class="cpp hljs">read_until(sock, buf, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">istream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; person p; in &gt;&gt; p;</code> </pre><br>  The really good side of using <code>streambuf</code> objects and, of course, the corresponding <code>std::ostream</code> for writing or <code>std::istream</code> for reading, is that you end up writing code that will be considered normal: <br><ul><li>  When writing something that will be transmitted over the network, it is very likely that you will have more than one piece of data.  So in the end, you add the data to the buffer.  If this data is not a string, then you must first convert it to a string.  All this happens by default when using the operator &lt;&lt;. </li><li>  The same thing happens on the other side, while reading the message;  you need to parse it, that is, read one piece of data at a time and, if the data is not a string, you need to convert it.  All this happens by default if you use the &gt;&gt; operator when reading. </li></ul><br>  Finally, a pretty cool trick is known, to reset the contents of the <code>streambuf</code> object in the console, use the following code: <br><br><pre> <code class="cpp hljs">streambuf buf; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; &amp;buf &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// dumps all content to the console</span></span></code> </pre><br>  Similarly, to convert its contents to a string, use the following code fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(streambuf &amp;buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> out; out &lt;&lt; &amp;buf; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out.str(); }</code> </pre><br><br><h4>  Class streambuf </h4><br>  As I said before, <code>streambuf</code> derived from <code>std::streambuf.</code>  Like std :: streambuf, it does not have a copy constructor. <br>  In addition, it has several additional features, such as: <br><ul><li>  <code>streambuf ([max_size,] [allocator])</code> : this function creates a <b>streambuf</b> object.  If necessary, you can optionally set the maximum buffer size and allocator that will be used to allocate / free memory. </li><li>  <code>prepare(n)</code> : This function returns a sub-buffer used to accommodate a continuous sequence of <code>n</code> characters.  It can be used to read or write.  The result of this function can be used with any independent function from Boost. Asio read / write, and not only with those that work with <code>streambuf</code> objects. </li><li>  <code>data()</code> : this function returns the entire buffer as a continuous sequence of characters and is used for writing.  The result of this function can be used with any independent function from Boost.Asio, recording, and not only with those that work with <code>streambuf</code> objects. </li><li>  <code>consume(n)</code> : in this function, the data is removed from the input sequence (from the read operation). </li><li>  <code>commit(n)</code> : in this function, data is removed from the output sequence (from a write operation) and added to the input sequence (in a read operation). </li><li>  <code>size()</code> : This function returns the size in characters of the entire <code>streambuf</code> object. </li><li>  <code>max_size()</code> : this function returns the maximum number of characters that can be contained in the <code>streambuf</code> object. </li></ul><br>  With the exception of the last two functions, the rest are not so easy to understand.  First of all, in most cases, you will send an instance of <code>streambuf</code> as an argument for reading / writing an independent function, as shown below: <br><br><pre> <code class="cpp hljs">read_until(sock, buf, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// reads into buf write(sock, buf); // writes from buf</span></span></code> </pre><br>  If you send the entire buffer to an independent function, as shown in the previous snippet, the function will first make sure that it will need to increase the buffer size, look for input and output pointers.  In other words, if there is data to read, then you can read it. <br>  For example: <br><br><pre> <code class="cpp hljs">read_until(sock, buf, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; &amp;buf &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  In the previous snippet, what you just read from the socket is discarded.  The following example will not dump something: <br><br><pre> <code class="cpp hljs">read(sock, buf.prepare(<span class="hljs-number"><span class="hljs-number">16</span></span>), transfer_exactly(<span class="hljs-number"><span class="hljs-number">16</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; &amp;buf &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Bytes are read, but the pointer does not move.  You must move it yourself, as shown below: <br><br><pre> <code class="cpp hljs">read(sock, buf.prepare(<span class="hljs-number"><span class="hljs-number">16</span></span>), transfer_exactly(<span class="hljs-number"><span class="hljs-number">16</span></span>) ); buf.commit(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; &amp;buf &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Similarly, if you want to write a <code>streambuf</code> object and if you use the independent write function, use the following code snippet: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"hi there"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; write(sock, buf);</code> </pre><br>  The following code will send <code>hi there</code> three times: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"hi there"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) write(sock, buf.data());</code> </pre><br>  This happens because the buffer is never destroyed and the data remains there.  If you want data to be destroyed, then look at how it is implemented: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"hi there"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; write(sock, buf.data()); buf.consume(<span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre><br>  In conclusion, you should prefer to deal with the whole <code>streambuf</code> instance.  Use the previous features if you want tweaking. <br>  Even if you can use the same streambuf for reading and writing, I still recommend you two separate instances, one for reading and one for writing.  This is perceived easier and clearer, and you will avoid many possible mistakes. <br><br><h4>  Independent functions that work with <code>streambuf</code> objects </h4><br>  The following list shows the independent functions from Boost.Asio that work with <code>streambuf</code> objects: <br><ul><li>  <code>read (sock, buf [, completion_function])</code> : this function reads from the socket to the <code>streambuf</code> object.  The final function is optional.  If it is, then it is called after each successful read operation and reports Boost.Asio, if the operation is completed (if not, it continues reading).  Its signature is as follows: <code>size_t completion(const boost::system::error_code &amp; err, size_t bytes_transfered)</code>  Upon completion, the function returns 0, meaning, if the read operation has completed completely;  if they return a non-zero value, this means that the maximum number of bytes for the next call to the stream function <code>read_some</code> . </li><li>  <code>read_at(radom_stream, offset, buf [, completion_function])</code> : this function reads from a random stream.  Note that this does not apply to sockets (since they do not model the concept of a random stream). </li><li>  <code>read_until(sock, buf, char | string | regex | match_condition)</code> : this function reads as long as this condition is met.  Either a certain character must be read, or a string or regular expression matches one of the read lines, or the <code>match_condition</code> function will tell us to exit the function.  The <code>match_condition</code> function signature is as follows: <code>match_conditionis pair&lt;iterator,bool&gt;match(iterator begin, iterator end)</code> ;  where the main iterator is <code>buffers_iterator &lt;streambuf::const_buffers_type&gt;</code> .  If a match is found, the pair will return ( <code>passed-end-of-match</code> set to <code>true</code> ), if no match is found, the other pair will return ( <code>begin</code> set to <code>false</code> ). </li><li>  <code>write(sock, buf [, completion_function])</code> : This function writes all the contents into a <code>streambuf</code> object.  The final function is optional and its behavior is similar to the final <code>read()</code> function: it returns 0 when the write operation is completed or a non-zero value when the number of bytes is specified which will be written upon the next call to the stream function <code>write_some</code> . </li><li>  <code>write_at(random_stream,offset, buf [, completion_function])</code> : this function writes to a random stream.  Again, does not apply to sockets. </li><li>  <code>async_read(sock, buf [, competion_function], handler)</code> : this asynchronous counterpart of the <code>read()</code> function.  The handler signature is as follows: <code>void handler(const boost::system::error_code, size_t bytes)</code> . </li><li>  <code>async_read_at(radom_stream, offset, buf [, completion_function] ,handler)</code> : this is the asynchronous counterpart of the <code>read_at()</code> function. </li><li>  <code>async_read_until (sock, buf, char | string | regex | match_condition, handler)</code> : this is the asynchronous counterpart of the <code>read_until()</code> function. </li><li>  <code>async_write(sock, buf [, completion_function] , handler)</code> : this is the asynchronous counterpart of the <code>write()</code> function. </li><li>  <code>async_write_at(random_stream,offset, buf [, completion_function], handler)</code> : this is the asynchronous counterpart of the <code>write_at()</code> function. </li></ul><br>  Suppose you want to read a vowel: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_vowel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c == <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'e'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'i'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'o'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'u'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(boost::system::error_code, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * begin = buffer_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;( buf.data()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( bytes == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( bytes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_vowel(*begin++)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> --bytes; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... read(sock, buf, read_complete);</code> </pre><br>  If you, for example, want to use regular expressions, then it is very simple: <br><br><pre> <code class="cpp hljs">read_until(sock, buf, boost::regex(<span class="hljs-string"><span class="hljs-string">"^[aeiou]+"</span></span>) );</code> </pre><br>  Or let us modify the example a little, and you can place the <code>match_condition</code> function to work: <br><br><pre> <code class="cpp hljs">streambuf buf; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_vowel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c == <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'e'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'i'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'o'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'u'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> buffers_iterator&lt;streambuf::const_buffers_type&gt; iterator; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;iterator,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; match_vowel(iterator b, iterator e) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( b != e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_vowel(*b++)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(e, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes = read_until(sock, buf, match_vowel);</code> </pre><br><br><h4>  Coroutines </h4><br>  The authors of Boost.Asio, around 2009-2010, implemented a very cool coroutine idea that will help you create asynchronous applications even easier. <br>  They allow you to facilitate two things, that is, it is easy to write an asynchronous application, and it is as easy to follow the flow of control, almost as if the application was written sequentially. <br><br><img src="http://habrastorage.org/storage3/56c/3b2/1ba/56c3b21ba43b330abb6f703efa78d87f.png"><br><br>  In the first case, the usual approach is displayed.  Using coroutines, you get as close as possible to the second case. <br>  Simply put, coroutine allows you to use multiple entry points to pause and resume execution at specific locations within a function. <br>  If you are going to use coroutines, then you will need to include two header files that you can find only in <code>boost/libs/asio/example/http/server4: yield.hpp</code> and <code>coroutine.hpp</code> .  Here two macros and a class are defined in Boost.Asio: <br><ul><li>  <code>coroutine</code> : this class is a derivative of your <code>connection</code> class or that you use in order to implement coroutines. </li><li>  <code>reenter(entry)</code> : this is the coroutine body.  The input argument is a pointer to a subroutine, for example, for use as a block within an entire function. </li><li>  yield code: executes instructions as part of the coroutine. </li></ul><br>  To better understand, consider a few examples.  We will re-implement the application of chapter 4, which is a simple client that logs in, pings and can tell you what other clients are logged. <br>  The main code is similar to: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_svr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;talk_to_svr&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> coroutine, boost::noncopyable { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err = error_code(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ reenter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sock_, write_buffer_, MEM_FN2(step,_1,_2) )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_read_until</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( sock_, read_buffer_,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, MEM_ FN2(step,_1,_2))</span></span></span></span>; yield service.post( MEM_FN(on_answer_from_server)); } } } };</code> </pre><br>  The first thing that has changed is that a large number of member functions have disappeared, such as <code>connect(), on_connect(), on_read(),do_read(), on_write(), do_write()</code> and so on. Now we have one called function <code>step()</code> <br>  The function body is inside the <code>reenter(this) { for (;;) { }}</code> .  You can think of <code>reenter(this)</code> as the code that we executed last, so that we can now call the following code. <br>  Inside the <code>reenter</code> block you can see several ongoing calls.  The first time the function is entered, the <code>async_write</code> function is <code>async_write</code> , the second input is the <code>async_read_until</code> function, the third is the <code>service.post</code> function, the fourth is <code>async_write</code> again <code>async_write</code> and so on. <br>  You should never forget the <code>for(;;) {}.</code> instance <code>for(;;) {}.</code>  Look at the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err = error_code(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ reenter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sock_, write_buffer_, MEM_FN2(step,_1,_2) )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_read_until</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( sock_, read_buffer_, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">,MEM_FN2(step,_1,_2))</span></span></span></span>; yield service.post( MEM_FN(on_answer_from_server)); } }</code> </pre><br>  If we used the previous code snippet for the third time, we would enter the function and <code>service.post</code> .  The fourth time we would have passed by <code>service.post</code> and didn‚Äôt do anything.  The same thing will happen for the fifth time and for all of the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_svr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;talk_to_svr&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> coroutine, boost::noncopyable { talk_to_svr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; username) : ... {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::endpoint ep)</span></span></span><span class="hljs-function"> </span></span>{ sock_.async_connect(ep, MEM_FN2(step,_1,<span class="hljs-number"><span class="hljs-number">0</span></span>) ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::endpoint ep, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; username)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> talk_to_svr(username))</span></span></span></span>; new_-&gt;start(ep); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err = error_code(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ reenter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started_) { started_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;write_buf_)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"login "</span></span> &lt;&lt; username_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sock_, write_buf_, MEM_FN2(step,_1,_2) )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_read_until</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( sock_,read_buf_,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, MEM_FN2(step,_1,_2))</span></span></span></span>; yield service.post( MEM_FN(on_answer_from_server)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_answer_from_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">istream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;read_buf_)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> word; in &gt;&gt; word; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( word == <span class="hljs-string"><span class="hljs-string">"login"</span></span>) on_login(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( word == <span class="hljs-string"><span class="hljs-string">"ping"</span></span>) on_ping(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( word == <span class="hljs-string"><span class="hljs-string">"clients"</span></span>) on_clients(); read_buf_.consume( read_buf_.size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (write_buf_.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) service.post( MEM_FN2(step,error_code(),<span class="hljs-number"><span class="hljs-number">0</span></span>)); } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ip::tcp::socket sock_; streambuf read_buf_, write_buf_; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> started_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> username_; deadline_timer timer_; };</code> </pre><br>  When we start a connection, the <code>start()</code> function is called, which asynchronously connects to the server.  When the connection is established, we enter <code>step()</code> for the first time.  This is when we send a message with our login. <br>  After this we use <code>async_write</code> , then <code>async_read_until</code> and process the message ( <code>on_answer_from_server</code> ). <br>  In the <code>on_answer_from_server</code> function <code>on_answer_from_server</code> we process incoming messages;  we read the first word and send it to the corresponding function, and we ignore the rest of the message (in any case): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_svr</span></span></span><span class="hljs-class"> :</span></span> ... { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_ask_clients(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">istream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;read_buf_)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> answer; in &gt;&gt; answer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( answer == <span class="hljs-string"><span class="hljs-string">"client_list_changed"</span></span>) do_ask_clients(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> postpone_ping(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> clients; clients &lt;&lt; &amp;read_buf_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; username_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">", new client list:"</span></span> &lt;&lt; clients. str(); postpone_ping(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;write_buf_)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ping\n"</span></span>; service.post( MEM_FN2(step,error_code(),<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postpone_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ timer_.expires_from_now(boost::posix_time::millisec(rand() % <span class="hljs-number"><span class="hljs-number">7000</span></span>)); timer_.async_wait( MEM_FN(do_ping)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ask_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;write_buf_)</span></span></span></span>; out &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ask_clients\n"</span></span>; } };</code> </pre><br>  The example is a bit more complicated, since we have to check the connection with the server at a random time.  To do this, we postpone the ping operation after successfully requesting a list of clients for the first time.  Then we postpone another ping operation for each reply ping from the server. <br>  To run all this, use the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; talk_to_svr::start(ep, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); service.run(); }</code> </pre><br>  Using coroutines, we reduced the code by 15 lines, and it also became much more readable.  Here we barely touched on the subject of coroutines.  If you want more information on this issue, you can visit this <a href="http://blog.think-async.com/2010_03_01_archive.html">page</a> . <br><br><h4>  Summary </h4><br>  We have seen how easy Boost.Asio works with STL streams and streambuf objects.  We also looked at how coroutines make our code more compact and easier to understand. <br>  In the next chapter, we will look at topics such as Asio vs. Boost.Asio, progressive debugging, SSL, as well as some other platform-specific features. <br><br>  Resources for this article: <a href="https://github.com/Vasilui/habrahabr/tree/master/Boost.Asio_C%252B%252B_Network_Programming/Chapter_6">link</a> <br><br>  Thank you all for your attention, until we meet again! </div><p>Source: <a href="https://habr.com/ru/post/196888/">https://habr.com/ru/post/196888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196878/index.html">We struggle with the errors of the accelerometer, gyroscope, M7, digital compass and other sensors in the iPhone 5S and not only</a></li>
<li><a href="../196880/index.html">White Graphene protects against rust even at high temperatures.</a></li>
<li><a href="../196882/index.html">Virus on the site or reverse engineering Exploit.SWF.254</a></li>
<li><a href="../196884/index.html">With a camera in the clouds. Part 1</a></li>
<li><a href="../196886/index.html">(Archive) Matreshka.js - MK.Object</a></li>
<li><a href="../196894/index.html">Another way to spend money - thanks to the "beloved" mobile operator!</a></li>
<li><a href="../196896/index.html">Ask questions to the experts. How can developers get help from Intel?</a></li>
<li><a href="../196900/index.html">About flags 0x41414141 times</a></li>
<li><a href="../196904/index.html">RAD Studio XE5 World Tour in Lviv, Ufa, Kiev, Minsk</a></li>
<li><a href="../196910/index.html">Opera 17 release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>