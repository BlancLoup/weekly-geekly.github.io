<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real-time event handling with SynapseGrid</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We were engaged somehow in audio processing in Java using complex algorithms. Each piece of audio had to go through a long chain of processing (20-50 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real-time event handling with SynapseGrid</h1><div class="post__text post__text-html js-mediator-article">  We were engaged somehow in audio processing in Java using complex algorithms.  Each piece of audio had to go through a long chain of processing (20-50 algorithms of varying degrees of complexity).  Audio streams arrived in parallel, the algorithms worked in parallel, and ended at different times.  Some algorithms needed different degrees of buffering.  Information from an increasing level of abstraction was extracted from pieces of audio, that is, starting from some level, it was not the audio that was coming, but the extracted information about this audio. <br><br>  The whole farm was supposed to work within the framework of a single instance of the application, but it had to have several nested almost independent very similar containers for the client code (such as beans). <br><br>  From the very beginning, we did not set the goal of universal unification, and we solved it in our own way in each part of the system.  Somewhere they used threads for long-term tasks, somewhere they created chains of calls, somewhere they used a subscription model.  Since the system was quite large, almost all known methods of decomposition and processing were involved in varying degrees.  Then we discovered commonality and implemented similar solutions in different parts of the system.  And then they invented the first version of what we now call contact system or <a href="">SynapseGrid</a> . <br><a name="habracut"></a><br><h4>  Modularity </h4><br>  Since we did not solve a separate applied task from the ‚Äúdid-forgotten‚Äù series, but implemented tools to solve a family of tasks, one of the principles of development was the <b>principle of modularity</b> .  That is, we created separate reusable components that had to be combined in an almost arbitrary manner in order to build systems to solve any task from the family. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Audio stream processing </h4><br>  When we first started, we didn't understand very well how to model the audio stream.  We began by representing it in the form of an AudioInputStream.  It turned out that such a representation does not allow for modularity.  Those.  One module can easily read from a byte stream with locks, and perform its processing.  But how will he pass the data on?  If you connect modules with pipe, you will have to put each tiny module in a separate execution thread, which will be blocked until a piece of new data arrives.  This, of course, was extremely inefficient. <br><br>  Then we found that if the audio stream is divided into frames (pieces of fixed length, 10-40 ms each), then the modules are much easier to connect.  Pieces of audio could be placed in a normal queue and the queue could be checked without blocking. <br><br>  Primary audio processing in many tasks turned out to be almost linear.  Those.  the modules were lined up in a chain in which the output of the previous module was connected to the input of the subsequent module.  This structure is usually called the pipeline. <br><br>  There are three ways to organize data transfer: <br><br>  1. pull <br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function"> </span></span>= process(previousModule.getData)</code> </pre> <br>  2. push <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushData</span></span></span></span>(d:data) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = process(d) nextModule.pushData(res) }</code> </pre><br>  3. functional aggregation <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(d:data) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = module1.f(d) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = module2.f(r1) r2 }</code> </pre><br>  In the case of pull, the data is ‚Äúpulled out‚Äù of the last component, and the chain of previous components is unobservable and blocking may occur due to lack of data in some buffer.  If any exception occurs, the entire stack collapses, which makes it impossible to continue working. <br><br>  In the case of push, the data ‚Äúpushes‚Äù into the first component and their subsequent fate remains unknown.  If there is a lack of data for buffering at the output of the chain, nothing appears.  When an exception occurs, the stack collapses again and the exception appears at the very beginning of the chain, where it is again not clear what can be done.  Continuing work is also impossible.  In addition, the implementation of modules in push mode is rather inconvenient / unusual for a programmer.  And it definitely requires side effects. <br><br>  When we began to use the functional-approach, it turned out that it has advantages over pull and push.  First, the entire chain of components is clearly visible, and can be easily traced.  Secondly, when an exception occurs in any component, it is easy to intercept, and, importantly, the exception affects only one component, and processing can be continued with minimal problems. <br><br>  Since  development at that time was Java, we made an interface for the functional approach that all modules had to implement.  It turned out that the modules were fundamentally divided into two types - those that always required exactly one output element for each input element, and other modules that could output 0..n elements at the output.  Modules of the first type (of the <code>map</code> type), although they were a special case of the second type, but they were encountered quite often and their interface was simpler: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapModule</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TIn</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TOut</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(data:<span class="hljs-type"><span class="hljs-type">TIn</span></span>):<span class="hljs-type"><span class="hljs-type">TOut</span></span> }</code> </pre><br><br>  Modules of the second type ( <code>flatMap</code> ) contained internal buffering specific to the module, and had at the output a collection containing 0..n elements: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlatMapModule</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TIn</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TOut</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(data:<span class="hljs-type"><span class="hljs-type">TIn</span></span>):<span class="hljs-type"><span class="hljs-type">Collection</span></span>[<span class="hljs-type"><span class="hljs-type">TOut</span></span>] }</code> </pre><br>  For "pumping" data through the pipeline, it was possible to use two strategies - depth first or width first. <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widthFirst</span></span></span></span>(d:<span class="hljs-type"><span class="hljs-type">Data</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1:<span class="hljs-type"><span class="hljs-type">Collection</span></span>[...] = module1.f(d) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(d1 &lt;- r1; d2 &lt;- module2.f(d1)) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> d2 <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r3 = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(d2 &lt;- r2; d3 &lt;- module3.f(d2)) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> d3 r3 } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depthFirst</span></span></span></span>(d:<span class="hljs-type"><span class="hljs-type">Data</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(d1 &lt;- module1.f(d); d2 &lt;- module2.f(r1); d3 &lt;- module3.f(d2) ) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> d3 }</code> </pre><br>  At depth first, each element was traced to the end of the chain, and then the next input element was processed.  With width first, all elements went through the first stage, then all received ones went through the second stage, and so on. <br><br>  The most common interface is 1 -&gt; 0..n (flatMap), so this interface was taken as the basis for development.  It turned out that modules having such an interface are very easy to integrate on the principle of functional aggregation into larger modules having exactly the same interface.  For a linear pipeline, it turned out that nothing else was required. <br><br><h4>  Subscription model </h4><br>  At some point, the processing forked.  The same data had to be transferred to several modules.  A scheme that worked well for the pipeline created problems here.  First, in order to transfer data to several places, it was necessary to have an algorithm in which both continuations were explicitly stated.  Secondly, when aggregating a chain with two ends, it was impossible to provide the same interface with one input and one output. <br><br>  We quickly came up with a scheme with a subscription to events.  An Event [T] object was created in which it was possible to put data on one side and subscribe to new data on the other.  This allowed for decoupling modules.  The event was made asynchronous and thread safe.  The created scheme is very similar to the <a href="https://github.com/Netflix/RxJava">RxJava</a> library (where the event is called Observable [T]). <br><br>  The subscription model was pretty good and made it quite simple to organize work in several independent streams.  One of the differences from Observable in our scheme was that data could come from several sources as input to Event. <br><br><img src="http://habrastorage.org/storage3/e98/991/bc7/e98991bc7aaaf0275042033927058eb5.png"><br>  Fig.1 Many-to-many, directly <br><br><img src="http://habrastorage.org/storage3/995/14a/f43/99514af4374c1be714a4ea138906305e.png"><br>  Fig.2 Many-to-many under the "star" scheme <br><br><br>  As the project progressed, the number of event's increased and the limitations of this scheme became apparent. <br><br>  1. It is not known whether this event is generated by anyone. <br>  2. It is not known whether anyone has subscribed to the event. <br>  3. Data streams flow unobservable - one event, a handler, hidden internal generation (?) Of another event, another handler, etc. <br>  4. If the subscription is synchronous, i.e.  If the handler is executed in the calling thread, it is not clear what to do with the exception. <br><br>  If the event handler's subscription to the event can still be traced, and even event-subscribers can be drawn, then the generator-event communication was otherworldly and it was impossible to understand whether someone was generating this event and under what conditions. <br><br><h4>  Akka </h4><br>  At this point <a href="http://akka.io/">Akka was</a> already used for remoting here and looked promising.  At least, one could hope to pass on the Akka multithreading and solve some problems with events. <br><br>  Akka offers a lightweight Actor who works in a conditionally separate stream, but does not consume a lot of resources.  A conditionally separate stream means that if an ector is busy processing a message, no other thread will be simultaneously used to process other messages by the same ector.  Those.  a separate ector processes the messages strictly sequentially, but with a large number of ectors it turns out that everyone works joyfully in parallel and does not interfere with each other. <br><br>  It turned out that in the approach with communication ectors, they are not thought out at all and are not observed.  Those.  Relations between ectors are entirely on the conscience of the developer and can crawl along the program as you please.  Moreover, although we can theoretically track the fate of a single link to an ector, however, Akka provides a way to get links to the textual url of the ector.  Those.  in principle, we cannot track and limit the spread of links in the system. <br><br>  What does this lead to?  In a multi-threaded system with a large number of similar ectors and a huge number of unobserved links, there are occasionally little-known phenomena.  For example, an infinite loop of three types: divergent, when in each iteration the number of messages increases, monotonous, which simply lives its own life, eats away processor resources, but does not lead to a catastrophe, and fading, when the number of messages slowly decreases.  To debug such a system is next to impossible.  It is very difficult.  In a number of critical places, we had to use the <a href="http://spinroot.com/spin/whatispin.html">Model Checking</a> approach.  Still, there was no complete certainty that some messages did not circulate somewhere. <br><br><h4>  Upstart </h4><br>  Some time ago, a boot system based on an event model ( <a href="http://upstart.ubuntu.com/cookbook/">Upstart</a> ) appeared in Ubuntu.  The system is very remarkable for its approach to events.  Each event has a name and can have parameters.  Handlers (tasks) can subscribe to a combination of events (with boolean conditions on parameters) and will be called if everything goes well.  Also, handlers declaratively describe the events that they generate (although it is possible to generate any event in another way). <br><br>  This system describes the so-called "lattice", or directed graph (digraph).  Lattice nodes are events, and branches are handlers.  Due to the upstart built-in parallelism in the graph, it is possible to start handlers much earlier than System V, based on fixed separating layers (runlevels 0..6).  Independent handlers work quietly in parallel. <br><br>  The ideas of Upstart influenced the further development of the contact system. <br><br><h4>  Contact system version 1 </h4><br>  As long as we consider a picture of a star with one event (shown in the figure above), we will not be able to come up with a good mechanism for organizing a multi-threaded system.  But if we construct a directed graph, interesting perspectives are already drawn. <br><br><img src="http://habrastorage.org/storage3/f18/9e4/635/f189e46356a2a11544a19b95b1134086.png"><br>  Fig.3 The grid of events and handlers <br><br><br>  The scheme is very similar upstart.  If you demand that the declarations are declared declaratively and prohibit / exclude the implicit creation of links, then the entire graph describing the operation of the entire system turns out to be at a glance and is available for static analysis.  Just by observing such a graph, you can detect unwanted cycles, missing links, hanging separately Event'y or handlers. <br><br>  In the first version, we just summarized and adapted Event [T] somewhat, but kept the distributed (‚Äúsmeared‚Äù) message passing mechanism.  The availability of the processing graph in itself allowed to understand the operation of the system and solve current problems.  But such a ‚Äúblurred‚Äù message transfer mechanism with mandatory buffering and protected and thread-safe was not suitable for solving similar problems in other parts of the system.  It required something similar, but more lightweight. <br><br><h5>  The mechanism of operation of lightweight ectors in Akka </h5><br>  It requires a slight digression on the mechanism of lightweight ectors, which has many similarities with the SynapseGrid architecture. <br><br>  Consider this code: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> helloActorRef = actor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Act</span></span> { become { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> ‚áí sender ! <span class="hljs-string"><span class="hljs-string">"hi"</span></span> } }) helloActorRef ! <span class="hljs-string"><span class="hljs-string">"Hello"</span></span></code> </pre><br><br>  When we send a ‚ÄúHello‚Äù message to an ector, a wrapper is created around our message: <br><br><pre> <code class="scala hljs"> <span class="hljs-type"><span class="hljs-type">Message</span></span>(helloActorRef, <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)</code> </pre><br><br>  And this message is placed in the queue.  Somewhere in parallel there are 16 threads that read messages from this large queue.  And there is still some dispatcher who ensures that two threads do not work with one ector at the same time.  The thread grabs the message, finds the ector and simply performs the function of this ector on our message (‚ÄúHello‚Äù). <br><br>  Such a scheme allows millions of ectors to exist who do not consume resources (except for a bit of memory) while they are sleeping.  And the consumption of processor time occurs only in 16 threads and exclusively on the processing of real data. <br><br>  If you look at the user model, then each ector has his own message queue and we are a team <code>!</code>  send our message to this queue.  That is, it looks like there are a million bursts.  And this custom model is implemented in the form of a global queue and global flows.  There is a kind of virtualization of the user view using an effective system view. <br><br>  In this scheme, actorRef plays the role of a handle, or a tag, or a label.  Those.  We supply our data with a label that shows the location of the ‚ÄúHello‚Äù message in the virtual space of virtual queues of ectors. <br><br>  Virtually every million ektorov we have a million queues.  Represent an array of 1,000,000 queues that you need to view?  In this virtual user model, everything will not be very effective.  And the same structure is implemented with the help of labels, which allows to get one big queue, but with tags-tags.  And this queue will work very effectively. <br><br>  Another analogy that comes to mind is using a HashMap to store huge sparse arrays.  How can we save some data for several points in three-dimensional space?  Let the size of our three-dimensional space - 1000x1000x1000.  If you store arrays, you will need 10e9 cells.  And if you use the label (x, y, z), then you need much less memory.  This is where <code>HashMap[(x,y,z), data]</code> works. <br><br><h4>  Contact System Version 2 or SynapseGrid </h4><br>  In the scheme with a blurred mechanism for transferring communications, messages were directly stored in Event.  It is as if a million queues to the ectors actually do.  But if you make a single collection where events and connections will be located, then you can provide an effective centralized message distribution mechanism. <br><br>  So, to represent events that you can subscribe to, we introduce the concept of <b>contact</b> , <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> contact1 = <span class="hljs-type"><span class="hljs-type">Contact</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-string"><span class="hljs-string">"1"</span></span>)</code> </pre><br>  and to submit messages associated with this contact, a <b>signal</b> . <br><pre> <code class="scala hljs"> <span class="hljs-type"><span class="hljs-type">Signal</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](contact1, data:<span class="hljs-type"><span class="hljs-type">T</span></span>)</code> </pre><br>  As you can see, the contact is similar to ActorRef, and the signal is similar to Message.  The difference is that neither the state nor the behavior is associated with the contact.  This is just some kind of ID.  If we recall the analogy with the virtual "queue", the contact identifies this queue. <br><br>  Since  there is no data or behavior in the contact, it is simply impossible to send a message to it.  This leads to the impossibility of creating otherworldly links, which usually arise inside handlers / handlers.  Relationships can only be declarative. <br><blockquote><h6>  External binding </h6><br>  In the use of contacts and signals, ActorRef and Message, we observe a common pattern, which, apparently, is quite common in functional programming.  I call this pattern "external binding".  The idea is not to store data in the object that is used to address this data.  Instead, the address (link, identifier) ‚Äã‚Äãis an immutable structure, similar to an index.  And the value is stored somewhere else or not anywhere at all.  To access the data, we use some kind of <strike>monad</strike> system that manages our data. <br><br>  For example, a signal is a temporary object that reports for a short time that such-and-such data is on such a contact.  It would be possible with the same success instead of a list of signals to use a HashMap or other structure that would seem convenient to us. <br><br>  Due to the fact that data is not stored in the contact itself, we can, for example, operate on the history of the ‚Äústate‚Äù of a variable.  It is enough to have a list of signals related to one contact.  A signal processing for the entire system allows you to build the development in time of all its "states". <br></blockquote><br>  As mentioned above, the model of the whole system is a directed graph.  If you look closely, you can see that this is a bichromatic graph.  But in most cases, elementary handlers are map or flatMap components that have one input and one output.  Therefore, the basis of the SynapseGrid is a simpler graph, the nodes of which correspond to the contacts, and the arcs are connected with the components that process the data.  Those.  the graph is defined by a set of triples (contact 1, contact 2, handler): <br><pre> <code class="scala hljs"> <span class="hljs-type"><span class="hljs-type">Link</span></span>[<span class="hljs-type"><span class="hljs-type">TIn</span></span>, <span class="hljs-type"><span class="hljs-type">TOut</span></span>](from:<span class="hljs-type"><span class="hljs-type">Contact</span></span>[<span class="hljs-type"><span class="hljs-type">TIn</span></span>], to:<span class="hljs-type"><span class="hljs-type">Contact</span></span>[<span class="hljs-type"><span class="hljs-type">TOut</span></span>],function: <span class="hljs-type"><span class="hljs-type">TIn</span></span>=&gt;<span class="hljs-type"><span class="hljs-type">Collection</span></span>[<span class="hljs-type"><span class="hljs-type">TOut</span></span>])</code> </pre><br>  (here we use the fact that map components are a special case of flatMap components). <br><blockquote>  In the <a href="">SynapseGrid description, there</a> is an interesting <b>metaphor for a breadboard model</b> , well illustrating the idea of ‚Äã‚Äãa SynapseGrid. </blockquote><br>  When data (signals) appear on any contact, we can easily identify all the handlers that would like to process this data, we can plan to call these handlers in one or several threads.  The results of the work received by each processor become signals on the output contacts to which the processors are attached, and again get into the general queue for processing. <br><br><h5>  Buiders and DSL </h5><br>  The described mechanism of operation assumes the presence of an immutable (immutable) graph, given by a set of triples.  Such a graph would not be very convenient to create immediately in one expression.  Instead, it turns out to be convenient to use the concept of builders, which allow step by step, by adding individual arcs, to construct a graph of the system. <br><br>  For the contact system, we developed the DSL <code>SystemBuilder</code> , which contains many methods for all occasions, allowing us to design the system step by step. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = input[<span class="hljs-type"><span class="hljs-type">Int</span></span>](<span class="hljs-string"><span class="hljs-string">"in"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// input -    ,       val c = contact[Int]("c") (in -&gt; c).map(_ * 2) //   Link   in  c.   map-,      2 val c2 = in.map(_ * 2) //       map.   </span></span></code> </pre><br>  Using the standard method names map, flatMap, filter allows you to use Scala-sugar - for-comprehension: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c2 = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i &lt;- in) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,      in.map val c3 = for(i &lt;- in; j &lt;- 0 until i) yield j * 2 // /*    : val temp = in.flatMap(i =&gt; 0 until i) val c3 = cc.map(j =&gt; j * 2) */</span></span></code> </pre><br>  More examples of using DSL are in the <a href="">SynapseGrid description</a> . <br><blockquote><h6>  Metamorphosis system </h6><br>  In SynapseGrid, two phases are clearly distinguished - the system design phase and the runtime phase.  And usually these phases do not overlap.  It is impossible to simply add new elements to the working system.  A similar phenomenon occurs, for example, in Guice - modules are created first, and then according to the description contained in the modules, a working system is constructed. <br><br>  The code that constructs the system uses the API Builder.  And the code that works in a real system knows nothing about contacts and signals.  It simply processes the incoming data and returns the result of the execution. <br></blockquote><br><h5>  Trellis, discrete time, synchronism and determinism </h5><br>  One of the features of Akka and other approaches based on ectors is the fact that the order of processing messages by different actors is not defined and given to chance.  Most likely, this leads to a gain in performance, but also adversely affects the predictability of the system. <br><br>  Since unpredictability is much worse for us than under-utilization of the processor's potential, we decided to ensure guarantees of the sequence of signals in the main modes of operation.  (A more productive, but less deterministic mode of operation is used only for optimization in rare cases.) <br><br>  All signals are immersed at a discrete time and are ordered within each time slot.  At the initial moment of time there is one signal at the input contact.  The transition from one point of time to another occurs only when all signals of the current point in time are processed.  Generated signals are ordered as if the handlers were called strictly sequentially (in single-threaded mode it is, and in multi-threaded signals are ordered by force). <br><br>  If you look at the set of signals at each moment in time, then the resulting picture is called a <a href="http://merganser.math.gvsu.edu/david/reed05/projects/jimenez/">trellis</a> and is used, for example, in <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D1%2581%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B4%25D0%25B5%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%2592%25D0%25B8%25D1%2582%25D0%25B5%25D1%2580%25D0%25B1%25D0%25B8">the Viterbi algorithm</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since all processing is centralized, no one prevents us from drawing such a picture and analyzing the passage of signals. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the graph forks, it can be quite simple to guarantee the synchronism of the appearance of signals at the given contacts. </font><font style="vertical-align: inherit;">If alternative chains have different lengths, then synchronism is provided very simply - by adding a few empty arrows (‚Äúdelay lines‚Äù).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subsystems </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The created system of contacts remarkably replaced the pipeline and subscriptions to events. And gradually, many components of the system were transferred to this system. However, to integrate several systems, it was necessary to provide for the existence of components with several inputs and several outputs. In contrast to the two-terminal components, analogs of which are normal functions, we did not find analogues for multi-contact components. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output was found in the use of all the same labels for distinguishing the inputs between themselves and the outputs among themselves. The component representing the subsystem obtained the following signature:</font></font><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Signal</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Collection</span></span>[<span class="hljs-type"><span class="hljs-type">Signal</span></span>]</code> </pre><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the data we want to send to the in1 input is wrapped in a Signal and marked with the in1 contact. </font><font style="vertical-align: inherit;">Data appearing at the out1 output is presented </font></font><code>Signal(out1, data)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of the trellis of the parent system, all processing in the child subsystem occurs in one time step. </font><font style="vertical-align: inherit;">Inside the subsystem creates its own trellis.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallelism </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The subsystem turned out to be a good contender for execution in a separate thread and we first implemented a mechanism that allows to allocate any subsystem into a separate Akka-Ector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a scheme made it possible to cover 90% of all needs for multithreading. </font><font style="vertical-align: inherit;">Akka guarantees that within one ector everything that happens can be considered single-threaded. </font><font style="vertical-align: inherit;">And SynapseGrid allowed to unite any number of ectors into a connected system with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">observed links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In ectors built on the basis of subsystems there is no direct possibility of creating another-world communication with another subsystem. </font><font style="vertical-align: inherit;">The picture of the world becomes much more transparent.</font></font><br><blockquote><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The advantages of the system of ektor on SynapseGrid </font></font></h6><br> ,    SynapseGrid,         ,    Akka .  Namely: <br> 1. -  .     (). <br> 2.      . <br> 3.       ,     . <br> 4.     ,         . <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are still 10% of the need for multithreading, which did not give us peace of mind. Namely, if we needed to provide parallel processing of the mass of the same type data using one component, the ectors based on subsystems skidded. They processed data strictly in a consistent manner. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then it was decided to make your scheduler, which will load the work of 16 ExecutorContext threads according to the SynapseGrid semantics. The synapse-grid-concurrent library allows you to fully implement the system of arbitrary nesting on the thread pool and at the same time ensures the determinism of the single-threaded version.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynapseGrid allows you to build modular systems that perform urgent (ASAP) data processing without unnecessary buffering. The library is based on a functional approach, external linking and a declarative approach. The system is built using the advanced API Builder in design mode. And in runtime the system is unmodifiable (immutable). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The processing logic can be executed in one or in several threads with the guarantee of obtaining identical results. SynapseGrid extends Akka by adding strongly typed inputs, outputs and connections between ejectors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library is published on GitHub under a free license (BSD-like).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As the SynapseGrid operating experience has shown, the library makes it easy to design efficient streaming data processing systems in real time. </font></font></div><p>Source: <a href="https://habr.com/ru/post/204596/">https://habr.com/ru/post/204596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204580/index.html">Update Yandex Disk has led to the inoperability of Windows and programs</a></li>
<li><a href="../204586/index.html">Security error of VKontakte web applications. Rule other applications</a></li>
<li><a href="../204588/index.html">Swiss scientists taught quadrocopter to stay on the fly after losing rotor</a></li>
<li><a href="../204590/index.html">Meet: IntelliJ IDEA 13</a></li>
<li><a href="../204594/index.html">Flat and thin</a></li>
<li><a href="../204598/index.html">Enyo 2. OOP</a></li>
<li><a href="../204600/index.html">Bubble sort and all-all-all</a></li>
<li><a href="../204602/index.html">Looking for a virtual keyboard or ‚ÄúInternet of Things‚Äù at your fingertip</a></li>
<li><a href="../204604/index.html">VmWare patch for linux 3.13</a></li>
<li><a href="../204610/index.html">Backup: success stories or how I survived OCZ Vertex 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>