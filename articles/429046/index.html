<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Four years of development SObjectizer-5.5. How has the SObjectizer changed during this time?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first version of SObjectizer, as part of the 5.5 branch, was released a little more than four years ago - at the beginning of October 2014. And to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Four years of development SObjectizer-5.5. How has the SObjectizer changed during this time?</h1><div class="post__text post__text-html js-mediator-article">  The first version of SObjectizer, as part of the 5.5 branch, was released a little more than four years ago - at the beginning of October 2014.  And today <a href="https://sourceforge.net/p/sobjectizer/news/2018/11/sobjectizer-5523-and-so5extra-120-released/">another version numbered 5.5.23</a> , which, quite possibly, will close the history of the development of SObjectizer-5.5.  In my opinion, this is an excellent reason to look back and see what has been done over the past four years. <br><br>  In this article I will try to thesesize the most important and significant changes and innovations: what was added, why, how did it affect SObjectizer itself or its use. <br><br>  Perhaps someone such a story would be interesting from the point of view of archeology.  And someone may be prevented from such a dubious adventure as developing your own actor framework for C ++;) <br><a name="habracut"></a><br><h1>  A small lyrical digression about the role of old C ++ compilers </h1><br>  The history of SObjectizer-5 began in the middle of 2010.  At the same time, we immediately focused on C ++ 0x.  Already in 2011, the first versions of SObjectizer-5 were used to write production code.  It‚Äôs clear that we didn‚Äôt have compilers with normal C ++ 11 support. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a long time, we could not fully use all the capabilities of the ‚Äúmodern C ++‚Äù: variadic templates, noexcept, constexpr, etc. This could not but affect the API SObjectizer.  And it affected a very, very long time.  Therefore, if while reading the description of a certain feature you have the question ‚ÄúWhy wasn‚Äôt it done before?‚Äù, Then the answer to this question is most likely: ‚ÄúBecause it wasn‚Äôt possible before.‚Äù <br><br><h1>  What has appeared and / or changed in SObjectizer 5.5 since that time? </h1><br>  In this section, we will go through a number of features that have had a significant impact on SObjectizer.  The order in this list is random and not related to the ‚Äúsignificance‚Äù or ‚Äúweight‚Äù of the described features. <br><br><h2>  Waiver of so_5 :: rt namespace </h2><br><h3>  What happened? </h3><br>  Initially, in the fifth SObjectizer, all that pertained to the SObjectizer runtime was defined within the so_5 :: rt namespace.  For example, we had so_5 :: rt :: environment_t, so_5 :: rt :: agent_t, so_5 :: rt :: message_t, etc.  What can be seen, for example, in the traditional HelloWorld example from SO-5.5.0: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::rt::agent_t { public: a_hello_t( so_5::rt::environment_t &amp; env ) : so_5::rt::agent_t( env ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5." &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::rt::environment_t &amp; env ) { env.register_agent_as_coop( "coop", new a_hello_t( env ) ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  The abbreviation ‚Äúrt‚Äù stands for ‚Äúrun-time‚Äù.  And it seemed to us that the entry ‚Äúso_5 :: rt‚Äù is much better and more practical than ‚Äúso_5 :: runtime‚Äù. <br><br>  But it turned out that for many people ‚Äúrt‚Äù is only ‚Äúreal-time‚Äù and nothing else.  And the use of ‚Äúrt‚Äù as an abbreviation for ‚Äúruntime‚Äù disrupts their feelings so much that sometimes the announcements of the SObjectizer versions in RuNet turned into holivars on the subject of the ‚Äúnon-admissibility of the interpretation of‚Äú rt ‚Äùdifferently than‚Äú real-time ‚Äù. <br><br>  In the end, we are tired of it.  And we just closed the namespace "so_5 :: rt". <br><br><h3>  What happened? </h3><br>  Everything that was defined inside ‚Äúso_5 :: rt‚Äù just jumped into ‚Äúso_5‚Äù.  As a result, the same HelloWorld now looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::agent_t { public: a_hello_t( context_t ctx ) : so_5::agent_t( ctx ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5 (" &lt;&lt; SO_5_VERSION &lt;&lt; ")" &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { env.register_agent_as_coop( "coop", env.make_agent&lt;a_hello_t&gt;() ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  But the old names from ‚Äúso_5 :: rt‚Äù are still accessible, through ordinary using-and (typedefs).  So the code written for the first versions of SO-5.5 turns out to be workable in the newer versions of SO-5.5. <br><br>  Finally, the so_5 :: rt namespace will be removed in version 5.6. <br><br><h3>  What impact did it have? </h3><br>  Probably, the code on SObjectizer is now more readable.  Still, ‚Äúso_5 :: send ()‚Äù is perceived better than ‚Äúso_5 :: rt :: send ()‚Äù. <br><br>  Well, we, as the developers of SObjectizer, have a headache diminished.  Around the announcements of SObjectizer at one time there was too much empty talk and unnecessary reasoning (starting from the questions ‚ÄúWhy do we need actors in C ++ in general‚Äù and ending with ‚ÄúWhy do not you use PascalCase for naming entities‚Äù).  One flaming theme became smaller and it was good :) <br><br><h2>  Simplify the sending of messages and the evolution of message handlers </h2><br><h3>  What happened? </h3><br>  Even in the very first versions of SObjectizer-5.5, the sending of a regular message was carried out using the deliver_message method, which had to be called from the recipient's mbox.  To send a deferred or periodic message, it was necessary to call single_timer / schedule_timer on an object of type environment_t.  And already sending a synchronous request to another agent generally required a whole chain of operations.  Here, for example, how it all could look like four years ago (std :: make_unique () is already used here, which was not yet available in C ++ 11): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . mbox-&gt;deliver_message(std::make_unique&lt;my_message&gt;(...)); //   . env.single_timer(std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2)); //   . auto timer_id = env.schedule_timer( std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2), std::chrono::seconds(5)); //         10 . auto reply = mbox-&gt;get_one&lt;std::string&gt;() .wait_for(std::chrono::seconds(10)) .sync_get(std::make_unique&lt;my_message&gt;(...));</span></span></code> </pre><br>  In addition, the format of message handlers in SObjectizer to version 5.5 has evolved.  If initially in SObjectizer-5 all handlers should have the format: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; &amp; cmd)</span></span></span></span>;</code> </pre> <br>  then over time some more were added to the allowed formats: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  Msg --  ,   . ret_value evt_handler(const Msg &amp; msg); ret_value evt_handler(Msg msg); //  ,     . ret_value evt_handler();</span></span></code> </pre><br>  New handler formats have become widely used, because  constantly writing ‚Äúconst so_5 :: event_data_t &lt;Msg&gt; &amp;‚Äù is something else a pleasure.  But, on the other hand, simpler formats were not friendly to template agents.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_To_Process&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_actor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg_To_Process &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Oops! ... } };</span></span></code> </pre> <br>  Such a template agent will only work if Msg_To_Process is a message type, not a signal. <br><br><h3>  What happened? </h3><br>  In the 5.5 branch, the family of send-functions appeared and significantly evolved.  To do this, it was necessary, first, to have at its disposal compilers with support for the variadic templates.  And, secondly, to accumulate sufficient experience, both with variadic templates in general, and with the first versions of send-functions.  Moreover, in different contexts: in ordinary agents, in ad-hoc-agents, and in agents that are implemented by template classes, and outside of agents in general.  Including when using send-functions with mchain (they will be discussed below). <br><br>  In addition to the send functions, the request_future / request_value functions also appeared, which are intended for synchronous interaction between agents. <br><br>  As a result, sending messages now looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . so_5::send&lt;my_message&gt;(mbox, ...); //   . so_5::send_delayed&lt;my_message&gt;(env, mbox, std::chrono::seconds(2), ...); //   . auto timer_id = so_5::send_periodic&lt;my_message&gt;( env, mbox, std::chrono::seconds(2), std::chrono::seconds(5), ...); //         10 . auto reply =so_5::request_value&lt;std::string, my_message&gt;(mbox, std::chrono::seconds(10), ...);</span></span></code> </pre> <br>  Added another possible format for message handlers.  Moreover, it is this format that will be left in the next major releases of SObjectizer as the main one (and, possibly, the only one).  This is the following format: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ret_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; cmd)</span></span></span></span>;</code> </pre> <br>  Where Msg can be both a message type and a signal type. <br><br>  Such a format not only erases the line between agents in the form of ordinary classes and agents in the form of template classes.  But it also makes it easier to send the message / signal (thanks to the send function family): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> my_agent::on_msg(<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;Some_Msg&gt; cmd) { ... <span class="hljs-comment"><span class="hljs-comment">// -  . //       . so_5::send(another_agent, std::move(cmd)); }</span></span></code> </pre> <br><h3>  What impact did it have? </h3><br>  The appearance of send-functions and message handlers that receive mhood_t &lt;Msg&gt; can be said to fundamentally change the code in which messages are sent and processed.  This is exactly the case when it only remains to regret that at the very beginning of work on SObjectizer-5 we did not have any compilers with support for the variadic templates, nor any experience of using them.  The family of send-functions and mhood_t should have been from the very beginning.  But the story turned out the way it did ... <br><br><h2>  Support for custom message types </h2><br><h3>  What happened? </h3><br>  Initially, all sent messages were supposed to be the heir classes of the so_5 :: message_t class.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//  my_message. my_message(...) : ... {...} //   my_message. };</span></span></code> </pre> <br>  While only we ourselves used the fifth SObjectizer, this did not raise any questions.  Well, so and so. <br><br>  But as soon as third-party users began to be interested in SObjectizer, we immediately faced a regularly recurring question: ‚ÄúDo I have to inherit the message from so_5 :: message_t?‚Äù This issue was especially relevant in situations when it was necessary to send objects as messages types that the user could not influence at all.  Let's say a user uses SObjectizer and some other external library.  And in this external library there is some type M whose objects the user would like to send as messages.  Well, how in such conditions to make friends type M and so_5 :: message_t?  Only additional wrappers that the user had to write manually. <br><br><h3>  What happened? </h3><br>  We added the ability to send messages to SObjectizer-5.5, even if the message type is not inherited from so_5 :: message_t.  Those.  Now the user can easily write: <br><br><pre> <code class="cpp hljs">so_5::send&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mbox, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>);</code> </pre> <br>  So_5 :: message_t still remains under the hood, send () simply understands that std :: string is not inherited from so_5 :: message_t and inside not a simple std :: string, but a special inheritor from so_5 :: message_t, inside of which the user std :: string is already located. <br><br>  Similar template magic is applied when subscribing.  When the SObjectizer sees a message handler of the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> <br>  then SObjectizer understands that a special message will actually come with a std :: string object inside.  And what you need to call the handler with the transfer to it of a link to std :: string from this special message. <br><br><h3>  What impact did it have? </h3><br>  Using SObjectizer has become easier, especially when you need to send not only objects of your own types as messages, but also objects of types from external libraries.  Several people even took the time to say a special thank you for this feature. <br><br><h2>  Mutable messages </h2><br><h3>  What happened? </h3><br>  Initially, only the 1: N interaction model was used in SObjectizer-5.  Those.  A sent message could have more than one recipient (and there could be more than one).  Even if the agents needed to interact in 1: 1 mode, they still communicated through a multi-producer / multi-consumer mailbox.  Those.  in 1: N mode, just N in this case was strictly one. <br><br>  In circumstances where a message can be received by more than one recipient agent, the sent messages must be immutable.  That is why message handlers had the following formats: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . ret_type evt_handler(const event_data_t&lt;Msg&gt; &amp; cmd); //       . ret_type evt_handler(const Msg &amp; msg); //    . //        . ret_type evt_handler(Msg msg);</span></span></code> </pre> <br>  In general, a simple and understandable approach.  However, it is not very convenient when agents need to communicate with each other in 1: 1 mode and, for example, transfer ownership of some data to each other.  Let's say that such a simple message cannot be made if all messages are strictly immutable objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process_image</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image_; process_image(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image) : image_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image)) {} };</code> </pre> <br>  More precisely, it would be possible to send such a message.  But having received it as a constant object, removing the contents of process_image :: image_ to yourself just wouldn't work.  I would have to mark such an attribute as mutable.  But then we would lose control of the compiler in the case when the process_image for some reason is sent in 1: N mode. <br><br><h3>  What happened? </h3><br>  In SObjectizer 5.5, the ability to send and receive mutable messages was added.  In this case, the user must in a special way mark the message both when sending and subscribing to it. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    . so_5::send&lt;my_message&gt;(mbox, ...); //     my_message. so_5::send&lt;so_5::mutable_msg&lt;my_message&gt;&gt;(mbox, ...); ... //     . void my_agent::on_some_event(mhood_t&lt;my_message&gt; cmd) {...} //      my_message. void my_agent::on_another_event(mhood_t&lt;so_5::mutable_msg&lt;my_message&gt;&gt; cmd) {...}</span></span></code> </pre><br>  For SObjectizer, my_message and mutable_msg &lt;my_message&gt; are two different types of messages. <br><br>  When the send function sees that it is asked to send a mutable message, the send function checks and in which mailbox they are trying to send the message.  If this is a multi-consumer box, then sending is not performed, and an exception is thrown with the corresponding error code.  Those.  SObjectizer guarantees that a mutable message can only be used when interacting in 1: 1 mode (via single-consumer boxes or mchains, which are a type of single-consumer boxes).  To ensure this guarantee, by the way, SObjectizer prohibits sending mutable messages in the form of periodic messages. <br><br><h3>  What impact did it have? </h3><br>  With mutable messages it turned out unexpectedly.  We added them to SObjectizer as a result of the discussion on the sidelines of a <a href="https://www.youtube.com/watch%3Fv%3D9fWDTbXnWaw">report on SObjectizer in C ++ Russia-2017</a> .  With the feeling of ‚Äúwell, just asking, it means someone needs, so it‚Äôs worth a try.‚Äù  Well, did without much hope for widespread demand.  Although it took a very long time to ‚Äúsmoke bamboo‚Äù before it came up with how to add mutable messages to SO-5.5 without breaking compatibility. <br><br>  But when the mutable messages appeared in SObjectizer, it turned out that there were not so many applications for them.  And that mutable messages are used surprisingly often (references to this can be found <a href="https://habr.com/post/417527/">in the second part of the story about the Shrimp demo project</a> ).  So, in practice, this feature turned out to be more than useful, since  it allows you to solve problems that, without the support of mutable messages at the SObjectizer level, did not have a normal solution. <br><br><h2>  Agents in the form of hierarchical finite automata </h2><br><h3>  What happened? </h3><br>  The agents in SObjectizer were originally state machines.  Agents had to explicitly describe states and make subscriptions to messages in specific states. <br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"free"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_bufy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"busy"</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     st_free. so_subscribe(mbox).in(st_free).event(...); //     st_busy. so_subscribe(mbox).in(st_busy).event(...); ... } };</span></span></code> </pre> <br>  But they were simple finite automata.  States could not be nested in each other.  There was no support for entry and exit exit handlers.  There were no restrictions on the time spent in the state. <br><br>  Even such limited support for state machines was convenient and we used it for years.  But at one point, we wanted more. <br><br><h3>  What happened? </h3><br>  SObjectizer adds support for hierarchical finite automata. <br><br>  Now states can be nested into each other.  Event handlers from parent states are automatically ‚Äúinherited‚Äù by child states. <br><br>  Handlers for entering and exiting state are supported. <br><br>  It is possible to set a limit on the time the agent is in the state. <br><br>  It is possible to store history for the state. <br><br>  In order not to be unfounded, here is an example of an agent that is not a complex hierarchical state machine (the code from the standard example of blinking_led): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  All this we have already described <a href="https://habr.com/post/423497/">in a separate article</a> , there is no need to repeat. <br><br>  There is currently no support for orthogonal states.  But this fact has two explanations.  First, we tried to make this support and faced a number of difficulties, overcoming of which seemed too costly to us.  And, secondly, no one has asked for orthogonal states yet.  When asked, then back to this topic. <br><br><h3>  What impact did it have? </h3><br>  There is a feeling that is very serious (although we are, of course, subjective and biased).  Indeed, it is one thing when, when confronted with complex finite automata in the domain, you begin to look for workarounds, to simplify something, to spend extra forces on something.  And it is quite another thing when you can display objects from your applied task into your C ++ code almost 1-in-1. <br><br>  In addition, judging by the questions that are asked, for example, the behavior of input / output handlers to / from the state, this functionality is used. <br><br><h2>  mchains </h2><br><h3>  What happened? </h3><br>  There was an interesting situation.  SObjectizer was often used in such a way that only part of the application was written in SObjectizer.  The rest of the code in the application could have nothing to do with the actors in general, nor with SObjectizer in particular.  For example, a GUI application in which the SObjectizer is used for some background tasks, while the main work is performed on the main application thread. <br><br>  And in such cases, it turned out that from the non-SObjectizer parts into the SObjectizer parts, sending information is easier than ever: it is enough to call ordinary send functions.  But with the dissemination of information in the opposite direction is not so simple.  It seemed to us that this is not good and that we should have some convenient channels of communication between SObjectizer parts of the application and non-SObjectizer parts right out of the box. <br><br><h3>  What happened? </h3><br>  So in SObjectizer appeared message chains or, in more familiar notation, mchains. <br><br>  Mchain is such a specific version of a single-consumer mailbox to which messages are sent by ordinary send functions.  But to extract messages from mchain, you do not need to create agents and sign them.  There are two special functions that can be called even inside agents, even outside agents: receive () and select ().  The first reads messages from only one channel, while the second can read messages from several channels at once: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); select( from_all().handle_n(<span class="hljs-number"><span class="hljs-number">3</span></span>).empty_timeout(<span class="hljs-number"><span class="hljs-number">200</span></span>ms), case_(ch1, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;first_message_type&gt; msg) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;second_message_type&gt; msg) { ... }), case_(ch2, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;third_message_type&gt; msg ) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_signal_type&gt;){...}, ... ));</code> </pre> <br>  We have already told about mchains here several times: <a href="https://habr.com/post/336854/">in August 2017</a> and <a href="https://habr.com/post/358120/">in May 2018</a> .  Therefore, we will not dwell on the topic of how the work with mchains looks. <br><br><h3>  What impact did it have? </h3><br>  After the appearance of mchains in SObjectizer-5.5, it turned out that SObjectizer, in fact, became an even less ‚Äúactor‚Äù framework than it was before.  To support Actor Model and Pub / Sub, SObjectizer also added support for communicating sequential processes (CSP).  Mchains allow developing quite complex multi-threaded applications on the SObjectizer without actors at all.  And for some tasks it is more than convenient.  What we ourselves use from time to time. <br><br><h2>  Message limits mechanism </h2><br><h3>  What happened? </h3><br>  One of the most serious shortcomings of the Model Actors is a predisposition to the occurrence of overloads.  It is very easy to be in a situation where the sending actor sends messages to the receiving actor at a higher rate than the receiving actor can process messages. <br><br>  As a rule, sending messages in actor frameworks is a non-blocking operation.  Therefore, in the event of the ‚Äúsmart-producer and brake-consumer‚Äù pair, the queue of the recipient actor will increase while there remains at least some free memory. <br><br>  The main difficulty of this problem is that a good overload protection mechanism should be tailored to the application and features of the subject area.  For example, to understand which messages can be duplicated (and, therefore, be able to safely discard duplicates).  To understand which messages cannot be thrown away in any way.  Who can stop and how much, and who generally can not.  Etc. <br><br>  Another difficulty is that it is not always necessary to have a good defense mechanism.  At times, it is enough to have something primitive, but effective, available out of the box and easy to use.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In order not to force the user to do his overload control where it is enough just to throw out the ‚Äúextra‚Äù messages or to send these messages to some other agent. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to use ready-made overload protection tools in simple scenarios, so-called were added to SObjectizer-5.5. </font><font style="vertical-align: inherit;">message limits. </font><font style="vertical-align: inherit;">This mechanism allows you to discard unnecessary messages, or forward them to other recipients, or even just to interrupt the application if the limits are exceeded.</font></font> For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: worker(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx <span class="hljs-comment"><span class="hljs-comment">//     100  handle_data, //      //  . + limit_then_redirect&lt;handle_data&gt;(100, [this]{ return another_worker_;}) //     1  check_status, //       . + limit_then_drop&lt;check_status&gt;(1) //     1  reconfigure, //     , ..  reconfigure //        . + limit_then_abore&lt;reconfigure&gt;(1) } {...} ... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In more detail, this topic is disclosed </font></font><a href="https://habr.com/post/310818/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a separate article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What impact did it have? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is not to say that the emergence of message limits has become something that drastically changed SObjectizer, its principles of operation, or work with it. </font><font style="vertical-align: inherit;">Rather, it can be compared with a reserve parachute, which is used only as a last resort. </font><font style="vertical-align: inherit;">But when you have to use it, you are glad that it exists at all.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Message delivery tracing mechanism </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 was a ‚Äúblack box‚Äù for developers. In which the message is sent and ... And it either comes to the recipient, or does not come. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the message does not reach the recipient, the user is faced with the need to go through an exciting quest in search of the cause. In most cases, the reasons are trivial: either the message was sent to the wrong mbox, or no subscription was made (for example, the user made a subscription in one agent state, but forgot to make it in another). But there may be more complex cases where the message is, say, rejected by the overload protection mechanism.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem was that the message delivery mechanism was hidden deep inside the SObjectizer Run-Time and, therefore, it was difficult to even forward the message delivery process to the SObjectizer developers, let alone the users. </font><font style="vertical-align: inherit;">Especially about novice users who have made the greatest number of such trivial errors.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In SObjectizer-5.5, a special mechanism for tracing the message delivery process has been added, called message delivery tracing (or simply msg_tracing). </font><font style="vertical-align: inherit;">This mechanism and its capabilities were described in more detail in a </font></font><a href="https://habr.com/post/352176/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separate article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So now, if messages are lost during delivery, you can simply turn on msg_tracing and see why this happens.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What impact did it have? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugging applications written in SObjectizer has become much simpler and more enjoyable. </font><font style="vertical-align: inherit;">Even </font></font><a href="http://eao197.blogspot.com/2018/04/progc-msgtracing.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for ourselves</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The concept of env_infrastructure and single-threaded env_infrastructures </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have always considered SObjectizer as a tool to simplify the development of multi-threaded code. </font><font style="vertical-align: inherit;">Therefore, the first versions of SObjectizer-5 were written to work only in a multithreaded environment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This was expressed as the use of synchronization primitives inside SObjectizer to protect the internals of SObjectizer when working in a multi-threaded environment. </font><font style="vertical-align: inherit;">This is also the case for creating several auxiliary work threads inside SObjectizer itself (for performing such important operations as timer maintenance and completion of deregistration of agent cooperations).</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer was created for multi-threaded programming and for use in a multi-threaded environment. </font><font style="vertical-align: inherit;">And it quite suited us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, as SObjectizer was used ‚Äúin the wild‚Äù, situations were discovered where the task was difficult enough for the actors to be used in its solution. </font><font style="vertical-align: inherit;">But, at the same time, all the work is possible and, moreover, it was necessary to do it on one single work flow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we faced a very interesting problem: is it possible to teach SObjectizer to work on a single working thread?</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out that you can. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It cost us dearly, it took a lot of time and effort to come up with a solution. </font><font style="vertical-align: inherit;">But the decision was invented. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A concept such as environment infrastructure (or env_infrastructure in a slightly abbreviated form) was introduced. </font><font style="vertical-align: inherit;">Env_infrastructure took over the task of managing the internal kitchen of SObjectizer. </font><font style="vertical-align: inherit;">In particular, he solved such issues as servicing timers, performing registration operations and deregistration of cooperatives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For SObjectizer, several single-threaded env_infrastructures options were made. </font><font style="vertical-align: inherit;">This made it possible to develop single-threaded applications on SObjectizer, within which there are normal agents that exchange normal messages with each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked more about this functionality </font></font><a href="https://habr.com/post/328872/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a separate article.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What impact did it have? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the most important thing that happened during the implementation of this feature is the breaking of our own templates. </font><font style="vertical-align: inherit;">A look at the SObjectizer will never be the same. </font><font style="vertical-align: inherit;">So many years, consider SObjectizer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exclusively</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as a tool for developing multi-threaded code. </font><font style="vertical-align: inherit;">And then again! </font><font style="vertical-align: inherit;">And to find out that single-threaded code in SObjectizer can also be developed. </font><font style="vertical-align: inherit;">Life is full of surprises.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run-time monitoring tools </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 was not just a black box for the message delivery mechanism. </font><font style="vertical-align: inherit;">But there were also no means to find out how many agents are currently working inside the application, how many and which dispatchers are created, how many working threads they have involved, how many messages are waiting in dispatchers queues, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this information is very useful for monitoring applications running 24/7. </font><font style="vertical-align: inherit;">But also for debugging, at times I would also like to understand whether queues are growing or whether the number of agents is increasing or decreasing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, for the time being, the time we simply didn‚Äôt reach to add to SObjectizer the means for collecting and disseminating such information.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happened? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At one point </font></font><a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Run-Time%2520Monitoring/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tools for run-time monitoring of SObjectizer‚Äôs internals appeared in SObjectizer-5.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">By default, run-time monitoring is disabled, but if it is enabled, then messages will be sent to a special mbox regularly, inside of which there will be information about the number of agents and cooperations, the number of timers, working threads owned by dispatchers (and there will already be information about the number of messages in the queues, the number of agents attached to these threads). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus, over time, it became possible to additionally include the collection of information about how much time agents spend inside event handlers. </font><font style="vertical-align: inherit;">This makes it possible to detect situations when an agent is too slow (or spends time on blocking calls).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What impact did it have? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our practice, run-time monitoring is not often used. </font><font style="vertical-align: inherit;">But when it is needed, then you realize its importance. </font><font style="vertical-align: inherit;">Indeed, without such a mechanism, it is sometimes impossible (well, or very difficult) to deal with what and how [does] work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So this is a feature from the "can and do" category, but its presence, in our opinion, immediately translates the instrument into another weight category.</font></font> Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">making a prototype of an actor framework ‚Äúon the knee‚Äù is not so difficult. </font><font style="vertical-align: inherit;">Many have done this and many more will do it. </font><font style="vertical-align: inherit;">But then provide your development with such a thing as run-time monitoring ... Not all knee drafts survive to this.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And one more thing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For four years, many innovations and changes have been found in SObjectizer-5.5, the description of which, even in brief form, will take too much space. Therefore, we denote part of them literally by one line. In random order, without any priorities. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Support for the CMake build system has been added to SObjectizer 5.5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now SObjectizer-5 can be built both as a dynamic and as a static library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.5 is now built and running under Android (both through the </font></font><a href="https://www.crystax.net/android/ndk"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrystaX NDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and through the latest Android NDK). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There were private dispatchers. Now you can create and use dispatchers that no one but you can see.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The delivery filters mechanism has been implemented. Now, when subscribing to messages from MPMC-mboxes, you can prohibit the delivery of messages whose content you are not interested in. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The means of creating and registering cooperations are significantly simplified: introduce_coop / introduce_child_coop, make_agent / make_agent_with_binder methods and that's it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The concept of the factory of lock-objects appeared and now you can choose which lock-objects you need (based on mutex, spinlock, combined or some other). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The wrapped_env_t class has appeared and now you can launch SObjectizer in your application not only with so_5 :: launch ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The concept of stop_guard has appeared and now it is possible to influence the process of finishing the work of SObjectizer. </font><font style="vertical-align: inherit;">For example, you can prohibit SObjectizer from stopping until some agents have completed their applied work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it is possible to intercept messages that were delivered to the agent, but were not processed by the agent (the so-called dead_letter_handlers). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can wrap messages in special "envelopes". </font><font style="vertical-align: inherit;">Envelopes may carry additional information about the message and may perform some action when the message is delivered to the recipient.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From 5.5.0 to 5.5.23 in numbers </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also interesting to look at the progress made in terms of the amount of code / tests / examples. </font><font style="vertical-align: inherit;">Here is what the cloc utility tells us about the amount of SObjectizer-5.5.0 kernel code:</font></font><br><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 58 2119 5156 5762</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 39 1167 779 4759</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 2 30 2 75</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 99 3316 5937 10596</font></font><font></font>
 -------------------------------------------------- -----------------------------
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And here is the same, but for v.5.5.23 (of which 1147 lines are optional-lite library code): </font></font><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 133 6279 22173 21068</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 53 2498 2760 10398</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 2 29 0 177</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 4 53 2 129</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 192 8859 24935 31772</font></font><font></font>
 -------------------------------------------------- -----------------------------
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The volume of tests for v.5.5.0: </font></font><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 84 2510 390 11540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 162 496 0 1054</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 1 11 0 32</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 247 3017 390 12626</font></font><font></font>
 -------------------------------------------------- -----------------------------
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tests for v.5.5.23: </font></font><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 324 7345 1305 35231</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 675 2353 0 4671</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 338 43 0 955</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 11 107 3 448</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 1348 9848 1308 41305</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, the examples for v.5.5.0: </font></font><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 27 765 463 3322</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 28 95 0 192</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 55,860,463,314</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> They are the same, but for v.5.5.23: </font></font><br><pre>  -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Language files blank comment code</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 67 2141 2061 9341</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 133 451 0 868</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 67 93 0 595</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 1 12 11 32</font></font><font></font>
 -------------------------------------------------- -----------------------------<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 268 2697 2072 10836</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost everywhere, an increase of almost three times. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the amount of documentation for SObjectizer has probably increased even more.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plans for the near (and not only) future </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The preliminary development plans for SObjectizer after the release of version 5.5.23 were described </font></font><a href="https://eao197.blogspot.com/2018/10/progthoughts-sobjectizer-201810.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about a month ago. Basically, they have not changed. But there was a feeling that version 5.6.0, the release of which is scheduled for the beginning of 2019, will need to be positioned as the beginning of the next stable branch of SObjectizer. With an eye to the fact that in the course of 2019, the SObjectizer will develop within the framework of the 5.6 branch without any significant breaking changes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will enable those who are currently using SO-5.5 in their projects to gradually switch to SO-5.6 without fear that they will have to switch to SO-5.7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The version 5.7, in which we want to allow ourselves to deviate somewhere from the basic principles of SO-5.5 and SO-5.6, in the 2019th year will be considered as experimental. </font><font style="vertical-align: inherit;">With stabilization and release, if all goes well, already in the 2020th year.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to thank everyone who helped us with the development of SObjectizer all this time. </font><font style="vertical-align: inherit;">And separately I want to say thanks to all those who dared to try to work with SObjectizer. </font><font style="vertical-align: inherit;">Your feedback has always been very useful to us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To those who have not yet used SObjectizer, we want to say: try. </font><font style="vertical-align: inherit;">This is not as scary as it may seem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you didn‚Äôt like something or didn‚Äôt have enough in SObjectizer - tell us. </font><font style="vertical-align: inherit;">We always listen to constructive criticism. </font><font style="vertical-align: inherit;">And, if it is in our power, we embody the wishes of users in life.</font></font></div><p>Source: <a href="https://habr.com/ru/post/429046/">https://habr.com/ru/post/429046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429036/index.html">Trust Me, I know what I'm doing: independent adaptation of the modular robot to the task environment</a></li>
<li><a href="../429038/index.html">Rust News # 2 (October 2018)</a></li>
<li><a href="../429040/index.html">Patching Java code in production without anesthesia</a></li>
<li><a href="../429042/index.html">We test SharxBase, a hardware-software virtualization platform from the Russian vendor SharxDC</a></li>
<li><a href="../429044/index.html">Apple shares have experienced the strongest fall since 2014. Large investors have lost billions</a></li>
<li><a href="../429048/index.html">Tips for a novice hoster</a></li>
<li><a href="../429050/index.html">Attack to the cryptocurrency exchange Gate.io is fixed</a></li>
<li><a href="../429052/index.html">Why some SPAs have stopped supporting touch events on touch laptops</a></li>
<li><a href="../429054/index.html">"Find N Differences." Experience testing layout Tinkoff.ru</a></li>
<li><a href="../429056/index.html">Physics, not biology, makes aging inevitable.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>