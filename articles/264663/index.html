<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redirecting data from the COM port to the Web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently on Habr√© there was an article "Displaying data from Serial in Chrome Application" about how beautifully to present the data sent by Arduin-ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Redirecting data from the COM port to the Web</h1><div class="post__text post__text-html js-mediator-article">  Recently on Habr√© there was an article <a href="http://habrahabr.ru/company/amperka/blog/263505/">"Displaying data from Serial in Chrome Application"</a> about how beautifully to present the data sent by Arduin-koy to Serial.  In my opinion, the guys offered a very beautiful solution, which on the one hand looks quite simple, and on the other allows you to get a great result with a minimum of effort. <br><br>  In the comments to the article, it was regretted that such a solution would not work under Firefox, and the idea was expressed that "you can still write a simple web server with html output based on this thing."  This idea ‚Äúhooked‚Äù me, I didn‚Äôt give out a quick search in google, and I decided to implement the idea myself.  And that's what came of it. <br><br>  <i>A warning!</i>  <i>In no case can the proposed solution be regarded as complete.</i>  <i>Unlike Amperka‚Äôs Serial Projector, this is a concept, a demonstration of a possible approach, a working prototype and nothing more.</i> <br><a name="habracut"></a><br>  Some time ago I did a project in which I used accelerometers built into the Android-smartphone to control the servers connected to the Arduino.  Then for these purposes I used the <a href="https://github.com/damonkohler/sl4a">Scripting Layer for Android (SL4A)</a> and <a href="https://github.com/Jonty/RemoteSensors">RemoteSensors</a> projects.  It turns out that the standard library python includes the <a href="httpserver.html">BaseHTTPServer</a> package, with which it is <a href="httpserver.html">possible</a> to raise a web service in python - this is a task for a couple of lines of code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There were no sensors for the Arduino at hand, so I used the internal thermometer built into the Arduino Uno as the source of the displayed information.  As far as I understand, it is not very accurate and is not intended to measure the ambient temperature at all, but it will completely come down for prototyping. <br><br>  After a brief googling, this sketch for arduinka appeared: <br><br><pre><code class="hljs pgsql">// source: https://code.google.com/p/tinkerit/wiki/SecretThermometer long readTemp() { long result; // <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> temperature sensor against <span class="hljs-number"><span class="hljs-number">1.1</span></span>V reference ADMUX = _BV(REFS1) | _BV(REFS0) | _BV(MUX3); delay(<span class="hljs-number"><span class="hljs-number">2</span></span>); // Wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vref <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> settle ADCSRA |= _BV(ADSC); // Convert <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bit_is_set(ADCSRA,ADSC)); result = ADCL; result |= ADCH&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; result = (result - <span class="hljs-number"><span class="hljs-number">125</span></span>) * <span class="hljs-number"><span class="hljs-number">1075</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); } <span class="hljs-type"><span class="hljs-type">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { String s = String(count++, <span class="hljs-type"><span class="hljs-type">DEC</span></span>) + ": " + String( readTemp(), <span class="hljs-type"><span class="hljs-type">DEC</span></span> ); <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println(s) delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre> <br>  This sketch opens the COM port, adjusts it to the speed of 115200 baud, and then every second writes the current value of the built-in thermometer to it.  (Do not ask me in what units the temperature is given - for the described task it is not important).  Since the value does not change very actively, a line number is displayed before the temperature for better visibility of data changes. <br><br>  To check that the web server will only send out whole lines, not parts of them, as they are read from the COM port, <br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(s)</code> </pre><br>  was replaced by <br><pre> <code class="hljs matlab"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; s.<span class="hljs-built_in"><span class="hljs-built_in">length</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ ){ Serial.print( s.charAt(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) ); delay( <span class="hljs-number"><span class="hljs-number">200</span></span> ); } Serial.println(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  those.  the generated string is not output to the serial port entirely, but character by character, with pauses of 200 ms. <br><br>  To begin with, a very simple prototype of a web server was written (it is analyzed below in parts): <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- #-- based on: https://raw.githubusercontent.com/Jonty/RemoteSensors/master/remoteSensors.py SERIAL_PORT_NAME = 'COM6' SERIAL_PORT_SPEED = 115200 WEB_SERVER_PORT = 8000 import time, BaseHTTPServer, urlparse import serial ser = None def main(): global ser httpd = BaseHTTPServer.HTTPServer(("", WEB_SERVER_PORT), Handler) #-- workaround for getting IP address at which serving import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect(('google.co.uk', 80)) sData = s.getsockname() print "Serving at '%s:%s'" % (sData[0], WEB_SERVER_PORT) ser = serial.Serial(SERIAL_PORT_NAME, SERIAL_PORT_SPEED, timeout=0) httpd.serve_forever() class Handler(BaseHTTPServer.BaseHTTPRequestHandler): # Disable logging DNS lookups def address_string(self): return str(self.client_address[0]) def do_GET(self): self.send_response(200) self.send_header("Content-type", "application/x-javascript; charset=utf-8") self.end_headers() try: while True: new_serial_line = get_full_line_from_serial() if new_serial_line is not None: self.wfile.write(new_serial_line) self.wfile.write("\n") self.wfile.flush() except socket.error, e: print "Client disconnected.\n" captured = '' def get_full_line_from_serial(): """ returns full line from serial or None Uses global variables 'ser' and 'captured' """ global captured part = ser.readline() if part: captured += part parts = captured.split('\n', 1); if len(parts) == 2: captured = parts[1] return parts[0] return None if __name__ == '__main__': main()</span></span></code> </pre><br>  Let's sort the script in parts. <br><br>  Since this is a prototype, all the basic operation parameters (the name of the COM port, its speed, and the number of the TCP port on which the web server will work) are indicated directly in the source text: <br><pre> <code class="python hljs">SERIAL_PORT_NAME = <span class="hljs-string"><span class="hljs-string">'COM6'</span></span> SERIAL_PORT_SPEED = <span class="hljs-number"><span class="hljs-number">115200</span></span> WEB_SERVER_PORT = <span class="hljs-number"><span class="hljs-number">8000</span></span></code> </pre><br>  Of course, you can organize the reading of these parameters from the command line.  For example, using the argparse module, this is done very quickly, simply and flexibly. <br><br>  In this case, Windows users need to find out the name of the COM port to which Arduin is connected in Device Manager.  I had it 'COM6'.  Users of other OSes should use the tools of their OS.  I have absolutely no experience with MacOS and in Linux I didn‚Äôt work with COM ports either, but most likely it will be something like "/ dev / ttySn". <br><br>  Next comes the definition of a global variable to which an instance of the Serial class that is responsible for working with the COM port in python will be associated: <br><pre> <code class="python hljs">ser = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br>  In line <br><pre> <code class="python hljs">httpd = BaseHTTPServer.HTTPServer((<span class="hljs-string"><span class="hljs-string">""</span></span>, WEB_SERVER_PORT), Handler)</code> </pre><br>  a web server is created that will listen for requests on the specified WEB_SERVER_PORT port.  And an instance of the Handler class, described below, will process these requests. <br><br>  The following lines are a small ‚Äúhack‚Äù that allows you to display the IP address on which the running web server actually runs: <br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#-- workaround for getting IP address at which serving import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect(('google.co.uk', 80)) sData = s.getsockname() print "Serving at '%s:%s'" % (sData[0], WEB_SERVER_PORT)</span></span></code> </pre><br>  As I understand it, there is no other way to find out this IP.  And how, without this knowledge, we will access our server from a browser? <br><br>  Therefore, you have to open a socket and connect to the Google site in order to extract information about your own IP address from the attributes of this socket. <br><br>  Just below the opening of the COM port and the actual launch of the web server: <br><pre> <code class="python hljs"> ser = serial.Serial(SERIAL_PORT_NAME, SERIAL_PORT_SPEED, timeout=<span class="hljs-number"><span class="hljs-number">0</span></span>) httpd.serve_forever()</code> </pre><br>  Then follows the description of the class that is responsible for processing the requests received by the launched web server: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseHTTPServer.BaseHTTPRequestHandler)</span></span></span><span class="hljs-class">:</span></span></code> </pre><br>  This is a descendant of the class built into the BaseHTTPServer module, in which it is enough to override only the do_GET method <br><br>  Since this is still a prototype, the server will be ‚Äúhappy‚Äù to any request - whatever URL it is requested from, it will give the client all the data read from the COM port.  Therefore, in Handler.do_GET, it immediately responds with a success code and the necessary headers: <br><pre> <code class="python hljs"> self.send_response(<span class="hljs-number"><span class="hljs-number">200</span></span>) self.send_header(<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/x-javascript; charset=utf-8"</span></span>) self.end_headers()</code> </pre><br>  after which an infinite loop starts, in which an attempt is made to read a whole line from the COM port and, if this attempt was successful, transfer it to the web client: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_serial_line = get_full_line_from_serial() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_serial_line <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.wfile.write(new_serial_line) self.wfile.write(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) self.wfile.flush()</code> </pre><br>  In the project, which was taken as a basis, this infinite cycle was wrapped in a try‚Ä¶ except block, with which it was supposed to carefully handle the disconnection of the connection.  Perhaps, in Android (the base project was developed for it), this works fine, but it didn‚Äôt work for me under Windows XP - when I disconnected, there was some other exception that I didn‚Äôt learn to intercept.  But, fortunately, this did not prevent the web server from operating normally and accepting the following requests. <br><br>  The function of receiving a whole string from a COM port works on the same principle as the creators of the Serial Projector: <br><ul><li>  there is some global buffer in which everything that is read from the COM port is stored </li><li>  each time the function is accessed, it tries to read something from the COM port. </li><li>  if she succeeds, then <br><ul><li>  it adds just read to the specified global buffer </li><li>  tries to divide the global buffer into at most two parts with a line terminator </li><li>  if it succeeds in this, then it returns the first part to the calling procedure, and uses the second part as the new value of the global buffer </li></ul><br></li><li>  if there is no new data in the COM port or the end of line character is not found, the function returns None: </li></ul><br><pre> <code class="python hljs">captured = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_full_line_from_serial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" returns full line from serial or None Uses global variables 'ser' and 'captured' """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> captured part = ser.readline() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> part: captured += part parts = captured.split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(parts) == <span class="hljs-number"><span class="hljs-number">2</span></span>: captured = parts[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parts[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br>  The result is: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/b6_8YW4e9zE%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhgoJ8pwRgYFe2-AulHqP2R_hOpDow" frameborder="0" allowfullscreen=""></iframe><br><br>  It can be seen that the lines read from the COM port appear in the browser.  I do not understand anything in the web front end: JavaScript, Ajax, CSS and DOM are for me a dark forest.  But it seems to me that for programmers creating web interfaces this should be quite enough to convert this output into the same beautiful picture that Amperka‚Äôs Serial Projector produces.  In my opinion, the task is to create a javascript script that accesses the web server, reads the stream from it and displays the last read line in the right place on the web page. <br><br>  Just in case, I decided to play it safe and tried to make the first approach on my own.  Not very deep search in Google prompted that generally for such purposes, at least, used WebSockets or Server-Sent Events earlier.  I found, it seemed to me, a good <a href="http://www.html5rocks.com/en/tutorials/eventsource/basics">tutorial</a> on using Server-Sent Events and decided to use this technology. <br><br>  <i>Note!</i>  <i>It seems that this is not the best solution, because this technology did not work either in Internet Explorer 8, or in the browser built into Android 2.3.5.</i>  <i>But it worked at least in Firefox 39.0, so I did not ‚Äúdig‚Äù further.</i> <br><br>  After reading this textbook, as well as another one <a href="http://webonrails.ru/post/398545752424454925/">in Russian</a> , I took the <a href="https://simpl.info/eventsource/">simpl.info/eventsource</a> project as a <a href="https://simpl.info/eventsource/">basis</a> . <br><br>  From the point of view of the Python script, the changes for Server-Sent Events are quite minor: <br><ul><li>  It is necessary to replace the type of data given to the client: <br>  line <br><pre> <code class="python hljs"> self.send_header(<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/x-javascript; charset=utf-8"</span></span>)</code> </pre><br>  replaced by <br><pre> <code class="python hljs"> self.send_header(<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/event-stream"</span></span>)</code> </pre><br></li><li>  as well as before the line read from the COM port, insert the ‚Äúdata:‚Äù prefix and add another newline character: <br>  lines <br><pre> <code class="python hljs"> self.wfile.write(new_serial_line) self.wfile.write(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre><br>  replaced by <br><pre> <code class="python hljs"> self.wfile.write(<span class="hljs-string"><span class="hljs-string">'data: '</span></span> + new_serial_line) self.wfile.write(<span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>)</code> </pre><br></li></ul><br><br>  Everything else could probably remain unchanged, but ... <br><br>  First, I created an index.html file with this content: <br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> dataDiv = </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">document</span></span></span><span class="javascript">.querySelector(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'#data'</span></span></span><span class="javascript">); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> source = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> EventSource(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'http://192.168.1.207:8000/'</span></span></span><span class="javascript">) source.onmessage = </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">e</span></span></span></span><span class="javascript"><span class="hljs-function">) </span></span></span><span class="javascript">{ dataDiv.innerHTML = e.data; }; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The most interesting in it is a string <br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  which forms a place to output the next line from the COM port, and a javascript script <br><pre> <code class="javascript hljs"> &lt;script&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#data'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventSource(<span class="hljs-string"><span class="hljs-string">'http://192.168.1.207:8000/'</span></span>) source.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ dataDiv.innerHTML = e.data; }; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  which is actually engaged in reading the stream from the web server and outputting the read information to the specified location. <br><br>  I assumed to open this file in a browser, for example, from a disk or from some other web server, but this did not work: when opening a page from disk, the javascript script once turned to the running Python web server and immediately disconnected.  I did not understand why this was happening, and suggested that this might be some kind of browser protection against various attacks.  He probably does not like the fact that the page itself is open from one source, and the script reads data from another source. <br><br>  Therefore, it was decided to change the Python web server so that it gives this html page.  Then it would happen that both the page and the stream are read from the same source.  I do not know whether my assumption about security turned out to be true, or something else, but with this implementation everything worked as it should. <br><br>  Of course, you only need to change the Handler class request handler: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseHTTPServer.BaseHTTPRequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Disable logging DNS lookups def address_string(self): return str(self.client_address[0]) def do_GET(self): if self.path == '/' or self.path == '/index.html': self.process_index() elif self.path == '/get_serial': self.process_get_serial() else: self.process_unknown() def process_index(self): self.send_response(200) self.send_header("Content-type", "text/html; charset=utf-8") self.end_headers() self.wfile.write(open('index.html').read()) self.wfile.write("\n\n") self.wfile.flush() def process_get_serial(self): self.send_response(200) self.send_header("Content-type", "text/event-stream") self.end_headers() try: while True: new_serial_line = get_full_line_from_serial() if new_serial_line is not None: self.wfile.write('data: ' + new_serial_line) self.wfile.write("\n\n") self.wfile.flush() except socket.error, e: print "Client disconnected.\n" def process_unknown(self): self.send_response(404)</span></span></code> </pre><br>  In this variant, it is assumed that the web server will respond only to two requests: '/index.html' (giving the page's html-code) and '/ get_serial' (giving up an endless stream of lines read from the COM port).  It will respond to all other requests with the code 404. <br><br>  Since index.html is given to the Python web server, it can be slightly changed by specifying a relative address instead of the absolute address of the stream of lines from the COM port: <br>  the string <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventSource(<span class="hljs-string"><span class="hljs-string">'http://192.168.1.207:8000/'</span></span>)</code> </pre><br>  replaced by <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventSource(<span class="hljs-string"><span class="hljs-string">'/get_serial'</span></span>)</code> </pre><br>  The result was this: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/C0ffOHTN8sU%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhix9OQFMtgPpuAR1LIj_9_9H1rHyw" frameborder="0" allowfullscreen=""></iframe><br><br>  On this I decided to stop.  It seems to me that it is beautiful to design a page - it should already be quite simple.  But I do not own either HTML or CSS, so let someone else do it.  I saw my task in showing that making a web service that provides data from a COM port is not at all difficult. <br><br>  All sources can be taken <a href="https://github.com/alguryanow/serial2web">on githabe</a> . <br><br>  I repeat: the presented code is not a complete solution that can be ‚Äúlet in production‚Äù.  This is only a prototype that shows a fundamental approach to solving a problem. <br><br>  What else can you work on: <br><ul><li>  First, reading the data from the COM port in the Python script is very clumsy - in fact, there is a constant polling ‚Äúis there anything fresh?‚Äù.  This approach, of course, loads the processor and one core on my computer is 100% busy. <br>  As a solution, you can use a blocking read with timeout.  For this, it is enough to specify a nonzero value (in seconds) when opening the COM port as a timeout, for example: <br><pre> <code class="python hljs"> ser = serial.Serial(SERIAL_PORT_NAME, SERIAL_PORT_SPEED, timeout=<span class="hljs-number"><span class="hljs-number">0.03</span></span>)</code> </pre><br>  In addition, in the description of the pySerial module there are three examples of creating a bridge: "TCP / IP - serial bridge", "Single-port TCP / IP - serial bridge (RFC 2217)" and "Multi-port TCP / IP - serial bridge (RFC 2217) "- you can see how such problems are solved by professionals. </li><li>  secondly, only one client can receive data.  Until the page is closed on the first client, you cannot connect to this server and receive values ‚Äã‚Äãon the second computer.  On the one hand, this is probably correct: the COM port is one, and there are several consumers - to whom of them should they give the read line?  If you think that the answer to this question should be ‚Äúeverything‚Äù, then here are my thoughts on this.  It seems to me that the issue cannot be solved only by using an ‚Äúhonest‚Äù multi-threaded web server (for example, some Tornado or Flask), which can simultaneously serve requests from several web clients.  Because you cannot open a COM port from each thread and read from it - in this case, the data from the COM port will leave only one thread / process.  Therefore, in my opinion, it is necessary to split the server part into two parts: <br><ul><li>  A zmq server that works with a COM port, reads strings from it and sends them through a PUB socket to all interested consumers. </li><li>  Python web server instead of connecting to a COM port connects to a zmq server and receives data from it. </li></ul><br>  If you are not familiar with the ZMQ library (ZeroMQ), then instead of it you can use normal TCP / IP or UDP sockets, but I would strongly recommend to get acquainted with ZMQ, because this library greatly facilitates the solution of such problems.  It seems to me that with the help of ZMQ, the solution will be packed with a maximum of 20 lines.  (I can not help but write: even if you do not plan to solve the described task, but your work is connected with multi-thread / multi-process programming with data exchange between threads / processes, look at this library - perhaps this is what you have been so long ago dreamed) </li><li>  data flow is still unidirectional - from the COM port to the web browser.  You cannot send data to the Arduino from the browser yet.  It seems to me that this task is also not very difficult and, unlike the previous one, it can only be solved <br><ul><li>  using a multi-threaded server </li><li>  refining the Handler.do_GET method so that it perceives GET requests with parameters and values ‚Äã‚Äãof which of them sent to the COM port </li></ul><br>  In my opinion, if you want to write a full-fledged analogue of a serial port monitor based on web technologies built into the Arduino IDE, it is not that difficult.  For myself, I see the difficulty only in creating a normal front end. <br></li><li>  It is not possible to set the COM port name and its operation parameters through the browser.  On the one hand, this seems logical: how does a user on the other side of our planet know from which COM port and at what speed the arduin is connected?  But it knows exactly Python web server running on the same computer.  But if, after all, it is desirable to give the user the opportunity to change the name of the COM port or the parameters of his work, then again this is easily solved by refining the Handler.do_GET method </li><li>  To start the server you need to install python.  This is generally not difficult, but if for some reason you don‚Äôt want to do it or don‚Äôt feel like it, pyInstaller can come to the rescue.  With its help, the Python script can be compiled into one executable file (in the case of Windows, into .exe), which can be simply copied to the computer to which arduinka is connected. <br>  Perhaps the best solution would be to use the Go language in this case.  As far as I know, in it the task of creating a file for ‚Äúdistribution‚Äù is solved better. </li></ul><br>  In conclusion: the question may arise: ‚Äúis it not easier to solve this problem through some ready-made cloud?‚Äù.  Why not publish the data read from the COM port in the cloud, and on the clients simply access the corresponding service in the cloud?  Probably, such a decision also has the right to exist, but before applying such a decision, you must answer the following questions: <br><ul><li>  Are there ready web services that allow you to publish data with the speed / frequency I need?  Are there any free ones among them or are you ready to pay the appropriate money? </li><li>  are you ready for the fact that in case of a cloud falling or a connection to it, you will be left without data </li><li>  Does it bother you that in order to transfer data from one room to another, they will cross the ocean or half a continent twice? </li></ul></div><p>Source: <a href="https://habr.com/ru/post/264663/">https://habr.com/ru/post/264663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264655/index.html">Algorithmic and Automated Trading: Introduction</a></li>
<li><a href="../264657/index.html">Javascript and time zones - the correct time on the site</a></li>
<li><a href="../264659/index.html">Making a game with Gideros</a></li>
<li><a href="../26466/index.html">The company offers people money so that they do not work there.</a></li>
<li><a href="../264661/index.html">Report from Dribbble Meetup 2015 in Moscow</a></li>
<li><a href="../264665/index.html">Google released the first public security bulletin for Android</a></li>
<li><a href="../264667/index.html">Our million, year and first eight years</a></li>
<li><a href="../264669/index.html">Docker in the bank. Video from the lecture by Alexander Tarasov from Alfa-Bank</a></li>
<li><a href="../264671/index.html">Preparing graphics for iOS applications</a></li>
<li><a href="../264673/index.html">What does the IaaS market statistics say?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>