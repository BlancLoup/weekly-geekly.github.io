<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>So, you decided to prohibit copying class objects in C ++.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite often, you can find C ++ code in which one or more classes have the copy constructor and the assignment operator declared private and a comment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>So, you decided to prohibit copying class objects in C ++.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/31d/3b9/914/31d3b9914b2a0b1e68646ab21a0d1144.jpg" alt="SHALL NOT DANCE THERE" align="right">  Quite often, you can find C ++ code in which one or more classes have the copy constructor and the assignment operator declared private and a comment like "copying is prohibited" is written. <br><br>  Reception is simple and seemingly obvious, however, with its use, pitfalls are possible, leading to errors that will not appear soon and the search for which can take more than one day. <br><br>  Consider possible problems. <br><a name="habracut"></a><br>  First - a brief excursion why this technique is needed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If a program tries to copy a class object, the default C ++ compiler automatically generates a copy constructor or an assignment operator if they are not explicitly declared in the class.  The automatically generated constructor performs term-by-term copying, and the automatically-generated assignment operator performs the term-by-term assignment. <br><br>  Here is a simple example: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoubleDelete</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: DoubleDelete() { ptr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">100</span></span>]; } ~DoubleDelete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] ptr; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr; };</code> </pre> <br>  In this code: <br><pre> <code class="cpp hljs">{ DoubleDelete first; <span class="hljs-function"><span class="hljs-function">DoubleDelete </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( first )</span></span></span></span>; }</code> </pre><br>  uncertain behavior will occur.  The copy constructor generated by the compiler will be called, which will copy the pointer.  As a result, both objects will store pointers with equal addresses.  The first will execute the second object's destructor, it will execute delete [], then the first object's destructor will be called, it will try to delete [] again for the same address, and this will lead to undefined behavior. <br><br>  The solution seems to be obvious - implement a copy constructor and an assignment operator with the correct behavior.  For example, when copying, a new object creates its own array and copies data from the old one into it. <br><br>  This is not always the right way.  Not all objects are inherently copyable. <br><br>  For example, an object might store an open file descriptor as an integer.  The destructor "closes the file" using the function of the operating system.  Obviously, textual copying will not work.  And what should happen when copying?  Should the file open again?  Usually in this case, copying does not make sense. <br><br>  Another example is a class for capturing a critical section when creating an object of such a class.  What is the point of copying an object?  Section already captured. <br><br>  A brief digression on this is completed, proceed to an attempt to portray the decision. <br><br>  If copying an object does not make sense, you need to make sure that the compiler cannot accidentally execute it.  To do this, usually do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOT BAD class NonCopyable { // blahblahblahpublic: private: // copy and assignment prohibited NonCopyable( const NonCopyable&amp; ); void NonCopyable::operator=( const NonCopyable&amp; ); };</span></span></code> </pre><br>  or so: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// FAIL class NonCopyable { // blahblahblahpublic: private: // copy and assignment prohibited NonCopyable( const NonCopyable&amp; ) { assert( false ); } void NonCopyable::operator=( const NonCopyable&amp; ) { assert( false ); } };</span></span></code> </pre><br>  or so: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// EPIC FAIL class NonCopyable { // blahblahblahpublic: private: // copy and assignment prohibited NonCopyable( const NonCopyable&amp; ) {} void NonCopyable::operator=( const NonCopyable&amp; ) {} };</span></span></code> </pre><br>  All three methods are found in real code. <br><br>  It would seem that the second and third options are different from the first?  The private modifier, in any case, will not cause a copy. <br><br>  EXTREMELY UNEXPECTED ... <br><br>  Member functions of the same class can call the copy constructor and the assignment operator, even if they are declared private.  And the "friends" of the class (friend) can also.  Nobody bothers to write something like this in the code: <br><br><pre> <code class="cpp hljs">NonCopyable NonCopyable::SomeMethod() { <span class="hljs-comment"><span class="hljs-comment">// blahblahblah return *this; }</span></span></code> </pre><br>  or such: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NonCopyable::SomeOtherMehod() { callSomething( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); }</code> </pre><br>  Now there is a difference between the first option and the rest. <br><br>  The first option (no implementation) will lead to an error during the build program.  The error message is not the most understandable, but at least reliable. <br><br>  In the second variant, an assert will be triggered ... provided that the control passes through this code.  Here a lot depends on how often this code is called, in particular, on the code coverage by tests.  Maybe you will notice a problem at the first start, maybe - very soon. <br><br>  In the third variant, it is even better - the assignment operator does not change the object, and the copy constructor calls the default constructors of all members of the class.  Wide room for error, it may be even more difficult to notice than the second. <br><br>  Expected objection - once the copy constructor and the assignment operator are declared but not defined, they can be mistakenly or maliciously defined anywhere in the code.  This problem is solved very simply. <br><br>  From the error helps comment like "prohibited operations" or, if in doubt, "prohibited operations, not to determine under the fear of dismissal."  Nothing helps you from malicious intent - in C ++ no one bothers to take the address of an object, cast it to type char * and rewrite the object as you like, byte-by-byte. <br><br>  C ++ 0x has the delete keyword: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++0x OPTIMAL class NonCopyable { private: // copy and assignment not allowed NonCopyable( const NonCopyable&amp; ) = delete; void operator=( const NonCopyable&amp; ) = delete; // superior developers wanted ‚Äì www.abbyy.ru/vacancy };</span></span></code> </pre> <br>  In this case, not only to determine but also to call them will be impossible - when you try to compile the place of the call, you will receive a compilation error. <br><br>  The option ‚Äúdeclare and not define‚Äù is also available in earlier C ++ 0x, in particular, it uses boost :: noncopyable.  The option to inherit from boost :: noncopyable or a similar class is also quite reliable and available in any version. <br><br>  The attentive reader probably noticed that in all the examples above the assignment operator returns void, and not a link to the same class.  This is done specifically to design <br><br><pre> <code class="cpp hljs">first = second = third;</code> </pre><br>  caused a compilation error in C ++ 03. <br><br>  So small code improvements sometimes help to avoid the Darwin Award. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/142595/">https://habr.com/ru/post/142595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142589/index.html">Polynomial hashes and their applications</a></li>
<li><a href="../142590/index.html">7 reasons why AngularJS is cool</a></li>
<li><a href="../142592/index.html">Perlin Noise</a></li>
<li><a href="../142593/index.html">When you connect the IPTV service you</a></li>
<li><a href="../142594/index.html">Erlang. Recommendations for code design</a></li>
<li><a href="../142596/index.html">Simulator for software testing</a></li>
<li><a href="../142597/index.html">We learn MS SQL Server Reporting Services 2008 R2 to show HTML in reports</a></li>
<li><a href="../142598/index.html">The story of another electric bicycle with their own hands</a></li>
<li><a href="../142599/index.html">The most common SQL injection pattern in PHP is the useless escape of characters.</a></li>
<li><a href="../142600/index.html">Difficult choice of Python or PHP. And maybe both?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>