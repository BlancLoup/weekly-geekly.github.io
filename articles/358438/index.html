<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to miss a single message</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Event handling is one of the most common tasks in the field of serverless technologies. Today we will talk about how to create a reliable message hand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to miss a single message</h1><div class="post__text post__text-html js-mediator-article">  Event handling is one of the most common tasks in the field of serverless technologies.  Today we will talk about how to create a reliable message handler that will reduce their loss to zero.  By the way, the examples are written in C # using the Polly library, but the approaches shown will work with any languages ‚Äã‚Äã(unless otherwise indicated). <br><br><img src="https://habrastorage.org/webt/qv/yd/v5/qvydv5zr-qknehi726vjgpojuzk.jpeg"><a name="habracut"></a><br><br>  I give the word <a href="https://medium.com/%40jeffhollan%3Fsource%3Dpost_header_lockup">to the author</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Reliable event handling with Azure Functions </h2><br>  A few weeks ago, I published an article on <a href="https://medium.com/%40jeffhollan/in-order-event-processing-with-azure-functions-bb661eb55428">how to handle events in order using Functions</a> .  In today's publication, I will explain in general how to create a reliable message handler that will reduce their loss to zero.  This article could be divided into two or three parts, but I decided to combine all the information in one material.  It turned out to be big, but it covers a wide range of tasks: from simple to the most complex, such as using circuit breaker patterns and exception filters.  Examples are written in C #, but the approaches shown will work with any languages ‚Äã‚Äã(unless otherwise indicated). <br><br><h2>  Problems related to event flows in distributed systems </h2><br>  Imagine a system that sends events at a constant rate ‚Äî for example, 100 pieces per second.  Setting up the reception of these events in Azure Functions is quite simple.  In just a few minutes, you can prepare many parallel instances that will handle these 100 events per second.  But what if the publisher sends an incorrectly formed event?  What if one of your copies fails due to a failure?  Or will one of the systems go through the next processing steps?  How to cope with such situations, while maintaining the overall integrity and throughput of your application? <br><br>  Ensuring the reliability of message processing when using queues is a little easier.  In Azure Functions, when processing a message from a queue, a function can ‚Äúblock‚Äù such a message, try to process it, and in case of failure, release the lock so that another instance can accept it and try again.  These attempts continue until the message is successfully processed or until the maximum allowable number of attempts is reached (4 by default).  In the second case, the message is added to the queue of suspicious messages.  When a message from the queue goes through this cycle of attempts, parallel retrieval of other messages from the queue does not stop.  Therefore, one error almost does not affect the overall throughput.  However, storage queues do not guarantee order and are not optimized to provide high bandwidth services (such as event hubs). <br><br>  In event streams (for example, in Azure Event Hubs), locks are not used.  These services are designed to provide high bandwidth, support multiple consumer groups and the ability to play.  When receiving events, they work like a tape drive.  Each section in the stream has one offset pointer.  You can read events in both directions.  Suppose an error occurs while reading the event stream, and you decide to leave the pointer in the same place.  Until it moves, further data processing from this section will not be possible.  In other words, if the system still receives 100 events per second, but Azure Functions stopped moving the pointer to new events, trying to cope with incorrect, then a congestion will happen.  Very quickly you will have a huge amount of unprocessed events that will constantly grow. <br><br><img src="https://habrastorage.org/webt/ni/li/oe/nilioetzvxceubmrxnpbgwxrepq.gif"><br>  <i>Handle exceptions, but do not delay the queue.</i> <br><br>  This behavior of the offset pointer and consumers was taken into account: <b>Functions will move the pointer downstream regardless of whether the processing was successful</b> .  This means that your system and your functions should be able to handle such situations. <br><br><h2>  How Azure Functions Receive Events from an Event Hub </h2><br>  Azure Functions interact with the event hub as follows: <br><br><ol><li>  For each partition in the event hub, a pointer is created (and placed in the Azure storage) (you can see it in the storage account). </li><li>  When receiving new messages of the event concentrator (by default, it is executed in batch mode), the node will try to start the function by passing a batch of messages to it. </li><li>  When the function completes (no matter with exceptions or not), the pointer moves on and its position is stored in the repository. </li><li>  If something prevents the function from completing, the node will not be able to move the pointer, and subsequent checks will receive the same messages (from the previous checkpoint). </li><li>  Stages 2‚Äì4 are repeated. </li></ol><br>  Here you should pay attention to a few things.  First: <b>if you do not handle exceptions, you may lose messages</b> , because even if the execution was completed with an exception, the pointer will be shifted.  Second: <b>Functions guarantee at least one-time delivery</b> (this is a common situation in distributed systems).  This means that your code and its dependent systems should work correctly in situations where the same message was received twice.  The following are examples of these two situations and the code that allows you to deal with them. <br><br>  As part of these tests, I published 100 thousand messages for sequential processing (per section key).  To test and visualize order and reliability, I will log each message as it is processed in the Redis cache.  In the first test, every hundredth message generates an exception, and exception handling is not performed. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">FunctionName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"EventHubTrigger"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[EventHubTrigger(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"events"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Connection = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"EventHub"</span></span></span></span></span><span class="hljs-function">)] EventData[] eventDataSet, TraceWriter log)</span></span> { log.Info(<span class="hljs-string"><span class="hljs-string">$"Triggered batch of size </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{eventDataSet.Length}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> eventDataSet) { <span class="hljs-comment"><span class="hljs-comment">// For every 100th message, throw an exception if (int.Parse((string)eventData.Properties["counter"]) % 100 == 0) { throw new SystemException("Some exception"); } // Insert the current count into Redis await db.ListRightPushAsync("events:" + eventData.Properties["partitionKey"], (string)eventData.Properties["counter"]); } }</span></span></code> </pre> <br>  After sending 100 thousand messages to this system, Redis showed the following: <br><br><img src="https://habrastorage.org/webt/kg/yb/xq/kgybxqnshckmgxgr58oq-zopzle.png"><br><br>  As you can see, I missed the whole chain of messages from the 100th to the 112th.  What happened?  At some point, one of the instances of my functions received a batch of messages for this partition key.  This particular packet ended on the 112th message, but an exception was thrown on the cell.  Execution was stopped, but the function node continued and counted the next packet.  Technically, these messages are stored in event hubs, but in order to process them again, I need to manually request messages from the 100th to the 112th. <br><br><h2>  Add try-catch block </h2><br>  The easiest way to solve this problem is to add a try / catch block to the code.  Now, in the case of an exception, I can process it in the same process before the pointer moves on.  <a href="">After adding a catch block to the above code</a> and restarting the test, all 100,000 messages appeared in the correct order. <br><br><img src="https://habrastorage.org/webt/lf/_y/ma/lf_ymalo6dtkjia_icyhfkkhorm.png"><br><br>  <i>Recommendation: all functions of the event hub should have a catch block.</i> <br><br>  In this example, I used a catch block to make an additional attempt to insert data into Redis, but it is easy for him to find other reasonable uses: for example, sending a notification or placing a message in a suspicious queue or in an event hub for further processing. <br><br><h2>  Retry mechanisms and policies </h2><br>  Some exceptions may occur only from time to time.  Sometimes for the correct execution of the operation it is enough just to repeat it.  In the catch block in the code from the previous section, one retry was performed, but if it failed or resulted in an exception, I would still lose messages 100-112.  There are many tools that allow you to configure more flexible retry policies with preserving the order of processing. <br><br>  For testing, I used the C # error-handling library called <a href="https://github.com/App-vNext/Polly">Polly</a> .  She allowed me to set up both simple and advanced retry policies.  Example: ‚Äútry to insert this message three times (possibly with a delay between attempts).  If all attempts were unsuccessful, add the message to the queue so that I can continue processing the events, and return to the raw or incorrect message later. ‚Äù <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> eventDataSet) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Policy .Handle&lt;Exception&gt;() .RetryAsync(<span class="hljs-number"><span class="hljs-number">3</span></span>, onRetryAsync: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (exception, retryCount, context) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.ListRightPushAsync(<span class="hljs-string"><span class="hljs-string">"events:"</span></span> + context[<span class="hljs-string"><span class="hljs-string">"partitionKey"</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)context[<span class="hljs-string"><span class="hljs-string">"counter"</span></span>] + <span class="hljs-string"><span class="hljs-string">$"CAUGHT</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{retryCount}</span></span></span><span class="hljs-string">"</span></span>); }) .ExecuteAndCaptureAsync(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)eventData.Properties[<span class="hljs-string"><span class="hljs-string">"counter"</span></span>]) % <span class="hljs-number"><span class="hljs-number">100</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemException(<span class="hljs-string"><span class="hljs-string">"Some Exception"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.ListRightPushAsync(<span class="hljs-string"><span class="hljs-string">"events:"</span></span> + eventData.Properties[<span class="hljs-string"><span class="hljs-string">"partitionKey"</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)eventData.Properties[<span class="hljs-string"><span class="hljs-string">"counter"</span></span>]); }, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;() { { <span class="hljs-string"><span class="hljs-string">"partitionKey"</span></span>, eventData.Properties[<span class="hljs-string"><span class="hljs-string">"partitionKey"</span></span>] }, { <span class="hljs-string"><span class="hljs-string">"counter"</span></span>, eventData.Properties[<span class="hljs-string"><span class="hljs-string">"counter"</span></span>] } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result.Outcome == OutcomeType.Failure) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.ListRightPushAsync(<span class="hljs-string"><span class="hljs-string">"events:"</span></span> + eventData.Properties[<span class="hljs-string"><span class="hljs-string">"partitionKey"</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)eventData.Properties[<span class="hljs-string"><span class="hljs-string">"counter"</span></span>] + <span class="hljs-string"><span class="hljs-string">"FAILED"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> queue.AddAsync(Encoding.UTF8.GetString(eventData.Body.Array)); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> queue.FlushAsync(); } }</code> </pre> <br>  In this code, I add a message to the Redis cache using a fragment that creates an entry. <br><br>  Redis final state: <br><br><img src="https://habrastorage.org/webt/1o/zc/ws/1ozcwscxzkfdqgw-8vzubtkeorg.png"><br><br>  When working with more advanced interception exception and retry policies, it should be borne in mind that for precompiled C # class libraries, an evaluation version is available that allows you to set "exception filters" for your function.  With it, you can write a method that will be executed when an unhandled exception is generated while the function is running.  More information and examples are available <a href="https://github.com/Azure/azure-webjobs-sdk/wiki/Function-Filters">in this publication</a> . <br><br><h2>  Errors and problems that are not exceptions </h2><br>  We have considered the case of generating exceptions in your code.  But what if the function instance encounters an interruption in the process? <br><br><img src="https://habrastorage.org/webt/w7/az/ms/w7azmsqnbmbimgjxkbpog7v50us.png"><br><br>  As we have already said, if Function does not complete execution, then the offset pointer does not move further, which means that when trying to receive messages, new instances will receive the same data.  To simulate such a situation, I manually stopped, launched and restarted my application function during the processing of 100 thousand messages.  On the left you can see some of the results.  Please note: all events were processed, everything is in order, but some messages were processed several times (after the 700th, the 601th and subsequent ones were reprocessed).  In general, this is good, since this behavior ensures at least one-time delivery, but this means that my code must be idempotent to a certain extent. <br><br><h2>  Circuit Breaker and Conveyor Stop </h2><br>  The above patterns and patterns of behavior are convenient for the implementation of repeated attempts and help make every effort to handle events.  A certain level of failures is acceptable in many cases.  But let's imagine that there are a lot of errors, and I want to stop the triggering on new events until the restoration of system performance.  This can be achieved by using a circuit breaker pattern - an element that allows you to stop the event processing circuit and resume operation later. <br><br>  Polly (the library with which I implemented retries) supports some of the circuit breaker capabilities.  However, these templates are not very suitable for use in the case of distributed temporal functions, when a chain spans several instances without state tracking.  There are <a href="https://github.com/App-vNext/Polly/issues/287">several interesting approaches to solving this problem</a> with Polly, but for now I‚Äôll add the necessary functions manually.  To implement a circuit breaker for event processing, two components are needed: <br><br><ol><li>  Common to all instances of the state for monitoring and monitoring the health of the chain. </li><li>  The main process that is able to manage the state of the circuit (open or close it). </li></ol><br>  I used the Redis cache as the first component, and the second was the Azure logic apps.  Both of these roles can perform many other services, but I liked these two. <br><br><h2>  Maximum allowable number of errors for all instances </h2><br>  Several instances can process events in parallel, therefore, to monitor the health of the chain, I need a general external state.  I wanted to implement the following rule: ‚ÄúIf, within 30 seconds, more than 100 errors were recorded for all instances in total, open the circuit and terminate operation on new messages.‚Äù <br><br>  I used the TTL tracking options available on Redis and sorted sets to get a sliding interval that records the number of errors in the last 30 seconds.  (If you are interested in the details, all these examples are available on <a href="https://github.com/jeffhollan/functions-csharp-eventhub-ordered-processing">GitHub</a> .) When a new error appeared, I turned to a sliding interval.  If the allowed number of errors (more than 100 in the last 30 seconds) was exceeded, I sent the event to the Azure Event Grid service.  The corresponding Redis code is available <a href="">here</a> .  So I could detect problems, send an event and open the circuit. <br><br><h2>  Circuit Status Management with Logic Applications </h2><br>  I used the Azure logic applications to manage the state of the circuit, since connectors and stateful orchestration perfectly complement each other.  When the open circuit condition was triggered, I initiated a workflow (trigger for the Azure Event Grid service).  The first step is to stop Azure Functions (using the Azure Resource Connector) and send a notification email and response options.  After that, I can check the operation of the circuit and run it again, if everything is in order.  As a result, the workflow will be resumed, the function will be started, and message processing will continue from the last checkpoint of the event hub. <br><br><img src="https://habrastorage.org/webt/43/ow/cm/43owcmknuwwp-4drvuuxgipryza.png"><br>  <i>The email I received from the logic applications after stopping the function.</i>  <i>I can press any button and resume operation of the circuit when required.</i> <br><br>  About 15 minutes ago, I sent 100 thousand messages and set up the system so that every hundredth message would lead to an error.  After approximately 5,000 messages, the allowed threshold was exceeded, and the event was sent to the Azure Event Grid service.  My Azure logic application immediately worked, stopped the function and sent me an email (shown above).  If you look at the contents of Redis, we will see a lot of partially processed sections: <br><br><img src="https://habrastorage.org/webt/dg/dp/b5/dgdpb5qo_g1wg2fgf9i8o084poa.png"><br>  <i>The lower part of the list is the processing of the first 200 messages for this section key, after which logic applications stopped the system.</i> <br><br>  I clicked the link in the email to resume the chain.  After completing the same query in Redis, you can see that the function continued its work from the last checkpoint of the event hub.  Not a single message was lost, everything was processed in a strict order, and it turned out to keep the circuit open for as long as required - the state was controlled by my logic application. <br><br><img src="https://habrastorage.org/webt/qg/eh/yt/qgehytprqndmfivolj6nuvy4oza.png"><br>  <i>Seventeen minute delay before re-closure command.</i> <br><br>  Hopefully this post has helped you learn more about the techniques and patterns for reliably processing message flows using Azure Functions.  This knowledge will allow you to take advantage of the features (in particular, their dynamic scaling and payment as resources are consumed) without compromising the reliability of the solution. <br><br>  Follow the <a href="https://github.com/jeffhollan/functions-csharp-eventhub-ordered-processing">link to</a> find the GitHub repository with pointers to each of the branches for the various reference points of this example.  If you have any questions, contact me via Twitter: @jeffhollan. </div><p>Source: <a href="https://habr.com/ru/post/358438/">https://habr.com/ru/post/358438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358426/index.html">Receiving user data (voluntary)</a></li>
<li><a href="../358428/index.html">What awaits the IaaS market: trends in brief</a></li>
<li><a href="../358432/index.html">How to make Vue.js and Electron work together</a></li>
<li><a href="../358434/index.html">Just add water: H2O.ai development</a></li>
<li><a href="../358436/index.html">Ubuntu DSVM Review: Alchemy</a></li>
<li><a href="../358440/index.html">Entering text in Linux (ibus)</a></li>
<li><a href="../358442/index.html">Tester Tools</a></li>
<li><a href="../358444/index.html">Remove trash from Xcode</a></li>
<li><a href="../358448/index.html">Automatically build Unity projects for Android and iOS using Gitlab CI</a></li>
<li><a href="../358450/index.html">How to identify and develop talents in IT: the results of the first Team Leader meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>