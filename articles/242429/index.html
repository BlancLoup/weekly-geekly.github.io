<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Seven principles for creating modern web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is based on my presentation from the BrazilJS conference in August 2014. It is based on ideas that I recently wrote about in a blog , mai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Seven principles for creating modern web applications</h1><div class="post__text post__text-html js-mediator-article">  This article is based on my presentation from the BrazilJS conference in August 2014.  It is based on ideas that I recently <a href="https://cloudup.com/blog/the-need-for-speed">wrote about</a> <a href="https://cloudup.com/blog/introducing-mydb">in a blog</a> , mainly in connection with UX and performance. <br><br>  I want to present 7 effective principles for websites that want to use JavaScript to manage the UI.  These principles are the result of my work as a web designer, but also as a long-time WWW user. <br><br>  JavaScript has undoubtedly become an indispensable tool for frontend developers.  Now its scope is expanding to other areas, such as servers and microcontrollers.  This programming language was chosen by prestigious universities to teach students the basics of computer science. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the same time, there are a number of questions regarding its role and specific use, which many find it difficult to answer, including the authors of frameworks and libraries. <br><br><ul><li>  Should javascript be used as a replacement for browser functions: history, navigation, rendering? </li><li>  Is the backend dying?  Should I render HTML at all? </li><li>  Is it true that the future belongs to applications on a single page (Single Page Applications, SPA)? </li><li>  Should JS generate pages on a website and render pages in web applications? </li><li>  Should I use techniques like PJAX or TurboLinks? </li><li>  What is the exact difference between a website and a web application?  Should there be one thing left? </li></ul><a name="habracut"></a><br>  Next will be my attempts to answer these questions.  I tried to explore how to use JavaScript from a user's perspective (UX).  In particular, he paid special attention to the idea of ‚Äã‚Äãminimizing the time it takes the user to retrieve data of interest.  Starting from the basics of network technologies and ending with the prediction of the future behavior of the user. <br><br><h2>  1. Rendering of pages on the server </h2><br><blockquote>  <b>tl; DR</b> : Rendering on the server is not done for SEO, but for performance.  Take into account additional requests for getting scripts, styles and subsequent requests to the API.  In the future, consider using the HTTP 2.0 Push method. </blockquote><br>  First of all, I have to pay attention to the common error of separating ‚Äúserver-rendered applications‚Äù and ‚Äúone-page applications‚Äù.  If we want to achieve the best perception from the point of view of the user, then we should not limit ourselves to such a framework and abandon one alternative in favor of another. <br><br>  The reasons are quite obvious.  Pages are transmitted over the Internet, which has physical limitations, which was unforgettably illustrated by Stuart Cheshire in the famous essay <a href="http://rescomp.stanford.edu/~cheshire/rants/Latency.html">"This is latency, idiot"</a> : <br><br><blockquote>  The distance between Stanford and Boston is 4320 km. <br>  The speed of light in vacuum is 300 x 10 ^ 6 m / s. <br>  The speed of light in fiber is about 66% of the speed of light in a vacuum. <br>  The speed of light in the fiber is 300 x 10 ^ 6 m / s * 0.66 = 200 x 10 ^ 6 m / s. <br>  One-way delay in transmission to Boston is 4320 km / 200 x 10 ^ 6 m / s = 21.6 ms. <br>  The delay in the transfer back and forth 43.2 ms. <br>  Ping from Stanford to Boston on the Internet of the modern sample of about 85 ms (...) <br>  So, modern Internet equipment transmits a signal at a speed of 0.5 from the speed of light. </blockquote><br>  This result can be improved by 85 ms (and now it is slightly better), but it is important to understand that there is a physical limitation on the delay in transmitting information via the Internet, no matter how much the bandwidth on users' computers increases. <br><br>  This is especially important due to the growing popularity of JavaScript applications, which usually contain only the &lt;script&gt; and &lt;link&gt; markup next to the empty &lt;body&gt; field.  The so-called single-page applications (Single Page Applications, SPA) - the server returns one page, and everything else is called by the code on the client side. <br><br>  Imagine a script when a user comes directly to <code><a href="http://xn--pp-6kc.com/orders/"></a> pp.com/orders</code>  <code><a href="http://xn--pp-6kc.com/orders/"></a> pp.com/orders</code> .  By the time your application receives and processes this request, it already has important <i>information</i> about what to show on the page.  It can, for example, load an order from the database and add it to the response.  But most of the SPA in this situation returns a blank page and the &lt;script&gt; tag.  Then you have to exchange requests again to get the contents of the script, and again to get the content. <br><br><img src="https://habrastorage.org/files/985/959/8c0/9859598c09144a439dc68efb273dd711.png"><br>  <i>Analysis of the HTML sent by the server for each SPA page</i> <br><br>  Many developers deliberately make such a sacrifice.  They try to ensure that additional network <i>hops</i> for a user occur only once, sending the correct headers for caching in the responses with scripts and CSS.  The generally accepted opinion is that this is an acceptable transaction, because after downloading all the files to a computer, most of the user's actions (like switching to other sections) are performed without requesting additional pages or scripts. <br><br>  However, even taking into account the cache, there is a certain performance loss, considering the time spent on parsing and script execution.  In the article <a href="http://modernweb.com/2014/03/10/is-jquery-too-big-for-mobile/">‚ÄúIs jQuery too big for a mobile phone?‚Äù It</a> says how jQuery alone can slow down some mobile browsers for hundreds of milliseconds. <br><br>  Worse yet, usually the user does not receive any feedback while the scripts are being loaded.  The result is a blank page on the screen, which then suddenly turns into a fully loaded page. <br><br>  Most importantly, we usually forget that the most common transport for transmitting Internet data (TCP) starts slowly.  This almost certainly ensures that most scripted suites will not be transferred at once, making the situation described above even worse. <br><br>  A TCP connection begins with a packet exchange for a handshake.  If you use SSL, which is important for the secure transfer of scripts, there are two additional packet exchanges (one if the client restores the session).  Only after that the server can start sending data, but practice shows that it does this slowly and in portions. <br><br>  A congestion control mechanism called Slow Start is built into the TCP protocol to send data, gradually increasing the number of <i>segments</i> .  This has two serious conclusions for the SPA: <br><br>  1. Large scripts load much longer than it seems.  As explained by Ilya Grigorik‚Äôs book <a href="http://chimera.labs.oreilly.com/books/1230000000545/ch02.html">"High Performance Browser Networking,"</a> it takes "four packet exchanges (...) and hundreds of milliseconds of delay to reach 64 kilobytes of data exchange between the client and the server."  For example, in the case of a fast Internet connection between London and New York, it takes 225 ms before TCP can reach the maximum packet size. <br><br>  2. Since this rule also applies to the initial loading of the page, it is very important what content is loaded for rendering on the page in the first place.  As Paul Irish concludes in his presentation <a href="https://docs.google.com/presentation/d/1MtDBNTH1g7CZzhwlJ1raEJagA8qM3uoV7ta6i66bO2M/present">‚ÄúDelivery of Goods‚Äù</a> , the first <b>14 KB</b> are critical.  This is understandable if you look at the chart with the indication of the volume of transmission between the client and the server in the first stages of establishing a connection. <br><br><img src="https://habrastorage.org/files/5eb/8e6/a3a/5eb8e6a3ae824a1bad7e27e6cd4f2718.png"><br>  <i>How many KB server can send at each stage of the connection, by segments</i> <br><br>  Websites that manage to deliver content (even if the basic markup without data) in this window seem to be extremely responsive.  In fact, many authors of fast server applications perceive JavaScript as something unnecessary or that needs to be used with great care.  This attitude is further enhanced if the application has a fast backend and database, and its servers are located near users (CDN). <br><br>  The role of the server in speeding up the presentation of content directly depends on the web application.  The solution does not always come down to "rendering whole pages on the server." <br><br>  In some cases, it is better to exclude part of the page that is currently irrelevant for the user from the initial answer and leave for later.  Some applications, for example, prefer to render only the ‚Äúcore‚Äù of the page to ensure immediate response.  Then they request different parts of the page in parallel.  This provides better responsiveness even in a situation with a slow outdated backend.  For some pages, rendering a <a href="http://www.feedthebot.com/pagespeed/prioritize-visible-content.html">visible part of the</a> page will be a good option. <br><br>  The <i>qualitative assessment of</i> scripts and styles is extremely important, taking into account the information that the server has about the session, the client and the URL.  Scripts that sort the orders will obviously be more important for <code>/orders</code> than the logic of the settings page.  Maybe not so obvious, but there is a difference in loading ‚Äústructural CSS‚Äù and ‚ÄúCSS for styling.‚Äù  The first may be needed for JavaScript code, so <i>blocking</i> is required, and the second is loaded asynchronously. <br><br>  A good example of a SPA that does not lead to excessive packet exchange is a conceptual clone of <a href="http://danlec.com/blog/stackoverflow-in-4096-bytes">StackOverflow in 4096 bytes</a> , it can theoretically be loaded with the very first packet after a handshake on a TCP connection!  The author managed to achieve this by refusing to cache, using inline for all resources in the response from the server.  Using <a href="http://www.chromium.org/spdy/link-headers-and-server-hint">SPDY or HTTP / 2 server push</a> , it is theoretically possible to transfer all cached client code in one hop.  Well, currently, rendering parts or the entire page on the server side remains the most popular way to get rid of unnecessary rounds of packet exchange. <br><br><img src="https://habrastorage.org/files/72c/744/42e/72c74442e1c34eb99c732631fe9c54b2.png"><br>  <i>Proof-of-concept SPA using inline for CSS and JS to get rid of extra roundtrip</i> <br><br>  A fairly flexible system that divides the rendering between the browser and the server and provides tools for the gradual loading of scripts and styles can easily erase the distinction between <i>web sites</i> and <i>web applications</i> .  Both use URLs, navigation, and demonstrate data to the user.  Even a spreadsheet application that traditionally relies on client-side functionality must first show the client the information to be edited.  And to do this in the least amount of roundtripes is of paramount importance. <br><br>  From my point of view, the biggest lack of performance in many popular systems in our time is due to the progressive accumulation of complexity in the stack.  Over time, technologies like JavaScript and CSS were added.  Their popularity also gradually grew.  Only now can we evaluate how they can be used differently.  We are talking about improving the protocols (this shows the current progress of SPDY and QUIC), but the greatest benefit comes from the optimization of applications. <br><br>  It will be useful to recall some historical discussions around the design of earlier versions of HTML and WWW.  For example, <a href="http://1997.webhistory.org/www.lists/www-talk.1993q1/0260.html">this</a> 1997 <a href="http://1997.webhistory.org/www.lists/www-talk.1993q1/0260.html">mailing list</a> suggests adding an &lt;img&gt; tag in HTML.  Marc Andressen repeats how important it is to quickly deliver information: <br><br><blockquote>  ‚ÄúIf the document needs to be integrated into a single unit on the fly, then it can be arbitrarily difficult, and even if the complexity is limited, we still have major performance problems due to the structuring of documents in a similar way.  First of all, this immediately violates the <b>principle of one hop on the WWW</b> (well, IMG also violates it, but for a very specific reason and in a very limited sense) - are we sure that we want it? ‚Äù </blockquote><br><br><h2>  2. Immediate response to user actions </h2><br><blockquote>  <b>tl; DR</b> : JavaScript allows you to hide network latency altogether.  Using this as a design principle, we can even remove almost all loading indicators and ‚Äúloading‚Äù messages from the application.  PJAX or TurboLinks miss out on opportunities to increase the subjective speed of the interface. </blockquote><br>  Our task is to accelerate the maximum response to user actions.  No matter how much effort we put into reducing the number of hops when working with a web application, but there are things beyond our control.  This is the theoretical limit of the speed of light and the minimum ping between the client and the server. <br><br>  An important factor is the unpredictable quality of communication between the client and the server.  If the call quality is poor, then packet retransmission will occur.  Where content needs to load in a couple of roundtrips, you may need a lot more. <br><br>  This is the main advantage of JavaScript to improve UX.  If on the client side the interface is controlled using scripts, we can hide the network latency.  We can create the impression of high speed.  We can artificially achieve a zero delay. <br><br>  Suppose again that we have plain HTML.  Documents are linked via hyperlinks or &lt;a&gt; tags.  If you click on any of them, the browser will make a network request, which takes an unpredictable long time, then it receives and processes the received data and finally goes into a new state. <br><br>  JavaScript allows you to <b>respond immediately</b> and <b>optimistically</b> to user actions.  Clicking on a link or button leads to an immediate response, without contacting the Network.  A well-known example is the Gmail (or Google Inbox) interface, in which email archiving occurs immediately, while the corresponding request to the server is sent and processed asynchronously. <br><br>  In the case of a form, instead of waiting for some HTML code as an answer to filling it out, we can respond immediately as soon as the user clicks ‚ÄúEnter‚Äù.  Or even better, as Google does, we can react even earlier by preparing markup for a new page in advance. <br><br><img src="https://habrastorage.org/files/275/fe8/32b/275fe832bffb4418ae000c18a2f6a8af.gif"><br><br>  This behavior is an example of what I call <i>markup adaptation</i> .  The basic idea is that the page ‚Äúknows‚Äù its future markup, so it can switch to it when there is no data to indicate this.  This is ‚Äúoptimistic‚Äù behavior, because there is still a risk that the data will never arrive, and you will have to display an error message, but this obviously happens rarely. <br><br>  The main page of Google is quite suitable as an example, because it very clearly demonstrates the first two principles from our article. <br><br>  First, a <a href="https://gist.github.com/guille/3e1b2d7529009370b986">batch dump of</a> TCP connections from <code><a href="http://www.google.com/"></a> www.google.com</code>  <code><a href="http://www.google.com/"></a> www.google.com</code> shows that they specifically try to send the entire page immediately after receiving the request.  The entire packet exchange, including closing the connection, takes 64 ms for me in San Francisco.  This was probably true for them <a href="http://en.wikipedia.org/wiki/Google">from the very beginning</a> . <br><br>  At the end of 2004, Google <a href="http://googleblog.blogspot.com/2004/12/ive-got-suggestion.html">pioneered</a> the use of JavaScript to provide real-time prompts during a search query (interestingly, an employee developed this function 20% of the time free from basic work, as well as Gmail).  It even became the foundation for the <a href="http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/">emergence of Ajax</a> : <br><br><blockquote>  Look at Google Suggest.  Watch how search terms are updated as you type, almost instantly ... without any delay in reloading the page.  Google Suggest and Google Maps are two examples of new approaches to creating web applications, which we called ‚ÄúAjax‚Äù in Adaptive Path </blockquote><br>  And in 2010, they <a href="http://googleblog.blogspot.com/2010/09/search-now-faster-than-speed-of-type.html">introduced</a> Instant Search, in which JS plays a central role, generally excluding the page refresh manually and switching to the ‚Äúsearch results‚Äù markup at the first keystroke, as seen in the illustration above. <br><br>  Another prominent example of adapting markup may be in your pocket.  From the very first days, iPhone OS demanded that application authors provide a <i>default.png</i> image, which can be immediately displayed on the screen while the application itself is loading. <br><br><img src="https://habrastorage.org/files/ca7/1b4/2e7/ca71b42e77644aabbdea579985f52c99.png"><br>  <i>iPhone OS forcibly loads default.png before launching the application</i> <br><br>  In this case, the operating system does not compensate for the network delay, but the CPU.  This was important given the performance of the early equipment.  True, in some cases, this approach failed.  For example, if the picture did not match the password entry screen.  A detailed analysis of the <a href="http://www.marco.org/2010/11/11/my-default-png-dilemma">results</a> published by <a href="http://rauchg.com/2014/7-principles-of-rich-web-applications/">Marco Arment in 2010</a> . <br><br>  Another type of action, besides clicks and submitting forms, that are greatly improved with the help of JavaScript, is the rendering of <b>the file download</b> . <br><br>  We can register a user‚Äôs attempt to load a file in various ways: drag-n-drop, pasting from the buffer, file selection.  Then, thanks to the new <a href="https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications">HTML5 APIs</a> , we can display the content as if it was already loaded.  An example of this kind of interface is our work with downloads in Cloudup.  Notice how the thumbnail image is generated and rendered instantly: <br><br><img src="https://habrastorage.org/files/ce4/f65/bb6/ce4f65bb67ce40e08ec9adf4d34eca83.gif"><br>  <i>The image is rendered and displayed until the download is complete.</i> <br><br>  In all these cases, we improve the <i>perception of speed</i> .  Fortunately, there is much evidence of the usefulness of this approach.  Take at least <a href="http://www.nytimes.com/2012/08/19/opinion/sunday/why-waiting-in-line-is-torture.html">an example of</a> how <i>increasing the</i> distance to the baggage conveyor at the Houston airport <i>reduced the</i> number of complaints about lost baggage without having to speed up baggage handling. <br><br>  This idea should seriously affect the UI of our applications.  I believe that download indicators should be rare, especially if we are switching to applications with real-time information, which are described in the next section. <br><br>  There are situations where the illusion of instantaneous action in reality has a detrimental effect on the UX.  This may be a form of payment or end of the session on the site.  Using an optimistic approach here, de facto deceiving the user, we risk irritating him. <br><br>  But even in these cases, the display on the screen of spinners or loading indicators should be stopped.  They need to be displayed only after the user regards the response as not instantaneous.  According to the frequently quoted <a href="http://www.nngroup.com/articles/response-times-3-important-limits/">Nielsen study</a> : <br><br><blockquote>  The basic advice on response time remains unchanged for thirty years <a href="http://rauchg.com/2014/7-principles-of-rich-web-applications/">Miller 1968;</a>  <a href="http://rauchg.com/2014/7-principles-of-rich-web-applications/">Card et al.</a>  <a href="http://rauchg.com/2014/7-principles-of-rich-web-applications/">1991</a> : <br>  * 0.1 seconds is the limit, so that the user perceives the response as immediate, there is no need to display any additional information, except for the result of the operation. <br>  * 1.0 seconds is the limit on the continuity of the thought flow of the user, even though he will notice a delay.  <b>Usually, no additional indication is required when the delay is more than 0.1 second, but less than 1.0 second</b> , but the user loses the feeling of direct work with the data. <br>  * 10 seconds is a limit to keeping the user's attention on the dialogue.  With a greater delay, users will want to perform another task, waiting for a response from the computer. </blockquote><br>  Techniques like PJAX or TurboLinks unfortunately miss most of the features described in this section.  The code on the client side does not "know" about the future state of the page until it communicates with the server. <br><br><h2>  3. Reaction to data change </h2><br><blockquote>  <b>tl; DR</b> : When data is updated on the server, the client should be notified without delay.  This is such a form of increasing productivity when the user is freed from the need to perform additional actions (press F5, refresh the page).  New problems: management (repeated) connection, restoration of a state. </blockquote><br>  The third principle relates to the response of the UI to changing data at the source, usually in one or more database servers. <br><br>  The model of transferring HTML data that goes static until the user refreshes the page (traditional websites) or interacts with it (Ajax) goes into the past. <br><br>  Your UI should <b>be updated automatically</b> . <br><br>  This is critically important in a world with an increasing flow of information from various sources, including watches, phones, tablets and wearable devices that will appear in the future. <br><br>  Imagine Facebook news feed immediately after its appearance, when information was published, mainly from users' personal computers.  Static rendering could not be called optimal, but it made sense for people who updated the tape, say, once a day. <br><br>  Now we live in the world when you upload a photo - and almost immediately get likes and comments from friends and acquaintances.  The need for instant response has become a natural necessity in the competitive environment of other applications. <br><br>  It would be wrong, however, to assume that the benefits of an instant UI update are limited only to multi-user applications.  That's why I like to talk about <i>agreed data points</i> , instead of <i>users</i> .  Take the typical photo synchronization script between your phone and your own laptop: <br><br><img src="https://habrastorage.org/files/0ed/099/bd4/0ed099bd41da4d25ba8f0860d697ab65.gif"><br>  A single-user application can also benefit from "reactivity" <br><br>  It is useful to present <i>all the</i> information that is sent to the user as "reactive".  <b>Synchronizing session and authorization status</b> is one example of a universal approach.  If the users of your application have several tabs open at the same time, then the end of a working session on one of them should immediately deactivate authorization on all the others.  This inevitably leads to improved security and better protection of confidential information, especially in situations where several people have access to the same device. <br><br><img src="https://habrastorage.org/files/04b/499/53e/04b49953e39947efa22fb6afdff9410d.gif"><br>  <i>Each page responds to session state and authorization status.</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once you have established the rule that the information on the screen is updated automatically, it is important to work on a new task: restoring the state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When sending requests and receiving atomic updates, it is easy to forget that your application should be updated normally even after a long lack of communication. Imagine that you close the lid of the laptop and open it in a few days. How will the application behave? </font></font><br><br><img src="https://habrastorage.org/files/ba0/3c5/d5f/ba03c5d5f1da46848846cad92164f660.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of what happens in case of incorrect communication update.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability of the application to restore communication normally interacts with principle No. 1. If you choose to send data when the page is first loaded, you must also take into account the time that has passed before the scripts are loaded. </font><font style="vertical-align: inherit;">This time is essentially equivalent to disconnect time, so the initial connection of your scripts is the resumption of the session.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Control data exchange with the server </font></font></h2><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tl; DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Now we can fine-tune the communication with the server. </font><font style="vertical-align: inherit;">Ensure error handling, repeated requests to the client, synchronization of data in the background, and keeping the cache offline.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When the web appeared, the data exchange between the client and the server was limited in several ways: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clicking on the link will send </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for a new page and its rendering.</font></font></li><li>    POST  GET     . </li><li>      GET    . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplicity of such a model is very attractive, and now everything is definitely complicated when it comes to understanding how to receive and send information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main restrictions relate to the second paragraph. The inability to send data without necessarily loading a new page was a disadvantage in terms of performance. But the most important thing is that it completely broke the "Back" button: </font></font><br><br><img src="https://habrastorage.org/files/ad2/b55/e17/ad2b55e1749649e786ac94d867eebe62.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probably the most annoying artifact of the old web.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That is why the web as a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">platform for applications</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> remained incomplete without JavaScript. Ajax was a huge leap forward in terms of convenience in terms of publishing information by the user.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have a lot of APIs (XMLHttpRequest, WebSocket, EventSource, these are just a few of them), which give full and clear control over the data flow. In addition to the ability to publish user data through the form, we have new opportunities for improving UX. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directly related to the previous principle is showing the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status of the connection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If we expect that the data will be updated automatically, we are obliged to inform the user about the facts </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of communication loss</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attempts to restore it</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a disconnect is detected, it is useful to store the data in memory (or even better, in localStorage), so that you can send it later. This is especially important in light of the future use of </font></font><a href="http://jakearchibald.com/2014/using-serviceworker-today/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ServiceWorker.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that allows javascript applications to run </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the background</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If your application is not open, you can still continue to try to synchronize data with the server in the background. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the possibility of timeouts and errors when sending data, such situations should be decided </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in favor of the client</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the connection is reestablished, try sending the data again. In case of a permanent error, report this to the user. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some errors need to be handled especially carefully. For example, an unexpected 403 can mean that a user session is invalidated. In such cases, it is possible to restore the session if you show the user a window for entering the login and password.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to make sure that the user does not accidentally interrupt the flow of data. </font><font style="vertical-align: inherit;">This can happen in two situations. </font><font style="vertical-align: inherit;">The first and most obvious case is closing the browser or tab that we are trying to prevent with the handler </font></font><code>beforeunload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/files/83f/e12/ac1/83fe12ac1c634aa39e7c9d035fca9143.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warning</font></font><code>beforeunload</code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Another (and less obvious) case is an attempt to switch to another page, for example, clicking on a link. </font><font style="vertical-align: inherit;">In this case, the application can stop the user by other methods, at the discretion of the developer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Don't break history, improve it. </font></font></h2><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tl; DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : If the browser does not manage URLs and history, we will have new problems. </font><font style="vertical-align: inherit;">Make sure you meet the expected scroll behavior. </font><font style="vertical-align: inherit;">Save your own cache for quick feedback.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apart from submitting forms, when using hyperlinks in the web application alone, we will have a fully functional ‚ÄúForward / Back‚Äù navigation in the browser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a typical ‚Äúendless‚Äù page is usually made using a javascript button that requests additional data / HTML and inserts it. Unfortunately, few people remember the need to call </font></font><code>history.pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>replaceState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a mandatory step. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's why I use the word ‚Äúbreak‚Äù. With a simple initial web model, this was not possible. Each state change was based on a URL change. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is also the other side of the coin - the ability </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to improve the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history of surfing, which we now control using JavaScript.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One such opportunity, Daniel Pipius, called </font></font><a href="https://medium.com/joys-of-javascript/beyond-pushstate-building-single-page-applications-4353246f4480"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast Back</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The back button should work quickly; </font><font style="vertical-align: inherit;">users do not expect too much data change.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how to consider the ‚ÄúBack‚Äù button as a button from a web application and apply principle 2 to it: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately respond to a user action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The main thing is that you have the opportunity to decide how to organize the caching of the previous page and instantly display it on the screen. You can then apply the principle number 3, and then inform the user about new data on this page. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are still a few situations where you can not control the behavior of the cache. For example, if you rendered a page, then went to a third-party site, and then the user clicked "Back." Applications that render HTML on the server side are especially susceptible to this small bug, and then modify it on the client side: </font></font><br><br><img src="https://habrastorage.org/files/b7c/008/cb9/b7c008cb98994566b3efa16e2579e4fd.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incorrect operation of the Back button</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another way to break the navigation is to ignore the memory of the scrolling state. Once again, pages that do not use JS and manual history management will most likely not have problems here. But there will be dynamic pages. I tested two of the most popular JavaScript-based news feeds on the Internet: Twitter and Facebook. Both had scrolling amnesia. </font></font><br><br><img src="https://habrastorage.org/files/61b/2e5/a11/61b2e5a11b244f4883e88ffeb96caf66.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endless paging of pages is usually a sign of scrolling amnesia.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the end of the day, beware of state changes that are only relevant when viewing history. For example, this is a case of changing the state of subtrees with comments. </font></font><br><br><img src="https://habrastorage.org/files/421/8c4/41b/4218c441b06849b7af9b28ab5650ec2f.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changing the type of comments you want to save in history</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the page has been re-drawn after clicking the link inside the application, the user can expect that all comments will be expanded. </font><font style="vertical-align: inherit;">When you change the state, you need to save it in history.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Updating code via push messages </font></font></h2><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tl; DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : It is not enough to send only data through push messages, you also need the code. </font><font style="vertical-align: inherit;">Avoid API errors and improve performance. </font><font style="vertical-align: inherit;">Use a stateless DOM for painless application redistribution.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is extremely important that your application reacts to changes in the code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it reduces the number of possible errors and increases reliability. If you have made an important change in the backend API, then you </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> update the client program code. Otherwise, customers may not accept new data or may send data in an incompatible format. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No less important is the observance of principle number 3. If your interface is updated itself, then users have little reason to turn to manual page reloading.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep in mind that for a regular site, updating a page triggers two things: reloading data and reloading code. Organizing a system with push updates of data without push updates of the code is defective, especially in a world where one tab (session) can remain open for a very long time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the server push channel is working, then the user can be sent a notification about the availability of new code. If not, the version number can be added to the outgoing HTTP requests header. The server can compare it with the latest known version, agree to process the request or not, and issue a task for the client. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, some web applications force the page to reload on behalf of the user. For example, if the page is </font></font><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not in the visible area of ‚Äã‚Äãthe screen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and there are no completed forms for input. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An even better approach is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hot-code replacement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This means that you do not have to perform a full page reload. Instead, certain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modules</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are replaced on the fly, and their code is resubmitted for execution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In many existing applications, it is quite difficult to perform hot-swappable code. To do this, you must initially adhere to the architecture that separates the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">behavior</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (code) from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (state). This separation will allow us to quickly roll a lot of different patches. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in our web application, there is a module that installs a bus for passing events (like </font></font><a href="http://socket.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). When an event occurs, the state of a particular component changes and this is reflected in the DOM. Then you change the behavior of this component, for example, so that it generates different DOM markup for the existing and new states. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideally, we should be able to change the code modularly. You will not need to reconnect to the socket, for example, if you can simply update the code of the desired component. The ideal architecture for push code updates is thus modular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But immediately there is a problem with how to evaluate modules without unwanted side effects. Here, an architecture like the one that </font><a href="http://facebook.github.io/react/"><font style="vertical-align: inherit;">React</font></a><font style="vertical-align: inherit;"> offers is best suited.</font></font><a href="http://facebook.github.io/react/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the component code is updated, its logic can simply be re-executed, and the DOM is updated. </font><font style="vertical-align: inherit;">An explanation of this concept from Dan Abramov is read </font></font><a href="http://gaearon.github.io/react-hot-loader/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essentially, the idea is that you update the DOM (or repaint it), which helps a lot in replacing the code. </font><font style="vertical-align: inherit;">If the state is stored in the DOM or event handlers are set by the application, updating the code can be a much more difficult task.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Predicting behavior </font></font></h2><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tl; DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Negative Delay.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modern JavaScript applications can have mechanisms for predicting user actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most obvious application of this idea is to download data in advance from the server before the user requests it. Downloading a webpage when the mouse cursor appears over it, so when you click on links, it is displayed instantly, this is a simple example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A slightly more advanced method of monitoring mouse tracking analyzes its trajectory for future ‚Äúcollisions‚Äù with interactive elements, like buttons. </font></font><a href="https://medium.com/%40cihadturhan/a-ux-idea-i-know-where-you-are-aiming-3e00d152afb2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JQuery example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/files/289/c0e/bc0/289c0ebc02f046c6996389d385e52240.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The jQuery plugin provides mouse trajectory</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The web remains the most versatile medium of information transfer. </font><font style="vertical-align: inherit;">We continue to add dynamics to our pages and, before their introduction, we must make sure that we keep the important web principles inherited by us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyperlinked pages are good building blocks for any application. </font><font style="vertical-align: inherit;">Progressive loading of code, styles, and markup as user actions ensure excellent performance without abandoning interactivity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New unique features provides JavaScript. </font><font style="vertical-align: inherit;">If these technologies are widely used, they will provide the best experience for users of the freest platform of all existing - WWW.</font></font></div><p>Source: <a href="https://habr.com/ru/post/242429/">https://habr.com/ru/post/242429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242413/index.html">Tinkoff Bank at a performance conference in C #</a></li>
<li><a href="../242415/index.html">New WebStorm 9: just better. Support for Meteor, React and JSX, integration with Gulp, PhoneGap and more</a></li>
<li><a href="../242417/index.html">Otkrytie Mobile Bank: development from reverse</a></li>
<li><a href="../242425/index.html">Jump Start in PowerShell (Part I)</a></li>
<li><a href="../242427/index.html">We use AngularJS in Windows Phone 8.1 applications</a></li>
<li><a href="../242433/index.html">View all keystrokes in Google Docs</a></li>
<li><a href="../242435/index.html">Opera Mini 9 for iOS</a></li>
<li><a href="../242439/index.html">Hackers hacked more than 3 million iTunes accounts?</a></li>
<li><a href="../242445/index.html">Jump Start in PowerShell (Part II)</a></li>
<li><a href="../242449/index.html">Samsung Gear App Challenge Finalists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>