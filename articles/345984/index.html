<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What else you need to learn about OpenCL C before you write on it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As it was written 


float4 val = (0, 0, 0, 0);  
 What the author wanted to write 


 float4 val = (float4)(0, 0, 0, 0);  
 How to write 


 float4 v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What else you need to learn about OpenCL C before you write on it</h1><div class="post__text post__text-html js-mediator-article"><table><tbody><tr><td>  As it was written <br></td><td><pre><code class="cpp hljs">float4 val = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br></td></tr><tr><td>  What the author wanted to write <br></td><td><pre> <code class="cpp hljs">float4 val = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br></td></tr><tr><td>  How to write <br></td><td><pre> <code class="cpp hljs">float4 val = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br></td></tr></tbody></table><br>  If you come across OpenCL or plan to encounter and don‚Äôt see the difference between the first and second options, and the third one you have doubts - ‚ÄúDoes it compile at all?‚Äù - welcome under the cat, there are many nuances of the language and absolutely nothing about the API and performance optimization . <br><a name="habracut"></a><br>  The most expensive computer memory - in the head of programmers.  This is probably why the two most popular GPU programming technologies ‚Äî CUDA and OpenCL ‚Äî are not based on fundamentally new parallel languages, not assemblers for specific architectures, but on adapted C ++ and C. In the case of OpenCL, the most popular core writing language is OpenCL C 1.2 - dialect C based on ISO C99.  Removed the standard library, added vector types and operations on them, several functions for locking and determining its place among other threads, four address spaces.  Simple atomic operations that are incompatible with C11 have been added (atomic operations and locks from C11 have been added to OpenCL C 2.0, which has not been widely adopted yet).  Added some handy features that were not in C, something like standardized <a href="https://en.wikipedia.org/wiki/Intrinsic_function">intrinsics</a> . <br><br>  In terms of language and API there are many examples, most of which are the addition of two vectors.  There is a good, albeit dry, <a href="https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf">official specification</a> , several English-language books, optimization tips from device manufacturers.  As soon as the programmer understands how to write his task - he writes it on the familiar C99 using new functions like <code>get_global_id()</code> and everything in terms of language seems clear and primitive.  Such a familiar C99 that you can easily fall into the trap and not notice it for the time being.  Yes, OpenCL C is very similar to C, but there are some very useful differences, unfairly forgotten because there are no analogues in C99, and very insidious differences, hiding behind a similar syntax. <br><br>  I looked through a lot of code on OpenCL C and people who are just starting to write on it, make the same mistakes: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  confuse vector literal with type conversion; </li><li>  do not use wonderful type conversion mechanisms; </li><li>  forget about the nuances of converting vector types. </li></ul><br>  As you can see from the list, it‚Äôs all a matter of type conversion.  In <a href="https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf">the OpenCL 1.2 specification,</a> these are sections <i>6.2. * Conversions and Type Casting</i> .  In addition, the next section <i>6.3 Operators is</i> tricky, <s>and nobody reads it either</s> .  As experience shows, much of the specification is written insufficiently clearly and too boringly - I will try to fill the gap in the available Russian-language documentation on these topics with this article. <br><br><h2>  Vector literals or explicit type conversions. </h2><br>  The new design in OpenCL C is a vector literal with which you can set the value of a vector.  Unfortunately, its syntax is very similar to the explicit type conversion: <br><br><pre> <code class="cpp hljs">( )(   )</code> </pre> <br>  for example <br><br><pre> <code class="cpp hljs">(int2)(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  or <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      int2 a = (int2)(1, 2); // a=[1,2] //       int2 b = (int2)(3, 4); // b=[3,4] //          int4 c = (int4)(a, b); // c=[1,2,3,4] //         int3 d = (int3)(1, c.xy); // d=[1,1,2] //       ?! float2 e = (float2)(1); // e=[1.0f,1.0f]</span></span></code> </pre> <br>  However, <code>(float2)(1)</code> and other examples above are not a type conversion, but a new construction (see <i>6.1.6 Vector Literals</i> in <a href="https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf">the OpenCL 1.2 specification</a> ). <br><br>  Inside the second brackets there must be a total of as many scalars or vector components as in a vector type inside the first brackets.  There is one exception - if to the right there is only one scalar value in brackets, then it itself "multiplies" to the required number of vector components. <br><br>  Explicit coercion of vector types in the style of C is simply not in the language.  A fatal mistake can be made if you see the ‚Äúfamiliar‚Äù type conversion instead of a vector literal with obscene eyes.  Then the type in parentheses can be removed at the beginning: ‚ÄúAfter all, it is compiled anyway, why unnecessary type conversion?  Already implicitly led. " <br><br>  Real example: <br><br><pre> <code class="cpp hljs">int2 coords = (get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>), get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  <code>coords</code> is not a vector literal given, for a vector literal it was necessary to add a vector type: <br><br><pre> <code class="cpp hljs">int2 coords = (int2)(get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>), get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  We got the following: <code>(get_global_id(0), get_global_id(1))</code> and this is a construction from ordinary C - in brackets the call of two functions through the operator " <code>,</code> " (comma), which means that both functions will be executed and the expression will return the result second function, as if we wrote: <br><br><pre> <code class="cpp hljs">get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); int2 coords = get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  The implicit conversion of a scalar to a vector (about it a little further) will work and the <code>coords</code> will be the vector <code>[get_global_id(1), get_global_id(1)]</code> , rather than <code>[get_global_id(0), get_global_id(1)]</code> , as expected. <br><br>  Fortunately, for simple cases the compiler may issue a warning like ‚Äú <code>warning: expression result unused</code> ‚Äù, but you should not count on it. <br><br>  This code can still be quickly found, because it does not work correctly.  But the following example will work, while the color is gray.  When we want to change the color, for some reason it will still be mockingly gray. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    float3 color = (0.5f, 0.5f, 0.5f); // color=[0.5f, 0.5f, 0.5f]</span></span></code> </pre> <br>  The code works, the project is delivered.  And suddenly it took a slight change - the color of gray to make dark blue. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    float3 color = (0.1f, 0.1f, 0.5f); // color=[0.5f, 0.5f, 0.5f]</span></span></code> </pre> <br>  It was necessary to use the vector literal: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   float3 color = (float3)(0.1f,0.1f, 0.5f); // color=[0.1f,0.1f, 0.5f]</span></span></code> </pre> <br><h2>  Convert Boolean Values ‚Äã‚Äãto Vectors </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; int2 val2 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  What is the value of <code>val</code> ?  What - in <code>val2</code> ? <br><br>  For scalars, the ISO C99 rules apply, when converting the <code>bool</code> value (and the <code>bool</code> type and the constants <code>true</code> and <code>false</code> exist in C99 and in OpenCL C) <code>false</code> becomes zero, and <code>true</code> becomes unity.  These are rules for scalars.  Thus, in <code>val</code> will be "1".  This is not always convenient, but this behavior is embedded in the brain of a programmer ‚Äî constructions like <code>x+=(a&gt;b)</code> no longer surprising. <br><br>  However, in OpenCL C, when converting to a vector integer type, values ‚Äã‚Äãof type <code>bool</code> return either integers with all bits in zero, or all bits in one, which corresponds to <code>(int)-1</code> .  Here is what the <a href="https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf">specification</a> says on this topic (section <i>6.2.2 Explicit Casts</i> ): <br><br><blockquote>  It will be set to -1 (ie all bits set) if it is true. </blockquote><br>  Thus, in <code>val2</code> will be a vector <code>[-1, -1]</code> .  This is a little unexpected in the context of type conversion when the expression is first cast to the type of the vector component, and then multiplies - as for the other types, but for <code>bool</code> exactly this behavior is declared.  With proper use, it allows you to replace conditional expressions with bitwise operations. <br><br>  For quick tests like ‚ÄúCompile or not?  What is the value in the variable? ‚ÄùI wrote and posted the <a href="https://github.com/tmagomedov/opencl-sandbox">opencl-sandbox</a> project on the github.  I checked all the examples from this article on my car.  Including <a href="">this</a> : <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool_to_int_vec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; int2 val2 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"int val = true; // val=%d\n"</span></span>, val); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"int2 val2 = true; // val2=%v2d\n"</span></span>, val2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(val2.x == <span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; val2.y == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Compiler follows specification for bool-&gt;intn conversion, OK\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Compiler does not follow specification for bool-&gt;intn conversion, FAILED\n"</span></span>); } }</code> </pre> <br>  As you know, compiler developers are also people and don‚Äôt remember the specifications by heart. <div class="spoiler">  <b class="spoiler_title">In my car, as a result of the experiment with two platforms, I observed two devices in each:</b> <div class="spoiler_text"> <code>$ ./clrun ../kernels/bool_to_int_vec.cl <br> ... <br> Running "bool_to_int_vec" kernel on AMD Accelerated Parallel Processing / Tonga <br> int val = true; // val=1 <br> int2 val2 = true; // <b>val2=-1,-1</b> <br> Compiler follows specification for bool-&gt;intn conversion, <b>OK</b> <br> ... <br> Running "bool_to_int_vec" kernel on AMD Accelerated Parallel Processing / Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz <br> int val = true; // val=1 <br> int2 val2 = true; // <b>val2=1,1</b> <br> Compiler does not follow specification for bool-&gt;intn conversion, <b>FAILED</b> <br> ... <br> Running "bool_to_int_vec" kernel on Intel(R) OpenCL / Intel(R) HD Graphics <br> int val = true; // val=1 <br> int2 val2 = true; // <b>val2=1,1</b> <br> Compiler does not follow specification for bool-&gt;intn conversion, <b>FAILED</b> <br> ... <br> Running "bool_to_int_vec" kernel on Intel(R) OpenCL / Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz <br> int val = true; // val=1 <br> int2 val2 = true; // <b>val2=1,1</b> <br> Compiler does not follow specification for bool-&gt;intn conversion, <b>FAILED</b></code> <br> </div></div><br>  Two OpenCL platforms - AMD and Intel.  Each platform has two devices - a GPU and a CPU.  And only the AMD compiler for the GPU (the most mature) follows the specification, the other three write to <code>val2</code> vector of units, not -1. <br><br><div class="spoiler">  <b class="spoiler_title">After some time, I checked the same kernel on another machine with three OpenCL implementations ‚Äî from AMD, Intel, and NVidia:</b> <div class="spoiler_text"> <code>... <br> Running "bool_to_int_vec" kernel on AMD Accelerated Parallel Processing / Ellesmere <br> int val = true; // val=1 <br> int2 val2 = true; // val2= <b>-1,-1</b> <br> Compiler follows specification for bool-&gt;intn conversion, <b>OK</b> <br> ... <br> Running "bool_to_int_vec" kernel on AMD Accelerated Parallel Processing / Intel(R) Core(TM) i5-7400 CPU @ 3.00GHz <br> int val = true; // val=1 <br> int2 val2 = true; // val2= <b>1,1</b> <br> Compiler does not follow specification for bool-&gt;intn conversion, <b>FAILED</b> <br> ... <br> Running "bool_to_int_vec" kernel on Intel(R) OpenCL / Intel(R) HD Graphics 630 <br> int val = true; // val=1 <br> int2 val2 = true; // val2= <b>-1,-1</b> <br> Compiler follows specification for bool-&gt;intn conversion, <b>OK</b> <br> ... <br> Running "bool_to_int_vec" kernel on Intel(R) OpenCL / Intel(R) Core(TM) i5-7400 CPU @ 3.00GHz <br> int val = true; // val=1 <br> int2 val2 = true; // val2= <b>-1,-1</b> <br> Compiler follows specification for bool-&gt;intn conversion, <b>OK</b> <br> ... <br> Running "bool_to_int_vec" kernel on NVIDIA CUDA / GeForce GTX 1060 6GB <br> int val = true; // val=1 <br> <b>1,1</b> <br> Compiler does not follow specification for bool-&gt;intn conversion, <b>FAILED</b> <br></code> <br></div></div><br>  There are five devices in the system.  AMD compilers behave the same way.  Intel's more recent compiler has ‚Äúcorrected‚Äù and now behaves in accordance with the standard.  The NVidia compiler failed not only to convert to a vector type, but simply to display the string in the second <code>printf()</code> . <br><br>  There are two conclusions from this: <br><br><ol><li>  without knowledge of the specification, do not write portable code; </li><li>  it is necessary to cover OpenCL kernels with tests, because each platform understands the specifications in its own way. </li></ol><br><br><h2>  Logical and vector comparison operators </h2><br>  As well as to bring <code>bool</code> to <code>int</code> , the corresponding operators have different behavior for scalars and vectors.  Values ‚Äã‚Äãof the result of the operators <code>&gt;</code> , <code>&lt;</code> , <code>&gt;=</code> , <code>&lt;=</code> , <code>==</code> <code>!=</code> , <code>&amp;&amp;</code> , <code>||</code>  <code>!</code>  This is an <code>int</code> .  For scalars, 0 or 1. For vectors, a vector of the appropriate length from <code>int</code> 's with values ‚Äã‚Äãof 0 or -1 (all bits are set to 1). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a=1 int4 b = (int4)(1) &gt; (int4)(0); // b=[-1,-1,-1,-1]</span></span></code> </pre> <br>  When checking on 4 compilers, this time everyone gave the correct result. <br><br><h2>  Ternary operator for vectors </h2><br>  Ternary operator of the form ‚Äú <code>exp1 ? expr2 : expr3</code>  <code>exp1 ? expr2 : expr3</code> "also behaves similarly for scalars and vectors in different ways.  For scalars, as in C99, the result of the expression is <code>expr2</code> if <code>expr1</code> non-zero and <code>exp3</code> if <code>expr1</code> zero. <br><br>  For vectors first, the type <code>expr1</code> can only be integer.  Secondly, when checking the condition in <code>expr1</code> check does not go to equality to zero, or even to the first bit, but to the most <a href="https://en.wikipedia.org/wiki/Most_significant_bit">significant bit</a> .  In this case, the operator works componentwise.  If one of the expressions <code>expr2</code> and <code>expr3</code> is a vector and the other is a scalar, then the scalar is implicitly converted to a vector type with the corresponding components. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a=1 int4 b = (int4)(1, 0, 1, 0) ? (int4)(1) : 0; // b=[0,0,0,0] int4 c = (int4)(-1, 0, -1, 0) ? 1 : (int4)(0); // c=[1,0,1,0] int4 d = (uint4)(0x80000000u, 0, 0, 0) ? (int4)(1) : (int4)(0); // d=[1,0,0,0] //  C99  ,     OpenCL     float e = 0.0f ? 1 : 2; //  , expr1     float4 f = (float4)(0) ? (float4)(1) : (float4)(2); // expr2  expr3     float4 g = (int4)(-1, 1, -1, 1) ? (float4)(1) : (float4)(0); // g=[1.0f, 0.0f, 1.0f, 0.0f]</span></span></code> </pre> <br>  As you can see, here you can again fall into the trap of similarity.  Compare the same code, accurate to vectorization: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a=1 int4 b = (int4)(1) ? (int4)(1) : (int4)(0); // b=[0, 0, 0, 0]</span></span></code> </pre> <br>  Vector <code>b</code> filled with zeros, in full accordance with the specification and to the confusion of the C programmers. <br><br><h2>  Convert real and integer types to OpenCL C </h2><br>  For scalar types, conversions from integer types to real and from real to integer are performed according to the same rules as in C99 ‚Äî that is, when converting from a real number to an integer, the fractional part is discarded; when converting from an integer to a real number, a real number with same value as the original integer.  If the number does not fit into the range of the type to which the conversion occurs - the result depends on the implementation. <br><br>  If you need to interpret data of one type as data of another, then the only way to do this in C99 is to use the <code>memcpy</code> function.  In OpenCL, there is no <code>memcpy</code> , but unlike C99, it is absolutely legal to use <code>union</code> 's to interpret data as data of another type: <br><br><blockquote>  For example, the use of a language is a branch of a different type. </blockquote><br>  On top of that, vector types and iron capabilities for saturation operations are supported - this dictates the features of type conversion in OpenCL. <br><br>  The following types of type conversions are supported: <br><br><ol><li>  Implicit Conversions; </li><li>  explicit cast (Explicit Casts); </li><li>  Explicit Conversions </li><li>  interpretation of data as data of another type (Reinterpreting Data As Another Type). </li></ol><br>  In OpenCL, points 1 and 2 are similar to C99, points 3 and 4 are innovations for the convenience and clarity of working with vector types. <br><br><h3>  Implicit conversions and C type explicit casts </h3><br>  As in C99, if there are operands of different types in the expression, they are converted to the same general type.  The difference is how it works for vectors.  For scalar types, implicit type conversion and explicit type conversion are supported in the same way as in C99: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">5.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a; <span class="hljs-comment"><span class="hljs-comment">// b = 5 float c = 1.6f; int d = (int)c; // d = 1</span></span></code> </pre> <br>  When explicitly or implicitly converting from a scalar type to a vector, the scalar is first converted to the type of a vector element according to the rules similar to C99, and then multiplied to <br>  size vector type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">4.7f</span></span>; float4 b = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int 5 ‚Üí float 5.0f ‚Üí (float4)(5.0f, 5.0f, 5.0f, 5.0f) int4 c = 4.7f; // float 4.7f ‚Üí int 4 ‚Üí (int4)(4, 4, 4, 4) int4 d = 1; // int 1 ‚Üí (int4)(1, 1, 1, 1) int4 e = (int4) a;// float 4.7 ‚Üí int 4 ‚Üí (int4)(4, 4, 4, 4)      float4 f = a; // float 4.7f ‚Üí (float4)(4.7f, 4.7f, 4.7f, 4.7f)</span></span></code> </pre> <br>  Implicit conversion and explicit coercion in the C style of one vector type into another is prohibited.  Even if they have the same number of components. <br><br><pre> <code class="cpp hljs">float4 a = (float4)(<span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ,     int4 b = a; // ,        float4 c = 0; int4 d = (int4)c; // ,        int4 e = (int4)(c); // ,      ‚Äî      float4  int4 int4 f = (int4)(c.xy, c.zw); // ,      ‚Äî      float2  int2 int4 g = (int4)(cx, cy, cz, cw); //      ,       float  int</span></span></code> </pre> <br>  There is no explicit reduction of vector types, however, a scalar can be reduced to a vector type.  This adds additional confusion to vector literals.  Compare three ways to set a vector with the same components: <br><br><pre> <code class="cpp hljs">float2 a = (float2)(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   float2 b = (float2)1; //       float2 c = 1; //      </span></span></code> </pre> <br>  For vectors with different components, the same code does not work, you only need to use a vector literal.  What's the worst, all the code below compiles perfectly, just the results will be relevant: <br><br><pre> <code class="cpp hljs">float2 a, b, c, d; <span class="hljs-comment"><span class="hljs-comment">//    a = (float2)(1, 2); // a=[1, 2] // 1       , 2 ‚Äî  b = (float2)1, 2; // b=[1, 1] // 1       , 2 ‚Äî  c = 1, 2; // c=[1, 1] // 1 , 2        d = (1, 2); // d=[2, 2]</span></span></code> </pre> <br><h3>  Explicit conversion of real and integer types </h3><br>  In addition to C-style type casting, OpenCL has a type-casting mechanism that handles overflow situations and works with vectors.  This is a family of functions. <br><br><pre> <code class="cpp hljs">convert_()</code> </pre> <br>  and more general functions <br><br><pre> <code class="cpp hljs">convert_&lt;_sat&gt;&lt;_&gt;()</code> </pre> <br>  which additionally take overflow mode and rounding mode.  For scalars and vectors, functions work in the same way.  The number of elements in the vectors of the original and the resulting types must match. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">5.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = convert_int(a); <span class="hljs-comment"><span class="hljs-comment">// b = 5 float4 c = a; // c=[5.5, 5.5, 5.5, 5.5] float2 d = convert_float2(c); // ,           //         //        int4 e = convert_int4(c); // e=[5,5,5,5]</span></span></code> </pre> <br>  When casting to integer types, overflow behavior is determined by the optional <br>  modifier <code>_sat</code> .  Without it, the overflow of the integer type occurs as usual in C99, with it the saturation works, the values ‚Äã‚Äãoutside the range allowed by the range are reduced to the closest possible value represented in the converted type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">257</span></span>; uchar b = convert_uchar(a); <span class="hljs-comment"><span class="hljs-comment">// b = 1,   b = convert_uchar_sat(a); // b = 255,  </span></span></code> </pre> <br>  When casting to real types, the use of <code>_sat</code> not allowed.  This is not necessary, because with the overflow of real types, they already become ¬± INF. <br><br>  To control the rounding, the <code>_rte</code> modifiers are provided: <code>_rte</code> (round to nearest even), <code>_rtz</code> (round to zero), <code>_rtp</code> (round to <code>_rtp</code> infinity) and <code>_rtn</code> (round to negative infinity), which designate rounding to the nearest integer, rounding to zero, rounding to plus infinity and rounding to minus infinity respectively.  In the absence of a rounding modifier, <code>_rtz</code> used to convert from real to integer and <code>_rte</code> when converting from integer to real.  In <code>_rte</code> , not the usual mathematics is used, but the so-called ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2580%25D1%2583%25D0%25B3%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">bank</a> ‚Äù version of rounding to the nearest integer.  When the fractional part is exactly 0.5, then there is no one nearest integer number, the even one is chosen from the two nearest ones. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = convert_int_rtp(<span class="hljs-number"><span class="hljs-number">4.2f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// a = 5 a = convert_int(4.2f); // a = 4 int4 b = convert_int4_rte((float4)M_PI_F); // b = [3, 3, 3, 3]</span></span></code> </pre> <br>  Converting <code>float</code> to <code>int</code> with different rounding modes (tested <a href="">here</a> ): <br><br><table><tbody><tr><td></td><td>  0.5 <br></td><td>  -0.5 <br></td><td>  1.1 <br></td><td>  -1.1 <br></td><td>  1.5 <br></td><td>  -1.5 <br></td><td>  1.7 <br></td><td>  -1.7 <br></td></tr><tr><td>  Rounding to the nearest integer <br>  (round to nearest even, rte) <br></td><td>  0 <br></td><td>  0 <br></td><td>  one <br></td><td>  -one <br></td><td>  2 <br></td><td>  -2 <br></td><td>  2 <br></td><td>  -2 <br></td></tr><tr><td>  Rounding to zero <br>  (round towards zero, rtz) <br></td><td>  0 <br></td><td>  0 <br></td><td>  one <br></td><td>  -one <br></td><td>  one <br></td><td>  -one <br></td><td>  one <br></td><td>  -one <br></td></tr><tr><td>  Round to plus infinity <br>  (round toward positive infinity, rtp) <br></td><td>  one <br></td><td>  0 <br></td><td>  2 <br></td><td>  -one <br></td><td>  2 <br></td><td>  -one <br></td><td>  2 <br></td><td>  -one <br></td></tr><tr><td>  Rounding to minus infinity <br>  (round toward negative infinity, rtn) <br></td><td>  0 <br></td><td>  -one <br></td><td>  one <br></td><td>  -2 <br></td><td>  one <br></td><td>  -2 <br></td><td>  one <br></td><td>  -2 <br></td></tr></tbody></table><br>  In the <a href="https://en.wikipedia.org/wiki/Rounding">English-language article about rounding on Wikipedia</a> there is a wonderful <a href="">illustration</a> .  The <code>rte</code> mode on it corresponds to ‚Äúeven‚Äù, <code>rtz</code> - ‚Äúround ‚Üí zero‚Äù, <code>rtp</code> - ‚Äúround up‚Äù, <code>rtn</code> - ‚Äúround down‚Äù. <br><br><h2>  Interpreting data as another type of data </h2><br>  To interpret data of one type as data of another type in OpenCL, there is, in addition to <code>union</code> 's, a family of functions <code>as_()</code> for scalars and vectors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">25.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = as_int(a); <span class="hljs-comment"><span class="hljs-comment">// b=0x41C80000,     25.0f</span></span></code> </pre> <br>  If the size in bytes of the original and the new types do not match, then the <code>as_</code> should cause a compilation error: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> b = as_char(a); <span class="hljs-comment"><span class="hljs-comment">//, sizeof(int)!=sizeof(char) float2 c = 0; float8 d = as_float8(c); //, sizeof(float2)!=sizeof(float8)</span></span></code> </pre> <br>  If the number of elements in the source and new types does not match (but the sizes of the types are the same), the result depends on the implementation of OpenCL (implementation-defined), except for the case when the operand is a 4-component vector, and the result is a 3-component vector.  So, it is convenient to get the bytes of a 32-bit word as elements of a vector: <br><br><pre> <code class="cpp hljs">uint word = <span class="hljs-number"><span class="hljs-number">0x01020304</span></span>; uchar4 bytes = as_uchar4(word);</code> </pre> <br>  But the result can be both <code>[4, 3, 2, 1]</code> , and <code>[1, 2, 3, 4]</code> , and anything, at the discretion of a specific implementation of OpenCL.  However, when optimizing and working on any one version of OpenCL, such use of <code>as_</code> is quite acceptable. <br><br>  If the operand is a 4-component vector, and the result is a 3-component vector, then <br>  <code>as_</code> must return the bits of the original type unchanged - according to the standard <br>  the sizes of the vectors of the three components are equal to the size of the vectors of the four components, if the sizes of their elements are the same. <br><br><pre> <code class="cpp hljs">float4 a = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; int3 b = as_int3(a); <span class="hljs-comment"><span class="hljs-comment">// ,   sizeof(int3)==sizeof(float4) // b=[0x3f800000, 0x3f800000, 0x3f800000] char3 c = as_char3(a); // , sizeof(char3)!=sizeof(float4)</span></span></code> </pre> <br><h2>  Conclusion </h2><br>  OpenCL C is cunning in its similarity to the usual C99.  I hope after reading this article you <br><br><ul><li>  never confuse a vector literal with an explicit type conversion; </li><li>  don't get caught on logical operators in vector types; </li><li>  add the convert_ * and as_ * functions to your arsenal; </li></ul></div><p>Source: <a href="https://habr.com/ru/post/345984/">https://habr.com/ru/post/345984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345972/index.html">TAU for the smallest: an example of the implementation of the PID controller in Unity3D</a></li>
<li><a href="../345974/index.html">Akumuli - time series database</a></li>
<li><a href="../345976/index.html">Docker is dead</a></li>
<li><a href="../345978/index.html">What are the images of the future we draw the largest IT companies</a></li>
<li><a href="../345982/index.html">Emotional burnout volunteers</a></li>
<li><a href="../345988/index.html">The principle of Anna Karenina in programming and IT</a></li>
<li><a href="../345990/index.html">Recovering data from CockroachDB</a></li>
<li><a href="../345994/index.html">About the shape of a rotating fluid</a></li>
<li><a href="../345998/index.html">Why is it bad to be an excellent student</a></li>
<li><a href="../346000/index.html">Business function modeling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>