<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Profiling: measurement and analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, I'm Tony Albrecht, an engineer at Riot. I like to profile and optimize. In this article I will talk about the basics of profiling, as well as anal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Profiling: measurement and analysis</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/2c/tv/26/2ctv26yjae88cmtvy7nnh12bomq.jpeg"></p><br><p>  Hi, I'm Tony Albrecht, an engineer at Riot.  I like to profile and optimize.  In this article I will talk about the basics of profiling, as well as analyze the example of C ++ code during its profiling on a Windows machine.  We will start with the simplest and will gradually delve into the intrinsic of the CPU.  When we meet the possibilities to optimize, we will implement the changes, and in the next article we will analyze real examples from the code base of the game League of Legends.  Go! </p><a name="habracut"></a><br><h2 id="obzor-koda">  Code review </h2><br><p>  First, take a look at the code that we are going to profile.  Our program is a simple little OpenGL renderer, an object-oriented, hierarchical scene tree.  I resourcefully called the main object Object'om - everything in the scene is inherited from one of these base classes.  In our code, only Node, Cube and Modifier are inherited from Object. </p><br><p><img src="https://habrastorage.org/webt/cx/nc/5v/cxnc5vbqvisgejbus7g9p5jvkc4.png"></p><br><p>  Cube is an Object that renders itself on the screen as a cube.  Modifier is an Object that ‚Äúlives‚Äù in the scene tree and, being Updated, transforms the Objects added to it.  A Node is an Object that can contain other Objects. </p><br><p>  The system is designed so that you can create a hierarchy of objects by adding cubes to the nodes, as well as one node to the other nodes.  If you convert a node (using a modifier), then all objects contained in the node will be converted.  With this simple system, I created a tree of cubes rotating around each other. </p><br><p><img src="https://habrastorage.org/webt/7b/w4/4e/7bw44eawi0fruocumqprgay_8go.gif"></p><br><p>  I agree, the proposed code is not the best implementation of the scene tree, but that's okay: this code is needed for subsequent optimization.  In fact, this is a direct porting of an example for PlayStation3¬Æ, which I wrote in 2009 to analyze the performance of <em>Pitfalls of Object Oriented Programming</em> .  In part, we can compare our today's article with a 9-year-old article and see if the lessons we learned once for PS3 apply to modern hardware platforms. </p><br><p>  But back to our cubes.  The above gif shows about 55 thousand rotating cubes.  Please note that I do not profile the rendering of the scene, but only the animation and culling during the transfer to render.  Libraries involved in creating an example: <a href="https://github.com/ocornut/imgui">Dear Imgui</a> and Vectormath from <a href="http://bulletphysics.org/">Bullet</a> are both free.  For profiling, I used AMD <a href="https://gpuopen.com/compute-product/codexl/">Code XL</a> and a simple instrumented profiler, hastily built for this article. </p><br><h2 id="prezhde-chem-perehodit-k-delu">  Before getting down to business </h2><br><h3 id="edinicy-izmereniya">  Units </h3><br><p>  First I want to discuss performance measurement.  Often, games per second use frames per second (FPS).  This is a good indicator of performance, but it is useless when analyzing parts of a frame or comparing improvements from different optimizations.  Suppose, ‚Äúthe game is now running at 20 frames per second faster!‚Äù - is that even how much faster? </p><br><p>  Depends on the situation.  If we had 60 FPS (or 1000/60 = 16,666 milliseconds per frame), and now it is 80 FPS (1000/80 = 12.5 ms per frame), then our improvement is 16.666 ms - 12.5 ms = 4.166 ms on frame.  This is a good increase. </p><br><p>  But if we had 20 FPS, and now it's 40 FPS, then the improvement is already (1000/20 - 1000/40) = 50 ms - 25 ms = 25 ms per frame!  This is a powerful performance boost that can turn a game from ‚Äúunplayable‚Äù to ‚Äúacceptable.‚Äù  The problem with the FPS metric is that it is relative, so we will always use milliseconds.  Is always. </p><br><h3 id="provedenie-zamerov">  Measurement </h3><br><p>  There are several types of profilers, each with its own advantages and disadvantages. </p><br><h4 id="kontrolno-izmeritelnye-profilirovschiki">  Control Profilers </h4><br><p>  For instrumented profiling, the programmer must manually mark a piece of code whose performance needs to be measured.  These profilers capture and save the start and end times of the profiled fragment, focusing on unique markers.  For example: </p><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Node::<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>() { FT_PROFILE_FN <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) { obj-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>(); } }</code> </pre> <br><p>  In this case, <code>FT_PROFILE_FN</code> creates an object that records the time of its creation, and then the destruction when it <code>FT_PROFILE_FN</code> out of scope.  These times along with the name of the function are stored in an array for further analysis and visualization.  If you try, you can implement the visualization in the code or - a little easier - in a tool like <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool">Chrome tracing</a> . </p><br><p>  Measurement profiling is great for visually displaying the performance of a code and detecting its bursts.  If the performance characteristics of the application are presented in the form of a hierarchy, then you can immediately see which functions work most slowly the most, which ones cause the most other functions, which ones have the most duration of execution, etc. </p><br><p><img src="https://habrastorage.org/webt/um/av/xe/umavxepznwmvgsm3ed3zqjxwkt4.png"></p><br><p>  In this illustration, each colored plate corresponds to a function.  Dies located directly under the other dies denote functions that are called "upstream" functions.  The length of the plate is proportional to the duration of the execution of the function. </p><br><p>  Although instrumentation profiling provides valuable visual information, it still has flaws.  It slows down the execution of the program: the more you measure, the slower the program becomes.  Therefore, when writing a measurement profiler, try to minimize its impact on application performance.  If you skip the slow function, a large gap in the profile will appear.  Also, you will not get information about the speed of each line of code: you can easily mark only visibility areas, but the overhead of measuring and profiling usually nullifies the contribution of individual lines, so measuring them is simply useless. </p><br><h4 id="sempliruyuschie-profilirovschiki">  Sampling Profilers </h4><br><p>  Sampling profiles request the execution status of the process you want to profile.  They periodically save the program counter (PC), showing which instruction is currently being executed, and also keep the stack, so you can find out what functions the function called that contains the current instruction called.  All this information is useful, since the function or lines with the largest number of samples will be the slowest function or lines.  The longer the sampling profiler is running, the more samples of instructions and stacks are collected, which improves the results. </p><br><p><img src="https://habrastorage.org/webt/x5/bn/5w/x5bn5wd_i-t1o4z_ywztm0ttllk.png"></p><br><p>  Sampling profilers allow you to collect very low-level performance characteristics of the program and do not require manual intervention, as is the case with instrumentation profilers.  In addition, they automatically cover the entire execution status of your program.  These profilers have two major drawbacks: they are not very useful for defining bursts for each frame, and also do not allow to know when a certain function was called relative to other functions.  That is, we get less information about hierarchical calls compared to a good measuring profiler. </p><br><h4 id="specializirovannye-profilirovschiki">  Specialized Profilers </h4><br><p>  These profilers provide specific process information.  Usually they are associated with hardware elements like a CPU or a video card that are capable of generating specific events if something of interest is happening, such as a cache miss or an erroneous branch prediction.  Equipment manufacturers are building the ability to measure these events so that it is easier for us to find out the reasons for poor performance;  therefore, to understand these profiles, knowledge of the hardware used is needed. </p><br><h4 id="profilirovschiki-prednaznachennye-dlya-konkretnyh-igr">  Game Profilers </h4><br><p>  At a much more general level, profilers designed for specific games can calculate, say, the number of minions on the screen or the number of visible particles in a character's field of view.  Such profilers are also very useful, they will help to identify high-level errors in the game logic. </p><br><h2 id="profilirovanie">  Profiling </h2><br><p>  Profiling an application without a benchmark does not make sense, so when optimizing, you need to have a reliable test script at hand.  This is not as easy as it sounds.  Modern computers perform not only your application, but at the same time dozens, if not hundreds of other processes, constantly switching between them.  That is, other processes may slow down the process you are profiling as a result of competition for accessing devices (for example, several processes are trying to be counted from disk) or for processor / video card resources.  So in order to get a good starting point, you need to run the code through several profiling operations before you even get down to the task.  If the results of the runs are very different, then you have to figure out the reasons and get rid of the variability or at least reduce it. </p><br><p>  Having achieved the smallest possible variation in results, do not forget that small improvements (less than the available variation) will be difficult to measure, because they can be lost in the "noise" of the system.  Suppose a particular scene in the game is displayed in the range of 14-18 ms per frame, an average of 16 ms.  You spent two weeks optimizing some function, repurposed it and got 15.5 ms per frame.  Has it become faster?  To find out exactly, you will have to chase the game many times, profiling this scene and calculating the arithmetic mean and plotting the trend.  In the application described here, we measure hundreds of frames and average the results to get a fairly reliable value. </p><br><p>  In addition, many games are executed in several streams, the order of which is determined by your hardware and operating system, which can lead to non-deterministic behavior or at least to different duration of execution.  Do not forget about the influence of these factors. </p><br><p>  In connection with the above, I collected a small test script for profiling and optimization.  It is simple to understand, but complex enough to have a resource of significant performance improvement.  Note that for the sake of simplicity, I turned off rendering when profiling, so that we only see the computational costs associated with the central processor. </p><br><h3 id="profiliruem-kod">  Profile the code </h3><br><p>  Below is the code that we will optimize.  Remember that one example will only teach us about profiling.  You will certainly encounter unexpected difficulties when profiling your own code, and I hope that this article will help you create your own diagnostic framework. </p><br><pre> <code class="hljs php">{ FT_PROFILE(<span class="hljs-string"><span class="hljs-string">"Update"</span></span>); mRootNode-&gt;Update(); } { FT_PROFILE(<span class="hljs-string"><span class="hljs-string">"GetWBS"</span></span>); BoundingSphere totalVolume = mRootNode-&gt;GetWorldBoundingSphere(Matrix4::identity()); } { FT_PROFILE(<span class="hljs-string"><span class="hljs-string">"cull"</span></span>); uint8_t clipFlags = <span class="hljs-number"><span class="hljs-number">63</span></span>; mRootNode-&gt;Cull(clipFlags); } { FT_PROFILE(<span class="hljs-string"><span class="hljs-string">"Node Render"</span></span>); mRootNode-&gt;Render(mvp); }</code> </pre> <br><p>  I added the <code>FT_PROFILE()</code> control macro to different scopes to measure the duration of execution of different parts of the code.  Below we will talk more about the purpose of each fragment. </p><br><p>  When I ran the code and recorded the data from the measured profile, I received the following picture in Chrome: // tracing: </p><br><p><img src="https://habrastorage.org/webt/l1/tv/j8/l1tvj8knj8y4xcektm9fiwjxa2c.png"></p><br><p>  This is a single frame profile.  Here we see the relative duration of each function call.  Please note that you can see the order of execution.  If I measured the functions that are called by these function calls, they would be displayed under the dies of the parent functions.  For example, I measured <code>Node::Update()</code> and got the following recursive call structure: </p><br><p><img src="https://habrastorage.org/webt/ab/7i/3h/ab7i3hth7psgj5o3_g8ckyzcktg.png"></p><br><p>  The duration of the execution of one frame of this code when measured varies by a couple of milliseconds, so we take the arithmetic mean for at least several hundred frames and compare it with the original standard.  In this case, 297 frames were measured, the average value was 17.5 ms, some frames were executed up to 19 ms, and others were slightly less than 16.5 ms, although in each of them almost the same thing was done.  Such is the implicit variation in frames.  Repeated run and comparison of results consistently give us about 17.5 ms, so this value can be considered as a reliable starting point. </p><br><p><img src="https://habrastorage.org/webt/kn/8i/aj/kn8iajjv5iqny_qoktym7fegwia.png"></p><br><p>  If you disable check marks in the code and run it through the <a href="https://gpuopen.com/compute-product/codexl/">AMD CodeXL</a> sampling profiler, you get the following picture: </p><br><p><img src="https://habrastorage.org/webt/j1/qv/ft/j1qvftnvjzefd-sj3yyrrokgqty.png"></p><br><p>  If we analyze the five most "sought-after" functions, we get: </p><br><p><img src="https://habrastorage.org/webt/ih/k0/tz/ihk0tzmcqf7metdwmnqrq5gypao.png"></p><br><p>  It seems that the slowest function is matrix multiplication.  It sounds logical, because for all these rotations, the function has to perform a bunch of calculations.  If you look closely at the stack hierarchy with a couple of illustrations above, you will notice that the matrix multiplication operator is called by <code>Modifier::Update()</code> , <code>Node::Update()</code> , <code>GetWorldBoundingSphere()</code> and <code>Node::Render()</code> .  It is called so often and from so many places - so this operator can be considered a good candidate for optimization. </p><br><h4 id="matrixoperator">  Matrix :: operator * </h4><br><p>  If you analyze the code responsible for multiplication using the sampling profiler, you can find out the "cost" of each line. </p><br><p><img src="https://habrastorage.org/webt/0i/lp/br/0ilpbroon3ja3l2z_4tfzrdxmak.png"></p><br><p>  Unfortunately, the length of the matrix multiplication code is just one line (for the sake of efficiency), so this result does little for us.  Or is it not so little? </p><br><p>  If you look at the assembler, you can identify the prologue and epilogue of the function. </p><br><p><img src="https://habrastorage.org/webt/wv/u9/6g/wvu96gkr97ptsfltyn3getun9gw.png"></p><br><p>  This is the cost of an internal function call instruction.  In the prologue, a new stack space is set (ESP is the current stack pointer, EBP is the base pointer for the current stack frame), and the epilogue is cleared and returned.  Each time you call a function that is not inline and uses any stack space (that is, it has a local variable), all these instructions can be inserted and called. </p><br><p>  Let's expand the rest of the function and see what matrix multiplication actually does. </p><br><p><img src="https://habrastorage.org/webt/np/68/zy/np68zyfyql5plpwkw0ri73-su_8.png"></p><br><p>  Wow, a lot of code!  And this is only the first page.  The full function takes more than a kilobyte of code with 250‚Äì300 instructions!  Let's analyze the beginning of the function. </p><br><p><img src="https://habrastorage.org/webt/zv/d8/f0/zvd8f0ldlqszwcb9vhqvnlfxq40.png"></p><br><p>  The line above the highlighted blue color takes about 10% of the total execution time.  Why is it performed much slower than its neighbors?  This MOVSS instruction takes from the memory at eax + 34h a floating point value and puts in the xmm4 register.  The line above does the same thing with the xmm1 register, but much faster.  Why? </p><br><p>  It's all a cache miss. </p><br><p>  We will understand in more detail.  Sampling of individual instructions is applicable in a variety of situations.  Modern processors at any time carry out several instructions, and within one clock cycle many instructions can be re-sorted.  Even event-based sampling can attribute events to the wrong instruction.  So when analyzing sampler assembly, you need to be guided by some kind of logic.  In our example, the most sampled instruction may not be the slowest.  We can only speak with a certain degree of confidence about the slow work of something related to this line.  And since the processor performs a number of MOVs in and out of memory, suppose that these MOVs are to blame for the poor performance.  To verify this, you can run a profile with enabled event-based sampling for cache misses and look at the result.  But for the time being, we will trust our instincts and drive out the profile based on the cache miss hypothesis. </p><br><p>  Passing the L3 cache takes more than 100 cycles (in some cases, several hundred cycles), and the L2 cache miss is about 40 cycles, although it all depends heavily on the processor.  For example, x86- <a href="http://www.agner.org/optimize/instruction_tables.pdf">instructions</a> take from 1 to about 100 cycles, with the majority being less than 20 cycles (some division instructions on some gland work rather slowly).  On my Core i7, the instructions for multiplying, adding and even dividing took several cycles.  The instructions fall into the pipeline, so that several instructions are processed simultaneously.  This means that one miss of the L3 cache ‚Äî loading directly from memory ‚Äî can take hundreds of instructions to execute.  Simply put, reading from memory is a very slow process. </p><br><p><img src="https://habrastorage.org/webt/q-/17/g_/q-17g_xbjlj85xmqxv7btydet6m.gif"></p><br><h4 id="modifierupdate">  Modifier :: Update () </h4><br><p>  So, we see that accessing memory slows down the execution of our code.  Let's go back and see what in the code leads to this conversion.  The test profiler shows that <code>Node::Update()</code> is running slowly, and from the sampling profiler report about the stack, it is obvious that the <code>Modifier::Update()</code> function is especially slow.  With this, we will start optimization. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Modifier::<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) { Matrix4 mat = obj-&gt;GetTransform(); mat = mTransform*mat; obj-&gt;SetTransform(mat); } }</code> </pre> <br><p>  <code>Modifier::Update()</code> passes through the vector of pointers to Objects, takes their transform matrix, multiplies it by the <code>mTransform</code> Modifier matrix, and then applies this transformation to Objects.  In the above code, the conversion is copied from object to stack, multiplied, and then copied back. </p><br><p>  <code>GetTransform()</code> simply returns a copy of <code>mTransform</code> , while <code>SetTransform()</code> copies the new matrix to <code>mTransform</code> and sets the <code>mDirty</code> state of this object: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDirty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dirty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dirty &amp;&amp; (dirty != mDirty)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mParent) mParent-&gt;SetDirty(dirty); } mDirty = dirty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTransform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix4&amp; transform)</span></span></span><span class="hljs-function"> </span></span>{ mTransform = transform; SetDirty(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Matrix4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTransform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mTransform; }</code> </pre> <br><p>  The inner data layer of this Object looks like this: </p><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Matrix4 mTransform; Matrix4 mWorldTransform; BoundingSphere mBoundingSphere; BoundingSphere mWorldBoundingSphere; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_IsVisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* mName; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mDirty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>* mParent; };</code> </pre> <br><p>  For clarity, I colored the entries in the memory of the Node object: </p><br><p><img src="https://habrastorage.org/webt/6j/qe/wo/6jqewovpmiq90xrl-guxt3dsin4.png"></p><br><p>  The first entry is a virtual table pointer.  This is part of the implementation of inheritance in C ++: a pointer to an array of function pointers that act as virtual functions for this particular polymorphic object.  For Object, Node, Modifier, and any class that inherits from the base class, there are different virtual tables. </p><br><p>  After this 4-byte pointer, there is a 64-byte array of floating-point numbers.  Behind the <code>mTransform</code> matrix goes the <code>mTransform</code> matrix, and then the two bounding spheres.  Note that the next entry, <code>m_IsVisible</code> , is single-byte; it takes 4 full bytes.  This is normal, since the next entry is a pointer that must have at least 4-byte alignment.  If, after <code>m_IsVisible</code> put another boolean value, then it would be packed into available 3 bytes.  Next comes the <code>mName</code> pointer (with 4-byte alignment), then the boolean <code>mDirty</code> (also loosely packed), then the pointer to the parent Object.  All of this is Object-specific data.  The subsequent <code>mObjects</code> vector <code>mObjects</code> belongs to the Node vector and occupies 12 bytes on this platform, although on other platforms it may be of a different size. </p><br><p>  If we look at the <code>Modifier::Update()</code> code, we will see what could be the cause of a cache miss. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Modifier::<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) {</code> </pre> <br><p>  To begin with, we note: the <code>mObjects</code> vector is an array of pointers to Objects, which are dynamically allocated in memory.  Iteration over this vector works well with the cache (the red arrows in the illustration below), since the pointers follow one after the other.  There are a few blunders there, but they point to something that is probably not adapted to work with the cache.  And since each Object is placed in memory with a new pointer, we can only say that our interference is somewhere in memory. </p><br><p><img src="https://habrastorage.org/webt/kc/hv/q9/kchvq9hxfgw7g2ehel48zgkqztw.png"></p><br><p>  When we get a pointer to an Object, we call <code>GetTransform()</code> : </p><br><pre> <code class="hljs lisp">Matrix4 mat = obj-&gt;GetTransform()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  This inline function simply returns a copy of <code>mTransform</code> Object, so the previous line is equivalent to this: </p><br><pre> <code class="hljs erlang-repl">Matrix4 mat = obj-&gt;mTransform;</code> </pre> <br><p>  As you can see in the diagram, the Objects referenced by the pointers in the <code>mObjects</code> array are scattered across memory.  Every time we add a new Object and call <code>GetTransform()</code> , this certainly results in a cache miss when loaded into <code>mTransform</code> and placed on the stack.  On the hardware I use, the cache line is 64 bytes, so if you're lucky and the object starts 4 bytes before the 64-byte border, <code>mTransform</code> will be loaded into the cache all at once.  But more likely is the situation when loading <code>mTransform</code> will result in two cache slips.  From the sampling profile of <code>Modifier::Update()</code> it is obvious that the matrix is ‚Äã‚Äãaligned randomly. </p><br><p><img src="https://habrastorage.org/webt/cf/ou/2q/cfou2qutul85vug8bunrziv7jtg.png"></p><br><p>  In this snippet, <code>edx</code> is the location of the Object.  And as we know, <code>mTransform</code> begins 4 bytes before the beginning of the object.  So this code copies <code>mTransform</code> to the stack (MOVUPS copies 4 floating-point values ‚Äã‚Äãto the register).  Pay 7% access to three MOVUPS instructions.  This suggests that cache misses are also found in the case of MOVs.  I do not know why the first MOVUPS per stack does not take as much time as the others.  It seems to me that the ‚Äúcosts‚Äù are simply transferred to subsequent MOVUPS due to the peculiarities of pipelining instructions.  But in any case, we received evidence of the high cost of memory access, so we will work with it. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Modifier::<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) { Matrix4 mat = obj-&gt;GetTransform(); mat = mTransform*mat; obj-&gt;SetTransform(mat); } }</code> </pre> <br><p>  After the matrix is ‚Äã‚Äãmultiplied, we call <code>Object::SetTransform()</code> , which takes the result of the multiplication (freshly placed onto the stack) and copies it into the Object instance.  Copying is fast, because the conversion is already cached, but <code>SetDirty()</code> is slow because it reads the <code>mDirty</code> flag, it is probably not in the cache.  So for testing and, possibly, determining this one byte, the processor has to read the surrounding 63 bytes. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  If you have read to the end - well done!  I know, at first it is difficult, especially if you are not familiar with the assembler.  But I highly recommend taking the time and see what the compilers do with the code they write.  To do this, you can use the <a href="https://godbolt.org/">Compiler Explorer</a> . </p><br><p>  We have gathered some evidence that the main cause of performance problems in our example code is memory access pointers.  Next, we minimize the cost of memory access, and then measure the performance again to see if it was possible to achieve improvement.  This we will do next time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351320/">https://habr.com/ru/post/351320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351308/index.html">Comparison of open OLAP-systems Big Data: ClickHouse, Druid and Pinot</a></li>
<li><a href="../351310/index.html">SSH in humans is not secure enough. How I struggle with paranoia</a></li>
<li><a href="../351312/index.html">3. Check Point for maximum. Content Awareness</a></li>
<li><a href="../351316/index.html">Introvert management introverts or experience managing technical teams</a></li>
<li><a href="../351318/index.html">John Carmack: Weekly vacation spent programming</a></li>
<li><a href="../351322/index.html">Evil by Design: interfaces from Mephistopheles (part one)</a></li>
<li><a href="../351324/index.html">Distant Joining: choose a representative set of genes</a></li>
<li><a href="../351326/index.html">Information security of bank non-cash payments. Part 4 - Overview of Threat Modeling Standards</a></li>
<li><a href="../351328/index.html">Uncompetitive wrestling: how crossover tournaments have changed in their first year</a></li>
<li><a href="../351332/index.html">What is PAT? Lab at Packet Tracer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>