<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Probability in algorithms. Yandex lecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many algorithms are deterministic - that is, the sequence of their actions depends only on the input data and the program. But what will happen if the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Probability in algorithms. Yandex lecture</h1><div class="post__text post__text-html js-mediator-article">  Many algorithms are deterministic - that is, the sequence of their actions depends only on the input data and the program.  But what will happen if the algorithm allows random numbers to be used in the course of work? <br><br>  It turns out that then interesting results become possible, which cannot be achieved with the help of ordinary algorithms.  For example, it is possible to build a hash function for which the adversary cannot easily pick up collisions.  Or process a large set of numbers and compress it many times, while retaining the ability to check the belonging of numbers to the original set.  You can approximately count the number of different elements in the data stream, having only a small amount of additional memory.  In <a href="http://tech.yandex.ru/education/m/shad/talks/655/">this lecture,</a> Maxim Babenko tells the students how exactly this happens. <br><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://video.yandex.ru/iframe/ya-events/m-67435-1503f013c31-6a33919b33eefee3/&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhiS2Tx2TcSAoQ-_wY-e6WsV7-NPGQ" width="450" height="253" frameborder="0" scrolling="no" allowfullscreen="1"></iframe><br><a name="habracut"></a><br><h4>  Hash functions </h4><br>  Suppose we want to come up with a data structure, which in computer science is called an associative table.  In this table, pairs of components are written in two columns.  The first column is called the ‚Äúkey‚Äù and the second is the ‚Äúvalue‚Äù.  The key, for example, can be the name of a person, and the value is his address.  Our task is to quickly perform a search on this table: to find a line in the table where a certain key is present, and to give the corresponding value.  The option to view the entire table from top to bottom does not suit us, since we want to search quickly.  If the number of rows in the table is taken as n, then the search time should be substantially less than n.  We believe that in our table all the keys are unique.  If the keys were integers, then everything would be simple enough.  It would be necessary to create an array in which elements will be indexed with possible key values ‚Äã‚Äãin the range from zero to m - 1, where m is not too large.  This approach is good because with this method of data storage, in order for key k to refer to the corresponding row and find the corresponding value, it is necessary to spend the constant time O (1).  The disadvantage of this method is that if, for example, strings are used as keys instead of numbers, you will have to encode these strings with numbers.  And with this encoding, the numerical range will be too large. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And here hashing comes to our rescue.  Suppose we still have a table of size m, but this time m will have nothing to do with what keys we have.  The keys here are some kind of integers.  How do we, under these conditions, find the position of the key k in the table?  Suppose we know a certain function - h (k), called the hash function.  It for a given k tells us which cell of m possible contains this key.  If you do not consider exactly how the hash function works, then everything looks very simple.  But there is a catch.  First, we have infinitely many possible key values, and the hash function maps to a finite set.  Therefore, of course, when two different keys after applying a hash function fall into the same cell: it is not clear how we can store them at the same time.  Such situations are called collisions, and you need to be able to deal with them.  There are many ways to fight.  One of the simplest, but at the same time quite effective way is to assume that the cells do not contain values, and even for pairs of key - value, but a whole list of pairs.  These are all pairs in which the keys, under the action of the hash function, take on some specific value.  This is called the resolution of collisions by the chain method. <br><br>  The key point here is the choice of a hash function.  This is what affects performance.  If we choose h (k) = 0, then all our hashes will be zero, and in the end we will get one chain in which we will search all the time.  It is very slow and unprofitable.  But if the values ‚Äã‚Äãof the hash functions are to some extent random, then this will not happen. <br><br><h4>  Randomness </h4><br>  Consider the concept of randomness from the point of view of mathematics, or rather, a discrete version of this concept.  Suppose we have a regular hex dice.  Throwing it, we generate some randomness.  Those.  we have a lot of elementary events - Œ©.  In our case, the elementary event will be the face that will be on top after the cube completely stops.  Denote the faces (a, b, c, d, e, f).  Next, we need to set the probability distribution: create a function that, for each elementary event, will say what its probability is from zero to one.  Since  if our cube is even and hex, then the probability of each side should fall to 1/6. <br>  The random variable in our case is any function defined on elementary events.  If we enumerate the faces of a cube by numbers from 1 to 6, then the number corresponding to the dropped face will be a random variable. <br><br>  Now consider the concept of the average random variable.  If elementary events we have are entities (a <sub>1</sub> , ..., a <sub>n</sub> ), and the probabilities assigned to them are (p <sub>1</sub> , ..., p <sub>n</sub> ), and our function maps elementary events to values ‚Äã‚Äã(x <sub>1</sub> , ..., x <sub>n</sub> ), then we call the average a weighted sum of the form x <sub>1</sub> p <sub>1</sub> + x <sub>2</sub> p <sub>2</sub> + ... x <sub>n</sub> p <sub>n</sub> .  Those.  you need to see what values ‚Äã‚Äãare accepted and with what probabilities, and then average with a coefficient that is equal to the probability of occurrence of one or another elementary event. <br><br><h4>  Markov's inequality </h4><br>  The informal meaning of this lemma is this: if a random variable does not have a very large mean, then it often cannot take large values.  We consider the formal formulation of the problem and the proof.  Let the discrete probabilistic space (Œ©, p) and a random variable on it ‚Äî f * Œ© ‚Üí R <sub>1</sub> be defined.  We are interested in the probability of such an event that the random variable has assumed a value greater than or equal to Œµ, where Œµ is some positive number. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/410/0ee/807/4100ee8076b7d39c88f9973c106736c2.png" alt="image"><br><br>  We turn to the proof.  The proved inequality can be rewritten differently: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe9/ff0/d8f/fe9ff0d8f56eb721d6807eff79af686a.png" alt="image"><br><br>  Recall that E [f] = x <sub>1</sub> p <sub>1</sub> + x <sub>2</sub> <sub>2</sub> + ‚ãØ + x <sub>n</sub> p <sub>n</sub> .  From this we can draw the following conclusion: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5d/5c0/d86/a5d5c0d862574d85ad887b777fded243.png" alt="image"><br><br>  After watching the lecture to the end, you will also learn how the above constructions help to build hash functions with a low probability of collisions, and to perform other algorithmic tasks that without the use of random numbers would be impossible or less efficiently solved. </div><p>Source: <a href="https://habr.com/ru/post/211018/">https://habr.com/ru/post/211018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211004/index.html">E-commerce trends: What is most important for an online store? Part 1</a></li>
<li><a href="../211008/index.html">Impact of Motorola Mobility Absorption by IBM-Lenovo Alliance</a></li>
<li><a href="../211012/index.html">Transparent encryption of network folders in the corporate space</a></li>
<li><a href="../211014/index.html">HGST HelioSeal - a promising platform for the next decade</a></li>
<li><a href="../211016/index.html">Pocket PaaS with Dokku</a></li>
<li><a href="../211020/index.html">About security in Meteor and not only (part 2)</a></li>
<li><a href="../211022/index.html">Use EXPLAIN. Query enhancement</a></li>
<li><a href="../211024/index.html">Proxmox API. Introduction</a></li>
<li><a href="../211026/index.html">You like to read exciting books - love and wear a vest ...</a></li>
<li><a href="../211028/index.html">Browser game "Cyberset" - continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>