<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Description of sorting algorithms and comparison of their performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Many articles have already been written on this topic. However, I have not yet seen the article, which compares all the basic sorting o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Description of sorting algorithms and comparison of their performance</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Many articles have already been written on this topic.  However, I have not yet seen the article, which compares all the basic sorting on a large number of tests of different types and sizes.  In addition, the implementation and description of the test suite are far from being everywhere.  This leads to the fact that there may be doubts about the correctness of the study.  However, the goal of my work is not only to determine which sorts work the fastest (in general, this is already known).  First of all, I was interested in exploring algorithms, optimizing them so that they work as quickly as possible.  Working on this, I managed to come up with an effective formula for sorting Shell. <br><br>  In many ways, the article is devoted to how to write all the algorithms and test them.  If we talk about programming itself, sometimes unexpected difficulties may arise (largely due to the C ++ optimizer).  However, it is equally difficult to decide which tests exactly and in what quantities should be done.  Codes of all algorithms that are laid out in this article, written by me.  Run results are available on all tests.  The only thing I can‚Äôt show is the tests themselves, since they weigh almost 140 GB.  At the slightest suspicion, I checked both the code corresponding to the test and the test itself.  I hope you enjoy the article. <br><a name="habracut"></a><br><h2>  Description of the main sorts and their implementation </h2><br>  I will try to briefly and clearly describe the sorting and specify the asymptotics, although the latter is not very important in the framework of this article (it is interesting to know the real time of work).  I will not write anything about memory consumption in the future, I will only note that sortings that use complicated data structures (such as tree sorting) usually consume it in large quantities, and other sortings in the worst case only create an auxiliary array.  There is also the concept of stability (sustainability) sorting.  This means that the relative order of elements does not change when they are equal.  This is also unimportant within the framework of this article (after all, you can simply attach an index to an element), but it will be useful in one place. <br><br><h4>  Bubble sort </h4><br>  We will go through the array from left to right.  If the current item is greater than the next one, swap them.  Do this until the array is sorted.  Note that after the first iteration, the largest element will be at the end of the array, in the right place.  After two iterations, the two largest elements will stand in the right place, and so on.  Obviously, no more than after n iterations the array will be sorted.  Thus, the asymptotics in the worst and average case is O (n <sup>2</sup> ), at best O (n). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubblesort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sz &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (b) { b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* i = l; i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; r; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i &gt; *(i + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { swap(*i, *(i + <span class="hljs-number"><span class="hljs-number">1</span></span>)); b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } r--; } }</code> </pre> </div></div><br><h4>  Shaker sort / Shaker sort </h4><br>  (also known as mixing and cocktail sorting).  Note that bubble sorting works slowly on tests, in which small elements stand at the end (they are also called ‚Äúturtles‚Äù).  Such an element at each step of the algorithm will move only one position to the left.  Therefore, we will go not only from left to right, but also from right to left.  We will support two pointers begin and end, denoting which segment of the array has not yet been sorted.  At the next iteration, when reaching end, subtract a unit from it and move from right to left, similarly, when you reach begin, add one and move from left to right.  The asymptotics of the algorithm is the same as that of bubble sorting, but the real time is better. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs matlab">void shakersort(int* l, int* r) { int sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sz &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; bool b = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span>; int* beg = l - <span class="hljs-number"><span class="hljs-number">1</span></span>; int* <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = r - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (b) { b = <span class="hljs-built_in"><span class="hljs-built_in">false</span></span>; beg++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int* <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = beg; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &gt; *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { swap(*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)); b = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!b) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int* <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &gt; beg; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { swap(*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>)); b = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span>; } } } }</code> </pre> </div></div><br><h4>  Comb sort </h4><br>  Another modification of the sorting bubble.  In order to get rid of "turtles", we will rearrange the elements that are at a distance.  We fix it and we will go from left to right, comparing the elements standing at this distance, rearranging them, if necessary.  Obviously, this will allow "turtles" to quickly get to the beginning of the array.  It is optimal to initially take the distance equal to the length of the array, and then divide it by some coefficient equal to about 1.247.  When the distance is equal to one, the bubble is sorted.  At best, the asymptotics is O (nlogn), at worst, O (n <sup>2</sup> ).  What is the average asymptotics for me is not very clear; <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs matlab">void combsort(int* l, int* r) { int sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sz &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; double k = <span class="hljs-number"><span class="hljs-number">1.2473309</span></span>; int step = sz - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (step &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int* <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = l; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + step &lt; r; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &gt; *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + step)) swap(*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + step)); } step /= k; } bool b = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (b) { b = <span class="hljs-built_in"><span class="hljs-built_in">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int* <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = l; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; r; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &gt; *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { swap(*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)); b = <span class="hljs-built_in"><span class="hljs-built_in">true</span></span>; } } } }</code> </pre> </div></div><br>  You can also read about these sortings (bubble, shaker and comb) <a href="https://habrahabr.ru/post/204600/">here</a> . <br><br><h4>  Sort Inserts / Insertion sort </h4><br>  Let's create an array in which after the completion of the algorithm will be the answer.  Let us alternately insert elements from the source array so that the elements in the response array are always sorted.  The average and worst case asymptotics is O (n <sup>2</sup> ); at best, O (n).  It is more convenient to implement the algorithm in a different way (creating a new array and actually inserting something into it is relatively difficult): we simply make sure that some prefix of the original array is sorted, instead of inserting, we will change the current element with the previous one while they are in the wrong order. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs matlab">void insertionsort(int* l, int* r) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = l + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; r; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { int* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &gt; l &amp;&amp; *(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; *<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) { swap(*(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>), *<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>--; } } }</code> </pre> </div></div><br><h4>  Shellsort </h4><br>  Use the same idea as sorting with a comb, and apply to sorting inserts.  Fix some distance.  Then the elements of the array will be divided into classes ‚Äî elements fall into one class, the distance between which is a multiple of the fixed distance.  Sort by insertion sorting each class.  Unlike the sorting comb, the optimal set of distances is unknown.  There are quite a few sequences with different ratings.  Shell sequence - the first element is equal to the length of the array, each following one half the previous one.  In the worst case, the asymptotics is O (n <sup>2</sup> ).  Hibbard sequence - 2 <sup>n</sup> - 1, asymptotics in the worst case - O (n <sup>1,5</sup> ), Sedgwik sequence (the formula is nontrivial, you can see it by the link below) - O (n <sup>4/3</sup> ), Pratt (all products of powers of two and triples) - O (nlog <sup>2</sup> n).  I note that all these sequences need to be calculated only to the size of the array and run from the larger one to the smaller one (otherwise, it will just be sorting by inserts).  I also conducted additional research and tested different sequences of the form s <sub>i</sub> = a * s <sub>i - 1</sub> + k * s <sub>i - 1</sub> (partly this was inspired by the empirical Tsiura sequence - one of the best distance sequences for a small number of elements).  The best were sequences with coefficients a = 3, k = 1/3;  a = 4, k = 1/4 and a = 4, k = -1/5. <br><br>  Some useful links: <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25A8%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B0">Sorting Shell in Russian Wikipedia</a> <br>  <a href="https://en.wikipedia.org/wiki/Shellsort">Sort Shell in English Wikipedia</a> <br>  <a href="https://habrahabr.ru/post/204968/">Article on Habr√©</a> <br><br><div class="spoiler">  <b class="spoiler_title">Implementations:</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">void shellsort(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = sz / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">step</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } } void shellsorthib(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sz &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) return; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">step</span></span> &lt; sz) <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">step</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> steps[<span class="hljs-number"><span class="hljs-number">100</span></span>]; void shellsortsedgwick(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l; steps[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> q = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">3</span></span> &lt; sz) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) steps[q] = <span class="hljs-number"><span class="hljs-number">9</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; q) - <span class="hljs-number"><span class="hljs-number">9</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (q / <span class="hljs-number"><span class="hljs-number">2</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> steps[q] = <span class="hljs-number"><span class="hljs-number">8</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; q) - <span class="hljs-number"><span class="hljs-number">6</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; ((q + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; q++; } q--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; q--) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = steps[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } } } void shellsortpratt(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l; steps[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">1</span></span>, q = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; sz; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur &gt; sz / <span class="hljs-number"><span class="hljs-number">2</span></span>) break; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; sz; j++) { cur *= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur &gt; sz / <span class="hljs-number"><span class="hljs-number">2</span></span>) break; steps[q++] = cur; } } insertionsort(steps, steps + q); q--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; q--) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = steps[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } } } void myshell1(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l, q = <span class="hljs-number"><span class="hljs-number">1</span></span>; steps[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; sz) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> s = steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>]; steps[q++] = s * <span class="hljs-number"><span class="hljs-number">4</span></span> + s / <span class="hljs-number"><span class="hljs-number">4</span></span>; } q--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; q--) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = steps[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } } } void myshell2(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l, q = <span class="hljs-number"><span class="hljs-number">1</span></span>; steps[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; sz) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> s = steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>]; steps[q++] = s * <span class="hljs-number"><span class="hljs-number">3</span></span> + s / <span class="hljs-number"><span class="hljs-number">3</span></span>; } q--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; q--) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = steps[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } } } void myshell3(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* l, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>* r) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sz = r - l, q = <span class="hljs-number"><span class="hljs-number">1</span></span>; steps[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; sz) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> s = steps[q - <span class="hljs-number"><span class="hljs-number">1</span></span>]; steps[q++] = s * <span class="hljs-number"><span class="hljs-number">4</span></span> - s / <span class="hljs-number"><span class="hljs-number">5</span></span>; } q--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; q--) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = steps[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *i = l + <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; i &lt; r; i++) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *j = i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (diff &gt;= l &amp;&amp; *diff &gt; *j) { swap(*diff, *j); j = diff; diff = j - <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; } } } }</code> </pre> </div></div><br><h4>  Sort tree / tree sort </h4><br>  We will insert elements into the binary search tree.  After all the elements are inserted, it is enough to go around the tree to the depth and get a sorted array.  If you use a balanced tree, such as red-black, the asymptotics will be equal to O (nlogn) in the worst, average and best.  In the implementation used multiset container. <br><br>  Here you can read about search trees: <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">Wikipedia</a> <br>  <a href="https://habrahabr.ru/post/65617/">Article on Habr√©</a> <br>  <a href="https://habrahabr.ru/post/66926/">And another article on Habr√©</a> <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">treesort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) m.insert(*i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q : m) *l = q, l++; }</code> </pre> </div></div><br><h4>  Gnome sort / Gnome sort </h4><br>  The algorithm is similar to sorting by inserts.  We support the pointer to the current element, if it is greater than the previous one or it is the first one - move the pointer to the position to the right, otherwise we change the current and previous elements in places and move to the left. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs matlab">void gnomesort(int* l, int* r) { int *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = l; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> == l || *(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;= *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> swap(*(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>), *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>--; } }</code> </pre> </div></div><br><h4>  Sort selection / sort selection </h4><br>  At the next iteration, we will find the minimum in the array after the current element and change it with it if necessary.  Thus, after the i-th iteration, the first i elements will stand in their places.  Asymptotics: O (n <sup>2</sup> ) at best, average and worst.  It should be noted that this sorting can be implemented in two ways - keeping the minimum and its index, or simply rearranging the current item with the item in question if they are in the wrong order.  The first method was a little faster, so it is implemented. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs matlab">void selectionsort(int* l, int* r) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = l; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; r; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { int minz = *<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *ind = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int *<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; r; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; minz) minz = *<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>, ind = <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>; } swap(*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, *ind); } }</code> </pre> </div></div><br><h4>  Pyramid Sorting / Heapsort </h4><br>  Development of the idea of ‚Äã‚Äãsorting choice  We use the heap data structure (or ‚Äúpyramid‚Äù, whence the name of the algorithm).  It allows you to get at least O (1), adding elements and extracting at least O (logn).  Thus, the asymptotic behavior of O (nlogn) is worst, average, and best.  I implemented the heap myself, although in C ++ there is a container priority_queue, since this container is rather slow. <br><br>  You can read about a bunch here: <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia</a> <br>  <a href="https://habrahabr.ru/post/112222/">Article on Habr√©</a> <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">heap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ h.push_back(a); SiftUp(n); n++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ n--; swap(h[n], h[<span class="hljs-number"><span class="hljs-number">0</span></span>]); h.pop_back(); SiftDown(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ h.clear(); n = <span class="hljs-number"><span class="hljs-number">0</span></span>; } T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [] (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h[a]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SiftUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = (a - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h[p] &gt; h[a]) swap(h[p], h[a]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; a--; a /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SiftDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; n) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">2</span></span> * a + <span class="hljs-number"><span class="hljs-number">1</span></span>, r = <span class="hljs-number"><span class="hljs-number">2</span></span> * a + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r == n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h[l] &lt; h[a]) swap(h[l], h[a]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h[l] &lt;= h[r]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h[l] &lt; h[a]) { swap(h[l], h[a]); a = l; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h[r] &lt; h[a]) { swap(h[r], h[a]); a = r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heapsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ heap&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; h; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) h.push(*i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) { *i = h.top(); h.pop(); } }</code> </pre> </div></div><br><h4>  Quick Sort / Quicksort </h4><br>  Choose some support element.  After that, we will throw all the elements, the smaller ones, to the left, and the large ones - to the right.  Recursively call from each of the parts.  As a result, we obtain a sorted array, since each element of the smaller reference one was before each larger reference one.  Asymptotics: O (nlogn) in the middle and best case, O (n <sup>2</sup> ).  The worst estimate is achieved if the support element is unsuccessful.  My implementation of this algorithm is completely standard, we go simultaneously to the left and to the right, we find a pair of elements such that the left element is larger than the reference element and the right element is smaller, and we swap them.  In addition to pure quick sorting, the sorting was used in comparison, passing with a small number of elements on sorting by inserts.  The constant is selected by testing, and the sorting by inserts is the best sorting suitable for this task (although it is not worth it to think that it is the fastest of quadratic ones). <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quicksort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = *(l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ll = l, *rr = r - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ll &lt;= rr) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*ll &lt; z) ll++; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*rr &gt; z) rr--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ll &lt;= rr) { swap(*ll, *rr); ll++; rr--; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; rr) quicksort(l, rr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ll &lt; r) quicksort(ll, r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickinssort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>) { insertionsort(l, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = *(l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ll = l, *rr = r - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ll &lt;= rr) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*ll &lt; z) ll++; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*rr &gt; z) rr--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ll &lt;= rr) { swap(*ll, *rr); ll++; rr--; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; rr) quickinssort(l, rr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ll &lt; r) quickinssort(ll, r); }</code> </pre> </div></div><br><h4>  Merge sort / Merge sort </h4><br>  Sorting based on the divide-and-conquer paradigm.  We divide the array in half, recursively sort the parts, and then execute the merge procedure: we support two pointers, one to the current element of the first part, the second to the current element of the second part.  From these two elements, select the minimum, insert into the response and shift the pointer corresponding to the minimum.  The merge works beyond O (n), the levels of all logn, so the asymptotics is O (nlogn).  Effectively create a temporary array in advance and pass it as a function argument.  This sorting is recursive, as well as quick, and therefore it is possible to switch to quadratic with a small number of elements. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* temp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *cl = l, *cr = m, cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cl &lt; m &amp;&amp; cr &lt; r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*cl &lt; *cr) temp[cur++] = *cl, cl++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> temp[cur++] = *cr, cr++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cl &lt; m) temp[cur++] = *cl, cl++; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cr &lt; r) temp[cur++] = *cr, cr++; cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* i = l; i &lt; r; i++) *i = temp[cur++]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_mergesort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* temp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *m = l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>; _mergesort(l, m, temp); _mergesort(m, r, temp); merge(l, m, r, temp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergesort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[r - l]; _mergesort(l, r, temp); delete temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_mergeinssort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* temp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>) { insertionsort(l, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *m = l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>; _mergeinssort(l, m, temp); _mergeinssort(m, r, temp); merge(l, m, r, temp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeinssort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[r - l]; _mergeinssort(l, r, temp); delete temp; }</code> </pre> </div></div><br><h4>  Sort by Counting / Counting sort </h4><br>  Create an array of size r - l, where l is the minimum and r is the maximum element of the array.  After that, go through the array and count the number of occurrences of each element.  Now you can go through the array of values ‚Äã‚Äãand write out each number as many times as necessary.  Asymptotics - O (n + r - l).  You can modify this algorithm so that it becomes stable: to do this, we define the place where the next number should be (this is just the prefix sums in the array of values) and we will go through the source array from left to right, putting the element in the right place and increasing the position by 1. This the sorting was not tested, since most of the tests contained rather large numbers that did not allow to create an array of the required size.  However, it nevertheless came in handy. <br><br><h4>  Block Sort / Bucket sort </h4><br>  (also known as basket and pocket sorting).  Let l be the minimal and r the maximal element of the array.  We divide the elements into blocks, in the first there will be elements from l to l + k, in the second - from l + k to l + 2k, etc., where k = (r - l) / number of blocks.  In general, if the number of blocks is two, then this algorithm turns into a sort of quick sort.  The asymptotics of this algorithm is unclear, the running time depends on the input data and the number of blocks.  It is argued that on successful data, the operating time is linear.  The implementation of this algorithm turned out to be one of the most difficult tasks.  You can do it this way: just create new arrays, recursively sort and glue them.  However, this approach is still rather slow and did not suit me.  In an effective implementation, several ideas are used: <br><br>  1) We will not create new arrays.  To do this, we use the sorting counting technique - we calculate the number of elements in each block, the prefix sums and, thus, the position of each element in the array. <br><br>  2) We will not run from empty blocks.  Put the indices of non-empty blocks in a separate array and run only on them. <br><br>  3) Check whether the array is sorted.  This does not worsen the running time, since you still need to make a pass in order to find the minimum and maximum, however, it will allow the algorithm to speed up on partially sorted data, because the elements are inserted into new blocks in the same order as in the original array. <br><br>  4) Since the algorithm turned out to be rather cumbersome, with a small number of elements it is extremely inefficient.  To such an extent that the transition to sorting inserts speeds up the work by about 10 times. <br><br>  It remains only to understand how many blocks you need to choose.  On randomized tests, I managed to get the following grade: 1500 units for 10 <sup>7</sup> elements and 3000 for 10 <sup>8</sup> .  It was not possible to pick up the formula - the work time deteriorated several times. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs go">void _newbucketsort(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* l, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* temp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { insertionsort(l, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minz = *l, maxz = *l; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sorted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; r; i++) { minz = min(minz, *i); maxz = max(maxz, *i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i &lt; *(i - <span class="hljs-number"><span class="hljs-number">1</span></span>)) is_sorted = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_sorted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = maxz - minz + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numbuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">1e7</span></span>) numbuckets = <span class="hljs-number"><span class="hljs-number">1500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> numbuckets = <span class="hljs-number"><span class="hljs-number">3000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> = (diff + numbuckets - <span class="hljs-number"><span class="hljs-number">1</span></span>) / numbuckets; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* cnt = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[numbuckets + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= numbuckets; i++) cnt[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* i = l; i &lt; r; i++) { temp[cur++] = *i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = (*i - minz) / <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>; cnt[ind + <span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= numbuckets; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt[i]) sz++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* run = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[sz]; cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= numbuckets; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt[i]) run[cur++] = i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= numbuckets; i++) cnt[i] += cnt[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = (temp[cur] - minz) / <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>; *(l + cnt[ind]) = temp[cur]; cur++; cnt[ind]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sz; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = run[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r != <span class="hljs-number"><span class="hljs-number">0</span></span>) _newbucketsort(l + cnt[r - <span class="hljs-number"><span class="hljs-number">1</span></span>], l + cnt[r], temp); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _newbucketsort(l, l + cnt[r], temp); } <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span> run; <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span> cnt; } void newbucketsort(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* l, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* r) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *temp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[r - l]; _newbucketsort(l, r, temp); <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span> temp; }</code> </pre> </div></div><br><h4>  Bitwise sort / Radix sort </h4><br>  (also known as digital sorting).  There are two versions of this sorting, in which, in my opinion, there is little in common, apart from the idea of ‚Äã‚Äãusing the representation of a number in some number system (for example, binary). <br><br><h6>  LSD (least significant digit): </h6><br>  Imagine each number in binary form.  At each step of the algorithm, we will sort the numbers so that they are sorted by the first k * i bits, where k is some constant.  From this definition, it follows that at each step it is sufficient to stably sort the elements by the new k bits.  Sorting by counting is ideal for this (2 <sup>k of</sup> memory and time are needed, which is a bit with a successful choice of a constant).  Asymptotics: O (n), if we assume that the numbers are of a fixed size (and otherwise it would not be possible to assume that the comparison of two numbers is performed per unit time).  The implementation is quite simple. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (n &gt;&gt; (N * k) &amp; (M - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _radixsort(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* l, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = (<span class="hljs-number"><span class="hljs-number">32</span></span> + N - <span class="hljs-number"><span class="hljs-number">1</span></span>) / N; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; N; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[sz]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[M]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; M; j++) c[j] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* j = l; j &lt; r; j++) c[digit(*j, i, N, M)]++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; M; j++) c[j] += c[j - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* j = r - <span class="hljs-number"><span class="hljs-number">1</span></span>; j &gt;= l; j--) b[--c[digit(*j, i, N, M)]] = *j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* j = l; j &lt; r; j++) *j = b[cur++]; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radixsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ _radixsort(l, r, <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> </div></div><br><h6>  MSD (most significant digit): </h6><br>  In fact, some kind of block sorting.  Numbers with equal k bits will fall into one block.  Asymptotics is the same as for LSD version.  The implementation is very similar to block sorting, but simpler.  It uses the digit function defined in the LSD version implementation. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> _radixsortmsd(<span class="hljs-type"><span class="hljs-type">int</span></span>* l, <span class="hljs-type"><span class="hljs-type">int</span></span>* r, <span class="hljs-type"><span class="hljs-type">int</span></span> N, <span class="hljs-type"><span class="hljs-type">int</span></span> d, <span class="hljs-type"><span class="hljs-type">int</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>) { insertionsort(l, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> M = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; N; <span class="hljs-type"><span class="hljs-type">int</span></span>* cnt = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[M + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= M; i++) cnt[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span>* i = l; i &lt; r; i++) { <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>[cur++] = *i; cnt[digit(*i, d, N, M) + <span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-type"><span class="hljs-type">int</span></span> sz = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= M; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt[i]) sz++; <span class="hljs-type"><span class="hljs-type">int</span></span>* run = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[sz]; cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= M; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt[i]) run[cur++] = i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= M; i++) cnt[i] += cnt[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> *i = l; i &lt; r; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> ind = digit(<span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>[cur], d, N, M); *(l + cnt[ind]) = <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>[cur]; cur++; cnt[ind]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sz; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> r = run[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r != <span class="hljs-number"><span class="hljs-number">0</span></span>) _radixsortmsd(l + cnt[r - <span class="hljs-number"><span class="hljs-number">1</span></span>], l + cnt[r], N, d - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _radixsortmsd(l, l + cnt[r], N, d - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> run; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cnt; } <span class="hljs-type"><span class="hljs-type">void</span></span> radixsortmsd(<span class="hljs-type"><span class="hljs-type">int</span></span>* l, <span class="hljs-type"><span class="hljs-type">int</span></span>* r) { <span class="hljs-type"><span class="hljs-type">int</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[r - l]; _radixsortmsd(l, r, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; }</code> </pre> </div></div><br><h4>  Biton sort / Bitonic sort: </h4><br>  The idea of ‚Äã‚Äãthis algorithm is that the original array is converted into a biton sequence ‚Äî a sequence that first grows and then decreases.  It can be effectively sorted in the following way: we divide the array into two parts, create two arrays, add all elements equal to the minimum of the corresponding elements of each of the two parts to the first, and equal to the maximum in the second.  It is argued that you get two bitonic sequences, each of which can be recursively sorted in the same way, after which you can glue two arrays (since any element of the first is less than or equal to any element of the second).  In order to convert the original array into a biton sequence, we will do the following: if the array consists of two elements, you can simply complete, otherwise divide the array in half, recursively call the algorithm from the halves, then sort the first part in order, the second in reverse order and glue .  Obviously, you get a biton sequence.  Asymptotics: O (nlog <sup>2</sup> n), because when building the biton sequence we used the sorting working for O (nlogn), and logn was the whole level.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also note that the size of the array should be equal to the power of two, so you may have to supplement it with fictitious elements (which does not affect the asymptotics). </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation:</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitseqsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *m = l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l, *j = m; i &lt; m &amp;&amp; j &lt; r; i++, j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inv ^ (*i &gt; *j)) swap(*i, *j); } bitseqsort(l, m, inv); bitseqsort(m, r, inv); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makebitonic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *m = l + (r - l) / <span class="hljs-number"><span class="hljs-number">2</span></span>; makebitonic(l, m); bitseqsort(l, m, <span class="hljs-number"><span class="hljs-number">0</span></span>); makebitonic(m, r); bitseqsort(m, r, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitonicsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inf = *max_element(l, r) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &lt; r - l) n *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) a[cur++] = *i; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cur &lt; n) a[cur++] = inf; makebitonic(a, a + n); bitseqsort(a, a + n, <span class="hljs-number"><span class="hljs-number">0</span></span>); cur = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = l; i &lt; r; i++) *i = a[cur++]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> a; }</code> </pre> </div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timsort </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid sorting, combining sorting inserts and merge sorting. We partition the array elements into several small subarrays, while expanding the subarray while the elements in it are sorted. We sort the subarrays by sorting by inserts, using the fact that it effectively works on sorted arrays. Next, we will merge the subarrays as in the merge sorting, taking them of approximately equal size (otherwise the work time will approach the quadratic one). For this, it is convenient to store subarrays in a stack, maintaining the invariant - the farther from the top, the larger the size, and merging the subarrays at the top only when the size of the third distant from the top of the subarray is greater than or equal to the sum of their sizes. Asymptotics: O (n) at best, and O (nlogn) at average and worst. The implementation is nontrivial,I have no firm confidence in it, however, she showed quite a good time and consistent with my ideas about how this sorting should work.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> More timsort is described here: </font></font><br><br>  <a href="https://habrahabr.ru/company/infopulse/blog/133303/">Here</a> <br>  <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3DTimsort">Here</a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation:</font></font></b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> _timsort(<span class="hljs-type"><span class="hljs-type">int</span></span>* l, <span class="hljs-type"><span class="hljs-type">int</span></span>* r, <span class="hljs-type"><span class="hljs-type">int</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> sz = r - l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sz &lt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { insertionsort(l, r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> minrun = sz, f = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (minrun &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { f |= minrun &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; minrun &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } minrun += f; <span class="hljs-type"><span class="hljs-type">int</span></span>* cur = l; stack&lt;pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt;&gt; s; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cur &lt; r) { <span class="hljs-type"><span class="hljs-type">int</span></span>* c1 = cur; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (c1 &lt; r - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; *c1 &lt;= *(c1 + <span class="hljs-number"><span class="hljs-number">1</span></span>)) c1++; <span class="hljs-type"><span class="hljs-type">int</span></span>* c2 = cur; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (c2 &lt; r - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; *c2 &gt;= *(c2 + <span class="hljs-number"><span class="hljs-number">1</span></span>)) c2++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c1 &gt;= c2) { c1 = max(c1, cur + minrun - <span class="hljs-number"><span class="hljs-number">1</span></span>); c1 = min(c1, r - <span class="hljs-number"><span class="hljs-number">1</span></span>); insertionsort(cur, c1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); s.push({ c1 - cur + <span class="hljs-number"><span class="hljs-number">1</span></span>, cur }); cur = c1 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { c2 = max(c2, cur + minrun - <span class="hljs-number"><span class="hljs-number">1</span></span>); c2 = min(c2, r - <span class="hljs-number"><span class="hljs-number">1</span></span>); reverse(cur, c2 + <span class="hljs-number"><span class="hljs-number">1</span></span>); insertionsort(cur, c2 + <span class="hljs-number"><span class="hljs-number">1</span></span>); s.push({ c2 - cur + <span class="hljs-number"><span class="hljs-number">1</span></span>, cur }); cur = c2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s.size() &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; x = s.top(); s.pop(); pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; y = s.top(); s.pop(); pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; z = s.top(); s.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z.first &gt;= x.first + y.first &amp;&amp; y.first &gt;= x.first) { s.push(z); s.push(y); s.push(x); break; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z.first &gt;= x.first + y.first) { merge(y.second, x.second, x.second + x.first, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); s.push(z); s.push({ x.first + y.first, y.second }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { merge(z.second, y.second, y.second + y.first, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); s.push({ z.first + y.first, z.second }); s.push(x); } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s.size() != <span class="hljs-number"><span class="hljs-number">1</span></span>) { pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; x = s.top(); s.pop(); pair&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; y = s.top(); s.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.second &lt; y.second) swap(x, y); merge(y.second, x.second, x.second + x.first, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); s.push({ y.first + x.first, y.second }); } } <span class="hljs-type"><span class="hljs-type">void</span></span> timsort(<span class="hljs-type"><span class="hljs-type">int</span></span>* l, <span class="hljs-type"><span class="hljs-type">int</span></span>* r) { <span class="hljs-type"><span class="hljs-type">int</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[r - l]; _timsort(l, r, <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; }</code> </pre> </div></div><br><h2>  Testing </h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iron and system </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processor: Intel Core i7-3770 CPU 3.40 GHz </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 8 GB </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing was conducted on an almost pure Windows 10 x64 system installed a few days before launch. </font><font style="vertical-align: inherit;">IDE used - Microsoft Visual Studio 2015.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tests </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All tests are divided into four groups. </font><font style="vertical-align: inherit;">The first group is an array of random numbers in different modules (10, 1000, 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">The second group is an array broken into several sorted arrays. </font><font style="vertical-align: inherit;">In fact, an array of random numbers was taken modulo 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then subarrays of size equal to the minimum of the length of the remaining suffix and a random number modulo some constant were sorted. The sequence of constants is 10, 100, 1000, etc. down to the size of the array. The third group is an initially sorted array of random numbers with a certain number of ‚Äúswaps‚Äù - permutations of two random elements. The sequence of numbers of swaps is the same as in the previous group. Finally, the last group consists of several tests with a completely sorted array (in the direct and reverse order), several tests with an initial array of natural numbers from 1 to n, in which several numbers are replaced with a random one, and tests with a large number of repetitions of one element (10 %, 25%, 50%, 75% and 90%). Thus, tests allow you to seehow sorting works on random and partially sorted arrays, which looks the most significant. The fourth group is largely against linear-time sorts, which love random number sequences. At the end of the article there is a link to the file, which describes in detail all the tests.</font></font><br><br><h4>    </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be rather silly to compare, for example, sorting with linear time of work and quadratic, and run them on tests of the same size. Therefore, each of the groups of tests is divided into four groups, the size of 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements. The sortings were divided into three groups, in the first - quadratic (sorting by bubble, inserts, selection, shaker and gnomes), in the second - something between logarithmic time and square, (biton, several types of Shell sorting and sorting by tree), in the third all rest. Someone may be surprised that the tree sorting did not fall into the third group, although its asymptotics is O (nlogn), but, unfortunately, its constant is very large. Sorts of the first group were tested on tests with 10</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements, the second group - on tests with 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the third - on tests with 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is these data sizes that allow you to somehow see an increase in the operating time, for smaller sizes the error is too large, for large ones the algorithm works too long (or lack of RAM). </font><font style="vertical-align: inherit;">With the first group, I did not bother, so as not to disturb the tenfold increase (10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements for quadratic sorts too little), after all, by themselves they are of little interest.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How was the testing done? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On each test, there were 20 launches, the total running time was an average of the resulting values. </font><font style="vertical-align: inherit;">Almost all the results were obtained after one program launch, but due to several errors in the code and system glitches (testing lasted almost a week of pure time), some sortings and tests had to be retested afterwards.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subtleties of implementation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It may be surprising to someone that I did not use function pointers in the implementation of the testing process itself, which would greatly reduce the code. </font><font style="vertical-align: inherit;">It turned out that this significantly slows down the operation of the algorithm (approximately by 5-10%). </font><font style="vertical-align: inherit;">Therefore, I used a separate call for each function (this, of course, would not affect the relative speed, but ... I still want to improve the absolute). </font><font style="vertical-align: inherit;">For the same reason, vectors were replaced with regular arrays, patterns and comparators were not used. </font><font style="vertical-align: inherit;">All this is more relevant for the industrial use of the algorithm, rather than testing it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> results </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All results are available in several forms - three diagrams (a histogram showing the change in speed during the transition to the next constraint on one type of test, a graph depicting the same, but sometimes more clearly, and a histogram showing which sorting is best works on some type of test) and the table on which they are based. The third group was divided into three parts, but little would be clear. However, even so far not all diagrams are successful (in general, I strongly doubt the utility of the third type of diagrams), but I hope everyone can find the most suitable for understanding.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since there are a lot of pictures, they are hidden by spoilers. </font><font style="vertical-align: inherit;">Few comments about the notation. </font><font style="vertical-align: inherit;">Sortings are named as above, if this is Shell sorting, then the author of the sequence is indicated in parentheses, Ins is assigned to the names of sortings that switch to sorting by inserts, (for compactness). </font><font style="vertical-align: inherit;">In the diagrams for the second group of tests, the possible length of the sorted subarrays is indicated, for the third group - the number of swaps, for the fourth - the number of substitutions. </font><font style="vertical-align: inherit;">The overall result was calculated as the average of four groups.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First Sort Group </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array of random numbers </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/22b/f0f/e6a/22bf0fe6a6d74bf8878ef842f6634f4a.jpg"><br><img src="https://habrastorage.org/web/536/add/666/536add6664024e90bb142695d324e64f.jpg"><br><img src="https://habrastorage.org/web/c8d/9b1/c59/c8d9b1c590064ef8a5daca5fac24ca3a.jpg"><br><img src="https://habrastorage.org/web/183/05b/d88/18305bd88637498c90c71c8c3a14e2f3.jpg"><br><img src="https://habrastorage.org/web/094/bcb/36c/094bcb36cf334bc980c51856c9bf2a71.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Very boring results, even partial sorting with a small module is almost imperceptible. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partially sorted array </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/d52/49a/f59/d5249af5913a46218f23c87bd95b52cb.jpg"><br><img src="https://habrastorage.org/web/44d/a39/b84/44da39b84f39492382980a9e99d2aa7f.jpg"><br><img src="https://habrastorage.org/web/880/d27/248/880d27248b4346ca8569cc031b3af69c.jpg"><br><img src="https://habrastorage.org/web/5c7/73c/edb/5c773cedb39240bd8bf88ec53d145ef4.jpg"><img src="https://habrastorage.org/web/2ff/35a/52c/2ff35a52cd91444298a0f7e018549a0e.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Already much more interesting. </font><font style="vertical-align: inherit;">Exchange sorting the most rapidly responded, shaker even overtook Gnome. </font><font style="vertical-align: inherit;">Sorting inserts sped up just at the very end. </font><font style="vertical-align: inherit;">Sorting by choice, of course, works perfectly well.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Swaps </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/a2b/6ae/230/a2b6ae2302194fa49d0ba86c330e3aca.jpg"><br><img src="https://habrastorage.org/web/677/990/c3a/677990c3abbb481ba8af62aaebb7adb5.jpg"><br><img src="https://habrastorage.org/web/a30/a8e/60c/a30a8e60c0504706b83a0e5823234bb1.jpg"><br><img src="https://habrastorage.org/web/fda/1f0/44c/fda1f044c49e42d79a101656ca3ba26c.jpg"><br><img src="https://habrastorage.org/web/24b/ef9/6ba/24bef96ba82b4e938da5ab48e8ba5b7c.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, sorting by inserts has finally manifested itself, although the increase in speed at the shaker is about the same. </font><font style="vertical-align: inherit;">This showed a weak sorting bubble - one swap is enough, moving a small element to the end, and it is already running slowly. </font><font style="vertical-align: inherit;">Sorting choice was almost at the end.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permutation changes </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/8b8/17c/67a/8b817c67ad024ed4858c4aa0d139cb66.jpg"><br><img src="https://habrastorage.org/web/fa8/daf/06d/fa8daf06dd8448fa9c31e2fc1230bbf8.jpg"><br><img src="https://habrastorage.org/web/837/5da/2da/8375da2da63a4b4aa017cbcf76bfc235.jpg"><br><img src="https://habrastorage.org/web/c82/793/95a/c8279395a3cf4a6e92495afd5c19c500.jpg"><br><img src="https://habrastorage.org/web/2d1/4b9/273/2d14b92733be440293f4a78da34187ee.jpg"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The group is almost the same as the previous one, so the results are similar. </font><font style="vertical-align: inherit;">However, the sorting of the bubble is pulled forward, since the random element inserted into the array will most likely be more than all the others, that is, in one iteration will move to the end. </font><font style="vertical-align: inherit;">Sort by choice has become an outsider.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replays </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/494/47e/5c7/49447e5c7009426b9d994424b9bb8508.jpg"><br><img src="https://habrastorage.org/web/4ea/c5a/22e/4eac5a22ef7b48808054276ccc9e012b.jpg"><br><img src="https://habrastorage.org/web/f8b/f3f/cf7/f8bf3fcf7ef447a880952761c31ba10f.jpg"><br><img src="https://habrastorage.org/web/76a/d1e/91c/76ad1e91c29340a8ae8642559208f08f.jpg"><br><img src="https://habrastorage.org/web/8d1/c9e/73a/8d1c9e73a86b4929b531cd9b98849c84.jpg"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, all sortings (except, of course, sorting by choice) worked almost equally, accelerating as the number of repetitions increased. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final results </font></font></h4><br><img src="https://habrastorage.org/web/226/687/2ab/2266872abe8847eca4f2d4ff5b1ca445.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to her absolute indifference to the array, sorting by choice, which worked the fastest on random data, still lost to sorting by inserts. </font><font style="vertical-align: inherit;">Dwarf sorting turned out to be noticeably worse than the last, which is why its practical use is doubtful. </font><font style="vertical-align: inherit;">Shaker and bubble sorting turned out to be the slowest.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The second group of sorts </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array of random numbers </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e6 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/7e5/283/3ff/7e52833ffd374b80bc9a64b3d3123c73.jpg"><br><img src="https://habrastorage.org/web/add/84c/3c2/add84c3c2d3749078fd89e0ba73781e7.jpg"><br><img src="https://habrastorage.org/web/621/56f/0a2/62156f0a215d4d0a8f863fa99d65ee83.jpg"><br><img src="https://habrastorage.org/web/e18/94c/ac8/e1894cac8e4a457aaefc5f2b39f5dcb7.jpg"><br><img src="https://habrastorage.org/web/203/8b2/49f/2038b249fba847cc8c03307658937813.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shell sorting with Pratt's sequence behaves very strange, the rest is less clear. </font><font style="vertical-align: inherit;">Tree sorting loves partially sorted arrays, but does not like repetition, perhaps, therefore, the worst time of work is in the middle.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/b29/e54/34a/b29e5434a5bf40b6a4c8d5532463b3a5.jpg"><br><img src="https://habrastorage.org/web/75d/41b/c81/75d41bc812c94f95aa2857e2890f6835.jpg"><br><img src="https://habrastorage.org/web/268/430/39f/26843039f37647779fa85186dde1adc1.jpg"><br><img src="https://habrastorage.org/web/ff5/dcd/2a4/ff5dcd2a43d4468e8006387426f5b6ad.jpg"><br><img src="https://habrastorage.org/web/0b2/7d6/bbf/0b27d6bbf49545dfbb25668f2d2a4fe5.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As before, only Shell and Pratt intensified in the second group due to the sorting. </font><font style="vertical-align: inherit;">The asymptotic effect also becomes noticeable - the tree sorting takes second place, in contrast to the group with a smaller number of elements.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partially sorted array </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e6 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/ba7/05f/1ad/ba705f1ad30246cc9edc4d7124f35cd2.jpg"><br><img src="https://habrastorage.org/web/8de/69e/c0b/8de69ec0b5714087a3cef445489fe5af.jpg"><br><img src="https://habrastorage.org/web/893/10a/960/89310a9604c349349e25b666bf506bae.jpg"><br><img src="https://habrastorage.org/web/bfc/3c5/99d/bfc3c599d7bb46c1992b7609344c9206.jpg"><img src="https://habrastorage.org/web/54b/d5a/678/54bd5a6781f54d0f981ff8a788080748.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here all sorts behave in an understandable way, except for Shell and Hibbard, who for some reason does not immediately begin to accelerate. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/413/230/810/413230810b8a4e6ead6428b296eab9e4.jpg"><br><img src="https://habrastorage.org/web/e22/042/3e0/e220423e08cd4e9eabc00893b1e67080.jpg"><br><img src="https://habrastorage.org/web/af1/53b/e3d/af153be3d3c144dcb1d53816de6492b5.jpg"><br><img src="https://habrastorage.org/web/715/49e/21b/71549e21b5a64e8f8c5360568c112a67.jpg"><br><img src="https://habrastorage.org/web/cb1/74b/b19/cb174bb19c744da6a9dee1197b4471e1.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here everything is, in general, as before. </font><font style="vertical-align: inherit;">Even the asymptotic sorting of the tree did not help her to escape from the last place.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Swaps </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e6 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/926/42d/b1f/92642db1fa5d48418948d5ea4af28f31.jpg"><br><img src="https://habrastorage.org/web/c22/8b4/651/c228b4651a9547c683385df6d851b366.jpg"><br><img src="https://habrastorage.org/web/de9/a11/30f/de9a1130fa4547db9429faf0b5e7428a.jpg"><br><img src="https://habrastorage.org/web/bc5/09a/cb6/bc509acb6cba48fa8bc8467507d58ee8.jpg"><br><img src="https://habrastorage.org/web/426/c0a/966/426c0a9666a34911b91d47d1383eff7e.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/ff8/486/b15/ff8486b151654cde90d2308dfc986373.jpg"><br><img src="https://habrastorage.org/web/37e/1ba/cee/37e1bacee1cd458996c651e581aeb7a5.jpg"><br><img src="https://habrastorage.org/web/e8f/1ce/442/e8f1ce4429f443bfb22a8348a114b07a.jpg"><br><img src="https://habrastorage.org/web/9b8/7d3/a31/9b87d3a3198541cda5b55532779cede7.jpg"><br><img src="https://habrastorage.org/web/b28/4ab/541/b284ab54164d400582354e72d738e826.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here it is noticeable that in Shell sorts there is a big dependence on partial sorting, since they behave almost linearly, and the other two only fall strongly on the last groups. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permutation changes </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e6 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/08f/693/ef7/08f693ef75274eb49bcaebe7eddfef18.jpg"><br><img src="https://habrastorage.org/web/c21/5bd/c85/c215bdc857ae42f49b668975cbaae0e9.jpg"><br><img src="https://habrastorage.org/web/0f3/491/17d/0f349117de264c38add27b53d760c690.jpg"><br><img src="https://habrastorage.org/web/9e9/d21/e71/9e9d21e715be41d4b8611d02e5cc0f42.jpg"><br><img src="https://habrastorage.org/web/a70/173/abf/a70173abfeb04de8a3481723c7256576.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/20e/f9a/d19/20ef9ad19154401d8d165a5d6dd9cb6f.jpg"><br><img src="https://habrastorage.org/web/f9c/53a/7c0/f9c53a7c03d64248851c8878425448dd.jpg"><br><img src="https://habrastorage.org/web/732/92d/6b4/73292d6b4ee9493f89fb1bec3668823d.jpg"><br><img src="https://habrastorage.org/web/c63/99e/0be/c6399e0be1d24339a320c52683805392.jpg"><br><img src="https://habrastorage.org/web/bff/70a/d43/bff70ad437b34fe39462948290b2ad69.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here everything looks like the previous group. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replays </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e6 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/067/45c/dc0/06745cdc00134491afcb2d26713867b1.jpg"><br><img src="https://habrastorage.org/web/07b/428/7ea/07b4287ea7cf4b7b9b64ad3d41b7fbbf.jpg"><br><img src="https://habrastorage.org/web/04c/1e5/cc1/04c1e5cc17bd430580ce0357d541a6a1.jpg"><br><img src="https://habrastorage.org/web/b8b/ef5/92d/b8bef592da6542458fffa8c30e7dc0fd.jpg"><br><img src="https://habrastorage.org/web/92b/db3/b88/92bdb3b8836044eb9665cff354a3be8a.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Again, all the sorting showed an amazing balance, even biton, which, it would seem, almost does not depend on the array. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/98f/b7c/2e8/98fb7c2e842743ee8f46929bcf8f9318.jpg"><br><img src="https://habrastorage.org/web/66d/72c/118/66d72c118a9e4540b92304ca7d3a3afc.jpg"><br><img src="https://habrastorage.org/web/06e/29f/08a/06e29f08a73a4d9bbe2642cb57b9875b.jpg"><br><img src="https://habrastorage.org/web/c12/2e1/4d0/c122e14d0d554435ab888e2e9afe039d.jpg"><br><img src="https://habrastorage.org/web/74b/5c4/452/74b5c44524c947f6b451f783fa2273cd.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nothing interesting. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final results </font></font></h4><br><img src="https://habrastorage.org/web/e38/72b/40e/e3872b40e7d4453b8bce8c0008f6fe0d.jpg"><img src="https://habrastorage.org/web/f4e/dea/fcb/f4edeafcb0f444bf8f70b32ba994f3a3.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convincing first place was taken by the sorting of Shell by Hibbard, not losing in any intermediate group. </font><font style="vertical-align: inherit;">It might have been worth sending it to the first group of sorts, but ... it is too weak for this, and even then almost no one would be in the group. </font><font style="vertical-align: inherit;">Biton sorting pretty confidently took second place. </font><font style="vertical-align: inherit;">The third place with a million elements was taken by another sort of Shell, and at ten millions by sorting by a tree (asymptotics was affected). </font><font style="vertical-align: inherit;">It is worth noting that with a tenfold increase in the size of the input data, all the algorithms, except for wood sorting, slowed down almost 20 times, and the latter is only 13.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The third group of sorts </font></font></h2><br><h4>    </h4><br><div class="spoiler"> <b class="spoiler_title">, 17 </b> <div class="spoiler_text"><img src="https://habrastorage.org/web/2ed/22b/9da/2ed22b9da5e74efaa3cd07aa273c013c.jpg"><br><img src="https://habrastorage.org/web/ab8/af6/049/ab8af604939b4079b9c55fa8a235760e.jpg"><br><img src="https://habrastorage.org/web/e32/797/988/e3279798889a48bfad831c21c3d573e5.jpg"><br><img src="https://habrastorage.org/web/c63/3b2/1fe/c633b21fef0c4a638209b97a9f9f5701.jpg"><br><img src="https://habrastorage.org/web/79f/37d/ca7/79f37dca711e42588313e4bcfdfbd80f.jpg"><br><img src="https://habrastorage.org/web/541/853/c92/541853c922aa46a69fbb298441962bf6.jpg"><br><img src="https://habrastorage.org/web/e4e/fa8/623/e4efa862383745f4902704195d15197b.jpg"><br><img src="https://habrastorage.org/web/7fe/b69/d54/7feb69d54a3049fa951b3e667108dc1e.jpg"><br><img src="https://habrastorage.org/web/953/1bd/a1b/9531bda1bafa46799568807e49fd78d1.jpg"><br><img src="https://habrastorage.org/web/0ae/22d/99e/0ae22d99e2fa47fbaaeabc97c371363b.jpg"><br><img src="https://habrastorage.org/web/461/c3f/d08/461c3fd0882e45fca9a825045e262eee.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title">, 18 </b> <div class="spoiler_text"><img src="https://habrastorage.org/web/5e2/3cd/50f/5e23cd50f814449ab606c99372941e86.jpg"><br><img src="https://habrastorage.org/web/ab6/cf6/817/ab6cf6817b5f4d85906a7a5917a2a61b.jpg"><img src="https://habrastorage.org/web/edc/343/442/edc343442e96456db838df3253784167.jpg"><img src="https://habrastorage.org/web/7e2/0cc/6d1/7e20cc6d14d9432a9d7f60caecb8b9e2.jpg"><img src="https://habrastorage.org/web/122/2f3/d38/1222f3d385a242de916c19e0ebdecc96.jpg"><img src="https://habrastorage.org/web/489/55d/34f/48955d34fec24ee892722a9a5e1c777d.jpg"><img src="https://habrastorage.org/web/aaf/451/8cf/aaf4518cf4444db09a4be92dfcb2c60e.jpg"><img src="https://habrastorage.org/web/2cd/bcb/18b/2cdbcb18bddf4074b0b900891f885b2e.jpg"><img src="https://habrastorage.org/web/e33/66d/e8d/e3366de8df654701ae2c3c6691a3add2.jpg"><img src="https://habrastorage.org/web/789/e57/d26/789e57d26c864d35ae8620bf2d59e6d5.jpg"><img src="https://habrastorage.org/web/cf8/834/450/cf883445093f4c0c9c2961b5ff0c1cdc.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost all sorts of this group have almost the same dynamics. </font><font style="vertical-align: inherit;">Why is almost all sorting accelerated when the array is partially sorted? </font><font style="vertical-align: inherit;">Exchange sorts work faster because fewer exchanges are needed; in Shell sorting, sorting is performed by inserts, which is greatly accelerated on such arrays; in pyramid sorting, insertion of elements immediately completes screening; in merge sorting, at least half the number of comparisons is performed. </font><font style="vertical-align: inherit;">Block sorting works the better, the smaller the difference between the minimum and maximum element. </font><font style="vertical-align: inherit;">Fundamentally different only bitwise sorting, which all this does not matter. </font><font style="vertical-align: inherit;">The LSD version works the better, the larger the module. </font><font style="vertical-align: inherit;">The dynamics of the MSD version is not clear to me, that it worked faster than LSD was surprised.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partially sorted array </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/fa6/3d3/4a3/fa63d34a307344f1a7e611f56f07840e.jpg"><img src="https://habrastorage.org/web/b28/370/35a/b2837035ac464948aaab5de202b0aa5f.jpg"><img src="https://habrastorage.org/web/2f7/404/a32/2f7404a32b0942bcb9249a29c2c3e97e.jpg"><img src="https://habrastorage.org/web/24b/796/834/24b7968341c9407694169e0fbb786a80.jpg"><img src="https://habrastorage.org/web/78e/3f6/128/78e3f61282aa477090a3b5cde8895ddd.jpg"><img src="https://habrastorage.org/web/c64/a07/9ad/c64a079ade304ad79f1450a5139f454c.jpg"><img src="https://habrastorage.org/web/ff5/c3d/535/ff5c3d5351954f5fb77b6cab14bd051a.jpg"><img src="https://habrastorage.org/web/8dd/977/596/8dd977596722401795d02dac15f581ab.jpg"><img src="https://habrastorage.org/web/b4c/03d/c82/b4c03dc820a841df8306556ab4b43c62.jpg"><img src="https://habrastorage.org/web/314/5d2/aff/3145d2aff4ac42d89e033ed0d7860e0b.jpg"><img src="https://habrastorage.org/web/fed/8e1/336/fed8e13362e14a1d9eb9bac0bb06d57f.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e8 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/497/d37/50c/497d3750c894473fa06503e478fe105f.jpg"><img src="https://habrastorage.org/web/220/082/f52/220082f529204e088bc455934713a1f4.jpg"><img src="https://habrastorage.org/web/4f0/02a/45b/4f002a45b9e14dfd9cfcd653bc32f028.jpg"><img src="https://habrastorage.org/web/196/90f/4ef/19690f4efbff481eb6d823e77bab84bb.jpg"><img src="https://habrastorage.org/web/e8a/d43/6ac/e8ad436ac3b84f6d9e581d15414a7928.jpg"><img src="https://habrastorage.org/web/a96/7a7/5cc/a967a75cc53840e597cde9f051e88c48.jpg"><img src="https://habrastorage.org/web/807/671/f24/807671f2475a4f0fbd405d9d0e0552af.jpg"><img src="https://habrastorage.org/web/be5/5e5/433/be55e543386c4316abe8eddf35220817.jpg"><img src="https://habrastorage.org/web/425/078/7a8/4250787a83c34bdf8ff35777377f3f68.jpg"><img src="https://habrastorage.org/web/7b9/96b/2af/7b996b2afec84cc5a222d8140109836c.jpg"><img src="https://habrastorage.org/web/cce/e7d/dd8/ccee7ddd81454134b61394eb5149e608.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is pretty clear here too. </font><font style="vertical-align: inherit;">The Timsort algorithm has become noticeable, the sorting affects it more strongly than the others. </font><font style="vertical-align: inherit;">This allowed this algorithm to almost equal the optimized version of quick sort. </font><font style="vertical-align: inherit;">Block sorting, despite the improvement in working time with partial sorting, could not overtake the bitwise sorting.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Swaps </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/2ab/551/801/2ab5518019124296887871f9a6b0fe34.jpg"><img src="https://habrastorage.org/web/54d/02b/9b8/54d02b9b837f49c4bfc82dfcbd30cefc.jpg"><img src="https://habrastorage.org/web/d05/955/abe/d05955abec6e4256bc862b024f75e7ec.jpg"><img src="https://habrastorage.org/web/18b/8b1/50f/18b8b150fad344328b800f2b732d5608.jpg"><img src="https://habrastorage.org/web/924/1fa/67f/9241fa67f42a482cb1319459f27f5ba0.jpg"><img src="https://habrastorage.org/web/f10/5e4/da7/f105e4da78364cd8b420b4b3952465a1.jpg"><img src="https://habrastorage.org/web/fa9/7d8/87b/fa97d887bfd94b809ae518ed6880c982.jpg"><img src="https://habrastorage.org/web/54d/5e2/78a/54d5e278a527477d904b6f84a026614c.jpg"><img src="https://habrastorage.org/web/307/be4/538/307be4538d3246f7ab619f8b2c1c4707.jpg"><img src="https://habrastorage.org/web/9e9/a00/407/9e9a0040725948d1abf5a31528bddf83.jpg"><img src="https://habrastorage.org/web/21c/4c7/d70/21c4c7d7003c40fd92acf40b5ee592a6.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e8 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/13e/df9/1c2/13edf91c269d428096c0918092546a81.jpg"><img src="https://habrastorage.org/web/d9b/fcc/930/d9bfcc9309e243cfa597bbc01d87b928.jpg"><img src="https://habrastorage.org/web/9e5/efd/9cf/9e5efd9cffcf4074b9c5b3ff1396628d.jpg"><img src="https://habrastorage.org/web/31d/84a/9b5/31d84a9b5687468eae19a3e35ffc84a1.jpg"><img src="https://habrastorage.org/web/1b9/1a5/d41/1b91a5d41d1e4aaea9da75d5b998cfe5.jpg"><img src="https://habrastorage.org/web/aaa/f01/9c8/aaaf019c89c4481f86a831238f34999d.jpg"><img src="https://habrastorage.org/web/f6b/d35/155/f6bd351556f147e782e8ff6dda7b1539.jpg"><img src="https://habrastorage.org/web/c46/ab0/fb7/c46ab0fb72fc4787997b04a3c5f6bc17.jpg"><img src="https://habrastorage.org/web/86f/ed3/88b/86fed388b5ba4c29a7af02777abbc128.jpg"><img src="https://habrastorage.org/web/139/75c/865/13975c86576c458a81f670161ebda1a2.jpg"><img src="https://habrastorage.org/web/2fa/eba/adc/2faebaadc7344e688dfce049bd5c8baa.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quick sorts worked very well here. </font><font style="vertical-align: inherit;">This is most likely due to the successful selection of the support element. </font><font style="vertical-align: inherit;">Everything else is almost the same as in the previous group.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permutation changes </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/869/48a/52e/86948a52e9c34914900c62a739466a02.jpg"><img src="https://habrastorage.org/web/db4/33c/29e/db433c29e0cb49f78afecf430fefe225.jpg"><img src="https://habrastorage.org/web/81d/d61/db8/81dd61db8e6744a08d26765303ddaf17.jpg"><img src="https://habrastorage.org/web/dd7/0bf/892/dd70bf8927b3450b81098f33e3dd94ff.jpg"><img src="https://habrastorage.org/web/89a/c48/01e/89ac4801e4204c7eaab238e30c1eb6d0.jpg"><img src="https://habrastorage.org/web/955/8e0/9e4/9558e09e494949a5be1f451cd83bd0aa.jpg"><img src="https://habrastorage.org/web/367/b79/4f6/367b794f6a6d49b78cf8f837b39b687f.jpg"><img src="https://habrastorage.org/web/0da/4dc/487/0da4dc48750f410681a8b1afb7fce064.jpg"><img src="https://habrastorage.org/web/c0d/1c1/f8c/c0d1c1f8ccab4f4d945ddad49d3fff59.jpg"><img src="https://habrastorage.org/web/047/736/da3/047736da3fbc491383e1d6e87304ad14.jpg"><img src="https://habrastorage.org/web/cce/8e9/2fe/cce8e92feb184ab1bec0ad2f5a7bc3da.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e8 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/f5e/0f9/114/f5e0f9114e2f4e5d91fc68b347bb1a67.jpg"><img src="https://habrastorage.org/web/581/6e3/455/5816e345530246d99f842c87f5d32305.jpg"><img src="https://habrastorage.org/web/de5/781/7ca/de57817cace941c2a2e85f09e41e98f3.jpg"><img src="https://habrastorage.org/web/a55/844/c7f/a55844c7f98f461ea5b3561b34db71a8.jpg"><img src="https://habrastorage.org/web/0ad/8df/800/0ad8df8002eb41828030afd6d98ad751.jpg"><img src="https://habrastorage.org/web/98a/922/18a/98a92218a8fa4575b9d72b92eab82959.jpg"><img src="https://habrastorage.org/web/749/396/bb2/749396bb21874fa98d9f4f434b70cf2b.jpg"><img src="https://habrastorage.org/web/6e9/4bc/d92/6e94bcd928384c0a8fadd6d9ba6e04bc.jpg"><img src="https://habrastorage.org/web/1c0/ada/665/1c0ada66538e41ee8d382e1f0782dfa1.jpg"><img src="https://habrastorage.org/web/81b/b7c/2b8/81bb7c2b8a1041f6992190cc6e604906.jpg"><img src="https://habrastorage.org/web/855/ec5/24d/855ec524db3c47a884d90243aca8bd19.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I managed to achieve the desired goal - the bitwise sorting fell even below the adapted quick. </font><font style="vertical-align: inherit;">Block sorting was better than the rest. </font><font style="vertical-align: inherit;">For some reason, timsort overtook the built-in sorting of C ++, although it was lower in the previous group.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replays </font></font></h4><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e7 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/c88/133/e01/c88133e01b634e44b67ee322d7fcd537.jpg"><img src="https://habrastorage.org/web/fdb/397/1b5/fdb3971b5c26449da43ed54556f8a0cb.jpg"><img src="https://habrastorage.org/web/41a/2eb/436/41a2eb4360544c1597b7028511541e99.jpg"><img src="https://habrastorage.org/web/3ce/ff1/793/3ceff17933b641b192bad4e7d050e1df.jpg"><img src="https://habrastorage.org/web/886/63f/2b4/88663f2b46f54b84a38db0849eae6c08.jpg"><img src="https://habrastorage.org/web/e0e/e23/dd1/e0ee23dd14c64d8e8fba905526c7d22e.jpg"><img src="https://habrastorage.org/web/49a/12c/57c/49a12c57c4414d7ab3c82570bcf3f37e.jpg"><img src="https://habrastorage.org/web/6de/d32/7db/6ded327dbd0c4a069fdf89d1afaa820d.jpg"><img src="https://habrastorage.org/web/faa/f4c/3ee/faaf4c3ee1984647adb9f1d1bffc17d5.jpg"><img src="https://habrastorage.org/web/e0b/23f/cc7/e0b23fcc7a3c422f96dcdc7743b9b4a6.jpg"><img src="https://habrastorage.org/web/f43/159/9a2/f431599a26b94f1cbff33a8430374d78.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tables, 1e8 elements</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/2d1/3da/f48/2d13daf482874b5681313c2d0aa3f368.jpg"><img src="https://habrastorage.org/web/856/2a8/883/8562a88835684da298f1f4ca59243bf4.jpg"><img src="https://habrastorage.org/web/d38/834/ca4/d38834ca497647f9ad25316c955f1442.jpg"><img src="https://habrastorage.org/web/09f/ecd/676/09fecd67619547928e2e8ec5a6ccba2b.jpg"><img src="https://habrastorage.org/web/0a3/84d/612/0a384d612d3d4720b3b06e989fedc520.jpg"><img src="https://habrastorage.org/web/e3f/35f/419/e3f35f41941444948b431b2cfdd1e232.jpg"><img src="https://habrastorage.org/web/6ff/9c3/5bc/6ff9c35bc7f94274b83800ff5a6ee3bc.jpg"><img src="https://habrastorage.org/web/217/4fe/e4c/2174fee4c2ee4af2b290d9a02de1aa42.jpg"><img src="https://habrastorage.org/web/c83/310/73a/c8331073a91a4306aadb7c53f69cb233.jpg"><img src="https://habrastorage.org/web/ca2/8b4/f9a/ca28b4f9a22146f1ae1a242c6034133e.jpg"><img src="https://habrastorage.org/web/6bf/d40/efd/6bfd40efd59a4976a1613494fdb734ce.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here everything is rather depressing, all the sortings work with the same dynamics (except linear). </font><font style="vertical-align: inherit;">From the unusual, it can be seen that the merge sort fell below Shell sort.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final results </font></font></h4><br><img src="https://habrastorage.org/web/8e7/79c/4b2/8e779c4b280142b6938fb08ac5432f9e.jpg"><img src="https://habrastorage.org/web/188/f5b/f66/188f5bf666954b08ad6aacfc6ec91d85.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite my efforts, the LSD version of the bitwise sorting still took first place at 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements. </font><font style="vertical-align: inherit;">She also showed an almost linear increase in time. </font><font style="vertical-align: inherit;">Her only weakness I noticed is poor work with permutations. </font><font style="vertical-align: inherit;">The MSD version worked a little worse, primarily due to the large number of tests consisting of random numbers modulo 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I was satisfied with the implementation of block sorting, despite its cumbersome, it showed a good result. By the way, I noticed it too late, it is not fully optimized, you can still separately create run and cnt arrays, so as not to waste time deleting them. Then confidently took the place of various versions of quick sort. Timsort, in my opinion, failed to render them a serious competition, although he was not far behind. Next in speed are merge sorts, after them my versions of Shell sort. The best was the sequence s * 3 + s / 3, where s is the previous element of the sequence. Next comes the only discrepancy in the two tables - the comb sorting turned out to be better with a larger number of elements than Shell sorting with the Sedgwik sequence.And for the last place the pyramid sorting and the original sort of Shell were fighting.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Won the last one. By the way, Shell sorting, as I later checked, works very poorly on tests of size 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so she was just lucky that she was in the first group.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we talk about practical application, then bitwise sorting (especially the lsd version) is good, it is stable, easy to implement and very fast, but not based on comparisons. Of the sorts based on comparisons, quick sorting looks best. Its drawbacks are instability and quadratic operating time on unsuccessful input data (even if they can occur only with the intentional creation of a test). But this can be dealt with, for example, by choosing a supporting element by some other principle, or by switching to a different sort on failure (for example, introsort, which, if I‚Äôm not mistaken, is implemented in C ++). Timsort is devoid of these shortcomings, works better on heavily sorted data, but it‚Äôs still slower overall and is much more difficult to write. The remaining sorting at the moment, perhaps, is not very practical. Except, of course,sorting inserts, which can be very well sometimes inserted into the algorithm.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I should note that not all known sortings took part in testing, for example, smooth sorting was missed (I just could not implement it adequately). However, I do not think that this is a big loss, this sorting is very cumbersome and slow, as you can see, for example, from this article: </font></font><a href="https://habrahabr.ru/post/133996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habrahabr.ru/post/133996 You</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can also explore sorting for parallelization, but, first, I don‚Äôt experience, and secondly, the results that were obtained are extremely unstable, the influence of the system is very great. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see the results of all launches, as well as some auxiliary testing: </font></font><a href="https://docs.google.com/spreadsheets/d/1rP9bF4IAbUvJXbDCN8lAVkwv53Xo2sg8GX1tYMAs4k8/edit%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link to the document</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://pastebin.com/M08sgZS6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see the code of the entire project.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementations of algorithms with vectors remained, but I do not guarantee their correctness and good work. </font><font style="vertical-align: inherit;">It is easier to take the function codes from the article and redo it. </font><font style="vertical-align: inherit;">Test generators may also not correspond to reality, in fact, they took on this form after the creation of tests, when it was necessary to make the program more compact. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, I am pleased with the work done, I hope that you were interested.</font></font></div><p>Source: <a href="https://habr.com/ru/post/335920/">https://habr.com/ru/post/335920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335904/index.html">A bit of the history of cryptography CCPP: M-105, codenamed Agat</a></li>
<li><a href="../335906/index.html">Available on cryptography on elliptic curves</a></li>
<li><a href="../335908/index.html">Using MVP + TDD in the development of iOS applications</a></li>
<li><a href="../335910/index.html">Own bike for JSON API</a></li>
<li><a href="../335916/index.html">Improvised barcode reader for 1C via Telegram on Go</a></li>
<li><a href="../335922/index.html">Join the game: the MAZE DevOps game from ITSumma</a></li>
<li><a href="../335924/index.html">On the quality of requirements in IT projects, to be honest (from the standpoint of the development team). Part 2</a></li>
<li><a href="../335926/index.html">Implementation and alternative of basic jQuery functions in pure javascript</a></li>
<li><a href="../335928/index.html">Security Week 33: Flash, bye bye, Chrome extensions steal traffic, Apple SEP firmware key is laid out</a></li>
<li><a href="../335930/index.html">New features in Laravel 5.5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>