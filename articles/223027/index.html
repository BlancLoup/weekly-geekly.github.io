<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you need to know about prototypes, closures, and performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so simple 
 At first glance, JavaScript may seem like a fairly simple language. Perhaps this is due to the rather flexible syntax. Or because of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you need to know about prototypes, closures, and performance</h1><div class="post__text post__text-html js-mediator-article"><h4>  Not so simple </h4><br>  At first glance, JavaScript may seem like a fairly simple language.  Perhaps this is due to the rather flexible syntax.  Or because of the similarity with other known languages, for example, with Java.  Well or because of rather small amount of data types, in comparison with Java, Ruby, or .NET. <br><br>  But in reality, the JavaScript syntax is much less simple and obvious than it might initially seem.  Some of the most characteristic features of JavaScript are still misunderstood and not fully understood, especially among experienced developers.  One of these features is performance when retrieving data (properties and variables) and performance problems that arise. <br><br>  In JavaScript, data retrieval depends on two things: prototype inheritance and chains of scope.  For the developer, an understanding of these two mechanisms is absolutely necessary, because it leads to an improvement in the structure, and often also in the performance of the code. <br><a name="habracut"></a><br><h4>  Getting properties in a prototype chain </h4><br>  When accessing a property in JavaScript, the entire chain of object prototypes is viewed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each function in JavaScript is an object.  When a function is called with the <code>new</code> operator, a new object is created. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstName, lastName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstName = firstName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = lastName; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'John'</span></span>, <span class="hljs-string"><span class="hljs-string">'Doe'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>, <span class="hljs-string"><span class="hljs-string">'Doe'</span></span>);</code> </pre><br><br>  In the example above, <code>p1</code> and <code>p2</code> two different objects, each of which is created using the <code>Person</code> constructor.  As you can see from the following example, they are independent instances of <code>Person</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(p1 <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Person); <span class="hljs-comment"><span class="hljs-comment">//  'true' console.log(p2 instanceof Person); //  'true' console.log(p1 === p2); //  'false'</span></span></code> </pre><br><br>  Once functions are in JavaScript objects, they can have properties.  The most important property they have is called <code>prototype</code> . <br><br>  <code>prototype</code> , which is an object, is inherited from the parent prototype again and again until it reaches the top level.  This is often called a <i>prototype chain</i> .  At the beginning of the chain is always the <code>Object.prototype</code> (that is, at the topmost level of the prototype chain);  it contains the <code>toString()</code> , <code>hasProperty()</code> , <code>isPrototypeOf()</code> methods, and so on. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18e/642/d7f/18e642d7f5fb6448ad928bb17ed3fdbf.png"><br><br>  The prototype of each function can be extended by its own methods and properties. <br><br>  When creating a new instance of an object (by calling a function with the <code>new</code> operator), it inherits all the properties through the prototype.  However, keep in mind that instances do not have direct access to the prototype object, only its properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Person    //  'getFullName': Person.prototype.getFullName = function() { return this.firstName + ' ' + this.lastName; } //  p1     console.log(p1.getFullName()); //  'John Doe' //   p1      'prototype'... console.log(p1.prototype); //  'undefined' console.log(p1.prototype.getFullName()); //  </span></span></code> </pre><br><br>  This is an important and subtle point: even if <code>p1</code> was created before defining the <code>getFullName</code> method, it will still have access to it, because its prototype was the prototype of <code>Person</code> . <br><br>  (It is worth mentioning that browsers retain a reference to the prototype in the <code>__proto__</code> property, but its use spoils karma, at least because it is not in <a href="http://www.ecma-international.org/ecma-262/5.1/">ECMAScript standard</a> , so <i>do not use it</i> ). <br><br>  Since the <code>Person</code> <code>p1</code> instance does not have direct access to the prototype object, we must rewrite the <code>getFullName</code> method in <code>p1</code> like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    p1.getFullName, ** p1.prototype.getFullName, //  p1.prototype : p1.getFullName = function(){ return '  '; }</span></span></code> </pre><br><br>  Now <code>p1</code> has its own property <code>getFullName</code> .  But the <code>p2</code> instance does not have its own implementation of this property.  Accordingly, the call to <code>p1.getFullName</code> pulls the object's own method of <code>p1</code> , while the call to <code>p2.getFullName()</code> goes up the prototype chain to <code>Person</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(p1.getFullName()); <span class="hljs-comment"><span class="hljs-comment">//  '  ' console.log(p2.getFullName()); //  'Robert Doe'</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/115/c48/8fb/115c488fb1d76ae14f5d40d73d74cd42.png" alt="image"><br><br>  Another thing to fear is the ability to dynamically change the prototype of an object: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.someVar = <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//   Parent,     'sayHello' Parent.prototype.sayHello = function(){ console.log('Hello'); }; function Child(){ //      //    . Parent.call(this); }; //   Child     'otherVar'... Child.prototype.otherVar = 'otherValue'; // ...       Child  Parent // (     'otherVar', //     Child  'otherVar'   ) Child.prototype = Object.create(Parent.prototype); var child = new Child(); child.sayHello(); //  'Hello' console.log(child.someVar); //  'someValue' console.log(child.otherVar); //  'undefined'</span></span></code> </pre><br><br>  When using prototype inheritance, remember that the properties of the child prototype should be set <i>after</i> inheriting from the parent object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb2/298/d22/fb2298d2288256b9e19f0ff7edd6b852.png"><br><br>  So, getting the properties in the prototype chain works like this: <br><br><ul><li>  If the object has a property with the desired name, it is returned.  (With the help of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>hasOwnProperty</code></a> method, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>hasOwnProperty</code></a> can verify that this is the object's own property). </li><li>  If the object has nothing similar, look at the object's prototype. </li><li>  If there is nothing, then we are checking his own prototype. </li><li>  And so on, until we find the desired property. </li><li>  If we got to the Object.prototype, but did not find anything, the property is considered not set. </li></ul><br><br>  Understanding how prototype inheritance works is generally important for developers, but beyond that it is important because of its influence (sometimes noticeable) on performance.  As written in the V8 documentation, most JavaScript engines use a data structure similar to a dictionary to store properties.  Therefore, calling any property requires a dynamic search to find the desired property.  This method makes accessing properties in JavaScript much slower than accessing instance variables in languages ‚Äã‚Äãsuch as Java or Smalltalk. <br><br><h4>  Finding a variable through a chain of scopes </h4><br>  Another JavaScript search engine is based on a closure. <br><br>  To understand how this works, you need to enter such a concept as <a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/">the execution context</a> . <br><br>  In JavaScript, two types of execution context: <br><br><ul><li>  Global, created when javascript is started </li><li>  Local, created when the function is called </li></ul><br><br>  Execution contexts are organized in a stack.  At the bottom of the stack is always a global context, unique to each program.  Each time a function is encountered, a new execution context is created and placed at the beginning of the stack.  As soon as the function is completed, its context is dropped from the stack. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var message = 'Hello World'; var sayHello = function(n){ //   1      var i = 0; var innerSayHello = function() { //   2      console.log((i + 1) + ': ' + message); //   2   } for (i = 0; i &lt; n; i++) { innerSayHello(); } //   1   }; sayHello(3); // : // 1: Hello World // 2: Hello World // 3: Hello World</span></span></code> </pre><br><br>  In each execution context, there is a special object called a scope chain that is used to resolve variables.  The chain is essentially a stack of available execution contexts, from current to global.  (To be more precise, the object at the top of the stack is called the <i>Activation Object</i> and contains: references to local variables for the executable function, given function arguments and two ‚Äúspecial‚Äù objects: <code>this</code> and <code>arguments</code> ). <br><br><img src="//habrastorage.org/files/e7a/a2b/452/e7aa2b4525914966bf81f7f1146427c3.png"><br><br>  Notice how the default diagram points to the <code>window</code> object, and that the global object contains other objects, such as <code>console</code> and <code>location</code> . <br><br>  When trying to resolve a variable through a chain of scopes, it first checks the current context for the desired variable.  If no match is found, the next context object in the chain is checked, and so on, until the desired is found.  If nothing is found, throw <code>ReferenceError</code> . <br><br>  In addition, it is important to note that a new scope is added if <code>try-catch</code> or <code>with</code> blocks are encountered.  In all these cases, a new object is created and placed at the top of the visibility chain. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstName, lastName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstName = firstName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = lastName; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">persist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (person) { <span class="hljs-comment"><span class="hljs-comment">//  'person'      //       "with",        // 'firstName'  'lastName',    person.firstName  // person.lastName if (!firstName) { throw new Error('FirstName is mandatory'); } if (!lastName) { throw new Error('LastName is mandatory'); } } try { person.save(); } catch(error) { //   ,   'error' console.log('Impossible to store ' + person + ', Reason: ' + error); } } var p1 = new Person('John', 'Doe'); persist(p1);</span></span></code> </pre><br><br>  In order to fully understand how a variable is resolved in a scope environment, it is important to remember that JavaScript does not currently have scope areas at the block level. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">// 'i'     ! console.log(i); //  '10'</span></span></code> </pre><br><br>  In most other languages, the code above will lead to an error, because the ‚Äúlife‚Äù (i.e. scope) of the variable <code>i</code> will be limited to a for block.  But not in javascript.  i is added to the Activation Object at the top of the scope chain, and remains there until the object is deleted, which happens after the execution context is removed from the stack.  This behavior is known as floating variables. <br><br>  It is worth mentioning that block-level scope support appeared in JavaScript with the addition of the new <code>let</code> keyword.  It is already available in JavaScript 1.7 and should become an officially supported keyword starting with ECMAScript 6. <br><br><h4>  Performance impact </h4><br>  The way of finding and resolving variables and properties is one of the key features of JavaScript, but at the same time it is one of the most subtle and tricky points to understand. <br><br>  The search operations that we have described along a chain of prototypes or scopes are repeated each time a property or variable is called.  When this happens in a loop or during another heavy operation, you immediately feel the impact on code performance, especially against the background of the single-threaded nature of JavaScript, which prevents you from performing multiple operations at the same time. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta = <span class="hljs-number"><span class="hljs-number">10</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; ChildA.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parent(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildB</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} ChildB.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildA(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} ChildC.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildB(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildD</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; ChildD.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildC(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildE</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; ChildE.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nestedFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; k++) { counter += child.delta; } } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Final result: '</span></span> + counter); } nestedFn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = end - start; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Total time: '</span></span> + diff + <span class="hljs-string"><span class="hljs-string">' milliseconds'</span></span>);</code> </pre><br><br>  In the code above, we have a long inheritance tree and three nested loops.  In the deepest cycle, the counter is incremented by the value of the variable <code>delta</code> .  But the delta value is determined at the very top of the inheritance tree!  <i>This means that each time you call <code>child.delta</code> entire tree is viewed from top to bottom</i> .  This can adversely affect performance. <br><br>  Realizing this time, we can easily improve the performance of nestedFn by locally <code>child.delta</code> value of <code>child.delta</code> in the <code>delta</code> variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nestedFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delta = child.delta; <span class="hljs-comment"><span class="hljs-comment">// cache child.delta value in current scope for(var i = 0; i &lt; 1000; i++) { for(var j = 0; j &lt; 1000; j++) { for(var k = 0; k &lt; 1000; k++) { counter += delta; // no inheritance tree traversal needed! } } } console.log('Final result: ' + counter); } nestedFn(); var end = new Date().getTime(); var diff = end - start; console.log('Total time: ' + diff + ' milliseconds');</span></span></code> </pre><br><br>  Naturally, we can do this if we only know for sure that the value of <code>child.delta</code> will not change during the execution of loops;  otherwise, we will have to periodically update the value of the variable with the current value. <br><br>  So, let's run now both versions of <code>nestedFn</code> and see if there is a noticeable difference in performance between them. <br><br><pre> <code class="bash hljs">diego@alkadia:~$ node test.js Final result: 10000000000 Total time: 8270 milliseconds</code> </pre><br><br>  The execution took about 8 seconds.  It's a lot. <br><br>  Now let's see what with our optimized version: <br><br><pre> <code class="bash hljs">diego@alkadia:~$ node test2.js Final result: 10000000000 Total time: 1143 milliseconds</code> </pre><br><br>  This time, just a second.  Much faster! <br><br>  The use of local variables to prevent heavy queries is used both for finding properties (through a chain of prototypes) and for resolving variables (through scope). <br><br>  Moreover, this ‚Äúcaching‚Äù of values ‚Äã‚Äã(i.e., in local variables) gives a gain when using some common JavaScript libraries.  Take jQuery, for example.  It supports ‚Äúselectors,‚Äù a mechanism for obtaining one or more DOM elements.  The ease with which this happens ‚Äúhelps‚Äù to forget how much the search on the selector is a difficult operation.  Therefore, storing the search results in a variable gives a significant increase in performance. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     DOM  $('.container') "n"  for (var i = 0; i &lt; n; i++) { $('.container').append(‚ÄúLine ‚Äú+i+‚Äù&lt;br /&gt;‚Äù); } //  ... // ,    $('.container')  , //     DOM "n"  var $container = $('.container'); for (var i = 0; i &lt; n; i++) { $container.append("Line "+i+"&lt;br /&gt;"); } //      ... //     DOM  $('.container')  , //   DOM    var $html = ''; for (var i = 0; i &lt; n; i++) { $html += 'Line ' + i + '&lt;br /&gt;'; } $('.container').append($html);</span></span></code> </pre><br><br>  The second approach will give significantly better performance than the first, especially on pages with a large number of elements. <br><br><h4>  Summarize </h4><br><br>  Finding data in JavaScript is quite different from other languages, and there are a lot of nuances.  Therefore, it is necessary to fully and most importantly correctly understand his concepts in order to truly know this language.  This knowledge will bring cleaner, more reliable code and improved performance. </div><p>Source: <a href="https://habr.com/ru/post/223027/">https://habr.com/ru/post/223027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223013/index.html">Reverse engineering and writing a bot for a flash game on Go</a></li>
<li><a href="../223015/index.html">Jump Start May 20: Data Center Virtualization using Windows Server 2012 R2 and System Center 2012 R2. Deploying Virtual Machines and Services</a></li>
<li><a href="../223017/index.html">5,000 rubles for website promotion: is there a business outside the Moscow Ring Road?</a></li>
<li><a href="../223021/index.html">Hadoop and Automation: Part 3</a></li>
<li><a href="../223025/index.html">Restoration of virginity accelerator Cyberstorm MK-III for Amiga computers</a></li>
<li><a href="../223037/index.html">Problems on the networks. Strange fall</a></li>
<li><a href="../223041/index.html">One use of annotations</a></li>
<li><a href="../223045/index.html">The ideal strategy of the game "2048"</a></li>
<li><a href="../223047/index.html">Laravel Forge</a></li>
<li><a href="../223049/index.html">‚ÄúWe can block Twitter or Facebook in Russia for a few minutes tomorrow‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>