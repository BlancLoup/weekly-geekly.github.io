<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Text captchas are easily recognized by deep learning neural networks.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deep learning neural networks have achieved great success in pattern recognition. At the same time, text captchas are still used in some well-known fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Text captchas are easily recognized by deep learning neural networks.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/fh/pr/cj/fhprcj4p0t2kvznyqnryihhl8qk.png"><br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D1%2583%25D0%25B1%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Deep learning neural networks</a> have achieved great success in pattern recognition.  At the same time, text captchas are still used in some well-known free email services.  I wonder if neural networks will be able to do deep learning to cope with the task of captcha recognition?  If so, how? <br><a name="habracut"></a><br><h4>  What is text captcha? </h4><br>  Captcha (eng. ‚ÄúCAPTCHA‚Äù) is a test for ‚Äúhumanity‚Äù.  That is, a task that is easily solved by a person, while for a machine, this task must be difficult.  Often used text with stuck letters, the example in the picture below, the image is also subjected to optical distortion. <br><br><img src="https://habrastorage.org/webt/lb/io/nl/lbionls99pnguecd-0wg6vk9mns.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Captcha is usually used on the registration page to protect against spam bots. <br><br><h4>  Full-convolutional neural network </h4><br>  If the letters ‚Äústuck together‚Äù, then they are usually very difficult to separate by heuristic algorithms.  Therefore, you need to look for each letter in each place of the picture.  The <a href="https://arxiv.org/pdf/1605.06211.pdf">full-convolutional neural network</a> will cope with this task.  Full-convolutional network - a convolutional network without a fully meshed layer.  An image is fed to the input of such a network; at the output, it also gives an image or several images (center maps). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2t/kq/yo/2tkqyo6dias5gx_3eybfyxm7ayc.png"></div><br><br>  The number of center cards is equal to the length of the alphabet of symbols used in a particular captcha.  The centers of the letters are marked with centers of letters.  The large-scale transformation that occurs in the network due to the presence of pulling layers is taken into account.  The following is an example of a character map for the ‚ÄúD‚Äù character. <br><img src="https://habrastorage.org/webt/wi/bv/gn/wibvgn6yq1ifhqtvpslqyw8gzfa.png"><br>  In this case, convolutional layers with padding are used so that the size of the images at the output of the convolutional layer is equal to the size of the images on the input layer.  The spot profile on the character map is given by a two-dimensional Gaussian function with widths of 1.3 and 2.6 pixels. <br>  Initially, the full-convolution net was tested on the ‚ÄúR‚Äù symbol: <br><img src="https://habrastorage.org/webt/jk/i6/bk/jki6bk3ucioupbye4sgwppaednk.png"><br>  A small network with 2 pulling, natrenni on the CPU was used for testing.  After making sure that the idea at least somehow works, I purchased a used Nvidia GTX 760, 2GB graphics card.  This gave me the opportunity to train larger networks for all the characters of the alphabet, and also accelerated learning (about 10 times).  For training the network, the <a href="http://deeplearning.net/software/theano/">Theano</a> library was used, currently <a href="https://groups.google.com/forum/">not supported anymore</a> . <br><br><h4>  Training on the generator </h4><br>  It seemed a long and laborious task to mark up a large dataset manually, so it was decided to generate captcha with a special script.  In this case, maps of the centers are generated automatically.  I chose the font used in the captcha for the <a href="https://www.live.com/">Hotmail</a> service, the generated captcha was visually similar in style to the real captcha: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/99/0_/hv990_9ghwt89xuonvcnq8x-qha.png"></div><br>  The final accuracy of training on generated captcha, as it turned out, is 2 times lower, compared to training on real captcha.  Probably, such nuances as the degree of intersection of symbols, scale, thickness of lines of symbols, distortion parameters, etc., are important, and these nuances could not be reproduced in the generator.  The network trained on generated captcha gave about 10% accuracy on real captcha, accuracy - what percentage of captcha was recognized correctly.  A captcha is considered recognized if all the characters in it are recognized correctly.  In any case, this experiment showed that the method is working, and it is required to increase the accuracy of recognition. <br><br><h4>  Training on a real dataset </h4><br>  For manual markup of real captcha datasets, a script was written on Matlab with a graphical interface: <br><br><img src="https://habrastorage.org/webt/3u/fi/iu/3ufiiu98wnjgthkewafvnm03m_u.png"><br><br>  Here you can arrange the circles and move the mouse.  The circle marks the center of the symbol.  Manual marking took 5-15 hours, however there are services where for a small fee they manually mark up datasets.  However, as it turned out, the <a href="https://www.mturk.com/mturk/welcome">Amazon Mechanical Turk service</a> does not work with Russian customers.  Placed an order for markup dataset on the famous freelancing site.  Unfortunately, the quality of the markup was not perfect, I corrected the markup myself.  In addition, the search for the artist takes time (1 week) and it also seemed expensive: $ 30 for the 560 marked captcha.  He refused this method, eventually came to use the manual recognition of captcha sites, where the lowest cost is 1 dollar for 2000 captchas.  But the answer received there is a string.  Thus, manual placement of the centers could not be avoided.  Moreover, the performers in such services make mistakes or act in bad faith at all, typing an arbitrary string in the answer.  As a result, it was necessary to check and correct errors. <br><br><h4>  Deeper network </h4><br>  Obviously the recognition accuracy was insufficient, so the question arose of the selection of architecture.  I was interested in the question of whether one pixel ‚Äúsees‚Äù on the output image the entire character on the input image: <br><br><img src="https://habrastorage.org/webt/ux/l2/r2/uxl2r20aufy-srttzmmb5j-ad1u.png"><br><br>  Thus, we consider one pixel in the output image, and there is a question: what values ‚Äã‚Äãof pixels on the input image affect the values ‚Äã‚Äãof this pixel?  I reasoned like this: if a pixel does not see the whole character, then not all the information about the character is used and the accuracy is worse.  To determine the size of this scope (we will call it that way), I conducted the following experiment: I set all the weights of the convolutional layers to 0.01, and the offset to 0, an image is fed to the input of the network, in which the values ‚Äã‚Äãof all pixels are 0 except the central one.  As a result, the output of the network is a stain: <br><br><img src="https://habrastorage.org/webt/ch/w0/hv/chw0hvkg7yt523c4gbb3_szm7k0.png"><br>  The shape of this spot is close to the shape of the Gaussian function.  The shape of the resulting spot raises the question: why is the spot round, while the bundle cores are square in convolutional layers?  (The network used 3x3 and 5x5 kernels).  My explanation is this: it looks like the <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B5%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0">central limit theorem</a> .  In it, as here, there is a desire for a Gaussian distribution.  The central limit theorem states that for random variables, even with different distributions, the <a href="http://sernam.ru/book_tp.php%3Fid%3D60">distribution of their sum is equal to the convolution of the distributions</a> .  Thus, if we fold any signal with ourselves many times, then according to the central limit theorem, the result tends to a Gaussian function, and the width of the Gaussian function grows as the root of the number of convolutions (layers).  If for the same network with constant weights to see where in the output image the pixel values ‚Äã‚Äãare greater than zero, then it turns out to be a square area (see figure below), the size of this area is proportional to the sum of the sizes of convolutions in the convolutional layers of the network. <br><br><img src="https://habrastorage.org/webt/tj/23/9s/tj239s1v082tot_azqj3gscgmsk.png"><br>  I used to think that because of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7)">associative property of convolution,</a> two consecutive 3x3 convolutions are equivalent to a 5x5 convolution and therefore, if you roll 2 2x 3x3 cores, you get one 5x5 core.  However, then I came to the conclusion that this is not equivalent if only because two bundles have 3x3 9 * 2 = 18 parameters, and one has 5x5 25 parameters, thus, the 5x5 convolution has more degrees of freedom.  As a result, the output of the network is a Gaussian function with a width less than the sum of the sizes of the bundles in the layers.  Here I answered the question which pixels on the output are affected by one pixel on the input.  Although initially the question was posed to reverse.  But both questions are equivalent, which can be understood from the figure: <br><br><img src="https://habrastorage.org/webt/mo/dr/_h/modr_hbw1j21xylwm5o4tf1mn6q.png"><br>  In the figure you can imagine that this is a view of images from the side or that our image height is 1. Each of the pixels A and B has its own zone of influence on the output image (marked in blue): for A this is DC, for B it is CE , the values ‚Äã‚Äãof pixel C are affected by the values ‚Äã‚Äãof pixels A and B and the values ‚Äã‚Äãof all pixels between A and B. Distances are equal: AB = DC = CE (taking into account scaling: there are pulling layers in the network, therefore the input and output images have different resolutions).  As a result, we get the following algorithm for finding the size of the scope: <br><br><ol><li>  set constant weights in convolutional layers, weights set weights to 0 </li><li>  input images with one non-zero pixel </li><li>  get the spot size at the output </li><li>  we multiply this size by a factor that takes into account the different resolutions of the input and output layers (for example, if we have 2 pooling in the network, then the output resolution is 4 times less than the input, then this size must be multiplied by 4). </li></ol><br>  In order to see what signs the network uses, he conducted the following experiment: send a captcha image to the trained network, receive images with marked centers of characters at the output, select a detected character from them, leave only the map that corresponds to the considered one on the center image cards. character.  This network output is memorized as <img src="https://habrastorage.org/webt/zq/vs/mp/zqvsmpudob-cfmohrzq9w17ong8.png">  , then gradient descent minimizes the function: <br><br><img src="https://habrastorage.org/webt/jp/rn/k3/jprnk3r4a1g4sioenkvor04gryk.png"><br><br>  Here <img src="https://habrastorage.org/webt/i2/vr/od/i2vrodgtncwieod27nz_udkynx4.png">  - input network image, <img src="https://habrastorage.org/webt/mk/rk/4m/mkrk4m-kym1cpkdcqps-byed7vc.png">  - output images of the network, <img src="https://habrastorage.org/webt/im/5n/rj/im5nrjolnajht4dwhpeq7ahieqi.png">  - some constant, which is chosen experimentally ( <img src="https://habrastorage.org/webt/s6/np/0r/s6np0rj5sct7snmgpc4rjxyoye4.png">  ).  With such a minimization, the input and output of the network are considered variables, and the weights of the network are constants.  Variable initial value <img src="https://habrastorage.org/webt/i2/vr/od/i2vrodgtncwieod27nz_udkynx4.png">  This image of the captcha is the starting point for the optimization of the gradient descent algorithm.  With this minimization, we reduce the pixel values ‚Äã‚Äãat the image input, while keeping the pixel values ‚Äã‚Äãat the output image, as a result of optimization, only those pixels that the network uses in character recognition remain on the input image. <br>  What happened: <br>  For the character ‚Äú2‚Äù: <br><img src="https://habrastorage.org/webt/c8/uo/2l/c8uo2lhr6whyys9k3tbhwwxra80.png"><br>  For the ‚Äú5‚Äù symbol: <br><img src="https://habrastorage.org/webt/d1/l3/6s/d1l36sc0jasltcfzffg0nkmd9pk.png"><br>  For the ‚ÄúL‚Äù symbol: <br><img src="https://habrastorage.org/webt/qo/cz/if/qoczif9hqgxh4hezawh7uqkzcui.png"><br>  For the ‚Äúu‚Äù character: <br><img src="https://habrastorage.org/webt/o3/sp/ay/o3spaydkmg5ctrgnky3uoi7b2b4.png"><br>  The images on the left are the original captch images, the images on the right are an optimized image <img src="https://habrastorage.org/webt/i2/vr/od/i2vrodgtncwieod27nz_udkynx4.png">  .  The square on the images indicates the scope of output&gt; 0, the circles in the figure are the lines of the level of the Gaussian function of the scope.  Small circle - the level of 35% of the maximum value, a large circle - the level of 3%.  Examples show what the network sees within its scope.  However, the ‚Äúu‚Äù symbol has a going beyond the scope, perhaps this is a partial false response to the ‚Äún‚Äù symbol. <br><br>  Many experiments with the network architecture have been carried out, the deeper and wider the network, the more complex captcha it can recognize, the most universal architecture is the following: <br><img src="https://habrastorage.org/webt/ke/m-/cw/kem-cwbtycelvmmld4g_l8h-k-g.png"><br>  Blue color, over the arrows, shows the number of images (feature maps).  c - convolutional layer, p - max-pooling layer, the green sizes at the bottom show the sizes of the cores.  The convolutional layers use 3x3 and 5x5 kernels without strade, the pulling layer has a 2x2 patch.  After each convolutional layer there is a ReLU layer (not shown in the figure).  One image is fed to the input, the output is 24 (the number of characters in the alphabet).  In convolutional layers, the padding is selected so that at the exit of the layer the image size is the same as at the entrance.  Padding adds zeros, but this does not affect the network in any way, because the background pixel value of the captcha is 0, since a negative image is always taken (white letters on a black background).  Padding only slightly slows down the network.  Since the network has 2 pulling layers, the image resolution at the output is 4 times less than the image resolution at the input, thus each pulling reduces the resolution by 2 times, for example, if we have a captcha at the input of 216x96, then the output will have 24 images of 54x24 . <br><br><h4>  Improvements </h4><br>  The transition from the SGD solver to the ADAM solver gave a noticeable acceleration of learning, and the final quality became better.  The ADAM solver imported from the <a href="https://github.com/Lasagne/Lasagne">lasagne</a> module and used inside the theano-code, the learning rate parameter was set to 0.0005, the L2 regularization was added through the gradient.  It was observed that from training to training the result is different.  I explain it this way: the gradient descent algorithm is stuck in an insufficiently optimal local minimum.  I partially overcame it in the following way: I ran the training several times and selected some of the best results, then I continued to train them for several more eras, after which I chose one best result and already this single best result I trained for a long time.  Thus, it was possible to avoid getting stuck in insufficiently optimal local minima and the final value of the error function (loss) was obtained sufficiently small.  The figure shows a graph - the evolution of the value of the error function: <br><img src="https://habrastorage.org/webt/ih/g_/wm/ihg_wmvslsq7uhciwi0lkadeuro.png"><br>  On the x axis, the number of epochs, on the y axis, the value of the error function.  Different colors show different workouts.  The order of training is like this: <br><br>  1) run 20 workouts of 10 eras <br>  2) choose the 10 best results (at the lowest loss value) and train them for another 100 eras <br>  3) choose one best result and continue to train it for another 1500 epochs. <br><br>  It takes about 12 hours.  Of course, to save memory, these trainings were carried out sequentially, for example, in point 2) 10 trainings were carried out sequentially one after another, for this I carried out a modification of the ADAM solver from Lasagne to be able to save and load the state of the solver into variables. <br><br>  Dividing the dataset into 3 parts made it possible to track network retraining: <br><br>  Part 1: training dataset - the initial one, where the network is trained <br>  Part 2: test dataset, on which the network is checked during training <br>  3 part: deferred dataset, it checks the quality of training after training <br><br>  Datasets 2 and 3 are small, in my case there were 160 captchas in each, and the optimal response threshold is determined from dataset 2, the threshold that is set on the output image.  If the pixel value exceeds the threshold, then the corresponding symbol is found in this place.  Typically, the optimal threshold value is in the range of 0.3 - 0.5.  If the accuracy on the test dataset is significantly lower than the accuracy on the training dataset, this means that retraining has occurred and the training dataset needs to be increased.  If these precisions are about the same, but not high, then the neural network architecture needs to be complicated, and the training data should be increased.  Complicate the network architecture in two ways: to increase the depth or increase the width. <br><br>  Pre-processing of images also increased recognition accuracy.  Pre-processing example: <br><img src="https://habrastorage.org/webt/74/lq/ug/74lqugawef81mnhhi91p0l6zkic.png"><br>  In this case, using the least squares method, the middle line of the rotated line was found, it is rotated and scaled, scaling is carried out along the average line height.  <a href="https://www.live.com/">Hotmail</a> often makes a variety of distortions: <br><img src="https://habrastorage.org/webt/2p/6d/hu/2p6dhurgzo20vq7omk5lp1xrop4.jpeg"><img src="https://habrastorage.org/webt/r4/bt/qd/r4btqdg7qigraa2yxbi7nn_z_qg.jpeg"><img src="https://habrastorage.org/webt/yh/w6/ec/yhw6ect0tyea225gtqfd4zaivp0.jpeg"><br>  These distortions need to be compensated. <br><br><h4>  Bad ideas </h4><br>  It is always interesting to read about other people's failures, I will describe them here. <br><br>  There was a problem with a small dataset: for quality recognition, a large dataset was needed, which was required to be manually marked out (1000 caps).  I have made various attempts to somehow train the network qualitatively in a small dataset.  I tried to train the network on the results of recognition of another network.  at the same time I chose only those captchas and those places of images in which the network was confident.  Confidence was determined by the pixel value on the output image.  Thus it is possible to increase.  However, the idea did not work, after several iterations of learning, the quality of recognition deteriorated greatly: the network did not recognize some characters, confused them, that is, recognition errors accumulated. <br><br>  Another attempt to learn in a small dataset is to use Siamese networks, the Siamese network at the entrance requires a couple of captchas, if we dataset from N captchas, then the pair will be N <sup>2</sup> , we get much more teaching examples.  The network converts captcha to a vector map.  As the metric of similarity of vectors chose the scalar product.  It was assumed that the Siamese network will work as follows.  The network compares a part of the image on a captcha with a certain reference image of a symbol, if the network sees that the symbol is the same, taking into account the distortion, then it is considered that there is a corresponding symbol in this place of kachi.  The Siamese network practiced with difficulty, often getting stuck in a non-optimal local minimum, the accuracy was noticeably lower than the accuracy of a conventional network.  Perhaps the problem was in the wrong choice of the vector similarity metrics. <br><br>  There was also an idea to use autoencoder for preliminary training of the lower part of the network (the one that is closer to the entrance) in order to speed up learning.  The autoencoder is a network that learns to produce the same image as the input on the output image, while organizing a narrow section in the architecture of the autoencoder.  Training avtoenkodera have training without a teacher. <br><br>  An example of autoecoder operation: <br><img src="https://habrastorage.org/webt/oq/9d/s6/oq9ds63d1ppkqkez1yae97nrogm.png"><br>  The first image is the input, the second is the output. <br>  A trained avtoenkoder take the lower part of the network, add new untrained layers, all this is tested for the desired task.  In my case, the use of an avtoenkoder did not accelerate the training of the network. <br><br>  There was also an example of a captcha that used color: <br><br><img src="https://habrastorage.org/webt/kc/01/s0/kc01s0ubyvdb7cz_mnwfmejhx7g.jpeg"><img src="https://habrastorage.org/webt/b2/6m/g6/b26mg69yu1xkzbceofgrcfmozry.jpeg"><br><br>  On this captcha, the described method with a full-convolutional neural network did not give a result, it did not appear even after various image preprocessing enhancing the contrast.  I suppose that full-convolutional nets do not cope well with low-contrast images.  However, this captcha was recognized by a conventional convolutional network with a fully connected layer, an accuracy of about 50% was obtained, and the coordinates of the symbols were determined using a special heuristic algorithm. <br><br><h4>  Result </h4><br><table><tbody><tr><th>  Examples </th><th>  Accuracy </th><th>  Commentary </th></tr><tr><td><img src="https://habrastorage.org/webt/aq/tg/j0/aqtgj0tektnoefhgxmyrzdegwcy.jpeg"><br><br><img src="https://habrastorage.org/webt/sq/fd/1u/sqfd1uus901vqlsbrvkrj3u1aru.jpeg"><br></td><td>  42% </td><td rowspan="3">  <a href="https://outlook.live.com/owa/%3Fnlp%3D1%26signup%3D1">Captcha Microsoft</a> <br>  jpg <br><br></td></tr><tr><td><img src="https://habrastorage.org/webt/r1/v1/jv/r1v1jvdphzq5an1nj2firdu5o24.jpeg"></td><td>  61% </td></tr><tr><td><img src="https://habrastorage.org/webt/p2/vq/lj/p2vqlj3s6x_gitn-5nqhqxya5qk.jpeg"></td><td>  63% </td></tr><tr><td><img src="https://habrastorage.org/webt/ga/fu/ur/gafuurwl_cqdzzj2qsrixr7ajtk.jpeg"></td><td>  93% </td><td>  captcha <a href="https://mail.ru/">mail.ru</a> , 500x200, jpg </td></tr><tr><td><img src="https://habrastorage.org/webt/j2/ig/nd/j2ignd-fre7eys3be4m5wjuvzly.jpeg"></td><td>  87% </td><td>  captcha <a href="https://mail.ru/">mail.ru</a> , 300x100, jpg </td></tr><tr><td><img src="https://habrastorage.org/webt/08/8r/af/088rafe0wn-l3dorn7mgz7oazi4.gif"></td><td>  65% </td><td>  Captcha <a href="https://mail.yandex.ru/">Yandex</a> , Russian words, gif </td></tr><tr><td><img src="https://habrastorage.org/webt/kr/ns/_c/krns_cg9cxqu10orkcu0gfjvoiy.png"></td><td>  70% </td><td>  Captcha <a href="https://steamcommunity.com/">Steam</a> , png </td></tr><tr><td><img src="https://habrastorage.org/webt/tw/s3/xw/tws3xwzso1fnf3pvwo-motuvcfy.png"></td><td>  82% </td><td>  captcha <a href="https://ru.wargaming.net/personal/password_reset/new/">World Of Tanks</a> , numbers, png </td></tr></tbody></table><br><h4>  What else could be improved </h4><br>  It would be possible to make an automatic marking of the centers of symbols.  The manual recognition services for captcha give out only recognized lines, so automatic marking of the centers would help to fully automate the marking of the training dataset.  The idea is this: to choose only those captchas in which each symbol occurs once, for each symbol to train a separate ordinary convolutional network, such a network will only answer the question: is there a symbol in this captcha or not?  Then, see which attributes the network uses using the minimization method of the pixel values ‚Äã‚Äãof the input image (described above).  The obtained signs will allow to localize the symbol, then we train the full-convolution net on the received centers of symbols. <br><br><h4>  findings </h4><br>  Text captchas are recognized by a full-convolutional neural network in most cases.  Probably, the time has come to abandon the text captchas.  Google has not used text captcha for a long time; instead of text, images with various objects are suggested that need to be recognized by a person: <br><img src="https://habrastorage.org/webt/rl/uj/ez/rlujezycqxpjbkagek_r7c1uox8.png"><br>  However, this problem seems to be solved for the convolutional network.  It can be assumed that in the future there will be people‚Äôs registration centers, for example, a person is interviewed by a live person on Skype, checks passport scans and the like, then a person is given a digital signature with which he can automatically register on any site. <br>  ¬© Maxim Vedenev </div><p>Source: <a href="https://habr.com/ru/post/343222/">https://habr.com/ru/post/343222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343210/index.html">We solve the problem of finding the length of the largest increasing subsequence</a></li>
<li><a href="../343212/index.html">Understanding Dagger 2</a></li>
<li><a href="../343216/index.html">"Write letters ..." or train to work with data on appeals of citizens to the government of Moscow (DataScience)</a></li>
<li><a href="../343218/index.html">Security Week 47: Blue Tooth Toys, Green-Eyed Taxi With Drain And Bilge Tetris</a></li>
<li><a href="../343220/index.html">How we prepared Crystal for production</a></li>
<li><a href="../343224/index.html">The digest of interesting materials for the mobile developer # 231 (November 20 - November 26)</a></li>
<li><a href="../343226/index.html">Cloud technology and my future</a></li>
<li><a href="../343228/index.html">White function or quadratic cosine "comes"</a></li>
<li><a href="../343232/index.html">Eh, I do not like to write boilerplate, because there is IntelliJ IDEA and Apache Velocity</a></li>
<li><a href="../343234/index.html">Biomes painter: fill the world with content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>