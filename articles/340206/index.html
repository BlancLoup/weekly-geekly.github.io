<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>BaumankaCoin - a bike in 3000 lines or a blockchain on the fingers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About Blockchain today does not write just lazy. There is a huge number of articles of varying degrees of clarity and usefulness. This is the next one...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>BaumankaCoin - a bike in 3000 lines or a blockchain on the fingers</h1><div class="post__text post__text-html js-mediator-article"><p>  About Blockchain today does not write just lazy.  There is a huge number of articles of varying degrees of clarity and usefulness.  This is the next one.  We wanted to create as simple as possible, but a <strong>working</strong> blockchain and write briefly, but understandable to non-specialists, how <del>  this dog </del>  This blockchain works.  This is how the project BaumankaCoin was born, the source of which can be <a href="https://github.com/AdPatres/BaumankaCoin">downloaded from GitHub</a> . </p><br><p>  Many people imagine the blockchain and cryptocurrency technology as a kind of mega rocket science.  Of course, to understand all the subtleties and nuances - it will take a lot of time;  but in reality, this technology, if you look, turns out to be much easier to understand than is commonly believed.  By implementing our coin, we intended to help people understand the device of these technologies ‚Äúon their fingers‚Äù. </p><br><p><img src="https://habrastorage.org/webt/59/de/ed/59deed25d964b972135634.gif"></p><a name="habracut"></a><br><p>  BaumankaCoin was developed by two students, <a href="https://habrahabr.ru/users/almiku/" class="user_link">almiku</a> and <a href="https://habrahabr.ru/users/skalniy/" class="user_link">skalniy,</a> under the mentorship of <a href="https://habrahabr.ru/users/pavelmstu/" class="user_link">PavelMSTU</a> . </p><br><h2 id="osnovy">  The basics </h2><br><h3 id="tranzakciya">  Transaction </h3><br><p>  The first semantic unit with which we will deal is a transaction: transferring money from one account to another.  In the modern world of banking systems, the transfer is carried out by reducing the amount opposite one name and increasing opposite another.  In a blockchain transaction is arranged differently. </p><br><p>  For now let's leave the question about <del>  mysterious and terrible </del>  mining, but let's talk only about transactions in the blockchain. </p><br><p>  To begin with, assume that transactions look like this: </p><br><ul><li>  Transaction 1 "Vasya sent 50 koins to Anya" </li><li>  Transaction 2 ‚ÄúGrisha sent 30 koins to Anya‚Äù </li><li>  ... </li></ul><br><p>  Having information <strong>about all</strong> completed transactions, you can find out the amounts in the accounts of Ani, Vasya and Grisha. <br>  The overall structure is a bit more complicated.  In each transaction there are fields: </p><br><ul><li>  <strong>inputs</strong> - transactions that this transaction refers to. </li><li>  <strong>tails</strong> - a list of structures of the form: {recipient, amount}. </li></ul><br><p>  In our case, the transaction structure of Vasya and Grisha will look like this: </p><br><p><img src="https://habrastorage.org/webt/59/df/d0/59dfd0ea37e51829987129.png"></p><br><p>  Now suppose that Anya was going to translate Ole 70 baumankakainov.  As it was written above, for this Anya needs to refer to the transaction from Vasya and Grisha.  The translation structure will be as follows: </p><br><p><img src="https://habrastorage.org/webt/59/df/d0/59dfd0b94ab08328403980.png"></p><br><p>  We remember that when transferring a person is obliged to refer to previous transactions, however, you can refer to each specific transaction only once.  That is, in order to spend the remaining 10 Coins, Anya cannot refer to money transfers from Vasya and from Grisha.  What to do? </p><br><p>  There is a very elegant way out of this situation: Anna must make a transfer for the remaining amount to herself. </p><br><p><img src="https://habrastorage.org/webt/59/df/d0/59dfd09472bd1479928020.png"></p><br><p>  In the future, Anya will be able to refer to the translation, which she made to herself, which will allow her to spend the last 10 coins. </p><br><p>  As a result, all the operations described above can be represented as follows: </p><br><p><img src="https://habrastorage.org/webt/59/df/d1/59dfd1379fb37233028607.png"></p><br><h3 id="identifikaciya-polzovateley">  User identification </h3><br><p>  Let's talk about how a person gets the address of his e-wallet, to which people will transfer money to him.  This procedure consists of three stages, which we will discuss later: generation of private and public keys, obtaining an address. </p><br><p><img src="https://habrastorage.org/webt/59/de/f3/59def34cd2969713288852.png"></p><br><p>  The main tool that determines each individual is the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2581_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D0%25BC_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25BE%25D0%25BC">private key</a> .  Thus, to create a new account, you just need to take a random number from a certain range.  If the number is chosen really randomly - the probability of coincidence that someone else has chosen the same number is extremely small. </p><br><p>  Next, the <strong>public</strong> <strong>key</strong> is built using the <strong>private key</strong> .  Then the public key is passed as an argument to the <strong><a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">hash function</a></strong> . </p><br><p>  Cryptographic hash functions are used in coin emission and message authentication protocols.  In this particular case, the hash function is used to generate pseudo-random numbers.  There are various functions for hashing, we will look at <a href="https://ru.wikipedia.org/wiki/SHA-2">SHA-256</a> .  Its peculiarity is that it converts any amount of incoming data into a hash of 256 bits.  The result of the function, which is also a hash, is essentially the address of our wallet. </p><br><p>  It must be said that knowing the value of the public key, it is difficult to calculate by what private key it was built.  Also, the number of possible results of the function is <strong><sup>2,256</sup></strong> . </p><br><p><img src="https://habrastorage.org/webt/59/de/f8/59def8cc2b5a2257857206.png"></p><br><h3 id="validaciya">  Validation </h3><br><p>  Now, when making a transfer, we need to confirm that we are indeed the owners of the wallet.  To do this, two more fields appear in the transaction structure: </p><br><ul><li>  signature; </li><li>  public key. </li></ul><br><p>  <strong>Step A:</strong> our key is recorded in the public key field. </p><br><p>  <strong>Step B: the</strong> transaction is signed and the signature is recorded in the appropriate field. </p><br><p>  What is a signature?  The signature creation scheme is as follows: </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df057fc55aa044224561.png"></p><br><p>  All transaction information is <strong>collected</strong> , <strong>i.e. inputs</strong> , <strong>tails</strong> and the <strong>public key</strong> .  This information is passed to the hash function, and the hash and private key are transferred to the signature algorithm.  This algorithm works in such a way that it is possible to find out with the help of the public key whether the correct private key was actually used, but the private key itself cannot again be known.  The output is a string weighing 512 bits. </p><br><p>  The overall structure of the transaction is as follows: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transaction</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Input&gt; inputs; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Tail&gt; tails; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; pubKey = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">279</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; signature = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); . . . };</code> </pre> <br><h3 id="blok">  Block </h3><br><p>  We now turn to the blocks. </p><br><p>  A block is an object that stores several transactions and a link to the previous block. </p><br><p>  The creation of the block involved in the so-called <strong>miners</strong> (about them below).  To create a new block, you need to fill in all the fields and fulfill a certain condition.  The block creation scheme is as follows: </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df057fc561d454521573.png"></p><br><p>  The illustration shows the process as a result of which the first block appears.  Let's look at it in more detail. </p><br><ol><li>  The first thing that a miner faces is checking the correctness of transactions that network members want to implement.  He should validate the signatures and check that transactions do not refer to already used tails.  It is also worth noting that one block can hold a limited amount of information, so the number of transactions for a block is limited. </li><li>  After that, all validated transactions are passed as arguments to the hash function.  At the output, we get one of the elements of the first block - <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Root</a> . </li><li>  The data supplied to the second hash function (see picture): hash header of the previous block;  merkle root;  transactions;  <strong>nonce</strong> (about this field below). </li><li>  Everything is hashed and the hash is checked for a "specific view".  For example, it checks that the last 4 bytes of the hash are zeros.  If this is not the case, the <strong>nonce</strong> field changes and the miner again tries to get the block.  It is impossible to predict the result of the hash function, which means that the miner simply needs to change the <strong>nonce</strong> argument until the result takes the desired form. </li></ol><br><p>  Thus, a valid block can be considered a block that includes the hash of the previous block, the hash of all transactions entered into the block, the list of transactions themselves and <strong>nonce</strong> fields, and the hash of this block must have a certain appearance, which is achieved by making changes to the <strong>nonce</strong> field. </p><br><p>  As soon as the miner selects the required <strong>nonce</strong> value, he can send this block to all network participants and mine the next one.  If someone made this block before him, he would have to start work already with the new block. </p><br><p>  For example, a series of 3 blocks will look like this: </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df0580142b7021233080.png"></p><br><h3 id="neizmennost-dannyh">  Data persistence </h3><br><p>  Since the information is transmitted over the network, anyone can change it and pass on the false version. <br>  The blockchain device eliminates such attempts.  The information inside the transaction cannot be changed, since the signature will become invalid.  The information in the block itself cannot be changed either, since the merkle root hash will not correspond to reality and / or the block hash itself will not satisfy the conditions.  Thus achieve the immutability of information. </p><br><h3 id="samaya-pervaya-tranzakciya">  The very first transaction </h3><br><p>  An attentive reader may wonder what the first block refers to?  Especially for this case there is a ‚ÄúGenesis block‚Äù ( <a href="https://bitcoin.org/en/glossary/genesis-block">Genesis block</a> ) with known fields and a generation algorithm.  A chain is considered legitimate only if it begins with a genesis block and all transactions and blocks contained in it are also legitimate. </p><br><div class="spoiler">  <b class="spoiler_title">Our version</b> <div class="spoiler_text"><p>  In BaumankaCoin for ease of implementation there is no genesis block.  Instead, the hash of the first block has a hash of the previous block equal to 0. </p></div></div><br><h3 id="razvetvlenie">  Branching </h3><br><p>  Any miner can add a block to the blockchain (provided that all checks are passed).  And, since the blockchain is a sequence, the blocks can be numbered by the so-called ‚Äúheight‚Äù - the sequence number from the genesis block number 0, however this height is not a unique block identifier. </p><br><p>  Each block can only refer to the previous one, but what happens if several blocks appear that refer to the same one?  They will have the same height (that is why the height is not used as an identifier), and the chain will become more like a tree.  This really happens from time to time when miners create blocks with a difference of just a few seconds (or if attackers with large computing power have attempted to roll back transactions).  This is called "fork" ( <a href="https://bitcoin.org/en/glossary/fork">chainfork</a> ). </p><br><p>  Each node independently chooses which of these blocks to accept.  We agreed to stop the selection at the first received.  Sooner or later, a block with a greater height will appear, then the ‚Äúmain‚Äù will become a longer chain, and the forks will be gradually forgotten (as a rule, they do not grow more than one block). </p><br><p><img src="https://habrastorage.org/webt/59/df/35/59df353171ccd192214402.png"></p><br><p>  Blocks of forks in some sources are called <a href="https://bitcoin.org/en/glossary/orphan-block">orphan</a> , in others <a href="https://bitcoin.org/en/glossary/stale-block">stale</a> .  At <a href="https://en.bitcoin.it/">bitcoin.it</a> , for example, the terminology changes in different articles ( <a href="https://en.bitcoin.it/wiki/Block_chain">1</a> , <a href="https://en.bitcoin.it/wiki/Pooled_mining">2</a> ).  We stick to the name "stale", because  it is closer etymologically.  But it is worth mentioning the orphan-blocks.  These are such blocks whose information about the predecessors of which the node does not yet possess (that is, cannot verify their authenticity).  Recently, few client applications support the work with orphan-blocks, they are usually rejected. </p><br><h3 id="set">  Network </h3><br><p>  The blockchain is built on a peer-to-peer broadcast network, where each node stores a complete copy of the entire chain.  This is sufficient to maintain the basic functionality (block and transaction exchange).  For example, in Bitcoin, this is about 130GB at the time of writing (the <a href="https://blockchain.info/charts/blocks-size">actual size is here</a> ). </p><br><p>  One of the main problems to be addressed in order to connect a new node to the network is the search for the rest of the network.  There is no fully decentralized solution at the moment.  Bitcoin uses a BitTorrent tracker analogy called <a href="https://bitcoin.org/en/glossary/dns-seed">DNS Seed</a> , a server that is used to help find the other peers.  The information on such servers is hard. </p><br><div class="spoiler">  <b class="spoiler_title">Our version</b> <div class="spoiler_text"><p>  For simplicity, BaumankaCoin stores information about famous peers in an INFO file </p></div></div><br><p>  Further connection to all known peers is the same and completely decentralized.  Let's look at this process in more detail and for definiteness we call the new node <strong>A</strong> , and the already well-known feast <strong>B.</strong>  When connected, <strong>A</strong> sends a <strong>B</strong> <em>version-</em> message with the following content: </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df058956f44699849163.png"></p><br><div class="spoiler">  <b class="spoiler_title">Our version</b> <div class="spoiler_text"><p>  In BaumankaCoin trimmed to </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">version</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: . . . net_addr addr_recv; net_addr addr_from; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nonce; };</code> </pre> </div></div><br><p>  <strong>B</strong> must reply with an empty <em>verack</em> message and set the protocol version to the minimum from his and those received from <strong>A</strong> , and also send the <em>version</em> from his side.  Similar actions are done by <strong>A.</strong>  This process is called a ‚Äúhandshake‚Äù (version handshake), and after it is completed, the nodes communicate using a protocol version supported by both of them. </p><br><p>  Next is the exchange of information about famous feasts.  <strong>A</strong> requests from <strong>B a</strong> list of active peers known to him by means of a <em>getaddr</em> request that contains nothing.  A peer is considered active if <strong>B has</strong> received messages from him recently (in Bitcoin, the last three hours).  <strong>B</strong> responds with <em>addr-</em> message with information about nodes. </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df0589991c4967510891.png"></p><br><h3 id="inventory-soobscheniya">  Inventory messages </h3><br><p>  When someone creates or receives a transaction or block, he sends an <em>inv</em> message containing several structures of the type {object type (block / transaction), hash} with information about these objects.  The recipient responds to <em>getdata</em> messages with the same structures as <em>inv</em> structures, but listing only new objects for themselves.  And only after that, sending messages with complete information about the blocks ( <em>block</em> ) and transactions ( <em>tx</em> ) occurs. </p><br><div class="spoiler">  <b class="spoiler_title">Our version</b> <div class="spoiler_text"><p>  The query in BaumankaCoin for simplicity contains only the above hash of the last block.  In non-learning cryptocurrencies everything is a bit more complicated. </p></div></div><br><p><img src="https://habrastorage.org/webt/59/df/05/59df0589f3e3f924747350.png"></p><br><p>  After the handshake, <strong>A</strong> still knows nothing about the relevance of his blockchain.  Therefore, this information should be updated.  For this, <strong>A</strong> sends a <em>getblocks</em> request containing the hash of the last block it knows to. </p><br><p>  If <strong>B</strong> has newer blocks, it sends them with pre-sending <em>inv</em> messages.  The whole process described looks something like this: </p><br><p><img src="https://habrastorage.org/webt/59/df/05/59df058a411cb404352459.png"></p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Hopefully, these simple explanations of complex processes have helped form the reader‚Äôs idea of ‚Äã‚Äãblockchain technology.  One of the most useful articles that helped us throughout the work was <a href="https://habrahabr.ru/post/319868/">Bitcoin in a Nutshell</a> .  As well as protocols with bitcoin.org and bitcoin.it.  We remind you that the source can be <a href="https://github.com/AdPatres/BaumankaCoin">downloaded here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340206/">https://habr.com/ru/post/340206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340196/index.html">ScadaPy application modbus protocol</a></li>
<li><a href="../340198/index.html">Kali Linux: security test questions</a></li>
<li><a href="../340200/index.html">Steve Wozniak opened an online university Woz U</a></li>
<li><a href="../340202/index.html">Love static code analysis</a></li>
<li><a href="../340204/index.html">Cj - new programming language</a></li>
<li><a href="../340210/index.html">New Yandex.Cashi API: payment lego for e-commerce of all stripes</a></li>
<li><a href="../340212/index.html">Deep learning with R and Keras on the example of the Carvana Image Masking Challenge</a></li>
<li><a href="../340214/index.html">Preview RamblerFront & # 3</a></li>
<li><a href="../340216/index.html">SQL Server: Performance when inserting data into a table with a clustered index and without</a></li>
<li><a href="../340218/index.html">MBLTdev 2017 is near: program on hardcore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>