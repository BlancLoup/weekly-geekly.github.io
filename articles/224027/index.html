<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Steam Files. Part 1 - GCF / NCF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As promised in the previous article , I begin to publish articles about the part of the Steam infrastructure that the Anti-Steam community was able to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Steam Files. Part 1 - GCF / NCF</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/000/dca/198/000dca198a459957c5d705d59a8bc514.png" alt="Steam Logo" align="left">  As promised in the <a href="http://habrahabr.ru/post/223961/">previous article</a> , I begin to publish articles about the part of the Steam infrastructure that the Anti-Steam community was able to open by reverse engineering and lengthy brainstorming. <br><br>  Until recently, GCF format files were the standard for all games produced by VALVE, and NCF for all others.  In themselves, these files represent a file system image with several levels of protection.  The difference between NCF and GCF is that the former contain only headers, and the files belonging to them are located in a separate directory ( <i>&lt;Steam&gt; / SteamApps / common / &lt;game name&gt;</i> ).  Therefore, I will describe the GCF, and all the features of the NCF will be given later. <br><br>  In this article I will examine in detail the structure of these files and work with them on the example of my library (a link to it is at the end of the article).  The beginning will be quite boring - a description of the structure and purpose of their fields.  The most "tasty" will be after them ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All the code shown here is the result of reverse engineering of the Steam libraries.  Most of the information about the format of files was obtained from <a href="http://wiki.singul4rity.com/steam:filestructures:gcf">open sources</a> , but I added a little bit and significantly optimized work with cache files (even in comparison with the most popular HLLIB library at that time). <br><a name="habracut"></a><br><h4>  General file structure </h4><br>  The file is logically divided into 2 parts - the headers and the content itself.  The content is divided into blocks, which in turn are divided into sectors of 8kB, which belong to certain files and their sequence is described in the headers.  All headers contain fields that are four-byte integers (the exception is the part responsible for the list of file and directory names). <br><br>  Headers consist of the following structures: <br><ul><li>  Fileheader </li><li>  BlockAllocationTableHeader </li><li>  BlockAllocationTable [] </li><li>  FileAllocationTableHeader </li><li>  FileAllocationTable [] </li><li>  ManifestHeader </li><li>  Manifest [] </li><li>  FileNames </li><li>  HashTableKeys [] </li><li>  HashTableIndices [] </li><li>  MinimumFootprints [] </li><li>  UserConfig [] </li><li>  ManifestMapHeader </li><li>  ManifestMap [] </li><li>  Checksumdatacontainer </li><li>  FileIdChecksumTableHeader </li><li>  FileIdChecksums [] </li><li>  Checksums [] </li><li>  ChecksumSignature </li><li>  LatestApplicationVersion </li><li>  Dataheader </li></ul><br>  The first thing that catches your eye is <i>ChecksumSignature</i> , which is the encrypted hash of the header section responsible for checksums of files. <br>  All these headers and the purpose of their fields will be discussed below. <br>  For those who did not read very carefully, let me remind you that all the fields of almost all headers are four-byte integers ( <b>uint32_t</b> in C ++), unless otherwise specified. <br><br><h5>  Fileheader </h5><br>  Based on the name, is the header of the entire file and contains the following fields: <br><ul><li>  Headerversion </li><li>  Cachetype </li><li>  FormatVersion </li><li>  ApplicationID </li><li>  ApplicationVersion </li><li>  Ismounted </li><li>  Dummy0 </li><li>  FileSize </li><li>  ClusterSize </li><li>  ClusterCount </li><li>  Checksum </li></ul><br>  <i>HeaderVersion</i> is always 0x00000001, indicating the version of this header. <br>  <i>CacheType</i> is 0x00000001 for GCF and 0x00000002 for NCF. <br>  <i>FormatVersion</i> - indicates the version of the structure of the remaining headers.  The latest version is 6. It will be described below. <br>  <i>ApplicationID</i> - file identifier (AppID). <br>  <i>ApplicationVersion</i> - the version of the file contents.  Used to control the need for updates. <br>  <i>IsMounted</i> - contains 0x00000001 if the file is currently mounted by another application.  Currently not used, therefore always equal to 0x00000000. <br>  <i>Dummy0</i> - leveling field containing 0x00000000. <br>  <i>FileSize</i> is the total file size.  If it exceeds 4GB, then this field contains the difference <i>&lt;file size&gt; -ffffffff</i> , and the file size is calculated from <br>  block size and quantity <br>  <i>ClusterSize</i> - the size of the data block in the content.  For GCF contains 0x00002000, and for NCF - 0x00000000. <br>  <i>ClusterCount</i> - the number of data blocks in the content. <br>  <i>Checksum</i> - header checksum.  Calculated by the following function: <br><br><pre><code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> HeaderChecksum(<span class="hljs-built_in"><span class="hljs-built_in">UINT8</span></span> *lpData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size) { <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Checksum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i&lt;Size ; i++) Checksum += *(lpData++); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Checksum; }</code> </pre> <br>  The first parameter is the pointer to the structure, and the second is its size, with the exception of the <i>Checksum</i> field (that is, 4 less). <br><br><h5>  BlockAllocationTableHeader </h5><br>  Contains the description of the block table (not sectors!): <br><ul><li>  Blockcount </li><li>  BlocksUsed </li><li>  LastUsedBlock </li><li>  Dummy0 </li><li>  Dummy1 </li><li>  Dummy2 </li><li>  Dummy3 </li><li>  Checksum </li></ul><br>  <i>BlockCount</i> - contains the total number of blocks in the file. <br>  <i>BlocksUsed</i> - the number of used blocks.  Always less than the total number of blocks.  If it approaches it, the value of the total number increases, causing all subsequent headers to be rebuilt and the first data sector to move to the end of the file to free up space for headers. <br>  <i>LastUsedBlock</i> - the index of the last block used. <br>  <i>Dummy0, Dummy1, Dummy2, Dummy2</i> - leveling fields, contain 0x00000000. <br>  <i>Checksum</i> - header checksum.  Contains the sum of all previous fields. <br><br><h5>  BlockAllocationTable </h5><br>  Is an array of <i>BlockAllocationTableEntry</i> structures, the number of which is equal to the total number of blocks ( <i>BlockAllocationTableHeader.BlockCount</i> ): <br><ul><li>  <b>uint16_t</b> Flags </li><li>  <b>uint16_t</b> Dummy0 </li><li>  Filedataoffset </li><li>  FileDataSize </li><li>  FirstClusterIndex </li><li>  NextBlockIndex </li><li>  PreviousBlockIndex </li><li>  ManifestIndex </li></ul><br>  <i>Flags</i> - contains bit flags of the block.  Possible masks: <br><ul><li>  0x8000 - block is used; </li><li>  0x4000 - local copy of the file takes precedence; </li><li>  0x0004 - the block is encrypted; </li><li>  0x0002 - the block is encrypted and compressed; </li><li>  0x0001 - the block contains some raw data (RAW). </li></ul><br>  <i>Dummy0</i> leveling field, contains 0x0000. <br>  <i>FileDataOffset</i> contains the offset of this block relative to the file to which it belongs. <br>  <i>FileDataSize</i> - the size of a fragment of the file stored in this block. <br>  <i>FirstClusterIndex</i> - index of the first cluster in the cluster table. <br>  <i>NextBlockIndex</i> - the index of the next block.  Contains the value of a <i>BlockAllocationTableHeader.</i>  <i>BlockCount</i> if this is the last block in the chain for this file. <br>  <i>PreviousBlockIndex</i> - contains the index of the previous block in the chain.  If it is the first, then it contains the value of <i>BlockAllocationTableHeader.</i>  <i>Blockcount</i> <br>  <i>ManifestIndex</i> - manifest index for this block. <br>  The index of the table is the block number from the <i>ManifestMap</i> list. <br><br><h5>  FileAllocationTableHeader </h5><br>  Sector Table Header: <br><ul><li>  ClusterCount </li><li>  FirstUnusedEntry </li><li>  IsLongTerminator </li><li>  Checksum </li></ul><br>  <i>ClusterCount</i> - contains the number of sectors.  Contains a value equal to <i>FileHeader.ClusterCount</i> . <br>  <i>FirstUnusedEntry</i> - the index of the first unused sector. <br>  <i>IsLongTerminator</i> - defines the value, which is an indicator of the end of the chain of sectors.  If it contains 0x00000000, then the terminator is 0x0000FFFF, otherwise - 0xFFFFFFFF. <br>  <i>Checksum</i> - header checksum.  As with the <i>BlockAllocationTableHeader</i> , is the sum of the previous header fields. <br><br><h5>  FileAllocationTable </h5><br>  A sector table containing <i>FileAllocationTableHeader.ClusterCount</i> records of type <b>uint32_t</b> .  Each cell contains the index of the next cluster in the chain or the terminator value (see the <i>FileAllocationTableHeader</i> declaration if it is the last in the chain. <br>  The index of the list is the sector number. <br><br><h5>  ManifestHeader </h5><br>  It contains the description of the manifest table: <br><ul><li>  Headerversion </li><li>  ApplicationID </li><li>  ApplicationVersion </li><li>  Nodecount </li><li>  Filecount </li><li>  CompressionBlockSize </li><li>  Binary size </li><li>  NameSize </li><li>  HashTableKeyCount </li><li>  NumOfMinimumFootprintFiles </li><li>  NumOfUserConfigFiles </li><li>  Bitmask </li><li>  Fingerprint </li><li>  Checksum </li></ul><br>  <i>HeaderVersion</i> - version of the header.  Contains 0x00000004. <br>  <i>ApplicationID</i> - file identifier.  Equal to <i>FileHeader.ApplicationID</i> . <br>  <i>ApplicationVersion</i> - the version of the file contents.  Equal to <i>FileHeader.ApplicationVersion</i> . <br>  <i>NodeCount</i> - the number of elements in the manifest. <br>  <i>FileCount</i> - the number of files declared in the manifest (and contained in the cache). <br>  <i>CompressionBlockSize</i> - the maximum size of a compressed block (its uncompressed data). <br>  <i>BinarySize</i> - the size of the manifest (including this structure). <br>  <i>NameSize</i> is the size of the data block containing the element names (in bytes). <br>  <i>HashTableKeyCount</i> - the number of values ‚Äã‚Äãin the hash table. <br>  <i>NumOfMinimumFootprintFiles</i> - the number of files required to run the application (which must be unpacked to disk). <br>  <i>NumOfUserConfigFiles</i> - the number of user configuration files.  With this file on the disk, it is not overwritten when the game starts and has a higher priority. <br>  <i>Bitmask</i> - contains <i>bitmasks</i> .  In public versions, files always contain 0x00000000. <br>  <i>Fingerprint</i> is a unique number that is randomly generated each time a manifest is updated. <br>  <i>Checksum</i> - checksum.  Calculated using the Adler32 algorithm.  The calculation algorithm will be given after the description of the headers. <br><br><h5>  Manifest </h5><br>  A tree containing a description of all the files in the cache.  The size of the table is equal to the value of <i>ManifestHeader.NodeCount</i> .  All elements of the table are represented by the following structures: <br><ul><li>  Nameoffset </li><li>  CountOrSize </li><li>  Fileid </li><li>  Attributes </li><li>  Parentindex </li><li>  NextIndex </li><li>  ChildIndex </li></ul><br>  <i>NameOffset</i> - the offset of the name of the element in the corresponding data block. <br>  <i>CountOrSize</i> - the size of the element.  For directories, it is equal to the number of child elements, and for files, it is directly the size of the file (or part of the file described by this manifest). <br>  <i>FileId</i> - file identifier.  Used to bind multiple manifests for large files and search for a list of checksums. <br>  <i>Attributes</i> - bit file attribute field.  Possible values ‚Äã‚Äã(from confirmed): <br><br><ul><li>  0x00004000 - the node is a file; </li><li>  0x00000100 - encrypted file; </li><li>  0x00000001 - configuration file.  The local copy is not overwritten. </li></ul><br>  <i>ParentIndex</i> - parent element index.  For the root element is 0xFFFFFFFF. <br>  <i>NextIndex</i> - the index of the next item at the current tree level. <br>  <i>ChildIndex</i> - the index of the first child. <br>  If there are no elements for <i>NextIndex</i> and <i>ChildIndex</i> , then they contain the value 0x00000000. <br>  The tree must contain at least one element - the root. <br>  The index of the list containing elements of the tree is the element number (used later) <br><br><h5>  FileNames </h5><br>  A <b>char</b> data block, <i>ManifestHeader.NameSize</i> bytes in size.  Contains <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D1%2583%25D0%25BB%25D1%258C-%25D1%2582%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B0">null-terminated strings</a> , which are the names of the elements described in the manifest tree.  It is obligatory to have the first, root element - an empty string.  The offset of element names is given by the value of <i>Manifest []. NameOffset</i> <br><br><h5>  HashTableKeys </h5><br>  Contains a hash table of item names.  Contains index values ‚Äã‚Äãfor <i>HashTableIndices</i> , distributed over indices derived from <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25BA%25D0%25B8%25D0%25BD%25D1%2581%25D0%25B0">the Jenkins hash function</a> <a href="">lookup2</a> for <a href="">lowercase</a> strings.  More will be considered in the description of the search elements. <br><br><h5>  HashTableIndices </h5><br>  Contains an index table of the elements referenced by the values ‚Äã‚Äãfrom the previous table.  Number of elements - <i>ManifestHeader.NodeCount</i> . <br><br><h5>  MinimumFootprints </h5><br>  Contains a list of item numbers in the <i>Manifest</i> that need to be unpacked when the application starts. <br><br><h5>  Userconfigs </h5><br>  Contains a list of item numbers in the <i>Manifest</i> that are user configuration files. <br><br><h5>  ManifestMapHeader </h5><br>  Manifest map title: <br><ul><li>  Headerversion </li><li>  Dummy0 </li></ul><br>  <i>HeaderVersion</i> - version of the header.  Equal to 0x00000001. <br>  <i>Dummy0</i> - equalizing value.  Contains 0x00000000. <br><br><h5>  Manifestmap </h5><br>  Contains a table of links to the first block ( <i>BlockAllocationTable</i> structure) for each element.  The element index is the element number in the manifest tree.  For directories and files that are not stored in the cache (with a size of zero or for NCF), contains a value equal to <i>BlockAllocationTableHeader.BlockCount</i> . <br><br><h5>  Checksumdatacontainer </h5><br>  Header of the container storing checksums: <br><ul><li>  Headerversion </li><li>  Checksumize </li></ul><br>  <i>HeaderVersion</i> - version of the header.  Equal to 0x00000001. <br>  <i>ChecksumSize</i> - container size.  Calculated from the following structure and by <i>LatestApplicationVersion</i> inclusive. <br><br><h5>  FileIdChecksumTableHeader </h5><br>  Heading the table of checksum indices: <br><ul><li>  FormatCode </li><li>  Dummy0 </li><li>  Fileidcount </li><li>  Checksum count </li></ul><br>  <i>FormatCode</i> is a kind of constant.  Equal to 0x14893721. <br>  <i>Dummy0</i> - leveling field.  Contains the value 0x00000001. <br>  <i>FileIdCount</i> - the number of elements in the <i>"element-first_hesh"</i> table. <br>  <i>ChecksumCount</i> - the number of items in the list of checksums. <br><br><h5>  FileIdChecksums </h5><br>  Table associating files with a list of checksums: <br><ul><li>  Checksum count </li><li>  FirstChecksumIndex </li></ul><br>  <i>ChecksumCount</i> - the number of checksums in the list for this item. <br>  <i>FirstChecksumIndex</i> - the index of the first checksum in the list. <br>  The index is the value of <i>Manifest []. FileId</i> . <br><br><h5>  Checksums </h5><br>  List of checksums.  Contains consecutive sublists whose first element is referenced by the value <i>FileIdChecksums []. FirstChecksumIndex</i> . <br>  Values ‚Äã‚Äãare calculated by the following algorithm: <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Checksum(<span class="hljs-built_in"><span class="hljs-built_in">UINT8</span></span> *lpData, <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> uiSize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (adler32(<span class="hljs-number"><span class="hljs-number">0</span></span>, lpData, uiSize) ^ crc32(<span class="hljs-number"><span class="hljs-number">0</span></span>, lpData, uiSize)); }</code> </pre> <br><br><h5>  ChecksumSignature </h5><br>  The signature of the block checksum.  Contains the hash value for the checksum block calculated using the SHA-1 algorithm and encrypted using the <a href="https://en.wikipedia.org/wiki/PKCS_1">RSASSA-PKCS1-v1_5 algorithm</a> . <br><br><h5>  LatestApplicationVersion </h5><br>  This field contains the version of the checksum block.  Updated to the latest after each content update. <br><br><h5>  Dataheader </h5><br>  A header describing the physical placement of data in the cache: <br><ul><li>  ClusterCount </li><li>  ClusterSize </li><li>  FirstClusterOffset </li><li>  Clustersused </li><li>  Checksum </li></ul><br>  <i>ClusterCount</i> - the number of sectors.  The value is equal to the <i>FileHeader.ClusterCount</i> field. <br>  <i>ClusterSize</i> - sector size.  The value is equal to the <i>FileHeader.ClusterSize</i> field. <br>  <i>FirstClusterOffset</i> - offset of the first sector relative to the beginning of the file. <br>  <i>ClustersUsed</i> - the number of used sectors. <br>  <i>Checksum</i> - header checksum.  Equal to the sum of the previous header fields. <br>  After updating the content, the number of used sectors could be reduced.  In such cases, the released sectors were transferred to the end of the file to reserve space for future updates. <br><br><h4>  Algorithms </h4><br>  Finally, the turn of the most interesting came - the most interesting examples of code working with these structures with detailed explanations.  The full source package can be found on my <a href="https://github.com/andreili/steam_libs">repository</a> . <br><br><h5>  Calculating file size </h5><br>  In most cases, the file size is equal to the value of the <i>Manifest []. CountOrSize field</i> .  But for files larger than 4GB, this path is not suitable.  VALVE programmers went around this way: for files larger than 2GB, set the high-order bit of this field to ‚Äú1‚Äù and enter another (or several) elements in the list with the same values ‚Äã‚Äãof the other fields, obtaining a kind of chain.  Summing up the value of the <i>Manifest []. CountOrSize fields</i> from this chain, we calculate the final file size. <br><br><div class="spoiler">  <b class="spoiler_title">File Size Calculation Code</b> <div class="spoiler_text"><pre> <code class="hljs php">UINT64 CGCFFile::GetFileSize(UINT32 Item) { UINT64 res = lpManifest[Item].CountOrSize &amp; <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((lpManifest[Item].CountOrSize &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (UINT32 i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i&lt;pManifestHeader-&gt;NodeCount ; i++) { ManifestNode *MN = &amp;lpManifest[Item]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((MN-&gt;Attributes &amp; <span class="hljs-number"><span class="hljs-number">0x00004000</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (MN-&gt;ParentIndex == <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>) &amp;&amp; (MN-&gt;NextIndex == <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>) &amp;&amp; (MN-&gt;ChildIndex == <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>) &amp;&amp; (MN-&gt;FileId == lpManifest[Item].FileId)) { res += MN-&gt;CountOrSize &lt;&lt; <span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> </div></div><br>  Here I made a small ‚Äúfeint with my ears‚Äù, assuming that files larger than 4 GB will not be included in the cache ... <br><br><h5>  Search item by name </h5><br>  for example, we need to find a file named ‚Äúhl2 / maps / background_01.bsp‚Äù.  All names are stored in our tree, so the path will have to be divided into elements connected by a separator (in this case, ‚Äú/‚Äù).  Then we look for an element with the name "hl2" among the descendants of the root element.  He has an element with the name "maps", and only then an element with the name "background_01.bsp".  This path is the most obvious, but very slow - there is a byte-by-byte string comparison, and a walk through the tree.  Solid costs. <br>  To speed up this procedure, there are hash tables in the headers. <br><br><div class="spoiler">  <b class="spoiler_title">Search item by name using hash</b> <div class="spoiler_text">  <b>C ++</b> <br><pre> <code class="hljs cpp">UINT32 CGCFFile::GetItem(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *Item) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelimiterPos = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (UINT32 i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i&lt;<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(Item) ; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Item[i] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) DelimiterPos = i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *FileName = &amp;Item[++DelimiterPos]; UINT32 Hash = jenkinsLookupHash2((UINT8*)FileName, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(FileName), <span class="hljs-number"><span class="hljs-number">1</span></span>), HashIdx = Hash % pManifestHeader-&gt;HashTableKeyCount, HashFileIdx = lpHashTableKeys[HashIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HashFileIdx == CACHE_INVALID_ITEM) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(LowerCase(Item), Item) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Hash = jenkinsLookupHash2((UINT8*)LowerCase(Item), <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(FileName), <span class="hljs-number"><span class="hljs-number">1</span></span>); HashIdx = Hash % pManifestHeader-&gt;HashTableKeyCount; HashFileIdx = lpHashTableKeys[HashIdx]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HashFileIdx == CACHE_INVALID_ITEM) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CACHE_INVALID_ITEM; HashFileIdx -= pManifestHeader-&gt;HashTableKeyCount; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { UINT32 Value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;lpHashTableIndices[HashFileIdx]; UINT32 FileID = Value &amp; <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(GetItemPath(FileID), Item) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FileID; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Value &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; HashFileIdx++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CACHE_INVALID_ITEM; }</code> </pre> <br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItemByPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end_block: boolean; Hash, HashIdx, HashValue: ulong; FileID, HashFileIdx: integer; PathEx: AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=-<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF UNICODE}</span></span> PathEx:=Wide2Ansi(ExtractFileName(Path)); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> PathEx:=ExtractFileName(Path); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> Hash:=jenkinsLookupHash2(@PathEx[<span class="hljs-number"><span class="hljs-number">1</span></span>], Length(PathEx), <span class="hljs-number"><span class="hljs-number">1</span></span>); HashIdx:=Hash <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> fManifestHeader.HashTableKeyCount; HashFileIdx:=lpHashTableKeys[HashIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> HashFileIdx=-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LowerCase(Path)&lt;&gt;Path) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF UNICODE}</span></span> Hash:=jenkinsLookupHash2(@LowerCaseAnsi(PathEx)[<span class="hljs-number"><span class="hljs-number">1</span></span>], Length(PathEx), <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> Hash:=jenkinsLookupHash2(@LowerCase(PathEx)[<span class="hljs-number"><span class="hljs-number">1</span></span>], Length(PathEx), <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> HashIdx:=Hash <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> fManifestHeader.HashTableKeyCount; HashFileIdx:=lpHashTableKeys[HashIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> HashFileIdx=-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(HashFileIdx, fManifestHeader.HashTableKeyCount); <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> HashValue:=lpHashTableIndices[HashFileIdx]; FileID:=HashValue <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">7</span></span>FFFFFFF; end_block:= (HashValue <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">80000000</span></span> = $<span class="hljs-number"><span class="hljs-number">80000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CompareStr(ItemPath[FileID], Path)=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=FileID; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(HashFileIdx); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> end_block; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result=-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (LowerCase(Path)&lt;&gt;Path) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result:=GetItemByPath(LowerCase(Path)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br>  As can be seen from the code, from the entire path to the file we take only its name and calculate the hash for it.  We take the remainder of the integer division of the result by the value of <i>ManifestHeader.HashTableKeyCount</i> - this will be the number of the entry in the <i>HashTableKeys</i> list containing either <b>0xffffffff</b> (if there is no such element) or the value <i>X + ManifestHeader.HashTableKeyCount</i> .  Based on this, we calculate <i>X</i> , which is the number of an element in the <i>HashTableIndices</i> list, from which the required element can be located.  The values ‚Äã‚Äãfrom this list indicate the item you are looking for, whose name is compared in the query.  If it does not match, we take the next element of the list and repeat until the most significant bit of the element number is ‚Äú0‚Äù. <br>  <i>I understand what turned out to be confusing, but this is exactly how it works ... Blame the VALVE programmers for this confusion.</i> <br>  This method is much better than direct search in the tree - performance was compared when starting the game with the self-written library emulator Steam.dll, which will be discussed later. <br><br><h5>  Getting the full path to the item </h5><br>  This action is somewhat back to the previous one - by the element number, you need to walk through the tree to the root element and get the path to the file. <br><br><div class="spoiler">  <b class="spoiler_title">Getting the file path</b> <div class="spoiler_text">  <b>C ++</b> <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *CGCFFile::GetItemPath(UINT32 Item) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Item].NameOffset]); UINT32 Idx = lpManifest[Item].ParentIndex; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Idx != CACHE_INVALID_ITEM) { len += <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Idx].NameOffset]) + <span class="hljs-number"><span class="hljs-number">1</span></span>; Idx= lpManifest[Idx].ParentIndex; } len--; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[len+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(res, <span class="hljs-number"><span class="hljs-number">0</span></span>, len+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> l = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Item].NameOffset]); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;res[len-l], &amp;lpNames[lpManifest[Item].NameOffset], l); len -= <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Item].NameOffset]); res[--len] = <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; Item = lpManifest[Item].ParentIndex; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Item != CACHE_INVALID_ITEM) &amp;&amp; (Item != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { l = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Item].NameOffset]); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;res[len-l], &amp;lpNames[lpManifest[Item].NameOffset], l); len -= <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;lpNames[lpManifest[Item].NameOffset]); res[--len] = <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; Item = lpManifest[Item].ParentIndex; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: integer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res: AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res:=pAnsiChar(@fNameTable[lpManifestNodes[Item].NameOffset+<span class="hljs-number"><span class="hljs-number">1</span></span>]); Item:=lpManifestNodes[Item].ParentIndex; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Item&gt;-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res:=pAnsiChar(@fNameTable[lpManifestNodes[Item].NameOffset+<span class="hljs-number"><span class="hljs-number">1</span></span>])+<span class="hljs-string"><span class="hljs-string">'\'</span></span>+res; Item:=lpManifestNodes[Item].ParentIndex; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Delete(res, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$IFDEF UNICODE}</span></span> result:=Ansi2Wide(res); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> result:=res; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br>  <i>The code for Delphi is significantly less due to the fact that for C ++ I did not use the class std :: string - I did not know about it then.</i>  <i>With it, the code would come out much shorter ...</i> <br><br><h5>  Streams </h5><br>  When writing libraries for archive-like file formats (which contain other files), I use the ‚Äústream-to-stream‚Äù principle, which allows you to open files in the archive without unpacking it.  For example, in the old-version cache <i>half-life.gcf</i> was the <i>pak0.pak</i> file, which is an archive.  As a result, I opened the <i>half-life.gcf file</i> , in it - <i>pak0.pak</i> .  in which in turn read the necessary files.  And all this - without unpacking even in memory, all the functionality is implemented through the wrappers I wrote over the file streams (low-level, at the WindowsAPI level). <br><br><div class="spoiler">  <b class="spoiler_title">Opening a file in the cache</b> <div class="spoiler_text">  <b>C ++</b> <br><pre> <code class="hljs objectivec">CStream *<span class="hljs-built_in"><span class="hljs-built_in">CGCFFile</span></span>::OpenFile(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* FileName, <span class="hljs-built_in"><span class="hljs-built_in">UINT8</span></span> Mode) { <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Item = GetItem(FileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Item == <span class="hljs-built_in"><span class="hljs-built_in">CACHE_INVALID_ITEM</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((lpManifest[Item].Attributes &amp; <span class="hljs-built_in"><span class="hljs-built_in">CACHE_FLAG_FILE</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">CACHE_FLAG_FILE</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpenFile(Item, Mode); } CStream *<span class="hljs-built_in"><span class="hljs-built_in">CGCFFile</span></span>::OpenFile(<span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Item, <span class="hljs-built_in"><span class="hljs-built_in">UINT8</span></span> Mode) { StreamData *Data = new StreamData(); memset(Data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(StreamData)); Data-&gt;Handle = (handle_t)Item; Data-&gt;Package = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Data-&gt;Size = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;GetItemSize(Item).Size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsNCF) Data-&gt;FileStream = (CStream*)new CStream(MakeStr(CommonPath, GetItemPath(Item)), Mode==<span class="hljs-built_in"><span class="hljs-built_in">CACHE_OPEN_WRITE</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> BuildClustersTable(Item, &amp;Data-&gt;Sectors); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new CStream(pStreamMethods, Data); }</code> </pre> <br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Access: byte)</span></span></span><span class="hljs-function">:</span></span> TStream; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Item: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; Item:=ItemByPath[FileName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Item=-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((lpManifestNodes[Item].Attributes <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> HL_GCF_FLAG_FILE&lt;&gt;HL_GCF_FLAG_FILE) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (ItemSize[Item].Size=<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; result:=OpenFile(Item, Access); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: integer; Access: byte)</span></span></span><span class="hljs-function">:</span></span> TStream; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res: TStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res:=TStream.CreateStreamOnStream(@StreamMethods); res.Data.fHandle:=ulong(Item); res.Data.Package:=self; res.Data.fSize:=(res.Data.Package <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TGCFFile).ItemSize[Item].Size; res.Data.fPosition:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsNCF) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CommonPath:=IncludeTrailingPathDelimiter(CommonPath); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Access <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ACCES_READ: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> res.Data.FileStream:=TStream.CreateReadFileStream(CommonPath+ItemPath[Item]); res.Methods.fSetSiz:=StreamOnStream_SetSizeNULL; res.Methods.fWrite:=StreamOnStream_WriteNULL; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ACCES_WRITE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ForceDirectories(ExtractFilePath(CommonPath+ItemPath[Item])); res.Data.FileStream:=TStream.CreateWriteFileStream(CommonPath+ItemPath[Item]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ACCES_READWRITE: res.Data.FileStream:=TStream.CreateReadWriteFileStream(CommonPath+ItemPath[Item]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; res.Data.FileStream.Seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, spBegin); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> GCF_BuildClustersTable(Item, @res.Data.SectorsTable); result:=res; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br>  Thus, the work with the contents is much simpler - you can open files and read data from them without unnecessary gestures. <br><br><h5>  Retrieve file with checksum verification </h5><br>  In this procedure, the streams described above are actively used - I just read the file with fragments of a fixed size (the maximum fragment size for checksums is 32Kb), I calculate checksums for them and compare them with the values ‚Äã‚Äãfrom the table in the headers. <br><br><div class="spoiler">  <b class="spoiler_title">Extracting a file with checking its COP</b> <div class="spoiler_text">  <b>C ++</b> <br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">UINT64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGCFFile</span></span>::ExtractFile(<span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Item, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *Dest, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsValidation) { CStream *fileIn = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;OpenFile(Item, <span class="hljs-built_in"><span class="hljs-built_in">CACHE_OPEN_READ</span></span>), *fileOut; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileIn == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsValidation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DirectoryExists(Dest)) Dest = MakeStr(IncludeTrailingPathDelimiter(Dest), GetItemName(Item)); fileOut = new CStream(Dest, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileOut-&gt;GetHandle() == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fileOut-&gt;SetSize(GetItemSize(Item).Size); } <span class="hljs-built_in"><span class="hljs-built_in">UINT8</span></span> buf[<span class="hljs-built_in"><span class="hljs-built_in">CACHE_CHECKSUM_LENGTH</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> CheckSize = <span class="hljs-built_in"><span class="hljs-built_in">CACHE_CHECKSUM_LENGTH</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UINT64</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((fileIn-&gt;Position()&lt;fileIn-&gt;GetSize()) &amp;&amp; (CheckSize == <span class="hljs-built_in"><span class="hljs-built_in">CACHE_CHECKSUM_LENGTH</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Stop) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> CheckIdx = lpFileIDChecksum[lpManifest[Item].FileId].FirstChecksumIndex + ((fileIn-&gt;Position() &amp; <span class="hljs-number"><span class="hljs-number">0xffffffffffff8000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>); CheckSize = (<span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span>)fileIn-&gt;Read(buf, CheckSize); <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> CheckFile = Checksum(buf, CheckSize), CheckFS = lpChecksum[CheckIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckFile != CheckFS) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsValidation) { fileOut-&gt;Write(buf, CheckSize); } res += CheckSize; } delete fileIn; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsValidation) delete fileOut; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtractFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: integer; Dest: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; IsValidation: boolean = false)</span></span></span><span class="hljs-function">:</span></span> int64; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StreamF, StreamP: TStream; CheckSize, CheckFile, CheckFS, CheckIdx: uint32_t; buf: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; Size: int64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=<span class="hljs-number"><span class="hljs-number">0</span></span>; StreamP:=OpenFile(Item, ACCES_READ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StreamP=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Size:=ItemSize[Item].Size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgress) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgress(ItemPath[Item], <span class="hljs-number"><span class="hljs-number">0</span></span>, Size, Data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgressObj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgressObj(ItemPath[Item], <span class="hljs-number"><span class="hljs-number">0</span></span>, Size, Data); StreamF:=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IsValidation) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DirectoryExists(Dest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Dest:=IncludeTrailingPathDelimiter(Dest)+ExtractFileName(ItemName[Item]); StreamF:=TStream.CreateWriteFileStream(Dest); StreamF.Size:=ItemSize[Item].Size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StreamF.Handle=INVALID_HANDLE_VALUE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> StreamF.Free; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SetLength(buf, HL_GCF_CHECKSUM_LENGTH); CheckSize:=HL_GCF_CHECKSUM_LENGTH; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((StreamP.Position&lt;StreamP.Size) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (CheckSize=HL_GCF_CHECKSUM_LENGTH)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckIdx:=lpFileIdChecksumTableEntries[lpManifestNodes[Item].FileId].FirstChecksumIndex+ ((StreamP.Position <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $ffffffffffff8000) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>); CheckSize:=StreamP.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], HL_GCF_CHECKSUM_LENGTH); CheckFile:=Checksum(@buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CheckSize); CheckFS:=lpChecksumEntries[CheckIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckFile&lt;&gt;CheckFS) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IgnoreCheckError) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnError) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnError(GetItemPath(Item), ERROR_CHECKSUM, Data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnErrorObj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnErrorObj(GetItemPath(Item), ERROR_CHECKSUM, Data); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IsValidation) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> StreamF.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CheckSize); inc(result, CheckSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgress) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgress(<span class="hljs-string"><span class="hljs-string">''</span></span>, result, Size, Data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgressObj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgressObj(<span class="hljs-string"><span class="hljs-string">''</span></span>, result, Size, Data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Stop <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SetLength(buf, <span class="hljs-number"><span class="hljs-number">0</span></span>); StreamP.Free; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IsValidation) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> StreamF.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br>  In the code for Delphi there is an additional code to display the progress of the work - a call to the <i>OnProgress, OnProgressObj</i> callback functions. <br><br><h5>  Decrypt file content </h5><br>  Since many games shortly before the release can be downloaded in advance, their content in such cases is completely or partially encrypted.  With the release of the game, the key for decrypting this content becomes available, implemented by the following code: <br><br><div class="spoiler">  <b class="spoiler_title">File decryption</b> <div class="spoiler_text">  <b>C ++</b> <br><pre> <code class="hljs pgsql">UCHAR IV[<span class="hljs-number"><span class="hljs-number">16</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-type"><span class="hljs-type">void</span></span> DecryptFileChunk(<span class="hljs-type"><span class="hljs-type">char</span></span> *buf, UINT32 size, <span class="hljs-type"><span class="hljs-type">char</span></span> *key) { AES_KEY aes_key; AES_set_decrypt_key((UCHAR*)key, <span class="hljs-number"><span class="hljs-number">128</span></span>, &amp;aes_key); AES_cbc_encrypt((UCHAR*)buf, (UCHAR*)buf, size, &amp;aes_key, IV, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } UINT64 CGCFFile::DecryptFile(UINT32 Item, <span class="hljs-type"><span class="hljs-type">char</span></span> *key) { UINT64 res = <span class="hljs-number"><span class="hljs-number">0</span></span>; CStream *str = OpenFile(Item, CACHE_OPEN_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">char</span></span> buf[CACHE_CHECKSUM_LENGTH], <span class="hljs-type"><span class="hljs-type">dec</span></span>[CACHE_CHECKSUM_LENGTH]; UINT32 CheckSize = CACHE_CHECKSUM_LENGTH; INT32 CompSize, UncompSize, sz; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((str-&gt;Position() &lt; str-&gt;GetSize()) &amp;&amp; (CheckSize == CACHE_CHECKSUM_LENGTH)) { UINT32 CheckIdx = lpFileIDChecksum[lpManifest[Item].FileId].FirstChecksumIndex + ((str-&gt;Position() &amp; <span class="hljs-number"><span class="hljs-number">0xffffffffffff8000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>); INT32 CheckSize = (INT32)str-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(buf, <span class="hljs-number"><span class="hljs-number">8</span></span>); memcpy(&amp;CompSize, &amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>); memcpy(&amp;UncompSize, &amp;buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((UINT32)UncompSize &gt; pManifestHeader-&gt;CompressionBlockSize) || (CompSize &gt; UncompSize) || (UncompSize &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span>) || (CompSize &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span>)) { // Chunk <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compressed CheckSize = (UINT32)str-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(&amp;buf[<span class="hljs-number"><span class="hljs-number">8</span></span>], CACHE_CHECKSUM_LENGTH<span class="hljs-number"><span class="hljs-number">-8</span></span>); DecryptFileChunk(&amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CheckSize, key); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((UINT32)UncompSize &lt;= pManifestHeader-&gt;CompressionBlockSize) &amp;&amp; (CompSize &lt;= UncompSize) &amp;&amp; (UncompSize &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>) || (CompSize &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>)) { // Chunk <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> compressed CheckSize = (UINT32)str-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(&amp;buf[<span class="hljs-number"><span class="hljs-number">8</span></span>], UncompSize<span class="hljs-number"><span class="hljs-number">-8</span></span>); INT32 CheckFile = UncompSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CompSize%<span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) sz = CompSize; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sz = CompSize + <span class="hljs-number"><span class="hljs-number">16</span></span> - (CompSize%<span class="hljs-number"><span class="hljs-number">16</span></span>); memcpy(<span class="hljs-type"><span class="hljs-type">dec</span></span>, buf, sz); DecryptFileChunk(&amp;<span class="hljs-type"><span class="hljs-type">dec</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], sz, key); uncompress((Bytef*)&amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], (uLongf*)&amp;CheckFile, (Bytef*)&amp;<span class="hljs-type"><span class="hljs-type">dec</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], sz); } str-&gt;Seek(-CheckSize, USE_SEEK_CURRENT); str-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(&amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CheckSize); UINT32 Check1 = Checksum((UINT8*)&amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CheckSize), Check2 = lpChecksum[CheckIdx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Check1 != Check2) break; res += CheckSize; } lpManifest[Item].Attributes = lpManifest[Item].Attributes &amp; (!CACHE_FLAG_ENCRYPTED); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IV: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptFileChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf: pByte; ChunkSize: integer; Key: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AES: TCipher_Rijndael; src: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..HL_GCF_CHECKSUM_LENGTH-<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Move(buf^, src[<span class="hljs-number"><span class="hljs-number">0</span></span>], HL_GCF_CHECKSUM_LENGTH); AES:=TCipher_Rijndael.Create(); AES.Init(Key^, <span class="hljs-number"><span class="hljs-number">16</span></span>, IV[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>); AES.Mode:=cmCFBx; AES.Decode(src[<span class="hljs-number"><span class="hljs-number">0</span></span>], buf^, ChunkSize); AES.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGCFFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: integer; Key: Pointer)</span></span></span><span class="hljs-function">:</span></span> int64; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StreamP: TStream; CheckSize, CheckFile, CheckFS, CheckIdx, sz: uint32_t; buf: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; dec: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..HL_GCF_CHECKSUM_LENGTH] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; CompSize, UncompSize: integer; Size: int64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=<span class="hljs-number"><span class="hljs-number">0</span></span>; StreamP:=OpenFile(Item, ACCES_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StreamP=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Size:=ItemSize[Item].Size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgress) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgress(ItemName[Item], <span class="hljs-number"><span class="hljs-number">0</span></span>, Size, Data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(OnProgressObj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OnProgressObj(ItemName[Item], <span class="hljs-number"><span class="hljs-number">0</span></span>, Size, Data); SetLength(buf, HL_GCF_CHECKSUM_LENGTH); CheckSize:=HL_GCF_CHECKSUM_LENGTH; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((StreamP.Position&lt;StreamP.Size) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (CheckSize=HL_GCF_CHECKSUM_LENGTH)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckIdx:=lpFileIdChecksumTableEntries[lpManifestNodes[Item].FileId].FirstChecksumIndex+ ((StreamP.Position <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $ffffffffffff8000) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>); CheckSize:=StreamP.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">8</span></span>); Move(buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], CompSize, <span class="hljs-number"><span class="hljs-number">4</span></span>); Move(buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], UncompSize, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ulong(UncompSize)&gt;fManifestHeader.CompressionBlockSize) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CompSize&gt;UncompSize) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (UncompSize&lt;-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CompSize&lt;-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//Chunk is not compressed! CheckSize:=StreamP.Read(buf[8], HL_GCF_CHECKSUM_LENGTH-8); DecryptFileChunk(@buf[0], CheckSize, Key); end else if ((ulong(UncompSize)&lt;=fManifestHeader.CompressionBlockSize) and (CompSize&lt;=UncompSize)) and ((UncompSize&gt;-1) and (CompSize&gt;-1)) then begin CheckSize:=StreamP.Read(buf[8], UncompSize-8); CheckFile:=UncompSize; //Chunk is compressed! if (CompSize mod 16=0) then sz:=CompSize else sz:=CompSize+16-(CompSize mod 16); Move(buf[8], dec[0], sz); DecryptFileChunk(@dec[0], sz, Key); uncompress(@buf[0], CheckFile, @dec[0], sz); end; StreamP.Seek(-CheckSize, spCurrent); StreamP.Write(buf[0], CheckSize); CheckFile:=Checksum(@buf[0], CheckSize); CheckFS:=lpChecksumEntries[CheckIdx]; if (CheckFile&lt;&gt;CheckFS) and (not IgnoreCheckError) then begin if Assigned(OnError) then OnError(GetItemPath(Item), ERROR_CHECKSUM, Data); if Assigned(OnErrorObj) then OnErrorObj(GetItemPath(Item), ERROR_CHECKSUM, Data); break; end; inc(result, CheckSize); //StreamP.Position:=StreamP.Position+CheckSize; if Assigned(OnProgress) then OnProgress('', result, Size, Data); if Assigned(OnProgressObj) then OnProgressObj('', result, Size, Data); if Stop then break; end; lpManifestNodes[Item].Attributes:=lpManifestNodes[Item].Attributes and (not HL_GCF_FLAG_ENCRYPTED); fIsChangeHeader[HEADER_MANIFEST_NODES]:=true; SaveChanges(); SetLength(buf, 0); end;</span></span></code> </pre> </div></div><br><br><h5>     <i>ManifestHeader</i> </h5><br>        : <br><ul><li> ManifestHeader </li><li> Manifest[] </li><li> FileNames </li><li> HashTableKeys[] </li><li> HashTableIndices[] </li><li> MinimumFootprints[] </li><li> UserConfig[] </li></ul><br>      : <br><ul><li> ManifestHeader.Fingerprint </li><li> ManifestHeader.Checksum </li></ul><br>         <a href="https://ru.wikipedia.org/wiki/Adler-32">Adler32</a>    : <br><br>  <b>Delphi</b> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ManifestChecksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Header: pCache_ManifestHeader; entries, names, hashs, table, MFP, UCF: pByte)</span></span></span><span class="hljs-function">:</span></span> uint32_t; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp1, tmp2: uint32; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> tmp1:=Header.Fingerprint; tmp2:=Header.Checksum; Header.Fingerprint:=<span class="hljs-number"><span class="hljs-number">0</span></span>; Header.Checksum:=<span class="hljs-number"><span class="hljs-number">0</span></span>; result:=adler32(<span class="hljs-number"><span class="hljs-number">0</span></span>, pAnsiChar(Header), sizeof(TCache_ManifestHeader)); result:=adler32(result, pAnsiChar(entries), sizeof(TCache_ManifestNode)*Header^.NodeCount); result:=adler32(result, pAnsiChar(names), Header^.NameSize); result:=adler32(result, pAnsiChar(hashs), sizeof(uint32)*Header^.HashTableKeyCount); result:=adler32(result, pAnsiChar(table), sizeof(uint32)*Header^.NodeCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Header^.NumOfMinimumFootprintFiles&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result:=adler32(result, pAnsiChar(MFP), sizeof(uint32)*Header^.NumOfMinimumFootprintFiles); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Header^.NumOfUserConfigFiles&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result:=adler32(result, pAnsiChar(UCF), sizeof(uint32)*Header^.NumOfUserConfigFiles); Header.Fingerprint:=tmp1; Header.Checksum:=tmp2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br><h4>  Conclusion </h4><br>  ,          (        ,     - )    <a href="https://github.com/andreili/steam_libs"></a> (      ,      ).         ( -   ...). <br>        ‚Äî   2011- . <br><br> <b>PS:</b>             <i> </i>   ‚Äî      (, ,    ).     , ,    ,              ‚Äî    -     (  ).          ‚Ä¶ </div><p>Source: <a href="https://habr.com/ru/post/224027/">https://habr.com/ru/post/224027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224003/index.html">Order-Independent Transparency algorithm using link lists on Direct3D 11 and OpenGL 4</a></li>
<li><a href="../224005/index.html">Cube iWork10 - a tablet on a full Windows 8.1 Pro</a></li>
<li><a href="../224017/index.html">Introduced an updated collection of Metro 2033 and Metro: Last Light on Linux, Windows and new consoles</a></li>
<li><a href="../224023/index.html">IT guy on vacation: what about the telescope?</a></li>
<li><a href="../224025/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ110 (May 18 - 24, 2014)</a></li>
<li><a href="../224029/index.html">The secret of the ancient game of go. Why has the computer still not beat the man?</a></li>
<li><a href="../224031/index.html">Derby 0.6 - FAQ</a></li>
<li><a href="../224033/index.html">Useful materials for mobile developer # 54 (May 19-25)</a></li>
<li><a href="../224039/index.html">New perspective gesture interface</a></li>
<li><a href="../224043/index.html">Tylt Energi 2K: AC adapter + spare battery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>