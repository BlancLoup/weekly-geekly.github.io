<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Competitiveness and concurrency on the platform .NET. Patterns of effective design "</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrozhiteli! The Ricardo Terrelli book (Riccardo Terrell) provides insight into the recommended methods for creating competitive and scalable pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Competitiveness and concurrency on the platform .NET. Patterns of effective design "</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/piter/blog/453804/"><img src="https://habrastorage.org/webt/xh/fk/az/xhfkazyaueuwhx3c7cjwt5ohyea.jpeg" align="left" alt="image"></a>  Hi, Habrozhiteli!  The <a href="http://www.rickyterrell.com/">Ricardo Terrelli book</a> (Riccardo Terrell) provides insight into the recommended methods for creating competitive and scalable programs in .NET, highlighting the advantages of the functional paradigm and providing the appropriate tools and principles to easily and properly maintain competitiveness.  As a result, armed with new skills, you will gain the knowledge necessary to become an expert in providing successful high-performance solutions. <br><br>  If you are writing multithreaded code in .NET, then this book can help you.  If you are interested in using a functional paradigm to simplify competitive programming and maximize application performance, then this book will be an important guide for you.  It will benefit any .NET developers who want to write competitive, reactive and asynchronous applications that scale and automatically adapt to existing hardware resources wherever such programs work. <br><a name="habracut"></a><br><h3>  Publication structure: roadmap </h3><br>  The fourteen chapters of this book are divided into three parts.  Part I presents the functional concepts of competitive programming and describes the skills needed to understand the functional aspects of writing multi-threaded programs. <br><br><ul><li>  Chapter 1 describes the basic concepts and goals of competitive programming, as well as the reasons for using functional programming to write multi-threaded applications. </li><li>  Chapter 2 explores a number of functional programming technologies to improve the performance of multi-threaded applications.  The purpose of this chapter is to provide the reader with the concepts used in the rest of the book, and to introduce powerful ideas from the functional paradigm. </li><li>  Chapter 3 provides an overview of the functional concept of immutability.  It explains how immutability is used to write predictable and correct competitive programs and to implement functional data structures that are thread-safe in nature. </li></ul><br>  Part II examines in depth the various models of competitive programming in the functional paradigm.  We will explore topics such as the Task Parallel Library (TPL) and implement parallel templates such as Fork / Join, Divide and Conquer, and MapReduce.  This part also discusses declarative layout, high-level abstractions in asynchronous operations, agent-based programming, and message passing semantics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Chapter 4 outlines the basics of processing a large amount of data in parallel, including patterns such as Fork / Join. </li><li>  Chapter 5 presents more sophisticated methods for parallel processing of large volumes of information, such as parallel aggregation, data reduction and implementation of the parallel MapReduce pattern. </li><li>  Chapter 6 provides detailed information about functional methods for processing real-time event (data) streams using high-order functional operators in .NET Reactive Extensions to form asynchronous event combinators.  The studied methods will then be used to implement a competitive publisher ‚Äì subscriber reactive pattern. </li><li>  Chapter 7 explains the task-based programming model as applied to functional programming to implement competitive operations using the Monadic template.  Then this method is used to build a competitive pipeline based on the functional programming paradigm. </li><li>  Chapter 8 is devoted to the implementation of unlimited parallel computing using the asynchronous programming model in C #.  This chapter also discusses error handling methods and methods for constructing asynchronous operations. </li><li>  Chapter 9 describes the asynchronous workflow on F #.  It shows how a delayed and explicit assessment in this model allows us to obtain a higher compositional semantics.  Then we will learn how to implement custom computational expressions to increase the level of abstraction to declarative programming. </li><li>  Chapter 10 shows how, based on the knowledge gained in previous chapters, you can implement combinators and patterns, such as Functor, Monad, and Applicative, to compose and run several asynchronous operations and error handling without side effects. </li><li>  Chapter 11 analyzes reactive programming using a program model of message passing.  It reveals the concept of natural isolation as a technology that complements immutability and allows you to create competitive programs.  This chapter focuses on the MailboxProcessor class used in F # to distribute parallel work using agent-based programming and a resource-free approach. </li><li>  Chapter 12 describes agent programming using the .NET TPL Dataflow library with examples in C #.  Here it is shown how to implement stateless and stateful agents on C #, as well as how to perform several calculations in parallel, which exchange data with each other, applying (transmitting) messages in a pipeline style. </li></ul><br>  Part III shows how to put into practice all the functional methods of competitive programming studied in previous chapters. <br><br><ul><li>  Chapter 13 presents a set of useful recipes for solving complex problems of competitiveness, taken from actual practice.  These recipes use all the functional patterns described in this book. </li><li>  Chapter 14 describes a complete application developed and implemented using functional competitive patterns and methods studied in this book.  You will create a highly scalable, responsive server application and a reactive client program.  The book presents two versions: one for iOS (iPad), created using Xamarin Visual Studio, and the second - created using Windows Presentation Foundation (WPF).  To ensure maximum scalability in the server application, a combination of various programming models, such as asynchronous, agent and reactive, is used. </li></ul><br>  The book also contains three applications. <br><br><ul><li>  Appendix A briefly describes the basic concepts of functional programming, and also presents the basic theory of functional methods used in this book. </li><li>  Appendix B covers the basic concepts of the F # language.  This is a basic F # review that will allow you to get a closer look at this language and feel comfortable while reading a book. </li><li>  Appendix B illustrates several methods that simplify the interaction between an asynchronous workflow in F # and a .NET task in C #. </li></ul><br><h3>  Excerpt  11.6.  F # MailboxProcessor: 10,000 Agents for Game of Life </h3><br>  Compared with the flows MailboxProcessor in combination with asynchronous workflows is a simple computing unit (primitive).  Agents can appear and be destroyed with minimal cost.  You can distribute the work among several MailboxProcessor objects in the same way that you can use threads without the additional overhead associated with creating a new thread.  Due to this, it is quite possible to create applications consisting of hundreds of thousands of agents working in parallel, with minimal load on computer resources. <br><br>  In this section, we will use multiple instances of MailboxProcessor to implement the Game of Life game (Life game) ( <a href="https://en.wikipedia.org/wiki/Game_of_Life">wiki-eng</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B3%25D1%2580%25D0%25B0_%25C2%25AB%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C">wiki-rus</a> ).  According to Wikipedia, Game of Life, in simple terms, is a cellular automaton.  It is a game without players ‚Äî in other words, when a game starts with a random initial configuration, it runs without any other input.  The game consists of a set of cells that form a grid;  in each cell several mathematical rules are fulfilled.  Cells can live, die and multiply.  Each cell interacts with eight neighbors (neighboring cells).  To move cells in accordance with these rules, it is necessary to constantly calculate the new state of the grid. <br><br>  Game of Life has the following rules: <br><br><ul><li>  if a cell has only one neighbor or no neighbors, then it dies ‚Äúfrom loneliness‚Äù; </li><li>  if four or more neighbors of the cell died, then it dies ‚Äúdue to overpopulation‚Äù; </li><li>  if a cell has two or three neighbors, then it remains to live; </li><li>  if a cell has three neighbors, then it multiplies. </li></ul><br>  Depending on the initial conditions, the cells form characteristic structures throughout the game.  Through repeated application of the rules, the next generations of cells are created until the cells reach a stable state (Fig. 11.12). <br><br>  Listing 11.9 shows the implementation of the Game of Life AgentCell cell, based on the MailboxProcessor F # -types based on MailboxProcessor.  Each cell-agent interacts with neighboring cells through asynchronous message passing, thus creating a fully parallelized Game of Life.  For brevity, I have omitted some parts of the code, since they are not related to the main topic of the example.  Full implementation you will find in the source code for this book, laid out on the publisher's website. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/qb/jp/siqbjpp_zc4oqi7dgpk032_8xe8.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/j9/u2/2dj9u2y7qplsftitwupamkmaji0.png" alt="image"></div><br>  AgentCell describes a cell in the Game of Life grid.  The basic concept is that each agent communicates with its neighboring cells about its current state through asynchronous message passing.  This template creates a chain of interconnected parallel communications that involves all cells that send their updated state to the MailboxProcessor updateAgent.  After receiving this data, updateAgent updates the graphics in the user interface (Listing 11.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/qy/j2/1aqyj2_ar1ua7a4mjylo8gxdqgg.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wr/jx/l4wrjxuth4-3quliytnseqegjw8.png" alt="image"></div><br>  updateAgent, as the name suggests, updates the state of each pixel according to the cell value received in the Update message.  The agent maintains the state of pixels and uses it to create a new image when all cells transfer their new state.  Then updateAgent updates the graphical WPF user interface using this new image that matches the current Game of Life grid: <br><br><pre><code class="plaintext hljs">do! Async.SwitchToContext ctx image.Source &lt;- createImage pixels do! Async.SwitchToThreadPool()</code> </pre> <br>  It is important to note that the updateAgent agent uses the current synchronization context to correctly update the WPF controller.  The current thread is switched to the user interface stream using the Async.SwitchToContext function (described in chapter 9). <br><br>  The final code snippet for executing Game of Life generates a grid that serves as a playing field for the cells, and then the timer notifies the cells to perform the update (Listing 11.11).  In this example, the grid is a square of 100 √ó 100 cells, a total of 10,000 cells (MailboxProcessor objects), which are calculated in parallel by a timer every 50 ms, as shown in Fig.  11.13.  Ten thousand MailboxProcessor objects interact and update the user interface 20 times per second (the code to which you should pay attention is in bold). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/px/jw/uepxjwb4re6grfx1wqbmp4rx6pq.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/cg/tx/eqcgtxipd3wr4kipmnbpqj0-rjm.png" alt="image"></div><br>  Notifications to all cells (agents) are sent in parallel, using PLINQ.  Cells are F # -sequences that are considered .NET IEnumerable, which makes LINQ / PLINQ easy to integrate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/9u/wl/rc9uwlhsymr64zmqrffpte7gqcc.png" alt="image"></div><br>  When executing the code, the program generates 10,000 F # objects of the type MailboxProcessor in less than 1 ms, while the agents occupy less than 25 MB in memory.  Impressive! <br><br><h3>  Summary </h3><br><ul><li>  The agent-based programming model naturally provides immutability and isolation when writing competitive systems, making it even easier to discuss complex systems, since agents are encapsulated inside active objects. </li><li>  A reactive manifest defines properties for implementing a reactive system that is flexible, loosely coupled, and scalable. </li><li>  Natural isolation is important for writing contention-free code.  In a multi-threaded program, isolation solves the problem of shared states by providing each stream with a copied portion of data to perform local calculations.  When using isolation, there is no race condition. </li><li>  Asynchronous, agents are simple because they do not block threads, waiting for messages.  As a result, you can use hundreds of thousands of agents in one application without much impact on the amount of memory. </li><li>  The MailboxProcessor F # object provides for two-way communication: the agent can use an asynchronous channel to return (respond) to the caller the result of the calculation. </li><li>  The agent-based programming model in F # through MailboxProcessor is an excellent tool for solving bottlenecks in applications such as multi-competitive access to a database.  In fact, with the help of agents, applications can be significantly accelerated while maintaining server responsiveness. </li><li>  Other .NET programming languages ‚Äã‚Äãallow you to use the MailboxProcessor F # -type by providing methods using a convenient TPL-based task-based programming model. </li></ul><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/new/product/konkurentnost-i-parallelizm-na-platforme-net-patterny-effektivnogo-proektirovaniya">the publisher's website.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544611072/978544611072_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544611072/978544611072_p.pdf">Excerpt</a> <br><br>  Hubrozhiteley 20% discount coupon - <b>Concurrency in .NET</b> <br><br>  Upon payment of the paper version of the book, an electronic version of the book is sent to the e-mail. </div><p>Source: <a href="https://habr.com/ru/post/453804/">https://habr.com/ru/post/453804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453794/index.html">10 useful tips on the implementation of Pixel Perfect design in Front-end development (for example, working with the Sketch editor)</a></li>
<li><a href="../453796/index.html">Do people need mathematics?</a></li>
<li><a href="../4538/index.html">Virtual worlds attract the attention of the tax inspectorate</a></li>
<li><a href="../45380/index.html">Bypassing J2EE or a review of Tapestry 5 framework for example blog</a></li>
<li><a href="../453800/index.html">How to solve ‚ÄúMinesweeper‚Äù (and make it better)</a></li>
<li><a href="../453806/index.html">Error Handling in Go</a></li>
<li><a href="../453808/index.html">We understand the business model of the Vikings</a></li>
<li><a href="../453810/index.html">Biometric feedback</a></li>
<li><a href="../453812/index.html">Themes, styles and other</a></li>
<li><a href="../453818/index.html">GitLab 11.11: Several Responsible for Merge Requests and Improvements for Containers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>