<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A story about how to create a repository and understand Redux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redux is an interesting template, and, at its core, it is very simple. But why is it hard to understand? In this article we will look at the basic con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A story about how to create a repository and understand Redux</h1><div class="post__text post__text-html js-mediator-article">  Redux is an interesting template, and, at its core, it is very simple.  But why is it hard to understand?  In this article we will look at the basic concepts of Redux and deal with the internal mechanisms of storage.  Having understood these mechanisms, you will be able to familiarize yourself with everything that happens, as they say, ‚Äúunder the hood‚Äù of Redux, namely, with how the storages, reducers and actions work.  This will help you to bring application debugging to a new level, will help to write better code.  You will know exactly what functions this or that line of your program performs.  We will go to the understanding of Redux through a practical example, which is to create your own repository using TypeScript. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/345340/"><img src="https://habrastorage.org/getpro/habr/post_images/832/6e0/9c0/8326e09c05d3ad61d45e57578536a06d.jpg" alt="image"></a> <br><br>  This material is based on the Redux <a href="https://github.com/UltimateAngular/redux-store">source code</a> , written in pure TypeScript.  The author offers everyone to look at this code and deal with it.  However, he points out that this project is intended for educational purposes. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Terminology</font> </h2><br>  If you only recently started learning Redux, or just flipped through the <a href="https://redux.js.org/">documentation</a> , you must have come across some terms that I think should be considered before we get to the point. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  <font color="#3AC1EF">‚ñç Actions</font> </h3><br>  Do not attempt to perceive actions as a JavaScript API.  Action has a definite goal - and this needs to be understood first.  Actions inform the repository of intent. <br><br>  Working with the repository, he is given instructions, for example, something like this: ‚ÄúHey, repository!  I have a request for you.  Please update the status tree by adding this data to it. ‚Äù <br><br>  The action signature, when using TypeScript to show it, looks like this: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Action</span></span> {  type: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  payload?: any; }</code> </pre> <br>  <code>Payload</code> (payload) - this is an optional property, because sometimes we can send to the store actions that do not take the payload, although in most cases this property is involved.  Here we have in mind that when creating an action, we describe it, for example, as follows: <br><br><pre> <code class="hljs scala">const action: <span class="hljs-type"><span class="hljs-type">Action</span></span> = { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'ADD_TOD</span></span>O', payload: { label: <span class="hljs-symbol"><span class="hljs-symbol">'Eat</span></span> pizza,', complete: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, };</code> </pre> <br>  This is essentially an action template.  But more about that after, but for now - continue familiarity with the terminology. <br><br><h3>  <font color="#3AC1EF">‚ñç Reducers</font> </h3><br>  A reducer (reducer) is just a <a href="https://toddmotto.com/pure-versus-impure-functions">pure function</a> that accepts the state of the application (the internal state tree that the repository transfers to the reducer), and, as a second argument, the action sent to the repository.  That is, it looks like this: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//...    }</span></span></code> </pre> <br>  So, what else do you need to know about the reducer?  The reduer, as we know, takes a state, and in order to do something useful (like updating the state tree), we need to respond to the <code>type</code> property of the action (we just saw this property).  This is usually done using the <code>switch</code> construction: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) {   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ADD_TODO'</span></span>: {     <span class="hljs-comment"><span class="hljs-comment">// ,   - ...   } } }</span></span></code> </pre> <br>  Each <code>case</code> branch inside the <code>switch</code> allows you to respond to different types of actions that are involved in shaping the state of the application.  For example, suppose we need to add a property with some value to the state tree.  To do this, we perform some actions and return the changed state: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = {}, action)</span></span></span></span> { switch (action.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) {   case <span class="hljs-string"><span class="hljs-string">'ADD_TODO'</span></span>: {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       ...state,       //  ,    ,   todos         //                todos: [...state.todos, { label: <span class="hljs-string"><span class="hljs-string">'Eat pizza,'</span></span>, complete: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }],     };   } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; }</code> </pre> <br>  Notice that there is a <code>state</code> return command at the bottom of the code.  This is done in order to return the initial state if there is no <code>case</code> branch in the reducer corresponding to some action.  Here you can add that the construction <code>state = {}</code> is added as the first argument.  This is the default value of the parameter.  The original state objects are usually formed outside the limits of the reducer, we will talk about this later. <br><br>  The last thing you need to pay attention to is the desire for immunity.  We return a completely new object in each branch of the <code>case</code> . It is a combination of the previous state and the changes made to it.  As a result, the output is a slightly modified version of the original state tree.  Here, first, apply the command <code>‚Ä¶state</code> , the extension operator, after which new properties are added to the current state. <br><br>  By following the concept of pure functions, we ensure that the same input data always leads to the same output data.  Reducers are pure functions that handle a dynamic state based on actions.  Simply put, we customize them, and everything else is done in the process.  They encapsulate functions that contain the logic necessary to update the state tree based on the instructions (actions) that we pass to them. <br><br>  Reducers are synchronous functions, asynchronous behavior should be avoided inside them. <br>  So, when does <code>action.payload</code> come into <code>action.payload</code> ?  Ideally, you should not rigidly set certain values ‚Äã‚Äãin the reducer, unless these are some simple things like transferring a logical value from <code>false</code> to <code>true</code> .  Now, in order to complete the theme of handling actions, we use the <code>action.payload</code> property, accessible due to the action passed to the editor when it is called, and we get the necessary data: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = {}, action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) {   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ADD_TODO'</span></span>: {     <span class="hljs-comment"><span class="hljs-comment">//        const todo = action.payload;     //         const todos = [...state.todos, todo];     //         return {       ...state,       todos,     };   } } return state; }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçStorage</font> </h3><br>  I constantly have to see how the state is confused with the store.  The storage is a container, and the state is simply placed in this container. <br><br>  The storage is an object with an API that allows you to interact with the state, modify it, read its values, and so on. <br><br>  I think we are almost ready to start creating our own repository, and everything that we have just talked about, while looking fragmented, will fall into place. <br><br>  I would like to note that, in essence, the functions of the repository consist in the implementation of a structured process of updating properties in an object.  In fact, this is Redux. <br><br><h2>  <font color="#3AC1EF">Storage API</font> </h2><br>  Our Redux learning repository will have just a few publicly available properties and methods.  Then we will use the storage as shown below, passing it the reduction gears and the initial state for the application: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store(reducers, initialState);</code> </pre> <br><h3>  <font color="#3AC1EF">Store Store.dispatch () method</font> </h3><br>  Method <pre> <code class="hljs">dispatch</code> </pre>  allow us to give instructions to the repository, informing it that we intend to change the state tree.  This operation is performed by means of a reducer, as we have already discussed above. <br><br><h3>  <font color="#3AC1EF">Store Store.subscribe () method</font> </h3><br>  The <code>subscribe</code> method allows organizing the transfer to the repository of subscriber functions interested in changing the state tree.  The corresponding information is transferred to these functions when the state tree changes. <br><br><h3>  <font color="#3AC1EF">Store Store.value property</font> </h3><br>  The <code>value</code> property will be configured as a <a href="https://toddmotto.com/typescript-setters-getter">getter</a> , it returns the internal state tree (as a result, we will be able to access the properties). <br><br><h2>  <font color="#3AC1EF">Storage container</font> </h2><br>  As we already know, the repository contains a state, and also allows us to send it actions that need to be performed on the state tree.  It allows you to subscribe to updates.  Let's start working on the <code>Store</code> class: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {} dispatch() {} subscribe() {} }</code> </pre> <br>  So far, everything looks quite normal, but we have forgotten about the object for the state, <code>state</code> .  Add it: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Store <span class="hljs-comment"><span class="hljs-comment">{ private state: { [key: string]: any }</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.state = {}</span></span></span><span class="hljs-function">;</span></span> } get value() <span class="hljs-comment"><span class="hljs-comment">{   return this.state; }</span></span> dispatch() <span class="hljs-comment"><span class="hljs-comment">{}</span></span> subscribe() <span class="hljs-comment"><span class="hljs-comment">{}</span></span> }</code> </pre> <br>  I like to write in TypeScript, here I also use its mechanisms to indicate that the <code>state</code> object will consist of string keys, which can correspond to values ‚Äã‚Äãof any type.  This is exactly what you need to work with our data structures. <br><br>  In addition, the method <code>get value() {}</code> added here, which returns a <code>state</code> object when it is accessed as a property: <br><br><pre> <code class="hljs pgsql">console.log(store.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>);</code> </pre> <br>  So now create an instance of the repository: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store();</code> </pre> <br>  At the moment, it is quite possible to call the <code>dispatch</code> method: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">store</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dispatch</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ADD_TODO'</span></span>, payload: { label: <span class="hljs-string"><span class="hljs-string">'Eat pizza'</span></span>, complete: false }, });</code> </pre> <br>  However, such a call still does not lead to anything, so let's do the work on the <code>dispatch</code> method, we will bring it to this form so that it can transfer the action to it: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... dispatch(action) {   //     ! } // ... }</span></span></code> </pre> <br>  So, in the <code>dispatch</code> method, you need to update the state tree.  But first, let us ask ourselves - what does it look like - is this a state tree? <br><br><h3>  <font color="#3AC1EF">‚ñçData structure for storing state</font> </h3><br>  For the purposes of this material, the state data structure will look like this: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">todos</span></span>: {   data: [],   loaded: false,   loading: false, } }</code> </pre> <br>  Why?  We already know that reducers update the state tree.  In a real application, we would have many reducers that are responsible for updating some of the state tree.  These parts are often called "layers" of the state.  Each such layer is controlled by a certain reducer. <br><br>  In this case, the <code>todo</code> property in the state tree, or the <code>todo</code> property layer, will be controlled by the reducer.  At the moment, our reducer will work with the <code>data</code> , <code>loaded</code> , and <code>loading</code> properties.  Here, the <code>loaded</code> (loaded) and <code>loading</code> (loaded) properties are used, because when an asynchronous operation is performed, like loading JSON over HTTP, we would like to control various steps that are performed as part of this operation - from initiating a request to its successful completion. <br><br>  We continue work on the <code>dispatch</code> method. <br><br><h3>  <font color="#3AC1EF">‚ñçUpdate the state tree</font> </h3><br>  In order to follow the immutable update pattern, we need to assign a new state representation to the state property in the form of a completely new object.  This new object includes the changes we wanted to make in the state tree using an action. <br><br>  In this example, for the time being we will forget about the existence of reducer and simply update the state manually: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... dispatch(action) {   this.state = {     todos: {       data: [...this.state.todos.data, action.payload],       loaded: true,       loading: false,     },   }; } // ... }</span></span></code> </pre> <br>  After we send the action <code>'ADD_TODO'</code> to the <code>dispatch</code> method, the status will look like this: <br><br><pre> <code class="hljs lua">{ todos: {   data: [{ label: <span class="hljs-string"><span class="hljs-string">'Eat pizza'</span></span>, complete: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }],   <span class="hljs-built_in"><span class="hljs-built_in">loaded</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,   loading: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, } }</code> </pre> <br><h2>  <font color="#3AC1EF">Development of reyuser</font> </h2><br>  Now that we know that the reducer updates a layer of state, we will describe this layer: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { data: [], loaded: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, loading: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçCreation of a reducer</font> </h3><br>  Now you need to pass to the function of the reducer the <code>state</code> argument, the default value of which is the above-described <code>initialState</code> object.  This allows preparing the reducer for the first boot when we call the reducer in the storage in order to connect all the reducers with the initial state: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">todosReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> state = initialState, action: { type: string, payload: any } </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     return state; }</span></span></code> </pre> <br>  At the moment, given what we already know about reducer, you can understand how to extend the code further: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">todosReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> state = initialState, action: { type: string, payload: any } </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) {   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ADD_TODO'</span></span>: {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todo = action.payload;     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = [...state.data, todo];     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       ...state,       data,     };   } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; }</code> </pre> <br>  Well, as long as everything goes fine, but the reducer needs to connect to the repository in order to be able to call it, passing it the state and the action to be performed on it. <br><br>  Let's go back to the <code>Store</code> object: <br><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> state: { [key: string]: any }; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> value() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state; } dispatch(action) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {     todos: {       <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: [...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.todos.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, action.payload],       loaded: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,       loading: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,     },   }; } }</code> </pre> <br>  We need to make it possible to add reducer to the storage: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Store <span class="hljs-comment"><span class="hljs-comment">{ private state: { [key: string]: any }</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> reducers: <span class="hljs-comment"><span class="hljs-comment">{ [key: string]: Function }</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reducers = </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">, initialState = </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.reducers = reducers;   this.state = {}</span></span></span><span class="hljs-function">;</span></span> } }</code> </pre> <br>  In addition, we provide the initial state to the repository, the <code>initialState</code> , so we can, if desired, transfer it when we create the repository. <br><br><h3>  <font color="#3AC1EF">Registration Reducer</font> </h3><br>  In order to register a reducer, we must remember that the <code>todos</code> property is in the state tree, and we must attach a reducer function to it.  Let me remind you, we are going to work with the state layer called <code>todos</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = { todos: todosReducer, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store(reducers);</code> </pre> <br>  Here is the most interesting, and usually incomprehensible.  Namely, here the <code>todos</code> property becomes the result of a call to the todosReducer reducer <code>todosReducer</code> , which, as we know, returns a new state based on some action. <br><br><h3>  <font color="#3AC1EF">‚ñçCalling Reducers in Storage</font> </h3><br>  The principle of operation of reduser, in its essence, resembles the work of the function <code>Array.prototype.reduce</code> , which leads the array processed to it to a certain single value.  Reducers work in a similar way, taking the old state, performing some actions on it, and returning a new state. <br><br>  Now we are going to wrap the logic of the reducer in a function called <code>reduce</code> here: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... dispatch(action) {   this.state = this.reduce(this.state, action); } private reduce(state, action) { //        return {}; } }</span></span></code> </pre> <br>  When we pass an action to the repository, we actually call the <code>reduce</code> method of the <code>Store</code> class that we just created, and pass it the state and the action.  This design is called the root reduction gear.  You can see that it takes <code>state</code> and <code>action</code> - just as it does <code>todosReducer</code> . <br><br>  Now let's talk about the private <code>reduce</code> method, since this is the most important step in building a state tree and bringing together everything we are talking about here. <br><br><pre> <code class="hljs markdown">export class Store { private state: { [<span class="hljs-string"><span class="hljs-string">key: string</span></span>]: any }; private reducers: { [<span class="hljs-string"><span class="hljs-string">key: string</span></span>]: Function }; constructor(reducers = {}, initialState = {}) {   this.reducers = reducers;   this.state = {}; } dispatch(action) {   this.state = this.reduce(this.state, action); } private reduce(state, action) {   const newState = {};   for (const prop in this.reducers) {     newState[<span class="hljs-string"><span class="hljs-string">prop</span></span>] = this.reducers[<span class="hljs-string"><span class="hljs-string">prop</span></span>](<span class="hljs-link"><span class="hljs-link">state[prop], action</span></span>);   }   return newState; } }</code> </pre> <br>  This is what happens here: <br><br><ul><li>  We create a <code>newState</code> object that will contain the new state tree. <br></li><li>  We <code>this.reducers</code> through <code>this.reducers</code> object registered in the repository. <br></li><li>  We, in a reducer, transfer properties from <code>todos</code> , to <code>newState</code> . <br></li><li>  We address each of the reducer one at a time and call it, passing the state layer (via <code>state[prop]</code> ) and the action <br></li></ul><br>  The value of <code>prop</code> in this case is just <code>todos</code> , so all this can be viewed as: <br><br><pre> <code class="hljs kotlin">newState.todos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reducers.todos(state.todos, action);</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçProcessing initialState with a reducer</font> </h3><br>  Now we just have to talk about the <code>initialState</code> object.  If we are going to use a record of the type <code>Store(reducers, initialState)</code> to prepare the initial state of the entire storage, we need to process it with the reducer during the creation of the storage: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Store <span class="hljs-comment"><span class="hljs-comment">{ private state: { [key: string]: any }</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> reducers: <span class="hljs-comment"><span class="hljs-comment">{ [key: string]: Function }</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reducers = </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">, initialState = </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.reducers = reducers;   this.state = this.reduce(initialState, {}</span></span></span><span class="hljs-function">);</span></span> } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Remember how we told that at the end of the code of each reducer there should be a command like <code>return state</code> ?  Now you know why.  We have this so that we can pass an empty object as an action, <code>{}</code> , meaning that the branches of the <code>switch</code> will be skipped, and as a result we will have a state tree obtained through the <code>constructor</code> . <br><br><h2>  <font color="#3AC1EF">Subscriber Tools</font> </h2><br>  You will often come across the term ‚Äúsubscriber‚Äù in the world of surveyed objects, where every time the surveyed object generates a new value, we are notified of this through a subscription.  A subscription is a kind of request: ‚Äúgive me the data when it is available or change.‚Äù <br><br>  In our case, working with subscription mechanisms will look like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store(reducers); store.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  - `state` });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Store followers</font> </h3><br>  Add a few more properties to the repository that allow you to customize the subscription mechanism: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ private subscribers: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(reducers = {}, initialState = {}) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscribers = [];   <span class="hljs-comment"><span class="hljs-comment">// ... } subscribe(fn) {} // ... }</span></span></code> </pre> <br>  Here is the <code>subscribe</code> method, which now takes the function ( <code>fn</code> ) as an argument.  Now we need to pass each such function to the <code>subscribers</code> array: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... subscribe(fn) {   this.subscribers = [...this.subscribers, fn]; } // ... }</span></span></code> </pre> <br>  This, as you can see, was simple.  And where can we tell our subscribers that something has changed?  Of course, in the <code>dispatch</code> method! <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get value() {   return this.state; } dispatch(action) {   this.state = this.reduce(this.state, action);   this.subscribers.forEach(fn =&gt; fn(this.value)); } // ... }</span></span></code> </pre> <br>  And this, again, is simple.  Every time we call <code>dispatch</code> , we pass a state to the <code>reduce</code> method and bypass the subscribers, passing it <code>this.value</code> (remember that the getter <code>value</code> triggered here). <br><br>  Now we need to solve only one problem.  When we call <code>.subscribe()</code> , we do not want (at this particular moment) to get the value of <code>state</code> .  We want to get it after executing the <code>dispatch</code> method.  Therefore, we will decide to inform new subscribers about the current status as soon as they subscribe: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Store</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... subscribe(fn) {   this.subscribers = [...this.subscribers, fn];   fn(this.value); } // ... }</span></span></code> </pre> <br>  Here we take the function passed through the <code>subscribe</code> method and, after making the subscription, we call it with the transfer of the state tree to it. <br><br><h3>  <font color="#3AC1EF">Review of the repository</font> </h3><br>  We can subscribe to changes in the repository, but it would be nice to implement the reverse mechanism.  Cancellation may be necessary, for example, in order to avoid excessive memory use, or due to the fact that certain changes in the storage do not interest us anymore. <br><br>  All you need to do here is return the closure, which, when called, will remove the function from the list of subscribers: <br><br><pre> <code class="hljs perl">export class Store { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... subscribe(fn) {   this.subscribers = [...this.subscribers, fn];   fn(this.value);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; {     this.subscribers = this.subscribers.filter(<span class="hljs-string"><span class="hljs-string">sub =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> !== </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">)</span></span>;   }; } // ... }</code> </pre> <br>  Here we use the function reference, iterate through the subscribers, check if the current subscriber is equal to our <code>fn</code> .  Next, using <code>Array.prototype.filter</code> , what is no longer needed is removed from the subscriber array.  You can use it like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store(reducers); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsubscribe = store.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> {}); destroyButton.on(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, unsubscribe, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  And that's all we need. <br><br>  The beauty of the subscription mechanism is that we can have many subscribers, which means that different parts of our application may be interested in different layers of the state. <br><br><h2>  <font color="#3AC1EF">Full repository code</font> </h2><br>  Here is the complete code of what we did: <br><br><pre> <code class="hljs markdown">export class Store { private subscribers: Function[<span class="hljs-string"></span><span class="hljs-string"></span>]; private reducers: { [<span class="hljs-string"><span class="hljs-string">key: string</span></span>]: Function }; private state: { [<span class="hljs-string"><span class="hljs-string">key: string</span></span>]: any }; constructor(reducers = {}, initialState = {}) {   this.subscribers = [<span class="hljs-string"></span><span class="hljs-string"></span>];   this.reducers = reducers;   this.state = this.reduce(initialState, {}); } get value() {   return this.state; } subscribe(fn) {   this.subscribers = [<span class="hljs-string"><span class="hljs-string">...this.subscribers, fn</span></span>];   fn(this.value);   return () =&gt; {     this.subscribers = this.subscribers.filter(sub =&gt; sub !== fn);   }; } dispatch(action) {   this.state = this.reduce(this.state, action);   this.subscribers.forEach(fn =&gt; fn(this.value)); } private reduce(state, action) {   const newState = {};   for (const prop in this.reducers) {     newState[<span class="hljs-string"><span class="hljs-string">prop</span></span>] = this.reducers[<span class="hljs-string"><span class="hljs-string">prop</span></span>](<span class="hljs-link"><span class="hljs-link">state[prop], action</span></span>);   }   return newState; } }</code> </pre> <br>  As you can see, everything is not so difficult. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  It is possible that you heard about all the mechanisms that we talked about today, or even used them, but were not interested in how they work.  I hope, creating your own repository, you understand how everything that it consists of works.  There is nothing mysterious in the work of actions and reducers.  The <code>dispatch</code> method informs the repository about the need to perform the process of defining a new state by calling each reducer and attempting to match <code>action.typ</code> e with one of the branches of the <code>switch</code> .  And the state tree is the final view of what comes after calling all the reducers. <br><br>  Thanks to the example I shared with you, I finally understood Redux.  I hope he will help you with this. <br><br>  <b>Dear readers!</b>  How do you master new technologies? </div><p>Source: <a href="https://habr.com/ru/post/345340/">https://habr.com/ru/post/345340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345326/index.html">Is there life without standards in javascript?</a></li>
<li><a href="../345328/index.html">Simulation of the simplest statements</a></li>
<li><a href="../345330/index.html">Using Roslyn to edit game content</a></li>
<li><a href="../345332/index.html">Kubernetes Service Writing Guide</a></li>
<li><a href="../345336/index.html">We spread the application in the App Store. Even if you are not a developer</a></li>
<li><a href="../345342/index.html">What are dangerous social networks on your PC?</a></li>
<li><a href="../345344/index.html">Sending a request to the specified MS SQL Server databases of all the specified servers using available tools</a></li>
<li><a href="../345346/index.html">Nebraska problem</a></li>
<li><a href="../345348/index.html">Adapting RoboVM for compiling for iOS from Windows / Linux</a></li>
<li><a href="../345350/index.html">Adding 3D objects to video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>