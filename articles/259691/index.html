<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Battle "Listener vs Visitor" at the stadium antlr4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Attend or listen? A matter of taste - no more. Or not? 
 Prehistory 

 Having examined the source code, a tree was formed at the output: 



 In itsel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Battle "Listener vs Visitor" at the stadium antlr4</h1><div class="post__text post__text-html js-mediator-article">  Attend or listen?  A matter of taste - no more.  Or not? <br>  <a href="http://habrahabr.ru/post/259475/">Prehistory</a> <br><br>  Having examined the source code, a tree was formed at the output: <br><br><img src="https://habrastorage.org/files/330/19a/102/33019a102c144652a211692f590eb98b.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In itself, the tree does not have any meaning, it is ‚ÄúWooden‚Äù, the result of the analysis (bypass) of this tree has meaning and value.  For those who are not ready to strain and write samopisnye sleigh on descent from the tree (for example, me) in antlr4 added the ability to get the analyzer almost for free. <br><br><h4>  1. Visitor </h4><br>  Classic is a behavioral design pattern.  When traversing nodes, the method that processes the current node type is determined, after which the method is called and this is where the development begins, namely the analysis of the incoming subtree. <br><br><h4>  2. Listener </h4><br>  Innovation, which appeared in the fourth version.  The behavior of this class is already far from classical (Observer or Publish / Subscribe).  In the classic version there is a manager who notifies subscribers about the occurrence of events.  The behavior of the listener in question is more like an inspector‚Äôs job.  The inspector makes a note ‚ÄúI check the X node‚Äù before checking the node, then follows the descendants of the node, after the traversal, which can be done ‚ÄúConclusion on the results of the X traversal‚Äù. <br><a name="habracut"></a><br><h4>  Practice </h4><br>  For a better understanding of what is happening, let's turn to the author of the recognizer <a href="https://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference">pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference</a> .  In the book <b>‚ÄúThe Definitive ANTLR 4 Reference‚Äù</b> In section <b>8.2 Translating JSON to XML, the</b> author translates using the Listener. <br><br>  The examples in the book are based on JAVA, I am not familiar with JAVA, but they are translated to C # without pain (that's what best practice means cloning). <br><br>  To prepare the listener, we need <b>VS, C # proj and JASON.g4 with something like this</b> <br><br><pre><code class="cs hljs">grammar JASON; json: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | array ; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : <span class="hljs-string"><span class="hljs-string">'{'</span></span> pair ( <span class="hljs-string"><span class="hljs-string">','</span></span> pair )* <span class="hljs-string"><span class="hljs-string">'}'</span></span> <span class="hljs-meta"><span class="hljs-meta"># AnObject | '{' '}' # EmptyObject ; pair: STRING':'value; array : '['value(','value)*']' # ArrayOfValues | '['']' # EmptyArray ; value : STRING # String | NUMBER # Atom | object # ObjectValue | array # ArrayValue | 'true' # Atom | 'false' # Atom | 'null' # Atom ; STRING : '"' ( ESC | ~["\\] )* '"'; fragment ESC: '\\'(["\\/bfnrt]|UNICODE); fragment UNICODE:'u'HEX HEX HEX HEX; fragment HEX:[0-9a-fA-F]; NUMBER : '-'? INT'.'INT EXP? //1.35,1.35E-9,0.3,-4.5 | '-'? INT EXP //1e10-3e4 | '-'? INT //-3,45 ; fragment INT: '0'|[1-9][0-9]*;//noleadingzeros fragment EXP: [Ee][+\-]? INT;//\-since-means"range"inside[...] WS : [\t\n\r]+-&gt;skip;</span></span></code> </pre> <br>  This is a grammar allowing to recognize JASON.  In the properties of the file, you must set Generate Listener and Generate Visitor (this is still useful).  The result of the Listener‚Äôs work in the original example from the book is the xml text, I‚Äôm not satisfied with it, I‚Äôll get the XElement (anyway, the xml text will need to be translated into something, although the plus text is that it doesn‚Äôt pinch into the framework of using specific classes). <br><br>  The algorithm is simple: if antlr4 uses descending parsing (in our case from the root to the nodes), then xml will be formed in the same way, creating an ancestor element to which descendants will be added. <br><br>  Example Listener: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XmlListener</span></span> : <span class="hljs-title"><span class="hljs-title">JASONBaseListener</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> fields ParseTreeProperty&lt;XElement&gt; xml = new ParseTreeProperty&lt;XElement&gt;(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> result public XElement Root { get; private set; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> xml api XElement GetXml( IParseTree ctx ) { return xml.Get( ctx ); } /// &lt;summary&gt; ///   xml  /// &lt;/summary&gt; XElement GetParentXml( IParseTree ctx ) { var parent = ctx.Parent; XElement result = GetXml( parent ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( result == null ) result = GetParentXml( parent ); return result; } void SetXml( IParseTree ctx, XElement e ) { xml.Put( ctx, e ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> listener public override void ExitString( JASONParser.StringContext context ) { var value = GetStringValue( context.STRING() ); AddValue( context, value ); } public override void ExitAtom( JASONParser.AtomContext context ) { var value = context.GetText(); AddValue( context, value ); } public override void EnterPair( JASONParser.PairContext context ) { var name = GetStringValue( context.STRING() ); XElement element = new XElement( name ); XElement ParentElement = GetParentXml( context ); ParentElement.Add( element ); SetXml( context, element ); } public override void EnterJson( JASONParser.JsonContext context ) { Root = new XElement( "JSON" ); SetXml( context, Root); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> private private string GetStringValue( ITerminalNode terminal ) { return terminal.GetText().Trim( '"' ); } private void AddValue( ANTLR_CSV.JASONParser.ValueContext context, string value ) { var parent = GetParentXml( context ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( context.Parent.RuleIndex == JASONParser.RULE_array ) { XElement element = new XElement( "elemnt" ); element.Value = value; parent.Add( element ); SetXml( context, element ); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> parent.Value = value; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  EnterJson corresponds to the entry to the node described in the grammar as follows: <br><br><pre> <code class="cs hljs">json: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | array ;</code> </pre><br>  ExitString corresponds to the output from the node described in the grammar as follows: <br><br><pre> <code class="cs hljs">STRING <span class="hljs-meta"><span class="hljs-meta"># String</span></span></code> </pre><br>  In contrast to the original example, I do not use all the charms of Enter and Exit.  For that is, ParseTreeProperty is recognized to store pairs [subtree, value], it is probably better to replace it with a regular dictionary (it definitely won't be worse). <br><br>  Visitor Sample: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XmlVisitor</span></span> : <span class="hljs-title"><span class="hljs-title">JASONBaseVisitor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">XElement</span></span>&gt; { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> fields private XElement _result; ParseTreeProperty&lt;XElement&gt; xml = new ParseTreeProperty&lt;XElement&gt;(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> xml api XElement GetXml( IParseTree ctx ) { return xml.Get( ctx ); } XElement GetParentXml( IParseTree ctx ) { var parent = ctx.Parent; XElement result = GetXml( parent ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( result == null ) result = GetParentXml( parent ); return result; } void SetXml( IParseTree ctx, XElement e ) { xml.Put( ctx, e ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> visitor /// &lt;summary&gt; ///    -   xml /// &lt;/summary&gt; protected override XElement DefaultResult { get { return _result; } } public override XElement VisitJson( JASONParser.JsonContext context ) { _result = new XElement( "JSON" ); SetXml( context, _result ); return VisitChildren( context ); } public override XElement VisitString( JASONParser.StringContext context ) { var value = GetStringValue( context.STRING() ); AddValue( context, value ); return DefaultResult; } public override XElement VisitAtom( JASONParser.AtomContext context ) { var value = context.GetText(); AddValue( context, value ); return DefaultResult; } public override XElement VisitPair( JASONParser.PairContext context ) { var name = GetStringValue( context.STRING() ); XElement element = new XElement( name ); XElement ParentElement = GetParentXml( context ); ParentElement.Add( element ); SetXml( context, element ); return VisitChildren( context ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> private private string GetStringValue( ITerminalNode terminal ) { return terminal.GetText().Trim( '"' ); } private void AddValue( ANTLR_CSV.JASONParser.ValueContext context, string value ) { var parent = GetParentXml( context ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( context.Parent.RuleIndex == JASONParser.RULE_array ) { XElement element = new XElement( "elemnt" ); element.Value = value; parent.Add( element ); SetXml( context, element ); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> parent.Value = value; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  As the saying goes, ‚ÄúFind the 10 differences‚Äù, the first difference of VisitJson, managing the visit without calling VisitChildren (context), the descendants' visit stops, and hence the detour.  Each of the visiting methods should return a value, that is, there is always a result of the visit, and this is convenient: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = visitor.Visit( tree );</code> </pre><br>  When working with a listener: <br><br><pre> <code class="cs hljs">walker.Walk( listener, tree ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = listener.Root;</code> </pre><br>  In the original example, without the Listener, it would be rather tight, for this solution there is not much difference, but I vote for the decision on the Visitor. <br><br>  Well, so that you can try it yourself: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IParseTree </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"{"</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"description\":\"Animaginary server config file\","</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"count\":500,"</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"logs\":{\"level\":\"verbose\",\"dir\":\"/var/log\"},"</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"host\":\"antlr.org\","</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"admin\":[\"parrt\",\"tombu\"],"</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"\"aliases\":[]"</span></span> ); sb.AppendLine( <span class="hljs-string"><span class="hljs-string">"}"</span></span> ); AntlrInputStream input = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AntlrInputStream( sb.ToString() ); JASONLexer lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JASONLexer( input ); CommonTokenStream tokens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommonTokenStream( lexer ); JASONParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JASONParser( tokens ); IParseTree tree = parser.json(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tree; }</code> </pre><br>  The sample JSON text is taken almost unchanged from the original example: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenerXml</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { IParseTree tree = CreateTree(); ParseTreeWalker walker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParseTreeWalker(); XmlListener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlListener(); walker.Walk( listener, tree ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = listener.Root; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitorXml</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { IParseTree tree = CreateTree(); XmlVisitor visitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlVisitor(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = visitor.Visit( tree ); }</code> </pre><br>  Well, the result of the implementation: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">JSON</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>Animaginary server config file<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">count</span></span></span><span class="hljs-tag">&gt;</span></span>500<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">count</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">logs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">level</span></span></span><span class="hljs-tag">&gt;</span></span>verbose<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">level</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dir</span></span></span><span class="hljs-tag">&gt;</span></span>/var/log<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dir</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">logs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">host</span></span></span><span class="hljs-tag">&gt;</span></span>antlr.org<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">host</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">admin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">elemnt</span></span></span><span class="hljs-tag">&gt;</span></span>parrt<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">elemnt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">elemnt</span></span></span><span class="hljs-tag">&gt;</span></span>tombu<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">elemnt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">admin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">aliases</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">JSON</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Oddly enough, but both methods gave the same thing. <br><br>  <a href="http://habrahabr.ru/post/260271/">Further</a> <br><br>  PS Listener vs Visitor - 0: 1 </div><p>Source: <a href="https://habr.com/ru/post/259691/">https://habr.com/ru/post/259691/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259671/index.html">Fast security-oriented fuzzing with AFL</a></li>
<li><a href="../259675/index.html">Ruby and C. Part 4. We are on friendly terms with the accelerometer, gyroscope and range finder with Raphael.js</a></li>
<li><a href="../259677/index.html">Autopilot system for radio-controlled helicopter. Part 1: The Idea</a></li>
<li><a href="../259679/index.html">Native OmniDirectional shadows implementation in DirectX11</a></li>
<li><a href="../259683/index.html">Autopilot system for radio-controlled helicopter. Part 2: Takeover</a></li>
<li><a href="../259701/index.html">Vim in full: Introduction</a></li>
<li><a href="../259709/index.html">Port i2cdevlib on STM32 HAL</a></li>
<li><a href="../259717/index.html">Start using GTKD</a></li>
<li><a href="../259719/index.html">OS Development on Go + asm Part 0x00</a></li>
<li><a href="../259721/index.html">SIP phone from stm32f4-discovery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>