<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inclusion of external languages ‚Äã‚Äãin Haskell programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article provides a brief description of the technique, which allows the use of libraries written in other programming languages ‚Äã‚Äãin Haskell prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inclusion of external languages ‚Äã‚Äãin Haskell programs</h1><div class="post__text post__text-html js-mediator-article">  This article provides a brief description of the technique, which allows the use of libraries written in other programming languages ‚Äã‚Äãin Haskell programs.  There is no need to either rewrite these libraries in Haskell, or write countless wrappers in C, or write explicit binding.  In the resulting program, you can either directly call someone else's code or call functions from someone else's Haskell code.  The function code itself can be written in an extended plug-in language, which allows specialists in plug-in languages ‚Äã‚Äãto work with it, which, unfortunately, are not yet familiar with Haskell. <br><a name="habracut"></a><br>  This task did not arise from scratch, but was required for one corporation in order to use together the code written in R and the models written in Haskell.  At the same time, it was desirable to use it in such a way that specialists in R programming did not have to learn Haskell either. <br><br>  Thus, the challenge was to enable Haskell to include libraries and code in other languages ‚Äã‚Äãin an efficient manner.  By efficiency, in this case, it is understood that there is no overhead for data transformations during transfer between functions in different languages, as far as possible, and as cheap as possible function calls between languages.  At the moment, there are two similar libraries <a href="https://hackage.haskell.org/package/inline-r">inline-r</a> and later <a href="https://hackage.haskell.org/package/inline-c">inline-c</a> , with an example, which I will explain certain concepts in this technique. <br><br><ul><li>  inline-c is a fairly simple library that allows you to insert C code into haskell code.  In practice, this library is an automation of a fairly simple procedure for writing your own auxiliary functions and creating FFI wrappers for them.  This library shows how you can make the inclusion of a language with a simple (missing runtime) into Haskell code. </li><li>  inline-r is a library that allows you to include code in R in Haskell code, it is already quite interesting, because it shows how you can combine different runtime systems.  Include dynamically typed R code in Haskell code, and efficiently manage data on systems with two garbage collectors. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to implement such a solution, it was necessary to solve the following questions: <br><ol><li>  how to connect code in other languages </li><li>  what should be the syntax of inserts in another language;  code entry method </li><li>  how to convert data so that both libraries can work with it </li></ol><br>  as well as other issues arising with various RTS (runtime system) execution systems, such as several garbage collectors, the use of dynamic typing <br><br><h4>  Embedding the execution system </h4><br>  To enable simple languages ‚Äã‚Äã(C, Rust) without RTS, everything is quite simple; in them, the execution environment is a Haskell program.  In this case, here only the interface support for calling external functions of FFI, and C interest is suitable for most cases. <br>  However, in the case of a performance system, as in R, the question arises as to how it is launched and communicated.  One of the standard approaches to solving this problem is to launch the ‚Äúinterpreter‚Äù (the program of the target language) by a separate process and use any of the RPC tools to exchange messages with it and the source program.  This method however has several drawbacks: <br><br>  If the runtime environment does not have an analogue of the <code>eval</code> method, then you will need to write it yourself.  May require specialization for a specific task, which will reduce the generality of the solution.  In any case, with this method, there are issues with the safety of execution. <br><br>  To transfer data to the donor, it is necessary to send it over the network (it is possible to reduce the complexity of using zero-copy), serialization and deserialization.  An alternative would be to create shared memory transfer mechanisms, which, however, can be quite a challenge in languages ‚Äã‚Äãwhere direct memory access is limited or additional difficulties arise, such as using a copying garbage collector. <br><br>  One of the advantages of this method is the simplicity of the solution, there is also no need for integration of the event loop, which is necessary, for example, for drawing graphics. <br><br>  These restrictions are usually incompatible with minimum overhead requirements.  Therefore, it was often better to embed the Haskell implementation environment.  This solution opens up several additional features: <br><ul><li>  since we are working with shared memory, the extra work on serialization and data transfer disappears; </li><li>  it becomes possible to use the C API (api provided by the functions exported from the library with the C interface), if available, greater control over interpreter / program errors; </li><li>  since such a program is ‚Äúmore aware‚Äù of the data and functions that can execute them, it can further optimize execution. </li></ul><br><br>  In this solution, technical difficulties are possible, for example, if the language runtime environment imposes additional restrictions, for example, it uses TLS (Thread Local Storage) or is essentially single-threaded.  In the first case, you need to use <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html">Control.Concurrent.forkOS</a> to create a branch tied to the OS thread (or use only the main thread).  Secondly, it is necessary to serialize requests on the language side, for example, this can be done using a fairly simple ‚Äúpattern‚Äù: <br><br><pre> <code class="hljs perl">{-<span class="hljs-comment"><span class="hljs-comment"># LANGUAGE ExistentialQuantification #-} import Control.Concurrent data Task = forall a . Task (IO a) (MVar (Either SomeException a)) sendTask :: Chan -&gt; IO a -&gt; IO a sendTask chan f = do result &lt;- newEmptyMVar writeChan chan (Task f result) takeMVar result runTasks :: Chan -&gt; IO () runTasks chan = forever $ do Task f result &lt;- readChan chan mask_ $ do r &lt;- try f putMVar result r</span></span></code> </pre><br>  In this approach there may be some variations, for example, to store the channel in the environment of <code>ReaderT Chan</code> or a global variable, if the uniqueness of this channel should be guaranteed at the program level (you should think three times before choosing this solution, but formally it can be justified).  Also, in some cases, it is better to transmit to the channel the action being formed by the caller, where he himself will put the result in MVar for a response.  But semantically (with accuracy (and) before working with exceptions and completing the execution of this thread) other solutions will be equivalent to this. <br><br><h4>  Data transfer </h4><br>  When transferring data, the first question that needs to be solved is how to present data from an external language in Haskell, the simplest types that C-types allow it to do are: CChar, CInt, CString, CStringLen, Ptr, and others.  Which are C-types to Haskell mappings and are sufficient for representing data from low-level languages.  For type-safe work with them, such data can be wrapped in wrapper types (newtypes), thanks to which, on the one hand, the type system allows, and on the other hand, they don‚Äôt add any load at runtime. <br>  Since plug-in languages ‚Äã‚Äãcan be dynamic, as in particular R the question arises how to represent their meanings in a language.  At the same time, it would be desirable, if possible, to have statically known information about types where it is possible.  In this case, the compiler can give more guarantees for the correctness of the code, and it is possible to generate code by type (see the type classes in Haskell).  Here we can recall the statement that languages ‚Äã‚Äãwith a dynamic type system are uni-typed languages, i.e.  in statics, the entire universe of types represented there is described by a single type.  Using this approach, you can present a value in the language as a pointer tagged with a phantom type indicating the type of expression (instead of a pointer, there may be an index in the table or another identifier that uniquely defines the value, depending on how they are represented in the included language) <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SEXPTYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- generated by hsc2hs newtype SEXP a = SEXP (Ptr SEXPTYPE)</span></span></span></span></code> </pre><br>  <code>SEXPTYPE</code> is a type of interface exported to C.  In order to indicate that, as is the case in dynamic languages, the expression may be of an unknown type, we use the following approach. <br>  To transfer information about types, you can use <code>DataKinds</code> extensions, which allows you to raise the constructors of simple data types to the type level, i.e.  create a type, for example `SomeThing 'False`.  Next, we list all possible primitive types in the pluggable language, for example, in the case of R, this <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SEXPTYPE</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NIL</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Closure</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Real</span></span></span><span class="hljs-class"> ... </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Now, if we know that an expression has a specific type (for example, it was created in Haskell), then we can explicitly write its type as `SEXP 'List` or` SEXP' Real '.  However, when working with a dynamic language, this is not enough, because  all return types are not known there and I would like to be able to pass on a truly dynamic type.  To do this, we can use the Rank2Types extension, which allows us to write the following type: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSEXP</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSEXP</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> . </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SEXP</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  This code means that <code>SomeSEXP</code> for any <code>a</code> expression <code>SomeSEXP a</code> correct, i.e.  accurately reflects the fact of dynamic value.  Now external language methods can safely return <code>SomeSEXP</code> , for converting the type to the known one, you can create a function <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">cast</span></span> :: SomeSEXP -&gt; Maybe (SEXP a)</code> </pre><br>  which will check the type of the expression, and either return an expression or an error. <br>  I would also like to be able to have the type sum, since in some functions the input can be supplied to various types of variables. <br>  To create these types, you can use the TypeFamilies extension, and create a new type of `In` that checks whether this type is in the list of allowed types: <br><br><pre> <code class="hljs rust">infix <span class="hljs-number"><span class="hljs-number">1</span></span> :‚àà -- | The predicate @a :‚àà <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>@ states that @a@ is a member <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span></span> the set @<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>@. <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">family</span></span></span></span> (a :: SEXPTYPE) :‚àà (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> :: [SEXPTYPE]) :: Constraint <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Any</span></span> :‚àà <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> = () a :‚àà (a ': <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = () a :‚àà (b ': <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = a :‚àà <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">In</span></span></span></span> ab = a :‚àà b</code> </pre><br>  This code works in the same way as regular pattern matching at the type level, where <code>()</code> indicates success, and the inability to verify a statement is an error.  Consider the example, <code>In 'Int (Env ': Int ': '[])</code> .  First, we find ourselves in the third condition, since <code>Int</code> does not coincide with <code>'Env</code> , and the type is obtained equal to <code>In 'Int ('Int ': '[])</code> .  His compiler simplifies further and we get to the second expression, from which we derive success, if we checked <code>'Real</code> , then we would reach <code>In 'Real '[]</code> for which there is no sample and, accordingly, a type error would occur. <br>  The problem with this approach is that the type is not injective, i.e.  if we have the expression <code>foo :: In a ['Int,'Real] =&gt; a -&gt; SEXP 'Int</code> , then we will not be able to infer type <code>a</code> , which may not be convenient. <br><br>  In this view, you can already work with functions using the C API and achieve some convenience of writing code.  At first it may seem that this approach will prevent the use of the possibility of modern programming languages, such as comparison with the sample and algebraic data structures, but this is not so. <br>  In order to use such structures we can use the following technique.  We create an image for the structure (view) in it, we define only a shallow (shallow) representation of the structure, this is done so that there is no need to create the entire structure display in memory, moreover, in general, the compiler completely removes all intermediate structures, allowing convenient to work with external data structures without overhead: <br><pre> <code class="hljs rust">data HExp :: * -&gt; SEXPTYPE -&gt; * <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> -- Primitive types. The field names <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> those of &lt;RInternals.h&gt;. Nil :: HExp R.Nil -- Fields: pname, value, internal. Symbol :: SEXP R.Char -&gt; SEXP a -&gt; SEXP b -&gt; HExp R.Symbol -- Fields: carval, cdrval, tagval. List :: (R.IsPairList b, c :‚àà [R.Symbol, R.Nil]) =&gt; SEXP a -&gt; SEXP b -&gt; SEXP c -&gt; HExp R.List ...</code> </pre><br>  And we introduce the function `hexp` creating such an image: <br><pre> <code class="hljs erlang-repl">hexp :: SEXP sa -&gt; HExp sa</code> </pre><br>  Further, using the <code>ViewPatterns</code> extension, <code>ViewPatterns</code> can be used: <br><pre> <code class="hljs erlang-repl">foo (hexp -&gt; Symbol s) = ...</code> </pre><br><br>  To complete the function <br><pre> <code class="hljs erlang-repl">unhexp :: HExp sa -&gt; ms (SEXP a)</code> </pre><br>  It is important to note that the expected <code>unhexp . hexp = id</code> rule is not fulfilled <code>unhexp . hexp = id</code>  <code>unhexp . hexp = id</code> since unhexp always creates a new structure. <br><br>  This technique allows you to conveniently work with external complex structures.  And can be transferred to any external programming language.  The final step here is to have the marshaling mapping of Haskell data structures into external language structures, for this you can enter a type class <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Literal</span></span></span><span class="hljs-class"> a ty | a -&gt; ty </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- | Internal function for converting a literal to a 'SEXP' value. You -- probably want to be using 'mkSEXP' instead. mkSEXP :: a -&gt; IO (SEXP V ty) fromSEXP :: SEXP s ty -&gt; a</span></span></code> </pre><br>  `| |  a -&gt; ty` is a functional relationship between parameters, which says that the type `a` will uniquely determine the type` ty`.  This information greatly assists the compiler in inferring types and does not allow for the creation of erroneous instances.  Next, for native types in Haskell, we define translation functions. <br><br><h4>  Writing code in an external language </h4><br><br>  For writing code, we can create an internal embedded language (e-dsl) (although in a high-level language, the boundaries between the library and the built-in specialized language are very blurred), or a full-featured dsl.  We decided to use ‚ÄúDSL‚Äù, i.e.  actually a slightly modified plugin language.  This method looks more convenient, since in this case the code can be written by those who do not know Haskell, but know the embedded language.  How it can be organized and how it looks. <br><br>  To generate Haskell source code, there is a Template Haskell extension that allows you to build an AST, however there is a series of restrictions, plus type checking is very limited, because  all the expressions generated are of the same type <code>Q Exp</code> , respectively, the compiler cannot verify part of the contracts and as a result non-valid code can be generated, which will be rejected by the compiler when generating the code. <br>  It is also possible to create quasi quotes QuasiQuotes <code>[generator|some-code |]</code> here the <code>generator</code> is a function that will parse the code <code>some-code</code> and get the result.  The result may be Haskell code generated using TemplateHaskell, creating files (for example, external C files), calling <del> <code>find / -delete</code> </del>  or in principle any work. <br><br>  Quasi-quoting is a great candidate for including code, we can create a new parser.  Further, when compiling the project, we call R and give it the source code and get back AST.  After we process the given AST and generate the code, which at runtime will build the same AST with regard to variable substitution from Haskell. <br>  For example, a simple code: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [r| x_hs + x_hs|]</code> </pre><br>  Turns into: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">eval</span></span> $ unhexpIO =&lt;&lt; Lang (installIO ‚Äú+‚Äù) (unHexp $ <span class="hljs-keyword"><span class="hljs-keyword">List</span></span> (mkSEXP x) (<span class="hljs-keyword"><span class="hljs-keyword">List</span></span> (mkSEXP x) Nil)</code> </pre><br>  In fact, the code is slightly more difficult for perception, since the generated code carefully monitors the protection of resources, for more details see the article about GC. <br><br><h4>  Regions and memory system mapping </h4><br>  The greatest difficulty with such a combination of languages ‚Äã‚Äãis the interaction with garbage collectors.  Especially the problem becomes complicated in the event that the garbage collector can move objects during assembly.  Fortunately, neither C (in which the garbage collector is missing) nor objects can be moved to R, which greatly simplifies working with them. <br>  The simplest safe operation mechanism is the creation of a special object that prevents the protected object from being deleted, and its lifetime can be controlled from another language, for Haskell it is: <br><br>  <code>Foreign.StablePtr.newStablePtr</code> - creating a ‚Äúprotecting‚Äù object <br>  <code>Foreign.StablePtr.freeStablePtr</code> - removal of the ‚Äúprotecting‚Äù object <br> <code>extern void hs_free_stable_ptr (HsStablePtr sp);</code>  - removal of the ‚Äúprotecting‚Äù object from an external language <br><br>  In R this is: <br>  <code>preserveObject</code> - mark the object as used <br>  <code>releaseObject</code> - mark an object as unused <br><br>  Then, if you use an object from R in haskell, you can do <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protected</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prected</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForeignPtr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SEXPPTR</span></span></span><span class="hljs-class">) protect (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SEXP</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) = do preserveObject p newForeignPtr p releaseObject</span></span></code> </pre><br>  This method is good enough, but not applicable to all languages, since  the necessary API may not be, and it does not work for objects on the ‚Äústack‚Äù, and finally, it may have a very high cost, for example, the price of creating and deleting an object in R <code>O(N)</code> , where <code>N</code> number of objects protected in this way .  Therefore, the use of such a method as the main one is not the best idea. <br>  However, this is not the only and not the main way to protect objects in R. In addition to this protection method, there is another one based on the ‚Äúprotection stack‚Äù, any object can be placed on the stack and N objects can be removed from the stack. these operations have O (1) complexity.  This approach to protecting objects is used both in R itself and in functions written in C. And I would really like to display this method in Haskell.  And for this it can be realized with the help of static regions, this technique was described in the <a href="http://okmij.org/ftp/Haskell/regions.html">article by</a> Oleg Kiselev. <br><br>  I note that due to the characteristics of the garbage collection system in R, this approach differs from the original solution, although they are equivalent in expressiveness <br><br>  newtype R sma = R {runR :: ReaderT (IORef Int) ma} <br>  deriving (Functor, Applicative, Monad) <br><br><br>  In <code>IORef</code> we store the number of objects allocated on a given ‚Äústack‚Äù segment, so that when we exit, we can free them all.  Next, an auxiliary function is introduced: <br><br><pre> <code class="hljs coffeescript">runRegion :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forall s . R s IO a)</span></span></span><span class="hljs-function"> -&gt;</span></span> IO a runRegion f = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ref &lt;- newIORef <span class="hljs-number"><span class="hljs-number">0</span></span> runReaderT (runR f) ref</code> </pre><br><br>  and main function: <br><br><pre> <code class="hljs coffeescript">region :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forall s . R (sm) ma)</span></span></span><span class="hljs-function"> -&gt;</span></span> ma region f = ‚Ä¶ </code> </pre><br>  Now we have to extend the <code>SEXP</code> type <code>SEXP</code> an additional phantom variable <code>s</code> , denoting the region in which the variable was allocated or protected. <br><br>  Here s plays the role of a region, in addition we introduce 2 regions: <br>  <code>data V</code> is an empty region, indicates that the variable does not belong to any stack segment and is not protected (can be deleted at the next memory allocation) <br>  <code>data G</code> is a global region, indicating that the variable was protected by a mechanism (preserve) and can be used in all regions. <br>  And with the help of the region function we can build hierarchies of structures <code>forall s1 s2 s3 . s1 (s2 s3 V))</code>  <code>forall s1 s2 s3 . s1 (s2 s3 V))</code> . <br><br>  The most interesting thing here is that we can introduce a semilattice (lattice) closed relative to the nesting operation of the regions.  In this case, we have that: <br> <code>V &lt; .. &lt; s2 (s1) &lt; s1 &lt; G</code> <br>  In this case, we know that we can safely use items from a ‚Äúlarger‚Äù region in a smaller one and can either enter the operation <br><br><pre> <code class="hljs coffeescript">loosen :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s1 &lt; s2)</span></span></span><span class="hljs-function"> =&gt;</span></span> SEXP s2 a -&gt; SEXP s1 a &lt;source&gt;     ,       : &lt;source language=<span class="hljs-string"><span class="hljs-string">"haskell"</span></span>&gt; someOperation :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s &lt; s1, s &lt; s2)</span></span></span><span class="hljs-function"> =&gt;</span></span> SEXP s1 Int -&gt; SEXP s2 Int -&gt; R s (SEXP s Int)</code> </pre><br><br>  It remains only to create relationships in intermediate regions: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ancestor</span></span></span><span class="hljs-class"> = (&lt;) class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ancestor</span></span></span><span class="hljs-class"> s s1 instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ancestor</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sm</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sm</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ancestor</span></span></span><span class="hljs-class"> parent region =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ancestor</span></span></span><span class="hljs-class"> parent (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class">)</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  The above describes the basic elements of a technique that can be applied to include other languages ‚Äã‚Äãin Haskell.  The technique can be applied to include code in low-level languages, to increase the efficiency of the code (where appropriate and increase it), such as <code>C</code> or <code>Rust</code> .  Or languages ‚Äã‚Äãwith a large number of libraries, which can allow working with a convenient programming language, without modifying the work already done, such as <code>python</code> , or specialized languages ‚Äã‚Äãlike <code>maxima</code> , <code>reduce</code> or proprietary counterparts. <br><br>  I also understand that here all the directions: interaction with external code, creation of regions, code generation were considered very surface and if I need to consider them in more detail, then I can do it in the following articles. </div><p>Source: <a href="https://habr.com/ru/post/269939/">https://habr.com/ru/post/269939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../26993/index.html">Silverlight 2 beta2 is available</a></li>
<li><a href="../269931/index.html">How to draw curves graphics in the style of XKCD</a></li>
<li><a href="../269933/index.html">Pitfalls of backup in hybrid storage systems</a></li>
<li><a href="../269935/index.html">Operating System Migration History</a></li>
<li><a href="../269937/index.html">PHP Digest number 73 - interesting news, materials and tools (October 18 - November 5, 2015)</a></li>
<li><a href="../26994/index.html">Social replacement for RSS reader</a></li>
<li><a href="../269943/index.html">How to write Go code that is easy to port</a></li>
<li><a href="../269947/index.html">Cloud explanations: we create a virtual PBX operator service in three days</a></li>
<li><a href="../269949/index.html">Choosing a Virtualization Platform: Why VMware</a></li>
<li><a href="../269951/index.html">How to detect and eliminate hidden forwarding for mobile devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>