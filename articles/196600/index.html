<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with TFT display on ARDUINO DUE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second part is here: http://habrahabr.ru/post/196864/ 
 This article opens a short series of articles on working with multi-color TFT displays on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with TFT display on ARDUINO DUE</h1><div class="post__text post__text-html js-mediator-article">  The second part is here: <a href="http://habrahabr.ru/post/196864/">http://habrahabr.ru/post/196864/</a> <br>  This article opens a short series of articles on working with multi-color TFT displays on the Arduino DUE.  In this and the following articles, the main features of TFT displays will be discussed, libraries will be described, examples of typical tasks arising from working with such displays will be considered. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/423/179/390/423179390dc9a3fbdfdba173fee975a0.jpg"></div><br>  Currently, there are many different TFT displays on the Arduino component market.  From the user's point of view, they differ from each other mainly in size, resolution, connection methods and additional functionality.  Most of these displays are equipped with a touch screen, which makes the control of the system more convenient and allows you to get rid of traditional buttons, joysticks, encoders and other mechanical devices. <br><br>  Working with a graphic display with a resolution of the order of 320x240 and higher assumes the presence of a solid amount of memory and a rather high speed of the microcontroller itself.  In addition, the connection often requires a large number of pins, so the Arduino DUE controller was chosen as the base. <br><a name="habracut"></a>  The following equipment was used as an ‚Äúexperimental setup‚Äù when writing this article: <br><ul><li>  Arduino DUE Controller - Arduino-compatible Iduino clone from Getech. </li><li>  TFT display: after much deliberation, the Coldtears Electronics 3,2 '' advanced version of the display was chosen, featuring an increased resolution (480x320 instead of 320x240 on most similar displays) and additional functionality (this display has built-in Flash-memory, which are sewn into additional fonts and icons, which allows you to refuse to download additional fonts, thereby saving the controller's precious memory).  The display is equipped with an ILI948 controller.  The card also has an SD card slot. </li><li>  Special Schild for connecting the display to the controller Arduino DUE.  This shield allows you to connect the display via a 16-bit parallel interface, and Flash memory through an Arduino ISP connector, which, according to the developers, ensures maximum performance.  The Schild is also equipped with an SD card slot (by default it is disabled, to enable it, you must close the jumper on the board, but more on that later). </li></ul><br>  Pay attention, Schild is designed for Arduino DUE.  To use the display with the Arduino MEGA, another plate version is needed, equipped with a 5v ‚Äì 3.3v level converter. <br>  All materials relating to pinout display and CTE plate can be downloaded on the manufacturer's website: <br>  Display: <a href="">http://coldtears.lin3.siteonlinetest.com/files/3.2b.zip</a> <br>  Schild: <a href="">http://coldtears.lin3.siteonlinetest.com/files/CTE_DUE_shield.zip</a> <br>  To work with TFT displays, the UTFT library set is used.  The most recent versions of these libraries can be found on the developer‚Äôs website: <a href="http://www.henningkarlsen.com/electronics/">http://www.henningkarlsen.com/electronics/</a> <br>  After connecting the display, the following pins of the controller remain free: D0, D1, D8, D11-D13, D14-D24, D29-D31, D41-D43, A0-A11, DAC0, DAC1, SCL1, SDA1, which can be used at your discretion. <br><br><h4>  1. Basic UTFT library.  General information </h4><br>  The UTFT library is designed to work with TFT displays of various types, connected both via a parallel (8bit or 16bit) and serial interface.  It was originally developed to support displays made by ITead Studio and NKG Electronics, but then it was supported by several other manufacturers.  The original library can be downloaded here: <a href="http://www.henningkarlsen.com/electronics/library.php%3Fid%3D51">http://www.henningkarlsen.com/electronics/library.php?id=51</a> <br>  The library comes with pretty good documentation in English.  This article is based mainly on developer documentation with the addition of a certain amount of practical experience and additional information that was obtained in the course of work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A list of displays supported by the library and their main features are provided in the accompanying document ‚ÄúUTFT Supported display modules &amp; controllers‚Äù, which is supplied with the library. <br>  This library is basic and contains only the main display functionality.  There are several additions to it that implement additional functions, such as control using the touch screen (U_Touch), working with on-screen buttons (UTFT_Buttons), an extended set of functions for drawing graphic primitives (UTFT_Geometry), using built-in fonts and icons in some displays (UTFT_CTE), etc. <br>  The base library allows you to work with loadable fonts.  Fonts are stored as data arrays, which are placed in separate files and connected to the program text. <br><br><h4>  2. Getting started with the library </h4><br>  The library can be used both with controllers based on AVR platform (Arduino MEGA), and with controllers on ARM platform (Arduino DUE).  Before you start using the library with an Arduino DUE controller, you need to go to the folder where the library is installed: _ARDUINO_FOLDER_ / libraries / UTFT, find the folder / hardware / arm and the file HW_ARM_defines in it.  In this file you need to uncomment the line: <br> <code>#define CTE_DUE_SHIELD 1</code> <br>  The UTFT library also has a useful "trick" that allows you to disable the initialization codes of those display models that are not currently in use.  This saves some amount of memory (for example, my compiled program size has decreased by almost 12 Kb).  To do this, open the memorysaver.h file in the editor located in the root folder of the library and uncomment the lines with the names of those controllers that you do not plan to use in your project.  At the same time, only one controller should be commented out - the one you use.  Our display, as mentioned above, is equipped with an ILI9481 controller.  Therefore, the line: <br> <code>//#define DISABLE_ILI9481 1 // CTE32HR</code> <br>  we leave it commented out, and in the remaining lines we delete all the characters // at the beginning of the lines.  Now you can work. <br><br>  The use of a library in a project begins with its loading and initialization.  Initialization parameters depend on the type of display used.  We load the UTFT base library and create an object - a display named myGLCD.  Parameters - display model identifier and pin numbers to which RS, WR, CS, RST and ALE lines are connected.  These parameters should be found out from the display manufacturer or selected by the list of supported displays that comes with the library. <br>  In our version, a 3.2 ‚Äùdisplay with a resolution of 480x320 and an ILI9481 controller manufactured by Coldtears electronics is referred to as the CTE32HR.  In this case, according to the Schild scheme, control lines are connected to pins 25-28. <br> <code>#include &lt;UTFT.h&gt;</code> <br> <code>UTFT myGLCD(CTE32HR,25,26,27,28);</code> <br>  Next, you need to connect external fonts (we will not use the built-in fonts of the display yet - this is a topic for another conversation).  The library comes with three basic fonts.  Here is the ad string for these fonts: <br> <code>extern uint8_t SmallFont[];</code> <br> <code>extern uint8_t BigFont[];</code> <br> <code>extern uint8_t SevenSegNumFont[];</code> <br>  So, we connected and initialized the library, attached the fonts, now we need to initialize our display in the void setup () procedure: <br> <code>void setup() {</code> <br> <code>myGLCD.InitLCD();</code> <br> <code>myGLCD.clrScr();</code> <br> <code>}</code> <br>  The InitLCD () command allows you to set the vertical or horizontal orientation of the display.  By default (if the command is invoked without a parameter) the horizontal orientation is set.  The clrScr () command;  just clears the display.  Note that the library does not have the concept of the background color of the entire display.  After cleaning, the display always turns black. <br><br>  Finally, before we move on to a detailed review of the library commands, finish our simplest example ‚Äî choose the BigFont font and print the traditional ‚ÄúHello, world!‚Äù In the center of the top line of the display: <br> <code>void loop() {</code> <br> <code>myGLCD.setFont(BigFont);</code> <br> <code>myGLCD.print("Hello, world!",CENTER,0);</code> <br> <code>}</code> <br> <br><h4>  3. Library Commands </h4><br>  When working with the library, you need to install it in the folder with the Arduino libraries and connect using the directive: <br> <code>#include &lt;UTFT.h&gt;</code> <br>  The description of the teams is taken mainly from the English manual supplied with the library, and is significantly complemented by practical observations and examples.  So‚Ä¶ <br><br>  <b>UTFT - creates a base display class with the specified name, specifies the model identifier and the connection method as parameters.</b> <br>  Two options are possible: for models with a parallel interface, the command is: <br>  <code>UTFT _NAME_ (model, RS, WR, CS, RST, ALE)</code> where _NAME_ is an arbitrary display object name that will be used as a prefix for any access to it, model is a specific display model identifier (see the list of supported models) , and RS, WR, CS, RST and ALE are pin numbers to which the corresponding control signals of the display module are connected by means of the nameplate.  Not all supported models have an ALE signal, if your model does not have one, just skip this parameter. <br>  For models with a serial interface, the command is: <br>  <code>UTFT _NAME_ (model, SDA, SCL, CS, RST, RS)</code> where SDA, SCL, CS, RST and RS are pin numbers to which the corresponding signals of the serial interface are connected.  The RS parameter is optional, for some display models it is not specified. <br>  The string with this command is placed in the definition area and must precede any other library commands.  The specified display name should be used as a prefix to all subsequent library commands. <br><br>  <b>InitLCD - initializes the display and sets the horizontal or vertical orientation.</b>  <b>The orientation identifier is specified as a parameter.</b> <br>  Being set without parameters, the command sets the horizontal orientation.  If you specify the PORTRAIT parameter or 0, the vertical orientation will be selected, if you specify LANDSCAPE or 1 is horizontal. <br>  In the horizontal orientation, the connectors of the controller are located on the left, with the vertical - at the bottom.  Other options are not provided.  Setting a parameter other than 0 and 1 as a parameter results in a distorted display of information. <br>  This command is usually used in the void setup () section, but it can also be used in the main program loop, as, for example, here: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { } void loop() { myGLCD.InitLCD(1); myGLCD.setFont(BigFont); myGLCD.print("Hello, world!",CENTER,0); delay(1000); myGLCD.InitLCD(0); myGLCD.setFont(BigFont); myGLCD.print("Hello, world!",CENTER,0); delay(1000); }</span></span></span></span></code> </pre><br>  In principle, by attaching a position sensor to the display, it would be possible to arrange a screen flip as in a tablet;)) however, during initialization the display flashes white for a short time, which spoils the impression.  ;) <br>  This command sets the background color to black, the text color to white, resets the font name used to ‚Äúnone‚Äù, and the result of the work of all print commands becomes unpredictable until the font is explicitly set (see the setFont command).  After initialization, it is recommended to clear the display (see the clrScr command), and the screen will be filled with black. <br><br>  <b>clrScr - clears the display, erasing all information displayed on the display and filling the display with black color.</b>  <b>It has no parameters.</b> <br>  When cleaning the display, the specified background color (see the setBackColor command) is not reset and remains the same, but the display is still filled with black.  In order to clear a display with a different background color, use the fillScr command.  The clrScr command is illustrated by the following example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); delay(1000); myGLCD.setBackColor(0,255,0); myGLCD.clrScr(); delay(1000); myGLCD.setFont(BigFont); myGLCD.print("FFFFFFFF", CENTER,0); } void loop() { }</span></span></span></span></code> </pre><br>  After the controller is reset, the display is initialized, then after 1 second cleaning (the display turns black) and after another second, the characters are displayed, and we see that the background color set before cleaning has not changed. <br>  Before considering the following several commands, it is necessary to consider the specifics of specifying colors in library commands. <br><br>  <b>Color coding system</b> <br>  The colors in the library are defined in several ways.  The internal format of the color data is RGB565.  In this format, color is encoded with a 16-bit value, in which the level of red and blue is encoded by five bits, and green by six.  Most of the library commands working with color take values ‚Äã‚Äãthat are given as three numbers separated by a comma.  Each of these numbers is responsible for the level of the corresponding color (R, G, B).  Valid values ‚Äã‚Äãfor each number are from 0 to 255. <br><br>  Thus, the colors are specified by the user in the RGB888 format, and RGB565 is used inside the library.  Format conversion is performed within the library using the following formula: <br> <code>word color = ((r&amp;248)&lt;&lt;8 | (g&amp;252)&lt;&lt;3 | (b&amp;248)&gt;&gt;3);</code> <br>  where color is the color value in RGB565 format, and r, g, and b are user-defined color values.  It is in this format that values ‚Äã‚Äãand all functions for determining the current color are returned. <br>  When specifying colors, it is necessary to take into account that not all combinations of the specified values ‚Äã‚Äãof r, g, and b will produce different colors.  Therefore, for example, the red level values ‚Äã‚Äãof 255 and 253 give the same red level.  The program below displays the maximum and minimum values ‚Äã‚Äãof r, g, and b valid for the color specified in the program in the color settings commands.  To perform the calculation, substitute in the parameters of the myGLCD.setBackColor command decimal values ‚Äã‚Äãof r, g and b for the selected color, compile and run the program.  The display shows the color code in the RGB565 system, returned by the function myGLCD.getBackColor, as well as the minimum and maximum values ‚Äã‚Äãof r, g, and b, which allow to obtain this color. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { myGLCD.setBackColor(245,34,112); myGLCD.setColor(VGA_NAVY); word CurrentColor=myGLCD.getBackColor(); byte R_1 = highByte(CurrentColor)&gt;&gt;3; byte R_min = R_1&lt;&lt;3; byte R_max = R_min|7; byte G_1 = highByte(CurrentColor)&lt;&lt;5; G_1 = G_1&gt;&gt;2|lowByte(CurrentColor)&gt;&gt;5; byte G_min = G_1&lt;&lt;2; byte G_max = G_min|3; byte B_1 = lowByte(CurrentColor)&lt;&lt;3; B_1 = B_1&gt;&gt;3; byte B_min = B_1&lt;&lt;3; byte B_max = B_min|7; myGLCD.print("GetColor", 0,0); myGLCD.print("RGB888 Min", 0,36); myGLCD.print("RGB888 Max", 0,54); myGLCD.printNumI(CurrentColor, 162,0); myGLCD.printNumI(R_min, 162,36); myGLCD.printNumI(R_max, 162,54); myGLCD.printNumI(G_min, 212,36); myGLCD.printNumI(G_max, 212,54); myGLCD.printNumI(B_min, 262,36); myGLCD.printNumI(B_max, 262,54); }</span></span></span></span></code> </pre><br>  Some standard colors can be set using identifiers: <br>  VGA_BLACK - black, <br>  VGA_SILVER - silver <br>  VGA_GRAY - gray <br>  VGA_WHITE - white <br>  VGA_MAROON - red-brown <br>  VGA_RED - red <br>  VGA_PURPLE - Magenta <br>  VGA_FUCHSIA - Fuchsia <br>  VGA_GREEN - green <br>  VGA_LIME - Lime <br>  VGA_NAVY - dark blue <br>  VGA_BLUE - blue <br>  VGA_TEAL - blue-green <br>  VGA_AQUA - sea wave <br>  If you want to find out the RGB codes for these colors - substitute the color identifier instead of three numbers into the myGLCD.setBackColor command in the above program, after compiling and running, the display will show the necessary codes. <br><br>  So, we will continue the consideration of the library commands: <br><br>  <b>fillScr - clears the display, erasing all the information displayed on the display and filling it with the specified background color as a parameter.</b> <br>  The background color is defined by three numbers or a color identifier, for example, like this: <br> <code>fillScr(0,0,0); //  </code> <br> <code>fillScr(255,255,255); //  </code> <br> <code>fillScr(255,128,0); //  </code> <br> <code>fillScr(VGA_RED); //   </code> <br>  This command, like clrScr, does not change the specified background color for print commands, therefore, when printing on a display filled with the specified color, the background color must also be specified (see the setBackColor command). <br><br>  <b>setColor - sets the ink color for all commands for printing and drawing graphic primitives.</b>  <b>The parameter indicates the desired color.</b> <br>  Colors are set the same way as for the fillScr command ‚Äî either numbers or standard color identifiers.  Example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { myGLCD.setColor(VGA_RED); myGLCD.print("Hello, World!",CENTER,0); myGLCD.setColor(VGA_NAVY); myGLCD.print("Hello, World!",CENTER,18); myGLCD.setColor(VGA_TEAL); myGLCD.print("Hello, World!",CENTER,36); myGLCD.setColor(VGA_LIME); myGLCD.print("Hello, World!",CENTER,54); while(1); }</span></span></span></span></code> </pre><br>  <b>setBackColor - sets the background color for print commands.</b>  <b>The parameter indicates the desired color.</b> <br>  Colors are set in the usual way - by numbers or identifiers (see the fillScr command), however, there is another identifier for this command - VGA_TRANSPARENT, which allows printing characters on a ‚Äútransparent‚Äù background. <br>  If you need to print on a display filled with any color other than black, you must set the exact same background color with the setBackColor command, or use the setBackColor (VGA_TRANSPARENT) command. <br><br>  <b>getColor - returns the current ink color value.</b>  <b>It has no parameters.</b> <br><br>  <b>getBackColor - returns the current value of the background color.</b>  <b>It has no parameters.</b> <br><br>  These two functions return a word value corresponding to the currently specified color in RGB565 format.  This value can be passed as a parameter in the setColor, SetBackColor and fillScr commands like this: <br> <code>setColor(32586);</code> <br>  This command gives the same color as setColor (120,232.80) or setColor (125,233,84), as can be seen with the RGB565 color decoding program discussed above. <br><br>  <b>getDisplayXSize - returns the width of the display in pixels at the selected orientation.</b>  <b>It has no parameters.</b> <br><br>  <b>getDisplayYSize - returns the value of the display height in pixels at the selected orientation.</b>  <b>It has no parameters.</b> <br><br>  These two functions can be illustrated by the following example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { } void loop() { myGLCD.InitLCD(PORTRAIT); myGLCD.setFont(BigFont); myGLCD.clrScr(); myGLCD.print("Screen Width=",0,0); myGLCD.printNumI(myGLCD.getDisplayXSize(),250,0); myGLCD.print("Screen Height=",0,18); myGLCD.printNumI(myGLCD.getDisplayYSize(),250,18); delay(2000); myGLCD.InitLCD(LANDSCAPE); myGLCD.setFont(BigFont); myGLCD.clrScr(); myGLCD.print("Screen Width=",0,0); myGLCD.printNumI(myGLCD.getDisplayXSize(),250,0); myGLCD.print("Screen Height=",0,18); myGLCD.printNumI(myGLCD.getDisplayYSize(),250,18); delay(2000); }</span></span></span></span></code> </pre><br>  When the program starts (vertical orientation is set), the display width will be equal to 320 pixels, and its height will be 480, after 2 seconds the orientation will change to horizontal and will become equal to 480 pixels, and will be 320 in height. <br>  Before considering the print commands and working with fonts, it is necessary to elaborate on the methods of using fonts in the UTFT library. <br><br>  <b>External fonts for print commands.</b> <br>  External fonts are stored in separate files with the extension .c and represent arrays of data containing information about font parameters and encoded graphic images of characters. <br>  The font is connected with the string "extern uint8_t _NAME_SHIFT_;".  The extern qualifier indicates that the array with the font data is in another file, and the font name is taken from the font file.  Please note that this is not the name of the file, but the name of the font itself (they may differ).  Fonts used must be declared in your program using the extern specifier.  For example: <br> <code>extern uint8_t BigFont[];</code> <br>  The library comes with three main fonts: <br><ul><li>  SmallFont - 95 characters 8x12 </li><li>  BigFont - 95 characters 16x16 </li><li>  SevenSegNumFont - 10 numeric characters 32x50 </li></ul><br>  Font SevenSegNumFont simulates a 7-segment digital indicator. <br>  Additional fonts can be found here: <br>  <a href="http://www.henningkarlsen.com/electronics/r_fonts.php">http://www.henningkarlsen.com/electronics/r_fonts.php</a> <br><br>  And here is an online service that allows you to create your own fonts from specially prepared graphic files: <br>  <a href="http://www.henningkarlsen.com/electronics/t_make_font_file.php">http://www.henningkarlsen.com/electronics/t_make_font_file.php</a> <br><br>  The fonts included in the library bundle are stored in the DefaultFonts.c file in the root folder of the library.  Additional fonts (drawn by yourself or downloaded from the above link) are recommended to be placed in the folder of your project, otherwise the compiler may not find them. <br><br>  Font files are definitions of arrays containing service information and an encoded graphic image of a font.  In addition to the title, the comments inside the font file also contain information on the size of the character in pixels (this information will be useful when setting the text display coordinates), the amount of memory occupied by the font data array and the number of characters specified in this font.  There are "full" fonts of 95 characters, "digital" (10 characters) and "subsets" (a different number of characters). <br>  The first 4 bytes of the array contain service information: <br><br>  Byte 0 - horizontal font size in pixels <br>  Byte 1 - vertical font size in pixels <br>  Byte 2 is the code of the first character of the font (for ‚Äúfull‚Äù fonts, this is 0x20, that is, the space code, for ‚Äúdigital‚Äù - 0x30 - the character code ‚Äúzero‚Äù). <br>  Byte 3 - the number of characters of the font (for "full" fonts 0x5F, for "digital" - 0x0A). <br><br>  More information about the subtleties of the format and creating custom fonts can be found here: <a href="http://www.henningkarlsen.com/electronics/h_utft_fonts_101.php">http://www.henningkarlsen.com/electronics/h_utft_fonts_101.php</a> <br><br>  If you plan to work with large figures stylized as a 7-segment indicator, we recommend immediately replacing the SevenSegNumFont font with the alternative SevenSegNumFontPlus font, which can be downloaded here: <br>  <a href="http://www.henningkarlsen.com/electronics/dlfont.php%3Fid%3D21%26t%3Dc">http://www.henningkarlsen.com/electronics/dlfont.php?id=21&amp;t=c</a> <br>  it is distinguished by the presence of a very useful ‚Äú:‚Äù character, which is not in the standard font.  The font file should be placed in the folder with your program, replace the ad extern uint8_t SevenSegNumFont [];  on extern uint8_t SevenSegNumFontPlus [];  then close and reopen the project.  The font file should open with the project in the adjacent tab. <br><br>  <b>setFont - sets the font for print commands.</b>  <b>Font name is passed as a parameter.</b> <br>  The font must be previously declared in the program definition area.  Example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t SmallFont[]; void setup() { myGLCD.InitLCD(); myGLCD.setFont(SmallFont); myGLCD.clrScr(); myGLCD.print("Hello, World!",0,0); } void loop() {}</span></span></span></span></code> </pre><br>  <b>getFont - returns a pointer to the address of the current font in the memory of the controller.</b> <br>  Consider an example.  Slightly above, we already said that the first four bytes in the font data array contain information about the font properties.  This information for the current font can be obtained directly from the memory of the controller and used in the program.  The following program places in variables and displays the size of the character in pixels, the code of the first character and the number of characters of the current font specified by the setFont command. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); SerialUSB.begin(9600); } void loop() { uint8_t* FontAddr = myGLCD.getFont(); byte CurrentFontX = *FontAddr; byte CurrentFontY = *(FontAddr+1); byte CurrentFontStartCode = *(FontAddr+2); byte CurrentFontSymNumber = *(FontAddr+3); myGLCD.printNumI(CurrentFontX, 0,0); myGLCD.printNumI(CurrentFontY, 0,18); myGLCD.printNumI(CurrentFontStartCode, 0,36); myGLCD.printNumI(CurrentFontSymNumber, 0,54);</span></span></span></span></code> </pre><br>  Similarly, you can access any byte of the current font. <br><br>  <b>getFontXsize - returns the horizontal size (width) of the character of the current font in pixels.</b>  <b>It has no parameters.</b> <br><br>  <b>getFontYXsize - returns the vertical size (height) of the character of the current font in pixels.</b>  <b>It has no parameters.</b> <br><br>  These functions can be useful in calculating coordinates for print commands.  Examples of using these functions for calculating coordinates are given in the description of print commands. <br>  Next, we consider several commands designed to display symbolic information, that is, print commands. <br><br>  <b>print - displays the text, the contents of a character variable or an object of type String.</b>  <b>The output text, the coordinates of the upper left corner of the printable area are passed as parameters.</b>  <b>Another optional parameter allows positioning a printable line with a given slope.</b> <br>  This command is designed to display textual information.  Print coordinates X and Y are specified in pixels and can be passed either explicitly or via integer variables or expressions.  There are also three predefined identifiers for use as the X coordinate: <br><ul><li>  LEFT - the text is aligned to the left of the display. </li><li>  CENTER - text is centered on the display. </li><li>  RIGHT - text is aligned to the right edge of the display. </li></ul><br>  Text information can be represented as a string enclosed in double quotes: <br> <code>myGLCD.print("Hello, World!", 0,0);</code> <br>  or as a variable of type String: <br> <code>String text = "Hello, World!";</code> <br> <code>myGLCD.print(text, 0,0);</code> <br>  or as the result of a function that returns a string value: <br> <code>int valueInt = 12345;</code> <br> <code>myGLCD.print(String(valueInt), 0,0);</code> <br> <code>float valueFloat = 12345.67;</code> <br> <code>myGLCD.print(String(valueFloat), 0,18);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinates are set individually for each invocation of the command, the current position of the print is not returned by the command. </font><font style="vertical-align: inherit;">Therefore, you need to independently calculate the position for the next print command. </font><font style="vertical-align: inherit;">This can be done in a fairly simple way. </font><font style="vertical-align: inherit;">The following example prints two string values ‚Äã‚Äãin a row on one line (without a space):</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { int X=0; int Y=0; int valueInt1 = 12345; myGLCD.print(String(valueInt1), X,Y); X=X+myGLCD.getFontXsize()*String(valueInt1).length(); int valueInt2 = 67890; myGLCD.print(String(valueInt2), X,Y); }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To separate output values ‚Äã‚Äãby a space, the calculated value of X must be increased by the width of one character. </font><font style="vertical-align: inherit;">And here the printing is carried out in two lines:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { int X=0; int Y=0; int valueInt1 = 12345; myGLCD.print(String(valueInt1), X,Y); Y=Y+myGLCD.getFontYsize(); int valueInt2 = 67890; myGLCD.print(String(valueInt2), X,Y); }    LEFT, CENTER  RIGHT       : #include &lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { int Y=60; myGLCD.print("Hello, World!", LEFT, Y); Y=Y+myGLCD.getFontYsize(); myGLCD.print("Goodbye, World!", LEFT,Y); Y=Y+myGLCD.getFontYsize()*4; myGLCD.print("Hello, World!", CENTER, Y); Y=Y+myGLCD.getFontYsize(); myGLCD.print("Goodbye, World!", CENTER,Y); Y=Y+myGLCD.getFontYsize()*4; myGLCD.print("Hello, World!", RIGHT, Y); Y=Y+myGLCD.getFontYsize(); myGLCD.print("Goodbye, World!", RIGHT,Y); }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another optional parameter allows you to print lines inclined at an angle from 0 to 359 degrees. Rotation is set relative to print coordinates (upper left corner). The zero value of the angle leads to the usual horizontal printing, then as the angle increases, the text rotates clockwise by a given angle. The following example allows you to get a funny graphic effect:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { int X=240; int Y=160; for (int DEG=0; DEG&lt;360; DEG+=20) { String text = "Hello, World!"; myGLCD.print(text, X,Y, DEG); } }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When printing text at an angle using the predefined identifiers LEFT, CENTER and RIGHT is not recommended, because they can not be adequately computed by the library. That is, the alignment is still calculated as if the line is printed horizontally, and the rotation is carried out after alignment and is still relative to the upper left corner of the print area. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, print commands do not know how to determine the output outside the display. So the maximum line length will have to be monitored independently. If the line is too long, then its "tail" can be displayed over the already printed text. If you get out of the bottom of the display, the result may be unpredictable.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printNumI - displays an integer or the contents of an integer variable. As parameters, the displayed value and the coordinates of the upper left corner of the printable area are transferred. Optional parameters allow you to control the output format.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Print coordinates are set the same as for the print command. When printing signed numbers at position X, the number sign is displayed, and then the first digit. When printing unsigned numbers or positive values, the first digit of the number is displayed at position X.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; void setup() { myGLCD.InitLCD(); myGLCD.clrScr(); myGLCD.setFont(BigFont); } void loop() { byte X=100; byte Y=10; int Num1 = 1234; int Num2 = -1234; unsigned int Num3= 12345; myGLCD.printNumI(Num1,X,Y); Y=Y+myGLCD.getFontYsize(); myGLCD.printNumI(Num2,X,Y); Y=Y+myGLCD.getFontYsize(); myGLCD.printNumI(Num3,X,Y); }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A printed value can be passed as an integer: </font></font><br> <code>myGLCD.printNumI(1250,0,0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or a variable of one of the integer types: </font></font><br> <code>int Num = 1324;</code> <br> <code>myGLCD.printNumI(Num,0,0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also possible to output the result of any function or expression, which is an integer value: </font></font><br> <code>myGLCD.printNumI(myGLCD.getFontYsize()*2,0,0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When working with integer values, you must remember that in Arduino DUE, the int type is stored as type long as a 4-byte number with a range of valid values ‚Äã‚Äãfrom ‚Äì2,147,483,648 to 2,147,483,647. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The unsigned int and unsigned long types are not supported by the printNumI command, i.e. the value can be transferred to the command, but will be displayed as a signed number. The type char is on the contrary treated as unsigned.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional optional parameters of this command allow you to set the format of the output numbers. The length parameter defines the minimum number of familiarity (including the sign of the number) occupied by the displayed number on the display. If the number of digits of the number is less than the specified value of length, the missing number of familiarity is supplemented on the left with the required number of characters. The filler parameter allows you to specify a character (the default is a space), which will be supplemented with a number. The combination of these symbols makes it possible, in particular, to organize the output of numbers aligned on the right border or to supplement with insignificant zeros of values ‚Äã‚Äãwhen displaying a time or date. That is, instead of the usual design:</font></font><br> <code>byte Day = 2;</code> <br> <code>byte Month = 9;</code> <br> <code>int Year = 2013;</code> <br> <code>if (Day&lt;10){</code> <br> <code>myGLCD.print("0",0,0);</code> <br> <code>myGLCD.printNumI(Day,16,0);</code> <br> <code>}else{</code> <br> <code>myGLCD.printNumI(Day,0,0);}</code> <br> <code>myGLCD.print(".", 32,0);</code> <br> <code>if (Month&lt;10){</code> <br> <code>myGLCD.print("0",48,0);</code> <br> <code>myGLCD.printNumI(Month,64,0);</code> <br> <code>}else{</code> <br> <code>myGLCD.printNumI(Month,48,0,2,'0');}</code> <br> <code>myGLCD.print(".", 80,0);</code> <br> <code>myGLCD.printNumI(Year,96,0);</code> <br>  you can simply write: <br> <code>byte Day = 2;</code> <br> <code>byte Month = 9;</code> <br> <code>int Year = 2013;</code> <br> <code>myGLCD.printNumI(Day,0,0,2,'0');</code> <br> <code>myGLCD.print(".", 32,0);</code> <br> <code>myGLCD.printNumI(Month,48,0,2,'0');</code> <br> <code>myGLCD.print(".", 80,0);</code> <br> <code>myGLCD.printNumI(Year,96,0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isn't it so much better? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printNumF - displays a real number or the contents of a real type variable. As parameters, the displayed value, the number of digits after the decimal point and the coordinates of the upper left corner of the print area are transferred. Optional parameters allow you to control the output format.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Print coordinates are set in the same way as in other print commands. The displayed real value can be specified as a number, as a variable of a real type (float), and also as a function that returns a real result or expression, the result of which is a real number.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of digits after the decimal point can be set from 1 to 5. A zero value is not allowed (in this case, it is recommended to convert the number to an integer type and use the printNumI command). For example, the command: </font></font><br> <code>myGLCD.printNumF(-234.3442, 2, 0, 0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to display the number ‚Äì234.34. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number can be specified both in exponential form and in floating point format, while the output will be carried out in floating point format. For example, two commands: </font></font><br> <code>myGLCD.printNumF(-2.343442E2, 2, 0, 0);</code> <br> <code>myGLCD.printNumF(-234.3442, 2, 0, 0);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display the same value ‚Äì234.34. The </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optional divider parameter allows you to redefine the character that plays the role of a decimal point (the default is '.'). For example, the command:</font></font><br> <code>myGLCD.printNumF(-234.3442, 2, 0, 0, ',');</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to replace the decimal point symbol with a comma. In this case, of course, you must still enter numbers in the program using a dot. Replacing only affects the output. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The optional parameters length and filler work similarly to the printNumF command, allowing you to control the minimum number of characters when displaying a number. The length parameter takes into account all familiarities occupied by the displayed number, including the sign, integer part, decimal point and fractional part. For example, the command: </font></font><br> <code>myGLCD.printNumF(-234.3442, 2, 0, 0, '.', 10, '0');</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">displays the number ‚Äì000234.34 (the initial number, supplemented by three insignificant zeros so that the total number of familiarity is 10).</font></font><br>  ATTENTION!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using the optional parameter length, the divider parameter must be specified, otherwise the system will try to interpret the length value as the character code of the separator, which can lead to unpredictable results. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to a group of commands that allow you to display graphic primitives on the display - points, lines, rectangles and circles. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawPixel - displays a point. The color of the point is determined by the current color value set by the setColor () command.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The coordinates X and Y are passed as parameters.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters can be given by numbers, variables, results of functions or expressions. Parameters can be a real number, but the fractional part will be discarded. You must also make sure that the coordinates of the point do not go beyond the display, otherwise the point may not be where you expect to see it;) You can use the getDisplayXsize () and getDisplayYsize () functions discussed earlier to control the display outside the display. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the drawPixel command ‚Äî the following construction displays a sinusoid constructed from individual points: </font></font><br> <code>for (int x=0; x&lt;48; x++) {</code> <br> <code>int y=(sin(x)*10)+100;</code> <br> <code>myGLCD.drawPixel(x*10,320-y);</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following group of commands require as parameters the coordinates of two points that determine the size of the figure being drawn.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawLine - displays the line given by the coordinates of the start and end points.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The line drawing direction depends on the location of the start and end points. For example, the line: </font></font><br> <code>myGLCD.drawLine(10,20,100,200);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draws the line between the points with coordinates X = 10, Y = 20 for the first point and X = 100, Y = 200 for the second one with the current color. Line: </font></font><br> <code>myGLCD.drawLine(100,200,10,20);</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draws exactly the same line between the same points, but the direction of drawing will be opposite. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawRect - displays a rectangle defined by the coordinates of two opposite corners.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coordinates are set the same as for the drawLine command. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawRoundRect - displays a rectangle with rounded corners, given by the coordinates of two opposite corners.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The minimum size of the sides of the rectangle is limited to 5 pixels. When specifying the sides of a smaller size, the rectangle cannot be displayed. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fillRect - displays a filled rectangle defined by the coordinates of two opposite corners.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The rectangle is drawn and filled with the current color. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fillRoundRect ‚Äî displays a filled rectangle with rounded corners, given by the coordinates of two</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opposite corners. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command functions the same as the drawRoundRect command. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following two commands are designed to draw circles and circles and require three parameters: the X and Y coordinates of the center of the circle (or circle) and radius. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawCircle - displays a circle defined by the coordinates of the center and radius.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The radius of the circle should not take negative values, since in this case it will be displayed incorrectly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following command displays a circle with a radius of 50 pixels and a center at a point with coordinates X = 100 and Y = 120: </font></font><br> <code>drawCircle(100,120,50);</code> <br> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fillCircle - displays a circle filled with the current color, defined by the coordinates of the center and radius.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At negative radius values ‚Äã‚Äãthe circle is not displayed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we looked at drawing commands for graphic primitives. By the way, for the UTFT library there is the addition UTFT_Geometry, which allows you to display triangles (contour and filled), arcs of circles and a sector of circles. We will look at the work with this supplement in one of the following articles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now there are quite a few: two commands that allow you to display a specially prepared bitmap image: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawBitmap - displays a specially prepared bitmap graphic image.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The parameters are the coordinates of the upper left corner of the image, its dimensions and the name of the array in which the encoded image is stored. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The optional scale parameter allows you to control the scaling of the image when displayed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The image for this command is prepared using the special utility ImageConverter565.exe, which comes with the library and is located in the Tools folder. And here you can use the online image conversion service:</font></font><br> <a href="http://www.henningkarlsen.com/electronics/t_imageconverter565.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.henningkarlsen.com/electronics/t_imageconverter565.php</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Converter can work with jpg, png and gif file formats. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example, consider the task of displaying a bitmap image and a text message on its background. Of course, a background image of 480x320 pixels will take up inadmissibly a lot of space in the controller's memory, so we use the image reduced by 2 times (240x160 pixels) and use scaling.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To prepare the image, you must run the ImageConverter565.exe file, and open the file with your image in it. Next, we will set the flag ‚ÄúReduce size to‚Äù and set the required image size (240x160). In the ‚ÄúSave As‚Äù switch, select ‚Äú.c‚Äù, and in the ‚ÄúTarget Board‚Äù switch, select ‚ÄúchipKit / Arduino Due‚Äù. In the ‚ÄúArray Name‚Äù field, set the name of the image and click ‚ÄúSave‚Äù.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of the converter operation, we will receive a file with the .c extension, in which information about the image and the encoded image will be stored. This file must be placed in the folder of your project and declare an array in the program using the extern specifier in the same way as we did for fonts. Only in square brackets it is necessary to indicate the size of the array in hexadecimal format (this value is in the first element of the array, it can be viewed by opening the file obtained as a result of the conversion in any text editor). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to close and reopen the program file after copying and connecting the array. At that, the file of the array will open on the adjacent tab next to the program text. The text of our program will look like this:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; extern unsigned short background[0x9600]; void setup() { myGLCD.InitLCD(); myGLCD.setColor(0,255,0); myGLCD.setFont(BigFont); myGLCD.setBackColor(VGA_TRANSPARENT); } void loop() { myGLCD.drawBitmap (0,0, 240, 160, background,2); myGLCD.print("Hello, World!", CENTER,50); while(1); }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we set the output to the upper left corner of the display of the image placed in the array named 240 240 pixels in size, but since we used the scale parameter equal to two, the picture will be stretched across the entire display. Next, on top of the image using the ‚ÄúVGA_TRANSPARENT‚Äù parameter, which ensures the ‚Äútransparency‚Äù of the background during printing, we display a text message. Pretty wasteful - about 100kb just one image, but beautiful;)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another form of invoking this command with additional parameters is possible, allowing you to rotate the image at a given angle. </font><font style="vertical-align: inherit;">Parameters in this case should be three: deg - angle of rotation of the image rox - X coordinate of the center of rotation, roy - Y-coordinate of the center of rotation. </font><font style="vertical-align: inherit;">The angle of rotation is set in degrees (from 0 to 359), and the coordinates of the center of rotation rox and roy are measured from the upper left corner of the picture.</font></font> Consider an example.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the image, we use the info.c file that comes with the library (it is located in the / examples / Arduino (ARM) / UTFT_Bitmap root folder of the library subfolder). </font><font style="vertical-align: inherit;">The size of the image is 32x32 pixels, the volume of the array is 0x400. </font><font style="vertical-align: inherit;">The following program will display a picture rotating around its axis:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UTFT.h&gt; UTFT myGLCD(CTE32HR,25,26,27,28); extern uint8_t BigFont[]; extern unsigned short info[0x400]; void setup() { myGLCD.InitLCD(); myGLCD.fillScr(VGA_WHITE); } void loop() { for (int R=0; R&lt;360; R+=10){ myGLCD.drawBitmap (100,100, 32, 32, info,R,16,16); } }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, simultaneous rotation and scaling are not possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, a few more commands: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lcdOff - disables the display. It has no parameters. </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lcdOn - turns on the display. It has no parameters.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After executing the lcdOff () command, the display turns off and does not respond to any commands until the lcdOn () command is executed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the developer‚Äôs statement, these two commands are implemented only for displays with a PCF8833 controller, so they are simply ignored on our display. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setContrast - sets display contrast. Parameter - the amount of contrast.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a parameter, a conditional value is defined that defines the display contrast: from 0 (minimum contrast) to 64 (maximum contrast).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This command is also implemented only for displays with a PCF8833 controller, so no contrast changes will occur on our display and the command will be ignored. </font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have learned to use all the commands of the UTFT base library. </font><font style="vertical-align: inherit;">In the following articles we will talk about additions to this library, allowing to expand its capabilities. </font><font style="vertical-align: inherit;">The next step is drawing triangles, arcs and sectors, working with a touch screen, as well as working with text and graphic buttons on the display, controlled by a touch screen. </font><font style="vertical-align: inherit;">In the future, we plan to consider the built-in capabilities of our display - working with the internal memory of the display module, with its fonts and icons sewn into its ROM.</font></font></div><p>Source: <a href="https://habr.com/ru/post/196600/">https://habr.com/ru/post/196600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196588/index.html">We collect a little bit from Google and Redmine services on our server</a></li>
<li><a href="../196590/index.html">5 reasons why Phonebloks probably won't work</a></li>
<li><a href="../196594/index.html">Tizen Native programming. Writing "Hello Habrahabr" for Tizen OS</a></li>
<li><a href="../196596/index.html">Meet RyuJIT: New JIT Compiler for .NET</a></li>
<li><a href="../196598/index.html">Photo surveillance or timelapse video on Raspberry Pi</a></li>
<li><a href="../196604/index.html">Regenix: New non-standard MVC framework for PHP</a></li>
<li><a href="../196606/index.html">Selection of banknotes in ATMs</a></li>
<li><a href="../196610/index.html">Microsoft released a set of updates, October 2013</a></li>
<li><a href="../196612/index.html">Another console radio</a></li>
<li><a href="../196614/index.html">Final of the Russian Code Cup Programming Championship: how it was</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>