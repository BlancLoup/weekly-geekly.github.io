<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 2.1 - Colors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the next lesson from learnopengl.com. I recently discovered Russian OpenGL tutorials from the OGLDev website , but some of them require...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 2.1 - Colors</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  Translation of the next lesson from learnopengl.com.  I recently discovered Russian <a href="https://triplepointfive.github.io/ogltutor/">OpenGL tutorials from the OGLDev website</a> , but some of them require version 4 of opengl, and the code samples are too dependent on previous lessons and object-oriented.  Therefore, to the attention of all interested beginners with old iron with an old iron, I propose a short article on color with which the second part of the training course from Joey de Vries begins: <br><a name="habracut"></a><br><a name="01_colors"></a></p><h2>  Colors </h2><br><p>  In the previous lessons there were brief references to how to work with color in OpenGL, but so far we have only touched the surface of this question.  Now we will discuss in detail what color is, and begin building the stage, which we will use in the next lessons on lighting. </p><br><div class="spoiler">  <b class="spoiler_title">Menu</b> <div class="spoiler_text"><p>  Part 1 </p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2 </p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Lighting maps</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple lighting</a> </li></ol><br><br><p>  Part 3 </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp and Mesh class</a> </li></ol><br></div></div><br><p>  In the real world, each object has its own color, which can take on virtually any value.  In the digital world, we need to display the (infinite) colors of reality through (limited range) digital values, so not all existing colors can be reproduced in digital form.  However, we can display so many colors that you probably won't notice the difference anyway.  Numerically, colors represent a combination of three components: red, green, and blue, usually abbreviated as RGB (Red Green Blue).  Using various combinations of just these three values, we can convey almost any existing color.  For example, to get a coral color, we define the color vector as follows: </p><br><pre><code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coral</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.31f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  The colors we see in real life are not the colors of the objects themselves, but the colors of the light reflected by them;  those.  we perceive colors that remain unabsorbed (discarded) by an object.  For example, the light of the sun is perceived as white light, which consists of all the colors of the spectrum (you can see it in the picture).  Thus, if we shine a white light on a blue toy, it will absorb all the components of white light in color except blue.  Since the toy does not absorb the blue color, it will be reflected, and this reflected light, acting on our organs of vision, gives the impression that the toy is colored blue.  The following figure illustrates this phenomenon by the example of a coral-colored object reflecting the original colors with different intensities: </p><br><div style="text-align:center;"><img alt="Reflection and absorption of colors" src="https://habrastorage.org/web/438/1fe/fad/4381fefad1814b46a42434de19839925.png"></div><br><p>  You can see that white sunlight is actually a collection of all visible colors, and the object absorbs the largest part of this range.  It reflects only those colors, the combination of which is perceived by us as the color of the object (in this case, coral color). </p><br><p>  These rules of light reflection are directly applied in computer graphics.  When we create a light source in OpenGL, we specify its color.  In the previous paragraph, we talked about white sunlight, so let's set our color to our light source too.  If we then multiply the color of the light source by the color of the object, then the resulting value will be the reflected color of the object (and, therefore, the color in which we perceive the object).  Let us return to our toy (this time of coral color) and see how to calculate its color, perceived by an observer, by graphic means.  To get the color we need, we produce componentwise multiplication of two color vectors: </p><br><pre> <code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toyColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.31f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::vec3 result = lightColor * toyColor; <span class="hljs-comment"><span class="hljs-comment">// = (1.0f, 0.5f, 0.31f);</span></span></code> </pre> <br><p>  The toy <i>absorbs</i> most of the white light, and the remaining amount of red, green and blue radiation, it reflects the color of its surface.  This is a demonstration of how colors behave in the real world.  Thus, we can set the color of an object by a vector, characterizing the <i>magnitude of the reflection of the color components</i> coming from the light source.  What would happen if we used green light to illuminate? </p><br><pre> <code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toyColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.31f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::vec3 result = lightColor * toyColor; <span class="hljs-comment"><span class="hljs-comment">// = (0.0f, 0.5f, 0.0f);</span></span></code> </pre> <br><p>  As we see, there is no red and blue component in the light source, so the toy will not absorb and / or reflect them.  One half of the total amount of green light toy absorbs, and the second reflects.  Therefore, the color of the toy that we will see will be dark green.  Thus, if we use a green light source, only the green components will be reflected and perceived;  no red and blue hues will be visible.  As a result, the object of coral color suddenly becomes dark greenish.  Let's do another experiment with a dark olive green: </p><br><pre> <code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.33f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.42f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.18f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toyColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.31f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; glm::vec3 result = lightColor * toyColor; <span class="hljs-comment"><span class="hljs-comment">// = (0.33f, 0.21f, 0.06f);</span></span></code> </pre> <br><p>  Here is an example of obtaining a strange color object due to the use of multi-colored lighting.  It turns out to be an original colorist is not at all difficult. </p><br><p>  But stop talking about flowers, let's get down to creating a scene in which we can practice. </p><br><a name="02_lighting_scene"></a><h2>  Illuminated scene </h2><br><p>  In the following lessons, working in depth with colors, we will create interesting visual effects that simulate lighting in the real world.  From now on, to simulate the lighting, we will use at least one light source, and we will depict it as a visible object of the scene. </p><br><p>  The first thing we need is an illuminated object, in the capacity of which we will take a cube already familiar to us from previous lessons.  We will also need some bright object to show where the light source is in the 3D scene.  For simplicity, we will also present the light source as a cube (after all, we already have the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/cube_vertices">coordinates of the vertices</a> , right?). </p><br><p>  Since the creation of a VBO (vertex buffer object), the installation of pointers of vertex attributes and the execution of all other tricky operations for you now should not be difficult, we will not stop there.  If these topics still cause you difficulties, then before proceeding, I recommend that you familiarize yourself with previous lessons and, if possible, perform the suggested exercises. </p><br><p>  So let's start with a vertex shader to draw a container.  The coordinates of the container's vertices remain old (although this time we will not need the texture coordinates), so there will be nothing new in the code.  We use the ‚Äútrimmed‚Äù version of the vertex shader from the latest lessons: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 model; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 view; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 projection; void main() { gl_Position = projection * view * model * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); }</code> </pre> <br><p>  Make sure that you update the vertex data and attribute pointers according to the new vertex shader (however, if you want, you can leave the texture coordinates buffer and the active pointer to these attributes in the VAO; we just won't use them yet, but and to start everything ‚Äúfrom scratch‚Äù is also not such a bad idea). </p><br><p>  Since we are going to add a cube lamp to the scene, we need to create a new VAO for it.  We could portray the lamp with the same VAO, transforming the model matrix, but in future lessons we will quite often change the vertex and attribute data of the container object and at the same time do not want the changes to affect the lamp object (we are only interested in the coordinates of the lamp vertices ), so let's create another VAO: </p><br><pre> <code class="cpp hljs">GLuint lightVAO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;lightVAO); glBindVertexArray(lightVAO); <span class="hljs-comment"><span class="hljs-comment">//   VBO -     ,         VAO glBindBuffer(GL_ARRAY_BUFFER, VBO); //   (     ) glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); glBindVertexArray(0);</span></span></code> </pre> <br><p>  This code is relatively simple.  Now that we have created both the container and the lamp-cube, one more thing remains to be done - the fragment shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 objectColor; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 lightColor; void main() { <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vec4(lightColor * objectColor, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); }</code> </pre> <br><p>  Fragment shader through uniform variables receives two parameters: the color of the object and the color of the light source.  As we discussed at the beginning of this lesson, to obtain a perceived (i.e. reflected by the object) color, we multiply the vector of the light source by the vector of the color of the object.  Again, the shader source should not raise questions. <br><br>  Let's give the object the coral color from the previous section: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     uniform-      glUseProgram GLint objectColorLoc = glGetUniformLocation(lightingShader.Program, "objectColor"); GLint lightColorLoc = glGetUniformLocation(lightingShader.Program, "lightColor"); glUniform3f(objectColorLoc, 1.0f, 0.5f, 0.31f); glUniform3f(lightColorLoc, 1.0f, 1.0f, 1.0f); //     ()</span></span></code> </pre> <br><p>  It remains to be noted that if we start editing the vertex and fragment shaders, the cube of the lamp will also change, and this is not at all what we want.  In the following lessons unnecessary inconveniences will appear if the calculation of illumination will influence the color of the lamp, so we prefer to separate the color of the lamp from everything else.  Let us make the lamp a constant bright color that is not affected by other color changes (from this the cube of the lamp will look as if it really is a source of light). </p><br><p>  To achieve this, we will create a second set of shaders, which we will use only to draw the lamp, and thus protect ourselves from any changes in the shaders that calculate the lighting of the scene.  The vertex shader will remain unchanged, so you can simply copy its source code to the vertex shader of the lamp.  A fragmentary shader will provide the lamp brightness by specifying constant white color of the fragments: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; void main() { <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); <span class="hljs-comment"><span class="hljs-comment">//   4    1.0f }</span></span></code> </pre> <br><p>  When we draw our cube container (or maybe a lot of containers), we will use the lighting shader created in this tutorial, and when we want to draw a lamp, we will apply lamp shaders.  In the other lessons, we will gradually improve the lighting shaders, and eventually we will achieve more realistic results. </p><br><p>  The main purpose of the cube of the lamp is to show the location of the light source.  We set the position of the light source somewhere in the scene, but this is only the coordinate of a point that has no visual representation.  To really show the lamp, we draw a cube at the location of the light source.  The lamp is drawn using the lamp shader, and this ensures that the cube of the lamp will always remain white, regardless of the scene lighting conditions. </p><br><p>  So, let's declare the global variable <b>vec3</b> , which will represent the position of the light source in the coordinates of world space: </p><br><pre> <code class="cpp hljs">glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.2f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Now, before drawing the lamp, move it to the position of the light source, and slightly reduce the size of the cube to make sure that the lamp does not dominate too much in the scene: </p><br><pre> <code class="cpp hljs">model = glm::mat4(); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>));</code> </pre> <br><p>  The resulting lamp drawing code should look something like this: </p><br><pre> <code class="cpp hljs">lampShader.Use(); <span class="hljs-comment"><span class="hljs-comment">//  uniform-  ,    ... //    glBindVertexArray(lightVAO); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0);</span></span></code> </pre> <br><p>  Inserting all the above code snippets into the appropriate places will give us a properly configured OpenGL scene for further experiments with lighting.  With a successful compilation, everything should look like this: </p><br><div style="text-align:center;"><img alt="Preliminary scene" src="https://habrastorage.org/web/1f2/16f/1c2/1f216f1c2fe74b0ba675db505096f81a.png"></div><br><p>  Yes, there is not much to look at so far, but I promise that in the next lessons this scene will become much more attractive. </p><br><p>  If it is difficult for you to understand how all the code fragments are combined with each other and combined into a ready-made program, then carefully study the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/colors_scene">source code</a> and carefully follow the entire sequence of actions performed in it. </p><br><p>  Now that we have enough knowledge about color and there is a basic scene for a more intimate acquaintance with the light, we can move on to the next lesson, in which real magic will begin. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329592/">https://habr.com/ru/post/329592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329576/index.html">Modeling designs. Requirements for the modeler</a></li>
<li><a href="../329578/index.html">Three cycles in the Lorenz attractor</a></li>
<li><a href="../329580/index.html">What is waiting for us in Swift 4?</a></li>
<li><a href="../329582/index.html">Creating a web application on Go in 2017</a></li>
<li><a href="../329584/index.html">Creating a web application on Go in 2017. Part 2</a></li>
<li><a href="../329594/index.html">Is there too much text in your game?</a></li>
<li><a href="../329596/index.html">A bit of reverse-engineering USB flash on the SK6211 controller</a></li>
<li><a href="../329598/index.html">Online course "Functional Security of Computer Systems"</a></li>
<li><a href="../329600/index.html">How to use implicits in Scala and keep sanity</a></li>
<li><a href="../329602/index.html">Completion of the 11th All-Russian Conference of IT & Security Forum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>