<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python cryptography: encrypting information and creating digital signatures with the PyCrypto package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Long suffered from PyCrypto , this article as a result turned out and full implementation of the following protocol : 

 Sending step: 

 1. Alice sig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python cryptography: encrypting information and creating digital signatures with the PyCrypto package</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/972/ff9/1f1/972ff91f120740f4b86aafc1867c35c3.jpg"><br><br>  Long suffered from <a href="https://www.dlitz.net/software/pycrypto/api/current/">PyCrypto</a> , this article as a result turned out and full implementation of the following <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB">protocol</a> : <br><br>  Sending step: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Alice signs the message with her <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">digital signature</a> and encrypts it <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D1%258E%25D1%2587_(%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F)">with the</a> Bob <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D1%258E%25D1%2587_(%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F)">public key</a> ( <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2581_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D0%25BC_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25BE%25D0%25BC">asymmetric algorithm</a> ). <br>  2. Alice generates a random session key and encrypts the message with this key (using a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D1%258B">symmetric algorithm</a> ). <br>  3. The session key is encrypted with Bob‚Äôs public key (asymmetric algorithm). <br>  Alice sends Bob an encrypted message, a signature, and an encrypted session key. <br><br>  Reception stage: <br><br>  Bob receives Alice's encrypted message, a signature, and an encrypted session key. <br>  4. Bob decrypts the session key with his private key. <br>  5. Using the session key thus received, Bob decrypts Alice's encrypted message. <br>  6. Bob decrypts and verifies Alice's signature. <br><a name="habracut"></a><br>  The above protocol is a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D0%25B1%25D1%2580%25D0%25B8%25D0%25B4%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">hybrid encryption system</a> , which works as follows.  For a symmetric <a href="https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm (or any other), a random session key is generated. <br><br>  Such a key usually has a size from 128 to 512 bits (depending on the algorithm).  A symmetric algorithm is then used to encrypt the message.  In the case of <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580">block encryption,</a> it <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580">is</a> necessary to use <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">encryption mode</a> (for example, <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">CBC</a> ), which will allow encrypting a message with a length exceeding the block length.  As for the random key itself, it must be encrypted using the public key of the recipient of the message, and it is at this stage that the <a href="https://ru.wikipedia.org/wiki/RSA">RSA</a> public key <a href="https://ru.wikipedia.org/wiki/RSA">is used</a> . <br><br>  Since the session key is short, its encryption takes a little time.  Encrypting a set of messages using an asymmetric algorithm is a computationally more complex task, so symmetric encryption is preferable here.  Then it is enough to send a message encrypted with a symmetric algorithm, as well as the corresponding key in an encrypted form.  The recipient first decrypts the key using his secret key, and then receives the entire message with the received key. <br><br>  Start by generating a pair of keys for Alice and Bob. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_OAEP <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.PublicKey <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RSA # key generation Alisa privatekey = RSA.generate(<span class="hljs-number"><span class="hljs-number">2048</span></span>) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\alisaprivatekey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(privatekey.exportKey(<span class="hljs-string"><span class="hljs-string">'PEM'</span></span>))); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() publickey = privatekey.publickey() f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\alisapublickey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(publickey.exportKey(<span class="hljs-string"><span class="hljs-string">'PEM'</span></span>))); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() # key generation Bob privatekey = RSA.generate(<span class="hljs-number"><span class="hljs-number">2048</span></span>) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobprivatekey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(privatekey.exportKey(<span class="hljs-string"><span class="hljs-string">'PEM'</span></span>))); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() publickey = privatekey.publickey() f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobpublickey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(publickey.exportKey(<span class="hljs-string"><span class="hljs-string">'PEM'</span></span>))); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>()</code> </pre> <br><br>  At the moment, an RSA-based encryption system is considered secure, starting with a key size of 2048 bits. <br><br>  In the RSA system, you can create messages that will be both encrypted and digitally signed.  To do this, the author must first add his digital signature to the message, and then encrypt the resulting pair (consisting of the message itself and the signature to it) using the public key belonging to the recipient.  The recipient decrypts the received message with his private key and verifies the author's signature with his public key. <br><br>  Using a one-way <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">cryptographic hash function</a> allows you to optimize the above digital signature algorithm.  Not the message itself is encrypted, but the hash value taken from the message.  This method provides the following benefits: <br><br>  1. Reducing computational complexity.  As a rule, the document is much larger than its hash. <br>  2. Increased cryptographic strength.  A cryptanalyst cannot, using the public key, pick up a signature for a message, but only for its hash. <br>  3. Ensuring compatibility.  Most algorithms operate on strings of data bits, but some use different representations.  The hash function can be used to convert arbitrary input text into a suitable format. <br><br>  Hash functions are functions, mathematical or other, that receive a variable length string (called a prototype) as input and convert it to a fixed, usually smaller, length string (called a hash value).  The meaning of the hash function is to obtain the characteristic feature of the pre-image - the value by which various pre-images are analyzed when solving the inverse problem.  A unidirectional hash function is a hash function that works only in one direction: it is easy to calculate the hash value by a prototype, but it is difficult to create a prototype whose hash value is equal to a given value.  The hash function is open, the secret of its calculation does not exist.  The security of a unidirectional hash function lies precisely in its unidirectionality. <br><br>  We proceed to writing the first paragraph of the protocol: <br><br>  1. Alice signs the message with her digital signature and encrypts it with the Bob public key (RSA asymmetric algorithm). <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Signature <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_v1_5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Hash <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SHA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.PublicKey <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RSA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_OAEP # creation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> signature f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) plaintext = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() privatekey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\alisaprivatekey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) myhash = SHA.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(plaintext) signature = PKCS1_v1_5.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(privatekey) signature = signature.sign(myhash) # signature encrypt publickey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobpublickey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) cipherrsa = PKCS1_OAEP.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(publickey) sig = cipherrsa.encrypt(signature[:<span class="hljs-number"><span class="hljs-number">128</span></span>]) sig = sig + cipherrsa.encrypt(signature[<span class="hljs-number"><span class="hljs-number">128</span></span>:]) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\signature.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(sig)); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>()</code> </pre><br><br>  The following listing code for the following two points of the protocol: <br><br>  2. Alice generates a random session key and encrypts the message with this key (using the AES symmetric algorithm). <br>  3. The session key is encrypted with Bob‚Äôs public key (asymmetric RSA algorithm). <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AES <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_OAEP <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.PublicKey <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RSA # creation <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> key sessionkey = Random.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) # <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> # encryption AES <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the message f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) plaintext = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() iv = Random.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>) # <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> obj = AES.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(sessionkey, AES.MODE_CFB, iv) ciphertext = iv + obj.encrypt(plaintext) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(ciphertext)); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() # encryption RSA <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> key publickey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobpublickey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) cipherrsa = PKCS1_OAEP.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(publickey) sessionkey = cipherrsa.encrypt(sessionkey) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\sessionkey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(sessionkey)); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>()</code> </pre><br><br>  The <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D0%25B8_%25D0%25BF%25D0%25BE_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583">CFB</a> encryption <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D0%25B8_%25D0%25BF%25D0%25BE_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583">mode</a> requires <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">an initialization vector (IV)</a> (variable iv). <br><br>  In cryptography, the initialization vector (IV) is a number, as a rule it should be random or pseudo-random.  Accident is crucial for achieving semantic security, which, when reusing a scheme with the same key, will not allow an attacker to infer relationships between segments of encrypted messages.  The initialization vector is not encrypted and is saved before the encrypted message. <br><br>  Next, Alice sends Bob an encrypted message, a signature, and an encrypted session key. <br><br>  Bob receives Alice's encrypted message, a signature, and an encrypted session key. <br><br>  4. Bob decrypts the session key with his private key. <br>  5. Using the session key thus received, Bob decrypts Alice's encrypted message. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AES <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_OAEP <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.PublicKey <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RSA # decryption <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> key privatekey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobprivatekey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) cipherrsa = PKCS1_OAEP.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(privatekey) f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\sessionkey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) sessionkey = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() sessionkey = cipherrsa.decrypt(sessionkey) # decryption message f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) ciphertext = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() iv = ciphertext[:<span class="hljs-number"><span class="hljs-number">16</span></span>] obj = AES.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(sessionkey, AES.MODE_CFB, iv) plaintext = obj.decrypt(ciphertext) plaintext = plaintext[<span class="hljs-number"><span class="hljs-number">16</span></span>:] f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>) f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(bytes(plaintext)); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>()</code> </pre><br><br>  Final stage: <br><br>  6. Bob decrypts and verifies Alice's signature. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Signature <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_v1_5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Hash <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SHA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.PublicKey <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RSA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Crypto.Cipher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PKCS1_OAEP # decryption signature f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\signature.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) signature = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() privatekey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\bobprivatekey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) cipherrsa = PKCS1_OAEP.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(privatekey) sig = cipherrsa.decrypt(signature[:<span class="hljs-number"><span class="hljs-number">256</span></span>]) sig = sig + cipherrsa.decrypt(signature[<span class="hljs-number"><span class="hljs-number">256</span></span>:]) # signature verification f = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\plaintext.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) plaintext = f.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(); f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() publickey = RSA.importKey(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'c:\cipher\\alisapublickey.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>()) myhash = SHA.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(plaintext) signature = PKCS1_v1_5.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(publickey) test = signature.verify(myhash, sig)</code> </pre><br><br>  RSA security is based on the complexity of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">problem of factoring the</a> product of two large primes.  <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D1%2586%25D0%25B5%25D0%25BB%25D1%258B%25D1%2585_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">Factoring integers</a> for large numbers is a task of great complexity.  There is no known way to solve this problem quickly.  Factorization is a candidate for <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258F%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">one-way functions</a> , which are relatively easy to calculate, but inverted with great difficulty.  That is, knowing x is easy to calculate f (x), but from the known f (x) it is not easy to calculate x.  Here, "not easy" means that it may take millions of years to calculate x over f (x), even if all the computers in the world will fight on this problem. <br><br>  Literature: <br>  Bruce Schneier - Applied Cryptography </div><p>Source: <a href="https://habr.com/ru/post/265309/">https://habr.com/ru/post/265309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265295/index.html">PostgreSQL support in Meteor</a></li>
<li><a href="../265301/index.html">Single-layer perceptron for beginners</a></li>
<li><a href="../265303/index.html">Work with a SQLite database using SQLitePCL wrapper</a></li>
<li><a href="../265305/index.html">Wake on Lan Telegram bot</a></li>
<li><a href="../265307/index.html">Writing a Labyrinth on XNA 4.0 C #</a></li>
<li><a href="../265311/index.html">Safe as in a safe</a></li>
<li><a href="../265313/index.html">How to configure the iOS device and RAD Studio XE8 (Delphi, C ++ Builder)</a></li>
<li><a href="../265315/index.html">Who is a designer?</a></li>
<li><a href="../265317/index.html">HP and Microsoft - a symbiosis of progress</a></li>
<li><a href="../265319/index.html">Requests in CoreData with aggregate functions and grouping in one line</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>