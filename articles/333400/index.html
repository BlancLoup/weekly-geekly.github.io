<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We make a website for virtual reality. We build the monitor into the monitor and reflect on the future</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that the concept of "virtual reality" is not the first year flashes before my eyes, it still remains a mystery to most people, and th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We make a website for virtual reality. We build the monitor into the monitor and reflect on the future</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/9a2/15f/7cf/9a215f7cf3de4368b573ba71ed13e4e0.png" alt="image"><br><br>  Despite the fact that the concept of "virtual reality" is not the first year flashes before my eyes, it still remains a mystery to most people, and the prices of accessories associated with this entertainment can go to infinity.  But there is a budget option.  The average person who is interested in new technologies can afford a smartphone with a gyroscope, built-in Google Cardboard or any analogue of this simple device and a simple joystick with a pair of buttons.  In our time, this option of exploring this technology is the most common.  But, like many other technological innovations, like quadcopters, an interesting toy quickly turns into a dusting one on the shelf.  Practical application is very limited.  Adults who bought virtual reality glasses, the first days of playing with toys, watching various videos <s>with beautiful young ladies</s> , rejoicing like children.  It's great.  New impressions are always helpful.  But quickly comes the understanding that the graphics in toys is at the level of the late 90s, the video is boring, and there is no other practical use of glasses for these people.  For individual developers, designers and experimenters, glasses become a tool for work, but the average consumer puts them on the shelf and throws them.  It would be interesting to apply this technology on the Internet on ordinary sites.  In this article we will try using Javascript to adapt the layout we are used to under the new display conditions.  There is not much information on the topic yet, the article is an experiment, so all interested people, as well as those who have had similar practical experience, are invited to join the discussion in advance and share their thoughts and experiences in the comments. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Introduction </h2><br>  Over time, new I / O devices appear in our world.  The monitor, mechanical keyboard and mouse with a ball were supplemented with touchpads; .  We stopped saying ‚Äúdo not poke a finger at the monitor‚Äù and began to think about the adaptation of interfaces to new realities.  The buttons are getting bigger so that the finger does not miss, the interactive elements support svaypas and other movements with different numbers of fingers.  With the advent of virtual reality glasses (a phone with a pair of lenses will also be considered as such), we should think about how to adapt what we have on the Internet at the moment to this turn of events.  Yes, it will take several more years (maybe several decades) until such glasses are in every home, but if we don‚Äôt start thinking now, we‚Äôll just postpone even more. <br><br><h2>  We get something, but we also lose something </h2><br>  VR glasses give us the opportunity to have information in three dimensions (or, at least, this effect is created), unlike a regular monitor.  We have the opportunity to control what is happening by turning the head, which is quite interesting.  Some joysticks, if you can call them that, allow you to control what we see with the help of hand movement in space.  But at the same time we lose the ability to use the keyboard - only if you really know how to type blindly, you can use it.  Moreover, for those who type a lot, the absence of the usual tactile sensation from it and the absence of a knock on the keys can be a serious challenge.  A similar effect, although not to such an extent, occurs when switching from an old keyboard from the beginning of the 2000s to a new one, with a small key travel and almost silent.  Losing the usual mouse - it is extremely problematic to imagine using a two-dimensional controller in three-dimensional space. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9b/4d6/6c9/d9b4d66c9e340914faf4ccffc1880e64.jpg" alt="image"><br><br>  It turns out that we have a completely new set of input-output devices with a new behavior for us.  We are not just evolving one of them, but replacing the entire stack.  In such a situation, questions are inevitable about how well all these devices are adapted for solving already existing problems. <br><br><h2>  Content consumption.  Still a plane? </h2><br>  Since we started talking about the application of technology from the point of view of the consumer, not the developer, we will continue to look from the same side.  The consumption of information over the past decades has not changed significantly.  Content can be presented in the form of text, sound, graphic image or video.  Mechanical buttons are replaced by virtual ones, page turning is replaced by clicking on the links, but the content itself does not change much.  Smells and tactile sensations from films or games to a wide range of consumers are not yet available. <br><br>  With audio, everything is more or less clear.  Headphones or several speakers can give a certain sense of volume, although two headphones do not allow you to "move" the sound source forward or backward.  We can listen to music as before, and most of the interfaces work silently, so the question of sound will worry us last.  Players for video in 3d are already in different versions.  It can be considered that the issue of video consumption "full screen" is more or less resolved. <br><br>  But with the text all the more interesting.  First of all, once in the virtual space, the thought arises of moving away from the idea of ‚Äã‚Äãa flat monitor and positioning the text on a curved surface.  Ball?  And the user is in the center.  Why not.  But it is better to keep the vertical axes on the bottom, or even pull out from such an interface.  Previously, we have not thought about this?  And now it is necessary.  Some toys make warnings for epileptics, and now they will probably be for people with problems with the vestibular apparatus.  A cylindrical surface seems like a good choice.  Equal ‚Äúdistance‚Äù to text at all points should reduce eye strain (compared to a huge monitor), efficient use of space ... <br><br><img src="https://habrastorage.org/web/adf/6e0/780/adf6e078092f43f6affb5e2651d661d7.jpg" alt="image"><br><br>  But reality beats very painfully.  Because of the distortions, it is very difficult to read such text, and this is aggravated by the poor quality of the displays on most smartphones - the letters on the edges of the scope become a soap-pixel something.  And constantly turning your head on every line of text is not an option.  It seems that in the near future we will be limited to planes in 3d.  We will have to lean towards the prism - we can embed three vertical monitors into our space and at the same time more or less preserve the readability of the text.  Moreover, it is desirable to place them in such a way that when you turn your head to the ‚Äúmonitor‚Äù, your gaze falls exactly into its center and the line of sight is perpendicular to the plane of the monitor.  Thus, the distortion will be minimal.  If you tried to sit at an angle to the monitor, then you will understand what I mean.  Why three?  One could make a couple more monitors behind his back, but if one assumes a long work, then one would need to have the health of an astronaut in order to rotate on a chair the whole day.  Some people and without glasses from a couple of turns will be enough for a rather unpleasant attack of dizziness and blurred eyes.  So it makes sense to limit the viewing angle.  Perhaps it is worth making experiments with a part of the dodecahedron, and not with a prism, but it is still difficult for me to imagine an interface built on pentagons. <br><br><h2>  And what about the input? </h2><br>  Three-dimensional controller - an interesting thing.  But ... Have you ever seen an ordinary artist who draws on an easel?  Formally, he is not engaged in physical labor - the brush weighs a few grams (well, maybe a couple of dozen), but after a full day of drawing his hand just falls off.  And the back is tired, whatever they say.  This is the same problem with 3D controllers.  Hands weakened by many years of lying on the table and typing on the keyboard can not be suspended all day.  So for games it‚Äôs great, for individual stages of 3d modeling, maybe, but for permanent work this kind of controller is not well adapted.  There is an option when the hand lies and presses a few buttons.  But this is already good.  On button controllers, usually more than on a standard mouse (for users of top models from Razer, I remind you that there are two of them + a wheel). <br><br>  With the keyboard - trouble.  You can make a kind of on-screen keyboard, but the printing speed on such a miracle will be below the baseboard.  Perhaps, over time, we will have semitransparent glasses spread so that we have an image at eye level, and we can see the real keyboard from below, but so far we are not talking about a budget version.  Plus - for those devices that are on the market, there is a problem with fatigable eyes - you can only read a translucent text for a long time if there is something more or less monotonous and stationary in the background.  You can see the notification, but read on an ongoing basis - no.  Voice input is also far from perfect.  It seems that in the near future to introduce large amounts of text in virtual reality will not work. <br><br>  At the moment, the version with a smartphone will not allow us to combine glasses and things like <a href="https://webgazer.cs.brown.edu/">WebGazer</a> in order to use the direction of the look as a mouse substitute.  If it is interesting, I will sort out separately the idea of ‚Äã‚Äãbuilding an interface for a web application that can be controlled with just one glance (it is quite likely that this may have practical applications in medicine).  But in the case of glasses, we only have a turn of the head.  The most effective way to use it in our situation seems to be the following: take the center of the field of view, build a beam from the user and use its intersection with the monitor planes in order to create a similarity of a mouse on these planes. <br><br><h2>  Let's try to do something. </h2><br>  Since we make several monitors, we will create some markup for them. <br>  (A link to GitHub with full sources will be at the end of the article).  This is the usual markup, I used buttons and an accordion from one of my projects in full source code. <br><br><pre><code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">'vr-area -left'</span></span>&gt; .... &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">'vr-area -center'</span></span>&gt; .... &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">'vr-area -right'</span></span>&gt; .... &lt;/div&gt;</code> </pre> <br><br>  There are not many options to use the usual HTML + CSS markup in three-dimensional space.  But there are a couple of renderers for Three.js, which immediately attract attention.  One of them, called CSS3DRenderer, allows us to take our markup and render it on a plane.  This is quite suitable for our task.  Second, the CSS3DStereoRenderer, which we will use, does the same, but divides the screen into two parts, creates two images, one for each eye. <br><br>  Initialization of Three.js has already been mentioned in various articles more than once, so we will not dwell heavily on it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, camera = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, renderer = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, controls = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; init(); render(); animate(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ initScene(); initRenderer(); initCamera(); initControls(); initAreas(); initCursor(); initEvents(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ renderer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.CSS3DStereoRenderer(); renderer.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); renderer.domElement.style.position = <span class="hljs-string"><span class="hljs-string">'absolute'</span></span>; renderer.domElement.style.top = <span class="hljs-number"><span class="hljs-number">0</span></span>; renderer.domElement.style.background = <span class="hljs-string"><span class="hljs-string">'#343335'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(renderer.domElement); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth/<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); camera.position.z = <span class="hljs-number"><span class="hljs-number">1000</span></span>; scene.add(camera); }</code> </pre><br><br>  The second component that we will immediately add is the DeviceOrientationController, which will allow the device to be rotated for orientation in 3d space.  The technology of determining the position of the device is experimental, and, to put it mildly, today it works so-so.  All three devices on which it was tested, behaved differently.  This is further aggravated by the fact that in addition to the gyroscope (and, perhaps, instead of it), the browser uses a compass, which behaves very inadequately surrounded by various iron and wires.  We will use this controller in order to preserve the possibility of using a conventional mouse when evaluating the results of an experiment. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initControls</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ controls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeviceOrientationController(camera, renderer.domElement); controls.connect(); controls.addEventListener(<span class="hljs-string"><span class="hljs-string">'userinteractionstart'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ renderer.domElement.style.cursor = <span class="hljs-string"><span class="hljs-string">'move'</span></span>; }); controls.addEventListener(<span class="hljs-string"><span class="hljs-string">'userinteractionend'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ renderer.domElement.style.cursor = <span class="hljs-string"><span class="hljs-string">'default'</span></span>; }); }</code> </pre><br><br>  CSS3DRenderer, as we have said, makes it possible to use the usual markup in our 3d example.  Creating CSS objects is a bit like making plain planes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initAreas</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>; initArea(<span class="hljs-string"><span class="hljs-string">'.vr-area.-left'</span></span>, [-width/<span class="hljs-number"><span class="hljs-number">2</span></span> -width/<span class="hljs-number"><span class="hljs-number">5.64</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,width/<span class="hljs-number"><span class="hljs-number">5.64</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI/<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]); initArea(<span class="hljs-string"><span class="hljs-string">'.vr-area.-center'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]); initArea(<span class="hljs-string"><span class="hljs-string">'.vr-area.-right'</span></span>, [width/<span class="hljs-number"><span class="hljs-number">2</span></span> + width/<span class="hljs-number"><span class="hljs-number">5.64</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,width/<span class="hljs-number"><span class="hljs-number">5.64</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,-<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI/<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initArea</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">contentSelector, position, rotation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(contentSelector), area = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.CSS3DObject(element); area.position.x = position[<span class="hljs-number"><span class="hljs-number">0</span></span>]; area.position.y = position[<span class="hljs-number"><span class="hljs-number">1</span></span>]; area.position.z = position[<span class="hljs-number"><span class="hljs-number">2</span></span>]; area.rotation.x = rotation[<span class="hljs-number"><span class="hljs-number">0</span></span>]; area.rotation.y = rotation[<span class="hljs-number"><span class="hljs-number">1</span></span>]; area.rotation.z = rotation[<span class="hljs-number"><span class="hljs-number">2</span></span>]; scene.add(area); }</code> </pre><br><br>  Then again comes the standard for almost all the Three.js demos functions for animating and changing the browser window. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'resize'</span></span>, onWindowResize); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWindowResize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ camera.aspect = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight ); render(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ controls.update(); render(); requestAnimationFrame(animate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ renderer.render(scene, camera); }</code> </pre><br><br>  But then the interesting begins.  CSS3DStereoRenderer inherently creates two identical tree of elements, which with the help of CSS-transformations are built in the right place.  In other words, there is no magic in this renderer.  And what is there creates a problem.  How can you interact with interactive elements if they are all duplicated?  We can not focus on two elements at the same time, we can not do double: hover, in general a small ambush.  The second problem is the id of elements that can only be in a single copy on the page.  But if id can not be used, then you need to think hard about the interactions. <br><br><img src="https://habrastorage.org/web/582/cc8/7d7/582cc87d7edd4baba083dbdaf3162d74.png" alt="image"><br><br>  The only way to control the appearance of two elements at the same time is to add some CSS classes to them.  We can also imitate click ().  We can click on several elements, it does not lead to strange behavior of the browser.  Thus, we can make the second cursor in the center of the field of view (not the entire screen, but in the centers of its halves, intended for different eyes).  In order to recognize the element under the cursor, we can use the document.elementFromPoint (x, y) function.  At this point, it seems very useful that the renderer uses transformations, but the elements themselves remain standard DOM elements.  We do not need to come up with geometry with the intersection of the ray with the plane on which the content is rendered, searching for the coordinates of the intersection and determining the elements on the plane along these coordinates.  Everything is much simpler.  Standard function copes with this task. <br><br>  The truth is, the question is about which element to add and delete classes to.  I decided to temporarily stop at a simple transition to the parent elements until the focusable element appears.  There is probably a more beautiful solution, and you can put it into a separate function, but I really wanted to see what happened there as soon as possible. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initCursor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth * <span class="hljs-number"><span class="hljs-number">0.25</span></span>, x2 = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth * <span class="hljs-number"><span class="hljs-number">0.75</span></span>, y = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight * <span class="hljs-number"><span class="hljs-number">0.50</span></span>, element1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body, element2 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body, cursor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.fake-cursor'</span></span>); setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1 &amp;&amp; element1.classList) { element1.classList.remove(<span class="hljs-string"><span class="hljs-string">'-focused'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element2 &amp;&amp; element2.classList) { element2.classList.remove(<span class="hljs-string"><span class="hljs-string">'-focused'</span></span>); } element1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.elementFromPoint(x1, y); element2 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.elementFromPoint(x2, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1 &amp;&amp; element2) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (element1.tabIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; element1.parentNode) { element1 = element1.parentNode; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (element2.tabIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; element2.parentNode) { element2 = element2.parentNode; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1.tabIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { element1.classList.add(<span class="hljs-string"><span class="hljs-string">'-focused'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element2.tabIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { element2.classList.add(<span class="hljs-string"><span class="hljs-string">'-focused'</span></span>); } } }, <span class="hljs-number"><span class="hljs-number">100</span></span>); }</code> </pre><br><br>  We also add a quick imitation of clicking on both elements under our fake cursor.  In the case of glasses, there should be a button processing on the controller, but not having one, let's stop at the usual enter on the keyboard. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'keydown'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.keyCode === <span class="hljs-number"><span class="hljs-number">13</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1 &amp;&amp; element2) { element1.click(); element2.click(); cursor.classList.add(<span class="hljs-string"><span class="hljs-string">'-active'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cursor.classList.remove(<span class="hljs-string"><span class="hljs-string">'-active'</span></span>); }, <span class="hljs-number"><span class="hljs-number">100</span></span>); } } });</code> </pre><br><br><h2>  What happened there? </h2><br>  Since a significant part of what was used in the article is experimental, it is still difficult to argue about cross-browser compatibility.  In Chrome, under Linux, with a normal mouse, everything works, in Chrome, under an android, on one device everything turns slightly depending on the position in the room (I suppose because of the compass, which is influenced by ambient noise), on the other, everything flies into a bow.  For this reason, I recorded a small video from the screen, which shows the result from the desktop browser: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JUTNqw-Wwaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Thoughts instead of conclusion. </h2><br>  The experiment is interesting.  Yes, it is still a long way from real use.  Browsers are still very poorly supported in determining the position of a device in space, the possibilities for calibrating the compass can be said to be absent (there is a formal compassneedscalibration event, but in practice there is not much use of it).  But in general, the idea of ‚Äã‚Äãcreating an interface in three-dimensional space is quite realizable.  At least on the desktop, we can definitely use this.  If you replace the stereo renderer with a regular one, and rotate the camera simply by mouse movement, you will get something similar to a regular three-dimensional toy, only with the ability to use <s>bootstrap</s> all the favorite tools of the layout designer. <br><br>  Full example sources are available <a href="https://github.com/sfi0zy/habraexample-ui-in-vr/blob/master/index.html">on GitHub.</a> </div><p>Source: <a href="https://habr.com/ru/post/333400/">https://habr.com/ru/post/333400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333388/index.html">The history of creating a library for group communication of android devices via Wi-Fi Peer-to-Peer connection</a></li>
<li><a href="../333390/index.html">Programming Contest: JSDash (Intermediate Results)</a></li>
<li><a href="../333392/index.html">Yandex shares soared after the deal with Uber</a></li>
<li><a href="../333396/index.html">PHP Reflection on closures</a></li>
<li><a href="../333398/index.html">Talk about Yii 2</a></li>
<li><a href="../333402/index.html">Recommendations for security when working with Docker</a></li>
<li><a href="../333404/index.html">Was there a hacking of "Gosuslug"? Yandex Hypothesis</a></li>
<li><a href="../333406/index.html">How Angry Birds 2 increased revenue several times over the year</a></li>
<li><a href="../333410/index.html">Developing wrapper scripts using the Sparrow tool</a></li>
<li><a href="../333412/index.html">Creating a schedule for SCADA systems based on cron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>