<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain on Go. Part 4: Transactions, Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article " Building Blockchain in Go. Part 4: Transactions 1 ". 

 Content 



1. Blockcha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain on Go. Part 4: Transactions, Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the article " <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-4/">Building Blockchain in Go. Part 4: Transactions 1</a> ". <br><br>  Content <br><br><ol><li>  <a href="https://habrahabr.ru/post/348672/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/348672/">Part 1: Prototype</a> </li><li>  <a href="https://habrahabr.ru/post/350804/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/350804/">Part 2: Proof-of-Work</a> </li><li>  <a href="https://habrahabr.ru/post/351296/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351296/">Part 3: Permanent Memory and Command Line Interface</a> </li><li>  <b>Blockchain on Go.</b>  <b>Part 4: Transactions, Part 1</b> </li><li>  <a href="https://habrahabr.ru/post/351834/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351834/">Part 5: Addresses</a> </li><li>  Blockchain on Go.  Part 6: Transactions, Part 2 </li><li>  Blockchain on Go.  Part 7: Network </li></ol><br><h4>  Introduction </h4><br>  Transactions are the heart of Bitcoin, and the only purpose of a blockchain is to keep transactions in a safe and secure way so that no one can modify them after creation.  In this article, we begin work on the implementation of the transaction mechanism.  But since this is a rather large topic, I have broken it into two parts: in this part, we implement a general mechanism, and in the second part we will examine the rest of the functionality in detail. <br><a name="habracut"></a><br>  In this article we will almost completely edit all of our previous code, so it makes no sense to describe every change, you can see all the changes <a href="https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  No spoons </h4><br>  If you once developed a web application, then for the implementation of payments, you probably created two of these tables in the database: <code> </code> and <code></code> .  The account stored information about the user, including his personal information and balance, and the transaction stores information about the transfer of money from one account to another.  In Bitcoin, payments are made in a completely different way: <br><br><ol><li>  No accounts. </li><li>  No balances. </li><li>  No addresses. </li><li>  No coins. </li><li>  No senders and recipients. </li></ol><br>  Since the blockchain is a public and open database, we do not want to keep confidential information about wallet owners.  Coins are not kept on accounts.  Transactions do not transfer money from one address to another.  There are no fields or attributes that contain an account balance.  There are only transactions.  But what's inside? <br><br><h4>  Bitcoin transaction </h4><br>  A transaction is a combination of inputs and outputs: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Vin []TXInput Vout []TXOutput }</code> </pre><br>  The inputs of the new transaction refer to the outputs of the previous transaction (there is an exception, which we will discuss below).  Outputs - the place where coins are stored.  The following diagram shows the transaction relationship: <br><br><img src="https://habrastorage.org/webt/00/0h/3q/000h3qegoqxobzjyccfpkefbp6u.png"><br><br>  Notice: <br><br><ol><li>  There are exits that are not connected to entrances. </li><li>  In a single transaction, inputs can refer to the outputs of multiple transactions. </li><li>  The input must always refer to the output. </li></ol><br>  In this article, we will use the words "money", "coins", "spend", "send", "account", etc.  But there are no such concepts in Bitcoin.  Transactions are simply a value blocked by a script that can only be unlocked by someone who has blocked it. <br><br><h4>  Transaction Outputs </h4><br>  Let's start with exits: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TXOutput <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Value <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ScriptPubKey <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre><br>  In fact, these are the outputs that store ‚Äúcoins‚Äù (note the <code>Value</code> field above).  Means are blocked by a special puzzle that is stored in the <code>ScriptPubKey</code> .  Inside, Bitcoin uses a scripting language, <code>Script</code> , which is used to determine the logic for blocking and unlocking outputs.  The language is quite primitive (this is done intentionally to avoid possible hacking), but we will not discuss it in detail.  You can read more about him <a href="https://en.bitcoin.it/wiki/Script">here</a> . <br><blockquote>  In Bitcoin, the value field holds the amount of satoshi, not the amount of BTC.  1 satoshi = 0.00000001 BTC.  Thus, it is the smallest unit of currency in Bitcoin (as, for example, a cent). <br></blockquote>  As we have no addresses, for the time being we will avoid all the logic associated with scripts.  To begin, the <code>ScriptPubKey</code> will store an arbitrary string (user wallet address). <br><blockquote>  By the way, the presence of such a scripting language means that Bitcoin can be used as a platform for smart contracts. <br></blockquote>  One important thing you need to know about exits is that they are <u>indivisible</u> , which means that you cannot refer to a part of your value.  When the output refers to a new transaction, it is consumed completely.  And if its value is greater than required, a difference is generated and a new value is sent back to the sender.  It‚Äôs like a real world situation when you pay, say, $ 5 dollars for what costs $ 1, and you get a change of $ 4. <br><br><h4>  Transaction inputs </h4><br>  Consider the input: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TXInput <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Txid []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Vout <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ScriptSig <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre><br>  As mentioned earlier, the input refers to the previous output: <code>Txid</code> stores the identifier of such a transaction, and <code>Vout</code> stores the exit index of the transaction.  <code>ScriptSig</code> is a script that provides data that will be further used in the <code>ScriptPubKey</code> script.  If the data is correct, the output can be unblocked, and its value can be used to generate new outputs;  if not, the input cannot refer to the output.  This mechanism ensures that users cannot spend coins belonging to other people. <br><br>  Again, since we still have no addresses, <code>ScriptSig</code> save only an arbitrary user wallet address.  We will create a public key and signature verification in the next article. <br><br>  Summarize.  Outputs are the place where ‚Äúcoins‚Äù are stored.  Each exit has an unlock script that defines the logic to unlock the exit.  Each new transaction must have at least one entry and exit.  The entry refers to the result of a previous transaction and provides data (the <code>ScriptSig</code> field) that is used in the exit unlock script to unlock it and use its value to create new exits. <br><br>  But what came first: the entrances or exits? <br><br><h4>  Egg </h4><br>  In Bitcoin, the egg appeared before the chicken.  The inputs-referencing-outputs logic is a classic chicken or egg situation: the inputs produce the outputs, and the outputs allow you to create inputs.  And in Bitcoin, exits always appear in front of the entrances. <br><br>  When the miner starts mining a block, he adds a <u>coinbase transaction</u> to it.  A coinbase transaction is a special type of transaction that does not require previously existing exits.  He creates exits (i.e. "Coins") from nowhere.  Egg without chicken.  This is the reward that miners receive for the extraction of new blocks. <br><br>  As you know, there is a genesis block at the beginning of the chain.  It is this block that generates the very first output in the block chain.  And no previous exits are required, since there are no previous transactions and there are no exits. <br><br>  Let's create a coinbase transaction: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewCoinbaseTX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, data </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data == <span class="hljs-string"><span class="hljs-string">""</span></span> { data = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Reward to '%s'"</span></span>, to) } txin := TXInput{[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{}, <span class="hljs-number"><span class="hljs-number">-1</span></span>, data} txout := TXOutput{subsidy, to} tx := Transaction{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []TXInput{txin}, []TXOutput{txout}} tx.SetID() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;tx }</code> </pre><br>  There is only one entry in the coinbase transaction.  In our implementation, <code>Txid</code> empty, and <code>Vout</code> is -1.  In addition, the coinbase transaction does not store the script in <code>ScriptSig</code> .  Instead, arbitrary data is stored there. <br><blockquote>  In Bitcoin, the very first coinbase transaction contains the following message: ‚ÄúThe Times 03 / Jan / 2009 Chancellor for brink of second bailout for banks‚Äù.  <a href="https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b%3Fshow_adv%3Dtrue">You yourself can look at it</a> . <br></blockquote>  <code>subsidy</code> is the amount of the reward.  In Bitcoin, this number is not stored anywhere and is calculated only on the basis of the total number of blocks: the number of blocks is divided by <b>210,000</b> .  Mining a block of genesis brings 50 BTC, and every 210,000 blocks the reward is halved.  In our implementation, we will store the reward as a constant (at least for the time being). <br><br><h4>  Saving transactions in the chain </h4><br>  From this point on, each block should keep at least one transaction, and it should be impossible to mine the blocks without a transaction.  Now, we will delete the date field from Block and instead we will now store transactions. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Block <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Transactions []*Transaction PrevBlockHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Hash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Nonce <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre><br>  <code>NewBlock</code> and <code>NewGenesisBlock</code> should also be changed accordingly. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transactions []*Transaction, prevBlockHash []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span> { block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>} ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGenesisBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coinbase *Transaction)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewBlock([]*Transaction{coinbase}, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{}) }</code> </pre><br>  Now create function <code>CreateBlockchain</code> <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockchain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Blockchain</span></span></span></span> { ... err = db.Update(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *bolt.Tx)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { cbtx := NewCoinbaseTX(address, genesisCoinbaseData) genesis := NewGenesisBlock(cbtx) b, err := tx.CreateBucket([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(blocksBucket)) err = b.Put(genesis.Hash, genesis.Serialize()) ... }) ... }</code> </pre><br>  The function now accepts an address that will be rewarded for mining a genesis block. <br><br><h4>  Proof-of-work </h4><br>  The Proof-of-Work algorithm should consider transactions stored in the block to ensure consistency and reliability of the chain as a transaction repository.  So now we have to change the <code>ProofOfWork.prepareData</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pow *ProofOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nonce </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { data := bytes.Join( [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{ pow.block.PrevBlockHash, pow.block.HashTransactions(), <span class="hljs-comment"><span class="hljs-comment">// This line was changed IntToHex(pow.block.Timestamp), IntToHex(int64(targetBits)), IntToHex(int64(nonce)), }, []byte{}, ) return data }</span></span></code> </pre><br>  Instead of <code>pow.block.Data</code> we now add <code>pow.block.HashTransactions ()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Block)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HashTransactions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> txHashes [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> txHash [<span class="hljs-number"><span class="hljs-number">32</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> b.Transactions { txHashes = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(txHashes, tx.ID) } txHash = sha256.Sum256(bytes.Join(txHashes, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{})) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> txHash[:] }</code> </pre><br>  Again, we use hashing as a mechanism for providing a unique view of the data.  We want all transactions in the block to be uniquely identified using a single hash.  To achieve this, we get the hashes of each transaction, combine them and get the hash of the combined combinations. <br><blockquote>  Bitcoin uses a more complex technique: it presents all transactions contained in a block as <a href="https://en.wikipedia.org/wiki/Merkle_tree">a hash tree</a> , and uses the root hash of the tree in the Proof-of-Work system.  This approach allows you to quickly check if a block contains a specific transaction that has only a root hash and does not load all transactions. </blockquote>  Check the correctness of the work: <br><br><pre> <code class="bash hljs">$ blockchain_go createblockchain -address Ivan 00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a Done!</code> </pre> <br>  Fine!  We received our first award.  But how do we check the balance? <br><br><h4>  Unspent exits </h4><br>  We need to find all unspent exits (UTXO).  This means that these outputs did not refer to any inputs.  In the diagram above, this is: <br><br><ol><li>  tx0, output 1; </li><li>  tx1, output 0; </li><li>  tx3, output 0; </li><li>  tx4, output 0. </li></ol><br>  Of course, when we check the balance, we don‚Äôt need them all, only those that can be unlocked with the key we own are needed (currently we don‚Äôt have implemented keys and user addresses will be used instead).  To begin with, let's define locking-unlocking methods for entrances and exits: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in *TXInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUnlockOutputWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unlockingData </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> in.ScriptSig == unlockingData } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out *TXOutput)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanBeUnlockedWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unlockingData </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out.ScriptPubKey == unlockingData }</code> </pre><br>  Here we simply compare the fields from <code>ScriptSig</code> to <code>unlockingData</code> .  In the next article we will improve them after we implement addresses based on private keys. <br><br>  The next step is to search for transactions with unspent exits ‚Äî this is more difficult: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUnspentTransactions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unspentTXs []Transaction spentTXOs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) bci := bc.Iterator() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { block := bci.Next() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> block.Transactions { txID := hex.EncodeToString(tx.ID) Outputs: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> outIdx, out := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vout { <span class="hljs-comment"><span class="hljs-comment">// Was the output spent? if spentTXOs[txID] != nil { for _, spentOut := range spentTXOs[txID] { if spentOut == outIdx { continue Outputs } } } if out.CanBeUnlockedWith(address) { unspentTXs = append(unspentTXs, *tx) } } if tx.IsCoinbase() == false { for _, in := range tx.Vin { if in.CanUnlockOutputWith(address) { inTxID := hex.EncodeToString(in.Txid) spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout) } } } } if len(block.PrevBlockHash) == 0 { break } } return unspentTXs }</span></span></code> </pre><br>  Because transactions are stored in blocks, we have to check every block in the chain.  Let's start with exits: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> out.CanBeUnlockedWith(address) { unspentTXs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(unspentTXs, tx) }</code> </pre><br><br>  If an exit has been blocked at the same address, we are looking for unspent exits that we want.  But before accepting it, we need to check if the input has already been specified at the output: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> spentTXOs[txID] != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, spentOut := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> spentTXOs[txID] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> spentOut == outIdx { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> Outputs } } }</code> </pre><br>  We skip those that are already referenced inputs (their values ‚Äã‚Äãwere transferred to other outputs, so we can not count them).  After checking the outputs, we collect all the inputs that can unblock the outputs blocked with the provided address (this does not apply to coinbase transactions, since they do not unblock the outputs): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.IsCoinbase() == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, in := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> in.CanUnlockOutputWith(address) { inTxID := hex.EncodeToString(in.Txid) spentTXOs[inTxID] = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(spentTXOs[inTxID], in.Vout) } } }</code> </pre><br>  The function returns a list of transactions containing unspent exits.  To calculate the balance, we need another function that takes transactions and returns only exits: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUTXO</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TXOutput</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> UTXOs []TXOutput unspentTransactions := bc.FindUnspentTransactions(address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> unspentTransactions { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, out := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vout { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> out.CanBeUnlockedWith(address) { UTXOs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(UTXOs, out) } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UTXOs }</code> </pre><br>  Done!  Now we are implementing the <code>getbalance</code> command <code>getbalance</code> <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cli *CLI)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bc := NewBlockchain(address) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> bc.db.Close() balance := <span class="hljs-number"><span class="hljs-number">0</span></span> UTXOs := bc.FindUTXO(address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, out := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> UTXOs { balance += out.Value } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Balance of '%s': %d\n"</span></span>, address, balance) }</code> </pre><br>  The account balance is the sum of the values ‚Äã‚Äãof all unspent exits blocked by the account address. <br><br>  Let's check our balance after mining a genesis block: <br><br><pre> <code class="bash hljs">$ blockchain_go getbalance -address Ivan Balance of <span class="hljs-string"><span class="hljs-string">'Ivan'</span></span>: 10</code> </pre><br>  These are our first coins! <br><br><h4>  Sending Coins </h4><br>  Now we want to send some coins to someone else.  To do this, we need to create a new transaction, put it into a block and process it.  So far, we have implemented only the coinbase transaction (which is a special type of transaction), now we need a general transaction: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewUTXOTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from, to </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bc *Blockchain)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputs []TXInput <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputs []TXOutput acc, validOutputs := bc.FindSpendableOutputs(from, amount) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> acc &lt; amount { log.Panic(<span class="hljs-string"><span class="hljs-string">"ERROR: Not enough funds"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// Build a list of inputs for txid, outs := range validOutputs { txID, err := hex.DecodeString(txid) for _, out := range outs { input := TXInput{txID, out, from} inputs = append(inputs, input) } } // Build a list of outputs outputs = append(outputs, TXOutput{amount, to}) if acc &gt; amount { outputs = append(outputs, TXOutput{acc - amount, from}) // a change } tx := Transaction{nil, inputs, outputs} tx.SetID() return &amp;tx }</span></span></code> </pre><br>  Before creating new exits, we first need to find all the unspent exits and make sure that there are enough coins in them.  This is the <code>FindSpendableOutputs</code> method.  After that, for each output found, an input is created that references it.  Then we create two outputs: <br><br><ol><li>  The one that is blocked with the recipient address.  This is the actual transfer of coins to another address. </li><li>  The one that is blocked with the sender address.  This is the difference.  It is created only when unspent exits matter more than what is required for a new transaction.  Remember: exits are <u>indivisible</u> . </li></ol><br>  The <code>FindSpendableOutputs</code> method <code>FindSpendableOutputs</code> based on the <code>FindUnspentTransactions</code> method, which we defined earlier: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSpendableOutputs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">][]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { unspentOutputs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) unspentTXs := bc.FindUnspentTransactions(address) accumulated := <span class="hljs-number"><span class="hljs-number">0</span></span> Work: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> unspentTXs { txID := hex.EncodeToString(tx.ID) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> outIdx, out := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vout { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> out.CanBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount { accumulated += out.Value unspentOutputs[txID] = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(unspentOutputs[txID], outIdx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> accumulated &gt;= amount { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> Work } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulated, unspentOutputs }</code> </pre><br>  The method performs a walk through all unspent transactions and accumulates their values.  When the accumulated value is greater than or equal to the amount we want to transfer, the crawl stops and returns the accumulated values ‚Äã‚Äãand output indices grouped by transaction identifiers.  We do not need to take more than we are going to spend. <br><br>  Now we can change the <code>Blockchain.MineBlock</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MineBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transactions []*Transaction)</span></span></span></span> { ... newBlock := NewBlock(transactions, lastHash) ... }</code> </pre><br>  Finally, create the <code>send</code> command: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cli *CLI)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from, to </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bc := NewBlockchain(from) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> bc.db.Close() tx := NewUTXOTransaction(from, to, amount, bc) bc.MineBlock([]*Transaction{tx}) fmt.Println(<span class="hljs-string"><span class="hljs-string">"Success!"</span></span>) }</code> </pre><br>  Sending coins means creating a transaction and adding it to the block chain by mining a block.  But Bitcoin doesn't do it right away (as we do).  Instead, it places all new transactions in the memory pool (or mempool), and when the miner is ready to mine the block, he takes all the transactions from the mempool and creates a candidate block.  Transactions become confirmed only when the block containing them is extracted and added to the block chain. <br><br>  Let's check how sending coins works: <br><br><pre> <code class="bash hljs">$ blockchain_go send -from Ivan -to Pedro -amount 6 00000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37 Success! $ blockchain_go getbalance -address Ivan Balance of <span class="hljs-string"><span class="hljs-string">'Ivan'</span></span>: 4 $ blockchain_go getbalance -address Pedro Balance of <span class="hljs-string"><span class="hljs-string">'Pedro'</span></span>: 6</code> </pre><br>  Fine!  Now let's create more transactions and make sure that sending from multiple outputs works correctly: <br><br><pre> <code class="bash hljs">$ blockchain_go send -from Pedro -to Helen -amount 2 00000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf Success! $ blockchain_go send -from Ivan -to Helen -amount 2 000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa Success!</code> </pre><br>  Now Helen's coins are blocked on two outs: one exit from Pedro and one from Ivan.  Send to someone else: <br><br><pre> <code class="bash hljs">$ blockchain_go send -from Helen -to Rachel -amount 3 000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0 Success! $ blockchain_go getbalance -address Ivan Balance of <span class="hljs-string"><span class="hljs-string">'Ivan'</span></span>: 2 $ blockchain_go getbalance -address Pedro Balance of <span class="hljs-string"><span class="hljs-string">'Pedro'</span></span>: 4 $ blockchain_go getbalance -address Helen Balance of <span class="hljs-string"><span class="hljs-string">'Helen'</span></span>: 1 $ blockchain_go getbalance -address Rachel Balance of <span class="hljs-string"><span class="hljs-string">'Rachel'</span></span>: 3</code> </pre><br>  Looks nice!  Now let's test the exceptions: <br><br><pre> <code class="bash hljs">$ blockchain_go send -from Pedro -to Ivan -amount 5 panic: ERROR: Not enough funds $ blockchain_go getbalance -address Pedro Balance of <span class="hljs-string"><span class="hljs-string">'Pedro'</span></span>: 4 $ blockchain_go getbalance -address Ivan Balance of <span class="hljs-string"><span class="hljs-string">'Ivan'</span></span>: 2</code> </pre><br><h4>  Conclusion </h4><br>  Phew!  It was not easy, but now we have transactions!  Although, some key features of a Bitcoin-like cryptocurrency are missing: <br><br><ol><li>  Addresses  While we do not have addresses on the basis of a private key. </li><li>  Awards  Mine blocks is absolutely unprofitable! </li><li>  Utxo.  Getting the balance requires scanning the entire block chain, which can take a very long time when there are so many blocks.  In addition, it will take a very long time if we want to confirm subsequent transactions.  UTXO is designed to solve these problems and to work quickly with transactions. </li><li>  Mempool.  Transactions are stored here before they are packaged.  In our current implementation, the block contains only one transaction, and it is very inefficient. </li></ol><br><h4>  Links </h4><br><ol><li>  <a href="https://github.com/Jeiwan/blockchain_go/tree/part_4">Full source codes</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Transaction">Transaction</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Protocol_documentation">Merkle tree</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Coinbase">Coinbase</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/351752/">https://habr.com/ru/post/351752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351740/index.html">Looking for the causes of database brakes using sys schema in MySQL 5.7</a></li>
<li><a href="../351744/index.html">Amazon Lambda with Golang</a></li>
<li><a href="../351746/index.html">Tutu PHP Meetup # 1</a></li>
<li><a href="../351748/index.html">Create iOS stopwatch on React-Native (subtitles)</a></li>
<li><a href="../351750/index.html">Angular. Recursive component</a></li>
<li><a href="../351756/index.html">Types of software testing (in pictures)</a></li>
<li><a href="../351758/index.html">Marvin Minsky "The Emotion Machine": Chapter 1. Love</a></li>
<li><a href="../351760/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "Playing With the Mud"</a></li>
<li><a href="../351762/index.html">Conference DEFCON 21. "As my Botnet earned millions of dollars in car sales and defeated Russian hackers"</a></li>
<li><a href="../351764/index.html">Data center with interesting physical protection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>