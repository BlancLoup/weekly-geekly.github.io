<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why use static types in javascript? (Advantages and disadvantages)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We talked about many things in the first part . Now with the syntax done, let's finally move on to the most interesting: to study the advantages and d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why use static types in javascript? (Advantages and disadvantages)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/eb6/2e5/8f9/eb62e58f9a234ca890279a0063ed1423.jpg" align="left">  We talked about many things in the <a href="https://habrahabr.ru/post/326304/">first part</a> .  Now with the syntax done, let's finally move on to the most interesting: to study the advantages and disadvantages of using static types. <br><br><h3>  Advantage # 1: You can find bugs and errors in advance. </h3><br>  Static type checking allows you to verify that the invariant defined by us is <code>true</code> , even without starting the program.  And if there is any violation of these invariants, it will be detected before the launch of the program, and not during its operation. <br><a name="habracut"></a><br>  A small example: suppose we have a small function that takes a radius and calculates the area: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateArea = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radius</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span> * radius * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> area = calculateArea(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 28.26</span></span></code> </pre> <br>  Now, if we want to pass functions to a radius that is not a number (of the ‚Äúmalefactor‚Äù type) ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> area = calculateArea(<span class="hljs-string"><span class="hljs-string">'im evil'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// NaN</span></span></code> </pre> <br>  We will return <code>NaN</code> .  If any functionality is based on the fact that the function <code>calculateArea</code> always returns a number, this will lead to vulnerability or failure.  Not very nice, right? <br><br>  If we used static types, we would define a specific type of the passed parameters and return values ‚Äã‚Äãfor this function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateArea = (radius: number): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span> * radius * radius;</code> </pre> <br>  Now try sending something besides the number of the function <code>calculateArea</code> - and Flow will return a convenient and nice message: <br><br><pre> <code class="javascript hljs">calculateArea(<span class="hljs-string"><span class="hljs-string">'Im evil'</span></span>); ^^^^^^^^^^^^^^^^^^^^^^^^^ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateArea</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Im evil'</span></span></span></span></span><span class="hljs-function">); ^^^^^^^^^ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function">. </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incompatible</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateArea</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radius: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function"> =&gt; 3.14 * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radius</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radius</span></span></span><span class="hljs-function">; ^^^^^^ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span></span></code> </pre> <br>  Now we have a guarantee that the function will only accept valid input numbers and return the result only in the form of valid numbers. <br><br>  Since the type controller reports errors to you right at the time of writing the code, it is much more convenient (and much cheaper) than finding a bug after the code has been sent to the customer. <br><br><h3>  Advantage # 2: You have live documentation. </h3><br>  Types work as living, breathing documentation for you and for others. <br><br>  To understand how, look at the method that I once found in a large code base with which I worked: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePayoutDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">quote, amount, paymentMethod</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payoutDate; <span class="hljs-comment"><span class="hljs-comment">/* business logic */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> payoutDate; }</code> </pre> <br>  At first glance (both the second and third), it is completely incomprehensible how to use this function. <br><br>  Is the quote a number?  Or a logical value?  Is the payment method an object?  Or can it be a string that represents the type of payment method?  Does the function return a date in string form?  Or is it a <code>Date</code> object? <br><br>  No idea. <br><br>  At that time, I decided to evaluate all business logic and did a grep on the code base until I found out everything.  But this is too much work just to understand how a simple function works. <br><br>  On the other hand, if I wrote something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePayoutDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> quote: boolean, amount: number, paymentMethod: string</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Date</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payoutDate; <span class="hljs-comment"><span class="hljs-comment">/* business logic */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> payoutDate; }</code> </pre> <br>  then it would immediately become clear which data type the function accepts and which type returns.  This is an example of how static types can be used to communicate what the function <i>intends to</i> do.  We can tell other developers what we expect from them, and we can see what they expect from us.  Next time, if someone is going to use this function, there will be no questions. <br><br>  It can be argued that this problem is solved by adding comments to the code or documentation: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* @function Determines the payout date for a purchase @param {boolean} quote - Is this for a price quote? @param {boolean} amount - Purchase amount @param {string} paymentMethod - Type of payment method used for this purchase */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePayoutDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">quote, amount, paymentMethod</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payoutDate; <span class="hljs-comment"><span class="hljs-comment">/* .... Business logic .... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> payoutDate; };</code> </pre> <br>  It works.  But there are more words.  In addition to verbosity, such comments in the code are difficult to maintain, because they are unreliable and have no structure ‚Äî some developers write good comments, others may write something incomprehensible, and some may forget to leave a comment. <br><br>  It is especially easy to forget to update the comment after refactoring.  On the other hand, type annotations have clearly defined syntax and structure, and they will never become obsolete because they are encoded in the code itself. <br><br><h3>  Advantage # 3: The handling of entangled errors is fixed. </h3><br>  Types help eliminate code handling in entangled errors.  Let's go back to our function <code>calculateArea</code> and see how this happens. <br><br>  This time I will give her an array of radii to calculate the areas for each radius: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radii</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areas = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; radii.length; i++) { areas[i] = PI * (radii[i] * radii[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areas; };</code> </pre> <br>  This function works, but does not properly handle invalid input arguments.  If we want to make sure that the function correctly handles situations where the input arguments are not valid arrays of numbers, then we arrive at a function of approximately the following form: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radii</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Handle undefined or null input if (!radii) { throw new Error("Argument is missing"); } // Handle non-array inputs if (!Array.isArray(radii)) { throw new Error("Argument must be an array"); } var areas = []; for (var i = 0; i &lt; radii.length; i++) { if (typeof radii[i] !== "number") { throw new Error("Array must contain valid numbers only"); } else { areas[i] = 3.14 * (radii[i] * radii[i]); } } return areas; };</span></span></code> </pre> <br>  Wow.  There is a lot of code for such a small piece of functionality. <br><br>  And with static types, we just write: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = (radii: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt;): <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areas = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; radii.length; i++) { areas[i] = <span class="hljs-number"><span class="hljs-number">3.14</span></span> * (radii[i] * radii[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areas; };</code> </pre> <br>  Now the function really looks like it looked before adding all the visual garbage due to error handling. <br><br>  Easy to understand the benefits of static types, right? <br><br><h3>  Advantage # 4: You can refactor more confidently. </h3><br>  Let me explain this story of life.  Once I worked with a very large code base, and I had to update the method installed in the <code>User</code> class.  In particular, change one of the parameters of the function from <code>string</code> to <code>object</code> . <br><br>  I made a change, but I was scared to send a commit ‚Äî there were so many calls to this function scattered throughout the code that I was not sure that I had updated all the instances correctly.  What if some call remained somewhere deep in an unverified auxiliary file? <br><br>  The only way to check is to send the code and pray that it will not explode with a bunch of errors. <br><br>  When using static types, this problem will not occur.  There I will have peace and tranquility in my heart: if I update the function and type definitions, the type controller will be near and find all the errors I could miss.  It only remains to go through these type errors and correct them. <br><br><h3>  Advantage # 5: Separation of data and behavior </h3><br>  One rarely mentioned advantage of static types is that they help separate data from behavior. <br><br>  Look again at our function <code>calculateArea</code> with static types: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = (radii: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt;): <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areas = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; radii.length; i++) { areas[i] = <span class="hljs-number"><span class="hljs-number">3.14</span></span> * (radii[i] * radii[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areas; };</code> </pre> <br>  Think about how we would approach the compilation of this function.  Since we specify data types, we are forced first of all to think about the data types that we are going to use, so that we can set the types for the passed parameters and return values ‚Äã‚Äãaccordingly. <br><br><img src="https://cdn-images-1.medium.com/max/720/1*iemrVKr16FMed25x6-bfBA.png"><br><br>  Only after that we implement the logic: <br><br><img src="https://cdn-images-1.medium.com/max/1080/1*PFxhb9gct7GYWBlBY0lofg.png"><br><br>  The ability to accurately express the data separately from the behavior allows us to clearly indicate our assumptions and more accurately convey the intention, which removes a certain mental load and gives the programmer a certain clarity of mind.  Otherwise, it remains to keep everything in the mind in some way. <br><br><h3>  Advantage # 6: Eliminating an entire category of bugs. </h3><br>  Errors of types at runtime are one of the most common errors or bugs encountered by JavaScript developers. <br><br>  For example, suppose that the initial state of the application was set as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appState = { <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: [], };</code> </pre> <br>  And suppose then we make an API call to pick up messages and fill our <code>appState</code> .  Further, our application has an oversimplified component for viewing, which takes <code>messages</code> (indicated in the state above) and displays the number of unread messages and each message as a list item: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ messages }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> You have { messages.length } unread messages </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { messages.map(message =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Message</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag"> } /&gt;</span></span></span><span class="xml"> )} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); };</span></span></code> </pre> <br>  If the call to the API for collecting messages did not work or returned <code>undefined</code> , then you will encounter a type error in production: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: Cannot read property <span class="hljs-string"><span class="hljs-string">'length'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span></code> </pre> <br>  ... and your program will fail.  You lose a customer.  A curtain. <br><br>  Let's see how static types can help.  We start by adding Flow types to the application state.  I use the <code>AppState</code> to determine the state: <br><br><pre> <code class="javascript hljs">type AppState = { <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: boolean, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: ?<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;string&gt; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appState: AppState = { <span class="hljs-attr"><span class="hljs-attr">isFetching</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, };</code> </pre> <br>  Since it is known that the API for collecting messages does not work reliably, we specify for the value of <code>messages</code> type of <code>maybe</code> for an array of strings. <br><br>  Just like last time, we retrieve messages through an unreliable API and use them in the view component: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ messages }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> You have { messages.length } unread messages </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { messages.map(message =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Message</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag"> } /&gt;</span></span></span><span class="xml"> )} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); };</span></span></code> </pre> <br>  But at this point, Flow will detect the error and complain: <br><br><pre> <code class="javascript hljs">&lt;h1&gt; You have {messages.length} unread messages &lt;<span class="hljs-regexp"><span class="hljs-regexp">/h1&gt; ^^^^^^ property `length`. Property cannot be accessed on possibly null value &lt;h1&gt; You have {messages.length} unread messages &lt;/</span></span>h1&gt; ^^^^^^^^ <span class="hljs-literal"><span class="hljs-literal">null</span></span> &lt;h1&gt; You have {messages.length} unread messages &lt;<span class="hljs-regexp"><span class="hljs-regexp">/h1&gt; ^^^^^^ property `length`. Property cannot be accessed on possibly undefined value &lt;h1&gt; You have {messages.length} unread messages &lt;/</span></span>h1&gt; ^^^^^^^^ <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> { messages.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Message message={ message } /&gt; )} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> method <span class="hljs-string"><span class="hljs-string">`map`</span></span>. Method cannot be called on possibly <span class="hljs-literal"><span class="hljs-literal">null</span></span> value { messages.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Message message={ message } /&gt; )} ^^^^^^^^ <span class="hljs-literal"><span class="hljs-literal">null</span></span> { messages.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Message message={ message } /&gt; )} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> method <span class="hljs-string"><span class="hljs-string">`map`</span></span>. Method cannot be called on possibly <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> value { messages.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Message message={ message } /&gt; )} ^^^^^^^^ <span class="hljs-literal"><span class="hljs-literal">undefined</span></span></code> </pre> <br>  Wait, buddy! <br><br>  Since we have defined <code>messages</code> as the type of <code>maybe</code> , we allow it to be <code>null</code> or <code>undefined</code> .  But this does not give us the right to perform operations with it (like <code>.length</code> or <code>.map</code> ) without checking for <code>null</code> , because if the value of <code>messages</code> is actually <code>null</code> or <code>undefined</code> , a type error will pop up when trying to perform an operation with it. <br><br>  So back and update our function to view something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ messages, isFetching }: AppState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFetching) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Loading... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (messages === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || messages === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Failed to load messages. Try again. </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> You have { messages.length } unread messages </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { messages.map(message =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Message</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag"> } /&gt;</span></span></span><span class="xml"> )} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } };</span></span></code> </pre> <br>  Now, Flow knows that we have considered all situations where <code>messages</code> are <code>null</code> or <code>undefined</code> , so the code type check ends with 0 errors.  Goodbye errors during program execution! <br><br><h3>  Advantage # 7: Reducing the number of unit tests </h3><br>  Previously, we saw how static types help get rid of parsing entangled errors, because they guarantee the types of parameters and return values ‚Äã‚Äãthat are passed to the function.  As a result, static types also reduce the number of unit tests. <br><br>  For example, back to our function <code>calculateAreas</code> with dynamic types and error handling. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radii</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Handle undefined or null input if (!radii) { throw new Error("Argument is missing"); } // Handle non-array inputs if (!Array.isArray(radii)) { throw new Error("Argument must be an array"); } var areas = []; for (var i = 0; i &lt; radii.length; i++) { if (typeof radii[i] !== "number") { throw new Error("Array must contain valid numbers only"); } else { areas[i] = 3.14 * (radii[i] * radii[i]); } } return areas; };</span></span></code> </pre> <br>  If we were diligent programmers, we could think about testing invalid passed parameters to verify that they are correctly processed by our program: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should not work - case 1'</span></span>, () =&gt; { expect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calculateAreas([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>])).to.throw(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should not work - case 2'</span></span>, () =&gt; { expect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calculateAreas(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>).to.throw(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should not work - case 2'</span></span>, () =&gt; { expect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calculateAreas(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>)).to.throw(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>); });</code> </pre> <br>  ‚Ä¶ and so on.  But it is very likely that we will forget to test some boundary cases - and our customer will be the one who finds the problem.  :( <br><br>  Since the tests are based solely on the situations that we have come up with to test, they are existential, and in practice they are easy to get around. <br><br>  On the other hand, when we need to set types: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateAreas = (radii: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt;): <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;number&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areas = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; radii.length; i++) { areas[i] = <span class="hljs-number"><span class="hljs-number">3.14</span></span> * (radii[i] * radii[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areas; };</code> </pre> <br>  ... we not only get a guarantee that our goal corresponds to reality, but such tests are simply more reliable.  Unlike empirical tests, types are universal and more difficult to circumvent. <br><br>  If you look at the whole, the picture is as follows: tests are good for checking logic and types for checking data types.  When they are combined, the sum of the parts gives an even greater effect. <br><br><h3>  Advantage # 8: The Domain Modeling Tool </h3><br>  One of my favorite examples of using static types is domain modeling.  In this case, a model is created that includes both the data and the program behavior on this data.  In this case, it is best to understand by example how to use types. <br><br>  Suppose that the application offers the user one or more payment methods for making purchases on the platform.  The user is allowed to choose from three payment methods (Paypal, credit card, bank account). <br><br>  So, first apply the type aliases for the three payment methods: <br><br><pre> <code class="javascript hljs">type Paypal = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Paypal'</span></span> }; type CreditCard = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CreditCard'</span></span> }; type Bank = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Bank'</span></span> };</code> </pre> <br>  Now you can set the <code>PaymentMethod</code> type as a non-overlapping set with three cases: <br><br><pre> <code class="javascript hljs">type PaymentMethod = Paypal | CreditCard | Bank;</code> </pre> <br>  Now we will make a model of the state of our application.  To keep things simple, suppose that these applications consist only of payment methods available to the user. <br><br><pre> <code class="javascript hljs">type Model = { <span class="hljs-attr"><span class="hljs-attr">paymentMethods</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;PaymentMethod&gt; };</code> </pre> <br>  It is acceptable?  Well, we know that to obtain user payment methods, you need to make a request to the API and, depending on the result and stage of the process, the application can take different states.  In reality, there are four possible states: <br><br>  1) We did not receive payment methods. <br>  2) We are in the process of receiving payment methods. <br>  3) We have successfully received payment methods. <br>  4) We tried to get payment methods, but an error occurred. <br><br>  But our simple <code>Model</code> type with <code>paymentMethods</code> does not cover all of these cases.  Instead, it assumes that <code>paymentMethods</code> always exists. <br><br>  Hmmmm  Is there a way to make a model so that the state of the application takes one of these four values, and only them?  Let's get a look: <br><br><pre> <code class="javascript hljs">type AppState&lt;E, D&gt; = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'NotFetched'</span></span> } | { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Fetching'</span></span> } | { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Failure'</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: E } | { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Success'</span></span>, <span class="hljs-attr"><span class="hljs-attr">paymentMethods</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;D&gt; };</code> </pre> <br>  We used the non-overlapping set type to set the <code>AppState</code> to one of the four states described above.  Notice how I use the <code>type</code> property to determine which of the four states the application is in.  This <code>type</code> property is what creates a non-intersecting set.  Using it we can analyze and determine when we have payment methods, and when not. <br><br>  You will also notice that I am passing the parameterized type <code>E</code> and <code>D</code> into an application state.  Type <code>D</code> will be the user's payment method ( <code>PaymentMethod</code> , defined above).  We have not set the type <code>E</code> , which will be our type for the error, so do it now: <br><br><pre> <code class="javascript hljs">type HttpError = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: string };</code> </pre> <br>  Now you can simulate the application domain: <br><br><pre> <code class="javascript hljs">type Model = AppState&lt;HttpError, PaymentMethod&gt;;</code> </pre> <br>  In general, the signature for the application state is now <code>AppState&lt;E, D&gt;</code> , where <code>E</code> is of the form <code>HttpError</code> , and <code>D</code> is the <code>PaymentMethod</code> .  And the <code>AppState</code> has four (and only these four) possible states: <code>NotFetched</code> , <code>Fetching</code> , <code>Failure</code> and <code>Success</code> . <br><br><img src="https://cdn-images-1.medium.com/max/1080/1*IDG2HHn55BhiZk8KMADLsQ.png"><br><br>  Such domain models seem to me useful for thinking and developing user interfaces in accordance with certain business rules.  Business rules tell us that an application can only be in one of these states, and this allows us to explicitly present the AppState and ensure that it will only be in one of these predefined states.  And when we develop on this model (for example, we create a component for viewing), it becomes absolutely obvious that we need to handle all four possible states. <br><br>  Moreover, the code documents itself ‚Äî just look at the disjoint sets, and it immediately becomes clear how AppState is structured. <br><br><h1>  Disadvantages of using static types </h1><br>  Like everything else in life and programming, checking static types requires some compromises. <br><br>  It is important to understand and recognize these shortcomings so that we can make an informed decision when it makes sense to use static types and when they are simply not worth it. <br><br>  Here are some of these considerations: <br><br><h3>  Deficiency # 1: Static types require preliminary study. </h3><br>  One reason why JavaScript is such a fantastic language for beginners is that beginners do not need to learn the complete type system before starting productive work. <br><br>  When I first learned Elm (a functional language with static typing), types often got in the way.  I constantly encountered compiler errors due to my type definitions. <br><br>  Learning to use types effectively was half the success in learning the language itself.  As a result, because of the static types, the Elm learning curve is cooler than JavaScript. <br><br>  This is especially important for beginners who have the greatest cognitive load from the study of syntax.  Adding syntax to this set can overwhelm the novice. <br><br><h3>  Disadvantage number 2: Can be bogged down in verbosity </h3><br>  Because of the static types, programs often look more verbose and cluttered. <br><br>  For example, instead: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">amountExceedsPurchaseLimit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">amount, getPurchaseLimit</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> limit = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getPurchaseLimit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> limit &gt; amount; }</code> </pre> <br>  We have to write: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">amountExceedsPurchaseLimit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> amount: number, getPurchaseLimit: (</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function">&gt; ): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> limit = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getPurchaseLimit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> limit &gt; amount; }</code> </pre> <br>  And instead: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Preethi'</span></span>, <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'San Francisco'</span></span>, };</code> </pre> <br>  I have to write this: <br><br><pre> <code class="javascript hljs">type User = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">city</span></span>: string, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user: User = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Preethi'</span></span>, <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'San Francisco'</span></span>, };</code> </pre> <br>  Obviously, extra lines of code are added.  But there are a couple of arguments against this as a disadvantage. <br><br>  First, as we mentioned earlier, static types destroy a whole category of tests.  Some developers may find this a perfectly reasonable compromise. <br><br>  Secondly, as we saw earlier, static types can sometimes eliminate the need to handle complex errors, and this, in turn, greatly reduces code clutter. <br><br>  It is difficult to say whether verbosity is a real argument against types, but it is worth keeping it in mind. <br><br><h3>  Disadvantage number 3: It takes time to achieve skill in the use of types </h3><br>  It takes a lot of time and practice to learn the best way to choose types in the program.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the development of a good feeling for what should be monitored statically, and what is best left in a dynamic form, also requires a careful approach, practice and experience. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, one approach is to encode critical business logic with static types, but leave short-term or unimportant fragments of logic dynamic to avoid unnecessary complexity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Understanding the difference is difficult, especially if the less experienced developer has to make decisions on the fly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disadvantage # 4: Static types can delay fast development. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned earlier, I tripped slightly on types when I studied Elm ‚Äî especially when I added code or made changes to it. </font><font style="vertical-align: inherit;">Constantly distracted by compiler errors, it is difficult to do work and feel progress. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The argument here is that because of checking static types, a programmer may lose concentration too often - and you know, concentration is a key factor in writing a good program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's not just that. </font><font style="vertical-align: inherit;">Static type controllers are also not always perfect. </font><font style="vertical-align: inherit;">Sometimes there is a situation when you know what to do, and type checking interferes and interferes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm sure I missed some other flaws, but these are the most important for me.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Need to use static types in javascript or not? </font></font></h1><br><img src="https://cdn-images-1.medium.com/max/720/1*PKmiFZ47uY9CwfIHrPny-A.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first programming languages ‚Äã‚ÄãI studied were JavaScript and Python, both languages ‚Äã‚Äãwith dynamic typing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But mastering static types has added a new dimension to how I think about programming. For example, although I considered the constant compiler error messages in Elm to be overwhelming at first, then the type definition and ‚Äúcompiler favoring‚Äù became second nature and actually improved my programming skills. In addition, there is nothing more liberating than a smart robot that tells me that I'm doing something wrong and how to fix it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, there are inevitable compromises of static types, such as excessive verbosity and the need to spend time studying them. But types add security and correctness to programs, which eliminates the significance of these ‚Äúflaws‚Äù for me personally.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic types seem faster and simpler, but they can fail when you actually run a program in action. </font><font style="vertical-align: inherit;">At the same time, you can talk to any Java developer who deals with more complex parameterized types - and he will tell you how much he hates them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ultimately, there is no universal solution. </font><font style="vertical-align: inherit;">Personally, I prefer to use static types under the following conditions:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program is critical to your business. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program is likely to refactor according to new needs. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program is complex and has many moving parts. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program is supported by a large group of developers who need to quickly and accurately understand the code. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On the other hand, I would refuse static types in the following conditions: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The code is short-lived and is not critical. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You make a prototype and try to move as fast as possible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program is small and / or simple. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You are the only developer. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The advantage of developing in JavaScript these days is that, thanks to tools like Flow and TypeScript, we finally have the choice of using static types or good old JavaScript. </font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope these articles have helped you understand the importance of types, how to use them and, most importantly, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* when *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to use them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to switch between dynamic and static types is a powerful tool for the JavaScript community, and an exciting one :) </font></font><br><br><img src="https://habrastorage.org/files/2f6/52a/c99/2f652ac99bf147f385b4fc45b2e22cf6.jpg" align="left"> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the author: Preethi Kasireddy, co-founder and lead engineer of Sapien AI, California</font></font></font> <br clear="all"></div><p>Source: <a href="https://habr.com/ru/post/326394/">https://habr.com/ru/post/326394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326384/index.html">Static analysis ‚Üí vulnerability ‚Üí profit</a></li>
<li><a href="../326386/index.html">What can go wrong on a tour - and how does this relate to the search aggregator</a></li>
<li><a href="../326388/index.html">Implement a custom UI element for timing. Part 2</a></li>
<li><a href="../326390/index.html">Why did it take 100 years to find the exact value of the Planck constant?</a></li>
<li><a href="../326392/index.html">VR development methodology</a></li>
<li><a href="../326396/index.html">Besides science: what else are our students interested in?</a></li>
<li><a href="../326398/index.html">How we build lean manufacturing (Lean) in our company</a></li>
<li><a href="../326400/index.html">Failover Cluster for Load Balancing</a></li>
<li><a href="../326402/index.html">Five principles for creating a secure "connected" car</a></li>
<li><a href="../326404/index.html">Why do some startups win</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>