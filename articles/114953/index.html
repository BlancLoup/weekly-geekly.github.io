<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with structures in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the wake of the recent topic ‚ÄúProcessing large amounts of data in memory in C # ‚Äù I present a translation of the article about structures mentioned...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with structures in C #</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>In the wake of the recent topic</i> <a href="http://habrahabr.ru/blogs/net/114495/"><i>‚ÄúProcessing large amounts of data in memory in C</i> # <i>‚Äù I</i></a> <i>present a translation of the article about structures mentioned there.</i> </blockquote><br>  Structures are the fundamental data types in C # and most other modern programming languages.  At their core, the structures are simple, but you may wonder how quickly work with them can become difficult.  Most often problems arise if you have to work with structures created in other languages ‚Äã‚Äãand stored on disk or obtained as a result of calling functions from libraries or COM objects.  In this article, I mean that you are familiar with the concept of structure, know how to define them and have basic skills of working with structures.  It is assumed that you have an idea of ‚Äã‚Äãhow to call API functions using p / Invoke, as well as marshaling.  In case of uncertainty in your knowledge, you can refer to the documentation. <br>  Many of the techniques described in this article can be extended and applied to any type of data. <br><a name="habracut"></a><br><h4>  Location </h4><br>  In most cases, you can describe and use a structure without knowing how it is implemented ‚Äî especially how its fields are located in memory.  If you have to create a structure for use by other applications, or you have to use someone else's structure, then the memory issues become important.  What do you think, what is the size of the following structure? <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte public int b; // 4 bytes public short c; // 2 bytes public byte d; // 1 byte }</span></span></code> </pre> <br>  The reasonable answer is 8 bytes, just the sum of the sizes of all the fields.  However, if you try to find out the size of the structure: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = Marshal.SizeOf(test);</code> </pre><br>  ... then (in most cases) find that the structure is 12 bytes.  The reason lies in the fact that most processors work better with data that is larger than a byte, and aligned to certain address boundaries.  Pentium prefers data in blocks of 16 bytes aligned to the address boundaries with a size identical to the size of the data itself.  For example, a 4-byte integer should be aligned on a 4-byte boundary.  Detailed details in this case are unimportant.  The important thing is that the compiler will add the missing bytes to align the data within the structure.  You can control this manually, however please note that some processors may return an error if unaligned data is used.  This creates additional problems for users of the .NET Compact Framework ( <i>interesting, many of these? - Lane comment.</i> ). <br><br>  To work you need a link to InteropServices: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices;</code> </pre><br>  For manual arrangement of fields in memory, the StructLayout attribute is used.  For example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte public int b; // 4 bytes public short c; // 2 bytes public byte d; // 1 byte }</span></span></code> </pre><br>  This forces the compiler to place the fields sequentially, in the order of the declaration, which it does by default.  Other attribute values ‚Äã‚Äãare the Auto value, which allows the compiler to determine the order of the fields themselves, and the Explicit value, which allows the programmer to specify the size of each field.  The Explicit type is often used for sequential packing, but in most cases it is easier to use the Pack parameter.  It tells the compiler how much memory should be allocated and how the data should be aligned.  For example, if you specify Pack = 1, then the structure will be organized in such a way that each field will be within one byte and can be read byte by-ie,  no packaging required.  If you change the structure declaration: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, Pack=1)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1</code> </pre><br>  ... then you will find that now the structure occupies exactly 8 bytes, which corresponds to the sequential arrangement of the fields in memory without additional ‚Äúpacking‚Äù bytes.  This is the way to work with most of the structures declared in the Windows API and C / C ++.  In most cases, you will not need to use other values ‚Äã‚Äãfor the Pack parameter.  If you set Pack = 2, then you will find that the structure will occupy 10 bytes, because one byte will be added to each single byte field so that the data can be read in 2 byte chunks.  If you set Pack = 4, the size of the structure will increase to 12 bytes, so that the structure can be read in blocks of 4 bytes.  The parameter value will no longer be taken into account, because the Pack size is ignored if it is equal to or exceeds the alignment used in this processor and is 8 bytes for the Intel architecture.  The location of the structure in memory for different values ‚Äã‚Äãof the Pack is shown in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/09/1c/091c43cf066619f3b90b5ce72142a2ae.jpg"></div><br>  It is also worth mentioning that it can change the way the structure is packaged by changing the order of the fields in it.  For example, when changing the order of the fields to: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte public byte d; // 1 byte public short c; // 2 bytes public int b; // 4 bytes }</span></span></code> </pre><br>  ... the structure does not need packaging, it already takes exactly 8 bytes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  To be precise </h4><br>  If you need to specify exactly how much memory will be allocated for each field, use the location type Explicit.  For example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte [FieldOffset(1)] public int b; // 4 bytes [FieldOffset(5)] public short c; // 2 bytes [FieldOffset(7)] public byte d; // 1 byte }</span></span></code> </pre><br>  So you get an 8-byte structure without additional leveling bytes.  In this case, this is equivalent to using Pack = 1.  However, using Explicit allows you to completely control memory.  For example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte [FieldOffset(1)] public int b; // 4 bytes [FieldOffset(10)] public short c; // 2 bytes [FieldOffset(14)] public byte d; // 1 byte }</span></span></code> </pre><br>  This structure will occupy 16 bytes, along with the extra bytes after field b.  Prior to C # 2.0, the Explicit type was mainly used to specify buffers with fixed sizes when calling third-party functions.  You cannot declare a fixed-length array in a structure because field initialization is prohibited. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> d; }</code> </pre><br>  This code will generate an error.  If you need a 10-byte array, here‚Äôs one way: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; [FieldOffset(<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; [FieldOffset(<span class="hljs-number"><span class="hljs-number">5</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> c; [FieldOffset(<span class="hljs-number"><span class="hljs-number">8</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer; [FieldOffset(<span class="hljs-number"><span class="hljs-number">18</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> d; }</code> </pre><br>  So you leave 10 bytes for the array.  There are a number of interesting nuances.  First, why use an 8 byte offset?  The reason is that you cannot start an array with an odd address.  If you use a 7 byte offset, you will see a runtime error indicating that the structure could not be loaded due to alignment problems.  This is important because when using Explicit you may run into problems if you don‚Äôt understand what you are doing.  The second point is related to the fact that additional bytes are added to the end of the structure, so that the structure size is a multiple of 8 bytes.  The compiler is still involved in how the structure will be located in memory.  Of course, in practice, any external structure that you try to convert to a C # structure must be correctly aligned. <br>  Finally, it is worth mentioning that you cannot access a 10-byte array using the array name (for example, buffer [1]), because C # thinks the value is not assigned to the array.  Therefore, if you cannot use an array and this causes a problem with alignment, it is much better to declare the structure like this: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> struct1 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// 1 byte [FieldOffset(1)] public int b; // 4 bytes [FieldOffset(5)] public short c; // 2 bytes [FieldOffset(7)] public byte buffer; [FieldOffset(18)] public byte d; // 1 byte }</span></span></code> </pre><br>  To access the array, you will need to use arithmetic on pointers, which is unsafe code.  To allocate a fixed number of bytes for the structure, use the Size parameter in the StructLayout attribute: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit, Size=64)</span></span>]</code> </pre><br>  Now in C # 2.0, fixed-size arrays are allowed, so all of the above constructs are generally optional.  It is worth noting that fixed-length arrays use the same mechanism: allocating a fixed number of bytes and pointers (which is also unsafe).  If you need to use arrays to call functions from libraries, perhaps the best way is explicitly marshaling arrays, which is considered ‚Äúsafe‚Äù.  Let's look at all the three mentioned ways. <br><br><h4>  API calls </h4><br>  As an example of a structure that requires alignment, we can use the EnumDisplayDevices function, which is defined as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumDisplayDevices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> LPCTSTR lpDevice, // device name DWORD iDevNum, // display device PDISPLAY_DEVICE lpDisplayDevice, // device information DWORD dwFlags // reserved </span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  It is quite simply converted to C #: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(‚ÄúUser32.dll‚Äù, CharSet=CharSet.Unicode )</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumDisplayDevices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lpDevice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iDevNum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DISPLAY_DEVICE lpDisplayDevice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwFlags</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The DISPLAY_DEVICE structure is defined as: <br><pre> <code class="cs hljs">typedef <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _DISPLAY_DEVICE { DWORD cb; WCHAR DeviceName[<span class="hljs-number"><span class="hljs-number">32</span></span>]; WCHAR DeviceString[<span class="hljs-number"><span class="hljs-number">128</span></span>]; DWORD StateFlags; WCHAR DeviceID[<span class="hljs-number"><span class="hljs-number">128</span></span>]; WCHAR DeviceKey[<span class="hljs-number"><span class="hljs-number">128</span></span>]; } DISPLAY_DEVICE, *PDISPLAY_DEVICE;</code> </pre><br>  It is clear that it contains four character arrays with a fixed length.  Using the Explicit alignment type, we rewrite the structure in C #: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit, Pack = 1,Size=714)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DISPLAY_DEVICE { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cb; [FieldOffset(<span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceName; [FieldOffset(<span class="hljs-number"><span class="hljs-number">68</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceString; [FieldOffset(<span class="hljs-number"><span class="hljs-number">324</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> StateFlags; [FieldOffset(<span class="hljs-number"><span class="hljs-number">328</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceID; [FieldOffset(<span class="hljs-number"><span class="hljs-number">584</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceKey; }</code> </pre><br>  Note the use of the Size parameter to specify the space required to store the DeviceKey field.  Now if we use this structure when calling the function: <br><pre> <code class="cs hljs">DISPLAY_DEVICE info = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DISPLAY_DEVICE(); info.cb = Marshal.SizeOf(info); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = EnumDisplayDevices(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> info, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  ... then all that you can refer to directly is the first characters of the arrays.  For example, a DeviceString contains the first character of a string of device information.  If you want to get the rest of the characters from the array, you need to get a pointer to DeviceString and use pointer arithmetic to go through the array. <br>  When using C # 2.0, the simplest solution is to use arrays in the structure: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, Pack = 1)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DISPLAY_DEVICE { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceName[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceString[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> StateFlags; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceID[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> DeviceKey[<span class="hljs-number"><span class="hljs-number">128</span></span>]; }</code> </pre><br>  Note that the structure must be marked with the unsafe modifier.  Now, after the API call, we can get data from arrays without using pointers.  However, implicitly, they are still used, and any code that accesses arrays should be marked as unsafe. <br>  The third and last method is custom marshaling.  Many C # programmers do not understand that the essence of marshaling is not only how type data is passed to library calls, it is also an active process that copies and modifies managed data.  For example, if you want to pass a reference to a typed array, you can pass it by value, and the system will convert it to a fixed-length array and back to the managed array without further action on your part. <br>  In this case, all we have to do is add the MarshalAs attribute, indicating the type and size of the arrays: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Unicode)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DISPLAY_DEVICE { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cb; [MarshalAs(UnmanagedType.ByValArray, SizeConst=<span class="hljs-number"><span class="hljs-number">32</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] DeviceName; [MarshalAs(UnmanagedType.ByValArray, SizeConst=<span class="hljs-number"><span class="hljs-number">128</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] DeviceString; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> StateFlags; [MarshalAs(UnmanagedType.ByValArray, SizeConst = <span class="hljs-number"><span class="hljs-number">128</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] DeviceID; [MarshalAs(UnmanagedType.ByValArray, SizeConst = <span class="hljs-number"><span class="hljs-number">128</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] DeviceKey; }</code> </pre><br>  In this case, when calling a library function, the fields are transmitted by creating unmanaged arrays of the required length inside the copy of the structure, which is passed to the call.  When the function completes its work, unmanaged arrays are converted into managed character arrays and references to them are assigned to structure fields.  As a result, after the function calls, you will find that the structure contains an array of the right size, filled with data. <br>  In the case of calling functions of third-party libraries, the use of custom marshaling is the best solution, since it uses secure code.  Although calling third-party functions with p / Invoke is not safe in a general sense. <br><br><h4>  Serialization of structures </h4><br>  Now, after we have examined the rather complex issues associated with the placement of structures in memory, it's time to learn how to get all the bytes that make up the structure.  In other words, how to serialize the structure?  There are many ways to do this, the Marshal.AllocHGlobal method is most often used to allocate heap memory for an unmanaged array.  After that, everything is done by memory functions, such as StructToPtr or Copy.  Example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RawSerialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anything</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rawsize = Marshal.SizeOf(anything); IntPtr buffer = Marshal.AllocHGlobal(rawsize); Marshal.StructureToPtr(anything, buffer, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] rawdata = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[rawsize]; Marshal.Copy(buffer, rawdata, <span class="hljs-number"><span class="hljs-number">0</span></span>, rawsize); Marshal.FreeHGlobal(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rawdata; }</code> </pre><br>  In fact, there is no need for so many actions; it is easier to move the structure bytes directly to a byte array without using an intermediate buffer.  The key object in this method is GCHandle.  It will return the Garbage Collector handle, and you can use the AddrOfPinnedObject method to get the starting address of the structure.  The RawSerialize method can be rewritten as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RawSerialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anything</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rawsize = Marshal.SizeOf(anything); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] rawdata = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[rawsize]; GCHandle handle = GCHandle.Alloc(rawdata, GCHandleType.Pinned); Marshal.StructureToPtr(anything, handle.AddrOfPinnedObject(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); handle.Free(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rawdata; }</code> </pre><br>  This method is easier and faster.  You can use the same methods to deserialize data from a byte array into a structure, but it would be more useful to consider solving the problem of reading a structure from a stream. <br><br><h4>  Reading structures from streams </h4><br>  Sometimes there is a need to read a structure, possibly written in another language, into a C # structure.  For example, you need to read a bitmap file that starts with a file header, then a bitmap header, and then the actual bit data.  The file header structure looks like this: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, Pack = 1)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BITMAPFILEHEADER { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Int16 bfType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Int32 bfSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Int16 bfReserved1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Int16 bfReserved2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Int32 bfOffBits; };</code> </pre><br>  A function that will read any stream and return a structure can be written without using generalizations: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadStruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileStream fs, Type t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[Marshal.SizeOf(t)]; fs.Read(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, Marshal.SizeOf(t)); GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned); Object temp = Marshal.PtrToStructure(handle.AddrOfPinnedObject(), t); handle.Free(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre><br>  For data transfer, GCHandle is used here.  New in this code is the use of a parameter indicating the type of structure.  Unfortunately, you cannot use this type for the return value, so after calling the function, you must convert its result: <br><pre> <code class="cs hljs">FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(@‚Äùc:\<span class="hljs-number"><span class="hljs-number">1.b</span></span>mp‚Äù, FileMode.Open, FileAccess.Read); BITMAPFILEHEADER bmFH = (BITMAPFILEHEADER) ReadStruct(fs, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(BITMAPFILEHEADER));</code> </pre><br>  If we want to avoid conversion, then we need to use the generalized method: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T ReadStruct&lt;T&gt; (FileStream fs) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T))]; fs.Read(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T))); GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned); T temp = (T) Marshal.PtrToStructure(handle.AddrOfPinnedObject(), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)); handle.Free(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre><br>  Notice that now we have to convert the object returned by the PtrToStructure method in the method itself, and not in the place of the call, which now looks like this: <br><pre> <code class="cs hljs">BITMAPFILEHEADER bmFH = ReadStruct&lt;BITMAPFILEHEADER&gt;(fs);</code> </pre><br>  It's nice to see how much better the use of the generic method looks. <br><br><h4>  Manual marshaling </h4><br>  Marshaling works so well in the overwhelming number of cases that you can forget about its existence altogether.  However, if you encounter something unusual, you may wonder what happens when the marshaling stops working.  For example, some API calls need to pass a pointer to a pointer to a structure.  You already know how to pass a pointer to a structure ‚Äî it's just passing by reference ‚Äî and therefore it may seem to you that passing a pointer to a pointer is also easy.  However, everything is more complicated than you expect.  Let's get a look. <br>  In the AVIFileCreateStream function, the last two parameters are passed as pointers to the IntPtr and structure, respectively: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(‚Äúavifil32.dll‚Äù)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AVIFileCreateStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr pfile, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr pavi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVISTREAMINFO lParam</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  To call this function, you would write: <br><pre> <code class="cs hljs">result = AVIFileCreateStream(pFile, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> pStream, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Sinfo);</code> </pre><br>  Based on the previous examples, it seems easier to change the transmission of a pointer to a structure by the pointer itself.  It would seem that could be wrong in the following ad: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(‚Äúavifil32.dll‚Äù)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AVIFileCreateStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr pfile, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr pavi, IntPtr lParam</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  However, if you try to transfer the address of the pinned structure: <br><pre> <code class="cs hljs">GCHandle handle = GCHandle.Alloc(Sinfo, GCHandleType.Pinned); result = AVIFileCreateStream(pFile, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> pStream, handle.AddrOfPinnedObject()); handle.Free();</code> </pre><br>  ... you will see an error. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/71/9d/719ddeafd55a2e3d9a41a53cc84f6d20.jpg"></div><br>  The reason for this error is that although you pass a pointer to the address of the beginning of the structure, this structure is located in managed memory, and unmanaged code cannot access it.  We forget that standard marshaling does some more work when creating pointers.  Before you create pointers, for all parameters passed by reference, complete copies are created in unmanaged memory.  After the end of the call, data from unmanaged memory is copied back to managed. <br>  Writing a similar function that does the marshaling job is easy and obviously useful: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MarshalToPointer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { IntPtr buf = Marshal.AllocHGlobal(Marshal.SizeOf(data)); Marshal.StructureToPtr(data, buf, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf; }</code> </pre><br>  Here, IntPtr is simply returned to the area on the heap that contains a copy of the data.  The only bad thing is that you need to remember about freeing the allocated memory: <br><pre> <code class="cs hljs">IntPtr lpstruct = MarshalToPointer(Sinfo); result = AVIFileCreateStream(pFile, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> pStream, lpstruct); Marshal.FreeHGlobal(lpstruct);</code> </pre><br>  The code above works exactly like standard marshaling.  However, do not forget that lpstruct is passed by value as an integer.  In order to copy the result back into the structure, we need another method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MarshalToStruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr buf, Type t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Marshal.PtrToStructure(buf, t); }</code> </pre><br>  Now, after we have implemented the manual marshaling of the pointer into the structure, we need to get a pointer to the pointer to the structure.  Fortunately, we do not need to write new code, because our structure-to-pointer transformation function can convert any data type to an unmanaged pointer ‚Äî including the pointer itself. <br><br>  As an example, take the AVISaveOption function, since  it takes two pointers to the pointer as parameters: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(‚Äúavifil32.dll‚Äù)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AVISaveOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr hWnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uiFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> noStreams, IntPtr ppavi, IntPtr ppOptions</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  In fact, ppavi is a pointer to a handle (which in turn is a pointer), and ppOptions is a pointer to a pointer to a structure.  To call this method, we need a structure: <br><pre> <code class="cs hljs">AVICOMPRESSOPTIONS opts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AVICOMPRESSOPTIONS();</code> </pre><br>  The definition of this structure can be found in the documentation for the standard AVI.  In the next step, we need to get a marshalized pointer to the structure: <br><pre> <code class="cs hljs">IntPtr lpstruct = MarshalToPointer(opts);</code> </pre><br>  ... and then a pointer to a pointer: <br><pre> <code class="cs hljs">IntPtr lppstruct = MarshalToPointer(lpstruct);</code> </pre><br>  ... followed by a pointer to the handle: <br><pre> <code class="cs hljs">IntPtr lphandle = MarshalToPointer(pStream);</code> </pre><br>  Now call the function: <br><pre> <code class="cs hljs">result = AVISaveOptions(m_hWnd, ICMF_CHOOSE_KEYFRAME | ICMF_CHOOSE_DATARATE, <span class="hljs-number"><span class="hljs-number">1</span></span>, lphandle, lppstruct);</code> </pre><br>  ... where other parameters are of no interest, information about them can be found in the documentation. <br><br>  After calling the function, all that remains is to transfer the data from the unmanaged buffer to the structure: <br><pre> <code class="cs hljs">opts = (AVICOMPRESSOPTIONS) MarshalToStruct(lpstruct, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(AVICOMPRESSOPTIONS));</code> </pre><br>  Please note that you need to use a pointer to the structure itself, not a pointer to a pointer!  Well, in the end we release the memory: <br><pre> <code class="cs hljs">Marshal.FreeHGlobal(lpstruct); Marshal.FreeHGlobal(lppstruct); Marshal.FreeHGlobal(lphandle);</code> </pre><br>  All this may seem complicated.  Using pointers to pointers is not a simple thing, which is why C # requires that code that works with pointers is marked unsafe. <br>  On the other hand, the general principles of operation are quite simple.  When you pass something by reference, this content is copied to unmanaged memory, and the address to the new memory location is passed to the function call. <br>  Normally, standard marshaling takes over the work.  However, if you need something beyond this, you can manage all copying manually. </div><p>Source: <a href="https://habr.com/ru/post/114953/">https://habr.com/ru/post/114953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114940/index.html"># 404fest: Section Organization of work</a></li>
<li><a href="../114941/index.html">"Aliketo" - looking for similar things, and sometimes even finds, but only in English</a></li>
<li><a href="../114943/index.html">How did the new website design Expression Engine</a></li>
<li><a href="../114947/index.html">Phonetic algorithms</a></li>
<li><a href="../114950/index.html">Fujitsu introduced a wireless monitor at CeBIT</a></li>
<li><a href="../114955/index.html">Through authorization on your website via Twitter</a></li>
<li><a href="../114958/index.html">Program as a little life</a></li>
<li><a href="../114960/index.html">Web Developer - how to fix View Image Information</a></li>
<li><a href="../114962/index.html">Google Adsense payments can now be received via e-wallet or bank account</a></li>
<li><a href="../114963/index.html">Friendly interface or casualization: good or evil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>