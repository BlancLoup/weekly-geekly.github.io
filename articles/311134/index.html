<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Locks aren't that slow.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Locks in general and mutexes, as their private implementation, have a long history of incorrectly assessing the speed of their work. Back in 1986, Mat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Locks aren't that slow.</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://en.wikipedia.org/wiki/Lock_(computer_science)">Locks</a> in general and mutexes, as their private implementation, have a long history of incorrectly assessing the speed of their work.  Back in 1986, Matthew Dillon <a href="http://groups.google.com/group/net.micro.mac/msg/752d18de371bd65c%3Fdmode%3Dsource">wrote</a> in one of the Usenet conferences: ‚ÄúMost people mistakenly realized that locks are slow.‚Äù  Today, after many years, it can be stated that nothing has changed. <br><br>  Indeed, locks may work slowly on some platforms, or in an extra-competitive code.  And, if you are developing a multi-threaded application, then it is quite possible that sooner or later you will encounter a situation where any one block will consume a lot of resources (most likely due to an error in the code that causes it to call too often).  But all these are special cases that have no relation to the statement ‚Äúlocks are slow‚Äù in the general case.  As we will see below, code with locks can work quite productively. <br><br>  One of the reasons for the misconceptions about the speed of operation of locks is that many programmers do not distinguish between the concepts of ‚Äúlightweight mutex‚Äù and ‚Äúmutex as an object of the OS kernel‚Äù.  <a href="http://preshing.com/20111124/always-use-a-lightweight-mutex">Always use lightweight mutexes</a> .  For example, if you are programming in C ++ on Windows, then your choice is critical sections. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/48c/f35/854/48cf35854bb5b4550495c9b69d87602e.png" alt="image" align="right">  The second reason for errors can serve, paradoxically, as benchmarks.  For example, later in this article we will measure the performance of locks under high load: each thread will require a lock to perform any action, and the locks themselves will be very short (and, as a result, very frequent).  This is normal for an experiment, but this way of writing code is not what you need in a real application. <br><a name="habracut"></a><br>  Locks are criticized for other reasons.  There is a whole family of algorithms and technologies called " <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee418650%2528v%3Dvs.85%2529.aspx">lock-free</a> " programming.  This is an incredibly exciting and challenging development method that can bring a huge performance boost to a range of applications.  I know programmers who spent weeks polishing their ‚Äúlock-free‚Äù algorithms, wrote a million tests on them - and all just to catch the rare bug associated with a certain combination of timings, a few months later.  This combination of danger and reward for it can be very attractive for some programmers (including me).  With the power of ‚Äúlock-free,‚Äù classic locks begin to seem boring, obsolete, and slow. <br><br>  But do not rush to discount them.  One of the good examples where locks are often used and show good performance are memory allocators.  A popular implementation of <a href="http://g.oswego.edu/dl/html/malloc.html">malloc from Doug Lea is</a> often used in game devs.  But it is single-threaded, so we need to protect it with locks.  During an active game, we may well have a situation where several threads access the allocator at a frequency of, say, 15,000 times per second.  During game loading, this figure can reach up to 100,000 times per second.  As you will see later, this is absolutely not a problem for code with locks. <br><br><h3>  Benchmark </h3><br>  In this test, we run a stream that will generate random numbers using the <a href="http://en.wikipedia.org/wiki/Mersenne_twister">Mersenne Vortex</a> algorithm.  In the course of work, he will regularly capture and release the synchronization object.  The time between capture and release will be random, but on average it will tend to the value we set.  For example, imagine that we want to use a lock 15,000 times per second and hold it 50% of the time.  Here is how timeline will look in this case.  Red color means the time when the lock is captured, gray - when free. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/f71/177/309f7117730193628b2e79597e62a4f5.png" alt="image"></div><br>  This is, in essence, the Poisson process.  If we know the average amount of time to generate one random number (and this is, for example, <b>6.349 nanoseconds</b> on a 2.66 GHz quad-core Xeon processor), we can measure the amount of work done in some units, not in seconds.  We can use the technique described in <a href="http://preshing.com/20111007/how-to-generate-random-timings-for-a-poisson-process">my other article</a> to determine the number of work units between capturing and releasing the synchronization object.  Here is an implementation in C ++.  I have omitted some non-essential details, but you can download the full source code <a href="">here</a> . <br><br><pre><code class="cpp hljs">QueryPerformanceCounter(&amp;start); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-comment"><span class="hljs-comment">//      workunits = (int) (random.poissonInterval(averageUnlockedCount) + 0.5f); for (int i = 1; i &lt; workunits; i++) random.integer(); //     workDone += workunits; QueryPerformanceCounter(&amp;end); elapsedTime = (end.QuadPart - start.QuadPart) * ooFreq; if (elapsedTime &gt;= timeLimit) break; //      EnterCriticalSection(&amp;criticalSection); workunits = (int) (random.poissonInterval(averageLockedCount) + 0.5f); for (int i = 1; i &lt; workunits; i++) random.integer(); //     workDone += workunits; LeaveCriticalSection(&amp;criticalSection); QueryPerformanceCounter(&amp;end); elapsedTime = (end.QuadPart - start.QuadPart) * ooFreq; if (elapsedTime &gt;= timeLimit) break; }</span></span></code> </pre> <br>  Now let's imagine that we run two such threads, each on its own processor core.  Each thread will keep blocking 50% of its work time, but if one thread tries to gain access to a critical section while it is being held by another thread, then it will have to wait.  A classic case of struggle for a shared resource. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/67e/a25/62867ea25d83e85356e81acf1e18a42e.png" alt="image"></div><br>  I think this is a fairly realistic example of how locks are used in real applications.  When we run the above code in two threads, we find that each thread spends about 25% of the time waiting and only 75% of the time doing the real work.  Together, the two threads increase performance by <b>1.5 times</b> compared with a single-threaded solution. <br><br>  I ran this test with different variations on a 2.66 GHz quad-core Xeon processor - into 1 stream, into 2 streams, into 4 streams, each on its own core.  I also varied the duration of locking a lock from a degenerate case, where the lock was released immediately, to the opposite face, when the lock took 100% of the time the thread was running.  In all cases, the frequency of capture remained constant - 15,000 times per second. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b18/14b/ca7/b1814bca786d7a488879c198736713a6.png" alt="image"></div><br>  The results were quite interesting.  For a short duration of capture (I would say up to 10% of the time), the system showed an extremely high degree of parallelism.  Not perfect, but close to that.  Locks work fast! <br><br>  To evaluate the results in terms of practical application, I analyzed the work of the memory allocator in a multi-threaded game using a profiler.  As the game progressed, there were about 15,000 calls to the allocator from three threads, blocking took up about 2% of the overall application performance.  This value is in the ‚Äúcomfort zone‚Äù on the left side of the graph. <br><br>  These results also show that as soon as the duration of the operation of the code inside the lock goes to the gracina at 90% of the total time, there is no longer any point in writing multi-threaded code.  A single-threaded application will work faster in this case.  What is even more surprising is the sharp jump in the productivity of 4 flows in the region of 60%.  It was like an anomaly, so I repeated the test several times, tried running the tests in a different order.  But each time it turned out the same thing.  My best guess is that this combination of the number of threads, the duration of locks and the load on the processor brought the Windows scheduler to some extreme mode of operation, but I didn‚Äôt explore it more deeply. <br><br><h3>  Benchmark lock frequency capture </h3><br>  Even a lightweight mutex incurs some overhead.  A pair of lock / unlock operations for the critical section in Windows runs at about 23.5 nanoseconds (on the above processor).  Thus, even 15,000 locks per second do not carry any significant load affecting performance.  But what if we increase the frequency? <br><br>  The above algorithm offers very convenient means of controlling the amount of work performed between the blocking locks.  I conducted another series of tests: from 10 nanoseconds to 31 microseconds between locks, which corresponds to about 32,000 locks per second.  Each test used two streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cb/4f8/7a4/3cb4f87a4a7f7d77ea8eec9fc3341c3e.png" alt="image"></div><br>  As you might imagine, at a very high frequency, the overhead of locks begins to affect the overall performance.  At such frequencies, only a few instructions are executed inside the lock, which is comparable in time to the capture / release of the synchronization object itself.  The good news is that for such short (and therefore simple) operations, it is quite possible to develop and use some lock-free algorithm. <br><br>  At the same time, the results showed that calling locks up to 320,000 times per second (3.1 microseconds between locks) can be quite effective.  In a game dev, a memory allocator can work normally at similar frequencies during game loading.  You still get up to 1.5x gain from multithreading in this case (but only if the duration of the blocking itself is short). <br><br>  We examined a wide range of different cases of using locks: from their very high performance to cases when the very idea of ‚Äã‚Äãmultithreading loses meaning.  An example with the memory allocator in the game engine showed that in real applications, a high frequency of using locks is quite acceptable when certain conditions are met.  With such arguments, no one will be able to simply say unfoundedly that "locks are slow."  Yes, blocking can be used in an inefficient way, but you shouldn‚Äôt live with this fear - fortunately we have profilers who easily identify such problems.  Every time you want to throw yourself headlong into the pool of exciting and dangerous lock-free programming - remember this article and the fact that locks can work quite quickly. <br><br>  The purpose of this article was to return a little bit of respect to locks that they rightly deserve.  I understand that with all the wealth of options for using locks in industrial software, programmers were accompanied by both successes and painful failures in the process of finding a balance of performance.  If you have an example of one or the other - tell about it in the comments. </div><p>Source: <a href="https://habr.com/ru/post/311134/">https://habr.com/ru/post/311134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311122/index.html">How it works: MegaFon card</a></li>
<li><a href="../311124/index.html">Aspirin from setting permissions on a file server</a></li>
<li><a href="../311126/index.html">How it was: reveal the details of Droidcon Moscow 2016</a></li>
<li><a href="../311128/index.html">.Net Core, exchange with 1C over TCP / IP between different devices</a></li>
<li><a href="../311130/index.html">UWP beginner: Responsive Design (VB.NET + C #)</a></li>
<li><a href="../311136/index.html">The Incredible Adventures of Aliens in Y Combinator</a></li>
<li><a href="../311138/index.html">Creating Babylon.js and WebGL based shaders: theory and examples</a></li>
<li><a href="../311140/index.html">Measuring Apache Ignite Cache Performance</a></li>
<li><a href="../311142/index.html">Grouping Fancy Bear uses malware for OS X in cyber attacks</a></li>
<li><a href="../311144/index.html">We integrate messengers (using Slack as an example): GitHub, RSS (in particular, Java), jobs for your request</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>