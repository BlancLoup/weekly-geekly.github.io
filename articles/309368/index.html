<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing Supreme Commander Graphics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Total Annihilation holds a special place in my heart because it was my first RTS; Together with Command & Conquer and Starcraft, this is one of the ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing Supreme Commander Graphics</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/e91/d37/0d7/e91d370d746c4e2690383d072859eac7.jpg"></div><br>  <a href="https://ru.wikipedia.org/wiki/Total_Annihilation">Total Annihilation</a> holds a special place in my heart because it was my first RTS;  Together with <a href="https://ru.wikipedia.org/wiki/Command_%2526_Conquer_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0,_1995)">Command &amp; Conquer</a> and <a href="https://ru.wikipedia.org/wiki/StarCraft">Starcraft,</a> this is one of the very best RTSs released in the second half of the 90s. <br><br>  Ten years later, in 2007, its successor was released: <a href="https://ru.wikipedia.org/wiki/Supreme_Commander">Supreme Commander</a> .  Due to the fact that one of the main creators of Total Annihilation (designer <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25B9%25D0%25BB%25D0%25BE%25D1%2580,_%25D0%259A%25D1%2580%25D0%25B8%25D1%2581_(%25D0%25B3%25D0%25B5%25D0%25B9%25D0%25BC%25D0%25B4%25D0%25B8%25D0%25B7%25D0%25B0%25D0%25B9%25D0%25BD%25D0%25B5%25D1%2580)">Chris Taylor</a> , engine programmer <a href="http://www.mavorsrants.com/">Jonathan Mayor</a> and composer <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2583%25D0%25BB,_%25D0%2594%25D0%25B6%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B8">Jeremy Soul</a> ) worked on the game, the expectations of the fans were very high. <br><br>  Supreme Commander was warmly received by critics and players thanks to its interesting features, such as ‚Äústrategic zoom‚Äù and physically realistic ballistics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's see how the SupCom engine called Moho renders the frame of the game.  <a href="https://github.com/baldurk/renderdoc">RenderDoc</a> does not support games for DirectX 9, so reverse engineering was done using the good old PIX. <br><a name="habracut"></a><br><h1>  Relief structure </h1><br>  Before delving into the issue of frame rendering, it is important to first talk about how the relief is created in SupCom and what technique is used. <br><br>  Here is the 1 for 1 Finn's Revenge fighting card.  This is a top view of the whole map, it looks like this in the game on the minimap: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b70/26d/428/b7026d42889b4fba83f7dcab951d68fc.jpg"></div><br>  Below is the same map from a different angle: <br><br><img src="https://habrastorage.org/files/8b5/a8a/5fe/8b5a8a5fef0749be9d8a2b3bf921a749.jpg"><br><br>  First, the geometry of the terrain is calculated using <a href="http://en.wikipedia.org/wiki/Heightmap">a height map</a> .  The elevation map describes the elevation of the terrain.  White color indicates a high level, and dark - a lower.  For our map, a single-channel image with the size of 513x513 is used, it represents 10x10 km in the game.  SupCom supports much larger maps up to 81x81 km. <br><br><img src="https://habrastorage.org/files/b16/e93/f33/b16e93f3345b4f3e9bae44758084c28e.jpg"><br><br>  So, we have a mesh representing relief.  Then the game imposes an albedo texture combined with a normal texture to cover all of these polygons.  For each map, the sea level is also indicated, so the game modulates the color of the albedo of pixels below the surface of the sea, giving them a blue tint. <br><br>  <em>(Translator's note: more clearly thanks to the animation, the changes here and below are visible in the <a href="http://www.adriancourreges.com/blog/2015/06/23/supreme-commander-graphics-study/">original article</a> .)</em> <br><br><div class="spoiler">  <b class="spoiler_title">Relief</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ecc/52d/30c/ecc52d30c6f847dfbd1c0bd9b60cf339.jpg"><br><br><img src="https://habrastorage.org/files/5e3/895/409/5e3895409e844d86ae3a81c236039d92.jpg"><br><br><img src="https://habrastorage.org/files/fdd/a37/ddd/fdda37ddde7b41199dc72878e1aaab53.jpg"><br></div></div><br>  Well, well, texturing with reference to height is not bad, but it quickly exhausts its limits. <br><br>  How can I add more details and variations to the map? <br><br>  Here we use a technique called <a href="https://en.wikipedia.org/wiki/Texture_splatting">Texture splatting</a> : the game draws sets of additional textures albedo + normals.  Each stage adds a new ‚Äúlayer‚Äù to the relief. <br>  We already have layer 0: relief with original albedo + color textures. <br>  To use the new layer, we need additional information: the weights map telling us where to draw new albedo + normals, and more importantly, where not to draw them!  Without such a scale map, also called an alpha map, when using a new layer, we completely override our previous layer.  When applied to the mesh, the albedo and normal textures have their own scaling factor. <br><br><div class="spoiler">  <b class="spoiler_title">Adding Layers</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b67/9af/aac/b679afaac22f4538bd0a8c3b5330ec6e.jpg"><br><br><img src="https://habrastorage.org/files/605/f41/8f8/605f418f831640a7bf03b118e5230e8d.jpg"><br><br><img src="https://habrastorage.org/files/ba9/239/d38/ba9239d38c8341779a0d7b88ead5d702.jpg"><br><br><img src="https://habrastorage.org/files/3b6/92d/73d/3b692d73d4074b5e9622e83a7669d25f.jpg"><br><br><img src="https://habrastorage.org/files/549/8ac/4fc/5498ac4fca394e9eb286426dcc387e29.jpg"></div></div><br>  So, we applied layers 1, 2, 3 and 4, each of which is based on 3 separate textures.  Albedo and normal textures use 3 channels (RGB) each, and the weights map uses only one.  Therefore, to optimize, 4 weight maps are combined into a single RGBA texture. <br><br><img src="https://habrastorage.org/files/44f/903/b98/44f903b987c84a84a376ea8fb55d8995.jpg"><br><br>  Great, we got more texture variations for the terrain.  It looks good from afar, but if you zoom in, you'll quickly notice a lack of high-resolution details. <br><br>  Therefore, decals come into play: these are small sprites that locally change the albedo color and pixel normal.  There are 861 copies of 21 unique decals on this relief. <br><br><div class="spoiler">  <b class="spoiler_title">Decals</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9e0/b2a/8e0/9e0b2a8e0b76495395aa84d5e488c448.jpg"><br><br><img src="https://habrastorage.org/files/ae8/4de/58e/ae84de58e6684eb9bca036245677291f.jpg"><br><br><img src="https://habrastorage.org/files/1f1/eec/39e/1f1eec39e9794e98b30190113c426555.jpg"></div></div><br>  So much better already, but what about vegetation?  The next step is to add to the relief of what the engine calls Props: models of trees or stones.  There are 6026 copies of 23 unique models on this card. <br><br><div class="spoiler">  <b class="spoiler_title">Props</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/49b/996/cd0/49b996cd0db549db88fca2c52ecdee54.jpg"><br><br><img src="https://habrastorage.org/files/2b6/d32/fb8/2b6d32fb886041b98a2dc3a4e09ef38c.jpg"><br><br><img src="https://habrastorage.org/files/6f8/122/cb4/6f8122cb4da74d8b874f9e0ee5bca88e.jpg"></div></div><br>  And now the final touch: the surface of the sea.  This is a combination of several normal maps with scrolling UV scans in different directions, an environment map for reflections and sprites for waves on the coastline. <br><br><div class="spoiler">  <b class="spoiler_title">Sea surface</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/760/228/598/7602285989754b5586a950b67a8ccf16.jpg"><br><br><img src="https://habrastorage.org/files/110/1eb/336/1101eb336df64e4bad0c2cad2c1dd43b.jpg"><br></div></div><br>  After that, the relief is ready.  Creating good height maps and scales can be a problem for map designers, but, fortunately, there are tools to help with this work: there is an official map editor, the Supcom Map Editor and <a href="http://www.world-machine.com/">World Machine,</a> with even more features. <br><br>  So, now you know the theory of development of the SupCom relief, let's move on to the very frame of the game. <br><br><h1>  Frame breakdown </h1><br>  Here is the frame that we will analyze: <br><br><img src="https://habrastorage.org/files/b3e/560/445/b3e560445dfe45f4bd17e12b596ee5a9.jpg"><br><br><h2>  Clipping on the pyramid of visibility </h2><br>  The game stores in RAM a mesh of a relief created from a height map, it is tessellated by a processor and the position of each vertex is known.  When the zoom level changes, the processor recalculates the tessellation of the terrain. <br><br>  Our camera looks at the scene near the shore.  Rendering the entire relief will be a waste of computational resources, so instead the engine selects a submesh of the entire relief, only the part that is visible to the player, and transfers this smaller data subset to the video processor for rendering. <br><br><div class="spoiler">  <b class="spoiler_title">Submesh isolation</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ac6/839/828/ac68398287f64df2a6cda7069812238e.jpg"><br><br><img src="https://habrastorage.org/files/099/a7e/ea6/099a7eea6c9441249b97947be9c2a637.jpg"></div></div><br><h2>  Normal map </h2><br>  First, only the normals are calculated.  The first pass calculates the normals obtained by combining 5 layers (5 normal maps and 4 weights maps).  Different normal maps are mixed together, all operations are performed in a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2581%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE">tangent space</a> . <br><br><img src="https://habrastorage.org/files/b44/334/ad3/b44334ad36ea4eafb4900ed72f428fb7.jpg"><br><br>  Calculations are performed in one draw call with 6 texture calls.  You may notice that the result looks yellowish, unlike other normal maps, which usually have a blue tint.  And really: here the blue channel is not used at all, there is only red and green. <br><br>  But wait, the normal is a three-component vector, how can it be stored in just two components?  In fact, the compression technique is used (it is discussed at the end of the post). <br><br>  So let's assume for now that the red and green channels contain all the necessary information about the normals. <br><br>  With the layers we‚Äôve finished, it‚Äôs time for the decals: we add relief decals and buildings to change the layer normals. <br><br><div class="spoiler">  <b class="spoiler_title">Decals</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/639/e38/d25/639e38d25e7749a2a622590229654cf5.jpg"><br><br><img src="https://habrastorage.org/files/c0a/a7d/7d5/c0aa7d7d5327473296d9c426478b6e3b.jpg"><br><br><img src="https://habrastorage.org/files/0f6/15f/096/0f615f096e8a4c2dac28183ac3c64bcc.jpg"><br></div></div><br>  We still haven't used the blue channel and alpha channel of our render. <br><br>  So, the game reads from the 512x512 texture, representing all the elevation normals (baked from the original height map), and calculates its normal for each pixel using bicubic interpolation.  Results are stored in blue and alpha channel. <br><br><img src="https://habrastorage.org/files/bc2/af6/9ff/bc2af69ff0524fec9f31c9360abd5187.jpg"><br><br>  The game then combines these two sets of normals (layer / decal normals and relief normals) into final normals used to calculate the illumination. <br><br><img src="https://habrastorage.org/files/0e1/e69/c54/0e1e69c54fca4afdbfbcb4e672c01566.jpg"><br><br>  In this case, no compression is performed: the normals use 3 RGB channels, one for each component. <br><br>  The map may look very green, but this is because the scene is rather flat, so the result is correct: you can take any pixel and calculate its normal vector using the <code>colorRGB * 2.0 - 1.0</code> formula, you can also check that the vector rate is 1. <br><br><h2>  Shadow map </h2><br>  The technique used to render shadows is called <a href="http://www.cg.tuwien.ac.at/research/vr/lispsm/">Light Space Perspective Shadow Maps</a> (LiSPSM).  Here we have only the sun as a source of directional lighting.  Each scene mesh is rendered, and the distance from it to the sun is stored in the red channel of the 1024x1024 texture.  The LiSPSM technique calculates the best projected space to maximize the accuracy of the shadow map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/87a/58c/d03/87a58cd0371e46919de81715f564adc0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a38/b1b/6f8/a38b1b6f83694b489f5781c64bc31c87.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5b2/261/e72/5b2261e7227242d3b879848cdd124109.png"></div><br>  If we dwell on this, we can only draw hard shadows.  In fact, when rendering units, the game tries to smooth out the edges of the shadows using <abbr title="Percentage Closer Filtering">PCF</abbr> sampling. <br><br>  But even with the help of PCF, we still will not be able to achieve such beautiful smoothed shadows that we see in the screenshot, especially the smoothed silhouettes of buildings on the ground ... How to get them? <br><br>  It seems that even in the final stages of the game development process, the problem of implementing shadows was still not resolved.  Here is what Jonathan Mayor said 11 months before the game‚Äôs public release: <br><br><blockquote>  The shadows on these screenshots will not match the final version, and we are still working on them. <br>  [...] <br>  At the moment we have not finished work on the graphics of the game. <br>  <em>Jonathan Mayvore, February 24, 2006</em> </blockquote><br>  Just a month after this announcement, a new amazing shadow mapping technique appeared: <a href="http://www.punkuser.net/vsm/">Variance Shadow Maps (VSM)</a> .  She was able to very effectively render wonderful soft shadows. <br><br>  It seems that the developers of SupCom tried to experiment with this new technique: when decompiling the D3D bytecode, a link to the DepthToVariancePS () function was found, which calculates the version of the shadow map with blur.  Before VSM was invented, shadow maps could not be performed. <br><br>  Here SupCom performs a 5x5 Gaussian blur (horizontal and vertical pass) for the shadow map. <br><br><img src="https://habrastorage.org/files/1ea/e2b/abd/1eae2babd573442d96a270f4520c70b7.jpg"><br><br>  However, the D3D bytecode does not contain instructions for storing the depth and square of the depth (information needed by the VSM technique).  It seems that it is implemented only partially: it is possible that at the final stages of development there was no time to improve the technique, however, the existing code gives quite good results. <br><br>  Note that the pseudo-VSM card was only used to create soft shadows on the ground. <br>  When a shadow needs to be drawn on a unit, this is done using a LiSPSM card with PCF sampling.  You can see the difference in the screenshot below (PCF has strong artifacts on the shadow border): <br><br><img src="https://habrastorage.org/files/075/609/59f/07560959f99343bba1264957a910dce6.jpg"><br><br><h2>  Relief with shadows </h2><br>  Thanks to the generated normal and shadow maps, you can finally begin to render the terrain: a textured mesh with lighting and shadows. <br><br><img src="https://habrastorage.org/files/0e7/19d/11d/0e719d11d3104cb89a3ac01bcdfffe8a.jpg"><br><br><h2>  Decals </h2><br>  After calculation, using the information about the normals of the lighting equation, the components of the albedo decals are drawn. <br><br><div class="spoiler">  <b class="spoiler_title">Decals</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/69e/d50/83f/69ed5083fc1b4723bc48ce6055748ccd.jpg"><br><br><img src="https://habrastorage.org/files/4b3/047/72e/4b304772e70a499a99ed5eca2366a142.jpg"><br><br><img src="https://habrastorage.org/files/2ca/92a/eda/2ca92aeda76b41cca7aa2ada6707d87f.jpg"></div></div><br><h2>  Water reflections </h2><br>  On the right side of the scene we have the sea, so if the robot is in the water, we should see its reflection on the surface of the sea. <br><br>  There is a classic trick for rendering reflections on the surface: an additional pass is performed and the vertical axis is scaled to -1 just before applying the camera transformation, so that the whole scene becomes symmetrical about the water surface (as in a mirror);  It is this transformation that is needed to render the reflection.  SupCom uses this technique and renders all reflected unit meshes onto the reflection map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/907/e5f/0ca/907e5f0ca6f24ac7a117ffce03e95f74.jpg"></div><br><img src="https://habrastorage.org/files/258/310/198/258310198c154cceb3a7cfec8646fe8f.jpg"><br><br><h2>  Mesh rendering </h2><br>  Then all the meshes are rendered in turn.  For vegetation, <a href="https://ru.wikipedia.org/wiki/Geometry_Instancing">duplicate geometry</a> is used to render multiple trees in a single draw call.  The sea is rendered using one quadrilateral with a pixel shader causing multiple normal maps, refraction maps (scenes rendered up to this point), reflection maps (just generated above) and skybox for additional reflections. <br><br><div class="spoiler">  <b class="spoiler_title">Mesh rendering</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/20e/e4f/e59/20ee4fe599f14beb9522294bb7e16ac2.jpg"><br><br><img src="https://habrastorage.org/files/6d5/f77/741/6d5f77741d7c456499b3d35fc00b8bc9.jpg"><br><br><img src="https://habrastorage.org/files/e9d/838/464/e9d83846462d487abef4a2fa5aae1d68.jpg"><br><br><img src="https://habrastorage.org/files/c39/030/84b/c3903084b14d44dea8762c32b324fe0a.jpg"></div></div><br>  Notice that in the last image there are small black artifacts on the sea near the edge of the screen;  they arise from the fact that the sampling of the surface of the water is distorted to create the illusion of movement.  Sometimes distortion introduces texels from outside the viewport, but this information does not exist, so black areas appear. <br><br>  During the game, the UI hides these artifacts behind a thin frame that overlaps the edges of the viewport. <br><br><h2>  Mesh structure </h2><br>  Each unit in SupCom is rendered in one draw call.  The model is determined by a set of textures: <br><br><ul><li>  albedo card </li><li>  normal map </li><li>  A ‚Äúreflection map‚Äù that actually contains more information than just reflections.  This is an RGBA texture containing the following information: <br><br><ul><li>  Red: the amount of reflection of the environment map (Reflection). </li><li>  Green: Specular reflections. </li><li>  Blue: Brightness.  Used later to control the bloom (bloom). </li><li>  Alpha: Team Color.  Changes the unit's albedo depending on the color of the team. </li></ul><br></li></ul><br><img src="https://habrastorage.org/files/249/880/17f/24988017fbea4d9db3ce6a22441e2353.jpg"><br><br><h2>  Particles </h2><br>  Then all particles are rendered, as well as health bars. <br><br><div class="spoiler">  <b class="spoiler_title">Rendering Particles and Health Indicators</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/549/b20/194/549b20194beb48d58e430709ff8c07e9.jpg"><br><br><img src="https://habrastorage.org/files/296/e7e/917/296e7e91753c49cd9f2083a1b6c6bbe0.jpg"><br><br><img src="https://habrastorage.org/files/632/9cb/abb/6329cbabb404470e9c976fa7761977f7.jpg"></div></div><br><h2>  Bloom </h2><br>  It is time to add shine!  But how do we get ‚Äúbrightness information‚Äù if we work with <abbr title="Low dynamic range">LDR</abbr> buffers?  In fact, the brightness map is contained in the alpha channel, it is created at the same time as the previous meshes are drawn.  A copy of a lower quality frame is created, an alpha channel is applied to highlight only bright areas, and then Gaussian blur is performed sequentially. <br><br><img src="https://habrastorage.org/files/7c8/283/5ba/7c82835baae741229e1b05834effb4bd.png"><br><br>  The blur buffer is then drawn over the original scene with additional blending. <br><br><div class="spoiler">  <b class="spoiler_title">Bloom</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ba7/671/606/ba7671606bb74c5bb220d4bd75f65446.jpg"><br><br><img src="https://habrastorage.org/files/92a/e5e/70b/92ae5e70b88d40ff8fb785642ebe1227.jpg"></div></div><br><h1>  User interface </h1><br>  We are done with the main stage.  At the end, the UI is rendered, which is remarkably optimized: the only render call for rendering the entire interface.  1158 triangles are simultaneously transmitted to the GPU. <br><br><div class="spoiler">  <b class="spoiler_title">Ui</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/72b/6af/6a9/72b6af6a973a4a3aaf93137e46e3268a.jpg"><br><br><img src="https://habrastorage.org/files/038/096/276/038096276a0a4c44a4ade5b2701920a2.jpg"></div></div><br>  The pixel shader reads from a single 1024x1024 texture used as a <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2582%25D0%25BB%25D0%25B0%25D1%2581">texture atlas</a> .  When you select another unit, the UI changes and the texture atlas is regenerated ‚Äúon the fly‚Äù to pack a new set of sprites. <br><br>  And on this we completed the analysis of the frame! <br><br><h1>  Additional Information </h1><br><h2>  Level of detail </h2><br>  Since SupCom supports many variations of the zoom level, it actively applies <a href="https://ru.wikipedia.org/wiki/Level_of_Detail">levels of detail</a> (LOD). <br><br>  If a player moves the camera away from the map, the number of visible units quickly increases;  To cope with the increased load on the video processor, it is necessary to render simplified geometry and textures of a smaller size.  Since units are very far away, the engine can drop them: models are replaced by <a href="https://en.wikipedia.org/wiki/Low_poly">low-poly</a> versions with reduced detail, but they are rendered on a screen so small that the player hardly notices differences from high-poly models. <br><br><div class="spoiler">  <b class="spoiler_title">LOD Differences</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/11e/2cc/fd0/11e2ccfd0f0d4e30812b54b757c047df.jpg"><br><br><img src="https://habrastorage.org/files/429/866/928/429866928242491484f05c9f368ea378.jpg"><br><br><img src="https://habrastorage.org/files/c6b/6da/0be/c6b6da0bed2348218cf4adca098ef0d8.jpg"><br><br><img src="https://habrastorage.org/files/24e/e4f/2d3/24ee4f2d349c47a2b96d9436709ba390.jpg"></div></div><br>  LOD is used not only for units: after a certain limit, shadows, decals and props no longer render. <br><br><h2>  Fog of war </h2><br>  Due to the presence of <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D0%25BC%25D0%25B0%25D0%25BD_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B">fog of war,</a> each unit has its own line of sight and only the area next to the units is fully visible.  Areas in which there are no units are filled with gray (opened earlier) or black (not yet investigated). <br><br>  The game stores fog information in a 128x128 single-channel texture, which determines the fog density: 1 means no visibility, and 0 means full visibility. <br><br><img src="https://habrastorage.org/files/fc4/06e/7d8/fc406e7d827c4aabbe192e4c97d088bd.png"><img src="https://habrastorage.org/files/a2e/450/c8d/a2e450c8d7934136a9b4304bf4fc318a.png"><img src="https://habrastorage.org/files/6f9/3cf/a62/6f93cfa627b2421badb1c57692f6d684.png"><br><br><h2>  Normal compression </h2><br>  As I promised, here is a brief explanation of the trick used in SupCom to compress normals.  Normally, the normal is a three-component vector, but in the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2581%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE">tangent space the</a> vector is expressed relative to the tangent to the surface: X and Y are on the tangent plane, and the component Z is always directed from the surface.  By default, the normal is (0, 0, 1);  that is why most normal maps are blue if the directions of the normals are not changed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1bc/efe/d1c/1bcefed1c01a477ca9fb759737d959e9.png"></div><br>  If we assume that the normal is a unit vector, then its length is one: X¬≤ + Y¬≤ + Z¬≤ = 1. <br><br>  If the values ‚Äã‚Äãof X and Y are known, then Z can have only two possible values: Z = ¬± ‚àö (1 - X¬≤ - ‚Äã‚ÄãY¬≤). <br><br>  But since Z is always directed from the surface, it must be positive, i.e.  Z = ‚àö (1 - X¬≤ - ‚Äã‚ÄãY¬≤). <br><br>  That is why it is enough to store the values ‚Äã‚ÄãX and Y in the red and green channels, the value Z can be obtained from them.  A more detailed (and better) explanation can be found in <a href="http://developer.download.nvidia.com/whitepapers/2008/real-time-normal-map-dxt-compression.pdf">this article</a> <em>(in English)</em> . <br><br><h2>  Mixing normals </h2><br>  If we are talking about normals: SupCom performs some kind of <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">lerp</a> between normal maps, using weights maps as coefficients.  In fact, there are several ways to mix two normal maps that give different results;  as explained in <a href="http://blog.selfshadow.com/publications/blending-in-detail/">this article</a> <em>(in English)</em> , this is not such a simple problem. <br><br>  Additional links <br><br><ul><li>  <a href="http://www.mavorsrants.com/">Jonathan Maver's blog</a> has a lot of technical ideas and a very interesting post about <a href="http://www.mavorsrants.com/2012/04/total-annihilation-graphics-engine.html">the TA graphic engine</a> . </li><li>  <a href="http://www.gamespot.com/features/totalstory/">TA development history.</a>  A very interesting piece of reading from 1998, archived in the Wayback Machine. </li><li>  Details on <a href="http://supcom.wikia.com/wiki/Height-_/_Texturemaps_with_image_editing_tools">editing maps</a> and modding SupCom. </li></ul><br>  A detailed discussion of the topic of this article: <a href="http://developers.slashdot.org/story/15/06/26/1550227/reverse-engineering-a-frame-of-supreme-commander">Slashdot</a> , <a href="https://news.ycombinator.com/item%3Fid%3D9770020">Hacker News</a> , <a href="https://www.reddit.com/r/programming/comments/3axbnb/supreme_commander_graphics_study_how_it_renders_a/">Reddit</a> . </div><p>Source: <a href="https://habr.com/ru/post/309368/">https://habr.com/ru/post/309368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309356/index.html">Agile or Lean: Aha aha, what's the difference?</a></li>
<li><a href="../309360/index.html">Igor Ilyunin: ‚ÄúThe customer asked to assemble a team that he did not find in Silicon Valley‚Äù</a></li>
<li><a href="../309362/index.html">And here is IoT</a></li>
<li><a href="../309364/index.html">Cloud Technology Myths. Part 3: Talking about "iron"</a></li>
<li><a href="../309366/index.html">The logic of consciousness. Part 4. The secret of brain memory</a></li>
<li><a href="../309370/index.html">Basics of Serverless Applications in Amazon Web Services</a></li>
<li><a href="../309372/index.html">How to "bleed" programming skills ... with virtually no programming</a></li>
<li><a href="../309376/index.html">SPA is not a silver bullet, or an alternative approach to web development. Part 1</a></li>
<li><a href="../309378/index.html">Tower Defense on the Unity engine - Part 1</a></li>
<li><a href="../309380/index.html">Introduction to GitLab CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>