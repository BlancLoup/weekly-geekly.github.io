<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to debug WebRTC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Voximplant, we have been using WebRTC since its inception: first, as an alternative to Flash for voice and video calls, and then as a complete repl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to debug WebRTC</h1><div class="post__text post__text-html js-mediator-article">  In Voximplant, we have been using WebRTC since its inception: first, as an alternative to Flash for voice and video calls, and then as a complete replacement.  The technology has gone a long and painful path of development, only recently all major browsers began to support it, there are difficulties with transferring the screen, several video streams, and sometimes the browser crashes simply if you turn off and turn on the video stream.  The accumulated experience allows us to translate interesting articles for Habr, and today we pass the word to Li Sylvester from Xirsys, who will talk about debugging (video) calls to Chrome, Firefox, Safari and Edge.  Debugging WebRTC is not easy, we even have special <a href="https://voximplant.com/blog/accessing-webrtc-logs-in-chrome-and-firefox">instructions</a> for logging in popular browsers.  And what Lee has - you will find out under the cut (spoiler: a lot of things, including WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  The dark side of WebRTC </h2><br>  Working in Xirsys, I saw some really cool apps that used WebRTC.  But while a small group of developers are creating high-tech stuff, most programmers can't even start using WebRTC.  Why?  And everything is simple.  It is complicated. <br><br>  Many of us are familiar with a typical web application.  Such an application has a client that sends requests and a server that responds to these requests.  Simple, linear and easily predictable process.  If something goes wrong, we usually know where to look at the logs and what could have happened.  But with WebRTC, things are not so simple. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Asynchrony </h2><br>  If you have ever written a multithreaded application, you probably know about the headache that this development delivers.  Flights, broken memory - but most often just bugs that are hard to find. <br><br>  WebRTC is asynchronous in nature.  And this is not a simple asynchronous AJAX.  To make an analogy, there are several simultaneous AJAX requests that try to reconcile the data on two computers.  This is still entertainment. <br><br><h2>  Mine Bypass NAT Field </h2><br>  Creating web applications comes down to developing something that runs on a server and responds to requests.  The worst thing that can happen is the port that is not open in IPTables.  It is treated in 2 minutes.  What can not be said about WebRTC. <br><br>  Web servers, not even their software, but hardware are devices with public IP addresses.  They are made to be accessible from anywhere.  And WebRTC is made to send and receive data from users' computers.  Which usually have IP addresses 192.168. Something and are not eager to respond to network requests. <br><br>  The authors of WebRTC know about this, so the engine will go through different methods of connection, in an attempt to establish a connection between two computers that are not very suitable for such. <br><br><h2>  Where to start debugging </h2><br>  In this article I tell about the main toolkit for solving the most popular problems.  But before that, let's see how WebRTC normally establishes a connection. <br><br><h2>  How WebRTC connects </h2><br>  All WebRTC connections require ‚Äúlittle help‚Äù from the signaling protocol.  ‚ÄúLittle Help‚Äù is your own server and protocol through which the caller will be able to communicate with the caller before establishing a Peer-to-peer connection. <br><br>  WebRTC will use the signaling protocol to transmit information about IP addresses, capabilities for capturing and reproducing voice and video, network topology, transmitted data. <br><br>  Commonly used protocol is COMET (or SIP - translator's note) and web sockets.  WebRTC does not limit the developers in any way, so you can use what you like, although you can transfer data through Notepad and copy-paste (they did it at one of the workshops, it works - again the translator).  The signaling connected to both computers allows you to start connecting via WebRTC. <br><br><h4>  Offer and answer </h4><br>  WebRTC connections use ‚Äúoffer‚Äù and ‚Äúanswer‚Äù: <br><br><ol><li>  The initiator of the connection creates and sends to the other side the ‚Äúoffer‚Äù. </li><li>  The other party receives the ‚Äúoffer‚Äù, creates the ‚Äúanswer‚Äù and sends it back. </li><li>  The initiator of the connection receives a ‚Äúanswer‚Äù. </li></ol><br>  This is in theory.  In practice, sharing courtesies does not look so easy. <br><br><ol><li>  Before sending the ‚Äúoffer‚Äù, the initiator of the connection creates an instance of the <b>RTCPeerConnection</b> and receives from it the ‚ÄúSDP‚Äù (Session Description Protocol) text packet using <b>rtcPeerConnection.createOffer ()</b> ;  This package describes the capabilities for receiving / transmitting voice and video for the browser. </li><li>  The contents of an SDP packet are set as ‚Äúdescription of the local side of the connection‚Äù using <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  The packet is transmitted to the other side, where its contents are set as ‚Äúdescription of the other side of the connection‚Äù using <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  On the other side of the connection, you create your own SDP packet using <b>rtcPeerConnection.createAnswer ()</b> , its content is set as the ‚Äúdescription of the local connection side‚Äù. </li><li>  The packet is transmitted to the initiator of the connection, which sets its contents as ‚Äúdescription of the other side of the connection‚Äù. </li></ol><br>  And only after all the actions, both connecting parties know each other's capabilities in receiving and sending voice / video. <br><br><h4>  ICE candidates </h4><br>  But there are few opportunities to work with media data.  After all, the contracting parties have not yet said anything about the status of the network. <br><br>  You can find out which video codecs the browser supports and whether there is a camera on the laptop almost instantly.  It takes time to learn your external IP address and the logic of how NAT works, and information about the state of the network is exchanged as this information is received. <br><br>  Thanks to Trickle ICE technology (not supported by all browsers - translator's note), the connection between two WebRTC devices can be established at any time - as soon as a suitable ‚Äúcandidate‚Äù is found. <br><br>  The developer must subscribe to the <b>onicecandidate</b> event (all lower case!) And transfer the received SDP packets to the other side, where they need to be transmitted to WebRTC using the <b>addIceCandidate</b> method (here, surprise, capital letter).  Works both ways. <br><br><h2>  Connection </h2><br>  WebRTC uses things like STUN (Session Traversal Utilities for NAT) and TURN (Traversal Using Relay around NAT) to establish a connection.  It sounds scary, but in fact only two network protocols. <br><br><h4>  STUN server </h4><br>  The first of the two protocols is a bit more complicated than the echo server.  When members of the connection want to describe how to connect to them, they need their public IP address.  And most likely it will not be the IP address of the computer, user devices are rarely allocated public addresses.  The whole NAT technology was invented so as not to highlight.  In order to find out your public address, the browser makes a request to the STUN server.  Passing through NAT, the network packet changes its return address to public.  Upon receiving the packet with the request, the STUN server copies the return address of the packet to its payload and sends the packet back.  Passing through NAT in the opposite direction, the packet loses its public IP address, but a copy of this address remains in payload, where WebRTC can read it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  TURN server </h2><br>  The TURN server uses the STUN protocol extension.  The same packages, headers, plus a new thing: <b>command</b> .  The server is a proxy: both clients connect to it through the UDP port <b>allocation</b> and transmit their data through the server. <br><br>  TURN servers are designed in such a way that the initiator of the connection has more features than the other side.  This leads to an interesting effect when a call through the TURN server is successful or unsuccessful depending on who is calling (everyone remembers Skype - the translator's note). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Debugging </h2><br>  So, you've read this paragraph before.  We are glad with the translator and remember that the article is about debugging WebRTC.  But everything written above is a necessary minimum, without which you can not even begin.  But if you start, and you do not have inhuman luck, then it will break. <br><br>  It will break in many different ways.  The first one: the lack of connection.  You passed both WebRTC STUN and TURN server settings, helped them exchange the offer, answer and ICE candidates, but there was no video or voice.  Where to begin?  With local playback problems. <br><br><h2>  WebRTC local debugging </h2><br>  As I wrote above, the main work of WebRTC takes place on the browser side.  STUN and TURN servers are incredibly simple, so most problems occur in your JavaScript code that runs in two browsers.  Sad but true.  On the other hand, if the most interesting thing happens locally in browsers, then you have extensive debugging capabilities! <br><br>  The first thing to check is your signaling.  It is your code that passes between the browsers audio configuration with video (offer, answer) and information about network settings (ice candidates).  You need to check which packets were sent, which packets were received and transmitted to WebRTC: <br><br><ul><li>  Did the other party get the offer?  Connection initiator received answer?  Connection will not be established without this minimum exchange of courtesies; </li><li>  WebRTC at both ends of the connection handed you packets with ICE candidates?  Did you exchange these packages and pass them back to the opposite side using <b>addIceCandidate</b> ? </li><li>  If everything went well with the packet exchange, was the <b>onaddstream</b> event handler <b>triggered</b> and did you install the resulting object in the HTML element to play the video (or audio)? </li></ul><br>  If the exchange of packages does not cause suspicion, then you can delve into the guts of the session. <br><br><h2>  Session Description Protocol </h2><br>  Offer, Answer and ICE candidate packages are created by WebRTC in SDP text format.  At first glance, the contents of the packages look scary, but with a little preparation you can get a lot of benefit from them during debugging.  Wikipedia describes SDP well, but for you I found a <a href="https://webrtchacks.com/sdp-anatomy/">better description</a> . <br><br>  The most important field in the SDP ICE candidate packages is <b>typ</b> .  For WebRTC, the field can have one of three values: <br><br><ul><li>  typ host; </li><li>  typ srflx; </li><li>  typ relay. </li></ul><br><h4>  typ host </h4><br>  The <b>host</b> type specifies an ICE candidate for a local area connection (WebRTC enumerates several candidates hoping to establish a connection, it is not known in advance what will happen - the translator's note).  Such a connection does not require either STUN or a TURN server, since devices on the local network can often establish network connections directly.  When debugging from a local network, you just have to check and debug the transfer of <b>host</b> packets and make sure that the devices can send UDP packets to each other.  Although there are exceptions, in practice I have seen network configurations in which the browser required a TURN server to connect ... to itself. <br><br><h4>  typ srflx </h4><br>  The combination of the letters "srflx" is decoded as "Server Reflexive" and marks candidates for connection using an external IP address, where a STUN server is enough for connection (using NAT penetration technology, which is successful in about 80% of cases - translator's note). <br><br><h4>  typ relay </h4><br>  ‚ÄúRelay‚Äù marks the connection through the TURN server, which is almost always successful.  It is important to remember that WebRTC is not required to create exactly three different packages with a ‚Äútyp‚Äù field;  how exactly candidates are selected depends on the implementation of WebRTC in a specific browser version. <br><br><h2>  Testing Device Connection </h2><br>  Google offers a special <a href="https://test.webrtc.org/">web application</a> for testing WebRTC connections on your device.  Open the page, click the ‚Äústart‚Äù button and the JavaScript code will try to connect to the Google server using signaling, STUN and Google TURN servers. <br><br><h2>  WebRTC Internals </h2><br>  You inspected all the packages, checked the code, everything looks right, but does not work?  For such cases, Google has provided its Chrome browser with a special section that shows the insides of WebRTC during connection setup and some beautiful graphs in case of successful connection.  To use, open a special technical link in your browser: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  If you already have an application using WebRTC, then you will immediately see a bunch of technical data.  Otherwise, just open another tab and in it something that uses WebRTC.  The tab displays all calls to the <b>RTCPeerConnection</b> object and allows you to see in real time how the connection is established. <br><br><h2>  ICE setup </h2><br>  At the top of the page is the ICE string that was used during connection initialization.  If an error was made during its formation, it will immediately be seen (by ‚ÄúICE-string‚Äù the author has in mind the configuration of the RTCPeerConnection object with the list of STUN and TURN-servers (the 'iceServers' object) - the translator's note).  Perhaps there is no server list?  You must configure an RTCPeerConnection object before you make the first call to <b>createOffer</b> or <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  RTCPeerConnection events </h2><br>  The following internals section shows the calls to the <b>RTCPeerConnection method</b> and the events received from the object in chronological order.  Errors are carefully highlighted in red.  Please note that the red-highlighted <b>addIceCandidateFailed is</b> often not a sign of an error and the connection can normally establish.  If the connection is successful, the last in the list will be the <b>iceconnectionstatechange</b> event with the <b>complete</b> value. <br><br><h2>  'Stats' section </h2><br>  The following section is relevant when the connection is successfully established.  It contains statistics of transmitted data and network delays.  The two most interesting parameters are <b>ssrc</b> and <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , ‚ÄúStream Source‚Äù, marks each of your audio and video tracks.  Displays data transfer statistics and parameters such as <b>round trip time</b> ; </li><li>  <b>bweforvideo</b> , BandWidth Estimate, displays the width of the network channel used. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  GetStats function </h2><br>  Often you will not be able to access the internals page.  For example, when a problem happens to your user.  In this case, you can get the same data as the internals page shows by calling the <b>getStats</b> method on the <b>RTCPeerConnection</b> object.  This method sets up a callback function that will be called by WebRTC every time something interesting happens.  The called function receives an object with the fields that the internals page displays: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Another useful tool is the <b>oniceconnectionstatechange</b> event of an <b>RTCPeerConnection</b> object.  The event handler will receive information about the connection progress.  Possible options: <br><br><ul><li>  <b>new</b> : WebRTC expects candidates from the second side of the connection, which must be added using the <b>addIceCandidate</b> method; </li><li>  <b>checking</b> : WebRTC received candidates from the second side of the connection, compares them with the local ones and iterates over the options; </li><li>  <b>connected</b> : An appropriate pair of candidates is selected and the connection is established.  It is noteworthy that after this, candidates can continue to come, in accordance with the protocol "Trickle ICE"; </li><li>  <b>completed</b> : all candidates received and connection established. </li><li>  <b>disconnected</b> : connection <b>disconnected</b> .  On unstable channels, WebRTC is able to reestablish the connection itself, following the flag of <b>connected</b> ; </li><li>  <b>closed</b> : connection is disconnected and WebRTC no longer works with it. </li></ul><br>  If the connection ended in the <b>failed</b> state, then we can examine the candidates received on both sides and understand why the connection failed.  For example, if one side provided the candidates <b>host</b> and <b>srflx</b> , the other side was <b>host</b> and <b>relay</b> , but the devices were on different networks. <br><br><h2>  Black rectangle instead of video </h2><br>  Often a situation happens when the connection is established, the sound is transmitted, but instead of a video, one or both participants have a black rectangle.  This most often happens if you assign the received object with the video to the HTML element before the connection goes to the <b>completed</b> state. <br><br><h2>  How to poke a wand outside </h2><br>  In addition to the <b>RTCPeerConnection</b> object <b>itself</b> and the internals displayed by the browser, you can use network packet analysis tools such as Wireshark.  These tools are able to display packets used WebRTC-protocols.  For example, Wireshark will show you the contents of the STUN packets in the main window, and you can filter them by typing the keyword ‚Äústun‚Äù in the filter field: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  What to look for in server responses?  If you see only replies with the <b>Binding</b> type, this means support only for STUN (a story about an external IP), and WebRTC can only offer <b>srflx</b> candidates.  If the responses have TURN-specific <b>Allocation</b> and <b>CreatePermission packages</b> , then WebRTC will have the opportunity to try to connect through a proxy server.  The packet sniffer marks successful and unsuccessful <b>Allocation</b> .  If there is no one successful, then the wrong parameters of access to the TURN servers (which are almost always protected with a login and password - the translator's note) are most likely transmitted. <br><br>  If the log has the <b>CreatePermission Success Response</b> package, then it can be assumed that everything is fine with the STUN and TURN configuration.  And if the <b>ChannelBind</b> package is also present, then it was possible to establish a connection to the TURN server at high speed. <br><br><h2>  Cellular Problems </h2><br>  In my practice, many WebRTC solutions that connect over WiFi cannot connect over 3G / 4G.  Running an application on a mobile device is harder to debug: we do not have such a simple packet analyzer as Wireshark, and Safari does not know how to show WebRTC internals.  Logic dictates that if the application works normally over WiFi, then the problem is not in the application itself, but in the cellular connection.  How to debug?  Get a laptop and connect a <a href="https://www.amazon.co.uk/gp/product/B06XC16QC1/ref%3Das_li_qf_asin_il_tl%3Fie%3DUTF8%26tag%3Ddesignrealm-21%26creative%3D6738%26linkCode%3Das2%26creativeASIN%3DB06XC16QC1%26linkId%3Db4dc0bfe06738f54ccd1e16e0f7a4bdd">3G dongle</a> to it.  So you have a packet analyzer and convenient logs, with which you can find the root of all troubles in a reasonable time. <br><br><h2>  findings </h2><br>  Debugging WebRTC is not easy, but if you search well on the Internet, you can find a lot of articles and examples.  If you are working in realtime communications, I recommend that you read the RFC specifications for <a href="https://tools.ietf.org/html/rfc5389">STUN</a> , <a href="https://tools.ietf.org/html/rfc5766">TURN</a> protocols and <a href="https://www.w3.org/TR/webrtc/">WebRTC</a> technology.  The documents are large, but the information contained in them helps to make reliable decisions and answer the question ‚Äúwhy it doesn‚Äôt call‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/417869/">https://habr.com/ru/post/417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417859/index.html">Integration of 3CX with Microsoft Dynamics 365</a></li>
<li><a href="../417861/index.html">Endless pattern based on prime numbers</a></li>
<li><a href="../417863/index.html">Children to order soon? Ethics Council in the UK authorized the genetic engineering of human embryos</a></li>
<li><a href="../417865/index.html">Android accessibility - a wolf in sheep's clothing? Yandex lecture</a></li>
<li><a href="../417867/index.html">How to estimate the duration of an IT project, and when it is not worth doing</a></li>
<li><a href="../417871/index.html">At the finish line of suborbital tourism</a></li>
<li><a href="../417873/index.html">Ways to create popup windows</a></li>
<li><a href="../417875/index.html">Getting out of the rabbit burrow SPA with modern Rails</a></li>
<li><a href="../417877/index.html">How Tinder (slightly) hides your location</a></li>
<li><a href="../417879/index.html">How to take Microsoft exams for free [on the example of a recent competition]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>