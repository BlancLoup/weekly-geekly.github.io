<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Patch gnupg or a pair of RSA-32768 in 106 minutes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fact, patch gnupg and libgcrypt ... 

 Once upon a time, in order to use 8192 and 16384 RSA keys, I relied on the size in keygen.c and the size of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Patch gnupg or a pair of RSA-32768 in 106 minutes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://blog-static.saraeff.net/uploads/2016/02/security_2c4767a5cd807cc8.png" alt="security" width="448" height="274"><br><br>  In fact, patch gnupg and libgcrypt ... <br><br>  Once upon a time, in order to use 8192 and 16384 RSA keys, I relied on the size in keygen.c and the size of the SECMEM buffer next door.  Cases of bygone days, now SECMEM is rendered in config.h and is called <code>SECMEM_BUFFER_SIZE</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, after downloading Veria 2.0.29 under the fresh debian 8.3, for the place of the killed 12th update on Ubuntu on the 14th, I quickly screwed up the key size and buffer size and joyfully generated a key for 1800 minutes on the 5200U for 18 (or 19) minutes, which used to take 45 50 minutes on the P6200. <br><br>  But 32kbit gave me a bunch of errors.  Free time is - we understand. <br><a name="habracut"></a><br>  The first thing that catches your eye is the hard-coded size when selecting SECMEMs.  Here are a few: <br><br>  agent / gpg-agent.c: <code>gcry_control (GCRYCTL_INIT_SECMEM, 32768, 0);</code>  - 4 kilobytes (since this implementation uses the value in bits) <br>  scd / scdaemon.c: <code>gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0);</code> <br>  tools / gpg-check-pattern.c: <code>gcry_control (GCRYCTL_INIT_SECMEM, 4096, 0);</code> <br><br>  In principle, saving memory is a good thing ... on the other hand, if there is enough memory, why not allocate a full volume equal to the constant <code>SECMEM_BUFFER_SIZE</code> . <br><br>  Further, the program is full of places where 4kb keys appear or associated with them (allocating a buffer for reading, or creating a ‚Äúpacket‚Äù for writing), here are a few: <br><br>  agent / command-ssh.c: <code>log_error (_("ssh keys greater than %d bits are not supported\n"), 4096);</code> <br>  g10 / card-util.c: <code>n = get_data_from_file (args, 16384, &amp;data);</code> <br>  g10 / plaintext.c: <code>byte *buffer = xmalloc( 32768 );</code> <br>  common / dns-cert.c: <code>rc=get_dns_cert (argv[1],16384,&amp;iobuf,&amp;fpr,&amp;fpr_len,&amp;url);</code> <br><br>  The very size of the key that the program eats is given in g10 / keygen.c: <br><br> <code>const unsigned maxsize = (opt.flags.large_rsa ? 8192 : 4096);</code> <br> <code>unsigned int nbits, min, def = DEFAULT_STD_KEYSIZE, max=4096;</code> <br> <br>  But, by correcting the gnupg source when generating the RSA-32768 key, we get: <br><blockquote>  gpg: checking the trustdb <br>  gpg: keyring_get_keyblock: read error: Invalid packet <br>  gpg: keyring_get_keyblock failed: Invalid keyring <br>  gpg: failed to rebuild keyring cache: Invalid keyring <br>  gpg: keydb_search failed: Invalid packet <br>  gpg: FB2E6BDF not found public key <br>  gpg: keyring_get_keyblock: read error: Invalid packet <br>  gpg: keydb_get_keyblock failed: Invalid keyring <br>  gpg: keydb_search failed: Invalid keyring <br>  gpg: public key of ultimately trusted key 6146D68D not found <br>  gpg: 3 marginal (s) needed, 1 complete (s) needed, PGP trust model <br>  gpg: keyring_get_keyblock: read error: Invalid packet <br>  gpg: keydb_get_keyblock failed: Invalid keyring <br>  gpg: validate_key_list failed </blockquote><br>  The devil is covered <del>  in details </del>  in libgcrypt: <br><br>  mpi / mpicoder.c: <code>#define MAX_EXTERN_MPI_BITS 16384</code> - packet size in bits. <br><br>  And in some way: <br>  src / secmem.c: <code>#define MINIMUM_POOL_SIZE 16384</code> <br>  src / secmem.c: <code>#define STANDARD_POOL_SIZE 32768</code> <br>  In a certain way, because, as I understood from the code, this is the size of the pool for SECMEM in bytes, in which gnupg initializes its securememory via <code>gcry_control (GCRYCTL_INIT_SECMEM, __, 0);</code> <br><br>  In the end, the modification resulted in such a diff for GnuPG-2.0.29 <br><br><div class="spoiler">  <b class="spoiler_title">gnupg-2.0.29-RSA32k.patch</b> <div class="spoiler_text"><pre> <code class="diff hljs">diff -uraN a/agent/command-ssh.cb/agent/command-ssh.c --- a/agent/command-ssh.c 2015-09-08 14:39:24.000000000 +0200 +++ b/agent/command-ssh.c 2016-02-26 21:46:47.000000000 +0100 @@ -592,7 +592,7 @@ not too large. */ if (mpi_data_size &gt; 520) { - log_error (_("ssh keys greater than %d bits are not supported\n"), 4096); + log_error (_("ssh keys greater than %d bits are not supported\n"), KEY_MAX_SIZE_LOOKSLIKE); err = GPG_ERR_TOO_LARGE; goto out; } diff -uraN a/agent/gpg-agent.cb/agent/gpg-agent.c --- a/agent/gpg-agent.c 2015-09-08 14:39:24.000000000 +0200 +++ b/agent/gpg-agent.c 2016-02-26 21:46:47.000000000 +0100 @@ -233,7 +233,7 @@ /* To avoid surprises we limit the size of the mapped IPC file to this value. Putty currently (0.62) uses 8k, thus 16k should be enough for the foreseeable future. */ -#define PUTTY_IPC_MAXLEN 16384 +#define PUTTY_IPC_MAXLEN KEY_MAX_SIZE_LOOKSLIKE #endif /*HAVE_W32_SYSTEM*/ /* The list of open file descriptors at startup. Note that this list @@ -743,7 +743,7 @@ } /* Initialize the secure memory. */ - gcry_control (GCRYCTL_INIT_SECMEM, 32768, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); maybe_setuid = 0; /* diff -uraN a/agent/protect-tool.cb/agent/protect-tool.c --- a/agent/protect-tool.c 2015-09-08 14:39:24.000000000 +0200 +++ b/agent/protect-tool.c 2016-02-26 21:46:47.000000000 +0100 @@ -1036,7 +1036,7 @@ } setup_libgcrypt_logging (); - gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); opt_homedir = default_homedir (); diff -uraN a/common/dns-cert.cb/common/dns-cert.c --- a/common/dns-cert.c 2015-09-08 14:39:24.000000000 +0200 +++ b/common/dns-cert.c 2016-02-26 21:46:47.000000000 +0100 @@ -305,7 +305,7 @@ printf("CERT lookup on %s\n",argv[1]); - rc=get_dns_cert (argv[1],16384,&amp;iobuf,&amp;fpr,&amp;fpr_len,&amp;url); + rc=get_dns_cert (argv[1],KEY_MAX_SIZE_LOOKSLIKE,&amp;iobuf,&amp;fpr,&amp;fpr_len,&amp;url); if(rc==-1) printf("error\n"); else if(rc==0) diff -uraN a/config.h.in b/config.h.in --- a/config.h.in 2015-09-08 15:30:25.000000000 +0200 +++ b/config.h.in 2016-02-26 21:46:47.000000000 +0100 @@ -608,6 +608,9 @@ /* Size of secure memory buffer */ #undef SECMEM_BUFFER_SIZE +/* Maximum key size or lookslike */ +#undef KEY_MAX_SIZE_LOOKSLIKE + /* defines the filename of the shred program */ #undef SHRED diff -uraN a/configure b/configure --- a/configure 2015-09-08 16:12:06.000000000 +0200 +++ b/configure 2016-02-26 21:46:47.000000000 +0100 @@ -5307,13 +5307,13 @@ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $large_secmem" &gt;&amp;5 $as_echo "$large_secmem" &gt;&amp;6; } if test "$large_secmem" = yes ; then - SECMEM_BUFFER_SIZE=65536 + SECMEM_BUFFER_SIZE=262144 else - SECMEM_BUFFER_SIZE=32768 + SECMEM_BUFFER_SIZE=262144 fi - cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF #define SECMEM_BUFFER_SIZE $SECMEM_BUFFER_SIZE +#define KEY_MAX_SIZE_LOOKSLIKE 32768 _ACEOF diff -uraN a/configure.ac b/configure.ac --- a/configure.ac 2015-09-08 14:39:24.000000000 +0200 +++ b/configure.ac 2016-02-26 21:46:47.000000000 +0100 @@ -183,12 +183,15 @@ large_secmem=$enableval, large_secmem=no) AC_MSG_RESULT($large_secmem) if test "$large_secmem" = yes ; then - SECMEM_BUFFER_SIZE=65536 + SECMEM_BUFFER_SIZE=262144 else - SECMEM_BUFFER_SIZE=32768 + SECMEM_BUFFER_SIZE=262144 fi AC_DEFINE_UNQUOTED(SECMEM_BUFFER_SIZE,$SECMEM_BUFFER_SIZE, [Size of secure memory buffer]) + +AC_DEFINE_UNQUOTED(KEY_MAX_SIZE_LOOKSLIKE,32768, + [Maximum key size or lookslike]) # Allow disabling of bzib2 support. diff -uraN a/doc/gnupg.info-1 b/doc/gnupg.info-1 --- a/doc/gnupg.info-1 2015-09-08 16:15:29.000000000 +0200 +++ b/doc/gnupg.info-1 2016-02-26 21:46:47.000000000 +0100 @@ -2552,7 +2552,7 @@ max-cert-size When retrieving a key via DNS CERT, only accept keys up to - this size. Defaults to 16384 bytes. + this size. Defaults to 32768 bytes. debug Turn on debug output in the keyserver helper program. Note diff -uraN a/doc/gpg.texi b/doc/gpg.texi --- a/doc/gpg.texi 2015-09-08 14:39:24.000000000 +0200 +++ b/doc/gpg.texi 2016-02-26 21:46:47.000000000 +0100 @@ -1645,7 +1645,7 @@ @ifclear gpgtwoone @item max-cert-size When retrieving a key via DNS CERT, only accept keys up to this size. - Defaults to 16384 bytes. + Defaults to 32768 bytes. @end ifclear @item debug diff -uraN a/g10/card-util.cb/g10/card-util.c --- a/g10/card-util.c 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/card-util.c 2016-02-26 21:46:47.000000000 +0100 @@ -946,7 +946,7 @@ { for (args++; spacep (args); args++) ; - n = get_data_from_file (args, 16384, &amp;data); + n = get_data_from_file (args, KEY_MAX_SIZE_LOOKSLIKE, &amp;data); if (n &lt; 0) return -1; } @@ -1285,7 +1285,7 @@ ask_card_keysize (int keyno, unsigned int nbits) { unsigned int min_nbits = 1024; - unsigned int max_nbits = 4096; + unsigned int max_nbits = KEY_MAX_SIZE_LOOKSLIKE; char *prompt, *answer; unsigned int req_nbits; diff -uraN a/g10/gpg.hb/g10/gpg.h --- a/g10/gpg.h 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/gpg.h 2016-02-26 21:46:47.000000000 +0100 @@ -35,7 +35,7 @@ /* Number of bits we accept when reading or writing MPIs. */ -#define MAX_EXTERN_MPI_BITS 16384 +#define MAX_EXTERN_MPI_BITS KEY_MAX_SIZE_LOOKSLIKE /* The maximum length of a binary fingerprints. */ #define MAX_FINGERPRINT_LEN 20 diff -uraN a/g10/keygen.cb/g10/keygen.c --- a/g10/keygen.c 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/keygen.c 2016-02-26 21:46:47.000000000 +0100 @@ -1429,7 +1429,7 @@ PKT_secret_key *sk; PKT_public_key *pk; gcry_sexp_t s_parms, s_key; - const unsigned maxsize = (opt.flags.large_rsa ? 8192 : 4096); + const unsigned maxsize = KEY_MAX_SIZE_LOOKSLIKE; assert (is_RSA(algo)); @@ -1798,7 +1798,7 @@ static unsigned ask_keysize (int algo, unsigned int primary_keysize) { - unsigned int nbits, min, def = DEFAULT_STD_KEYSIZE, max=4096; + unsigned int nbits, min, def = DEFAULT_STD_KEYSIZE, max=KEY_MAX_SIZE_LOOKSLIKE; int for_subkey = !!primary_keysize; int autocomp = 0; diff -uraN a/g10/keyserver.cb/g10/keyserver.c --- a/g10/keyserver.c 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/keyserver.c 2016-02-26 21:46:47.000000000 +0100 @@ -94,7 +94,7 @@ struct keyserver_spec *keyserver); /* Reasonable guess */ -#define DEFAULT_MAX_CERT_SIZE 16384 +#define DEFAULT_MAX_CERT_SIZE KEY_MAX_SIZE_LOOKSLIKE static size_t max_cert_size=DEFAULT_MAX_CERT_SIZE; diff -uraN a/g10/parse-packet.cb/g10/parse-packet.c --- a/g10/parse-packet.c 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/parse-packet.c 2016-02-26 21:46:47.000000000 +0100 @@ -1681,7 +1681,7 @@ --*length; nbits |= c; - if (nbits &gt; 16384) + if (nbits &gt; KEY_MAX_SIZE_LOOKSLIKE) { log_error ("mpi too large (%u bits)\n", nbits); return NULL; diff -uraN a/g10/plaintext.cb/g10/plaintext.c --- a/g10/plaintext.c 2015-09-08 14:39:24.000000000 +0200 +++ b/g10/plaintext.c 2016-02-26 21:46:47.000000000 +0100 @@ -225,9 +225,9 @@ } } else { /* binary mode */ - byte *buffer = xmalloc( 32768 ); + byte *buffer = xmalloc( KEY_MAX_SIZE_LOOKSLIKE ); while( pt-&gt;len ) { - int len = pt-&gt;len &gt; 32768 ? 32768 : pt-&gt;len; + int len = pt-&gt;len &gt; KEY_MAX_SIZE_LOOKSLIKE ? KEY_MAX_SIZE_LOOKSLIKE : pt-&gt;len; len = iobuf_read( pt-&gt;buf, buffer, len ); if( len == -1 ) { rc = gpg_error_from_syserror (); @@ -294,7 +294,7 @@ } } else { /* binary mode */ - byte *buffer = xmalloc( 32768 ); + byte *buffer = xmalloc( KEY_MAX_SIZE_LOOKSLIKE ); int eof_seen = 0; while ( !eof_seen ) { @@ -304,10 +304,10 @@ * off and therefore we don't catch the boundary. * So, always assume EOF if iobuf_read returns less bytes * then requested */ - int len = iobuf_read( pt-&gt;buf, buffer, 32768 ); + int len = iobuf_read( pt-&gt;buf, buffer, KEY_MAX_SIZE_LOOKSLIKE ); if( len == -1 ) break; - if( len &lt; 32768 ) + if( len &lt; KEY_MAX_SIZE_LOOKSLIKE ) eof_seen = 1; if( mfx-&gt;md ) gcry_md_write ( mfx-&gt;md, buffer, len ); diff -uraN a/scd/apdu.cb/scd/apdu.c --- a/scd/apdu.c 2015-09-08 14:39:24.000000000 +0200 +++ b/scd/apdu.c 2016-02-26 21:46:47.000000000 +0100 @@ -2964,7 +2964,7 @@ if (opt.ctapi_driver &amp;&amp; *opt.ctapi_driver) { - int port = portstr? atoi (portstr) : 32768; + int port = portstr? atoi (portstr) : KEY_MAX_SIZE_LOOKSLIKE; if (!ct_api_loaded) { @@ -3612,7 +3612,7 @@ else if (extended_mode &lt; 0) { /* Send APDU using chaining mode. */ - if (lc &gt; 16384) + if (lc &gt; KEY_MAX_SIZE_LOOKSLIKE) return SW_WRONG_LENGTH; /* Sanity check. */ if ((class&amp;0xf0) != 0) return SW_HOST_INV_VALUE; /* Upper 4 bits need to be 0. */ diff -uraN a/scd/command.cb/scd/command.c --- a/scd/command.c 2015-09-08 14:39:24.000000000 +0200 +++ b/scd/command.c 2016-02-26 21:46:47.000000000 +0100 @@ -45,13 +45,13 @@ #define MAXLEN_PIN 100 /* Maximum allowed size of key data as used in inquiries. */ -#define MAXLEN_KEYDATA 4096 +#define MAXLEN_KEYDATA KEY_MAX_SIZE_LOOKSLIKE /* Maximum allowed total data size for SETDATA. */ -#define MAXLEN_SETDATA 4096 +#define MAXLEN_SETDATA KEY_MAX_SIZE_LOOKSLIKE /* Maximum allowed size of certificate data as used in inquiries. */ -#define MAXLEN_CERTDATA 16384 +#define MAXLEN_CERTDATA KEY_MAX_SIZE_LOOKSLIKE #define set_error(e,t) assuan_set_error (ctx, gpg_error (e), (t)) diff -uraN a/scd/scdaemon.cb/scd/scdaemon.c --- a/scd/scdaemon.c 2015-09-08 14:39:24.000000000 +0200 +++ b/scd/scdaemon.c 2016-02-26 21:46:47.000000000 +0100 @@ -497,7 +497,7 @@ } /* initialize the secure memory. */ - gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); maybe_setuid = 0; /* diff -uraN a/sm/gpgsm.cb/sm/gpgsm.c --- a/sm/gpgsm.c 2015-09-08 14:39:24.000000000 +0200 +++ b/sm/gpgsm.c 2016-02-26 21:46:47.000000000 +0100 @@ -965,7 +965,7 @@ /* Initialize the secure memory. */ - gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); maybe_setuid = 0; /* diff -uraN a/tools/gpg-check-pattern.cb/tools/gpg-check-pattern.c --- a/tools/gpg-check-pattern.c 2015-09-08 14:39:24.000000000 +0200 +++ b/tools/gpg-check-pattern.c 2016-02-26 21:46:47.000000000 +0100 @@ -179,7 +179,7 @@ } setup_libgcrypt_logging (); - gcry_control (GCRYCTL_INIT_SECMEM, 4096, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); opt.homedir = default_homedir (); diff -uraN a/tools/make-dns-cert.cb/tools/make-dns-cert.c --- a/tools/make-dns-cert.c 2015-09-01 08:52:21.000000000 +0200 +++ b/tools/make-dns-cert.c 2016-02-26 21:46:47.000000000 +0100 @@ -64,7 +64,7 @@ goto fail; } - if(statbuf.st_size&gt;16384) + if(statbuf.st_size&gt;KEY_MAX_SIZE_LOOKSLIKE) fprintf(stderr,"Warning: key file %s is larger than the default" " GnuPG max-cert-size\n",keyfile); diff -uraN a/tools/symcryptrun.cb/tools/symcryptrun.c --- a/tools/symcryptrun.c 2015-09-08 14:39:24.000000000 +0200 +++ b/tools/symcryptrun.c 2016-02-26 21:46:47.000000000 +0100 @@ -999,7 +999,7 @@ NEED_LIBGCRYPT_VERSION, gcry_check_version (NULL) ); } setup_libgcrypt_logging (); - gcry_control (GCRYCTL_INIT_SECMEM, 16384, 0); + gcry_control (GCRYCTL_INIT_SECMEM, SECMEM_BUFFER_SIZE, 0); /* Tell simple-pwquery about the the standard socket name. */ {</code> </pre><br></div></div><br><br>  <em>The maximum certificate and key size for ssh has been increased to the heap.</em> <br><br>  And such a diff for libgcrypt-1.6.5 <br><br><div class="spoiler">  <b class="spoiler_title">libgcrypt-1.6.5-RSA32k.patch</b> <div class="spoiler_text"><pre> <code class="diff hljs">diff -uraN a/mpi/mpicoder.cb/mpi/mpicoder.c --- a/mpi/mpicoder.c 2015-02-23 11:55:58.000000000 +0100 +++ b/mpi/mpicoder.c 2016-02-25 17:45:29.000000000 +0100 @@ -27,7 +27,7 @@ #include "mpi-internal.h" #include "g10lib.h" -#define MAX_EXTERN_MPI_BITS 16384 +#define MAX_EXTERN_MPI_BITS 32768 /* Helper used to scan PGP style MPIs. Returns NULL on failure. */ static gcry_mpi_t diff -uraN a/src/secmem.cb/src/secmem.c --- a/src/secmem.c 2016-02-09 10:10:38.000000000 +0100 +++ b/src/secmem.c 2016-02-25 17:45:29.000000000 +0100 @@ -45,8 +45,8 @@ #define MAP_ANONYMOUS MAP_ANON #endif -#define MINIMUM_POOL_SIZE 16384 -#define STANDARD_POOL_SIZE 32768 +#define MINIMUM_POOL_SIZE 32768 +#define STANDARD_POOL_SIZE 65536 #define DEFAULT_PAGE_SIZE 4096 typedef struct memblock</code> </pre><br><br></div></div><br>  Pool size has been doubled.  For almost bezlukova 16384 keys, the size of the pool was 32768 (with a key rate of 4096 and 8192). <br><br>  Does this work? <br><br>  Yes: <br><blockquote>  sec 32768R / 18B54A62 2016-02-24 <br><br>  uid test32768key <br><br>  ssb 32768R / 1507CD2A 2016-02-24 </blockquote><br>  Productivity on i5-5200 under Debian 8.3 (4.3.0-0.bpo.1-amd64 # 1 SMP Debian 4.3.3-7 ~ bpo8 + 1 (2016-01-19) x86_64 GNU / Linux): <br><blockquote>  RSA 16384 - 19 minutes (pair generation time) <br><br>  RSA 32768 - 106 minutes (pair generation time) </blockquote><br>  Encrypting a file of 12MB in size (another RSA-32768 key, during the tests and writing, I downloaded 10 pieces of them): <br><blockquote>  time gpg2 --out file.gz.enc --recipient "test32768pair" --encrypt file.gz <br><br>  real 0m0.079s <br><br>  user 0m0.072s <br><br>  sys 0m0.004s </blockquote><br>  Decryption: <br><blockquote>  time gpg2 --out file.gz.gz --decrypt file.gz.enc <br><br>  real 0m7.610s <br><br>  user 0m5.624s <br><br>  sys 0m0.024s </blockquote><br>  And check: <br><blockquote>  7ab98fd4a154fad5f5bbe0d698178783cd2ac994 file.gz <br><br>  9773bb1b9d7f75f408f562d476e8936aafa0f3b9 file.gz.enc <br><br>  7ab98fd4a154fad5f5bbe0d698178783cd2ac994 file.gz.gz </blockquote><br>  Subtleties: if you add such a key to the keyring, then the vanilla version will not read, as described above (mpi, etc.).  So when using this version (modified) and using vanilla software (which works with classic keys), you need to create a separate keyring. <br><br>  Well, as usual: LOSS OF DATA, Crash Systems and Red Eyes are POSSIBLE. <br><br>  Links to the project and patches (= diff) on github: <br><ul><li>  <a href="https://github.com/nikitasius/GnuPG/tree/2.0.29-RSA32k">GnuPG-2.0.29-RSA32k</a> </li><li>  <a href="https://github.com/nikitasius/libgcrypt/tree/1.6.5-RSA32k">libgcrypt-1.6.5-RSA32k</a> </li></ul><br>  Good luck and in the presence of questions I am ready to answer them, with my two years of experience C which was 15 years ago! <br><br>  Just listen to comments on improving the modification. <br><br>  <strong>Question</strong> : why RSA-32768, you that RSA- (2048 | 4096 | 8192 | 16384) is not enough? <br><br>  <strong>Answer</strong> : because <em>* you can</em> ! <br><br>  * Modern hardware allows itself to work with large keys without tangible problems.  Even notebook.  I will not invoke RSA-32768, but it‚Äôs a good idea to have such a big key and a pack of sub-keys, as well as to encrypt especially critical data, until the great Quantum <em>Computer</em> has <em>conquered the</em> world of prime numbers! </div><p>Source: <a href="https://habr.com/ru/post/278051/">https://habr.com/ru/post/278051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278041/index.html">Personalize IMGUI and Unity Editor. Part one</a></li>
<li><a href="../278043/index.html">The story of the endless city. On Three.js</a></li>
<li><a href="../278045/index.html">Configuring fault tolerance in 3CX Version 14</a></li>
<li><a href="../278047/index.html">jsPDF + canvas: export to PDF of a multipage table in Russian</a></li>
<li><a href="../278049/index.html">How to create your own Dependency Injection Container</a></li>
<li><a href="../278053/index.html">Apple hired the author Signal</a></li>
<li><a href="../278055/index.html">A little about data storage and experience 1cloud</a></li>
<li><a href="../278069/index.html">Machine Learning: Questions and Answers</a></li>
<li><a href="../278071/index.html">Citrix Tech Exchange Moscow 2016: how it changed my attitude to Xen</a></li>
<li><a href="../278073/index.html">[ScanDoc] preprocessing scans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>