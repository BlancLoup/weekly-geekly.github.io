<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive applications with Model-View-Intent. Part 1: Model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When working with the Android platform, I ran into a lot of problems because I designed my models incorrectly. My applications were not reactive enoug...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive applications with Model-View-Intent. Part 1: Model</h1><div class="post__text post__text-html js-mediator-article">  When working with the Android platform, I ran into a lot of problems because I designed my models incorrectly.  My applications were not reactive enough.  Now using RxJava and Model-View-Intent (MVI), I finally achieved the desired level of reactivity.  About this I am writing a series of articles.  In the first part I will talk about the model and explain how it is important. <a name="habracut"></a><br><br>  What did I mean when I said that I designed the models incorrectly?  Many architectural patterns separate the ‚ÄúView‚Äù from the ‚ÄúModel‚Äù.  The most popular in the development of Android - Model-View-Controller (MVC), Model-View-Presenter (MVP) and Model-View-ViewModel (MVVM).  By name it is clear that they all use the ‚ÄúModel‚Äù.  I realized that most of the time I didn‚Äôt have a model at all. <br><br>  Example.  The task is to download a list of people from the server.  The ‚Äútraditional‚Äù implementation of MVP looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsPresenter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsView</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ getView().showLoading(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ProgressBar   backend.loadPersons(new Callback(){ public void onSuccess(List&lt;Person&gt; persons){ getView().showPersons(persons); //      } public void onError(Throwable error){ getView().showError(error); //       } }); } }</span></span></code> </pre> <br>  What is a model and where is it?  A model is not a backend or List that we receive.  This is the entity that the View displays along with other load indicators or error messages.  From my point of view, the model should look like this: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //          final boolean loading; final List&lt;Person&gt; persons; final Throwable error; public(boolean loading, List&lt;Person&gt; persons, Throwable error){ this.loading = loading; this.persons = persons; this.error = error; } }</span></span></code> </pre><br>  And then Presenter can be implemented as follows: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsPresenter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Presenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsView</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ getView().render( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonsModel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">//  ProgressBar backend.loadPersons(new Callback(){ public void onSuccess(List&lt;Person&gt; persons){ getView().render( new PersonsModel(false, persons, null) ); //    } public void onError(Throwable error){ getView().render( new PersonsModel(false, null, error) ); //     } }); } }</span></span></code> </pre><br>  Now View has a model that is displayed on the screen. <br><br>  The first definition of MVC was proposed by Trygve Reenskaug in 1979.  It reflects a similar idea: View observes how the model changes.  The researchers described the term MVC a large number of templates that do not fall under the formulation of Reenskaug.  For example, server developers use MVC frameworks, iOS has a ViewController.  There are questions: <br><br><ul><li>  What does MVC mean in Android? </li><li>  Activity - controller? </li><li>  What is ClickListener? </li></ul><br>  Today, the term MVC is used and interpreted incorrectly, so we will suspend the discussion so that it does not get out of control.  Let's return to my initial statement.  In the development of Android, we face a number of problems that can be avoided using the model: <br><br><ol><li>  Condition problem </li><li>  Screen orientation changes. </li><li>  Backsight navigation. </li><li>  Death process. </li><li>  Immutability and unidirectional data flow. </li><li>  Debugging and playback of states. </li><li>  Testability </li></ol><br>  Let's see how the ‚Äútraditional‚Äù implementation of MVP and MVVM copes with problems, and how the model eliminates common errors. <br><br>  <b>Condition problem</b> <br><br>  Reactive applications are a trendy definition of UI applications that respond to state changes.  The condition is what we see on the screen.  For example, the loading state when View displays the ProgressBar.  As frontend developers, we tend to focus on the UI: a good UI determines how successful the application is, how many people will use it. <br><br>  Take another look at the Presenter code above - not the one that uses PersonsModel.  The presenter determines the state of the UI, it is he who tells View what to display.  The same applies to MVVM.  In this article, I highlight two implementations of MVVM: one uses Android Data Binding, the other RxJava.  In MVVM with Data Binding the state is in ViewModel: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsViewModel</span></span></span><span class="hljs-class"> </span></span>{ ObservableBoolean loading; <span class="hljs-comment"><span class="hljs-comment">// ...       public void load(){ loading.set(true); backend.loadPersons(new Callback(){ public void onSuccess(List&lt;Person&gt; persons){ loading.set(false); // ...  ,    } public void onError(Throwable error){ loading.set(false); // ...  ,      } }); } }</span></span></code> </pre><br>  In MVVM with RxJava, we do not use the Data Binding mechanism, but associate Observable with UI widgets in View: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RxPersonsViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PublishSubject&lt;Boolean&gt; loading; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PublishSubject&lt;List&lt;Person&gt; persons; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PublishSubject loadPersonsCommand; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RxPersonsViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ loadPersonsCommand.flatMap(ignored -&gt; backend.loadPersons()) .doOnSubscribe(ignored -&gt; loading.onNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)) .doOnTerminate(ignored -&gt; loading.onNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) .subscribe(persons) <span class="hljs-comment"><span class="hljs-comment">//      } public Observable&lt;Boolean&gt; loading(){ return loading; } public Observable&lt;List&lt;Person&gt;&gt; persons(){ return persons; } //       (   onNext())  Persons public PublishSubject loadPersonsCommand(){ return loadPersonsCommand; } }</span></span></code> </pre><br>  Code examples are not perfect, your implementation may look different.  The main thing is that in MVP and MVVM state is controlled by a Presenter or ViewModel.  What this leads to: <br><br>  1. Business logic has its own state, just like Presenter or ViewModel.  You are trying to synchronize the state of business logic and Presenter so that they are the same.  Set the visibility of a widget directly to View, or Android itself restores the state from the bundle during the re-creation. <br><br>  2. Presenter and ViewModel have an arbitrary number of input points.  View triggers the event that Presenter handles.  But Presenter also has many output channels - like view.showLoading () or view.showError () in MVP.  And ViewModel offers multiple Observables.  This leads to conflicting states of View, Presenter, and business logic, especially when working with multiple threads. <br><br>  At best, visual errors will appear, for example, the display of the loading indicator (loading status) and the error indicator (error status) at the same time. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zCwESjEpNdk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In the worst case, in the crash reporting tool ‚Äî for example, in Crashlytics ‚Äî you will get a bug report that you cannot reproduce and fix quickly. <br><br>  Consider a situation where we have a single source of state, transmitted from the bottom up - from business logic to View.  We already saw a similar idea at the beginning of the article when we talked about the model. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonsModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> loading; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Person&gt; persons; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Throwable error; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> loading, List&lt;Person&gt; persons, Throwable error){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loading = loading; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.persons = persons; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = error; } }</code> </pre><br>  The model reflects the state - if you understand this, you will avoid many state-related problems.  Presenter will have only one output source: getView (). Render (PersonsModel).  This reflects the simple mathematical function f (x) = y.  There may be several input values, for example f (a, b, c), but the output will always be one. <br><br>  Not everyone likes mathematics, but mathematicians, unlike programmers, do not know what a bug is.  Understanding the essence of the model and how to properly form it is very important: it solves the problem of state. <br><br>  <b>Screen orientation changes</b> <br><br>  In Android, changing the screen orientation is a difficult problem.  Of course, you can ignore it and reboot everything at every turn of the screen.  Most of the time your application is offline, and data comes from a local database or another local cache.  As a result, after changing the screen orientation, data loads very quickly. <br><br>  However, I personally do not like to see the download indicator even for a few milliseconds, because, in my opinion, this does not look like a smooth interface .. Therefore, developers use MVP with retain presenter.  While the screen is rotated, the View can be separated (and deleted), while the Presenter continues to exist in memory and the View is attached again to it. <br><br>  The same idea is possible when using MVVM with RxJava.  But as soon as View unsubscribe from its ViewModel, observable stream - the observed stream - is destroyed.  This can be avoided using Subjects.  In MVVM with Data Binding, a ViewModel is directly connected to the View by the Data Binding mechanism.  To avoid memory leaks, you need to destroy the ViewModel when the screen orientation changes. <br><br>  The main problem with the retain presenter or ViewModel is how to return the View state to what it was before turning the screen so that View and Presenter were in the same state again?  I wrote the Mosby MVP library, it includes the ViewState component, which synchronizes the state of your business logic and View.  Moxy, another MVP library, uses commands and reproduces the View state after the screen orientation has changed: <br><img src="https://habrastorage.org/files/a2e/b51/8b4/a2eb518b465a4df9b47e68794519270d.gif" alt="image"><br>  There are other solutions to the View state problem.  Let's take a step back and summarize: all these libraries are trying to solve the state problem. <br><br>  So again: if we have one ‚ÄúModel‚Äù, reflecting the current ‚ÄúState‚Äù, and one method to handle the ‚ÄúModel‚Äù, we solve the state problem simply by calling getView (). Render (PersonsModel) (with the latest Model, when we re-attach View to Presenter). <br><br>  <b>Backsight navigation</b> <br><br>  Does Presenter or ViewModel save if we no longer use View?  For example, Fragment (View) has been replaced by another Fragment, and the user has moved to another screen.  View is no longer attached to Presenter - it will not be able to update View with the latest data from the business logic.  What if the user comes back, for example, by pressing the ‚ÄúBack‚Äù button and deleting the last transaction in the back stack?  Do I need to reload data or use an existing Presenter? <br><br>  The user, returning to the previous screen, wants to continue working with the application in the same place where he stopped.  We discussed this problem when we talk about changing the orientation of the screen.  The solution is obvious: as soon as the user returns from the back stack, call getView (). Render (PersonsModel) with a model that reflects the state. <br><br>  <b>Death process</b> <br><br>  There is a common misunderstanding in Android development that the death of the process is bad, and we need libraries that help restore the state after the death of the process.  The process dies in two cases: if the Android operating system needs resources for other applications or to save battery.  This will not happen when your application is in the foreground and is being actively used.  Do not argue with the platform.  If you have long operations in the background, use the Service - so the system will understand that the application is used. <br><br>  If the process is dead, Android will provide some life-cycle methods, such as onSaveInstanceState (), to save the state.  And again we ask questions: <br><br><ul><li>  Do I need to save information from View to bundle? </li><li>  Does the presenter have his own state, which we also need to save in the bundle? </li><li>  What about the state of business logic? </li></ul><br>  We conclude.  As described in the previous paragraphs, we need a model that reflects the complete state.  Then we just save the model in a bundle and restore it later.  But often the best solution is not to save the state, but to reload the entire screen, like when you first started the application.  Submit an application that displays a list of news.  Our application is killed, we save the state.  After 6 hours, when the user opens the application and the status is restored, the application displays the outdated content.  In this scenario, it is better to reload the data rather than save the state. <br><br>  <b>Immutability and unidirectional data flow</b> <br><br>  Let's not talk about the benefits of immutability, we have a lot of information about it.  We want to get a single source of reliable data.  This requires an immutable model that reflects the state.  Other components of the application should not affect our model or state. <br><br>  Imagine that we are writing a simple counter application that displays the current value in TextView and has only two buttons - ‚ÄúIncrease‚Äù and ‚ÄúReduce‚Äù.  In this case, our model is the counter value.  If this is an immutable model, how do we change the counter?  We will not change the TextView immediately after each button click. <br><br><ol><li>  Our model should use only the view.render (...) method. </li><li>  Direct model changes are not possible. </li><li>  We must have the only source of reliable data - business logic. </li></ol><br>  In business logic, there is a private field with the current model, and it creates a new model with a larger or smaller value relative to the old model. <br><br><img src="https://habrastorage.org/files/f66/0ca/f87/f660caf87809499db9cc0cedd6b158d4.png" alt="image"><br><br>  We establish a unidirectional data flow, where business logic is a single data source that creates immutable model instances.  It looks technically complicated for a simple counter, because the counter is a simple application.  Many applications developers start with simple things, but then complicate.  Unidirectional data flow and immutable model are important even for simple applications ‚Äî for developers, they will remain simple, even when complexity increases. <br><br>  <b>Debug and reproducible states</b> <br><br>  Unidirectional data flow provides simple debugging in our application.  It would be nice to get a full crash report from Crashlytics to reproduce and quickly fix this crash.  All the information we need is the current model and the action that the user wanted to take at the time of the crash.  For example, pressing the "Reduce" button in the counter.  This is enough to reproduce the failure; this information is simply logged and attached to the failure report.  Without a unidirectional data flow, it was difficult to find out, for example, that someone misused the EventBus and launched our CounterModel in an incomprehensible way.  Without immutability, we could not figure out who and where exactly changed our Model. <br><br>  <b>Testability</b> <br><br>  The ‚Äútraditional‚Äù use of MVP or MVVM improves application testability.  MVC can also be tested: it is not necessary to place all business logic in the Activity.  With a model that reflects state, we can simplify our unit tests by simply writing assertEquals (expectedModel, model). <br>  This will save us from creating a lot of "Mock" objects. <br><br>  We will get rid of tests confirming that a particular method has been called, i.e. <br>  Mockito.verify (view, times (1)). ShowFoo ()).  It will be easier for us to read, understand and maintain the unit test code - we don‚Äôt have to work with the details of the implementation of this code. <br><br>  <b>Conclusion</b> <br><br>  In the first part of a series of articles on MVI, we talked more about theoretical things.  Why do we need a separate article about the model? <br><br>  The model helps to avoid a number of problems: <br><br><ol><li>  Condition problems </li><li>  Screen orientation changes. </li><li>  Backstay navigation. </li><li>  Death process. </li><li>  Immutability and unidirectional data flow. </li><li>  Debugging and state playback. </li><li>  Testability </li></ol><br>  In their projects, developers have differently called business logic - Interactor, Usecase, Repository.  A model is not a business logic.  Business logic produces a model. <br><br>  In the next article we will look at all this theoretical part about the Model in work.  For example, create a reactive application where we use Model-View-Intent.  We are going to create a demo application for a fictional online store. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rmR9mV1Dsqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/325376/">https://habr.com/ru/post/325376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325366/index.html">Intel processors will triple</a></li>
<li><a href="../325368/index.html">We download the history of correspondence with all users of VKontakte using Python</a></li>
<li><a href="../325370/index.html">HTTP / 2 Server Push to Go 1.8</a></li>
<li><a href="../325372/index.html">CLion 2017.1 release: C ++ 14, C ++ 17, disassembler code in debugger, Catch, MSVC and much more</a></li>
<li><a href="../325374/index.html">Python Junior Meetup # 2</a></li>
<li><a href="../325378/index.html">Moscow Python Meetup ‚Ññ44</a></li>
<li><a href="../325380/index.html">Security Week 13: Doctor Who fans were found in the CIA, APT29 allows backdoor traffic through Google, start the SAP GUI patch</a></li>
<li><a href="../325382/index.html">Fundamental laws of information security</a></li>
<li><a href="../325384/index.html">Making your first game on the Phaser. Part 3 - Creating the game world</a></li>
<li><a href="../325386/index.html">10 applications to protect devices on Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>