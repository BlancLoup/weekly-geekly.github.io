<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interrupts in pipelined processors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely you know what interrupts are. Perhaps even interested in the processor device. Almost certainly you have never seen a clear story about how the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interrupts in pipelined processors</h1><div class="post__text post__text-html js-mediator-article">  Surely you know what interrupts are.  Perhaps even interested in the processor device.  Almost certainly you have never seen a clear story about how the processor detects an interrupt, goes to the handler, and, most importantly, returns from it exactly where it should be. <br><br>  I wrote this article a year.  Initially, it was designed for hardwarders.  Understanding that I will never finish it, as well as the thirst for fame and the desire to be read by more than ten people, made me adapt it to a relatively wide audience, throwing out diagrams, pieces of code on Veriloga and kilometers of time diagrams. <br><br>  If you ever wondered what the words ‚Äúthe processor supports precise aborts‚Äù mean in datashit, please under the cat. <br><a name="habracut"></a><br><h4>  Some terminology: processor, processes and interrupts </h4><br>  In order not to try to embrace the immense, I will not consider: <br><ul><li>  Processors with exotic architectures (stack, stream, asynchronous, and so on), because their market share is very small, and as an example it is more logical to use common architecture.  RISC I chose solely for religious reasons </li><li>  Multi-core processors, because each processor core processes its interrupts independently of other cores </li><li>  Superscalar, multi-threaded, and VLIW processors, because from the point of view of interrupt organization, they are similar to scalar processors (although, of course, much more complicated). </li></ul><br>  Thus, by processors I will understand only single-core single-threaded scalar RISC-processors.  I assume that the reader is at least in general terms familiar with their device. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, a <b>processor</b> is a device that executes a sequence of commands (a program) to solve a certain task.  For each command, in turn, the processor must perform a sequence of operations called the instruction cycle and consists of the following steps: <br><ol><li>  Command selection from memory </li><li>  Command decoding </li><li>  Command execution </li><li>  Write results to registers and / or memory </li></ol><br>  A processor with sequential execution of commands begins the execution of the next instruction cycle only after the previous one is completed, that is, only one instruction is executed at a time. <br><br>  A processor with parallel execution of instructions can execute several instructions simultaneously.  For example, a processor with a four-stage command pipeline can simultaneously record the results of the first command, use the second, decode the third, and select the fourth from memory. <br><br>  <b>A process</b> is an executing program.  The process should produce the same results regardless of whether it is executed on the processor with sequential or parallel execution of instructions.  The state of the process is determined by the contents: <br><ul><li>  CPU instruction counter (program counter, aka instruction pointer) </li><li>  processor registers (general purpose, status, flags, and so on) </li><li>  random access memory </li></ul><br>  In real-time systems, the effect of cache memory, MMU associative translation buffers (translation lookaside buffer, TLB), and dynamic transition prediction tables must also be considered. <br><br>  Each executed command somehow updates the state of the process: <br><ul><li>  arithmetic and logic commands update the contents of the registers and the program counter </li><li>  jump instructions update the contents of the instruction counter and the dynamic jump prediction table </li><li>  load commands update the contents of the registers, the command counter and the cache memory (in case of a cache miss; if you need to replace the cache line, then also the RAM) </li><li>  save commands update the contents of the RAM (or cache) and the command counter </li></ul><br>  <b>An interrupt</b> is an event upon which the processor must suspend the execution of the current process, save its state, and begin performing another process called the interrupt handler.  After the completion of the interrupt handler, the state of the interrupted process must be restored, and in the event of a fatal interrupt (for example, due to hardware failure), the processor must be restarted or stopped. <br><br>  Depending on the interrupt source, it can be: <br><ol><li>  Internal, if caused by the execution of a command in the processor: <br><ul><li>  Software (software interrupt), if caused by a special command </li><li>  An exception (exception, fault, abort is all that), if caused by an error when executing the command </li></ul><br></li><li>  External if caused by an event outside the processor </li></ol><br>  A command that was executed when any of the above interrupts occurred will be called an interrupted command for brevity. <br><br>  Saving and restoring the state of a process can be implemented in hardware, software, or software and hardware.  In the future, I will consider the simplest hardware and software version, in which: <br><ul><li>  the processor saves the instruction counter to the special register of the return address (PAB), at the same time writing the interrupt vector to the instruction counter, thus starting the interrupt handler </li><li>  all other process state elements are saved by the interrupt handler if necessary (for example, before using registers, it must save their contents to the stack) </li><li>  before terminating the interrupt handler, it must restore all process state elements that were changed (for example, restore the contents of registers saved to the stack) </li><li>  the interrupt handler is completed with the return-from-interrupt command, which writes the contents of the PAB back to the command counter, that is, returns control to the interrupted process </li></ul><br>  After returning control to the interrupted process, he should be able to continue working as if he had not been interrupted.  This requirement is trivial, but for most modern processors it is quite difficult to fulfill.  It is so difficult that sometimes it is abandoned.  Interruptions that guarantee the fulfillment of this requirement are called <i>precise</i> (precise), and others - <i>inaccurate</i> (imprecise). <br><br><h4>  Accurate and inaccurate interrupts </h4><br>  Formally, an interrupt is called <b>exact</b> if all of the following conditions are met: <br><ol><li>  All commands preceding the interrupted one were fully executed and correctly saved the state of the process. </li><li>  all commands following the interrupted have not been executed and in no way changed the state of the process </li><li>  interrupted command, depending on the type of interruption, either was completely executed or was not executed at all </li></ol><br>  The first two conditions of accuracy do not need comments.  The third condition is due to the following: <br><ul><li>  A command that was executed at the time of the arrival of an external interrupt must update the state of the process before it is saved.  The same applies to the command that caused the software interrupt.  In both cases, the PAB will indicate a command that, without an interruption, should have been executed next.  It will be executed immediately after returning from the interrupt handler. </li><li>  The team that caused the exception is the ‚Äúbad‚Äù team.  Its results are most likely incorrect, so it should not update the state of the process.  Instead, its address is saved in the PAB, after which the interrupt handler is called, which will try to correct the error.  After returning from the handler, this command will be executed again.  If it again causes the same exception, then the error is uncorrectable and the processor will generate a fatal interrupt. </li></ul><br>  Obviously, external interrupts must always be accurate.  Who needs a processor that cannot correctly recover the process after processing a timer interrupt? <br><br>  Software interrupts and exceptions may be accurate or inaccurate.  In some cases, it is impossible to do without exact exceptions - for example, if there is a MMU in the processor (then, if a TLB miss occurs, control is transferred to the appropriate exception handler, which programmatically adds the page to the TLB, after which it should be possible to re-execute the command that caused the miss ). <br><br>  In microcontrollers, exceptions may be inaccurate.  For example, if the save command caused an exception due to a memory error, instead of trying to somehow fix the error and rerun this command, you can simply reload the microcontroller and start the program again (that is, do the same thing that the watchdog does timer when the program hung). <br><br>  In most textbooks on computer architecture (including classics such as <a href="http://www.amazon.com/gp/reader/0123744938/ref%3Dsib_dp_pop_fc%3Fie%3DUTF8%26p%3DS001">Patterson &amp; Hennessy</a> and <a href="http://www.amazon.com/gp/reader/012383872X/ref%3Dsib_dp_pop_fc%3Fie%3DUTF8%26p%3DS001">Hennessy &amp; Patterson</a> ), accurate interruptions are bypassed.  In addition, inaccurate interrupts are of no interest.  In my opinion, these are excellent reasons to continue the story about exact interruptions. <br><br><h4>  Precise interrupts in processors with sequential execution of commands </h4><br>  For processors with sequential execution of commands, the implementation of exact interrupts is quite simple, so it seems logical to start with it.  Since only one command is executed at a time, at the moment of interruption detection all the commands preceding the interrupted one are already executed, and the subsequent ones are not even started. <br><br>  Thus, to implement accurate interrupts in such processors, it is enough to make sure that the interrupted command never updates the state of the process until it becomes clear whether it caused an exception or not. <br><br>  The place where the processor must determine whether to allow the command to update the process status or not is called a <b>commit point</b> .  If the processor saves the results of the command, that is, the command did not cause an exception, then they say that this command is fixed (in slang it is committed). <br><br>  To understand where the point of fixation should be located, it is useful to recall the steps of the command cycle: <br><ol><li>  Command selection from memory </li><li>  Command decoding </li><li>  Command execution </li><li>  Write results to registers and / or memory </li></ol><br>  By definition, it must be before the results are recorded, but by this point it should already be known whether the command caused an exception or not.  An exception can occur at any of four stages, for example: <br><ol><li>  memory error while fetching the command </li><li>  unknown opcode when decoding </li><li>  division by zero in performance </li><li>  memory error while writing results </li></ol><br>  Obviously, the implementation of accurate interrupts is impossible until the problem of recording results in memory is solved: <br><ul><li>  you cannot fix a command and allow it to write the results into memory until it becomes clear that the command did not raise an exception </li><li>  it is impossible to know that an exception was not caused without writing the results into memory (for this you need to receive a confirmation from the memory controller that the recording was successful) </li></ul><br><br>  As you can guess, this problem is quite difficult to solve, so for many processors, ‚Äúalmost exact‚Äù interrupts are implemented, that is, all interrupts are accurate, except for exceptions caused by memory errors when writing results.  In this case, the fixation point is between the third and fourth stages of the command cycle. <br>  <b>Important!</b>  It must be remembered that the command counter must also be updated strictly after the fixation point of the results.  At the same time, it changes regardless of whether a command is fixed or not ‚Äî either the address of the next command, the interrupt vector, or the PAB is written to it. <br><br><h4>  Precise interrupts in processors with parallel instruction execution </h4><br>  To date, there are almost no processors with sequential execution of commands (I can only recall analogs of Intel's 8051) - they were supplanted by processors with parallel execution of instructions, which, other things being equal, provide higher performance.  The simplest processor with parallel execution of commands is the processor with the instruction pipeline. <br>  Despite numerous advantages, the pipeline of commands considerably complicates the implementation of accurate interruptions, which has been a great sadness for developers for many decades. <br><br>  In a processor with sequential execution of commands, the steps of the command cycle depend on each other.  The simplest example is the command counter.  Initially, it is used at the sampling stage (as an address in the memory where the command should be read from), then at the execution stage (to calculate its next value), and then, if the command is fixed, it is updated at the recording results stage.  This leads to the fact that you can not select the next command until the previous one completes the last stage and updates the command counter.  The same applies to all other signals inside the processor. <br><br>  A processor with a command pipeline can be obtained from the processor with sequential execution of commands, if you make it so that each stage of the command cycle is independent of the previous and subsequent stages. <br><br>  For this, the results of each stage, except the last, are stored in auxiliary memory elements (registers) located between the stages: <br><ol><li>  The result of the selection ‚Äî the encoded instruction ‚Äî is stored in a register located between the sampling and decoding stages. </li><li>  The result of decoding - the type of operation, the values ‚Äã‚Äãof the operands, the address of the result - are stored in the registers between the stages of decoding and execution </li><li>  Execution results - the new value of the command counter for the conditional transition, the result of an arithmetic operation calculated in the ALU, and so on - are stored in the registers between the execution and recording stages </li><li>  At the last stage, the results are already recorded in registers and / or memory, so no auxiliary registers are needed. </li></ol><br>  This is how the resulting pipeline works: <br><br><pre> Tact SC Sampling Decoding Performance Record
 1 0x00 Team1 - - -
 2 0x04 Team2 Team1 - -
 3 0x08 Team3 Team2 Team1 -
 4 0x0C Team4 Team3 Team2 Team1 Team1            
 5 0x10 Team5 Team4 Team3 Team3 Team2            
</pre><br>  Pay attention to the SK column ("command counter").  Its value changes every clock and determines the address in memory, where the command is selected from. <br>  The attentive reader has already noticed a small discrepancy - to ensure the accuracy of interrupts, the first team does not have the right to change the command counter before the fourth clock cycle.  To fix this, we need to move the command counter for the fixation point of the result (suppose that it is between the third and fourth stages): <br><br><pre> Tact Sample Decoding Performance Record SC
 1 Team1 - - - 0x00
 2 - Team1 - - 0x00
 3 - - Team1 - 0x00
 4 Team2 - - Team1 0x04
 5 - Team2 - - 0x04
</pre><br>  Processor performance has dropped a bit, right?  In fact, the solution lies on the surface - we need two instruction counters!  One should be at the beginning of the pipeline and indicate where to read the commands, the second at the end, and point to the command that should be fixed next. <br>  The first is called ‚Äúspeculative‚Äù, the second - ‚Äúarchitectural‚Äù.  Most often, the speculative command counter does not exist by itself, but is built into the predictor of transitions.  It looks like this: <br><br><pre> Tact CCQ Sampling Decoding Execution Record_ASC results
 1 0x00 Team 1 - - - 0x00
 2 0x04 Team2 Team1 - - 0x00
 3 0x08 Team3 Team2 Team1 - 0x00
 4 0x0C Team4 Team3 Team2 Team2 Team1 0x04
 5 0x10 Team5 Team4 Team3 Team3 Team2 0x08
</pre><br>  What happens next is what happens next.  The team, moving between stages, drags the address from which it was selected (that is, its FCS).  Before the fixation point of the result, the processor looks to see if an external interrupt has arrived, if the command has caused an exception, and also compares its address with the ACK: <br><ul><li>  If an external interrupt arrives, the command is committed, but the address of the next command is not recorded in the ACK, but in the PAB.  In the ACK is written the address of the interrupt vector. </li><li>  If an exception occurs, the command is not committed, instead, the address of the vector of the corresponding exception is written to the ACK, and the address of the command is recorded in the PAB. </li><li>  If the address of the command is not equal to the ASC, it also does not commit (more on that later).  If the address is equal to ACK and the exception did not occur - the processor fixes the command and updates the ACK (writes the transition address in the case of a branch command or simply increments in the case of another command) </li></ul><br>  Why the address of the command may not be equal to the ACK?  Take my favorite example: the processor has just been turned on, and it selects the first command from the interrupt table, which is nothing more than a command to go to the far distance (at 0x1234 address): <br><br><pre> Tact CCQ Sampling Decoding Execution Record_ASC results
 1 0x00 jump 0x1234 - - - 0x00
 2 0x04 Team2 jump 0x1234 - - 0x00
 3 0x08 Team3 Team2 jump 0x1234 - 0x00
 4 0x0C Team4 Team3 Team2 Jump2 team 0x1234
 *** For Komandy2 on the fourth cycle, its address (0x04) is not equal to ACK, because the transition was predicted incorrectly ***
 5 0x1234 Team666 - - - 0x1234
 6 0x1238 Team667 Team666 - - 0x1234
 7 0x1240 Team668 Team667 Team666 - 0x1234
 8 0x1244 Team669 Team668 Team667 Team666 0x1238
</pre><br>  That's all.  Of course, the shown four-stage pipeline is simple to the point of impossibility.  In fact, some commands can execute more than one clock cycle, and even a simple microcontroller can complete them not in the order in which he launched them, while ensuring the accuracy of interrupts.  However, the general principle of organizing interrupts, I assure you, remains the same. <br><br>  Those who wish to aggravate the brain explosion, I recommend to familiarize yourself with the <a href="http://www.eecs.berkeley.edu/~culler/courses/cs252-s05/papers/p291-smith.pdf">Implementation of precise interrupts in pipelined processors</a> .  Yes, your newest Intel Cor Core Seven works exactly as described in this article twenty-five years ago.  Welcome to the eighties! </div><p>Source: <a href="https://habr.com/ru/post/188002/">https://habr.com/ru/post/188002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187982/index.html">Free Software Foundation begins fundraising for Replicant</a></li>
<li><a href="../187986/index.html">Ineffective programmer or how to hack your brain in 2 days</a></li>
<li><a href="../187988/index.html">Overview of the Chinese DPSS laser 532nm</a></li>
<li><a href="../187992/index.html">American agents "lucky" in the pursuit of Russian hackers</a></li>
<li><a href="../187994/index.html">Streaming in Rails 4</a></li>
<li><a href="../188010/index.html">Know the complexity of the algorithms</a></li>
<li><a href="../188012/index.html">Sort in .NET</a></li>
<li><a href="../188014/index.html">Twitter Bootstrap 3 RC Released 1</a></li>
<li><a href="../188016/index.html">The court forbade the publication of launch codes for luxury cars</a></li>
<li><a href="../188018/index.html">Windows NT today is 20 years old</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>