<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel Virtual World. Part 2: SMP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article (link), I talked about the basic concept of a hypervisor based on Intel hardware virtualization technology. Now I propose to e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel Virtual World. Part 2: SMP</h1><div class="post__text post__text-html js-mediator-article">  In the previous <a href="https://habr.com/post/419065/">article</a> (link), I talked about the basic concept of a hypervisor based on Intel hardware virtualization technology.  Now I propose to expand the capabilities of the hypervisor by adding support for multiprocessor architecture (SMP), and also to consider an example of how the hypervisor can make changes to the operation of the guest OS. <br><br>  All further actions will be carried out on a PC with the following configuration: <br><br>  CPU: Intel Core i7 5820K <br>  Motherboard: Asus X99-PRO <br>  Ram: 16GB <br>  Guest OS: Windows 7 x32 with PAE disabled <br><a name="habracut"></a><br>  I will begin by describing the location of the hypervisor components on the hard disk (all values ‚Äã‚Äãare given in sectors). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/in/_l/4b/in_l4birv9nzswyy15vouhjywla.jpeg" alt="image"><br>  <i>The process of loading the hypervisor differs from the previous version only in the presence of a new module <i>hypervisor.ap</i> , the purpose of which is the basic initialization of the processor AP.</i> <br><br>  The process of loading modules into memory: <br><br><img src="https://habrastorage.org/webt/3a/in/ul/3ainulrasx1dmbgbpodesnsg-qy.jpeg"><br><br>  <b>SMP support</b> <br><br>  I implemented a hypervisor on the principle of symmetric multiprocessing, which means that the same copy of VMX will run on all logical processors present.  In addition, IDT and GDT tables as well as tables for paging memory will be common to all logical processors.  I did this because the hypervisor will immediately initialize the memory for the guest OS address space and there is no need to dynamically reassign the physical addresses of individual pages.  Also, with this approach, it is possible not to monitor on the hypervisor side the compliance of TLB with processor caches. <br>  The initialization process for BSP and AP will be different.  All the basic structures involved in the work of the hypervisor will be created during the initialization of the BSP.  In addition, the Activity state for vmx non root AP mode processors will be set to HLT state.  Thus, the guest OS environment will be emulated in accordance with what it would be without the use of virtualization. <br><br>  BSP Initialization: <br><br><ol><li>  Spinlock initialization </li><li>  Initialization and loading of GDT and IDT tables </li><li>  Initialization of paging addressing tables </li><li>  Initialization of VMCS structures and creation of a common EPT table </li><li>  AP processor activation.  To this end, the INIT - SIPI interrupt sequence is transmitted to each AP.  The SIPI interrupt vector is 0x20, which corresponds to the transfer of control to the AP at 0x20000 (hypervisor.ap module) </li><li>  Running the guest OS at 0x7C00 (module win7.mbr) </li></ol><br>  AP Initialization: <br><br><ol><li>  After activating the AP, the processor is in real mode.  The hypervisor.ap module initializes the memory and paging addressing tables for the transition to long mode </li><li>  Loading IDT, GDT, and also the catalog of tables of page addressing, created at the stage of initialization of BSP </li><li>  Initialization of VMCS structures, and loading of the EPT table created at the initialization stage of the BSP </li><li>  Switch to vmx non-root mode with active HLT state </li></ol><br>  We can say that the implementation of SMP support in the hypervisor is quite simple, but there are several points that I would like to draw attention to. <br><br>  1.USB Legacy Support <br><br>  The new motherboard models may have no PS / 2 connectors, so USB Legacy Support is used for backward compatibility.  This means that you can work with the usb keyboard or mouse using the same methods (input / output ports) as was the case with the PS / 2 standard.  The implementation of USB Legacy Support depends not only on the motherboard model, but it can also lure in various versions of the firmware.  On my Asus X99-PRO motherboard, USB Legacy Support is implemented via SMI interrupts, in which PS / 2 emulation occurs.  I am writing about it in such detail, because in my case (firmware version 3801), USB Legacy Support is not compatible with long mode and when I return from SMM, the processor goes into shutdown state. <br><br>  The simplest solution in this situation is to turn off USB Legacy Support before switching to long mode.  However, in Windows, when selecting boot options, the PS / 2 keyboard polling method is used, so USB Legacy Support must be activated again before the guest OS starts downloading. <br><br>  2. Hardware Task Switch <br><br>  In modern operating systems, switching between tasks is implemented, as a rule, by program methods.  However, in Windows7, for interrupts 2 - NMI and 8 - Double Fault, selectors are assigned that point to TSS, which means such interrupts will lead to a hardware context switch.  Intel VMX does not support the hardware Task Switch, and attempting to execute it results in VM Exit.  For such cases, I wrote my Task Switch handler (the GuestTaskSwitch function).  Double Fault interrupts only in the event of a serious system conflict caused by improper handling of other interrupts.  In the process of debugging, I did not come across it.  But NMI appears on AP processors at the time of restarting Windows.  I still doubt this because it is not clear whether these NMIs are the result of a regular reboot process or is it the incorrect work of the hypervisor at some of the previous stages.  If you have any information on this subject, please comment in the comments or write to me in a personal message. <br><br>  <b>Changes in the guest OS</b> <br><br>  Honestly, for a long time I couldn‚Äôt decide what changes in the operation of the guest OS should be made by the hypervisor.  The fact is that, on the one hand, I wanted to show something interesting, such as the implementation of my handlers in the basic network protocols, but on the other hand, it would all rest on a large amount of code, and there is little hypervisor associated with the subject matter.  In addition, I did not want to bind the hypervisor to any particular set of hardware. <br><br>  As a result, the following compromise was found: in this version of the hypervisor, control over system calls from user mode is implemented, in other words, it will be possible to monitor the operation of application programs running in the guest OS.  This type of control is quite simple to implement, and besides it allows you to get a visual result of the work. <br><br>  Control over the work of application programs will be executed at the level of system calls.  And the main goal will be to change the result of the function <i>NtQuerySystemInformation</i> so that when calling with the argument <i>SystemProcessInformation</i> ( <i>0x05</i> ) you can intercept information about the processes. <br><br>  In Windows 7, the application program calls the sysenter assembly command to call the system function, after which control is transferred to the kernel at the r0 level by the <i>KiFastCallEntry</i> handler.  To return to the application level r3, use the sysexit command. <br>  To access the results of executing the <i>NtQuerySystemInformation</i> function, <i>you</i> must save the number of the function being called each time the sysenter command is executed.  Then, when executing <i>sysexit,</i> compare the stored value with the number of the function being intercepted and, in case of coincidence, make changes to the data returned by the function. <br>  Intel VMX does not provide direct means of monitoring the execution of <i>sysenter / sysexit</i> , however, if you write a value of 0 to <i>Guest MSR IA32_SYSENTER_CS</i> , then <i>sysenter / sysexit commands</i> will cause a GP exception that can be used to call the VM Exit handler.  In order for a GP exception to cause VM Exit, you need to set 13 bits in the <i>Exception Bitmap</i> field of VMCS. <br><br>  The structure below is used when emulating a sysenter / sysexit pair. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> QWORD ServiceNumber; QWORD Guest_Sys_CS; QWORD Guest_Sys_EIP; QWORD Guest_Sys_ESP; } SysEnter_T;</code> </pre> <br>  The <i>ServiceNumber</i> field contains the number of the function being called and is updated each time sysenter is called. <br><br>  The <i>Guest_Sys_CS, Guest_Sys_EIP, Guest_Sys_ESP fields</i> are updated when the guest OS tries to write to the corresponding MSR register.  For this, write masks are specified in <i>MSR-Bitmap Address</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS write mask ptrMSR_BMP[0x100 + (0x174 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x174 &amp; 0x3F)); // 175H 373 IA32_SYSENTER_ESP SYSENTER_ESP write mask ptrMSR_BMP[0x100 + (0x175 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x175 &amp; 0x3F)); // 176H 374 IA32_SYSENTER_EIP SYSENTER_EIP write mask ptrMSR_BMP[0x100 + (0x176 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x176 &amp; 0x3F));</span></span></code> </pre><br>  The guest OS should not see changes made by the hypervisor in the work of calls to system functions.  By setting the mask for reading <i>MSR IA32_SYSENTER_CS,</i> you can return the guest OS to the original register value when reading. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS read mask ptrMSR_BMP[0x174 &gt;&gt; 6] |= (1UL &lt;&lt; (0x174 &amp; 0x3F));</span></span></code> </pre><br>  Below is the <i>sysenter / sysexit</i> command emulation scheme. <br><br><img src="https://habrastorage.org/webt/bl/wx/vo/blwxvocgthxx_0skhnjmm4sbf4i.jpeg"><br><br>  At the <i>sysexit</i> emulation <i>step</i> , the stored number of the called function is compared with the <i>NtQuerySystemInformation</i> number (0x105).  If there is a match, it is checked that NtQuerySystemInformation is called with the System Process Information argument, and if so, the <i>ChangeProcessNames</i> function <i>(DWORD SPI_GVA, DWORD SPI_size)</i> makes changes to the structures containing information about the processes. <br>  <i>SPI_GVA</i> is the guest virtual address of the <i>SYSTEM_PROCESS_INFORMATION</i> structure <br>  <i>SPI_size</i> is the total size of the structures in bytes. <br>  The <i>SYSTEM_PROCESS_INFORMATION</i> structure <i>itself</i> looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span></span></span><span class="hljs-class"> {</span></span> ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[<span class="hljs-number"><span class="hljs-number">48</span></span>]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[<span class="hljs-number"><span class="hljs-number">6</span></span>]; } SYSTEM_PROCESS_INFORMATION;</code> </pre><br>  There is nothing complicated in its parsing, the main thing to remember is to transfer the guest virtual address to the physical one; for this, the <i>GuestLinAddrToPhysAddr ()</i> function is used. <br><br>  For clarity of the result, I replaced the first two characters in the names of all processes with the ' <b>:)</b> ' sign. The result of this replacement is visible in the screenshot. <br><br><img src="https://habrastorage.org/webt/rs/nq/rt/rsnqrtxvkrcoc0r_4xgjnuabk8o.png"><br><br>  <b>Results</b> <br><br>  In general, the tasks set at the beginning of the article were completed.  The hypervisor ensures stable operation of the guest OS, and also monitors the calling of system functions from the application layer.  I note that the main drawback of using <i>sysenter / sysexit</i> command emulation is a significant increase in VM Exit calls, which affects performance and this is especially noticeable when the guest OS is running in single-processor mode.  This disadvantage can be eliminated by performing call control only in the context of selected processes. <br><br>  And that's all for now.  The source for the article can be found <a href="https://github.com/staticbear/hypervisor_smp">here.</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/429918/">https://habr.com/ru/post/429918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429908/index.html">How to use korutiny in prode and sleep well at night</a></li>
<li><a href="../429910/index.html">AppsConf Rises</a></li>
<li><a href="../429912/index.html">Library development: from API to public release</a></li>
<li><a href="../429914/index.html">OpenSceneGraph: Scene graph and smart pointers</a></li>
<li><a href="../429916/index.html">How to build and build</a></li>
<li><a href="../429920/index.html">The tragicomedy in NaN acts: how we made the game on JS and released it on Steam</a></li>
<li><a href="../429922/index.html">How to turn a simple project into unfinished or cutting off all unnecessary</a></li>
<li><a href="../429926/index.html">Roskomnadzor: Google confirms willingness to comply with Russian legislation</a></li>
<li><a href="../429928/index.html">Everything you need to know about stress and strong emotions.</a></li>
<li><a href="../429930/index.html">Splunk. Easy Troubleshooting application work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>