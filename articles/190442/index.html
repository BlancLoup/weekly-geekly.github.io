<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming imperatively in Haskell using lenses</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell gets a lot of unflattering feedback, because there is no built-in toolkit for working with changes and states. Therefore, if we want to bake a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming imperatively in Haskell using lenses</h1><div class="post__text post__text-html js-mediator-article">  Haskell gets a lot of unflattering feedback, because there is no built-in toolkit for working with changes and states.  Therefore, if we want to bake an apple pie full of states, we first need to create a whole universe of operators for working with states.  However, this has already been paid for with interest and this stage has already been passed, and now Haskele programmers are enjoying more elegant, concise and powerful imperative code than even what you can find in self-describing imperative languages.  However, you can see for yourself. <br><br><h4>  Lenses </h4><br><img src="https://habrastorage.org/storage2/849/07a/a20/84907aa2031c116499fc96584493b009.jpg"><br>  Your ticket to the elegant code is a library of lenses. <a name="habracut"></a><br>  You define your data as usual, just add an underscore to the beginning of the names of your fields.  For example, we can define a game (Game) as: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Game</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Game</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_score</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_units</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class">] , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_boss</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  full creatures (unit): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_health</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_position</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  whose locations are determined by points: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_x</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_y</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  We add an underscore to the fields, because we will not use them directly.  Instead, we will use them in order to build lenses with which it is much more pleasant to work. <br><br>  We can build lenses in two ways.  The first option is to manually create lenses using the convenient <code>lens</code> function from <code>Control.Lens</code> .  For example, we can define a lens <code>score</code> for the <code>_score</code> field as follows: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Lens score :: Lens' Game Int score = lens _score (\<span class="hljs-title"><span class="hljs-title">game</span></span> <span class="hljs-title"><span class="hljs-title">v</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">game</span></span> { <span class="hljs-title"><span class="hljs-title">_score</span></span> = <span class="hljs-title"><span class="hljs-title">v</span></span> })</code> </pre><br>  Type <code>Lens</code> as a map for navigating complex data types.  We use a lens of a <code>score</code> to come from the <code>Game</code> type to <code>_score</code> . <br>  The type reflects where we should start and what to finish: <code>Lens' Game Int</code> means that we should start with <code>Game</code> and end <code>Int</code> (for the <code>_score</code> field in our case).  Similarly, our other lenses clearly reflect the starting and ending points of their types: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">units</span></span> :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> [<span class="hljs-type"><span class="hljs-type">Unit</span></span>] units = lens _units (\game v -&gt; game { _units = v }) boss :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> boss = lens _boss (\game v -&gt; game { _boss = v }) health :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> health = lens _health (\unit v -&gt; unit { _health = v }) position :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span> position = lens _position (\unit v -&gt; unit { _position = v }) x :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> x = lens _x (\point v -&gt; point { _x = v }) y :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> y = lens _y (\point v -&gt; point { _y = v })</code> </pre><br>  However, we are often lazy and do not want to write routine code. In this case, you can choose a different path using <code>Template Haskell</code> to create lenses for us: <br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Lens data Game = Game { _score :: Int , _units :: [Unit] , _boss :: Unit } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Unit = Unit { _health :: Int , _position :: Point } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Point = Point { _x :: Double , _y :: Double } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) makeLenses ''Game makeLenses ''Unit makeLenses ''Point</code> </pre><br>  Just remember, the template Hasel trumpets that the <code>makeLenses</code> declaration <code>makeLenses</code> after the declaration of data types. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Initial state </h5><br>  The next thing we need to do is initialize the initial state of the game. <br><div class="spoiler">  <b class="spoiler_title">initialState :: Game</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">initialState</span></span> :: <span class="hljs-type"><span class="hljs-type">Game</span></span> initialState = <span class="hljs-type"><span class="hljs-type">Game</span></span> { _score = <span class="hljs-number"><span class="hljs-number">0</span></span> , _units = [ <span class="hljs-type"><span class="hljs-type">Unit</span></span> { _health = <span class="hljs-number"><span class="hljs-number">10</span></span> , _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> { _x = <span class="hljs-number"><span class="hljs-number">3.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">7.0</span></span> } } , <span class="hljs-type"><span class="hljs-type">Unit</span></span> { _health = <span class="hljs-number"><span class="hljs-number">15</span></span> , _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> { _x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">1.0</span></span> } } , <span class="hljs-type"><span class="hljs-type">Unit</span></span> { _health = <span class="hljs-number"><span class="hljs-number">8</span></span> , _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> { _x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">2.1</span></span> } } ] , _boss = <span class="hljs-type"><span class="hljs-type">Unit</span></span> { _health = <span class="hljs-number"><span class="hljs-number">100</span></span> , _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> { _x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } } }</code> </pre></div></div><br>  We created three heroes who will fight against the boss of the dungeon.  Let the battle begin! <br><br><h5>  The first steps </h5><br>  Now we can use our lenses!  Let's create a function for our warriors to attack the boss. <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.Class <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State strike :: StateT Game IO () strike = do lift $ putStrLn "*shink*" boss.health -= 10</code> </pre><br>  The attack function ( <code>strike</code> ) prints a similar sound to us in the console, further reduces the health of the boss 10 health units. <br>  The type of attack function shows us that we are operating with a <code>StateT Game IO</code> monad.  You may think that this is such a built-in language where we create a layer of pure game states (i.e. <code>StateT Game</code> ) on top of side effects (i.e. <code>IO</code> ) so that we can simultaneously change states and print our sweetest effects from the battle to the console .  All you need to remember now is that if we want to use side effects we need to use the <code>lift</code> function. <br>  Let's try using our function in the interpreter ( <code>ghci</code> ).  For this we need the initial state: <br><div class="spoiler">  <b class="spoiler_title">execStateT strike initialState</b> <div class="spoiler_text"><pre> <code class="haskell hljs">&gt;&gt;&gt; execStateT strike initialState *shink* <span class="hljs-type"><span class="hljs-type">Game</span></span> {_score = <span class="hljs-number"><span class="hljs-number">0</span></span>, _units = [<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">10</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Poin</span></span> t {_x = <span class="hljs-number"><span class="hljs-number">3.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">7.0</span></span>}},<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">15</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> {_ x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">1.0</span></span>}},<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">8</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">2.1</span></span>}}], _boss = <span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">90</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> { _x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>}}}</code> </pre></div></div><br>  The <code>execStateT</code> function takes our code with the states and our initial state, starts it, and produces a new state.  The interpreter automatically displays to us on the screen, and we can immediately analyze the result.  The output turned out porridge, however, if you train your eye, you can see that the boss now has only 90 health units. <br>  We can see it more easily if we first create a new variable for the resulting state. <br><pre> <code class="haskell hljs">&gt;&gt;&gt; newState &lt;- execStateT strike initialState *shink*</code> </pre><br>  and then extract the necessary information from it: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; newState^.boss.health <span class="hljs-number"><span class="hljs-number">90</span></span></code> </pre><br><br><h4>  Composition </h4><br><img src="http://habrastorage.org/storage2/b41/211/f66/b41211f66c9deeb2f5205de0336e92aa.jpg"><br>  The following code is very similar to the imperative and object-oriented code: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">boss</span></span>.health -= <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  What's going on here??  Haskell is definitely <b>not a</b> multi-paradigm language, but we have what appears in the multi-paradigm code. <br>  Incredibly, nothing in this code is a chip embedded in the language! <br><ul><li>  <code>boss</code> and <code>health</code> are just the lenses we defined above </li><li>  <code>(-=)</code> - infix function </li><li>  <code>(.)</code> - functional composition from haskel <code>Prelude</code> ! </li></ul><br>  Wait, <code>(.)</code> Is a functional composition ?!  Really?! <br>  This is where all the lens magic happens.  Lenses are the most common functions, and all our ‚Äúmulti-paradigm‚Äù code is really nothing but a mixture of functions! <br><br>  In fact, the type <code>Lens' ab</code> is a synonym for the type of functions of higher order: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Lens'</span></span></span><span class="hljs-class"> ab = forall f . (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) =&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  You do not need to understand everything now.  Just remember that <code>Lens' ab</code> is a higher order function that takes type <code>(b -&gt; fb)</code> as an input argument and returns a new function of type <code>(a -&gt; fa)</code> .  <code>Functor</code> - part of the theory, which can now be regarded as "magic". <br><div class="spoiler">  <b class="spoiler_title">Make sure the boss.</b>  <b class="spoiler_title">health :: Lens' Game Int</b> <div class="spoiler_text">  Armed with this knowledge, let's see how you can decompose the types of functions <code>boss</code> and <code>health</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">boss</span></span> :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-comment"><span class="hljs-comment">--   : boss :: (Functor f) =&gt; (Unit -&gt; f Unit) -&gt; (Game -&gt; f Game) health :: Lens' Unit Int --   : health :: (Functor f) =&gt; (Int -&gt; f Int) -&gt; (Unit -&gt; f Unit)</span></span></code> </pre><br>  Now let's look at the definition of functional composition: <br><pre> <code class="haskell hljs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c) (f . g) x = f (gx)</code> </pre><br>  Notice if we replace our type variables with: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> ~ (<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Int</span></span>) b ~ (<span class="hljs-type"><span class="hljs-type">Unit</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Unit</span></span>) c ~ (<span class="hljs-type"><span class="hljs-type">Game</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Game</span></span>)</code> </pre><br>  then we get a completely one-to-one correspondence for the composition of two lenses: <br><pre> <code class="haskell hljs">(.) :: ((<span class="hljs-type"><span class="hljs-type">Unit</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Unit</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Game</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Game</span></span>)) -&gt; ((<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Int</span></span> ) -&gt; (<span class="hljs-type"><span class="hljs-type">Unit</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Unit</span></span>)) -&gt; ((<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Int</span></span> ) -&gt; (<span class="hljs-type"><span class="hljs-type">Game</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Game</span></span>))</code> </pre><br>  If we perform a reverse replacement of the synonym for <code>Lens'</code> , we will get: <br><pre> <code class="haskell hljs">(.) :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> boss . health :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre></div></div><br>  It follows that the composition of the lenses is also a lens!  In fact, the lenses form a category, where <code>(.)</code> Is the categorical composition operator, and the <code>id</code> identity function is also a lens: <br><pre> <code class="haskell hljs">(.) :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> xy -&gt; <span class="hljs-type"><span class="hljs-type">Lens'</span></span> yz -&gt; <span class="hljs-type"><span class="hljs-type">Lens'</span></span> xz id :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> xx</code> </pre><br>  As a result, using the fact that you can remove spaces near the operator, we get a code that looks like the notation of object-oriented code! <br><br>  Categories make it incredibly easy to connect and group components on the fly.  For example, if we expect to change the health of the boss often, we can determine the composition of the lenses: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bossHP</span></span> :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bossHP = boss.health</code> </pre><br>  and now we can use it wherever it was previously necessary to use <code>boss.health</code> . <code>boss.health</code> . <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">strike</span></span> :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () strike = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"*shink*"</span></span> bossHP -= <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  and also find a new health value: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; newState^.bossHP <span class="hljs-number"><span class="hljs-number">90</span></span></code> </pre><br><br><h5>  Combed </h5><br>  The lenses are based on one really very elegant theory, and as a result we get the fact that in most imperative languages ‚Äã‚Äãyou can't just do it! <br><img src="http://habrastorage.org/storage2/6c1/5bb/891/6c15bb891cd454afdc6bea055b6204ca.jpg"><br>  For example, let's say that our boss is a dragon that breathes fire that damages heroes.  Using lenses, we can achieve this effect with one line: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fireBreath</span></span> :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () fireBreath = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"*rawr*"</span></span> units.traversed.health -= <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  This makes it possible to work with lenses in a new way! <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">traversed</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> [a] a</code> </pre><br>  <code>traversed</code> helps us to ‚Äúget to the bottom‚Äù of the values ‚Äã‚Äãin the list so that we can work with it as a whole, instead of manually traversing the entire list.  However, this time we use the type <code>Traversal'</code> instead of <code>Lens'</code> . <br><br>  <code>Traversal'</code> is the same <code>Lens'</code> , only weaker: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Traversal'</span></span></span><span class="hljs-class"> ab = forall f . (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) =&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  If we create a composition <code>Traversal'</code> and <code>Lens'</code> , we get a weaker type, namely <code>Traversal'</code> .  It works regardless of the order in which we combine: <br><pre> <code class="haskell hljs">(.) :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> ab -&gt; <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> bc -&gt; <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> ac (.) :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> ab -&gt; <span class="hljs-type"><span class="hljs-type">Lens'</span></span> bc -&gt; <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> ac units :: <span class="hljs-type"><span class="hljs-type">Lens'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> [<span class="hljs-type"><span class="hljs-type">Unit</span></span>] units.traversed :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> units.traversed.health :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre><br>  In fact, we don‚Äôt even need to know.  The compiler correctly finds the type itself: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; :t units.traversed.health units.traversed.health :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Game</span></span> -&gt; f <span class="hljs-type"><span class="hljs-type">Game</span></span></code> </pre><br>  This is exactly the same as the definition of <code>Traversal' Game Int</code> ! <br><br>  Actually, why don't we combine these two lenses into one? <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">partyHP</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> partyHP = units.traversed.health fireBreath :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () fireBreath = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"*rawr*"</span></span> partyHP -= <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Let's also use the <code>partyHP</code> function to find out the new health value: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; newState &lt;- execStateT fireBreath initialState *rawr* &gt;&gt;&gt; newState^.partyHP &lt;interactive&gt;:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Monoid</span></span>.<span class="hljs-type"><span class="hljs-type">Monoid</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `partyHP' .........</code> </pre><br>  Oops!  This is a type of mistake, because we can not get the only value of health!  That is why <code>Traversal'</code> weaker than <code>Lens'</code> : bypassed can point to multiple values, so they do not support a well-defined way to show a single value.  The system helped us get rid of a possible bug. <br><br>  Instead, we need to specify that we want to get the list using the <code>toListOf</code> function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">toListOf</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> ab -&gt; a -&gt; [b]</code> </pre><br>  This gives us a satisfactory result: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; toListOf partyHP newState [<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre><br>  or the infix equivalent of the <code>toListOf</code> function: <code>(^..)</code> : <br><pre> <code class="haskell hljs">&gt;&gt;&gt; initialState^..partyHP [<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>] &gt;&gt;&gt; newState^..partyHP [<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre><br>  This gives us a clear view of what we got what we wanted with <code>fireBreath</code> . <br><br>  And let's get something really fancy.  We can define a listing by geographic area.  Can we do this? <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">around</span></span> :: <span class="hljs-type"><span class="hljs-type">Point</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-type"><span class="hljs-type">Unit</span></span> around center radius = filtered (\unit -&gt; (unit^.position.x - center^.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (unit^.position.y - center^.y)^<span class="hljs-number"><span class="hljs-number">2</span></span> &lt; radius^<span class="hljs-number"><span class="hljs-number">2</span></span> )</code> </pre><br>  Of course we can!  We were able to limit the fiery breath to a circle! <br>  <i><code>filtered</code> is actually not theoretically enumerated, because it does not save the number of elements</i> <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fireBreath</span></span> :: <span class="hljs-type"><span class="hljs-type">Point</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () fireBreath target = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"*rawr*"</span></span> units.traversed.(around target <span class="hljs-number"><span class="hljs-number">1.0</span></span>).health -= <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Notice how expressive the code is - we reduce the health of everyone around the target.  This code tells us much more than its equivalent in leading imperative languages.  And the resulting code leaves much less room for errors. <br><br>  In any case, let's go back to the fire detector.  First, let's see who is next to him: <br><pre> <code class="haskell hljs">&gt; initialState^..units.traversed.position [<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">3.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">7.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">1.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">2.1</span></span>}]</code> </pre><br>  Hmm, two warriors are close to each other.  Let's get the fireball there. <br><pre> <code class="haskell hljs">&gt;&gt;&gt; newState &lt;- execStateT (fireBreath (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">1.5</span></span>)) initialState *rawr* &gt;&gt;&gt; (initialState^..partyHP, newState^..partyHP) ([<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>],[<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>])</code> </pre><br>  Got it! <br><br><h4>  Scaling </h4><br><img src="http://habrastorage.org/storage2/57f/87c/480/57f87c480ba75a0317b71c2dcdc90309.jpg"><br>  We can do more unique things with lenses.  For example, scale a subset of our global state. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">retreat</span></span> :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () retreat = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"Retreat!"</span></span> zoom (units.traversed.position) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x += <span class="hljs-number"><span class="hljs-number">10</span></span> y += <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  As before, we can combine two lenses into one if we are going to use them: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">partyLoc</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversal'</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span> partyLoc = units.traversed.position retreat :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () retreat = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"Retreat!"</span></span> zoom partyLoc $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x += <span class="hljs-number"><span class="hljs-number">10</span></span> y += <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Well, let's try! <br><pre> <code class="haskell hljs">&gt;&gt;&gt; initialState^..partyLoc [<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">3.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">7.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">1.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">2.1</span></span>}] &gt;&gt;&gt; newState &lt;- execStateT retreat initialState <span class="hljs-type"><span class="hljs-type">Retreat</span></span>! &gt;&gt;&gt; newState^..partyLoc [<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">13.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">17.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">11.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">11.0</span></span>},<span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">10.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">12.1</span></span>}]</code> </pre><br>  Let's look closely at the type of scaling in our context: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zoom</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversal</span></span> ab -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> b <span class="hljs-type"><span class="hljs-type">IO</span></span> r -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> a <span class="hljs-type"><span class="hljs-type">IO</span></span> r</code> </pre><br>  The <code>zoom</code> feature has several theoretical great features.  For example, we expect that a composition of scaled 2x lenses should give the same result as the scaling of their compositions. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zoom</span></span> lens1 . zoom lens2 = zoom (lens1 . lens2)</code> </pre><br>  and that scaling the empty lens will give itself: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zoom</span></span> id = id</code> </pre><br>  In other words, the <code>zoom</code> function is a functor, which means it obeys the laws of the functor! <br><br><h5>  Combine teams </h5><br>  Before that, we considered one team at a time, but now let's unite the concepts and imperatively define the battle between the actors: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">battle</span></span> :: <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () battle = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">-- ! forM_ ["Take that!", "and that!", "and that!"] $ \taunt -&gt; do lift $ putStrLn taunt strike --  ! fireBreath (Point 0.5 1.5) replicateM_ 3 $ do --  ! retreat --    zoom (boss.position) $ do x += 10 y += 10</span></span></code> </pre><br>  Well, let's go! <br><pre> <code class="haskell hljs">&gt;&gt;&gt; execStateT battle initialState <span class="hljs-type"><span class="hljs-type">Take</span></span> that! *shink* and that! *shink* and that! *shink* *rawr* <span class="hljs-type"><span class="hljs-type">Retreat</span></span>! <span class="hljs-type"><span class="hljs-type">Retreat</span></span>! <span class="hljs-type"><span class="hljs-type">Retreat</span></span>! <span class="hljs-type"><span class="hljs-type">Game</span></span> {_score = <span class="hljs-number"><span class="hljs-number">0</span></span>, _units = [<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">10</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Poin</span></span> t {_x = <span class="hljs-number"><span class="hljs-number">33.5</span></span>, _y = <span class="hljs-number"><span class="hljs-number">37.0</span></span>}},<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">12</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">31.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">31.0</span></span>}},<span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">5</span></span>, _position = <span class="hljs-type"><span class="hljs-type">Point</span></span> {_x = <span class="hljs-number"><span class="hljs-number">30.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">32.1</span></span>}}], _boss = <span class="hljs-type"><span class="hljs-type">Unit</span></span> {_health = <span class="hljs-number"><span class="hljs-number">70</span></span>, _position = <span class="hljs-type"><span class="hljs-type">P</span></span> oint {_x = <span class="hljs-number"><span class="hljs-number">30.0</span></span>, _y = <span class="hljs-number"><span class="hljs-number">30.0</span></span>}}}</code> </pre><br>  I think that people really do not joke when they say that Haskell is the best imperative language! <br><br><h4>  Conclusion </h4><br>  We just opened the curtain of the <code>lens</code> library, which is considered to be one of the royal treasures of the Haskell ecosystem.  You can also use lenses for pure programming in order to compress powerful and complex structures into very readable and elegant code.  However, you can still write a lot about this wonderful library. </div><p>Source: <a href="https://habr.com/ru/post/190442/">https://habr.com/ru/post/190442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190428/index.html">Modification of stock firmware for Android. Part 4</a></li>
<li><a href="../190434/index.html">Quick view comments on Habr√©</a></li>
<li><a href="../190436/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ70 (August 11 - 17, 2013)</a></li>
<li><a href="../190438/index.html">MakerBot 3D scanner goes on sale next week</a></li>
<li><a href="../190440/index.html">Do you use a loose comparison ("==") operator in PHP?</a></li>
<li><a href="../190444/index.html">10 myths about home 3D printing</a></li>
<li><a href="../190450/index.html">Google fell by two minutes - the volume of world traffic has decreased by 40%</a></li>
<li><a href="../190454/index.html">An overview of the open Adobe Brackets IDE</a></li>
<li><a href="../190456/index.html">Interstellar travel: from point A to point B</a></li>
<li><a href="../190458/index.html">I love graphics programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>