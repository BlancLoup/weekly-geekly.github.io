<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PVS-Studio confesses love to Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a note about love. About the love of the PVS-Studio static code analyzer for the wonderful open Linux operating system. This love is young, to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PVS-Studio confesses love to Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/179/ec2/e3a/179ec2e3ace00660f28efdf4b3147f51.png" alt="PVS-Studio confesses love to Linux" align="left">  This is a note about love.  About the love of the PVS-Studio static code analyzer for the wonderful open Linux operating system.  This love is young, touching and vulnerable.  This love needs help to be strengthened.  You can help if you sign up in volunteers beforehand for testing the beta version of PVS-Studio for Linux. <br><a name="habracut"></a><br>  For a very long time, my colleagues and I refused to discuss the topic of developing PVS-Studio for the Linux and UNIX operating systems of the world as a whole.  This is not about some personal predilections or technical difficulties.  Everything is easier - it is a cold, pragmatic approach to product development. <br><br>  We are a small company that exists solely through the sale of the PVS-Studio software product.  We do not receive grants or any other support from the state or large companies - all this imposes great responsibility for the choice of the direction of development. <br><br>  Now we have accumulated new strengths, have gathered our courage and are starting a new topic for us to master Linux.  Yes, yes, it happened.  We decided to start work in this direction.  Hopefully with this we <a href="http://www.viva64.com/ru/b/0320/">‚Äôll</a> get better than with <a href="http://www.viva64.com/ru/b/0320/">CppCat</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  PVS-Studio for Windows </h2><br>  At the beginning I‚Äôll briefly remind you what PVS-Studio is now, and what it can do at the moment.  If you have already read our articles, you can skip this section. <br><br>  PVS-Studio is a tool for detecting errors in the source code of programs written in C, C ++ and C # languages.  The analyzer has so far been targeted at developers using the Visual Studio environment.  Supported languages ‚Äã‚Äãand dialects: <br><ul><li>  Visual Studio 2015: C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Visual Studio 2013: C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Visual Studio 2012: C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Visual Studio 2010: C, C ++, C ++ / CLI, C # </li><li>  MinGW (partially): C, C ++ </li></ul><br>  Main features of PVS-Studio: <ul><li>  Automatic analysis of files after their recompilation in Visual Studio. </li><li>  Saving and loading analysis results: you can check the code at night, save the results, and load them in the morning and watch them. </li><li>  Running from the command line to check the entire solution: allows you to integrate PVS-Studio into nightly builds, so that everyone has a fresh log in the morning. </li><li>  Mark as False Alarm - markup in the code, so as not to swear specific diagnostics in a specific file fragment. </li><li>  Mass Suppression - suppress all old messages so that the analyzer generates 0 operations.  You can always return to them later.  Convenient implementation.  Errors only in the new code. </li><li>  Using relative paths in report files to enable report transfer to another machine. </li><li>  CLMonitoring - checking for projects that do not have Visual Studio files (.sln / .vcxproj);  if CLMonitoring's functionality is not enough for you, then you can integrate PVS-Studio into any Makefile-based build system manually. </li><li>  Good scalability: the analyzer can load all the processor cores.  Additionally can be used in conjunction with IncrediBuild. </li></ul><br>  You can learn more about the analyzer, as well as download it on the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> product page.  Finally, I will give a summary table of the main diagnostic capabilities of PVS-Studio.  Not all diagnostics are included in the table, as some of them are difficult to classify.  This does not hurt to make a general impression, and in detail with the existing diagnostics can be found <a href="http://www.viva64.com/ru/d/0368/">here</a> . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/dd2/108/3c1/dd21083c1fa51c60749263444a7349c1.png" alt="Table 1 - PVS-Studio features. Click on the picture to enlarge it."></a> <br>  <font color="#999999"><i>Table 1 - PVS-Studio features.</i></font>  <font color="#999999"><i>Click on the picture to enlarge it.</i></font> <br><br><h2>  PVS-Studio for Linux </h2><br>  Now we‚Äôll actually talk about why many people started reading this article: about supporting Linux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c4/d9d/519/6c4d9d519eb91b73daf8125733e75b45.png" alt="PVS-Studio love Linux"><br><br>  This task is not as simple as it may seem at first glance.  Compiling an executable for Linux and using it to check something is a simple task.  We have long dealt with it.  A year ago, we <a href="http://www.viva64.com/ru/b/0311/">wrote</a> an article about an experiment about checking Vim.  However, this is only a small part of the total amount of work.  Programmers forget that assembling an executable and creating a software product is not the same thing. <br><br>  We plan to support GCC and Clang.  We started with GCC, and we will return to Clang later.  I'll tell you about the tasks that are now facing us. <br><br><h3>  1. More complete support for GCC and Clang </h3><br>  Sometimes it seems to me that compiler developers are bored, and they come up with various ways to make life more difficult for themselves, and at the same time, developers who implement code highlighting, static analysis, and so on.  In another way, I cannot explain why, for example, it was necessary to introduce <a href="https://gcc.gnu.org/onlinedocs/gcc/Conditionals.html">Conditionals with Omitted Operands</a> .  Of course, it's cool that you can shorten the ternary operator to: z = x ?: y ;.  In my opinion, without this you can absolutely safely manage and live a happy life. <br><br>  Many wonder why you need to bother with various documented and undocumented extensions to the compiler.  It seems to be enough to analyze C ++ that is compliant with the standard and not to pay attention to extensions, as they are used extremely rarely.  Unfortunately, this is not the case, and extensions have to spend a lot of time. <br><br>  It doesn‚Äôt matter whether or not there are often non-standard entities in the program.  In any serious program will meet the header files containing some of the extensions.  As a result, it confuses the parser in the analyzer, and it cannot fully process the multitude of * .cpp files in which this unfortunate * .h file is included.  Of course, PVS-Studio analyzer has built-in mechanisms that try to compensate for the error in parsing the code and continue the analysis.  Unfortunately, this mechanism does not always help.  As a result, strange false positives can occur or, vice versa, a code fragment will be excluded from the analysis (until the end of the function or class, or even the entire file). <br><br>  Moreover, all sorts of "cunning" things like to use in the system header files.  So in practice it is very easy to run into some kind of expansion. <br><br>  If someone is interested in what is still being discussed, I can offer a look, for example, at: <ul><li>  Gcc  <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">Extensions to the C Language Family</a> </li><li>  Gcc  <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html">Extensions to the C ++ Language</a> </li></ul><br>  And these are only documented extensions.  From the experience of working with Visual C ++, we still expect the presence of sublimates in the form of undocumented extensions. <br><br>  Since we use our own parser (development of the now forgotten and abandoned OpenC ++ library), we must support various extensions. <br><br>  However, if we use some other parser, it would not help us much.  For example, if we rewrite the analyzer, taking Clang as a basis, we will still have to fight on our own with the GCC and Visual C ++ extensions. <br><br><h3>  2. New regression test system in Linux </h3><br>  When developing PVS-Studio, we use seven testing methods: <ol><li>  Static code analysis on developer machines.  All developers have PVS-Studio installed.  New or changed code is immediately checked using the incremental analysis mechanism.  C ++ and C # code is checked. </li><li>  Static code analysis for nightly builds.  If the warning was not noticed, it will be revealed at the stage of the night assembly on the server.  PVS-Studio checks C # and C ++ code.  In addition, we additionally use Clang to test C ++ code.  One time for C # code, FxCop was also used additionally.  During the year, he never found anything useful, and we refused to use it.  But Clang found errors a couple of times that PVS-Studio did not notice, and we found it rational to continue using it. </li><li>  Unit tests at the level of classes, methods, functions.  The system is not very developed, since many issues are difficult to test because of the need to prepare a large amount of input data for the test.  We rely more on high-level tests. </li><li>  Functional level tests of specially prepared and tagged files with errors. </li><li>  Functional tests confirming that we correctly parse the system header files.  This is important, since if non-standard extensions are used in the system file, this spoils the verification of many projects at once. </li><li>  Regression tests at the level of individual third-party projects and solutions (projects and solutions) are the most important and useful type of testing for us.  To implement it, we regularly check 105 open projects in C ++ and 49 in C #.  Comparing the old and new results of the analysis, we control that something has not been broken and we are honing new diagnostic messages. </li><li>  Functional user interface tests.  This refers to the testing of extensions (plug-in), which is integrated into the Visual Studio environment.  We check that clicking on various buttons and menu items leads to the desired results. </li></ol><br>  From the point of view of support for Linux, we need to first expand the item N5 and N6.  Item N5 overlaps with the previous section "Fuller support for GCC and Clang."  Making tests to check the system header files is easy, but time consuming to expand the parser.  However, we have already spoken about this, and point N6 is much more interesting. <br><br>  In fact, this is the largest and most complex testing system used by us.  Here is how this program looks in the process: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/597/4a4/bbe/5974a4bbe8be3c59585c92181b9ce5e4.png" alt="Testing system"></a> <br><br>  It makes no sense to describe this tool in the article, since it is intended solely for internal use.  I can only say that it makes it very convenient for developers to track the results of their edits in the analyzer core and add new diagnostics. <br><br>  So, now we have to create an analogue of such a system for Linux.  Since this is a very important part of the analyzer development process, we must approach this task with all seriousness.  We will also need to do a lot of work on the selection of open projects, on which the analyzer will be tested.  On the one hand, these projects should not be too large so as not to make the verification time too long.  On the other hand, they should be ‚Äúsaturated‚Äù: different projects should use different approaches to programming.  That is, it is desirable that <i>goto</i> operators were actively used somewhere, templates were actively used somewhere, Unicode was actively used somewhere, and so on.  This makes analyzer testing more comprehensive.  To collect such a collection of source codes is a very difficult task, requiring time to study a large number of open source projects. <br><br><h3>  3. Monitoring Compilers </h3><br>  Standalone.exe GUI utility is included in PVS-Studio for Windows.  With its help, you can conveniently work with reports (* .plog-files), if the Visual Studio development environment is not installed: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a9a/ea9/c67/a9aea9c670ed69686633b1db52f8b50c.png" alt="PVS-Studio Standalone Tool"></a> <br><br>  But this is not the main thing.  More importantly, with this utility you can check the project, assembled by any exotic or samopisnyy assembly system.  However, this is not intended for exotic situations.  Even if you have a classic makefile, it is easier to perform an analysis with Standalone, rather than deal with the PVS-Studio documentation, in order to write the analyzer's call to the maklefile. <br><br>  Standalone allows you to track the launches of compilers Visual C ++, GCC (MinGW), Clang and collect all the information you need to check.  It looks like this: you say the program ‚Äústart spying‚Äù, after which you perform an ordinary build of the project.  Then you say the program is "done."  Starts the analysis of all those files that have just been compiled. <br><br>  By the way, all this is not necessarily done manually.  You can use the CLMonitor.exe utility to check the project on the server.  It also collects information about running compilers and performs project validation. <br><br>  Implementing the Linux version, we immediately decided that it was necessary to support tracking the compiler runs.  This will help programmers to quickly and easily get acquainted with the PVS-Studio analyzer.  The fact is that, using this utility, the project will be able to test any member of the team, without distracting people involved in supporting makefiles and the build system in general.  In large projects, not everyone knows how their application is actually built.  Moreover, not everyone will find the time and desire to understand how and where to register the PVS-Studio call.  All this can be complicated by the presence of an autogenerated makefile.  It is clear that everything can be sorted out, but this is a significant barrier to the first verification of the project and the satisfaction of research curiosity. <br><br>  So you met another subtask to create a Linux version.  We are working on developing a system for monitoring compiler launches and assembling all the necessary information for verification. <br><br><h3>  4. Documentation revision </h3><br>  When writing documentation, we always face opposing desires.  On the one hand, we always tried to keep the product simple and understandable, and in order to work with it there was no need to get acquainted with a great guide.  On the other hand, static analysis is a rather complicated tool, and the manual should reflect all the subtleties of working with it.  This is especially true of the description of <a href="http://www.viva64.com/ru/d/0368/">diagnostic messages</a> : there are many of them, and it is necessary that each of them be described in detail and accompanied by code examples. <br><br>  As a result, we have a lot of work to adjust and supplement the documentation sections on work in Linux.  Plus, we need to figure out how to implement the ability for users to quickly receive information on a particular diagnosis.  In Visual Studio there are no problems with this - just click on the error code in the list of warnings and the corresponding page will open. <br><br>  How and what to offer in the Linux environment - you have to think.  Of course, there is always a PDF file (350 pages) or online documentation on the site, but this cannot be called a convenient way to access the description of diagnostics. <br><br><h3>  5. Finalization of the site </h3><br>  The site, of course, will also require some work.  This is not a programming task, but it‚Äôs necessary to do it, so I decided to mention the site for educational purposes.  Many programmers think only about the code and forget that many other colleagues are involved in the product release, solving a large number of problems hidden from them. <br><br><h3>  6. Other: testing, distribution, support organization </h3><br>  Naturally, do not forget about testing.  Although multi-level tests will reveal most of the problems, some completely unexpected errors or shortcomings will most likely manifest themselves.  Now it is even impossible to assume that this will happen, but we have no illusions about the ideality of the world.  Under Windows, we are faced with a variety of situations where it seems we are not to blame, but something is not working properly.  I spoke about some of these unpleasant surprises in <a href="http://www.viva64.com/ru/b/0231/">an interview</a> about 2 years ago (look for the phrase ‚ÄúUnfortunately, the beauty and reliability of the internal code sometimes falls apart due to the effects of a hostile environment‚Äù).  I'm sure there are similar surprises waiting for us in Linux. <br><br>  The results of our work should be wrapped in a distribution kit, which can be easily downloaded and used.  To say this is much easier than to do.  I think it will take more than one iteration to make it convenient and take into account various subtleties. <br><br>  One last thing: we must organize support for the new direction.  Our users appreciate us for quality and prompt support.  With the release of the Linux version, the number of requests will increase, especially at the beginning, when not everything will work, and we should be ready for this. <br><br><h3>  7. Plans for the future </h3><br>  Above, I have described far from everything that we will need to spend time in order to adapt PVS-Studio to Linux.  There are lots of smaller tasks that you don‚Äôt immediately remember, and it‚Äôs not interesting to write about them.  For example, I need to write this and many other articles that will tell people that PVS-Studio for Linux has appeared. <br><br>  There are big tasks that we will deal with later.  For example, as I said, at first we focused on GCC, and only then we plan to work with Clang.  I still don‚Äôt even know whether the first release version of PVS-Studio for Linux will support Clang or not. <br><br>  Here are some of the bigger challenges that await us: <ul><li>  Integration with Qt Creator. </li><li>  Integration with ... (time will tell). </li><li>  Refinement and improvement of diagnostics.  For example, inside PVS-Studio there are tables with information about typical functions, such as malloc, memset, std :: swap.  This information allows you to identify many errors incorrectly using functions.  It is worth expanding these tables with many of the functions described in POSIX. </li></ul><br><h2>  In progress </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/465/923/087/465923087805488c639d7d9f3c614038.png" alt="Pregnant unicorn"><br><br>  We look forward to when something can be presented to the world.  I hope I am interested in you, and many Linux developers want to try checking out their projects.  If you have the desire and time, I invite you to join the group of beta testers in advance. <br><br>  So, if you want to help us test the operation of PVS-Studio for Linux, please write to us.  To make the letters easier to process, please indicate the line ‚ÄúPVS-Studio for Linux, Beta‚Äù in the subject line.  Send letters to <a href="">support@viva64.com</a> .  Please write letters from corporate mailboxes and briefly introduce yourself.  We will be grateful to everyone who responds, but first of all we will pay attention to those people who can potentially become our clients over time. <br><br>  Also I ask in the letter to give answers to the following questions: <ul><li>  What operating system do you plan to run the analyzer under? </li><li>  What development environment are you using? </li><li>  What compiler is used to build the project? </li><li>  What build system are you using? </li></ul><br>  When there is a version that you can try, we will write letters to all responding. <br><br>  Thank you in advance.  We will occasionally mention in articles how the development of PVS-Studio for Linux is progressing.  I wish everyone to run the debugger less often! </div><p>Source: <a href="https://habr.com/ru/post/306636/">https://habr.com/ru/post/306636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306624/index.html">The creators of the film Zero Days shed light on the authors of Stuxnet</a></li>
<li><a href="../306626/index.html">Graphical user interface as a reflection of the real world: the shadows and the rise of elements</a></li>
<li><a href="../306628/index.html">Updated Cisco CCNA Certification Program</a></li>
<li><a href="../306632/index.html">Big Data analytics and supply chain evolution</a></li>
<li><a href="../306634/index.html">What to do with the found vulnerability and what to do if there is no Bug Bounty program?</a></li>
<li><a href="../306638/index.html">Important user experience lessons from the development of the combat HUD for the Dreadnought game</a></li>
<li><a href="../306642/index.html">The new rating of programming languages ‚Äã‚Äãfrom IEEE Spectrum turned out to be original</a></li>
<li><a href="../306644/index.html">CRAWL dynamic pages for Google and Yandex search engines (snapshots, _escaped_fragment_, ajax, fragment)</a></li>
<li><a href="../306646/index.html">What to keep in mind when rewriting software</a></li>
<li><a href="../306648/index.html">Systematization of publications in the web. Part 2 of 3: Three Steps to Scientific Respectability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>