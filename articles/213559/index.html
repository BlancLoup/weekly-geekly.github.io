<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network programming for game developers. Part 3: virtual connections over UDP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: This is a translation of the third article in the series "Networking for game programmers" . I really like the whole series of ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network programming for game developers. Part 3: virtual connections over UDP</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: This is a translation of the third article in the series <a href="http://gafferongames.com/networking-for-game-programmers/">"Networking for game programmers"</a> .</i>  <i>I really like the whole series of articles, plus I always wanted to try myself as a translator.</i>  <i>Perhaps an experienced developers article seems too obvious, but, as it seems to me, the benefits of it in any case will be.</i> <i><br></i>  <i>The first article is <a href="http://habrahabr.ru/post/209144/">http://habrahabr.ru/post/209144/</a></i> <i><br></i>  <i>The second article - <a href="http://habrahabr.ru/post/209524/">http://habrahabr.ru/post/209524/</a></i> <i><br></i> <br><hr><br><h4>  Virtual connections over UDP </h4><br><h5>  Introduction </h5><br>  Hey.  My name is Glenn Fiedler and I greet you in the third article in the series ‚ÄúNetwork Programming for Game Developers‚Äù. <br><br>  In the previous article, we figured out how to send and receive packets using the UDP protocol. <br><br>  Since UDP does not support connections, one UDP socket can be used to exchange packets with any number of remote computers.  However, in multiplayer games, as a rule, we exchange information with only a few nodes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/5b2/11c/e56/5b211ce564ff61b004b075a1ac8b1385.jpg"><br>  As a first step towards the implementation of the connection system, we consider the simplest case: the creation of a virtual connection between two computers. <br><br>  But first, we need to more tightly understand how the Internet works. <br><a name="habracut"></a><br><h5>  The Internet is not a collection of pipes </h5><br>  In 2006, Senator Ted Stevens entered the history of the Internet with his <a href="http://en.wikipedia.org/wiki/Series_of_tubes">famous speech</a> on the Network Neutrality Act: <br><br><blockquote>  ‚ÄúThe Internet is not a thing in which you can put something.  Not a big truck.  This is a set of pipes. ‚Äù </blockquote><br>  When I first started using the Internet, I thought the same way as Ted.  Sitting in the computer classroom at the University of Sydney in 1995, I ‚Äúsurfed the internet‚Äù with the help of a newfangled thing called Netscape Navigator, and had no idea what was really going on there. <br><br>  Then I thought that every time I connected to a site, a real connection was created, like during a telephone conversation.  And I thought - how much does it cost to connect to the site?  Thirty cents?  Dollar?  Will anyone from the university demand money from me for long-distance connections?  :) <br><br>  Of course, now it all sounds ridiculous. <br><br>  There is no remote, which is somewhere and directly connects you with a telephone wire to another computer to which you want to connect, no sets of pipes, which told us Senator Stevens. <br><br><h5>  No direct connections </h5><br>  Instead of all this, your data is sent over IP in packets that run from computer to computer. <br><br>  A packet can go through several nodes until it reaches the destination.  You cannot know in advance the number of these nodes, as it changes dynamically, depending on how the network decides to forward packets.  Even if you send two packages A and B to the same address, they can go in different ways.  This, by the way, is the reason for the lack of guaranteed delivery of packets in order in UDP. <br><br>  In unix-like systems, you can examine the packet paths with the ‚Äútraceroute‚Äù utility, passing it the host name or IP address. <br><br>  In windows, tracert is used instead of traceroute. <br><br>  Try to analyze routes to several sites, for example: <br><br><pre><code class="bash hljs">traceroute slashdot.org traceroute amazon.com traceroute google.com traceroute bbc.co.uk traceroute news.com.au</code> </pre> <br>  Look at the results of the utility, and you, I think, immediately make sure that there are no direct connections to the sites. <br><br><h5>  How are packages delivered? </h5><br>  In the first article of the cycle, I gave a simple analogy of the package delivery process - like passing a note from one person to another in a room full of people. <br><br>  Although this analogy reflects the general idea, it is too simplified.  The Internet is not a simple peer-to-peer network, but a network of networks.  And, of course, we need to send notes not within the room, but to anywhere in the world! <br><br>  Obviously, a lot better analogy is ... postal service! <br><br>  When you want to send someone a letter, you put it in the mailbox, and at the same time you are sure that it will come to the address.  It does not matter for you exactly how it will be delivered, but the fact of delivery is important.  Of course, someone must physically deliver the letter - but how? <br><br>  Obviously, the postman will not deliver your letter himself - the postal service is also not a set of pipes :).  Instead, he will take your letter to the post office for further processing. <br><br>  If the addressee of the letter lives in the same area as you, then at the post office your letter will simply be given to another postman, and he will assign it.  But if not, the more interesting process begins.  Your local post office cannot deliver the letter on its own, and it passes it ‚Äúhigher‚Äù through the hierarchy - to the regional office or postal center at the airport if the addressee is far away.  In the ideal case, your letter will be taken in a big truck (referring to the speech of that senator - approx. Transl.). <br><br>  Let's take a hard case - let's say we send a letter from Los Angeles to Sydney in Australia.  The local post office receives a letter, determines that it must be delivered abroad, and sends it to the postal center at Los Angeles airport.  They process the address of the letter again, and send it by the nearest flight to Sydney. <br><br>  The plane with a letter sits in Sydney, where a new postal service enters, and does all the same operations, but in reverse order.  The letter goes "down" in the hierarchy, from the general to the particular.  From the mail sorting point at the airport, it gets to the regional office, which, in turn, sends it to the local post office, and finally the postman (with a funny accent) hands the letter to the addressee.  Wonderful!  :) <br><br>  Just as the post office determines how to deliver a letter, based on the analysis of the recipient's address, packets in the network are delivered based on the analysis of the IP address.  The process of determining the route for transmitting a packet is rather complicated, but the basic idea is that each router is the same computer that has a routing table that determines where to send packets with specific destination addresses and the default gateway address to send packets for which there was no matching entry in the routing table.  All this together makes up the very ‚Äúnetwork of networks‚Äù - the Internet. <br><br>  Setting up routing tables is a task for network administrators, not developers (that is, us).  But if you want to learn more about this, then <a href="">this article</a> from ars technica magazine has a lot of interesting information about how networks exchange packets using peering and peering agreements.  You can also read about <a href="http://www.faqs.org/docs/linux_network/x-087-2-issues.routing.html">the routing tables</a> in this linux faq, and <a href="http://en.wikipedia.org/wiki/Border_Gateway_Protocol">the border gateway protocol (BGP)</a> in wikipedia, which automatically determines how to forward packets between networks ‚Äî which makes the Internet a truly distributed system with the ability to dynamically bypass corrupted communication channels. <br><br><h5>  Virtual connections </h5><br>  Now back to the topic of connections. <br><br>  If you have already worked with TCP sockets, then you know that working with them is similar to working with connections, however, since TCP runs on top of IP, and IP can only forward individual packets, TCP should have a virtual connection mechanism. <br><br>  And if TCP implements a virtual connection mechanism, it means that we can implement it using UDP. <br><br>  Also, let's define the term ‚Äúvirtual connection‚Äù as the exchange of UDP packets between two computers with a fixed frequency - say, ten packets per second.  As long as the packet exchange continues, the virtual connection is considered established. <br><br>  The connection has two ends: <br><br><ul><li>  The first computer is waiting for a connection from another computer - this computer will be called a server. </li><li>  The second computer connects to the server with a specific IP address and port.  This computer will be called a client. </li></ul><br>  In our case, only one client will be able to connect to the server at a time.  In future articles, we will refine the code so that the server can support several connections at once.  We also assume that the server will always have a public IP address, and the client can connect to it directly.  We will also discuss the topic of work through NAT in the following articles. <br><br><h5>  Protocol ID </h5><br>  Since UDP itself does not support connections, a UDP socket can receive packets from any computer. <br><br>  We need to limit this behavior so that the server accepts packets only from its client, and the client only from the server.  Nor can we simply filter packets at the sender‚Äôs address, since the server cannot know the addresses of the clients in advance.  Therefore, at the beginning of each UDP packet, we will add a small header 32 bits long, in which the unique identifier of the protocol will be stored. <br><br><pre> <code class="bash hljs">[ID   uint] ( ...)</code> </pre><br>  A protocol identifier is simply a unique number chosen for our protocol.  As soon as the UDP socket accepts the packet, it should immediately analyze the first four bytes of the packet.  If the data does not match our identifier, then the packet is discarded.  If matched, then these four bytes are truncated, and the rest of the packet data is sent for processing. <br><br>  You need to select a protocol identifier so that it is likely to be unique - for example, you can take a hash from the name of the game and the version number of the protocol.  Although by the way, you can take any number you want.  The point of the whole idea from the point of view of our protocol is to discard packets that do not have our chosen identifier. <br><br><h5>  Determining whether a compound is present </h5><br>  Next, we need to come up with a method for determining the presence of a compound. <br><br>  Of course, we could come up with some complicated scheme with ‚Äúhandshakes‚Äù and sending several UDP packets back and forth.  For example, the following: the client sends the ‚ÄúRequest Connection‚Äù packet to the server, and the server responds to it either with the ‚ÄúConnection established‚Äù packet or ‚ÄúBusy‚Äù if the client tries to connect to a server that already has a connection with another client. <br><br>  ... or we could simply program the server so that after receiving the first packet with the correct protocol identifier, it would immediately assume that the connection is established. <br><br>  In this case, the client can simply start forwarding packets to the server (assuming that the connection is already established), and when the server accepts the first packet, it will save the client‚Äôs IP address and port, and also start sending packets. <br><br>  In this case, the client, of course, knows in advance the IP address and port of the server, as it connects first.  Therefore, when a client receives packets in response from the server, it can filter them by the address.  Similarly, the server after receiving the first packet from the client can take the address and port of the client from the ‚Äúrecvfrom‚Äù function, and filter all other packets that will not come from the client. <br><br>  We can use this scheme because we have only two computers to connect.  In future articles, we will improve our connection implementation in such a way that it supports data exchange between more than two computers (like client-server or peer-to-peer), and improve the invented algorithm for filtering connections. <br><br>  But for the time being we will not complicate more and more than necessary. <br><br><h5>  Trip detection </h5><br>  And how do we determine the shutdown? <br><br>  Well, since we defined the connection as a packet transfer process, we can also define disconnection as the absence of packet transfer. <br><br>  To determine, in turn, the absence of packet transmission, we must monitor the number of seconds since the last packet was received from the other side, on both computers. <br><br>  Every time we receive a packet from another computer, we reset this counter, and in each new game cycle we increase its value by the number of seconds since the last cycle. <br><br>  If the counter exceeds a certain threshold, for example, ten seconds, we consider this a ‚Äútime-out‚Äù of the connection and close it. <br><br>  This algorithm also takes into account the case when a client tries to connect to a server that already has a connection with another client.  Since the server already has a connection, it drops all packets from addresses other than the address of the connected client, and therefore the second client (the one that tries to connect) does not receive response packets from the server, and its connection is disconnected due to a timeout. <br><br><h5>  Conclusion </h5><br>  So, here's what is required to create a virtual connection: the algorithm for establishing a connection, filtering non-participating packets, and a timeout mechanism for determining outages. <br><br>  Our connection is as real as any TCP connection, and the UDP packet it provides is enough for use in our future multiplayer action. <br><br>  In the article, we also discussed a bit how packet routing on the Internet works.  For example, we have learned the reason why UDP packets sometimes do not come in the correct order - because they can go different routes at the IP level.  Look at the map of the Internet - is it any wonder that the packages even go somewhere else?  If you want a better understanding of all this, a good starting point can be <a href="http://en.wikipedia.org/wiki/Internet_backbone">this article on wikipedia</a> . <br><br>  Now that we have a virtual connection mechanism over UDP, we can easily implement the data exchange between the client and the server for our multiplayer game ‚Äî and without using TCP. <br><br>  You can see an example implementation in the <a href="">source code</a> for this article. <br><br>  This is a simple client-server application that exchanges packets at a rate of 30 packets per second.  You can run the server on any machine, but with a public IP address, since <a href="http://www.jenkinssoftware.com/raknet/manual/natpunchthrough.html">packet forwarding via NAT</a> is not supported yet. <br><br>  You can start the client as follows: <br><br><pre> <code class="bash hljs">./Client 205.10.40.50</code> </pre><br>  In this case, it will try to connect to the server at the address you provide on the command line.  By default, if you do not specify anything, it will try to connect to 127.0.0.1. <br><br>  If one client is connected to the server, you can try to launch another client, and then you will see that it will not be able to connect - this is how it was intended.  In this implementation, only one client can be connected to the server. <br><br>  You can also try to stop the client or server when a connection is established between them, and then you will notice that after ten seconds, the application on the other side disconnects due to a timeout.  When the client is disconnected, control is returned to the shell, and when the server is disconnected, it returns to the pending state of connections from other clients. </div><p>Source: <a href="https://habr.com/ru/post/213559/">https://habr.com/ru/post/213559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213549/index.html">Box2d: Collision Anatomy</a></li>
<li><a href="../213551/index.html">[User experience] Audio-Technica ANC7b - full immersion</a></li>
<li><a href="../213553/index.html">Happy Defender of the Fatherland</a></li>
<li><a href="../213555/index.html">The history of game consoles in advertising. Part 2</a></li>
<li><a href="../213557/index.html">Shell - console Just for fun</a></li>
<li><a href="../213561/index.html">STM32CubeMX - advanced project generator for STM32</a></li>
<li><a href="../213565/index.html">Derby 0.6.0-alpha3 released</a></li>
<li><a href="../213567/index.html">Readpe console application</a></li>
<li><a href="../213569/index.html">The digest of news from the world of mobile development for the last week ‚Ññ41 (February 17-23, 2014)</a></li>
<li><a href="../213573/index.html">Digma R60G Review: Low Cost Reader with Pearl HD Screen and Backlight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>