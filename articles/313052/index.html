<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dissect OpenVPN. Part 1. Static keys</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I ran into an incomprehensible mistake in establishing an OpenVPN connection and felt a lack of understanding of how it works inside. Under the c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dissect OpenVPN. Part 1. Static keys</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/eb/f0/59ebf0eb40e30901826922.gif" align="left" height="160">  Once I ran into an incomprehensible mistake in establishing an OpenVPN connection and felt a lack of understanding of how it works inside.  Under the cut a story about how the cryptographic part of the protocol is arranged, how it all looks in reality (ie in Wireshark) and how to look inside the VPN, i.e.  decipher traffic hands (with the keys, of course ;-)).  In this part, we consider only the mode with static keys. </p><br><a name="habracut"></a><br><h1 id="rezhimy-raboty">  Modes of operation </h1><br><p>  OpenVPN itself without plug-ins supports 2 ways to establish a connection: </p><br><ul><li>  <b>PSK</b> (PreSharedKey or <b>static key mode</b> ) - with a symmetric key that is generated and written to all machines during the VPN setup process.  The first part of the article deals only with this mode. </li><li>  <b>TLS</b> - based on <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">public key infrastructure (PKI)</a> .  At the beginning, a TLS connection is established with the authentication of both parties using certificates, through which key material is exchanged.  Symmetric keys are generated from this key material and the traffic inside the VPN is already encrypted with these keys in the same way as in the PSK mode.  There is no user traffic channel inside the TLS channel - only the service information of OpenVPN itself.  I plan to write the second part about the preparation of OpenVPN in this mode. </li></ul><br><h1 id="podrobnee-pro-psk-rezhim">  More about PSK mode </h1><br><p>  PSK mode is enabled by the <i>secret</i> option, the first parameter of which is the name of the file with static keys that are generated during the VPN configuration step.  The file contains 2 pairs of 512 bit random keys (in each pair, the key for encryption and the key for HMAC), written down one by one (without headers and the rest) and encoded in HEX.  The same key file must be on all computers connected by VPN.  If the second optional parameter, <i>direction</i> , is not specified for the <i>secret</i> option, then only the first pair of keys will be used, that is, in both directions, the traffic will be signed and encrypted with the same keys. </p><br><p>  In static key mode, only <i>CBC</i> and <i>No-crypto</i> data packet formats ( <i>data channel crypto format</i> ) can be used.  Further we consider the <i>CBC</i> format, since  <i>No-crypto is</i> not so interesting. </p><br><p>  By default, <a href="https://ru.wikipedia.org/wiki/Blowfish">BlowFish is</a> used for encryption in <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">CBC</a> mode with a 128-bit key, and <a href="https://ru.wikipedia.org/wiki/SHA-1">SHA1</a> and a 160-bit key are used for <a href="https://ru.wikipedia.org/wiki/HMAC">HMAC</a> .  The first 128 and 160 bits from the 512 bit keys from the file with the static key are used as keys, respectively. </p><br><p>  Since all key information and settings are set in advance, if the address of the remote host (the <em>remote</em> option) is specified, the encapsulated traffic can be transmitted immediately after the launch of OpenVPN even before the exchange of control packets (they will be discussed below). </p><br><h1 id="testovyy-stend">  Test stand </h1><br><p>  The following key was used for tests (generated by the <em>openvpn --genkey --secret psk.key command</em> ): </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># # 2048 bit OpenVPN static key # -----BEGIN OpenVPN Static key V1----- 5234f60f846bb1d5f059c70e75434be6 &lt;--      89f41113ef56e2bf69253fad6a30ab5f a449204f52f64a0265fd5744a9489f41 cefd95a1d642830e9cf9cdce13c55245 270cf7d367ddc6b56eb1ba749be40e42 &lt;--      HMAC 80cdf7cfbad178348a0e057f1fdc87f0 e5ba84717475b868a7fd617fee8c561c b4575d983534ef71dd8aaa48a53ed469 0ae85faf4522f7defd89ba373a0d22ee &lt;--      f9356e487fdfa0796b0b1fc393fd3ab5 52db7a1ed691ddd50eeb7be2cc32d912 52df93987f4878ec42a12e3a7cda5a40 b1aa850a05821b300359a796313cbcec &lt;--      HMAC 4076483ec7692708c32d323ed080beba 60c58d9281fb5d27c688ac271d3b6d15 1695093291fb788dbbfefb8b7c7f9bef -----END OpenVPN Static key V1-----</span></span></code> </pre> <br><p>  In fact, every 4 lines with HEX is a 512 bit key.  1st and 3rd - keys for encryption, from each in the example only the first 128 bits will be used (the remaining 384 bits are not used at all), 2nd and 4th - keys for the <a href="https://ru.wikipedia.org/wiki/HMAC">HMAC</a> , from each the first 160 bits will be used .  In other words: </p><br><pre> <code class="python hljs">key_encrypt_0 = unhexlify(<span class="hljs-string"><span class="hljs-string">"5234f60f846bb1d5f059c70e75434be689f41113ef56e2bf69253fad6a30ab5fa449204f52f64a0265fd5744a9489f41cefd95a1d642830e9cf9cdce13c55245"</span></span>)[:<span class="hljs-number"><span class="hljs-number">16</span></span>] key_hmac_0 = unhexlify(<span class="hljs-string"><span class="hljs-string">"270cf7d367ddc6b56eb1ba749be40e4280cdf7cfbad178348a0e057f1fdc87f0e5ba84717475b868a7fd617fee8c561cb4575d983534ef71dd8aaa48a53ed469"</span></span>)[:<span class="hljs-number"><span class="hljs-number">20</span></span>] key_encrypt_1 = unhexlify(<span class="hljs-string"><span class="hljs-string">"0ae85faf4522f7defd89ba373a0d22eef9356e487fdfa0796b0b1fc393fd3ab552db7a1ed691ddd50eeb7be2cc32d91252df93987f4878ec42a12e3a7cda5a40"</span></span>)[:<span class="hljs-number"><span class="hljs-number">16</span></span>] key_hmac_1 = unhexlify(<span class="hljs-string"><span class="hljs-string">"b1aa850a05821b300359a796313cbcec4076483ec7692708c32d323ed080beba60c58d9281fb5d27c688ac271d3b6d151695093291fb788dbbfefb8b7c7f9bef"</span></span>)[:<span class="hljs-number"><span class="hljs-number">20</span></span>]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">For those who are not familiar with Python</b> <div class="spoiler_text"><p>  <em>unhexlify</em> simply turns a HEX string into an array of bytes. <br>  Index [: 16] means that we take the first 16 elements (bytes) of the sequence. <br>  Index [16:] means that we take everything except the first 16 bytes of the sequence. <br>  Index [16:20] means that we take the first 20 bytes and discard the first 16 of them. </p></div></div><br><p>  Settings files when working through UDP in static key mode using both pairs of keys (each direction is encrypted by its own pair): </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   dev tun ifconfig 192.168.1.1 192.168.1.2 remote 192.168.0.2 secret psk.key 0</span></span></code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   dev tun ifconfig 192.168.1.2 192.168.1.1 remote 192.168.0.1 secret psk.key 1</span></span></code> </pre> <br><p>  Where 192.168.0.1 and 192.168.0.2 are the addresses of the physical interfaces of the machines, and 192.168.1.1 and 192.168.1.2 are the corresponding addresses inside the tunnel. </p><br><p>  The <em>remote</em> option is sufficient to specify only one of the configuration files.  In this case, the host to which the <em>remote is</em> not specified will simply wait for the incoming connection (in this case, the UDP packet). </p><br><h1 id="prepariruem">  We prepare </h1><br><p>  The format of the transmitted packet is: </p><br><pre> <code class="hljs ruby">[Len (<span class="hljs-number"><span class="hljs-number">2</span></span> )] <span class="hljs-params"><span class="hljs-params">| HMAC (20 ) |</span></span> IV (<span class="hljs-number"><span class="hljs-number">8</span></span> ) <span class="hljs-params"><span class="hljs-params">| packet ID (4 ) |</span></span> timestamp (<span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-params"><span class="hljs-params">| packet payload</span></span></code> </pre> <br><p>  <i>Len</i> - the length of the entire packet, except for the first two bytes;  used only when working via TCP.  When working via UDP, the OpenVPN packet length is calculated from the UDP packet length, and the Len field in the OpenVPN packet does not exist. <br>  <i>HMAC</i> - HMAC-SHA1 from everything that comes after HMAC (IV and encrypted data) <br>  <i>IV</i> - initialization vector for CBC mode. <br>  Everything that comes after IV is transmitted encrypted. <br>  <i>Packet ID</i> - package number.  It is included here to protect against repetition, and is not used to organize guaranteed data delivery. <br>  <i>timestamp</i> - also used to protect against repetitions. <br>  <i>packet payload</i> - data that carries the packet.  This is either the OpenVPN service information or the encapsulated traffic itself. </p><br><div class="spoiler">  <b class="spoiler_title">What is HMAC</b> <div class="spoiler_text"><p>  <a href="https://ru.wikipedia.org/wiki/HMAC">HMAC</a> (key, message) is a function based on a cryptographic hash function (in this case, based on SHA1), which generates an authentication code ‚Äî a string of bits that serves as a signature for the message.  With a <strong>private key</strong> , message, and authentication code, anyone can verify that the authentication code is correct.  If the code is correct, then the message (in our case, the package) has not changed since it was signed by someone who has <b>the same</b> key.  Those.  to check HMAC, unlike EDS, both parties must have the same secret key. </p></div></div><br><h3 id="rasshifrovyvaem-sluzhebnye-pakety">  Decrypt service packages </h3><br><p>  Now promised wireshark (contrary to the statement on <a href="https://wiki.wireshark.org/OpenVPN">the dissector page</a> , he does not understand OpenVPN in static key mode): </p><br><img src="https://habrastorage.org/files/494/0a2/bb3/4940a2bb33b34f4ca13d8eea8e4a877a.jpg"><br><p>  Take the first packet and try to decrypt it.  Since  VPN is configured to work via UDP, then the Len field is not present, the package starts immediately with HMAC.  Let's try to calculate what the HMAC from this packet should be equal to without the HMAC field: </p><br><pre> <code class="python hljs">packet = unhexlify(<span class="hljs-string"><span class="hljs-string">"7c0a45b025b3225c9a60051699fc87bae44dec9026e792a7ff3842aabd7cc77b439564b42002e5e327cba04c620cd80ca92c60139e2345a2c5d99b0f"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"HMAC = %s"</span></span> % HMAC(key_hmac_0, packet[<span class="hljs-number"><span class="hljs-number">20</span></span>:], <span class="hljs-string"><span class="hljs-string">'sha1'</span></span>).hexdigest())</code> </pre> <br><pre> <code class="markdown hljs">HMAC = 7c0a45b025b3225c9a60051699fc87bae44dec90</code> </pre> <br><p>  We see that the HMAC calculated by us exactly coincides with the HMAC inserted into the packet.  So packet authentication is passed, and we are on the right track!  Now it's time to decipher it. </p><br><pre> <code class="python hljs">iv = packet[<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>] encrypted_part = packet[<span class="hljs-number"><span class="hljs-number">28</span></span>:] decrypted = Blowfish.new(key_encrypt_0, mode=Blowfish.MODE_CBC, IV=iv).decrypt(encrypted_part) print(<span class="hljs-string"><span class="hljs-string">" : %s"</span></span> % hexlify(decrypted).decode())</code> </pre> <br><pre> <code class="markdown hljs"> : 00000001 58069a45 287f346bd4ef7a812d56b8d3afc5459c00 07070707070707</code> </pre> <br><p>  The first 4 bytes are the packet number.  That's right, we took the first package.  The second 4 bytes are a timestamp.  Seven bytes 0x07 at the end is padding (the bytes added during encryption so that the message length is a multiple of the block length), it is correct, discarded. </p><br><pre> <code class="python hljs">packet_id = decrypted[:<span class="hljs-number"><span class="hljs-number">4</span></span>] timestamp = decrypted[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] decrypted_data = decrypted[<span class="hljs-number"><span class="hljs-number">8</span></span>:-decrypted[<span class="hljs-number"><span class="hljs-number">-1</span></span>]] <span class="hljs-comment"><span class="hljs-comment">#  packet_id  timestamp       print("ID : %s" % hexlify(packet_id).decode()) print(" : %s" % hexlify(timestamp).decode()) print(" : %s" % hexlify(decrypted_data).decode())</span></span></code> </pre> <br><pre> <code class="markdown hljs">ID : 00000001  : 58069a45  : 287f346bd4ef7a812d56b8d3afc5459c00</code> </pre> <br><p>  At first glance, it looks like a 16-byte random string and a zero byte are being transmitted.  Since  OpenVPN is an open source project, we go into the code and in the <em>occ.c</em> file we find the answer, partially confirming the hypothesis. </p><br><p>  287f346bd4ef7a812d56b8d3afc5459c - this is the <em>occ_magic</em> constant - a sign that the package is the OpenVPN control package.  It is followed by a type sign of the control packet, in this case it is byte 0x00 == <em>OCC_REQUEST</em> .  In the packet with OCC_REQUEST nothing more should be transmitted. </p><br><p>  Now decipher the second package: </p><br><img src="https://habrastorage.org/files/76b/a92/b6b/76ba92b6b413465092fac4f9f9cc47da.jpg"><br><pre> <code class="python hljs">packet = unhexlify(<span class="hljs-string"><span class="hljs-string">"91861a4479c376d3013cdcd7f3e657ac093048cdb3a40775fc5804f68842ef06288a9343acb298562aaa4c92c10aae2213441619c3df0d8b89a0f13f5dd69d1eaa0e22667938b68e38a1238e39b76b889b7b6e5dbadd8f3a264f6fc9bb9c225de387d5d17914b2e2853d7fbb706da429f596721ab394febe7e52875183f0e9e10ec16042398c4116c2069ef18f06da45b55581a9997d1f54def143b053226727934404be44379a0172d1b618bbf1b676b60f57889e734af6b54291d07d9c7e13573cc81e"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#        'secret'    'direction',         . key_hmac = key_hmac_1 key_encrypt = key_encrypt_1 print("HMAC = %s" % HMAC(key_hmac, packet[20:], 'sha1').hexdigest()) iv = packet[20:28] encrypted_part = packet[28:] decrypted = Blowfish.new(key_encrypt, mode=Blowfish.MODE_CBC, IV=iv).decrypt(encrypted_part) print(" : %s" % hexlify(decrypted).decode()) packet_id = decrypted[:4] timestamp = decrypted[4:8] decrypted_data = decrypted[8:-decrypted[-1]] #  packet_id  timestamp       print("ID : %s" % hexlify(packet_id).decode()) print(" : %s" % hexlify(timestamp).decode()) print("  HEX: %s" % hexlify(decrypted_data).decode()) print(" : %s" % decrypted_data)</span></span></code> </pre> <br><pre> <code class="markdown hljs">HMAC = 91861a4479c376d3013cdcd7f3e657ac093048cd  : 0000000158069a45287f346bd4ef7a812d56b8d3afc5459c0156342c6465762d747970652074756e2c6c696e6b2d6d747520313534342c74756e2d6d747520313530302c70726f746f2055445076342c6966636f6e666967203139322e3136382e312e31203139322e3136382e312e322c6b657964697220312c6369706865722042462d4342432c6175746820534841312c6b657973697a65203132382c73656372657400030303 ID : 00000001  : 58069a45   HEX: 287f346bd4ef7a812d56b8d3afc5459c0156342c6465762d747970652074756e2c6c696e6b2d6d747520313534342c74756e2d6d747520313530302c70726f746f2055445076342c6966636f6e666967203139322e3136382e312e31203139322e3136382e312e322c6b657964697220312c6369706865722042462d4342432c6175746820534841312c6b657973697a65203132382c73656372657400    ASCII: b'(\x7f4k\xd4\xefz\x81-V\xb8\xd3\xaf\xc5E\x9c\x01V4,dev-type tun,link-mtu 1544,tun-mtu 1500,proto UDPv4,ifconfig 192.168.1.1 192.168.1.2,keydir 1,cipher BF-CBC,auth SHA1,keysize 128,secret\x00'</code> </pre> <br><p>  We see that the first 16 bytes of this packet are <em>occ_magic</em> , and the next byte (type of control packet) is 0x01 == <em>OCC_REPLY</em> .  In the OCC_REPLY package, after the type of the package, a C-string with parameters is passed.  In this case, the following text is transmitted: <em>V4, dev-type tun, link-mtu 1544, tun-mtu 1500, proto UDPv4, ifconfig 192.168.1.1 192.168.1.2, keydir 1, cipher BF-CBC, auth SHA1, keysize 128, secret</em> .  The same line can be found in the OpenVPN log. </p><br><p>  The next two packages are <em>OCC_REQUEST</em> from the second host to the first and <em>OCC_REPLY</em> to it.  We decipher them in the same way: </p><br><img src="https://habrastorage.org/files/8d8/1b1/710/8d81b1710d4740a8bfd579d97c9ef9e4.jpg"><br><pre> <code class="markdown hljs">HMAC = fc52f6981ccb4d7c2a3c951bd1ce8e882f9155da ID : 00000002  : 58069a45   HEX: 287f346bd4ef7a812d56b8d3afc5459c00  : b'(\x7f4k\xd4\xefz\x81-V\xb8\xd3\xaf\xc5E\x9c\x00'</code> </pre> <br><img src="https://habrastorage.org/files/caa/2cb/b7b/caa2cbb7b4aa43e9889138f2744fa832.jpg"><br><pre> <code class="markdown hljs">HMAC = e4987efec6d4625e89ba26b69b0d8f54ed391c3c ID : 00000002  : 58069a45   HEX: 287f346bd4ef7a812d56b8d3afc5459c0156342c6465762d747970652074756e2c6c696e6b2d6d747520313534342c74756e2d6d747520313530302c70726f746f2055445076342c6966636f6e666967203139322e3136382e312e32203139322e3136382e312e312c6b657964697220302c6369706865722042462d4342432c6175746820534841312c6b657973697a65203132382c73656372657400  : b'(\x7f4k\xd4\xefz\x81-V\xb8\xd3\xaf\xc5E\x9c\x01V4,dev-type tun,link-mtu 1544,tun-mtu 1500,proto UDPv4,ifconfig 192.168.1.2 192.168.1.1,keydir 0,cipher BF-CBC,auth SHA1,keysize 128,secret\x00'</code> </pre> <br><p>  After receiving the settings of the remote host, the local host checks the compliance of its own and other people's settings and issues a warning if there are inconsistencies.  In this case, we see that the VPN settings on both sides match up to the direction: </p><br><p>  <em>V4, dev-type tun, link-mtu 1544, tun-mtu 1500, proto UDPv4, ifconfig 192.168.1.1 192.168.1.2, keydir 1, cipher BF-CBC, auth SHA1, keysize 128, secret</em> <br>  <em>V4, dev-type tun, link-mtu 1544, tun-mtu 1500, proto UDPv4, ifconfig 192.168.1.2 192.168.1.1, keydir 0, cipher BF-CBC, auth SHA1, keysize 128, secret</em> </p><br><h3 id="rasshifrovyvaem-inkapsulirovannyy-trafik">  Decrypt Encapsulated Traffic </h3><br><p>  The next packet in this traffic dump carries user data.  We decipher them in the same way as before: </p><br><img src="https://habrastorage.org/files/489/d96/6c3/489d966c3cb043fe89b104b1ea55db7b.jpg"><br><pre> <code class="markdown hljs">HMAC = efe4850d41f0e4a7535f13310685d74c2722a0da ID : 00000003  : 58069a45   HEX: 4500005420874000400196cec0a80102c0a80101080066ed1a1300014d9a0658000000005a390a0000000000101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637</code> </pre> <br><p>  There is neither occ_magic, nor ping_magic (another magic constant equal to <em>2a187bf3641eb4cb07ed2d0a981fc748</em> ), so this is a data packet.  In fact, 0x45 is the first byte of an IPv4 packet without optional header fields.  We see that this is exactly the same IPv4 packet with ping-request, which came out of the tun interface (in hex in the picture, IPv4 starts from the 2nd line): </p><br><img src="https://habrastorage.org/files/88e/fb6/af9/88efb6af92344912bf270b5df065a643.jpg"><br><p>  Return package: </p><br><img src="https://habrastorage.org/files/ac4/c70/eec/ac4c70eec8044818bb7e2a3a28b80afc.jpg"><br><pre> <code class="markdown hljs">HMAC = a0a0108cd173e8829b91e8b34bd5cac2ab8a9c0b ID : 00000003  : 58069a45   HEX: 450000547f00000040017855c0a80101c0a8010200006eed1a1300014d9a0658000000005a390a0000000000101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637</code> </pre> <br><p>  It can be seen that this is exactly the same IPv4 with the ping-reply that was sent to the tunnel: </p><br><img src="https://habrastorage.org/files/117/355/4e5/1173554e593040e9846d3ff1eb0e0e1e.jpg"><br><h1 id="zamechaniya">  Remarks </h1><br><h3 id="openvpn-ping">  OpenVPN Ping </h3><br><p>  There are also ping packages - service packages that OpenVPN sends to confirm the connection if too much time has passed since the last package was sent to another host (configured with keepalive, inactive and ping * options).  Unlike the usual icmp ping, OpenVPN does not respond to the received packet, but simply remembers that the connection is alive. </p><br><h3 id="nmap-vs-openvpn">  nmap vs OpenVPN </h3><br><p>  The UDP port, on which OpenVPN listens in PSK mode (as well as in TLS mode with the TLS-AUTH option enabled), for anyone who does not know the secret key, will look as if all the packets on it are dropping.  <strong>nmap</strong> will show the status of this port as "open | filtered".  In the OpenVPN logs (if the verb option is high enough), when scanning the port, the entries "Authenticate / Decrypt packet error: packet HMAC authentication failed" will be displayed. </p><br><h3 id="obnaruzhenie-trafika-openvpn">  OpenVPN traffic detection </h3><br><p>  In PSK mode, when working through UDP, the entire contents of the OpenVPN packets for an outside observer (who does not have secret keys) will look random, i.e.  there are no signatures that could be used to attribute these packages to OpenVPN.  However, the length of the packets will be out of the random data image - it depends on the hash function used and varies with a step equal to the block size of the cipher used, as well as the presence of service packets of a fixed length (OCC_REQUEST and OpenVPN PING packets). </p><br><p>  When working via TCP, besides, at the beginning of each OpenVPN packet there will be an unencrypted 2-byte packet length field. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  It can be seen that in the PSK mode, everything is very simple.  There is not even a client / server separation here. </p><br><p>  In TLS mode, establishing a connection is much more complicated, but it allows using <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">the public key infrastructure</a> , provides regular session key changes and implements <a href="https://ru.wikipedia.org/wiki/Perfect_forward_secrecy">Perfect forward secrecy</a> .  But about TLS mode in the next part. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313052/">https://habr.com/ru/post/313052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313038/index.html">Writing a simple React application using the cellx library</a></li>
<li><a href="../313040/index.html">A person. As the creator of JavaScript, Brendan Ike came to the creation of his company</a></li>
<li><a href="../313042/index.html">Configure the LoRaWAN gateway and create our first IoT application</a></li>
<li><a href="../313044/index.html">How will virtual offices affect our lives?</a></li>
<li><a href="../313048/index.html">Personal experience of receiving the Blue Card in Germany 2015-2016. Part 1: Job Search</a></li>
<li><a href="../313054/index.html">RailsClub 2016: podcasts with Ivan Nemytchenko and Ilya Zykin</a></li>
<li><a href="../313056/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 17</a></li>
<li><a href="../313058/index.html">Architecture and programming computer Texas Instruments TI-99 / 4a</a></li>
<li><a href="../313062/index.html">Programming & Music: Buttervo Frequency Filter. Part 3</a></li>
<li><a href="../313064/index.html">Customer support operator, manager, programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>