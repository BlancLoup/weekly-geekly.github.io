<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming Training: Finger Painting and Killing Zombies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zmob, my first (and only) own game. 

 By the end of the course, the width and depth of our collective knowledge was much more than anyone could have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming Training: Finger Painting and Killing Zombies</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cc/896/179/2cc89617998ab6fb20ae68966951102d.png"></div><br>  <i>Zmob, my first (and only) own game.</i> <br><br><blockquote>  By the end of the course, the width and depth of our collective knowledge was much more than anyone could have expected from <em>any high school course in any subject</em> . </blockquote><br><h2>  Education vs. Research </h2><br>  This semester, I work as an assistant teacher in an introductory course in Python, and this makes me depressed.  I recall my early years of programming, when the possibilities seemed almost limitless, and adding new features to my programs was a delightful and joyful process.  I was proud of every line, boasted to my friends about what amazing things I was able to do, and I felt all-powerful.  The world literally changed under my fingers.  I could put in flesh practically any idea that was interesting to me, and any facet of life that I wanted to explore.  I have developed an insatiable thirst for programming, which remains with me to this day. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/522/e47/d41/522e47d41f132bf978a0b6cd57fdbe54.jpg"></div><br>  <i>So I would look like in my youth, if there were more spaghetti in programming.</i> <br><br>  The irony is that when I look back at the programs I have written today, I feel endless embarrassment.  My old code was the artistic equivalent of kindergarten finger painting.  Yes, the drawing <em>resembles a</em> horse, but only because the child does not understand what he is doing.  In the programs I wrote there were a bunch of bugs, they are difficult to read, they are poorly ordered and full of confusing spaghetti logic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But I cannot deny how interesting it was, and how much I learned.  I will talk about this in more detail, but first I want to contrast my own experience with how students behave this semester.  Their lab work is nothing more than a meaningless data shuffle and implementation of dry, boring functions like <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2585%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%2593%25D0%25BE%25D1%2580%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0">the Horner scheme</a> for calculating polynomials.  And (surprisingly) their independent projects are even less interesting.  I think the biggest difference is that my students do not really need to solve problems by creating programs.  Therefore, their experience is reduced to repeating instructions and to the fact that they pretend to be computers to follow the logic of their own programs. <br><br>  Of course, I do not want to say that following instructions and simulating a computer in my head are not important for a good programmer.  I try to convey that my students are not enjoying their work.  Their solutions are as dry as the task itself, and I noticed that they are mostly happy when they finish the task and they don‚Äôt need to return to it anymore (even if their solution is completely wrong). <br><br>  The course also has its own problems.  For example, a professor teaches students C paradigms, not Python (I don‚Äôt think he learned to do anything correctly in Python at all), and they are confused when he talks about stack frames, registers and all kinds of irrelevant aspects of architecture .  Do not forget, these students have never written programs before, and some have started the course barely familiar with the computer.  I did not know what a frame frame is until I had been programming for three years (two of which were the years of my first experiments). <br><br>  All this made me quite often think about what I would teach students in my own course if I had one.  In this post, I will talk about how my own study of computer science began.  I will highlight the most important aspects: what made me love programming, and what taught me deep concepts on the example of natural contexts. <br><br><h2>  My first experience was with java </h2><br>  Fortunately, in my high school years (at <a href="http://www.acalanes.k12.ca.us/campolindo/">Campolindo High</a> , Moraga, California) there was an informatics course.  From early childhood I was familiar with computers (from three years, thanks to my parents), I loved video games and knew the basics of HTML, so I inevitably had to get on this course.  In retrospect, I consider him perhaps the most useful of all the courses for me, followed by in-depth English, German, and public policy.  He not only gave me the aforementioned thirst for programming, but also engendered in me a mathematical grain that had grown many years later into a huge beanstalk, which I have been climbing up to now. <br><br>  From the very beginning of the course was completely different.  The teachers were Mr. Mathers;  by the end of the first week the lectures were over.  Mr. Mathers showed us the bare minimum to write a simple program that receives and outputs data, and then left us alone with our computers. <br><br>  Roughly speaking, to complete the course you could choose one of two options.  First: follow the progress of classes and small projects from the GUI programming tutorial in Java.  Most of the students spent the first two months on assignments, and I, too, at least until I made a stupid little program for a pizzeria that allowed me to order pizza. <br><br>  The second option was much more free.  Students could do anything - Mr. Mathers jokingly told us: ‚Äúat the end of each quarter, I will evaluate your progress, and if you deserve a five, you will get it, but otherwise you will receive a unit!‚Äù <br><br>  Of course, Mr. Mathers was the nicest person I've ever met.  He calmly sat at his computer at the head of the class, and helped the students who approached him with questions.  He calmly and quietly listened to the student's question, and then suggested the correct way of seeing the problem.  Mr. Mathers better understood the level of student success by how frequent and relevant their questions were, and most often the students standing in line solved their problems on their own before they even got to the teacher. <br><br>  Most class students chose the path of ‚Äúample opportunity,‚Äù and this meant that they wanted to develop games.  I'm not talking about <em>good</em> games, I'm talking about games created by high school students.  I wrote the ugliest mole game in the world, stupid AI for Sea Battle, a poker machine with Mr. Mathers‚Äôs face on the shirt of all cards (it also replaced the faces of all kings, queens and jacks).  To create the last game, I even collaborated with other students who used a deck with Mr. Mathers‚Äôs face in their card games.  The cooperation became even closer in the second year of the course (yes, I took the same course again), but before we get to it, I have to tell you some more necessary details. <br><br>  First, the network in the office was designed in such a way that Mr. Mathers could remotely monitor from his computer any computer in the classroom.  The observation program had the reverent name of "Vision" and the quicktrips trembled before its power.  Vision allowed Mr. Mathers to view our code while we were standing in front of his desk, and helped him track students' progress.  Secondly, we were allowed to use a shared disk in the school network, so we could transfer files between computers in the office.  This gave direct benefits in learning, for example, we could share code examples, sprites and sound files from our programs.  But more importantly, it gave the class a sense of common culture.  Sometimes we held competitions in which every student of the Photoshop class Mats face into some funny scene (in fact, we used MS-Paint).  It was the birth of Internet memes, and naturally, we, the youth, were at the forefront of progress. <br><br>  Thirdly, we often had days of ‚Äúresearch‚Äù in which we were freed from all training obligations.  We could play games, surf the Internet, just sit and chat.  Most often, everything ended up playing Unreal Tournament on LAN, but by the end of my second code I decided to use these days to work on my programs;  It was more interesting for me to work on my games than to play other people. <br><br>  All this gave the course a feeling of relaxation.  We were not prepared for intermediate knowledge tests or in-depth exams (although over time I passed them, getting a rather high result, considering that I did not prepare for them at all).  Sometimes we were not even forced to work.  The course was more aimed at creating a community, and even though we were making fun of Mr. Mathers, we respected him as a teacher. <br><br>  Like me, most of the students who graduated from the first year are left with one more.  And then we began to appear awesome projects. <br><br><h2>  Zmob </h2><br>  The second year of the informatics course was entirely devoted to games.  Moreover, we started thinking about real-time games, such as side-scrolling platformers, which we liked to play (yes, Super Mario Brothers and Donkey Kong Country).  I tried to do something similar on my own, but quickly got lost in how to make collisions work.  Creating levels, animating characters, and scrolling the screen were challenging tasks, but feasible for me. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/191/cf9/038191cf935c8bc6de71c11c0c7b25a5.png"></div><br>  <i>One of my first side scrollers, inspired by the Starfox series.</i> <br><br>  But when I got tired of teaching the character to jump on the blocks, I found a better project: Zmob (abbreviated from Zombie Mob).  He was inspired by our collaboration.  I helped a friend find a way to draw two circles in a special way: one circle was large and stationary, and the second was smaller, always touched the first, and the line between the two centers passed through the position of the mouse cursor.  In other words, the smaller circle represented the ‚Äúdirection‚Äù of a pair of circles and was always directed towards the mouse.  It was a fairly simple trigonometry, but before I understood how to do this, I decided that it would be interesting to work on a zombie shooter with a top view.  Therefore, I started this project.  This is how the screensaver of the early version of the game looked like (typos and errors were completely saved): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88c/66f/785/88c66f785d1c0838aa997dae5aba9a1a.png"></div><br>  <i>Zmob 1.0 home screen</i> <br><br>  The player controls the black circle, and the gray circle indicates the weapon.  Zombies (blue circles) are regularly created in random positions and move at different speeds right in the direction of the character.  The player can walk on the field, and holding Shift, for some time to run faster than they.  And of course, the player shoots them until they die, and the game ends when a character dies.  The number of zombies created over time increases, and ammunition is limited (however, you can get more ammunition after a certain number of murders), so that the player‚Äôs death is inevitable.  The goal of the game is to score as many points as possible. <br><br>  The gameplay looked more like a shepherd‚Äôs job than the shooter, and although it was difficult, I don‚Äôt think that anyone else would play the game for more than ten minutes. <br><br>  It was important that I had a lot of ideas, and I needed to understand how to implement these ideas.  I wanted the zombies not to pass through each other.  I wanted to make a weapon that poisoned a zombie, so that when a poisoned zombie touched a healthy one, it would also poison it.  I wanted a lot of things going on in the game, and the solutions naturally came in the form of Java features that I used. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/56f/000/34656f0007e02b6b5ecf86403e7ea7db.png"></div><br>  <i>Poison cannon.</i>  <i>White zombies are poisoned, blue ones are healthy.</i> <br><br>  For example, in the beginning, zombies were simply indicated by circles.  There was no information that distinguished one zombie from another, so I could store them simply as a list of x, y coordinates.  When I wanted to add them a strip of life, and different speeds, and learn how to poison them, I had to create <em>a</em> zombie <em>class</em> so that each zombie could be asked for its internal state (poisoned or not, fast or slow, etc.).  Then I created a player class, item class, and bullet class. <br><br>  And the bullets were the most interesting part for me.  I wanted each bullet on the screen to be updated only when I called the ‚Äúupdate ()‚Äù function.  It turned out that this was similar to the transformation of a bullet into an <em>interface</em> , from which each specialized class of bullets inherited.  I have already seen the need and elegance of object-oriented programming.  All this completely eluded me when I made these stupid ‚ÄúShape‚Äù interfaces, repeating after the introductory tutorials.  I solved the problem that I needed to solve, and the understanding of inheritance remained forever in my mind. <br><br>  The logic of the bullets was a pleasure in itself.  The first three guns I created were boring: a pistol, a machine gun, and a shotgun.  As usual, they scattered small black circles.  I wanted to stand out and create a cool cannon.  I called my first idea a wave beam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/792/ac3/dc6792ac38c1bbbd920745d5bbf69c6d.png"></div><br>  <i>Wave beam: sinusoidal bullets.</i> <br><br>  The idea of ‚Äã‚Äãa wave beam was that the bullets move in the direction of a shot along a sine wave.  However, for me it became a huge difficulty: how can you turn a sine wave at an arbitrary angle?  I had the x and y coordinates of the bullets, but all the sophisticated formulas in which I randomly tried to use sines, cosines, and tangents failed miserably.  The best thing I managed to achieve was to get a sinusoid ugly stretched to the sides. <br><br>  After a week of unsuccessful attempts, I approached my statistical teacher (with whom I still keep in touch) and asked him if he knew the magical mathematical formulas that I needed. <br><br>  After thinking for a minute, he took out a textbook and showed me a page about the rotation matrix.  For the eyes of a seventeen-year-old, this formula was as mysterious as the ancient runes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/209/8f4/d6b/2098f4d6b8f847cd7fb97b60e8e2098d.png"></div><br>  As a result, I wrote the following code: <br><br><pre><code class="java hljs">x += frame*Math.cos(angle) + Math.sin(frame)*Math.sin(angle) y += frame*Math.sin(angle) + Math.sin(frame)*Math.cos(angle)</code> </pre> <br>  When I ran the code, it worked so perfectly that I screamed with delight.  After a week of torment and incompetent attempts to solve the problem, the solution turned out to be elegant, beautiful and wonderful.  After that, I used analysis to make my StarFox side scroller look more natural.  I experimented with other matrix operations, such as shear and stretch.  By the end of that year, I began to better understand the ‚Äúreplacement of the basis‚Äù (although I did not even know these words yet) than most of the students who studied linear algebra in college!  It was just another coordinate system for space;  there were rotated coordinates, increased and stretched coordinates, narrowed and inverse coordinates.  I tried all this in search of interesting gameplay. <br><br>  And I overtook the training program not only in mathematics.  By the end of the year I ‚Äúfinished‚Äù the game.  I created a chain weapon that created chain reactions when it hit a zombie, improved the look by adding new graphics for the player and the zombies.  I even developed a smart tile allocation system that measured the size of the screen and the window and correctly displayed the background.  I‚Äôm tired of measuring dimensions manually, so I wrote a program that did this work.  This seems trivial, but in fact this is the core of computer science problems. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/873/293/45287329341d8672b2b24823825fec64.png"></div><br>  The whole class was engaged in ‚Äúbeta testing‚Äù of the game, that is, we just spent a few days playing the game and finding bugs.  And my classmates found a lot of bugs.  Obvious (errors of dividing by zero drove the bullets crazy) and less noticeable (if you correctly calculate the time, the zombies will not be able to get close enough to the player and will just bump against each other). <br><br>  Another rather important problem emerged - speed.  After adding the images, I decided to use the Java library to rotate the images in each frame in the right direction.  Today, some say that Java is slow, but this part was <em>very</em> slow, especially when it came to hundreds and more zombies.  My solution, as it happens, turned out to be a programming paradigm called <em>caching</em> .  I calculated in advance all the turns that would be needed in the game, and then saved them.  Actually, what I implemented is called <em>lazy loading</em> .  This is a slightly more complicated technique used to store only calculated turns when they are necessary. <br><br>  I learned the name of this technique only when I got to dynamic web programming, studied in the third year of college, and we discussed the object-relational display of Hibernate data for databases!  As in the case of linear algebra, the tasks that I set for myself on my own allowed me to discover or reinvent important concepts much earlier than if I had been taught them.  I developed a deep understanding of the concepts and the types of tasks that they can solve.  It was completely different from the study that takes place in college: students remember the name of the concept and its meaning, but only the best students manage to understand why it is important and how to use it. <br><br><h2>  Honest analysis in retrospect </h2><br>  I must admit that I was more devoted to my work than the average student.  A small part of the class was engaged only in nonsense.  Some students had a goal in their head, but they did not pursue it with the same perseverance as I did.  We did not have access to many good examples outside of our own wandering on the Internet and the mediocre quality of the books that Mr. Mathers had.  The selected Java language for some probably had a too steep learning curve, but as a result, it did more good than harm. <br><br>  But on the other hand, those of us who worked well studied everything independently and learned the material at our own pace.  We fought with tasks that we ourselves wanted to solve, which led us to new insights.  One of my classmates made a chat client and a network version of Tron, others wrote role-playing games, music applications, encryption algorithms, and more.  By the end of the course, the width and depth of our collective knowledge was much more than anyone could have expected from <em>any high school course in any subject</em> .  I do not say this at random: I spent a lot of time analyzing the literature, discussing modern problems, memorizing a German dictionary, editing an essay and conducting biological experiments, but programming was a special case.  This experience was fascinating, artistic, technical, logical and <em>intuitive</em> .  Moreover, this skill has proven useful to me in the labor market.  Today, I can graduate from the master's program and find a good job as a software engineer in any major city and probably in any of the industries in which they are engaged in software.  It was this course that set me on the path that I am taking now. <br><br>  Worst of all, <u>my heart breaks</u> when my students say, ‚ÄúI didn‚Äôt think programming would be like <em>this</em> .‚Äù  I'm not ready for this.  Best of all, I can answer them: ‚ÄúDo not judge programming in this course.  In fact, it can be fun. ‚Äù <br><br><h2>  What do they need </h2><br>  For me, it is absolutely clear - to interest students in programming, they need a couple of things: <br><br>  <strong>1. Instant reward</strong> <br><br>  My students spend too much time figuring out their own code.  Something needs to be changed so that they see the effect right away.  They need training tools designed by <a href="http://www.youtube.com/watch%3Fv%3DPUv66718DII">Brett Victor</a> (to understand what I'm talking about, rewind the video at 10:30, but it's worth it to watch the whole thing).  And they need to work on visual programs.  Programs for drawing, games and music.  Programs, whose effect can be felt in a non-intellectual way, and not boring checking that they correctly consider derivatives of polynomials. <br><br>  <strong>2. Projects must be meaningful, or at least interesting.</strong> <br><br>  As when I was studying myself, students need the opportunity to study.  Let them work on their own projects and, as a teacher, have enough knowledge to help them when they reach a dead end (or better yet, brainstorm with them).  If creating a project that is unique for each student is impossible, then at least let them work on something meaningful.  Alas, in the last two projects of the course, which I teach, students were engaged in the input / output of files and the addition of matrices.  Why not let them work on a video game or a search engine (this may seem complicated, but here‚Äôs an introductory course on <a href="http://www.udacity.com/overview/Course/cs101">udacity</a> ), or on drawing / animation, on a chat client, on a sudoku solution?  Yes, at least show how to get data from Facebook through the Graph API.  All these things can be largely abstract, so that a student of any level can cope with them, and at the same time, each of them requires the ability to work with certain concepts (basics of working with the network for a chat client, sudoku matrix, input-output files in parts of the search engine, etc.).  Despite the abundance of interesting things that students can work on, teachers, it seems, simply do not want to give them interesting projects, so again and again they force students to calculate the sums of matrices. <br><br>  <strong>3. The ability to read someone else's code.</strong> <br><br>  This is an integral part of learning.  Students should not only be able to write their own code, but also read someone else's.  They should be able to look at examples and select important parts from them for use in their own work.  They must learn to collaborate with their classmates, work on a common project, and brainstorm when discussing bugs.  They must learn to <em>criticize the</em> code, how they can criticize a movie or a cafe.  Students should have their own judgments about the software and strive for the correct implementation, openly ridiculing the bloated or chaotic code (well, maybe not so hard, but they still need to be consciously prepared for this). <br><br>  These three principles underlie computer science and software development, and the rest of the stuff (stack frames, lazy booting and Linux shells) can wait until students are interested and start striving for more.  Moreover, it can wait until they have the opportunity to <em>choose an</em> area that requires knowledge of Linux shells, or web frameworks, or network security, or graphics processing.  I learned all the basics and something else without touching the Linux terminal and not even knowing about its existence.  And I have no doubt that my current students are also capable of that. <br><br>  And when students are completely immersed in the code (like me, having spent a year or two writing spaghetti code), they can learn to see the beauty of the elegant ways of organizing programs, and the expressive power that you can have for writing useful programs.  In a sense, programming is similar to architecture: a good program has the beauty of form and functionality.  At this point, they should start thinking about system and network programming, because then they can compare the new paradigms with their own.  They can criticize, discuss and make innovations, or at least appreciate them, and apply ideas to the ‚Äúzombie projects‚Äù they are working on. <br><br>  I am of the opinion that in every computer science curriculum there should be several courses used as a blank sheet of paper, and in the learning process one of them should be given as early as possible (maybe even as part of the very first course).  I think that students are not taught this way for the same reason that in teaching math: proper teaching is <em>hard work</em> !  No matter how sad it may sound, professors (especially in research educational institutions) do not have time to develop carefully designed student projects. <br><br>  And while I'm in the training system, I will work to make a difference.  I will develop courses so that they are interesting, and help my future employees who do not succeed.  Even in highly structured courses, I will allow students to work on free projects. <br><br>  Therefore, I will add to my wish list of a high school teacher a course called ‚ÄúProgramming as drawing with fingers‚Äù.  (Or "Programming on a clean sheet"? Or "How to kill zombies"?) I am open to suggestions. </div><p>Source: <a href="https://habr.com/ru/post/348748/">https://habr.com/ru/post/348748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348736/index.html">DM.Mobile Trade: what puzzles were solved by our Android developers in the new release and why</a></li>
<li><a href="../348738/index.html">Crash Course on Assemblers</a></li>
<li><a href="../348740/index.html">Microservice madness will be held in 2018</a></li>
<li><a href="../348744/index.html">Web development as an incentive or in pursuit of a dream</a></li>
<li><a href="../348746/index.html">Issue # 10: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../348750/index.html">Open lesson on the topic ‚ÄúAudit of advertising campaigns in Yandex. Direct ¬ª</a></li>
<li><a href="../348752/index.html">How the virtual infrastructure will develop: 4 main trends</a></li>
<li><a href="../348754/index.html">Backblaze statistics, a scientific approach to analyzing drive reliability</a></li>
<li><a href="../348756/index.html">Automatic vectorization of satellite images: one model - the first two places</a></li>
<li><a href="../348758/index.html">When the experience of the 25k + team is included in the lecture: how EPAM collaborates with universities in Belarus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>