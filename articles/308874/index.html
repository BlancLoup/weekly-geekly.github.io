<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>64-bit browser arithmetic and WebAssembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly is being actively developed and has already reached the state when the assembled module can be tried in Chrome Canary and Firefox Nightly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>64-bit browser arithmetic and WebAssembly</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/8f3/c82/6fb/8f3c826fb43d4fd698aed6a6afd6798b.png" align="left">  WebAssembly is being actively developed and has already reached the state when the assembled module can be tried in Chrome Canary and Firefox Nightly by turning on the checkbox in the settings. </p><br><p>  Let's compare the performance of arithmetic calculations with 64-bit numbers in WebAssembly, asm.js, PNaCl and native-code.  Let's look at the tools that are available for WebAssembly now, and look into the near future. </p><a name="habracut"></a><br><h1 id="disclaimer">  Disclaimer </h1><br><p>  WebAssembly is currently under development, in a month the article may become outdated.  The purpose of the article is to tell about the situation for those who are interested. </p><br><h1 id="tldr">  TL; DR </h1><br><p>  <a href="https://antelle.github.io/argon2-browser">demos</a> , <a href="https://github.com/antelle/argon2-browser">graphics</a> </p><br><h1 id="algoritm">  Algorithm </h1><br><p>  As a benchmark, we take Argon2, which I recently needed to calculate in the browser. <br>  Argon2 ( <a href="https://github.com/P-H-C/phc-winner-argon2">github</a> , <a href="https://habrahabr.ru/post/281569/">habr</a> ) is a relatively new cryptographic key generation function (key derivation function, KDF) that won the <a href="https://password-hashing.net/">Password Hashing Competition</a> . </p><br><p>  It is based on 64-bit arithmetic, here are the functions that are executed about 60M times in one iteration: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> fBlaMka(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = UINT64_C(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> xy = (x &amp; m) * (y &amp; m); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + <span class="hljs-number"><span class="hljs-number">2</span></span> * xy; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> rotr64(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> w, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (w &gt;&gt; c) | (w &lt;&lt; (<span class="hljs-number"><span class="hljs-number">64</span></span> - c)); }</code> </pre> <br><h1 id="slozhnosti-realizacii-na-asmjs">  Implementation difficulties on asm.js </h1><br><p>  It would seem that everything is simple: take and multiply two 64-bit numbers, as is done in the native-code argon2, for example, by calling an sse-instruction.  But not in the browser. </p><br><p>  In V8, as you know, there are no 64-bit integers, so all arithmetic, for lack of a better one, is emulated by 31-bit smi (small integer).  Which is very slow.  So slow and so ugly that the developers of Unity repeatedly mentioned it, and 64-bit types were <a href="https://github.com/WebAssembly/design/issues/81">included</a> in WebAssembly MVP, although at first they wanted to postpone it for later. </p><br><p>  Let's look at the code generated by asm.js for the multiplication function of two int64, this is the function from the compiler-rt: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">___muldsi3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$a, $b</span></span></span><span class="hljs-function">) </span></span>{ $a = $a | <span class="hljs-number"><span class="hljs-number">0</span></span>; $b = $b | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">6</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">11</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">12</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; $<span class="hljs-number"><span class="hljs-number">1</span></span> = $a &amp; <span class="hljs-number"><span class="hljs-number">65535</span></span>; $<span class="hljs-number"><span class="hljs-number">2</span></span> = $b &amp; <span class="hljs-number"><span class="hljs-number">65535</span></span>; $<span class="hljs-number"><span class="hljs-number">3</span></span> = Math_imul($<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; $<span class="hljs-number"><span class="hljs-number">6</span></span> = $a &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; $<span class="hljs-number"><span class="hljs-number">8</span></span> = ($<span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (Math_imul($<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; $<span class="hljs-number"><span class="hljs-number">11</span></span> = $b &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; $<span class="hljs-number"><span class="hljs-number">12</span></span> = Math_imul($<span class="hljs-number"><span class="hljs-number">11</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (tempRet0 = (($<span class="hljs-number"><span class="hljs-number">8</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (Math_imul($<span class="hljs-number"><span class="hljs-number">11</span></span>, $<span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>) + ((($<span class="hljs-number"><span class="hljs-number">8</span></span> &amp; <span class="hljs-number"><span class="hljs-number">65535</span></span>) + $<span class="hljs-number"><span class="hljs-number">12</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> | ($<span class="hljs-number"><span class="hljs-number">8</span></span> + $<span class="hljs-number"><span class="hljs-number">12</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | $<span class="hljs-number"><span class="hljs-number">3</span></span> &amp; <span class="hljs-number"><span class="hljs-number">65535</span></span>)) | <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  <a href="">Here it is</a> , and here <a href="">it is in JavaScript</a> .  The implementation is very good by the way, not causing deopts in V8.  Check it out just in case: </p><br><p>  Compile asm.js, disabling variable renaming so that the function names in the code are readable, and run with flags that allow you to open artifacts in <a href="http://mrale.ph/irhydra/2/">IR Hydra</a> (you can simply install npm i -g node-irhydra): </p><br><img src="https://habrastorage.org/files/eb6/7d9/34c/eb67d934c7c94828b623a4a81cfaa01f.png"><br><p>  As you can see, V8 even zainlayn __muldsi3 function in <code>__muldi3</code> .  You can also look at the assembler code of this function. </p><br><div class="spoiler">  <b class="spoiler_title">IR</b> <div class="spoiler_text"><pre> <code class="hljs go">v50 EnterInlined ___muldsi3 Tagged i71 Constant <span class="hljs-number"><span class="hljs-number">65535</span></span> Smi i72 Bitwise BIT_AND i234 i71 TaggedNumber i76 Bitwise BIT_AND i236 i71 TaggedNumber t79 LoadContextSlot t47[<span class="hljs-number"><span class="hljs-number">13</span></span>] Tagged t82 CheckValue t79 <span class="hljs-number"><span class="hljs-number">0x3d</span></span>78a90c3b59 &lt;JS Function imul (SharedFunctionInfo <span class="hljs-number"><span class="hljs-number">0x3d78a9058f</span></span>91)&gt; Tagged i83 Mul i76 i72 TaggedNumber i88 Constant <span class="hljs-number"><span class="hljs-number">16</span></span> Smi i89 Shr i234 i88 TaggedNumber i94 Shr i83 i88 TaggedNumber i100 Mul i76 i89 TaggedNumber i104 Add i94 i100 TaggedNumber i111 Shr i236 i88 TaggedNumber i118 Mul i111 i72 TaggedNumber i125 Shr i104 i88 TaggedNumber i131 Mul i111 i89 TaggedNumber i135 Add i125 i131 TaggedNumber i142 Bitwise BIT_AND i104 i71 TaggedNumber i145 Add i142 i118 TaggedNumber i151 Shr i145 i88 TaggedNumber i153 Add i135 i151 TaggedNumber t238 Change i153 i to t v158 StoreContextSlot t47[<span class="hljs-number"><span class="hljs-number">12</span></span>] = t238 changes[ContextSlots] Tagged v159 Simulate id=<span class="hljs-number"><span class="hljs-number">319</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] = t47, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] = i234, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] = i236, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>] = i83, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>] = t6, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>] = i104, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>] = t6, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>] = i118, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">9</span></span>] = t6, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-number"><span class="hljs-number">7</span></span>] = t6, push i153 Tagged i163 Add i104 i118 TaggedNumber i166 Shl i163 i88 TaggedNumber i170 Bitwise BIT_AND i83 i71 TaggedNumber i172 Bitwise BIT_OR i166 i170 TaggedNumber v179 LeaveInlined Tagged v180 Simulate id=<span class="hljs-number"><span class="hljs-number">172</span></span> pop <span class="hljs-number"><span class="hljs-number">1</span></span> / push i172 Tagged v181 Goto B3 Tagged</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Assembler</b> <div class="spoiler_text"><p>  140 andl r8,0xffff <br>  ;;  &lt;@ 43, # 72&gt; gap <br>  147 movq r9, rdx <br>  ;;  &lt;@ 44, # 76&gt; bit-i <br>  150 andl r9,0xffff <br>  ;;  &lt;@ 48, # 79&gt; load-context-slot <br>  170 movq r11, [r11 + 0x77] <br>  ;;  &lt;@ 50, # 82&gt; check-value <br>  174 movq r10,0x3d78a90c3b59 ;;  object: 0x3d78a90c3b59 &lt;JS Function imul (SharedFunctionInfo 0x3d78a9058f91)&gt; <br>  184 cmpq r11, r10 <br>  187 jnz 968 <br>  ;;  &lt;@ 51, # 82&gt; gap <br>  193 movq rdi, r9 <br>  ;;  &lt;@ 52, # 83&gt; mul-i <br>  196 imull rdi, r8 <br>  ;;  &lt;@ 53, # 83&gt; gap <br>  200 movq r11, rax <br>  ;;  &lt;@ 54, # 89&gt; shift-i <br>  203 shrl r11, 16 <br>  ;;  &lt;@ 55, # 89&gt; gap <br>  207 movq r12, rdi <br>  ;;  &lt;@ 56, # 94&gt; shift-i <br>  210 shrl r12, 16 <br>  ;;  &lt;@ 58, # 100&gt; mul-i <br>  214 imull r9, r11 <br>  ;;  &lt;@ 60, # 104&gt; add-i <br>  218 addl r9, r12 <br>  ;;  &lt;@ 61, # 104&gt; gap <br>  221 movq r12, rdx <br>  ;;  &lt;@ 62, # 111&gt; shift-i <br>  224 shrl r12, 16 <br>  ;;  &lt;@ 63, # 111&gt; gap <br>  228 movq r14, r12 <br>  ;;  &lt;@ 64, # 118&gt; mul-i <br>  231 imull r14, r8 <br>  ;;  &lt;@ 65, # 118&gt; gap <br>  235 movq r8, r9 <br>  ;;  &lt;@ 66, # 125&gt; shift-i <br>  238 shrl r8, 16 <br>  ;;  &lt;@ 68, # 131&gt; mul-i <br>  242 imull r12, r11 <br>  ;;  &lt;@ 70, # 135&gt; add-i <br>  246 addl r12, r8 <br>  ;;  &lt;@ 71, # 135&gt; gap <br>  249 movq r8, r9 <br>  ;;  &lt;@ 72, # 142&gt; bit-i <br>  252 andl r8,0xffff <br>  ;;  &lt;@ 74, # 145&gt; add-i <br>  259 addl r8, r14 <br>  ;;  &lt;@ 76, # 151&gt; shift-i <br>  262 shrl r8, 16 <br>  ;;  &lt;@ 78, # 153&gt; add-i <br>  266 addl r8, r12 <br>  ;;  &lt;@ 80, # 238&gt; smi-tag <br>  269 ‚Äã‚Äãmovl r12, r8 <br>  272 shlq r12, 32 <br>  ;;  &lt;@ 84, # 158&gt; store-context-slot <br>  289 movq [r11 + 0x6f], r12 <br>  ;;  &lt;@ 86, # 163&gt; add-i <br>  293 leal r8, [r9 + r14 * 1] <br>  ;;  &lt;@ 88, # 166&gt; shift-i <br>  297 shll r8, 16 <br>  ;;  &lt;@ 90, # 170&gt; bit-i <br>  301 andl rdi, 0xffff <br>  ;;  &lt;@ 92, # 172&gt; bit-i <br>  307 orl rdi, r8 </p></div></div><br><p>  Chrome does not generate the optimal code, as you could do with type annotations, the V8 developers basically do not want to support the asm.js js subset, and in general, that's right.  In contrast, Firefox, seeing "use asm", in case the code passes validation, throws out some checks, with the result that the resulting code is faster about 3..4 times faster. </p><br><p>  Compared to native code, Chrome and Safari are 50 times slower, Firefox is 12 times slower. <br>  IE11 is quite slow, but Edge with asm.js enabled is somewhere in the middle between Chrome and Firefox: </p><br><img src="https://habrastorage.org/files/4d2/290/cdc/4d2290cdc65e40998f36823300822579.png"><br><h1 id="webassembly">  WebAssembly </h1><br><p>  Compile this code in WebAssembly.  This <a href="https://github.com/WebAssembly/binaryen">can be</a> done in several ways, first we will try C / C ++ Source ‚áí asm2wasm ‚áí WebAssembly (some parameters are excluded for brevity): </p><br><pre> <code class="bash hljs">cmake \ -DCMAKE_TOOLCHAIN_FILE=~/emsdk_portable/emscripten/incoming/cmake/Modules/Platform/Emscripten.cmake \ -DCMAKE_C_FLAGS=<span class="hljs-string"><span class="hljs-string">"-O3"</span></span> \ -DCMAKE_EXE_LINKER_FLAGS=<span class="hljs-string"><span class="hljs-string">"-O3 -g0 -s 'EXPORTED_FUNCTIONS=[\"_argon2_hash\"]' -s BINARYEN=1"</span></span> &amp;&amp; cmake --build .</code> </pre> <br><p>  You can use the same toolchain as for the asm.js assembly, specifying that we want to use binaryen ( <code>-s BINARYEN=1</code> ). <br>  At the output we get: </p><br><ul><li>  wast file: textual representation of WebAssembly, S-Expressions. </li><li>  mappedGlobals: json with functions exported from the module and available in JavaScript, there will be runtime functions and what we have specified in <code>EXPORTED_FUNCTIONS</code> . </li><li>  js-wrapper that manages a wasm module or can execute code in other ways if wasm is not supported. </li><li>  asm.js code that will be used as a fallback, in case there is no support for wasm. </li></ul><br><p>  Convert the wast file to <a href="">the</a> wasm <a href="">binary format</a> : </p><br><pre> <code class="bash hljs">~/binaryen/bin/wasm-as argon2.wast &gt; argon2.wasm</code> </pre> <br><h1 id="ispolzuem-modul-v-brauzere">  We use the module in the browser </h1><br><p>  What can js-wrapper do except call the wasm-module and how to use it? </p><br><ul><li>  load binary wasm module </li><li>  create a <code>Module</code> object with settings </li><li>  any way to import the script into the browser </li></ul><br><pre> <code class="javascript hljs">global.Module = { <span class="hljs-attr"><span class="hljs-attr">print</span></span>: log, <span class="hljs-attr"><span class="hljs-attr">printErr</span></span>: log, <span class="hljs-attr"><span class="hljs-attr">setStatus</span></span>: log, <span class="hljs-attr"><span class="hljs-attr">wasmBinary</span></span>: loadedWasmBinaryAsArrayBuffer, <span class="hljs-attr"><span class="hljs-attr">wasmJSMethod</span></span>: <span class="hljs-string"><span class="hljs-string">'native-wasm,'</span></span>, <span class="hljs-attr"><span class="hljs-attr">asmjsCodeFile</span></span>: <span class="hljs-string"><span class="hljs-string">'dist/argon2.asm.js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">wasmBinaryFile</span></span>: <span class="hljs-string"><span class="hljs-string">'dist/argon2.wasm'</span></span>, <span class="hljs-attr"><span class="hljs-attr">wasmTextFile</span></span>: <span class="hljs-string"><span class="hljs-string">'dist/argon2.wast'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'dist/argon2.wasm'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.responseType = <span class="hljs-string"><span class="hljs-string">'arraybuffer'</span></span>; xhr.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ global.Module.wasmBinary = xhr.response; <span class="hljs-comment"><span class="hljs-comment">// load script }; xhr.send(null);</span></span></code> </pre> <br><p>  Here we indicate the location of the compiled artifacts, connect our logs and determine the method by which we will execute the code.  From the methods you can choose: </p><br><ul><li>  <code>native-wasm</code> : use wasm support in the browser; </li><li>  <code>interpret-s-expr</code> : load .wast textual representation and interpret it; </li><li>  <code>interpret-binary</code> : interpret the .wasm binary format; </li><li>  <code>interpret-asm2wasm</code> : load asm.js code, compile it into .wasm and execute; </li><li>  <code>asmjs</code> : execute asm.js code. </li></ul><br><p>  You can list several methods separated by commas, then the first successful one will be executed.  The default method is <code>native-wasm,interpret-binary</code> , that is, try if there is no wasm, if not, then interpret the binary module. </p><br><p>  After successful loading, all exported methods appear in the <code>Module</code> object. </p><br><p>  Example of use ( <a href="">completely</a> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwd = Module.allocate(Module.intArrayFromString(<span class="hljs-string"><span class="hljs-string">'password'</span></span>), <span class="hljs-string"><span class="hljs-string">'i8'</span></span>, Module.ALLOC_NORMAL); <span class="hljs-comment"><span class="hljs-comment">// ... var res = Module._argon2_hash(t_cost, m_cost, parallelism, pwd, pwdlen, salt, saltlen, hash, hashlen, encoded, encodedlen, argon2_type, version); var encodedStr = Module.Pointer_stringify(encoded);</span></span></code> </pre> <br><p>  Firefox Nightly allows you to look inside the wasm module: </p><br><img src="https://habrastorage.org/files/cea/955/cab/cea955cab1074e2185c8aa5feae31380.png"><br><p><br>  In Chrome, there are no tools to view wasm, the module is not even displayed in the editor.  But the release also promised to make view source. </p><br><h1 id="interpretator-iz-binaryen">  Interpreter from Binaryen </h1><br><p>  Binaryen generates an interpreter that can execute text .wast and binary .wasm formats.  You can try it by setting <code>method</code> in <code>interpret-s-expr</code> or <code>interpret-binary</code> .  So far, the interpreter is so slow that I did not wait for the hash calculation, but I appreciated it by a smaller number of iterations.  It would have been half an hour, while in Chrome it was 7 seconds and even in IE11 45 seconds. </p><br><h1 id="kachestvo-koda">  Quality code </h1><br><p>  Let's see what kind of code we got.  I wrote a simple test so that .wast was extremely small, <a href="">here it is</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> fBlaMka(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = UINT64_C(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> xy = (x &amp; m) * (y &amp; m); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + <span class="hljs-number"><span class="hljs-number">2</span></span> * xy; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exp_fBlaMka</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fBlaMka(i, i) == i - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Let's take a look at .wast and find our function: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">func</span></span> $_exp_fBlaMka (<span class="hljs-name"><span class="hljs-name">result</span></span> i32) (<span class="hljs-name"><span class="hljs-name">local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span> i32) (<span class="hljs-name"><span class="hljs-name">set_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">0</span></span>) ) (<span class="hljs-name"><span class="hljs-name">loop</span></span> $while-out$<span class="hljs-number"><span class="hljs-number">0</span></span> $while-in$<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> #  ,     (<span class="hljs-name"><span class="hljs-name">i32</span></span>.and (<span class="hljs-name"><span class="hljs-name">i32</span></span>.eq (<span class="hljs-name"><span class="hljs-name">call</span></span> $___muldi3 #   (<span class="hljs-name"><span class="hljs-name">call</span></span> $_i64Add (<span class="hljs-name"><span class="hljs-name">call</span></span> $_bitshift64Shl (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">1</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.load (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">168</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">0</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.load (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">168</span></span>) ) (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">0</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.add (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">i32</span></span>.const <span class="hljs-number"><span class="hljs-number">-1</span></span>) ) ) # ...</code> </pre> <br><p>  I32 again?  Why is this so?  Recall that we received a wasm code by compiling asm.js, so i64 will not be seen here.  It is no wonder that such code is also executed for a long time. </p><br><p>  However, now the speed of execution in Chrome is the same as in Firefox, and a little faster than asm.js in Firefox. </p><br><h1 id="llvm-webassembly-backend">  LLVM WebAssembly Backend </h1><br><p>  Now let's try a more complicated way, C / C ++ Source ‚áí WebAssembly LLVM backend ‚áí s2wasm ‚áí WebAssembly. </p><br><p>  LLVM learned how to generate WebAssembly, doing this without emscripten.  But he does it so far very badly, the resulting module does not always work. </p><br><p>  We assemble LLVM with support for WebAssembly: </p><br><pre> <code class="bash hljs">cmake -G Ninja -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly .. &amp;&amp; ninja</code> </pre> <br><p>  We include it in compilation: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> EMCC_WASM_BACKEND=1 -DCMAKE_EXE_LINKER_FLAGS=<span class="hljs-string"><span class="hljs-string">"-s WASM_BACKEND=1"</span></span></code> </pre> <br><p>  To try different versions of LLVM in emscripten, specify the path to it in ~ / .emscripten, LLVM_ROOT.  And ... we get an error when loading the module into the browser. </p><br><p>  You can still collect not the fork of fastcomp used in emcc, but vanilla LLVM from upstream, something like this: </p><br><pre> <code class="bash hljs">clang -emit-llvm --target=wasm32 -S perf-test.c llc perf-test.ll -march=wasm32 ~/binaryen/bin/s2wasm perf-test.s &gt; perf-test.wast ~/binaryen/bin/wasm-as perf-test.wast &gt; perf-test.wasm</code> </pre> <br><p>  Also falling.  Perhaps, wasm from wast for V8 should be <a href="https://github.com/WebAssembly/sexpr-wasm-prototype">built sexpr-wasm-prototype</a> , not binaryen, but it still does not help. </p><br><p>  However, the simple test works quite well; you can at least evaluate the performance using the example of one function.  Let's look at the resulting .wast: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">func</span></span> $fBlaMka (<span class="hljs-name"><span class="hljs-name">param</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span> i64) (<span class="hljs-name"><span class="hljs-name">param</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> i64) (<span class="hljs-name"><span class="hljs-name">result</span></span> i64) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.add (<span class="hljs-name"><span class="hljs-name">i64</span></span>.add (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.mul (<span class="hljs-name"><span class="hljs-name">i64</span></span>.and (<span class="hljs-name"><span class="hljs-name">i64</span></span>.shl (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.const <span class="hljs-number"><span class="hljs-number">1</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.const <span class="hljs-number"><span class="hljs-number">8589934590</span></span>) ) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.and (<span class="hljs-name"><span class="hljs-name">get_local</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">i64</span></span>.const <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) ) ) ) )</code> </pre> <br><p>  Hooray, i64!  We will load it into the browser and estimate the time in comparison with the previous option: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'i64'</span></span>); Module._exp_fBlaMka(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'i64'</span></span>); i32: <span class="hljs-number"><span class="hljs-number">1851.5</span></span>ms i64: <span class="hljs-number"><span class="hljs-number">414.49</span></span>ms</code> </pre> <br><p>  In the bright future, the speed of 64-bit arithmetic is several times better. </p><br><h1 id="threading">  Threading </h1><br><p>  Pthreads are not included in MVP WebAssembly, they will appear only <a href="">later</a> .  While it is difficult to say what will happen, in general, for the next year - the answer is no.  But WebAssembly can be easily used in web workers without any performance degradation, as you can see for yourself on the demo page. </p><br><h1 id="pnacl">  PNaCl </h1><br><p>  Now compare performance with PNaCl.  PNaCl is also a binary code format developed by Google for Chrome and even enabled by default.  It was once supposed to support it in other browsers, but <a href="https://en.wikipedia.org/wiki/Google_Native_Client">Mozilla rejected the proposal</a> , while others did not think about it.  Did not take off. </p><br><p>  So, PNaCl is .pexe, which is jit-run in runtime, let's make a <a href="">simple module</a> for it: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Argon2Instance</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> pp::Instance { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pp::Var&amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ pp::<span class="hljs-function"><span class="hljs-function">VarDictionary </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">req</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     int t_cost = req.Get(pp::Var("time")).AsInt(); // ... int res = argon2_hash(t_cost, m_cost, parallelism, pwd, pwdlen, salt, saltlen, hash, hashlen, encoded, encodedlen, argon2_type == 1 ? Argon2_i : Argon2_d, version); pp::VarDictionary reply; reply.Set(pp::Var("res"), res); PostMessage(reply); //   } };</span></span></code> </pre> <br><p>  You can call this by inserting .pexe on the page in <code>&lt;embed&gt;</code> and <a href="">sending</a> him a message: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      listener.addEventListener('message', e =&gt; console.log(e.data)); //   moduleEl.postMessage({ pwd: 'password', ... });</span></span></code> </pre> <br><p>  Unlike WASM, PNaCl already supports 64-bit types and pthreads, therefore, the operating time is 1.5..2 times longer than native-code in terms of speed.  But it is only chrome.  Sadly, only the download time, which is a few seconds, and in the case of the first use of PNaCl in general, the user can grow to irresponsible figures in the order of 30 seconds. </p><br><h1 id="grafiki">  Charts </h1><br><p>  Average code execution time in different environments: </p><br><img src="https://habrastorage.org/files/8c0/7ae/428/8c07ae428be54a5fa8ce9ea55aa0efdd.png"><br><p>  Load time and first run: </p><br><img src="https://habrastorage.org/files/d83/a76/cca/d83a76cca6d842bc80505387cab995e6.png"><br><h1 id="razmer-koda">  Code size </h1><br><table><thead><tr><th></th><th>  Code size, KiB </th><th>  Comment </th></tr></thead><tbody><tr><td>  asm.js </td><td>  109 </td><td>  all js nickname </td></tr><tr><td>  WebAssembly </td><td>  43 </td><td>  only .wasm, without wrapper </td></tr><tr><td>  PNaCl </td><td>  112 </td><td>  .pexe </td></tr></tbody></table><br><h1 id="a-chto-naschyot-nodejs">  What about node.js? </h1><br><p>  In node.js, compiling native code is very simple right now; just add a couple of bindings.  When V8 is upgraded to some version, node.js can be run with the <code>--expose-wasm</code> (as long as its support is in the experimental stage) and you can use wasm in the node.  Until it boots up, because the V8 is quite old. </p><br><h1 id="vyvody">  findings </h1><br><p>  It is now sensible to use asm.js in Firefox and PNaCl in Chrome.  WASM is already good enough now, by the time of MVP, the compilation in LLVM will most likely be brought to mind, but using it is, of course, early, even in nightly builds it is turned off by default.  However, the performance of the wasm is already indicative now and exceeds the speed of asm.js, even without the support of i64. </p><br><h1 id="ssylki">  Links </h1><br><ul><li>  demo: <a href="https://antelle.github.io/argon2-browser/">github</a> </li><li>  code of examples from the article: <a href="https://github.com/antelle/argon2-browser">github</a> </li><li>  argon2: <a href="https://github.com/P-H-C/phc-winner-argon2">github</a> , <a href="https://habrahabr.ru/post/281569/">habr</a> , <a href="https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf">for nerds</a> </li><li>  page new llvm wasm backend: <a href="https://github.com/kripken/emscripten/wiki/New-WebAssembly-Backend">github / binaryen</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308874/">https://habr.com/ru/post/308874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308864/index.html">Asynchronous code to synchronous embedded</a></li>
<li><a href="../308866/index.html">How to survive the influx of customers and not to close: a checklist for Internet entrepreneurs</a></li>
<li><a href="../308868/index.html">Multiple git directory watcher</a></li>
<li><a href="../308870/index.html">A bit about VPN: Add-ons to the software implementation overview</a></li>
<li><a href="../308872/index.html">Android Data Binding for RecyclerView: flexible way</a></li>
<li><a href="../308876/index.html">Cross-cloud architecture and VMware Cloud Foundation, a single platform for managing SDDC</a></li>
<li><a href="../308878/index.html">The logic of consciousness. Part 2. Dendritic waves</a></li>
<li><a href="../308880/index.html">NGINX: Interception of 5xx errors using a debug server</a></li>
<li><a href="../308882/index.html">SRL - Simple Regex Language</a></li>
<li><a href="../308884/index.html">As I wrote a diploma / application created / on Google Play, I posted</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>