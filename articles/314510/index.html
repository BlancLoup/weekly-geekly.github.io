<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>6 functional programming concepts. Use and examples of use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! My name is Ivan Smolin, I am a developer of mobile applications on the iOS platform. Today I invite you to plunge into the world of function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>6 functional programming concepts. Use and examples of use</h1><div class="post__text post__text-html js-mediator-article">  Good day!  My name is Ivan Smolin, I am a developer of mobile applications on the iOS platform.  Today I invite you to plunge into the world of functional programming.  The article is mostly theoretical in nature than practical.  In it, I will try to define the basic concepts of functional programming and show examples of implementations in C, Objective-C, Swift, Haskell. <br><br>  Functional programming is a programming paradigm that focuses on computation through functions in the mathematical style, immutability, expressiveness and reduction in the use of variables and states ( <a href="https://www.raywenderlich.com/82599/swift-functional-programming-tutorial">link</a> ). <br><br>  There are 6 main concepts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  first class concept and higher order functions </li><li>  clean function concept </li><li>  immutable state concept </li><li>  concept of optionality and image matching </li><li>  concept of laziness and endless data structures </li><li>  lambda calculus concept </li></ul><br><a name="habracut"></a><br><h2>  First class function </h2><br><h4>  What is it </h4><br>  This is an entity that supports operations that are usually available for other entities.  These operations are usually.  include: passing an entity as an argument, returning an entity from a function, and assigning it to a variable. <br><br><h4>  What is useful </h4><br>  Simplifies working with functions, giving more features and ways to use them. <br><br><h4>  Examples of using </h4><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*callback_func_t) (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> list_files(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path, callback_func_t callback) { <span class="hljs-comment"><span class="hljs-comment">// recursive read directory structure ... } void print_file_path(char* file_path) { printf("%s\n", file_path); } callback_func_t get_print_func() { callback_func_t callback_var = &amp;print_file_path; return callback_var; } list_files("/tmp/", get_print_func());</span></span></code> </pre> <br>  In the above example, the get_print_func function creates a variable in which it stores the function reference, and then returns it.  And below the code, we pass the result returned to us by the function get_print_func to another function.  These are the operations available to us through first-class functions. <br><br><h2>  Higher order function </h2><br><h4>  What is it </h4><br>  This is a function that operates on other functions.  Operates by getting them as a parameter or returning them. <br><br><h4>  What is useful </h4><br>  As in the case of functions of the first order, this concept gives us more opportunities to work with functions.  This concept also opens up the possibility of using functions as event handlers that the system or a library can tell us by calling the first-class function passed to it. <br><br><h4>  Examples of using </h4><br>  See  previous example.  There is a function that reads the directory.  And recursively reads all subfolders.  For each file found, it calls the function we passed - callback. <br><br>  The example in C shows that in the 70s of the last century it was possible to operate with functions of the first class and higher order.  Blocks appeared in Objective-C.  Unlike functions, they can capture variables and some state.  Closure appeared in Swift.  In essence, this is the same thing as blocks in Objective-C. <br><br><h2>  Net function </h2><br><h4>  What is it </h4><br>  This is a function that fulfills two conditions.  The function always returns the same result with the same input parameters.  And the result calculation does not cause visible semantic side effects or output to the outside. <br><br><h4>  What is useful </h4><br>  A pure function is usually an indicator of well-written code, since such functions are easy to cover with tests, they can be easily transferred and reused. <br><br><h4>  Examples of using </h4><br>  The following fragment shows examples of pure functions (they are marked with the comment ‚Äúpure‚Äù). <br><br><pre> <code class="hljs pgsql">func quad1(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { // pure func square() -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> square() * square() } func quad2(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { // pure func square(y: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { // pure <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y * y } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> square(x) * square(x) } func square(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { // pure <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x } func <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> square(x) * x } func printSquareOf(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>) { print(square(x)) } let screenScale = <span class="hljs-number"><span class="hljs-number">2.0</span></span> func pixelsToScreenPixels(pixels: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixels * <span class="hljs-type"><span class="hljs-type">Int</span></span>(screenScale) }</code> </pre><br>  Used everywhere.  For example, standard math libraries in almost all programming languages ‚Äã‚Äãcontain mostly pure functions. <br><br><h2>  Immutable state </h2><br><h4>  What is it </h4><br>  The immutable state is the state of an object that cannot be changed after the object has been created.  The state of an object here implies a set of values ‚Äã‚Äãfor its properties. <br><br><h4>  What is useful </h4><br>  Since immutable objects guarantee us that during their life cycle they cannot change their state, we can be sure that using or transferring such objects to other places of the program will not lead to any unintended consequences.  This is especially important when working in a multithreaded environment. <br><br>  In C language ‚Äúout of the box‚Äù there is no possibility to create immutable objects.  The const keyword prohibits changing the value only in the current context, however, if we pass a reference to this value to a function, then this function will be able to change the data found on this link.  You can solve this problem through encapsulation (through public and private header files).  However, in this case we must independently implement the mechanism of ‚Äúprotecting‚Äù data from changes. <br><br>  In Objective-C, too, nothing new has come.  Added only base classes that do not allow to change their internal state and their mutable (mutable) counterparts. <br><br>  In Swift, we have the let keyword, which ensures that a variable or structure cannot be changed after creation. <br><br><h4>  Examples of using </h4><br>  An example of using immutable values ‚Äã‚Äãin Swift: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> one = <span class="hljs-number"><span class="hljs-number">1</span></span> one = <span class="hljs-number"><span class="hljs-number">2</span></span> // compile <span class="hljs-literal"><span class="hljs-literal">error</span></span> let hello = <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello = <span class="hljs-string"><span class="hljs-string">"bye"</span></span> // compile <span class="hljs-literal"><span class="hljs-literal">error</span></span> let argv = [<span class="hljs-string"><span class="hljs-string">"uptime"</span></span>, <span class="hljs-string"><span class="hljs-string">"--help"</span></span>] argv = [<span class="hljs-string"><span class="hljs-string">"man"</span></span>, <span class="hljs-string"><span class="hljs-string">"reboot"</span></span>] // compile <span class="hljs-literal"><span class="hljs-literal">error</span></span> argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"man"</span></span> // compile <span class="hljs-literal"><span class="hljs-literal">error</span></span></code> </pre><br><h2>  Optional type </h2><br><h4>  What is it </h4><br>  An optional type is a generic type that represents the encapsulation of an optional value.  This type contains either a specific value or a null value. <br><br><h4>  What is useful </h4><br>  Bring the notion of a null value to a higher level.  Allows you to work with optional values ‚Äã‚Äãusing the syntax constructs of the language. <br><br><h4>  Examples of using </h4><br>  Practically in all modern, especially young, languages ‚Äã‚Äãthere is a concept of an optional type and syntactic constructions for working with it.  In Swift, this is a construction if let, or switch case: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> some: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (some) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">None</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"no string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"string is: \(str)"</span></span>) }</code> </pre><br><h2>  Pattern Matching </h2><br>  Pattern Matching - the act of checking the sequence of tokens for a match with a specific pattern. <br><br><h4>  What is useful </h4><br>  Lets us write shorter, problem-focused code. <br><br><h4>  Examples of using </h4><br>  Here is an example on Haskell.  In my opinion, the best example of pattern matching. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a) =&gt; [a] -&gt; a sum [] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">-- no elements sum (x:[]) = x -- one element sum (x:xs) = x + sum xs -- many elements</span></span></code> </pre><br>  The sum function takes as its input an array of objects.  If the sum function gets an empty array, the sum of the elements is 0. If the array contains one object, we simply get this object. If there are more objects, then we add the first object and the tail of the array, then we repeat the operation recursively until we have elements in the tail of the array.  We have described this function as a pattern.  This means that we describe all the possible (or necessary for us at the moment) options for the operation of this function depending on the input values.  Without if and other conditional statements. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addOne</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addOne (<span class="hljs-type"><span class="hljs-type">Just</span></span> a) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (a + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- not empty value addOne Nothing = Nothing -- empty value</span></span></code> </pre><br>  The addOne function adds one to the number.  It takes as input an argument of type Maybe Int and returns a value of the same type as output.  Maybe is a monad that contains either a value (Just a) or nothing (Nothing).  The addOne function works as follows: if there is a value in the function argument, (Just a), then we add one and return the argument, if there is nothing (Nothing), then we return nothing (Nothing). <br><br>  In Swift, pattern-matching looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> somePoint = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> somePoint { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"point at the origin"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"(point on the x-axis"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"point on the y-axis"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (-<span class="hljs-number"><span class="hljs-number">2</span></span>...<span class="hljs-number"><span class="hljs-number">2</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>...<span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"point inside the box"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"point outside of the box"</span></span>) }</code> </pre><br>  Pattern Matching, in my opinion, is quite limited in Swift, you can only check cases in the switch statement, however, this can be done quite flexibly. <br><br><h2>  Laziness or lazy calculations </h2><br><h4>  What is it </h4><br>  Lazy evaluation is a calculation strategy that defers the evaluation of an expression until the moment when the value of this expression is necessary. <br><br><h4>  Than useful </h4><br>  Allows you to postpone the calculation of some code until a certain or predetermined point in time. <br><br><h4>  Usage example </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dateFormatter = <span class="hljs-type"><span class="hljs-type">NSDateFormatter</span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> creationDate: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdAt: <span class="hljs-type"><span class="hljs-type">NSDate?</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dateFormatter.dateFromString(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.creationDate) }() }</code> </pre><br>  It can be used to initialize fields in a class after it is initialized.  This technique allows you to avoid duplication of the field initialization code in several class constructors and to postpone the initialization of this field until it becomes necessary.  In the example above, the value of the createdAt field is calculated at the time of the first access to it. <br><br><h2>  Infinite data structure </h2><br>  An infinite data structure is a structure whose definition is given in terms of infinite ranges or incessant recursion, but real values ‚Äã‚Äãare calculated only at the moment they are needed. <br><br><h4>  What is useful </h4><br>  Allows us to determine data structures of infinite or enormous size without spending resources on the calculation of the values ‚Äã‚Äãof this structure. <br><br><h4>  Examples of using </h4><br>  Here is an example on Swift.  We take Range from one to trillion.  Make a map on this Range - turn a billion values ‚Äã‚Äãinto strings.  Such a number of lines hardly fit in the RAM of a personal computer.  But, nevertheless, we can easily do it and take the necessary values.  In the example, the lambda passed to the map function is called only twice.  Everything is done very lazily. <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> bigRange = 1...1_000_000_000_000 // from one to one trillion <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> lazyResult = bigRange.lazy.map { <span class="hljs-string"><span class="hljs-string">"Number \(</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string">)"</span></span> } // called 3 <span class="hljs-built_in"><span class="hljs-built_in">times</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> fourHundredItem = lazyResult[400] // <span class="hljs-string"><span class="hljs-string">"Number 400"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> lazySlice = lazyResult[401...450] // Slice&lt;LazyMapCollection&lt;Range&lt;Int&gt;, String&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> fiveHundredItem = lazyResult[500] // <span class="hljs-string"><span class="hljs-string">"Number 500"</span></span></code> </pre><br>  In Swift, we are always limited to Range.  We cannot create an infinite range of values.  You can fake it and do it differently, but out of the box there is no such thing.  But in Haskell is. <br><br>  You can make a list from one to infinity.  Make a map to all elements (number and number, which will turn into a string).  Then take any elements of either a slice or a list.  The cut will also be returned by a lazy list. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">infiniteList</span></span> = [<span class="hljs-number"><span class="hljs-number">1.</span></span>.] mappedList = map (\x -&gt; <span class="hljs-string"><span class="hljs-string">"Number "</span></span> ++ show x) infiniteList <span class="hljs-comment"><span class="hljs-comment">-- called 2 times fourHundredItem = mappedList !! 400 -- ‚ÄúNumber 400‚Äù lazySlice = take (450 - 400) (drop 400 mappedList) -- [401..450] fiveHundredItem = mappedList !! 500 -- ‚ÄúNumber 500‚Äù lazyArray = [2+1, 3*2, 1/0, 5-4] -- item values not evaluated lengthOfArray = length lazyArray -- still not evaluated</span></span></code> </pre><br>  Haskell is the laziest language I've ever seen.  In it, arrays can contain boxed (packed) and unboxed (unpacked) elements.  In the case when the array elements are packed (not yet computed) during array operations that do not require obtaining the value of the elements, these values ‚Äã‚Äãwill not be calculated.  An example of such an operation is the length method. <br><br><h2>  Lambda calculus </h2><br><h4>  What is it </h4><br>  Lambda calculus is a formal system in mathematical logic for expressing computation based on the operations of application and abstraction of functions by means of linking and changing variables. <br><br><h4>  Than useful </h4><br>  The concept of lambda calculus brings to programming languages ‚Äã‚Äãthe concept of anonymous functions that can capture external (with respect to a function) variables. <br><br><h4>  Usage example </h4><br>  Below is an example on Swift, where we use lambda instead of named functions. <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> numbers = [0,1,2,3,4,5,6,7,8,9,10] <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> stringNumbers = numbers.map { String(<span class="hljs-variable"><span class="hljs-variable">$0</span></span>) } // [<span class="hljs-string"><span class="hljs-string">"0"</span></span>,<span class="hljs-string"><span class="hljs-string">"1"</span></span>,<span class="hljs-string"><span class="hljs-string">"2"</span></span>,<span class="hljs-string"><span class="hljs-string">"3"</span></span>,<span class="hljs-string"><span class="hljs-string">"4"</span></span>,<span class="hljs-string"><span class="hljs-string">"5"</span></span>,<span class="hljs-string"><span class="hljs-string">"6"</span></span>,<span class="hljs-string"><span class="hljs-string">"7"</span></span>,<span class="hljs-string"><span class="hljs-string">"8"</span></span>,<span class="hljs-string"><span class="hljs-string">"9"</span></span>,<span class="hljs-string"><span class="hljs-string">"10"</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> sum = numbers.reduce(0, combine: { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> + <span class="hljs-variable"><span class="hljs-variable">$1</span></span> }) // 55 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> avg = numbers.reduce(0.0, combine: { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> + Double(<span class="hljs-variable"><span class="hljs-variable">$1</span></span>) / Double(numbers.count) }) // 5.0 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> from4To7SquareNumbers = numbers.filter { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> &gt; 3 }.filter { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> &lt; 7 }.map { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> * <span class="hljs-variable"><span class="hljs-variable">$0</span></span> } // [16, 25, 36]</code> </pre><br>  Here is an example of how to calculate the sum or average of one line.  And filter. <br><br>  The concept of lambda calculus also introduces the concept of currying into programming languages.  Currying allows us to split a function with several parameters into several functions with one parameter.  This enables us to obtain the result of the calculation of intermediate functions and apply different arguments to these functions to obtain several results. <br><br><h4>  Curry usage example </h4><br><pre> <code class="hljs pgsql">func raiseToPowerThenAdd(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>: [<span class="hljs-type"><span class="hljs-type">Double</span></span>], power: <span class="hljs-type"><span class="hljs-type">Double</span></span>) -&gt; ((<span class="hljs-type"><span class="hljs-type">Double</span></span>) -&gt; [<span class="hljs-type"><span class="hljs-type">Double</span></span>]) { let poweredArray = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.map { pow(<span class="hljs-meta"><span class="hljs-meta">$0</span></span>, power) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> poweredArray.map { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> } } } let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = [<span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">4.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>] let intermediateResult = raiseToPowerThenAdd(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, power: <span class="hljs-number"><span class="hljs-number">3</span></span>) intermediateResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) // [<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">125</span></span>] intermediateResult(<span class="hljs-number"><span class="hljs-number">5</span></span>) // [<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">69</span></span>, <span class="hljs-number"><span class="hljs-number">230</span></span>] intermediateResult(<span class="hljs-number"><span class="hljs-number">10</span></span>) // [<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">74</span></span>, <span class="hljs-number"><span class="hljs-number">135</span></span>]</code> </pre><br>  Here we get the result of calculating the power of the numbers in the array and then add a certain number to this result.  It is important to note that the calculation of degrees occurs only once when the call to the raiseToPowerThenAdd function is called. <br><br><h3>  Conclusion </h3><br>  In my opinion, the most important concepts for developing mobile software (in terms of code quality) are: the concept of pure functions and the concept of optionality.  The first one gives us a clear and simple idea how to make our code more portable, high-quality and testable.  The second one makes us think about possible extreme cases and errors that may come from outside, and process them correctly. <br><br>  I hope the material will be useful and your code will be even better. <br><br>  Ivan Smolin, iOS developer. </div><p>Source: <a href="https://habr.com/ru/post/314510/">https://habr.com/ru/post/314510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314496/index.html">How important is mathematical training in promising areas of software development</a></li>
<li><a href="../314500/index.html">Comparing objects by value - 2, or Features of the implementation of the Equals method</a></li>
<li><a href="../314502/index.html">A brief history of the development of game engines</a></li>
<li><a href="../314506/index.html">ZFS on Linux: News from the Field 2017</a></li>
<li><a href="../314508/index.html">Synthesis of images using deep neural networks. Lecture in Yandex</a></li>
<li><a href="../314512/index.html">Names of large numbers in idle games</a></li>
<li><a href="../314514/index.html">Sudoku: so how many of them? Part 2/2</a></li>
<li><a href="../314518/index.html">Working with the VKontakte C # API</a></li>
<li><a href="../314520/index.html">Measurement of resistance and inductance of a DC motor</a></li>
<li><a href="../314522/index.html">Auto-collection of data about database files and logical disks of the operating system in MS SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>