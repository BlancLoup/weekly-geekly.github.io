<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Old Shakes: intercepting data stream between i386 and ATA controller using STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. In today's article, we indulge in nostalgia, work with the good old iron, and try to fasten to it no less good new t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Old Shakes: intercepting data stream between i386 and ATA controller using STM32</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear habrovchane.  In today's article, we indulge in nostalgia, work with the good old iron, and try to fasten to it no less good new things.  And at the same time, let's remember how the ISA bus works and how the x86 processor communicates with the peripherals in general. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  A couple of days ago, my very first computer caught my eye ‚Äî an old 386y, on an AMD processor (Am386-DX), with 4 megabytes of RAM, a VGA video card, and a multi-card that takes on the functions of a disk drive controller, hard drive, parallel and serial ports. <br>  Of course, he had long been spared from his case and from the old, defunct hard - now he was just a motherboard with a pair of expansion cards.  A few years ago, I connected a new hard drive to it, 10 GB (initially it contained only a 200 megabyte drive), on which I put FreeDOS. <br><br><img src="https://habrastorage.org/storage2/f78/f2c/0b6/f78f2c0b6c647268775087330fdae59e.jpg"><br><br>  However, this time he refused to boot further on the BIOS - judging by the sounds, 10 GB hard for several years lying in the closet had time to go after two hundred meters. <br>  And then I woke up with a keen desire to do something with this computer, to touch this antiquity, with which I began my acquaintance with IT, already as a developer, and not as a user.  Ideally, of course, I would like to make a hard disk emulator that works with an SD card, but we will gradually go towards this goal.  Let's start with a simpler task - we will assemble a device that hangs in parallel with a real hard disk controller and logs data exchange in order to find out exactly how the old BIOS detects hard disks.  Initially, I intended to do the same, but for the floppy controller, however, after my last hard drive died, all I had left was a BIOS that didn‚Äôt check for floppy.  But he has a couple of items related to Hardy - the detection of hard drives and means for formatting them. <br>  Of course, on the FPGA this is done very easily due to their architecture, but we will stick to the budget option and try to do it on the STM32F103 controller and a few discrete logic chips.  So, let's begin. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Iron </h4><br>  Traditionally we will go from the hard bottom.  Let's remember what the ISA bus is, which is the basis of old computers, and how you can connect to it.  For those who do not really represent the circuitry inside x86 machines, this will help shed light on the architecture of such systems.  In fact, everything is very simple - in the "clean" ISA there are no means of Plug &amp; Play - they appeared only in the following standard - and, therefore, no means of issuing addresses to devices. <br>  Thus, ISA-cards are devices with a hardware-defined address (rigidly defined circuitry, at best - with the ability to choose a base address with jumpers).  The bus itself contains 20 address lines, 16 data lines, several power signals, several IRQ lines, and a set of control signals. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/8ea/766/784/8ea766784b5de8b9177bafd37ddb67ee.png" alt="image"><br><br>  How does all this work?  Suppose we need the ability to light / extinguish several LEDs on our device.  To do this, we will place on our ISA board a register chip, for example, such as <a href="http://www.nxp.com/documents/data_sheet/74HC_HCT273.pdf">74HC273</a> . <br>  This is the most common 8-bit "latch", remembering what she was given to the input signal.  The outputs of the register will connect to the LEDs and forget about them.  From a software point of view, interaction with a device on the ISA bus can be implemented in two ways. <br><br><ol><li>  Using memory mapping - then we will decode the memory read / write signals and output the results to the bus instead of the DRAM controller - this is how the video card comes in, its video memory is mapped to the address memory space of the computer.  Thus, writing to the memory of a video card for a computer is no different from writing to its RAM and is performed by the usual <b>MOV</b> command. </li><li>  For those devices that do not need to transfer large blocks of data, the so-called ‚Äúinput-output space‚Äù is used - a separate address space allocated for peripheral devices and limited to 16 bits of the address.  It is accessed by the <b>IN</b> and <b>OUT</b> commands (read and write to I / O ports) </li></ol><br>  In fact, behind the words "separate address space" lies a physically simple entity: there are 4 signals on the ISA bus - <b>MEMW, MEMR, IOR, IOW</b> .  When executing a read / write to memory ( <b>MOV</b> ) command or read / write to IO ( <b>IN</b> , <b>OUT</b> ), the desired address is set on the same bus, lines <b>A0-A19</b> ISA.  The data also follow the same lines - <b>D0-D15</b> .  The only difference is that when reading from memory, the active level is set on the <b>MEMR</b> line, when writing to memory - <b>MEMW</b> , when reading from the IO port - <b>IOR</b> , when writing to it - <b>IOW</b> . <br>  Thus, in order to make a simple device with one register and LEDs, we need to determine when the address we need is set on the bus (we remember that no one gives us addresses, we have to choose an address that will not conflict with the existing peripherals) and on the signal <b>IOW</b> to allow data recording from lines <b>D0-D8</b> to our register. <br>  In more complex devices containing several registers, the upper address lines go to the decoder, forming an active output signal when coinciding with some ‚Äúbase‚Äù address of the device, while the lower ones form the register number that should be addressed. <br>  Let us turn to a more specific example - our ATA controller.  For a better understanding of the principles of its work, I recommend reading the <a href="http://wiki.osdev.org/ATA_PIO_Mode">article</a> from the OSDev wiki. <br>  It is controlled by nine IO registers, eight of which are located in a row, starting with the base address <i>0x1F0</i> .  The ninth, unfortunately, is located at the address <i>0x3F6</i> , which somewhat complicates the decoding scheme. <br>  Of course, we won‚Äôt get all the address lines to the controller and do a decoder on it, otherwise we don‚Äôt have time - the 8 MHz bus clock frequency, the IO cycle, according to the specification, lasts 4 clocks, which at a frequency of 72 MHz gives us only 36 clocks to think.  Therefore, we use cheap chips discrete logic. <br>  If it were not for this ninth register, which sticks out at <i>0x3F6</i> , then we would need to build a circuit that outputs an active signal when zero is set on lines <b>A9</b> and <b>A3</b> , and one is set on <b>A4-A8</b> (that is, for addresses <i>0x1F ( ..)</i> ).  Bits older than <b>A9</b> in ISA cards usually do not decode, not paying attention to the ability to access the same device at the addresses above. <br>  The processing of the three lower bits could already be assigned to the controller.  Alas, we still have an <i>uncovered</i> register <i>0x3F6</i> . <br>  Initial conditions (active <b>A4-A8</b> lines and inactive <b>A3</b> ) are always met, since these bits are in the specified states for <i>both 0x1F (..)</i> and <i>0x3F6</i> .  A condition is added to them, which can be formulated as follows: with active <b>A9</b> , there should be active levels on <b>A1</b> and <b>A2</b> (address <i>0x3F6</i> ) <br>  I.e, <br><br><pre><code class="cpp hljs">CS0 = A8 &amp; A7 &amp; A6 &amp; A5 &amp; A4 &amp; ~A3 CS1 = A1 &amp; A2 &amp; A9 CS2 = CS0 &amp; (~A9 | CS1)</code> </pre> <br>  Using the online logic circuit simulator <a href="http://logic.ly/demo/">Logic.Ly</a> , I built this circuit based on the chips I had in my possession - 74HC04, the quadruple element <i>NOT</i> , 74HC30 - eight-input <i>NAND</i> and 74HC10, triple three-input <i>NAND</i> . <br>  Since we do not have the <i>OR</i> element, we recall the rules of De Morgan - negation of a conjunction is a disjunction of negations and negation of a disjunction is a conjunction of negations, or, in the form of logical equalities <br><br><pre> <code class="cpp hljs">~(A&amp;B) = ~A | ~B ~(A|B) = ~A &amp; ~B</code> </pre><br>  This and use: <br><br><pre> <code class="cpp hljs"> ~( ~ (~A9 | CS1))) = ~(A9&amp;~CS1) - = (A9 NAND ~CS1) CS2 = CS0 &amp; (A9 NAND ~CS1)</code> </pre><br>  We also do not have pure <i>AND</i> , therefore we will submit its components to the three-input <i>NAND</i> block and we will enter into a recess interrupt. <br>  As you can see, all the logic fits in exactly three cases. <br><br><img src="https://habrastorage.org/storage2/313/1c9/1be/3131c91bece9a687dea95d2e1801f354.png"><br><br>  The presence of an active level on <b>IOR</b> or <b>IOW is</b> added to these conditions (do not forget that, according to the standard, the active level is low on them, that is, we already receive inverted signals, <b>~ IOR</b> and <b>~ IOW</b> ): <br><pre> <code class="cpp hljs">CS = CS2 &amp; (IOR | IOW) (IOR|IOW) = ~(~(IOR &amp; IOW) ) = ~(~IOR &amp; ~ IOW) = (IOR NAND IOW) CS = CS2 &amp; (IOR NAND IOW)</code> </pre><br>  The final scheme looks like this: <br><br><img src="https://habrastorage.org/storage2/a08/1d0/c18/a081d0c18b3ae2c434245c65934723b1.png"><br><br>  Now we begin to collect it in the gland, using a breadboard.  First, we will arrange the first three chips, to which the most input signals go, and take care of their connection to the power and ground buses. <br><br><img src="https://habrastorage.org/storage2/0a6/090/526/0a60905268d69d6dbe7a5f3423903278.jpg"><br><br>  Carefully add the output circuits, then add the input in the form of sufficiently long probes, which then plug into the computer's motherboard: <br><br><img src="https://habrastorage.org/storage2/d1f/2df/95c/d1f2df95c60b2c588c438ced48792505.jpg"><br><br>  For convenience, I temporarily fixed the upper address entries on the left ( <b>A3-A9</b> ), the younger ones on the right ( <b>A0-A2</b> ), and in the middle I output the signal <b>CS2</b> . <br><br>  Let's temporarily distract from the assembly and try to look with an oscilloscope, what happened with us.  So, we connect the address inputs to the bus - since ISA is the bus, we do not need to try to plug the probes into the same connector where the ATA controller card is inserted, we choose any convenient for us.  Probes, unfortunately, turned out to be too small for such holes, so I plugged a comb of straight pins from above ‚Äî individually, and the probes and pins fall out, but they hold together quite well. <br>  Also, do not forget to connect the earth and power supply to the ISA, and at the same time - the earth of the oscilloscope probes. <br>  Turn on the oscilloscope and computer (I immediately went into the BIOS setup menu) and poke into the <b>CLK</b> signal.  We should see something like this: <br><br><img src="https://habrastorage.org/storage2/7aa/737/34d/7aa73734db38f2b91580218e4066bdfa.jpg"><br><br>  This, of course, is a bus clock whose frequency is usually 8 MHz.  On my motherboard, its frequency is equal to 7.19 MHz, which is reflected in the BIOS settings.  Apparently, this is a feature of iron - BIOS did not allow me to lower this frequency, or at least set it at exactly 8 MHz, stubbornly exposing 7.19 MHz.  Anyway. <br>  We check the contacts of the inputs of our circuit - by poking into any of them we will get a chaotic signal on the oscilloscope screen, as the system constantly refers to different addresses and ports.  So if there is silence at the entrance, it means that the contact has departed and you need to double-check it. <br>  Now we connect to our signal <b>CS2</b> and see the following picture: <br><br><img src="https://habrastorage.org/storage2/cbb/b2e/34b/cbbb2e34b779efa36e724a7fcf0e44f0.jpg"><br><br>  Quite expectedly, the signals <b>IOR</b> and <b>IOW</b> do not participate in the formation of <b>CS2</b> , so that it becomes active when the address on the bus matches the one we specified ( <b>0x1F0-0x1F7</b> and <b>0x3F6</b> ).  The system performs regular DRAM regeneration, so we get a nice periodic signal.  Now is the time to tune the scan and levels of the oscilloscope to see the signals in all its glory. <br>  After making sure that everything works, we de-energize the circuit and assemble it to the end, having obtained a hellish mess of wires like this: <br><br><img src="https://habrastorage.org/storage2/b5b/ee4/981/b5bee498142ec19280f0541f195ac833.jpg"><br><br>  Turn on the computer again, go to the BIOS setup menu, turn on the oscilloscope. <br>  No signals!  Well, it's time to check the correctness of our calculations - select the item ‚ÄúAutodetect hard drive‚Äù.  The first disk is determined quickly, and, most likely, we will not have time to notice anything on the oscilloscope screen unless we turn on the single mode. <br>  But the second disk (due to its absence) will be detected long enough for us to see this on the computer screen: <br><br><img src="https://habrastorage.org/storage2/962/5a0/139/9625a0139e9a6553ad908eb5a08ada80.jpg"><br><br>  And on the oscilloscope screen - this is: <br><br><img src="https://habrastorage.org/storage2/556/56d/c3e/55656dc3e15ff6d1bbe727c35d80dce4.jpg"><br><br>  To make sure that we are right, we exit the disk detection, turn on the oscilloscope's single mode and carefully look at its screen - nothing!  No matter how much we wait, <b>CS</b> does not become active!  But one has only to go into the detection of disks, as we again catch the familiar picture, which fully complies with the standards - the I / O cycle lasts four bus cycles. <br>  Well, it's time to take a fee with the STM32 and connect it to the system! <br>  I connected as follows: <br><br>  ISA data bus ( <b>D0 - D7</b> ) is connected to <b>GPIOD.0 - GPIOD.7</b> , <br>  Three lower address lines ( <b>A0 - A2</b> ) - to <b>GPIOD.8 - GPIOD.10</b> , <br>  The address line <b>A9</b> is to <b>GPIOD.11</b> (after all, we will need this bit to understand that the call goes not to <i>0x1F6</i> , but to <i>0x3F6</i> !) <br>  <b>IOW</b> and <b>IOR</b> lines to <b>GPIOD.12</b> and <b>GPIOD.13</b> . <br>  <b>CS</b> signal - to <b>GPIOB.0</b> <br><br>  Now, when interrupting on <b>GPIOB.0,</b> we just need to read <b>GPIOD-&gt; IDR</b> (Input Data Register), in which the lower 8 bits will be the desired data, the next four will be the address (and possible combinations will be <i>0000 - 0111</i> and <i>1011</i> , corresponding to ports <i>0x1F0 - 0x1F7</i> and <i>0x3F6</i> ), the next two are in the mode (read at <i>01</i> or write at <i>10</i> ). <br>  Here it is important to note the following: if suddenly we get the result with the mode bits that are in the invalid state ‚Äî <i>00</i> or <i>11</i> , this will signal to us about the operation error ‚Äî this fact will be useful to us very soon. <br>  So, go to the software. <br><br><h4>  Soft </h4><br>  With software, everything is extremely simple - we set up a <b>GPIOD</b> as an input, like <b>GPIOB.0</b> , and then we set up a drop interrupt on the <i>EXTI</i> line connected to <b>GPIOB.0</b> . <br>  In the interrupt handler, we will only read the value from the <b>GPIOD</b> and increment the pointer to the buffer.  This buffer can then be sent to a computer for analysis on any interface, or not bother with it at all and watch it directly in debug. <br>  The setup code is shown below: <br><br><pre> <code class="cpp hljs">GPIO_InitTypeDef GPIO_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7 |GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11| GPIO_Pin_12|GPIO_Pin_13; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0); EXTI_InitStructure.EXTI_Line = EXTI_Line0; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); NVIC_InitTypeDef NVIC_InitStructure; NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0); NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure);</code> </pre><br>  And here is the interrupt handler code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Log[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> ptr=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI0_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log[ptr]=GPIOD-&gt;IDR; ptr++; EXTI_ClearITPendingBit(EXTI_Line0); }</code> </pre><br><h4>  Tests, debugging and finishing </h4><br>  It's time to check out what happened!  We start the computer, go to the BIOS setting.  We launch STM debag.  We go into the detection of disks, and, after detecting the disk C, we suspend the execution of the controller program.  In the debug window, we see that some data has been caught, and there are a lot of them! <br>  Then I did the following: I copied the contents of the buffer to MS Exel from the debag window to break down the columns and get rid of the first one containing the variable name, then copied the column with the values ‚Äã‚Äãinto a new text file and got something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">58453</span></span> <span class="hljs-number"><span class="hljs-number">54527</span></span> <span class="hljs-number"><span class="hljs-number">42069</span></span> <span class="hljs-number"><span class="hljs-number">38143</span></span> <span class="hljs-number"><span class="hljs-number">42069</span></span> <span class="hljs-number"><span class="hljs-number">38143</span></span> ...</code> </pre><br>  Now it's time to write a program to process the results in any convenient language, I used C # for this.  We need to split each input uint into data, address and access mode, creating a readable report.  This is done very simply, with the usual bit shifts and bitwise operations, for example, like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> busData = <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>.Parse(entry); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> data = (busData &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> address = ((busData &amp; <span class="hljs-number"><span class="hljs-number">0xFF00</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> rw = (address &amp; <span class="hljs-number"><span class="hljs-number">0x30</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>; address = (address &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>);</code> </pre><br>  However, after launching the program, I ran into a big problem - many records from the file contained access mode <i>11</i> , which meant no read / write signals.  Since the entrance to the interrupt was possible only with one of these signals, I concluded that the interrupt lasts longer than the bus cycle takes place, and I just don‚Äôt have time to read valid data. <br>  To test this hypothesis, I decided to set the <b>GPIOB.2</b> pin to <b>1</b> at the entrance to the interrupt, and reset it to <b>0</b> at the exit, after which I hung an oscilloscope probe on it. <br>  The result was depressing: <br><br><img src="https://habrastorage.org/storage2/64b/029/d3d/64b029d3da65c76cc251571c6bd8b5dd.jpg"><br><br>  As you can see, the system enters the interrupt already at the very end of the I / O cycle, despite the promised 12 input cycles.  Even the attribute <i>(naked)</i> did not help, the difference was completely insignificant. <br>  It upset me, but I decided to try to overclock the controller - the same AVRs succumbed very well to overclocking, why not check out how this is with STM32.  To do this, we need to go to the file <b>system_stm32f10x.c</b> , to the procedure for initializing the system clock signal <b>SetSysClockTo72</b> , and find the line <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);</code> </pre><br>  In this line you should change the constant <b>RCC_CFGR_PLLMULL9</b> for something bigger.  I will say right away - I tried all the options and eventually settled on the maximum value, <b>RCC_CFGR_PLLMULL16</b> .  Thus, the controller quietly wound up at 128 MHz instead of 72, even without warming up. <br>  By the way, it would be very good to tie the controller clock signal to the <b>CLK of</b> the ISA bus to work with it synchronously, but I really didn‚Äôt want to unsolder the quartz on the debug board, so I didn‚Äôt do that. <br>  Let's see what the oscilloscope shows now: <br><br><img src="https://habrastorage.org/storage2/8cf/8fa/43d/8cf8fa43ddd47223fa100c6bf1687218.jpg"><br><br>  Finally, we began to enter the interrapte early enough to have time to process it!  Let's type in the input data again and try to analyze it. <br>  I added a little to the program so that the report was issued formatted and immediately with the names of the registers that are being accessed.  In the case of an incorrect access mode, a row is added to the report about the invalid data. <br>  Here is the result of the program: <br><pre> <code class="cpp hljs">WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span> WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xAA</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xAA</span></span> WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x0F</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x0F</span></span> WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xA0</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x04</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xA0</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xA0</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Command [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x10</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xA0</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Drive/Head [<span class="hljs-number"><span class="hljs-number">0x1F6</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xA0</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x50</span></span> WRITE: Command [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xEC</span></span> READ: Status [<span class="hljs-number"><span class="hljs-number">0x1F7</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x58</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x5A</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xFF</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x10</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x3F</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x00</span></span> READ: Data [<span class="hljs-number"><span class="hljs-number">0x1F0</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x45</span></span> ...</code> </pre><br>  As we see, there are no invalid data anymore. <br>  Let's try to understand how BIOS performs detection. <br>  In the beginning, he persistently writes-reads to the registers that specify the address - making sure that the same value that was written is read.  If the ATA controller is not in the system, then the BIOS will try for a long time to write-read this same register, <i>0x1F4</i> - this is an example of a report when the controller board is pulled out: <br><br><pre> <code class="cpp hljs">WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xFF</span></span> WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xFF</span></span> ... WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span> READ: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0xFF</span></span> WRITE: Cylinder Low [<span class="hljs-number"><span class="hljs-number">0x1F4</span></span>] VALUE: <span class="hljs-number"><span class="hljs-number">0x55</span></span></code> </pre><br>  Then he gives the command <b>0x10</b> , the value of which was kindly suggested by <a href="http://geektimes.ru/users/mark_ablov/" class="user_link">mark_ablov</a> and which is an outdated recalibration command, forcing the disk to rearrange its magnetic heads to sector 0. Then the BIOS checks the status byte, waiting for the command to complete (you can see that the hard does not even enter the BUSY state , immediately responding that he did). <br>  And finally - the command <b>0xEC</b> , <i>DRIVE IDENTIFY</i> , in response to which hard gives 256 16-bit words of disk information. <br>  Before starting to read them from port <i>0x1F0</i> , BIOS requests the status byte from register <i>0x1F7</i> , waiting for the disk to be ready. <br>  Here, unfortunately, I understood my mistake - I decided that the data is given out by 8 bits, since the control registers are 8-bit.  However, as it turned out, the data is given out at 16 bits, so I received only 256 low bytes.  To get complete information, you will have to redo the scheme a bit, giving the entire <b>GPIOD</b> to the data, and outputting the address and access mode to other pins, which, of course, will increase the delay in processing them. <br>  Therefore, at the moment I paused, although perhaps in the near future I will continue to work and try to get on the bus not as a monitor, but as a device.  The ISA bus has a wonderful <b>IOCHRDY</b> signal, exposing an inactive level at which the device signals the need to increase the duration of the IO-cycle, which means that I may have enough time to switch pins to the output and issue my status. <br><br>  That's all for now, thank you for your attention. <br><br>  <b>Upd</b> : <br>  Just discovered an interesting thing.  If in the project settings you set O1 optimization instead of O3, then the interrupt entry time becomes exactly the way it should be.  After some research, I found out that with O2 or O3 optimization turned on, the compiler rearranges the instructions, which is why the signal pin is set to <b>1</b> not immediately after entering the interrupt, but after executing part of the code. <br>  Thus, when optimizing O1 on an oscilloscope, you can see that the system entered the interrupt handler earlier, but the execution time of this handler is longer than in the case of O3. </div><p>Source: <a href="https://habr.com/ru/post/161617/">https://habr.com/ru/post/161617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161605/index.html">View OpenCV images while debugging C ++ code in Visual Studio</a></li>
<li><a href="../161607/index.html">Once you read about the volatile keyword ...</a></li>
<li><a href="../161609/index.html">Overview of dialer programs for Windows Phone OS</a></li>
<li><a href="../161611/index.html">Traffic jams from the future</a></li>
<li><a href="../161615/index.html">Room plans are now available for Google Maps / Germany</a></li>
<li><a href="../161621/index.html">Google Maps API v2 - end of service</a></li>
<li><a href="../161625/index.html">Try R</a></li>
<li><a href="../161627/index.html">Are the Chinese taking over Epic Games?</a></li>
<li><a href="../161629/index.html">How much memory does objects consume in PHP and is it worth using the 64-bit version?</a></li>
<li><a href="../161631/index.html">Client for Habrastorage.org on Ruby</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>