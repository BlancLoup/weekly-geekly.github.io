<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Diagnostics in pictures: we understand the state of the product using tables and graphs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A beautiful idea of ‚Äã‚Äãa product within a large company or a startup almost always inevitably faces a number of difficulties during the implementation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Diagnostics in pictures: we understand the state of the product using tables and graphs</h1><div class="post__text post__text-html js-mediator-article">  A beautiful idea of ‚Äã‚Äãa product within a large company or a startup almost always inevitably faces a number of difficulties during the implementation phase.  It often happens that work is going on, bugs are fixed, the release is approaching, but there is no general understanding of the state of the product.  This happens because the own genius of the creators of the software or service (especially when it comes to startups) blinds their eyes, and the problems of the product are understood inadequately.  As a result, at best, the team does not fall into the release dates, and at worst, a non-viable product is born that users contemptuously call alpha and send hate rays to creators through a feedback form. <br><br>  Captain Obvious hints: to prevent this, it is important to be able to understand the state of your product at each stage of its development.  In this large article, a method of assessing its state is proposed in the most visual form - in the form of tables and graphs.  This is a summary of my experience and the experience of the entire team of the Parallels Novosibirsk office over the past six years.  To be clear: we are doing Parallels Plesk Panel - hosting panel, which is used on approximately every second server in the world that provides web hosting services.  Applying this technique, we got the following results: <br><ol><li>  significantly improved the quality of releases (according to the Incident rate); </li><li>  releases have become more predictable, the accuracy of our forecasts and estimates has increased significantly; </li><li>  there was an understanding of why something was going wrong and how to avoid it in the future. </li></ol><br>  Interested parties please under the cat and in the comments.  I will answer any questions. <br><a name="habracut"></a><br>  The article was written based on the speech at the QASib conference in Omsk. <br><br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.slideshare.net/slideshow/embed_code/13441179&amp;xid=17259,15700022,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhhHJgigRMaBNIkDphIB2LzgOHH6pQ" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By signing an offer to work in a large company or inventing a startup, we expect money, success and recognition from work.  At the beginning of the journey it often seems that everything is fine and cloudless, that we are geniuses who have invented cool software or a service with a set of useful functions, we have a team that worked together and a lot of time.  The road to success looks simple and hassle-free. <br><br>  Understanding usually comes at the stage of preparation for release.  The problems begin: a third-party team, with which you sponsored a part of the work, dynamite with your deadlines, someone in your team suddenly fell ill, the conceived features during the implementation turned out to be significantly more difficult, the chosen technical solutions do not look very successful.  In addition, you are drowning in a sea of ‚Äã‚Äãbugs, requirements from future users are constantly changing, new super-important features arise, which you definitely need to cram into this release.  Against this background, people's motivation is slowly melting.  These problems can absorb you and prevent the release to take place.  Consequently, the "bag of money" can not be seen.  There is not far to panic. <br><br>  The answer to the well-known questions ‚ÄúWho is to blame?‚Äù And ‚ÄúWhat to do?‚Äù Can be obtained on the basis of analyzing the data that will inevitably be collected in your hands.  If you somehow and somewhere record your tasks, current progress, results, problems found and other useful information, then it will be easy to track the status of the product.  Maintaining a "logbook" project in a barn book has the right to life, but it is better to store the data in some system that has an API or a clear database structure.  Using API and / or DB will make information easily accessible and analyzed. <br><br>  The Parallels Plesk Panel team is working with tasks and bugs in the <a href="http://www.targetprocess.com/">TargetProcess</a> system.  This system has a number of built-in reports that allow us to quickly receive information about the release, the current progress on working on it, the tasks completed and those that are still to be done, the command load and balancing of resources, bugs found, the dynamics of their location, etc.  If we need more detailed and diverse information, then we get it directly from the TargetProcess database. <br><br>  Well, now directly to the data and graphics. <br><br>  One of the first steps that in the future will allow you to correctly assess the state of your product is to assess whether you have time to do all that you have in mind. <br>  On the one hand, you have a great team, and, on the other hand, a set of features from the customer / product owner / program manager.  This is what should be compared. <br><br>  First you need to figure out how many man-hours (or story points, or ‚Äúparrots‚Äù) your team can digest.  For example, the release duration is estimated at three months.  In each month there are four weeks, in each week there are 5 days, in each day there are 8 hours (for simplicity, I do not take into account holidays).  The team consists of 10 people, where three are megaproductive guys, five are regular employees and two are novices who have worked on the project for a short time.  Summing up and multiplying, we get that our team is able to digest the amount of work with a total weight of about 4,000 man-hours in one release. <br><br>  Now let's estimate what the team will have to do: testing new features - 2,200 hours, verification of bugs - 350 hours, regression testing at the end of release - 600 hours, automation - 500 hours, holidays - 160 hours (you can subtract them from the team capacity, and you can lay here as someone is more convenient), risks - 200 hours (people‚Äôs diseases usually come here, new features that come unexpectedly with a ‚Äúmust‚Äù note, delays caused by other teams, etc.).  Total 3800 hours.  It looks like we manage to do everything and ensure the release of proper quality. <br><br>  Or not? <br><br>  But what if we have a team performance that is significantly less than the amount of work to be done? <br><br>  There are several options: <br><ol><li>  To keep silent and leave everything as it is, thinking that later on it will somehow decide by itself, or throw out people's vacations, or automation, or part of testing, which is likely to lead to a decrease in the quality of the product.  So what?  Fine!  Normally, if you are working on a product that you hate, or with a team that you want to destroy ... It is a pity that this approach is so often used in the industry. </li><li>  To bring this problem to the limitations of the team's performance to program and project managers and to achieve a decrease in the number of features on the release or a shift in the release date to a later date.  It sounds more or less.  And you can take this situation as a difficult and interesting challenge and take the third path. </li><li>  Come up with a way to do the same thing, but in less time and with less effort.  Ideally, use the last two options at the same time. </li></ol><br>  Be sure to ensure that the amount of work that needs to be done is correlated with the amount of work that your team can digest.  Well, or you had a clear plan on how to get around this problem. <br><br>  Your estimates will lay the foundation for a release burn down chart. <br><br>  Translated into Russian, the burn down will sound like ‚Äúburn to the ground‚Äù - which corresponds well to the meaning of this schedule - to show the amount of work done and the remaining work in relation to time. <br><br>  Now there will be slides. <br><img src="https://habrastorage.org/getpro/habr/post_images/f60/0b6/c13/f600b6c130483747d90896ae01789b92.jpg" alt="Slide 09"><br><br>  Consider for example the schedule of QA team work for a release lasting three months. <br><br>  The green line corresponds to the perfect utilization of resources, when each team member performs a fixed amount of work every day, corresponding to his qualifications and performance.  The blue line shows the amount of work that needs to be done at each point in time. <br><br>  From the graph it is clear that: <br><ul><li>  the first seven days was the planning and evaluation of tasks for release </li><li>  then about three weeks there was work on release (since the blue line is parallel to the green, then, most likely, the tasks were done according to plan, and the initial estimates got to the point) </li><li>  a month after the start of the release, we see a jump in the blue line up, most likely due to the addition of new features or a reassessment of labor costs </li><li>  then again we see the work on the tasks, which obviously does not go according to plan (it may be caused by the illness of someone from the team, delays on the side of other teams, poor quality features, etc.) </li></ul><br>  If it was inherent in risks for us - excellent, if not - then you need to make a decision about what to do to correct the situation. <br><br>  And one more line on the graph, red dotted, shows when to really expect the release to end, if we continue to work at the same pace as in recent days.  It is recalculated every day, based on the actual speed of disposal of tasks in recent days. <br><br>  The schedule looks simple, but it is very useful for understanding the current situation in your project and allows you to adjust your plans in a timely manner, based on the current situation. <br><br>  Useful life hack.  In addition to the general schedule for the project, it makes sense to have separate graphics for development and for QA.  If the teams are large and can be divided into subcommands, then it is better for each of them to keep their schedule.  This can be extremely useful in finding bottlenecks in your project.  You may even be able to find the team that pulls the whole project down and does not let them fly. <br><br>  Often we have questions: do we repair it?  Do we have time?  The answer to us here can give information about the number of open bugs on the release, grouped by priority. <br><br>  For each bug, we set a priority from p0 to p4, where: <br><ul><li>  P0 - must be fixed by ASAP </li><li>  P1 - must be repaired before the end of the iteration / sprint </li><li>  P2 - must be repaired before the end of release. </li><li>  P3 - fix if there is time </li><li>  P4 - everything else you can live without </li></ul><br>  As an example, consider the following graph. <br><img src="https://habrastorage.org/getpro/habr/post_images/b78/b71/1e1/b78b711e1ae0a02c5ed6379c9e9f88d2.jpg" alt="Slide 10"><br><br>  The green line shows the number of open bugs p0-p1, judging by the schedule, we can assume that 4 and 8 weeks are the ends of the iterations, when all the bugs p0-p1 are repaired.  This is one of the criteria for closing an iteration. <br><br>  The red line, respectively, shows the number of open bugs p0-p2, and the blue line - the total number of open bugs in the release. <br><br>  Therefore, if you see at the beginning and middle of the iteration that the volume of bugs p0-p1 grows so fast that you can‚Äôt fix everything and check their fixes until the end of the iteration, then you need to take appropriate decisions: re-prioritize bugs (it‚Äôs interesting to reduce the priority for some bugs p0- p1), transfer part of features to the next iteration (free time to spend on bug fixing), extend the iteration until all p0-p1 bugs are fixed, add additional resources to the command, etc. <br><br>  Toward the end of the release, it makes sense to add another line to the same schedule.  The purple line shows the number of bugs that the development team can fix.  That is, if we have a release to happen at the beginning of the 19th week, then in the 18th week developers will be able to repair 38 bugs, for the 17th and 18th weeks - 79 bugs, for the 16-17-18th weeks - 147 bugs, and so on. <br>  Such a schedule allows you to predict the situation when a team of developers is not able to fix all the bugs that need to be fixed before the end of the release.  This will allow you to take certain actions in advance: <br><ul><li>  sort the p1-p2 bugs in order to re-prioritize them, the development focus only on those bugs that really need to be repaired, and not waste time on p3-p4 bugs and pseudobags p1-p2 </li><li>  attract additional resources to bugfix </li><li>  move the release date to a later time, etc. </li></ul><br>  The next thing that makes sense to look at is the number of found and fixed bugs in relation to time. <br><br>  The picture shows an example of a release of three iterations, where two iterations are the development of new features and one is product stabilization. <br><img src="https://habrastorage.org/getpro/habr/post_images/ac8/304/d08/ac8304d0891ecb081dc1311dad9116e9.jpg" alt="Slide 11"><br><br>  If we look at this chart at the time of working on one of the first iterations, then this allows us to track the quality of the features that we are currently working on.  For example, if on the 6th week we received 60 bugs instead of 37, then this would be a signal to us that we need to figure out why we found problems twice as large as usual at this stage of the iteration. <br><br>  Much the same goes for bugfixing.  For example, if on the 4th and 8th week much fewer bugs were fixed than usual, then you need to understand why.  Bugs harder?  Or is there less time allocated for bugfixing than expected? <br><br>  If we look at this graph at the stage of stabilization of the product, then it is immediately obvious whether we are bringing the product to the state when it can be given to end users.  It seems that the answer is simple: yes, if the number of found bugs falls, and not if it grows.  But this is not always the case.  This graph gives us only information about how many bugs are found, but does not say what kind of bugs. <br><br>  If we consider the distribution of found bugs by severity on the same release, it becomes clear that the release does stabilize even though the number of found bugs does not decrease as it approaches the end date. <br><img src="https://habrastorage.org/getpro/habr/post_images/689/f28/9df/689f289df6b6bd9aa3508cdc4f8b75e1.jpg" alt="Slide 12"><br><br>  The bugs found on the latest releases are less critical in terms of severity: last week the blockers disappeared completely, the critics almost disappeared, the number of found majors decreased by half, but the number of normals and minors increased. <br>  Consequently, the unchanged number of bugs found does not mean that the product has not been improved. <br><br>  Another valuable source of information is the distribution of bugs according to the circumstances in which they were found. <br><img src="https://habrastorage.org/getpro/habr/post_images/146/eaa/276/146eaa276d650aa7996e055763cb1e1d.jpg" alt="Slide 13"><br><br>  For this we have bugs there is a special field ‚ÄúFound under condition‚Äù, which can take the following values: <br><ul><li>  Customer - we missed a bug in one of the previous versions, and the custom owners found it and reported to us </li><li>  Regression - the functionality working in previous versions was broken in the current </li><li>  Fresh Look - we became better and more tested and found bugs from previous versions that we missed earlier </li><li>  New TC - we found a bug in the new features of the current release </li><li>  Other... </li></ul><br>  Understanding how the found bugs are distributed over these categories gives us a number of useful information that can be briefly presented in such an easily perceived table. <br><table><tbody><tr><td>  What happened? </td><td>  What to do? </td></tr><tr><td>  We find a lot of regression bugs when testing new functionality made in the current iteration </td><td>  We need to understand the reason why, by doing the new functionality, we break the old one working, talk to the developers of the relevant features, increase the number of unit tests, plan additional regression testing. </td></tr><tr><td>  We find a lot of new TCs bugs </td><td>  Talk with the developers about the reasons for the poor quality of the features, send them for revision, improve the code review procedures. </td></tr><tr><td>  We find a lot of fresh look bugs </td><td>  On the one hand, we began to test better, look deeper and wider, on the other hand, why did we not find these problems before?  If the deadlines are very tight at the end of the release, then such bugs can be sacrificed, because  the product will not get worse, and the found bugs may not interfere with anyone, since no one complains about them from the users. </td></tr></tbody></table><br>  Another useful source of information is the distribution of bugs by component, it will give us the answer to the question of which component of your product is weak in the knees. <br><img src="https://habrastorage.org/getpro/habr/post_images/cbf/939/1d3/cbf9391d3e98942afa36f8bf6e0341c1.jpg" alt="Slide 14"><br><br>  Combining this with the distribution of severity, you can highlight the most problematic components of the current moment and try to understand why this is happening and how to fix it. <br><br>  If the problematic components do not change from week to week, you can be congratulated: you have found a bottleneck in your product.  And if customers also constantly complain about these components, then it makes sense to think about their quality, architecture, the team that is working on them, adding additional resources to them from both development and QA, increasing test coverage and many other things. . <br><br>  One of the main sources of product information for you, of course, are your users.  When you are not working on the first version of the product, then you have a chance to use feedback from them, which you can receive through your support, forum, sales agent, manual, automatic reports built into your product, etc. <br><br>  This will allow: <br><ul><li>  understand what features are generally in demand, and what is not, what is worth developing, and what is not; </li><li>  understand exactly how customers use your product, what scenarios (it often happens that you checked everything before the release, and after the release comes bugs that such a script does not work, and this doesn‚Äôt work, and you went completely different trails); </li><li>  use risk-based testing (for example, complete testing on the most common configurations and trimmed down on all others). </li></ul><br>  Another powerful tool is a comparison of the current situation with previous releases. <br><img src="https://habrastorage.org/getpro/habr/post_images/117/3ca/6cd/1173ca6cd21f18f7f27b762bee7981d4.jpg" alt="Slide 16"><br><br>  Since we use TargetProcess for several years, the amount of accumulated information is very large, it allows us to predict exactly what to expect from the release, to understand how much we make mistakes in the estimates we give, how many bugs we will find and how much we will fix, what risks usually shoot and how to get around them, how much time we need for certain tasks, etc. <br><br>  What else is worth paying attention when analyzing the current state of the release: <br><ul><li>  the results of the regular execution of autotests, </li><li>  the difference between the initial estimates and the actual time spent </li><li>  the quality of the features that is affixed by the people responsible for testing these features, </li><li>  number of open bugs on severity-priority, </li><li>  number of bugs on the verification regarding the time </li><li>  what percentage of bugs found during the release we repair </li><li>  density bugs in the code, etc. </li></ul><br>  As you can see, all these graphs and tables are a very powerful and useful tool that will help you correctly and accurately plan your release, taking into account most of the possible problems, predict the problem in advance and help you correct it in time, and, equally important, avoid it in the future. <br><br>  In particular, they allowed the development of the recent Parallels Plesk Panel 11. <br>  There should be a list of what in QA has become in Plesk 11 a real breakthrough.  Of course, if this could be spoken out loud. <br><br>  But!  It is very important to remember that no matter how much data you collect, no matter how many tablets and graphs you build, <b>they will only be useful if you draw useful conclusions based on them and change the product and processes for the better</b> . </div><p>Source: <a href="https://habr.com/ru/post/148812/">https://habr.com/ru/post/148812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148805/index.html">Two approaches to software design for embedded</a></li>
<li><a href="../148806/index.html">The most important motivation</a></li>
<li><a href="../148808/index.html">The stock hackers again came "breaking" ...</a></li>
<li><a href="../148809/index.html">The problem of "two or more teachers." First touches</a></li>
<li><a href="../148810/index.html">Koding.com - localhost in the cloud</a></li>
<li><a href="../148814/index.html">44th anniversary, as well as other interesting letters and numbers from the life of Intel</a></li>
<li><a href="../148815/index.html">STALKER 2 - the project continues Bethesda</a></li>
<li><a href="../148818/index.html">Microsoft launches Outlook.com</a></li>
<li><a href="../148819/index.html">Five interesting hover effects using multiple background images</a></li>
<li><a href="../148821/index.html">Microsoft invites Google to go to the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>