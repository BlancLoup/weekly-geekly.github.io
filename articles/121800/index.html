<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Young Tables in Search and Sort Tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jung's tables are a widely known (in narrow circles) type of objects studied in combinatorics and related sciences: reference , reference , book . Bel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Young Tables in Search and Sort Tasks</h1><div class="post__text post__text-html js-mediator-article">  Jung's tables are a widely known (in narrow circles) type of objects studied in combinatorics and related sciences: <a href="http://en.wikipedia.org/wiki/Young_tableaux">reference</a> , <a href="http://dic.academic.ru/dic.nsf/enc_mathematics/6410/%25D0%25AE%25D0%259D%25D0%2593%25D0%2590">reference</a> , <a href="http://biblio.mccme.ru/node/1818">book</a> .  Below we consider the use of a particular type of Young table with reference to such standard algorithmic problems as search and sorting.  From this point of view, Jung's tables are very close to the pyramids, in fact, this is how they are positioned in the Kormen and co textbook (exercises in the section on pyramids). <a name="habracut"></a><br><br><h5>  The concept of Young table </h5><br>  Let us call the Young table a partially ordered almost filled numerical matrix.  Partial ordering means that each element of such a matrix does not exceed the values ‚Äã‚Äãof its upper and left neighbors (provided that these elements have such neighbors).  Almost full means the following: the first j rows of the matrix (from zero to (j-1) -th) are completely filled in the table, the first l elements are filled in the j-th row, all the remaining rows are empty.  An example of a Young table is shown in the following figure. <br><img src="http://ir43.com/images/jt1.jpg"><br>  According to our definition, the rows and columns of the Young table are ordered in descending order.  In particular, the largest element of the table is in its upper left corner.  However, the location of all other elements is already not clearly defined.  Thus, Young table can be considered as a matrix (tabular) analogue of partially-ordered almost filled trees, known in the world as pyramids. <br><br><h5>  Insert and delete items </h5><br>  First, let's look at how to insert a new value of x into the Young table.  To do this, we first write the value of x in the first free cell of the table, so that its almost full property is not violated.  If the table does not have the end of a filled row, then insert a new element in the first free cell of this row.  If there is no such line, then we will insert a new element into the first (zero) cell of the first empty line.  After the insertion is completed, only the partial order property can be broken.  To restore it perform the operation of lifting the item.  For this, the current element x is compared with its upper and left neighbors.  If any of these neighbors is a smaller x, then swap x with the smaller of the neighbors.  This process of moving x up and to the left on the table continues until we rest in the upper left corner, or both neighbors (or one, if there is no second one) turn out to be larger or equal to x.  The following figure shows the process of inserting the number 5 in the table from the first figure. <br><img src="http://ir43.com/images/jt2.jpg"><br>  Only the largest element located in its upper left corner will be deleted from the Young table.  First, we transfer the value x from the last occupied cell of the table to this cell, after which we apply the element descent operation.  This operation is performed in the same way as lifting, but in the other direction (right and down), until the current element has lower and right neighbors, or these neighbors (or only one, if there is no second) are less or equal to x.  The process of deleting the largest element from the table from the last figure is shown below. <br><img src="http://ir43.com/images/jt3.jpg"><br>  It is obvious that the Young table with the above insert and delete operations is actually an implementation of the ADT Queue with priority.  An interesting feature of this implementation is that the time of insertion and deletion is of the order of O (max (r, c)), where r and c are the dimensions of the matrix.  If we assume that r = c, then we get that the insertion time is of the order O (n <sup>0.5</sup> ), where n is the number of elements in the table.  Below we will assume that a square table of the smallest possible size m = int (ceil (sqrt (n))) is used to store the n elements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Sort using Young table </h5><br>  It is clear that with the implementation of the ADT Queue with priority, you can organize the sorting of a given numerical sequence X. The scheme of such sorting is trivial: first write all their X elements into the queue, then remove all the elements from the queue and write and return to X starting from the end (t. e. right to left).  Thus, the largest element will be written at the end of X, the next largest - in the penultimate cell X, etc.  It is obvious that the time of such sorting will be asymptotically equal to the product of the number n of elements in X by the time of insertion (deletion) of elements into the queue.  Those.  when using the Young table as a priority queue, the sorting complexity will be O (n <sup>1.5</sup> ).  This means that the proposed algorithm asymptotically occupies an intermediate position between the quadratic (inset) and linear-logarithmic algorithms (merge) and is a close neighbor of Shell sort. <br>  The described general sorting scheme assumes that a separate data structure is used to store the queue, i.e.  additional memory volume is not less than n.  However, as for pyramids, it is possible for Young's tables to sort by place, without going beyond the sequence (array) of X. To do this, note that 1) every time an element is removed from X, it is immediately inserted into the table and vice versa i.e. the total amount of necessary memory remains constant all the time and equal to n);  2) usually matrices are stored in computer memory line by line in the form of, essentially, a one-dimensional array (or we ourselves can organize such a storage scheme).  Based on these considerations, we obtain the following simple sorting algorithm, which uses two auxiliary functions of lifting (MoveUp) and descending (MoveDown) of elements in the Young table.  At each moment of time, the left part of the array X contains the Young table, the right - the sequence X. In the first pass, we start with a table in one element and gradually add elements from X to it. with the last element of the table, at the same time reducing the size of the table by one.  This leads to the fact that the newly built sequence X is ordered in ascending order. <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YoungTableauSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, n)</span></span></span><span class="hljs-function">:</span></span> m = int(ceil(sqrt(n))) <span class="hljs-comment"><span class="hljs-comment">#   for i in range(1,n): #   MoveUp(X,i,m) for i in range(1,n): #   X[0], X[ni] = X[ni], X[0] MoveDown(X,ni,m) def MoveUp(X,i,m): while True: t = i if i%m and X[i-1]&lt;X[t]: t = i-1 #    if i/m and X[im]&lt;X[t]: t = im #    if i==t: return #    X[i], X[t] = X[t], X[i] i = t def MoveDown(X,k,m): # k -     i = 0 while True: t = i if i%m+1&lt;m and i+1&lt;k and X[i+1]&gt;X[t]: t = i+1 #    if i/m+1&lt;m and i+m&lt;k and X[i+m]&gt;X[t]: t = i+m #    if i==t: return #  X[i], X[t] = X[t], X[i] i = t</span></span></code> </pre> <br><br>  So, we have an in-place sorting algorithm that works during O (n <sup>1.5</sup> ) in the worst case. <br><br><h5>  Search Young table </h5><br>  Suppose we want to use a Young table (represented by a one-dimensional array, as was done above) as a container.  What functions can support such a container?  First of all, the insertion of a new element, secondly, the search for the largest element (especially not to look for it, since this element is the first), removal of the largest element, conversion to an ordered sequence.  The listed operations are also inherent in the pyramids.  What distinguishes Young's tables about the pyramids is the ability to effectively search for items.  Finding anything other than the largest element in the pyramid can only be done by exhaustively searching all its elements (at worst).  But in the Young table, the search for any element can be performed at the same time of the order O (n <sup>0.5</sup> ).  The algorithm for such a search is as follows.  We start the search for the element x from the upper right corner of the table (in a one-dimensional array it is the element with the number m-1).  If the current item is equal to the search, the search is completed.  If the current element is less than the desired one, then move the table one step to the left, because  all elements below will be obviously smaller x.  If there is nowhere to move, the search is declared unsuccessful.  If the current element is greater than the desired one, then it is necessary to move down one cell.  If the current line is the last one, then the shift is not possible - the search is unsuccessful.  If the current line is not the last, but there is no current element at the bottom, then it is necessary to shift to the left again (with a check to reach the left edge of the table).  The code for this function is shown below. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X,k,m,x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># k -     i = m-1 while True: if X[i]==x: return i #  if X[i]&lt;x or i/m+1&lt;m and i+m&gt;=k: #    if i%m: i -= 1 else: return -1 else: #    if i/m&lt;m-1 and i+m&lt;k: i += m else: return -1</span></span></code> </pre> <br><br>  It is easy to make sure that the number of elements scanned in a table when performing a search does not exceed twice the size of the table, i.e.  again, it is of the order of O (n <sup>0.5</sup> ).  An example of finding the number 4 in the Young table is shown in the following figure. <br><img src="http://ir43.com/images/jt4.jpg"><br><br><h5>  Instead of conclusion </h5><br>  To the above operations on Young table, you can add 1) change the value of any element in time O (n <sup>0.5</sup> );  2) removal of an arbitrary element in time O (n <sup>0.5</sup> );  3) search for the smallest element that is generally performed in constant time, since  the smallest element, by virtue of the definition of the Young table, is located either in the last non-empty cell or in the last cell of the last but one non-empty row. <br>  Thus, Young's tables can be considered as a relatively simple analogue of binary search trees, advantages: ease of implementation, low overhead costs for data storage;  shortcomings: the execution time of the main operations is not logarithmic, but root-root, the overflow problem is after the place in the table ends, we can either add a new row (without performing full restructuring, but violating the squareness of the table, which may further reduce efficiency of operations), or perform a complete restructuring of a new larger square table.  These deficiencies are partially solved with the help of the so-called binary Young tables, which I will try to write about sometime in the near future. </div><p>Source: <a href="https://habr.com/ru/post/121800/">https://habr.com/ru/post/121800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121295/index.html">The rhetoric on the topic "And if we are not carried away by the new media?"</a></li>
<li><a href="../121795/index.html">ReSharper 6 beta released</a></li>
<li><a href="../121796/index.html">Yevgeny Butman: ‚ÄúPrices in Apple for Apple products will never be equal to American ones‚Äù</a></li>
<li><a href="../121797/index.html">VHDL for beginners. Brainfuck</a></li>
<li><a href="../121799/index.html">Property in C ++</a></li>
<li><a href="../121801/index.html">Experienced trivia windows admin</a></li>
<li><a href="../121803/index.html">Top 11 most common errors in javascript</a></li>
<li><a href="../121804/index.html">Time management in practice</a></li>
<li><a href="../121805/index.html">Computer virus - the pursuit of the living?</a></li>
<li><a href="../121806/index.html">ACL: Cisco IOS Access Control Lists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>