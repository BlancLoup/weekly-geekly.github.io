<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ad render v.2.0. Book One. Overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gag 
 A year ago I came across a series of very interesting articles by Mr. Simon . Simon loves to disassemble how games are created, namely the graph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ad render v.2.0. Book One. Overview</h1><div class="post__text post__text-html js-mediator-article"><h3>  Gag </h3><br>  A year ago I came across a series of very interesting articles by Mr. <a href="https://simonschreibt.de/">Simon</a> .  Simon loves to disassemble how games are created, namely the graphic solutions of one or another element in the game.  Starting from <a href="https://simonschreibt.de/gat/fallout-3-edges/">chipping on the edges of plates</a> , ending with <a href="https://simonschreibt.de/gat/alien-vs-wolfenstein-cutting-torch/">how cutting of pieces from objects is implemented</a> .  But especially interesting is his series of articles under the general title ‚Äú <a href="https://simonschreibt.de/gat/renderhell/">Render Hell</a> ‚Äù, in which he examines in detail how the rendering of 3D objects occurs at the hardware level (and programmatically too). <br><br>  Free translation.  I made it for myself so that at some point I could come back and read what I could not catch on the first try, or just forget. <br><br>  So, let's start? <br><a name="habracut"></a><br><h3>  Book One.  Overview </h3>  (original book <a href="https://simonschreibt.de/gat/renderhell-book1/">here</a> ) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Guys, hold on: in terms of PCs, your work in 3D is nothing more than a list of vertices and textures.  All this data is converted into the Next-Gene image, and this is mainly done using a system processor ( <b>CPU</b> ) and a graphics processor ( <b>GPU</b> ). <br><br>  First, data is loaded from your hard disk ( <b>HDD</b> ) into random access memory ( <b>RAM</b> ) for quick access to it.  After that, the objects ( <b>Meshes</b> ) and textures that are needed for displaying (rendering) are loaded into the video memory of the video card ( <b>VRAM</b> ).  This is due to the fact that access to VRAM from a video card is much faster. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/copy_data_from_hdd_to_ram_vram_01.webm" type="video/webm"></video></div></div></div><br><br>  If the texture is no longer needed (after unloading in VRAM), it can be removed from RAM (But you must be sure that you will not need it anytime soon, because unloading from the HDD takes a very long time). <br>  The meshes should remain in RAM, because most likely the processor will want to have access to them, for example, to determine a collision. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/delete_data_in_ram.webm" type="video/webm"></video></div></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Amended by the second edition</b> <div class="spoiler_text">  Now all the information on the video card (in the video card RAM - VRAM).  But the transfer speed from VRAM to GPU is still low.  A GPU can process much more information than it receives. <br><br>  Consequently, the engineers put a small amount of memory straight into the video processor (GPU) itself and called this memory cache (Cache).  This is a small amount of memory, because it is incredibly expensive to put a large amount of memory directly into the processor.  The GPU copies to cache only what it needs now and in small portions. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/copy_data_from_vram_to_l2_01.webm" type="video/webm"></video></div></div></div><br><br>  Our copied information now lies in a Level 2 cache (L2 Cache).  Basically, this is a small amount of memory (for example, on the NVDIA GM204, the volume is 2048 kB), which is installed in the GPU and is available for reading much faster than VRAM. <br><br>  But even this is not enough to work effectively!  Therefore, there is a small level 1 cache (L1 Cache).  On the NVIDIA GM204, it is 384Kbytes, which is available not only for the GPU, but also for the nearest co-processors. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/copy_data_from_l2_to_l1_01.webm" type="video/webm"></video></div></div></div><br><br>  In addition, there is another memory that is intended for input and output data for the GPU cores: for file registration and recording.  From here, the GPU takes, for example, two types of values, counts them and records the results in a register: <br>  After that, these results are placed back into L1 / L2 / VRAM to make room for new calculations.  You, as a programmer, usually do not have to worry about their calculations. <br><br>  Why does all this work without problems?  As stated above, this is all about access time.  And if we compare the access time, for example, HDD and L1 Cache, then a black hole between them is such a difference.  You can also read about the exact figures for the delay on this link: <a href="https://gist.github.com/hellerbarde/2843375">gist.github.com/hellerbarde/2843375</a> <br></div></div><br>  Before the render starts to fire, the CPU sets some global values ‚Äã‚Äãthat describe how the meshes should be rendered.  These values ‚Äã‚Äãare called Render State. <br><br>  <b>Render state</b> <br><br>  These are sort of parameters for how meshes should be rendered.  The parameters contain information about what the texture should be, what vertex and pixel shaders should be used to draw subsequent meshes, light, transparency, and so on. <br><br>  AND IT IS IMPORTANT TO UNDERSTAND: Each mesh that the CPU sends to the GPU for rendering will be rendered under the parameters (Render State) that were specified before it.  That is, you can render a sword, a stone, a chair and a car - all of them will be rendered under one texture, if you do not specify RenderState drawing parameters in front of each of these objects. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/renderstate.webm" type="video/webm"></video></div></div></div><br><br>  When all the preparations are complete, the CPU can finally call the GPU and tell it to draw.  This command is called Draw Call. <br><br>  <b>Drawcall</b> <br><br>  This is the CPU command for the GPU to render one mesh.  The command specifies a specific mesh for the render and does not contain any information about materials and other things - this is all indicated in the Render State. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/cpu_calls_gpu.webm" type="video/webm"></video></div></div></div><br><br>  Mesh is already loaded in VRAM memory. <br><br>  After the command is sent, the GPU takes the RenderState data (material, textures, shaders), as well as all the information about the vertices of the object, and converts this data into (we want to believe) beautiful pixels on your screen.  This conversion process is called Pipeline (Google likes to translate this word as ‚Äúpipeline‚Äù). <br><br>  <b>Pipeline</b> <br><br>  As mentioned earlier, any objects are no more than a collection of vertices and texture information.  To convert this into a brain-bearing picture, the video card creates triangles from vertices, calculates how they should be lit, draws textures on them, and so on. <br><br>  These actions are called Pipeline States.  Most often, most of this work is done using a GPU video card.  But sometimes, for example, the creation of triangles is done with the help of other co-processors of the video card. <br><br><div class="spoiler">  <b class="spoiler_title">Amended by the second edition</b> <div class="spoiler_text">  This example is extremely simplified and should be considered only as a rough overview or ‚Äúlogical‚Äù pipeline: each triangle / pixel goes through logical steps, but what actually happens is slightly different from the one described. <br></div></div><br>  Here is an example of the steps that iron takes for a single triangle: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/pipeline_overview.webm" type="video/webm"></video></div></div></div><br><br>  Rendering a picture takes place by solving tens, hundreds of thousands of similar tasks, drawing millions of pixels on the screen.  And all this should (I hope) fit at least 30 frames per second. <br><br>  Modern processors have 6-8 cores each, while video processors have several thousand cores (though not as powerful as the CPU, but powerful enough to handle a bunch of vertices and other data). <br><br>  Book number 2 is devoted to the details of the organization of high and low levels in the graphics processor. <br><br>  When information (for example, a handful of vertices) gets on the pipeline, then several cores carry out the work of transformation from vertices into a full-fledged image, so a handful of these elements are formed into the image simultaneously (in parallel). <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/pipeline_overview_multicore.webm" type="video/webm"></video></div></div></div><br><br>  Now we know that the GPU can process information in parallel.  But what about the communication between the CPU and the GPU?  Does the CPU wait for the GPU to finish before sending new tasks to it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0b/add/d86/f0baddd86eefd7916d2cd0d994b78063.gif" alt="image"><br><br>  NO! <br><br>  Fortunately, no!  The reason for this is the weak link, which is formed like a bottleneck, when the CPU is not able to send the following tasks quickly enough.  The solution is a list of commands in which the CPU adds commands to the GPU while it processes the previous command.  This sheet is called - Command Buffer. <br><br>  <b>Command buffer</b> <br><br>  The command buffer makes it possible for CPU and GPU operations to be independent of each other.  When the CPU wants to render something, it stuffs the objects into the command queue, and when the GPU is released, it takes them out of the list (buffer) and starts executing the command.  The principle of taking the team - the order of execution.  The first team came, and it will be the first to be executed. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://data.simonschreibt.de/gat049/commandbuffer_communication.webm" type="video/webm"></video></div></div></div><br><br>  By the way, there are different teams.  For example, one command can be DrawCall, the second one can change RenderState to new parameters. <br><br>  Well, in general, this is the first book.  Now you have an idea of ‚Äã‚Äãhow the information is rendered, called Draw Calls, Render State, and interact between the CPU and the GPU. <br><br>  The End. </div><p>Source: <a href="https://habr.com/ru/post/336688/">https://habr.com/ru/post/336688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336678/index.html">How we created the ATOL Online cash desk service</a></li>
<li><a href="../336680/index.html">Work with complex software: how to migrate the cash program and not "break" the store</a></li>
<li><a href="../336682/index.html">How to evaluate a job offer</a></li>
<li><a href="../336684/index.html">Quick Python performance test for computing tasks</a></li>
<li><a href="../336686/index.html">Boot from GPT disk from BIOS</a></li>
<li><a href="../336690/index.html">RailsClub 2017: Interview with Nick Sutterer. Rails dies (Ruby doesn't)</a></li>
<li><a href="../336692/index.html">Animation in WPF and Blend SDK</a></li>
<li><a href="../336694/index.html">The practice of forming requirements in IT projects from A to Z. Part 1. Introduction</a></li>
<li><a href="../336696/index.html">Overview of one Russian RTOS, part 2. Core MAX RTOS</a></li>
<li><a href="../336698/index.html">What are the favicons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>