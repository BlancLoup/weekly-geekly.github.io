<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Correcting typos with context</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I recently needed a library to correct typos. Most open spell-checkers (for example, hunspell) do not take into account the context, and without it, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Correcting typos with context</h1><div class="post__text post__text-html js-mediator-article"><p>  I recently needed a library to correct typos.  Most open spell-checkers (for example, hunspell) do not take into account the context, and without it, it is difficult to obtain good accuracy.  I took Peter Norvig‚Äôs spell checker as a basis, screwed a language model (based on N-grams) onto it, sped it up (using the SymSpell approach), overcame a strong memory consumption (via bloom filter and perfect hash) and then designed it all as a library on C ++ with swig bindings for other languages. </p><a name="habracut"></a><br><h2 id="metriki-kachestva">  Quality metrics </h2><br><p>  Before writing spellchecker directly, you had to think of a way to measure its quality.  Norvig used a ready-made collection of typos for this purpose, which contains a list of misspelled words along with the correct version.  But in our case, this method is not suitable due to the lack of context in it.  Instead, the first thing to do was write a simple typo generator. </p><br><p>  The input error generator takes the word, gives the word at the output with a certain number of errors.  Errors are of the following types: replacing one letter with another, inserting a new letter, deleting an existing one, and also rearranging two letters in places.  The probabilities of each type of error are adjusted separately; the total probability of a typo is also adjusted (depending on the length of the word) and the probability of a repeated typo. </p><br><p>  So far, all the parameters have been chosen intuitively, the probability of error is about 1 in 10 words, the probability of the simplest type of error (replacing one letter with another) is 7 times higher than other types of errors. </p><br><p>  This model has many flaws - it does not rely on real-life typo statistics, does not take into account the keyboard layout, and also does not glue or split words.  However, for the initial version of it is enough.  And in the next versions of the library model will be improved. </p><br><p>  Now, having a typo generator, you can drive through any text and get the same text with errors.  As a quality metric of a spell checker, you can use the percentage of errors remaining in the text after running it through this spell checker.  In addition to this metric, the following were used: </p><br><ul><li>  percentage of corrected words (as opposed to a metric with a percentage of errors ‚Äî counted only as words that contain errors, and not across the text) </li><li>  percentage of broken words (this is when there was no error in the word, but the spell checker decided that it was there, and corrected it) </li><li>  Percentage of words for which the correct version was proposed in the list of N candidates (spellcheckers usually offer several correction options) </li></ul><br><h2 id="spellcheker-pitera-norviga">  Peter Norvig Spellchecker </h2><br><p>  Peter Norvig described a simple spell checker version.  For each word, all possible variations are generated (deletes + inserts + replacements + permutations), recursively with a depth of &lt;= 2. The resulting words are checked for presence in the dictionary (hash table), the one that occurs most often is selected among the set of matching options.  You can read more about this spell checker in the <a href="http://norvig.com/spell-correct.html">original article</a> . </p><br><p>  The main disadvantages of this spellchecker are a long time (especially on long words), lack of context.  We begin with correcting the latter ‚Äî add a language model and instead of a simple word frequency we will use the estimate returned by the language model. </p><br><h2 id="model-yazyka-na-osnove-n-gramm">  N-gram based language model </h2><br><table><tbody><tr><td>  N-grams - a sequence of n elements.  For example, a sequence of sounds, syllables, words or letters. </td></tr></tbody></table><br><p>  The language model is able to answer the question - with what probability this sentence may occur in the language.  To date, two approaches are mainly used: <a href="https://web.stanford.edu/~jurafsky/slp3/4.pdf">models based on N-grams</a> and also <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">based on neural networks</a> .  For the first version of the library, the N-gram model was chosen, since it is simpler.  However, in the future there are plans to try the neural network model. </p><br><p>  The n-gram model works as follows.  According to the text used to train the model, we go through a window with a size of N words and count the number of times each combination (n-gram) has been encountered.  When requesting a model, we similarly pass through the window according to the proposal and consider the product of the probabilities of all n-grams.  We estimate the probability of meeting the n-gram by the number of such n-grams in the training text. </p><br><p>  The probability <em>P (w <strong>1</strong> , ..., w <strong>m</strong> ) to</em> meet the sentence <em>(w <strong>1</strong> , ..., w <strong>m</strong> )</em> of m words is approximately equal to the product of all n-grams of size n, of which this sentence consists: <br><img src="https://habrastorage.org/getpro/habr/post_images/8d1/499/205/8d14992058f8a82f566ebe452ee964ef.jpg" alt="formula1"></p><br><p>  The probability of each n-gram is determined by the number of times that n-gram has been encountered relative to the number of times that the same n-gram has been encountered but without the last word: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/db9/6a6/96f/db96a696f12c65fc2ac2ff12d1ad87a0.jpg" alt="formula2"></p><br><p>  In practice, such a model is not used in its pure form, since it has the following problem.  If some n-gram is not met in the training text - the whole sentence will immediately receive a zero probability.  To solve this problem, use one of the options smoothing (smoothing).  In its simplest form, it is the addition of a unit to the frequency of occurrence of all n-grams, and in a more complicated form, the use of n-grams of a lower order in the absence of n-grams of a higher order. </p><br><p>  The most popular smoothing technique is <a href="http://u.cs.biu.ac.il/~yogo/courses/mt2013/papers/chen-goodman-99.pdf">Kneser ‚Äì Ney smoothing</a> .  However, it requires for each n-gram to store additional information, and the gain in comparison with more simple smoothing was not strong (at least in experiments with small models, up to 50 million n-grams).  For simplicity, as smoothing, we will consider the probability of each n-gram as the product of n-grams of all orders, for example, for trigrams: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/52b/115/dbd/52b115dbd27d97ba8f77826d4c5b3411.jpg" alt="formula3"></p><br><p>  Now that we have a language model, we will choose among candidates for correcting typos for which the language model will give the best grade based on the context.  In addition, we will add to the assessment a small penalty for changing the original word to avoid a large number of false positives.  Changing this penalty allows you to adjust the percentage of false positives: for example, you can leave the percentage of false positives higher in a text editor, and lower for automatic correction of texts. </p><br><h2 id="symspell">  Symspell </h2><br><p>  The next problem with the spellchecker Norvig is the low speed of work for cases when there are no candidates.  So, on a 15-letter word, the algorithm works for about a second, such performance is hardly enough for practical use.  One of the options for speeding up performance is <a href="http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/">the SymSpell algorithm</a> , which, according to the authors, works a million times faster.  SymSpell works as follows: for each word from the dictionary, deletions are added to a separate index, or rather, all words derived from the original by deleting one or more letters (usually 1 and 2), with reference to the original word.  At the time of searching for candidates for the word, similar deletions are made and their presence in the index is checked.  This algorithm correctly handles all cases of errors - replacement of letters, permutations, additions and deletions. </p><br><p>  For example, consider the replacement (in the example, we will consider only the distance 1).  Let the original dictionary contain the word " <strong>test</strong> ".  And we typed the word " <strong>temt</strong> ".  The index will contain all deletions of the word ‚Äú <strong>test</strong> ‚Äù, namely: <strong>eating</strong> , <strong>tst</strong> , <strong>tet</strong> , <strong>tes</strong> .  For the word ‚Äú <strong>tempt</strong> ‚Äù the deletions will be: <strong>emt</strong> , <strong>tmt</strong> , <strong>tet</strong> , <strong>emt</strong> .  The deletion of ‚Äú <strong>tet</strong> ‚Äù is contained in the index, which means that a word with a typo ‚Äú <strong>tempt</strong> ‚Äù corresponds to the word ‚Äú <strong>test</strong> ‚Äù. </p><br><h2 id="perfect-hash">  Perfect Hash </h2><br><p>  The next problem is memory consumption.  The model, trained on the text of two million sentences (one million from Wikipedia + one million from news texts) occupied 7 GB of RAM.  About half of this volume used the language model (n-grams with a frequency of occurrence) and the other half used the index for SymSpell.  With such memory consumption, application usage became not very practical. </p><br><p>  I didn‚Äôt want to reduce the size of the dictionary, as the quality began to subside markedly.  As it turned out, this is not a new problem.  Scientific articles offer different ways to solve the problem of memory consumption by the language model.  One of the interesting approaches (described in the article <a href="http://www.lrec-conf.org/proceedings/lrec2010/pdf/860_Paper.pdf">Efficient Minimal Perfect Hash Language Models</a> ) is to use <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash</a> (or rather, the <a href="http://cmph.sourceforge.net/chd.html">CHD</a> algorithm) to store information about n-grams.  Perfect hash is a hash that does not cause collisions on a fixed data set.  In the absence of collisions, there is no need to store keys, since there is no need to compare them.  As a result, it is possible to keep in memory an array equal to the number of n-grams in which to store their frequency of occurrence.  This gives a very strong saving of memory, since the n-grams themselves take up much more space than their frequency of occurrence. </p><br><p> But there is one problem.  When using the model, it will receive n-grams that have never been encountered in the training text.  As a result, perfect hash will return a hash of some other existing n-gram.  To solve this problem, the authors of the article for each n-gram suggest additionally storing another hash, by which it will be possible to compare whether the n-grams match or not.  If the hash is different - this n-gram does not exist and the frequency of occurrence should be considered zero. </p><br><p>  For example, we have three n-grams: n1, n2, n3, which met 10, 15, and 3 times, and also n-gram n4, which was not found in the source code: </p><br><table><tbody><tr><td></td><td>  n1 </td><td>  n2 </td><td>  n3 </td><td>  n4 </td></tr><tr><td>  Perfect Hash </td><td>  one </td><td>  0 </td><td>  2 </td><td>  one </td></tr><tr><td>  Second hash </td><td>  42 </td><td>  13 </td><td>  24 </td><td>  18 </td></tr><tr><td>  Frequency </td><td>  ten </td><td>  15 </td><td>  3 </td><td>  0 </td></tr></tbody></table><br><p>  We have got an array in which we store the frequencies of occurrence, as well as an additional hash.  Use the perfect-hash value as the array index: </p><br><table><tbody><tr><td>  15, 13 </td><td>  10, 42 </td><td>  3, 24 </td></tr></tbody></table><br><p>  Suppose we met n-gram n1.  Its perfect-hash is 1, and second-hash 42. We go to the array at index 1, and check the hash that is there.  It is the same, meaning the frequency of the n-gram 10. Now consider the n-gram n4.  Its perfect hash is also 1, but second hash is 18. This is different from the hash which is at index 1, which means the frequency of occurrence is 0. </p><br><p>  In practice, 16-bit CityHash was used as a hash.  Of course, the hash does not completely eliminate false positives, but reduces their frequency to one that is not reflected in the final quality metrics. </p><br><p>  The frequency of occurrence was also encoded more compactly, from 32-bit numbers to 16-bit, by non-linear <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25B8%25D0%25B3%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B2)">quantization</a> .  Small numbers corresponded as 1 to 1, larger ones as 1 to 2, 1 to 4, and so on. Quantization again did not affect the resulting metrics. </p><br><p>  Most likely, you can pack and hash, and the frequency of occurrence is even stronger - but this is in the next versions.  In the current version, the model shrank to 260 MB - more than 10 times, without any quality drawdown. </p><br><h2 id="bloom-filter">  Bloom filter </h2><br><p>  In addition to the language model, there was also an index from the SymSpell algorithm, which also occupied a lot of space.  He had to think a little longer, since there were no ready-made solutions for it.  In scientific articles about the compact representation of the language model, the <a href="https://habrahabr.ru/post/112069/">bloom filter was</a> often used.  It seemed that in this task he can help.  It was not possible to apply the bloom-filter to the forehead - for each word from the index with deletions we needed references to the original word, and the bloom filter does not allow storing values, only to check the fact of existence.  On the other hand, if the bloom filter says that such a deletion is in the index, we can restore the original word for it by performing inserts and checking them in the index.  The final adaptation of the SymSpell algorithm is as follows: </p><br><p>  We will store all deletions of words from the original dictionary in the bloom-filter.  When searching for candidates, we will first make deletions from the source word to the desired depth (similar to SymSpell).  But, unlike SymSpell, the next step for each deletion is to insert it, and check the resulting word in the original dictionary.  And the index with deletions stored in the bloom-filter will be used to skip inserts for those deletions that are missing in it.  In this case, the false alarms are not terrible for us - we will just do a little extra work. </p><br><p>  The performance of the resulting solution practically did not slow down, and the memory used was reduced very significantly - up to 140 MB (approximately 25 times).  As a result, the total memory size was reduced from 7 GB to 400 MB. </p><br><h2 id="rezultaty">  results </h2><br><p>  The table below shows the results for English text.  300K sentences from Wikipedia and 300K sentences from news texts were used for training (texts are taken <a href="http://wortschatz.uni-leipzig.de/en/download/">here</a> ).  The initial sample was divided into 2 parts, 95% was used for training, 5% for evaluation.  Results: </p><br><table><tbody><tr><td></td><td>  Errors </td><td>  Top 7 Errors </td><td>  Fix rate </td><td>  Top 7 Fix Rate </td><td>  Broken </td><td>  Speed <br>  (words per second) </td></tr><tr><td>  JamSpell </td><td>  3.25% </td><td>  1.27% </td><td>  79.53% </td><td>  84.10% </td><td>  0.64% </td><td>  1833 </td></tr><tr><td>  Norvig </td><td>  7.62% </td><td>  5.00% </td><td>  46.58% </td><td>  66.51% </td><td>  0.69% </td><td>  395 </td></tr><tr><td>  Hunspell </td><td>  13.10% </td><td>  10.33% </td><td>  47.52% </td><td>  68.56% </td><td>  7.14% </td><td>  163 </td></tr><tr><td>  Dummy </td><td>  13.14% </td><td>  13.14% </td><td>  0.00% </td><td>  0.00% </td><td>  0.00% </td><td>  - </td></tr></tbody></table><br><p>  JamSpell - the resulting spell checker.  Dummy - corrector that does nothing, is given in order to understand what percentage of errors in the source text.  <a href="http://norvig.com/spell-correct.html">Norvig</a> is Peter Norvig's spell checker.  <a href="https://github.com/hunspell/hunspell">Hunspell</a> is one of the most popular open-source spell checkers.  For the purity of the experiment - the same was checked on the artistic text.  Metrics on the text "The Adventures of Sherlock Holmes": </p><br><table><tbody><tr><td></td><td>  Errors </td><td>  Top 7 Errors </td><td>  Fix rate </td><td>  Top 7 Fix Rate </td><td>  Broken </td><td>  Speed <br>  (words per second) </td></tr><tr><td>  JamSpell </td><td>  3.56% </td><td>  1.27% </td><td>  72.03% </td><td>  79.73% </td><td>  0.50% </td><td>  1764 </td></tr><tr><td>  Norvig </td><td>  7.60% </td><td>  5.30% </td><td>  35.43% </td><td>  56.06% </td><td>  0.45% </td><td>  647 </td></tr><tr><td>  Hunspell </td><td>  9.36% </td><td>  6.44% </td><td>  39.61% </td><td>  65.77% </td><td>  2.95% </td><td>  284 </td></tr><tr><td>  Dummy </td><td>  11.16% </td><td>  11.16% </td><td>  0.00% </td><td>  0.00% </td><td>  0.00% </td><td>  - </td></tr></tbody></table><br><p>  JamSpell showed better quality and performance compared to Hunspell and Norvig spellcheckers in both tests, both in the case with one candidate and in the case with the best 7 candidates. </p><br><p>  The following table shows the metrics for different languages ‚Äã‚Äãand for the training sample of different sizes: </p><br><table><tbody><tr><td></td><td>  Errors </td><td>  Top 7 Errors </td><td>  Fix rate </td><td>  Top 7 Fix Rate </td><td>  Broken </td><td>  Speed </td><td>  Memory </td></tr><tr><td>  English <br>  (300k wikipedia + 300k news) </td><td>  3.25% </td><td>  1.27% </td><td>  79.53% </td><td>  84.10% </td><td>  0.64% </td><td>  1833 </td><td>  86.2 MB </td></tr><tr><td>  Russian <br>  (300k wikipedia + 300k news) </td><td>  4.69% </td><td>  1.57% </td><td>  76.77% </td><td>  82.13% </td><td>  1.07% </td><td>  1482 </td><td>  138.7 MB </td></tr><tr><td>  Russian <br>  (1M wikipedia + 1M news) </td><td>  3.76% </td><td>  1.22% </td><td>  80.56% </td><td>  85.47% </td><td>  0.71% </td><td>  1375 </td><td>  341.4 MB </td></tr><tr><td>  German <br>  (300k wikipedia + 300k news) </td><td>  5.50% </td><td>  2.02% </td><td>  70.76% </td><td>  75.33% </td><td>  1.08% </td><td>  1559 </td><td>  189.2 MB </td></tr><tr><td>  French <br>  (300k wikipedia + 300k news) </td><td>  3.32% </td><td>  1.26% </td><td>  76.56% </td><td>  81.25% </td><td>  0.76% </td><td>  1543 </td><td>  83.9 MB </td></tr></tbody></table><br><h2 id="itogi">  Results </h2><br><p>  The result was a high-quality and fast spell-checker, which surpasses similar open solutions.  Examples of use are text editors, instant messengers, preprocessing of dirty text in machine learning tasks, etc. </p><br><p>  Sources <a href="https://github.com/bakwc/JamSpell">are available on github</a> , under the MIT license.  The library is written in C ++, binders for other languages ‚Äã‚Äãare available via swig.  Example of use in python: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jamspell corrector = jamspell.TSpellCorrector() corrector.LoadLangModel(<span class="hljs-string"><span class="hljs-string">'model_en.bin'</span></span>) corrector.FixFragment(<span class="hljs-string"><span class="hljs-string">'I am the begt spell cherken!'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># u'I am the best spell checker!' corrector.GetCandidates(['i', 'am', 'the', 'begt', 'spell', 'cherken'], 3) # (u'best', u'beat', u'belt', u'bet', u'bent', ... ) corrector.GetCandidates(['i', 'am', 'the', 'begt', 'spell', 'cherken'], 5) # (u'checker', u'chicken', u'checked', u'wherein', u'coherent', ...)&lt;/td&gt;</span></span></code> </pre> <br><p>  Further improvements - improving the quality of the language model, reducing memory consumption, adding the ability to handle gluing and splitting words, support features of different languages.  If someone wants to participate in improving the library - I will be glad to your pull-requests. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  JamSpell sources: <a href="https://github.com/bakwc/JamSpell">github.com/bakwc/JamSpell</a> </li><li>  How to Write a Spelling Corrector, <em>Peter Norvig</em> : <a href="http://norvig.com/spell-correct.html">norvig.com/spell-correct.html</a> </li><li>  Hunspell: <a href="https://github.com/hunspell/hunspell">github.com/hunspell/hunspell</a> </li><li>  Language Modeling with N-grams, <em>Daniel Jurafsky &amp; James H. Martin</em> : <a href="https://web.stanford.edu/~jurafsky/slp3/4.pdf">web.stanford.edu/~jurafsky/slp3/4.pdf</a> </li><li>  Understanding LSTM Networks, <em>Christopher Olah</em> : <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">colah.github.io/posts/2015-08-Understanding-LSTMs/</a> </li><li>  N-GRAM LANGUAGE MODELING USING RECURRENT NEURAL NETWORK ESTIMATION, Google Tech Report, <em>Ciprian Chelba, Mohammad Norouzi, Samy Bengio</em> : <a href="https://static.googleusercontent.com/media/research.google.com/ru//pubs/archive/46183.pdf">static.googleusercontent.com/media/research.google.com/ru/pubs/archive/46183.pdf</a> </li><li>  <a href="http://u.cs.biu.ac.il/~yogo/courses/mt2013/papers/chen-goodman-99.pdf">Anonymous</a> <em>and Stanley F. Chen and Joshua Goodman</em> : <a href="http://u.cs.biu.ac.il/~yogo/courses/mt2013/papers/chen-goodman-99.pdf">u.cs.biu.ac.il/~yogo/courses/mt2013/papers/cs/courses/mt2013/papers/school/99-pod</a> </li><li>  1000x Faster Spelling Correction algorithm, <em>Wolf Garbe</em> : <a href="http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/">blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/</a> </li><li>  Efficient Minimal Perfect Hash Language Models, <em>David Guthrie, Mark Hepple, Wei Liu</em> : <a href="http://www.lrec-conf.org/proceedings/lrec2010/pdf/860_Paper.pdf">www.lrec-conf.org/proceedings/lrec2010/pdf/860_Paper.pdf</a> </li><li>  Perfect hash function, <em>wikipedia</em> : <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">en.wikipedia.org/wiki/Perfect_hash_function</a> </li><li>  Hash, displace, and compress.  <em>Djamal Belazzougui1, Fabiano C. Botelho, Martin Dietzfelbinger</em> : <a href="http://cmph.sourceforge.net/papers/esa09.pdf">cmph.sourceforge.net/papers/esa09.pdf</a> </li><li>  Bloom Filter, <em>habrahabr</em> : <a href="https://habrahabr.ru/post/112069/">habrahabr.ru/post/112069/</a> </li><li>  Leipzig Corpora Collection: <a href="http://wortschatz.uni-leipzig.de/en/download/">wortschatz.uni-leipzig.de/en/download/</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346618/">https://habr.com/ru/post/346618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346600/index.html">Unusual multiplication system</a></li>
<li><a href="../346604/index.html">The digest of interesting materials for the mobile developer # 236 (January 8 - January 14)</a></li>
<li><a href="../346606/index.html">Learned Telegram chat bot with AI in 30 lines of Python code</a></li>
<li><a href="../346608/index.html">We test user scripts with Hermione. Yandex lecture</a></li>
<li><a href="../346610/index.html">Reasoning around systems engineering and comments on "Richard Hamming: Chapter 28. Systems Engineering"</a></li>
<li><a href="../346622/index.html">Examination of internal FPGA defects: we are looking for a black cat in a dark room</a></li>
<li><a href="../346628/index.html">Spring Security interrogation query path</a></li>
<li><a href="../346630/index.html">Events, processes and services: a modern approach to automating business processes</a></li>
<li><a href="../346632/index.html">Parsim memes in python: how to bypass the server lock</a></li>
<li><a href="../346634/index.html">Lab: Introduction to Docker from scratch. Your first microservice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>