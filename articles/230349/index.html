<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Queue dissection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much time has passed since the previous post in the life of lock-free containers. I expected to quickly write a continuation of the treatise on queues...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Queue dissection</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fe5/e1d/6b9/fe5e1d6b9d857a50da2edbe8399f44b4.jpg" align="right"><br>  Much time has passed since the <a href="http://habrahabr.ru/company/ifree/blog/219201/">previous post</a> in the life of lock-free containers.  I expected to quickly write a continuation of the treatise on queues, but there was a hitch: what to write about, I knew, but I did not have a C ++ implementation.  ‚ÄúIt‚Äôs not good to write about what I didn‚Äôt try myself,‚Äù I thought, and as a result I tried to implement new queue algorithms in <a href="http://libcds.sourceforge.net/">libcds</a> . <br>  Now the moment has come when I can continue my cycle with arguments.  This article will finish with the queues. <br><br>  Let me briefly remind you of what I‚Äôve stopped at.  Several interesting lock-free queue algorithms were considered, and under the curtain the results of their work on some synthetic tests are presented.  The main conclusion - everything is bad!  The hope that the lock-free approach on the magic compare-and-swap (CAS) will give us, if not linear, but at least <i>some</i> increase in performance with an increase in the number of threads, did not materialize.  Queues do not scale.  What is the reason?.. <br><a name="habracut"></a><br>  The answer to this question lies in the features of the architecture of modern processors.  Primitive CAS is a rather heavy instruction, heavily loading the cache and the internal synchronization protocol.  With the active use of CAS over the same cache line, the processor is mainly busy supporting the coherence of the cache, as Professor Paul McKenney has already <a href="http://habrahabr.ru/company/ifree/blog/196548/">written</a> <s>with my help about</s> . <br><br>  Stacks and queues are very unfriendly for the lock-free approach of the data structure, since they have a small number of entry points.  For the stack, there is only one such point ‚Äî the top of the stack; for the queue, there are two of them ‚Äî the head and the tail.  CAS competes for access to these points, while performance drops at 100% processor load - all threads are busy with something, but only one will win and gain access to the head / tail.  Nothing like? .. It's a classic spin-lock!  It turns out that with the lock-free approach on CAS, we got rid of external synchronization with a mutex, but we got an internal one, at the level of the processor instruction, and won little. <br><div class="spoiler">  <b class="spoiler_title">Restricted Queues</b> <div class="spoiler_text">  It should be noted that all of the above applies to unlimited (unbounded) MPMC (multiple producer / multiple consumer) queues.  In limited (bounded) by the number of elements of queues, which are built, as a rule, on the basis of an array, this problem may not be so clearly expressed due to the accurate dispersion (scatter) of elements of the queue over the array.  Also, faster algorithms can be built for queues with one writer or / and one reader. <br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The problem of effective implementation of competitive queues interests researchers until now.  In recent years, the understanding that different tricks in the implementation of the lock-free queue "head on" does not give the expected result has increased, and some other approaches should be invented.  Next we look at some of them. <br><br><h2>  Flat combining </h2><br>  I already <a href="http://habrahabr.ru/company/ifree/blog/216013/">described</a> this method in the article about the stack, but flat combining is a universal method, therefore, it is applicable to the queue.  I refer readers to the video of my <a href="http://meetingcpp.ru/%3Fp%3D155">presentation</a> on <a href="http://meetingcpp.ru/">C ++ User Group, Russia</a> , dedicated to the implementation of flat combining. <br><div class="spoiler">  <b class="spoiler_title">As advertising</b> <div class="spoiler_text">  Taking this opportunity, I want to send rays of support to the <a href="https://habrahabr.ru/users/sermp/" class="user_link">sermp</a> - the mastermind and organizer of the C ++ User Group, Russia.  Sergey, your selfless work in this field is priceless! <br>  Readers urge to pay attention to this event and support it with your turnout, as well as who have something to share, presentations.  I learned from my own experience that live communication is much better than even reading Habr. <br>  I also draw your attention to the upcoming C ++ Russia <a href="http://meetingcpp.ru/%3Fpage_id%3D233">conference</a> on February 27-28, 2015 in Moscow, - come! <br></div></div><br><br><h2>  Array of queues </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/d48/ad6/be7d48ad62a56f0b87fba5e7e96df29e.jpg" align="right"><br>  An approach that lies on the surface, but nevertheless rather difficult to implement, with a lot of pitfalls, was proposed in 2013 in the <a href="https://repository.ist.ac.at/124/307/main-spaa2013.pdf">article</a> titled <i>‚ÄúReplacing competition with cooperation for the implementation of a scalable lock-free queue‚Äù</i> that best suits the topic of this post. . <br>  The idea is very simple.  Instead of one queue, an array of the size of K is built, each element of which is a lock-free queue represented by a simply linked list.  A new element is added to the next (modulo K) slot of the array.  Thereby, the crowds on the tail of the queue are leveled, - instead of one tail, we have K tails, so we can expect that we will obtain linear scalability up to K parallel streams.  Of course, we need to have a certain atomic monotonically increasing counter of push operations in order to multiplex each insert into its slot of the array.  Naturally, this counter will be a single ‚Äústicking point‚Äù for all push streams.  But the authors argue (according to my observations, not without reason) that the <code>xadd</code> instruction of atomic addition (in our case, increment) on the x86 architecture is slightly faster than CAS.  Thus, we can expect that on x86 we will get a win.  On other architectures, the atomic <code>fetch_add</code> emulated by CAS, so the gain will not be so noticeable. <br>  The code for removing an element from a queue is similar: there is an atomic counter for deleted elements (pop-counter), on the basis of which an array slot is selected modulo K.  To prevent violation of the main property of the queue - FIFO - each element contains an additional load ( <code>ticket</code> ) - the value of the push counter at the time of adding the element, in fact - the sequence number of the element.  When deleting a slot, an item with <code>ticket</code> = is searched for the current value of the pop-counter, the item found is the result of the <code>pop()</code> operation. <br>  An interesting way that solves the problem of removing from an empty queue.  In this algorithm, the atomic increment of the deletion counter (pop-counter) goes first, and then the search in the corresponding slot.  It may well be that the slot is empty.  This means that the whole queue is empty.  But the pop-counter is already incremented, and its further use will lead to violation of the FIFO and even to the loss of elements.  It is impossible to roll back (decrement) - all of a sudden, at the same time, other flows add or remove elements (in general, ‚Äúback-play-cannot be‚Äù is an essential feature of the lock-free approach).  Therefore, when a <code>pop()</code> situation arises from an empty queue, the array is declared invalid, which leads to the creation of a new array with new push and pop counters the next time the element is inserted. <br><br>  Unfortunately, the authors did not bother (as they write, due to lack of space) the problem of freeing memory, giving it only a few sentences with a superficial description of the application of the Hazard Pointer scheme to its algorithm.  I <s>have</s> not yet managed to decipher their hints, so there is no implementation of this interesting algorithm in the <code>libcds</code> library.  In addition, the algorithm is subject to unlimited accumulation of deleted items if the queue is never empty, that is, if the array is not invalidated, since it is not envisaged to delete items from the list-slot of the array.  <code>pop()</code> simply searches for an item with the current <code>ticket</code> in the corresponding slot, but does not physically exclude an item from the list until the entire array is invalidated. <br><br>  Summing up, we can say: the algorithm is interesting, but the memory management is not described clearly enough.  Additional study required. <br><br><h2>  Segmented Queues </h2><br>  Another way to increase the scalability of a queue is to break its main first-in property, first-out (FIFO).  Is it really scary, depends on the task: for some, strict compliance with the FIFO is mandatory, for others - within certain limits it is quite acceptable. <br>  Of course, absolutely no one wants to violate the basic FIFO property - in this case we will get a data structure called a pool, in which no order is observed at all: the <code>pop()</code> operation returns <i>any</i> element.  This is not a queue.  For a queue with a FIFO violation, I would like to have some guarantees of this violation, for example: the <code>pop()</code> operation will return one of the first K elements.  For K = 2, this means that for a queue with elements A, B, C, D, ... <code>pop()</code> returns A or B. Such queues are called <i>segmented</i> or <i>K-segmented</i> to emphasize the value of the factor K - the limit on the FIFO violation.  Obviously, for a strict (fair) FIFO queue, K = 1. <br>  As far as I know, for the first time the simplest segmented queue was considered in detail in 2010 in a <a href="http://mcg.cs.tau.ac.il/papers/opodis2010-quasi.pdf">paper</a> on just the allowable attenuation of requirements imposed on a lock-free data structure.  The internal structure of the queue is quite simple (image from the above article, K = 5): <br><img src="https://habrastorage.org/files/186/5f8/b47/1865f8b47e5f46cdb90534c5fc11f9c9.jpg"><br>  The queue is a single-linked list of segments, each segment is an array of K elements.  <code>Head</code> and <code>Tail</code> point to the first and last <i>segment</i> in the list, respectively.  The <code>push()</code> operation inserts a new element <i>into an arbitrary free</i> slot of the tail segment, the <code>pop()</code> operation extracts the element <i>from an arbitrary busy</i> head segment slot.  With this approach, it is obvious that the smaller the K segment size, the less is the FIFO property violated;  with K = 1 we get a strict queue.  Thus, by varying K, we can control the degree of FIFO violation. <br>  In the described algorithm, each slot of a segment can be in one of three states: free, busy (contains an element) and "garbage" (the element was read from the slot).  Note that the <code>pop()</code> operation <code>pop()</code> slot in the garbage state, which is <i>not</i> equivalent to the ‚Äúfree‚Äù state: the garbage state is the final slot state, writing the value to such a slot is invalid.  This demonstrates the lack of an algorithm ‚Äî a slot in the garbage state cannot be reused, which leads to the distribution of new segments even in such a typical sequence of operations for the queue, such as alternating <code>push() / pop()</code> .  This flaw was corrected in <a href="http://www.cosy.sbg.ac.at/research/tr/2012-04_Kirsch_Lippautz_Payer.pdf">another work</a> at the cost of a significant code complication. <br><br><h2>  Investigate </h2><br>  So, in libcds, there are implementations of two new algorithms for queues - FCQueue and SegmentedQueue.  Let's see their performance and try to understand whether it was worth doing them. <br>  Unfortunately, the server on which I drove the tests for the previous article was loaded with other tasks, and subsequently crashed.  I had to run tests on another server, less powerful - 2 x 12 core AMD Opteron 1.5GHz with 64G of memory running Linux, which was practically free - idle at 95%. <br><br>  I changed the visualization of the results - instead of the test time on the Y axis, I now postpone the number of mega-operations per second (Mop / s).  Let me remind you that the test is a classic producer / consumer: only 20 million operations - 10M push and 10M pop without any emulation of payload, that is, a dull swotting into a queue.  In all tests, lock-free queues are used by the Hazard Pointer to safely free up memory. <br><br><div class="spoiler">  <b class="spoiler_title">Old data in new parrots</b> <div class="spoiler_text">  The graph from the previous article in the new parrots - MOp / s, looks like this <br><img src="https://habrastorage.org/getpro/habr/post_images/ce5/168/e10/ce5168e1045ffc3ceb19cc9d67b83b8c.jpg"><br></div></div><br><br>  First, a digression: what are we striving for?  What do we want to get in terms of scalability? <br><br>  The ideal scaling is a linear increase in Mop / s with an increase in the number of streams, if the iron physically supports such a number of streams.  A really good result would be <i>some kind of</i> increase in Mop / s, more like a logarithmic one.  If, with an increase in the number of threads, we get a performance drop, the algorithm is non-scalable, or scalable to some limits. <br><br>  Results for intrusive queues (remember, an intrusive container is characterized by the fact that it contains a pointer to the data itself, and not their copy, as in STL; thus, it is not required to allocate memory for a copy of the elements, which is considered a move in the world of lock-free). <br><img src="https://habrastorage.org/files/2ea/528/6e9/2ea5286e975c45219852ee5606f60542.png"><br>  It can be seen that Flat Combining is not implemented in vain - this technique shows a very good result compared to other algorithms.  Yes, it does not increase productivity, but there is no significant subsidence either.  Moreover, a significant bonus is that it practically does not load the processor - only one core always works.  The remaining algorithms show 100% CPU usage with a large number of threads. <br>  The segmented queue shows itself as an outsider.  Perhaps this is due to the specifics of the implemented algorithm: memory allocation for segments (in this test, the segment size is 16), the inability to reuse segment slots, which leads to permanent allocations, the implementation of the list of segments based on boost :: intrusive :: slist under blocking (I tried two types of locks - spin-lock and std :: mutex; the results are almost the same). <br>  I had a hope that the main brake is false sharing.  In the implementation of a segmented queue, the segment was an array of pointers to elements.  When the segment size is 16, the segment occupies 16 * 8 = 128 bytes, that is, two cache lines.  With constant crush of flows on the first and last segments, false sharing can manifest itself in full growth.  Therefore, I entered an additional option in the algorithm - the required padding.  By specifying padding = cache line size (64 bytes), the segment size increases to 16 * 64 = 1024 bytes, but this way we exclude false sharing.  Unfortunately, it turned out that padding has almost no effect on the performance of the SegmentedQueue.  Perhaps the reason for this is that the cell search algorithm of a segment is probabilistic, which leads to many unsuccessful attempts to read occupied cells, that is, again, to false sharing.  Or, false sharing is not at all the main brake on this algorithm, and you need to look for the true reason. <br><br>  Despite the loss, there is one interesting observation: SegmentedQueue does not show a performance drop with an increase in the number of threads.  This gives hope that the algorithms of this class have some perspective.  You just need to implement them differently, more efficiently. <br><br>  For STL-like queues, with the creation of a copy of the element, we have a similar picture: <br><img src="https://habrastorage.org/files/439/f87/dc2/439f87dc2e2d420aa9687b6b0e9aa8f0.png"><br><br>  Finally, just for the sake of interest, I will give the result of a bounded queue - an array of Dmitry Vyukov, an intrusive implementation: <br><img src="https://habrastorage.org/files/a50/8cd/eda/a508cdedaa01487ba2e0024602b77b87.png"><br>  With the number of threads = 2 (one reader and one writer), this queue shows 32 MOPS / s, which did not fit on the chart.  With an increase in the number of threads, we also observe a degradation of performance.  As an excuse, it can be noted that for the Vyukov queue, false sharing can also be a very significant inhibiting factor, but the option, including padding along the cache line, is not yet in libcds for it. <br><br><div class="spoiler">  <b class="spoiler_title">for lovers of strange</b> <div class="spoiler_text">  I also got an unusual Linux server on IBM Power8 - two 3.42 GHz processors with ten cores in each, each core can simultaneously execute up to 8 instructions simultaneously, for a total of 160 logical processors.  Here are the results of the same tests on it. <br>  Intrusive turns: <br><img src="https://habrastorage.org/files/627/997/c50/627997c50551449cb902cb941e2a434e.png"><br>  STL-like queues: <br><img src="https://habrastorage.org/files/566/3ee/1af/5663ee1afb6b492696d0600ee9fcae17.png"><br>  As can be seen, no fundamental changes are observed.  But no, there is one thing - the results for the segmented queue are shown with the segment size K = 256 - this is exactly what K was for this server close to the best. <br></div></div><br><br>  In conclusion, I want to note one interesting observation.  In the above tests for readers and writers there is no payload (payload), our goal is just to stuff into the queue and read from it.  In real tasks, there is always some kind of load - we do something with the data read from the queue, and before we put in the queue, we prepare the data.  It would seem that payload should lead to a drop in performance, but practice shows that this is not always the case.  I have repeatedly observed that payload leads to a significant increase in MOp / s <s>parrots</s> .  The reason, as it seems to me, is the unloading of the internal cache synchronization protocol, see again P.McKenney article.  The conclusion suggests this: it is necessary to test on real problems. <br><br><img src="https://habrastorage.org/files/ba5/3d1/9b6/ba53d19b602341f1889fed2e5744a07c.png" align="left"><br>  In this article, I touched on a small part of the work on queues, and only dynamic (unbounded), that is, without limiting the number of elements.  As I said, the queue is one of the favorite data structures for researchers, apparently because it is difficult to scale.  There are many other works left overboard ‚Äî about bounded queues, work-stealing queues used in task schedulers, single consumer or single producer queues ‚Äî the algorithms of such queues are significantly sharpened per writer or reader, and therefore often easier / or much more productive, etc.  etc. <br><div class="spoiler">  <b class="spoiler_title">News from the microworld libcds</b> <div class="spoiler_text">  Since the previous article, version 1.6.0 of the library has been released, in which, in addition to the implementation of the Flat Combining and SegmentedQueue techniques, a certain number of errors have been fixed, and SkipList and EllenBinTree have been significantly reworked. <br>  The repository for the upcoming version 2.0 moved to <a href="http://github.com/khizmax/libcds">github</a> , and version 2.0 itself is devoted to the transition to the C ++ 11 standard, combing code, unifying interfaces, which will break the notorious backward compatibility (which means that some entities will be renamed) and remove crutches support of old compilers (well, and, as usual, fix found and generate new bugs). <br></div></div><br>  I am glad that I managed, despite the large time lag, to bring the story about queues and stacks to a logical end, because these are not the most friendly for the lock-free approach and modern data structure processors, and not very interesting for me . <br>  Much more interesting structures are waiting for us - associative containers (set / map), in particular, hash map, with beautiful algorithms and, I hope, more grateful in terms of scalability. <br>  Continuation, I think, will follow ... <br><br><div class="spoiler">  <b class="spoiler_title">Lock-free data structures</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br>  Basics: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/195948/">Atomicity and atomic primitives</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/196548/">Where did the memory barriers go from</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Memory model</a> </li></ul><br>  Inside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/202190/">Memory management circuits</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/216013/">Stack evolution</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/219201/">Another treatise</a> </li><li>  <a href="http://habrahabr.ru/post/230349/">Queue dissection</a> </li><li>  <a href="http://habrahabr.ru/post/250383/">Concurrent maps: warm up</a> </li><li>  <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li>  <a href="https://habrahabr.ru/post/251267/">Concurent maps: trees</a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li>  <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br>  Outside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/196834/">Introduction to libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/230349/">https://habr.com/ru/post/230349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230339/index.html">NSA employees are also having fun at work.</a></li>
<li><a href="../230341/index.html">Google has launched an API to monitor the data of its cloud services.</a></li>
<li><a href="../230343/index.html">Firmware Intel Integrated RAID Module RMS25JB080 in IT mode</a></li>
<li><a href="../230345/index.html">Browser Browser - empowering file sharing, as well as a way to survive pirated sites with anti-piracy laws</a></li>
<li><a href="../230347/index.html">How PolyITAN-1 was born in KPI laboratories</a></li>
<li><a href="../230351/index.html">Simple websocket chat on Dart</a></li>
<li><a href="../230353/index.html">Squeryl - simplicity and grace</a></li>
<li><a href="../230355/index.html">Measure temperature: TEMPer + Python + Windows</a></li>
<li><a href="../230357/index.html">Parallel non-parallel or search for prime numbers on the GPU</a></li>
<li><a href="../230359/index.html">SASM - IDE for assembler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>