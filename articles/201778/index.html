<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Profiling and debugging Python, go to practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we defined the concepts of profiling and optimization, got acquainted with different approaches to profiling and types of tools. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Profiling and debugging Python, go to practice</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/company/mailru/blog/201594/">last article,</a> we defined the concepts of profiling and optimization, got acquainted with different approaches to profiling and types of tools.  A little touched the history of profilers. <br><br>  Today, I propose to move to practice and show examples of manual profiling methods (and even the ‚Äúgaze method.‚Äù Tools for statistical profiling will also be considered. <br><a name="habracut"></a><br><ul><li>  <a href="http://habrahabr.ru/company/mailru/blog/201594/">Introduction and theory</a> - why do you need profiling, different approaches, tools and differences between them? </li><li>  <strong>Manual and statistical profiling</strong> - go to practice </li><li>  <a href="http://habrahabr.ru/company/mailru/blog/202832/">Event Profiling</a> - tools and their use </li><li>  <a href="http://habrahabr.ru/company/mailru/blog/205426/">Debugging</a> - what to do when nothing works </li></ul><br><h2>  Train </h2><br>  What can be practice without examples and training?  I have been thinking for a long time, which project should be taken as a textbook, so that it is both indicative and not very difficult.  In my opinion, this is <a href="http://projecteuler.net/">Project Euler</a> , a collection of mathematical and computer puzzles, since for solving the proposed problems it is necessary to apply numerical algorithms and, without optimization, the search for an answer can last for years. <br><br>  <i>In general, I strongly advise you to solve puzzles from the "Project Euler."</i>  <i>It helps to distract, meditate and relax, and at the same time keep your brain in good shape.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As an example for an article, take <a href="http://projecteuler.net/problem%3D3">task 3</a> : <br><blockquote>  The prime divisors of 13195 are 5, 7, 13, and 29. <br>  What is the biggest divisor of the number 600851475143, which is a prime number? </blockquote><br>  We write a simple solution "in the forehead": <br><pre><code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Project Euler problem 3 solve"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_prime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Checks if num is prime number"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, num): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_prime_factors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Find prime factors of num"""</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, num): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_prime(i) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: num = int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (TypeError, ValueError, IndexError): sys.exit(<span class="hljs-string"><span class="hljs-string">"Usage: euler_3.py number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>: sys.exit(<span class="hljs-string"><span class="hljs-string">"Error: number must be greater than zero"</span></span>) prime_factors = find_prime_factors(num) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(prime_factors) == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Can't find prime factors of %d"</span></span> % num) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Answer: %d"</span></span> % prime_factors[<span class="hljs-number"><span class="hljs-number">-1</span></span>])</code> </pre> <br>  <i>An attentive or experienced reader will probably immediately call me a noob, call a few problems of this program and give a few recipes for its optimization, but we specifically took a simple example and pretend that we consider this code good, optimizing it in the course of action.</i> <br><br>  To check, run the program with a number, the divisors of which are known to us: <br><br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 13195 <br>  Answer: 29 </blockquote><br>  Answer 29, issued by the program is correct (it can be found in the statement of the problem).  Hooray!  Now we run the program with the number 600851475143 we are interested in: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 600851475143 </blockquote><br>  And ... nothing happens.  CPU utilization is 100%, program execution has not completed even after several hours of operation.  We start to understand.  We recall that you can only optimize the code that works correctly, but we checked the program on a small number and the answer was correct.  Obviously, there is a performance problem and we need to start optimizing. <br><br><h2>  Gaze method </h2><br>  In real life, I would profile the program with an argument of 13195 (when its work time is adequate).  But since we are training here and in general, just for jun, we will use the ‚Äúgaze method.‚Äù <br><br>  Open the code and carefully look at it.  We understand (if we‚Äôre lucky, we understand quickly) that to search for divisors of the number <strong>N</strong> we don‚Äôt make sense to go through numbers from the interval <strong>sqrt (N) + 1 ... N-1</strong> , since  we already found all dividers from this range when searching numbers from interval <strong>2 ... sqrt (N)</strong> .  Slightly modify the code (see lines 9 and 18): <br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Project Euler problem 3 solve"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_prime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Checks if num is prime number"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, int(math.sqrt(num)) + <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_prime_factors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Find prime factors of num"""</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(math.sqrt(num)) + <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_prime(i) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_prime(num): result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: num = int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (TypeError, ValueError, IndexError): sys.exit(<span class="hljs-string"><span class="hljs-string">"Usage: euler_3.py number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>: sys.exit(<span class="hljs-string"><span class="hljs-string">"Error: number must be greater than zero"</span></span>) prime_factors = find_prime_factors(num) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(prime_factors) == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Can't find prime factors of %d"</span></span> % num) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Answer: %d"</span></span> % prime_factors[<span class="hljs-number"><span class="hljs-number">-1</span></span>])</code> </pre> <br>  To check again run the program with a number, the dividers of which we know: <br><br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 13195 <br>  Answer: 29 </blockquote><br>  Subjectively, the program worked much faster, so we start it again with the number 600851475143 we are interested in: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 600851475143 <br>  Answer: 6857 </blockquote><br>  We check the answer on the site, it turns out to be true, the problem is solved, we feel moral satisfaction. <br><br>  The program was executed in an acceptable time (less than a minute), the answer is correct, there is no point in further optimization in this particular case, since  We solved the task.  As we remember, the most important thing in optimization is to be able to stop on time. <br><br>  <i>Yes, I am aware that the guys from Project Euler are asked not to post answers and solutions to the public.</i>  <i>But the answer to task 3 is googling (for example, by the condition of ‚Äúproject euler problem 3 answer‚Äù at a time, so I think that there‚Äôs nothing wrong with the fact that I wrote the answer no.</i> <br><br><h2>  Manual profiling </h2><br>  One of the most common ways to quickly estimate "what's what."  In the most elementary case, if we use the unix-utility ‚Äútime‚Äù it looks like this (before optimization): <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> time python euler_3.py 13195 <br>  Answer: 29 <br>  python euler_3.py 13195 3.83s user 0.03s system 99% cpu 3.877 total </blockquote><br>  And so (after optimization): <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> time python euler_3.py 13195 <br>  Answer: 29 <br>  python euler_3.py 13195 0.03s user 0.02s system 90% cpu 0.061 total </blockquote><br>  Acceleration almost 65 times (from ~ 3.87 seconds to ~ 61 milliseconds)! <br><br>  Also manual profiling may look like this: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ... start = time.time() prime_factors = find_prime_factors(num) print(<span class="hljs-string"><span class="hljs-string">"Time: %.03f s"</span></span> % (time.time() - start))</code> </pre> <br>  Result: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 600851475143 <br>  Answer: 6857 <br>  Time: 19.811 s </blockquote><br>  Or using a special module " <a href="http://docs.python.org/2/library/timeit.html">timeit</a> ", which is designed to measure the speed of small programs.  Application example: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python -m timeit -n 10 -s'import euler_3 '' euler_3.find_prime_factors (600851475143) ' <br>  10 loops, best of 3: 21.3 sec per loop </blockquote><br>  When can manual profiling be used?  First of all, this is a great way to conduct various kinds of competitions between developers (‚ÄúMy code is now faster than yours, so I‚Äôm <i>a better</i> programmer!‚Äù), And that‚Äôs good.  Secondly, when it is required to ‚Äúby eye‚Äù determine the program speed (20 seconds? Long!) Or get the results of the improvements achieved (accelerated the code 100 times!). <br><br>  But the most important application is to collect statistics on the execution time of a code almost in real time right on production.  For this, the measured time is sent to any system for collecting metrics and drawing graphs (I really like to use <a href="http://graphite.wikidot.com/">Graphite</a> and <a href="https://github.com/etsy/statsd/">StatsD</a> as an aggregator for graphite). <br><br>  To do this, you can use a simple context manager: <br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Collect profiling statistic into graphite"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time CARBON_SERVER = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> CARBON_PORT = <span class="hljs-number"><span class="hljs-number">2003</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stats</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Context manager for send stats to graphite"""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name)</span></span></span><span class="hljs-function">:</span></span> self.name = name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.start = time.time() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__exit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> duration = (time.time() - self.start) * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment"># msec message = '%s %d %d\n' % (self.name, duration, time.time()) sock = socket.socket() sock.connect((CARBON_SERVER, CARBON_PORT)) sock.sendall(message) sock.close()</span></span></code> </pre> <br>  An example of its use: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> python_profiling.context_managers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Stats ... <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Stats(<span class="hljs-string"><span class="hljs-string">'project.application.some_action'</span></span>): do_some_action()</code> </pre> <br>  Or a simple decorator: <br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Collect profiling statistic into graphite"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time CARBON_SERVER = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> CARBON_PORT = <span class="hljs-number"><span class="hljs-number">2003</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Decorator for send stats to graphite"""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_timing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> start = time.time() result = func(*args, **kwargs) duration = (time.time() - start) * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment"># msec message = '%s %d %d\n' % (name, duration, time.time()) sock = socket.socket() sock.connect((CARBON_SERVER, CARBON_PORT)) sock.sendall(message) sock.close() return result return _wrapper return _timing</span></span></code> </pre> <br>  An example of using a decorator: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> python_profiling.decorators <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> stats ... @stats(<span class="hljs-string"><span class="hljs-string">'project.application.some_action'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_some_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Doing some useful action"""</span></span></code> </pre> <br>  At the output we get a timeline for the execution of the code section of interest, for example, this: <br><img src="http://habrastorage.org/storage3/dca/265/995/dca265995d1f8aa25ba2c7214394d5a1.png"><br>  which always shows how the code feels on live servers, and whether it is time to optimize it.  You can see how the code feels after the next release.  If refactoring or optimization was carried out, the schedule allows you to assess the results in a timely manner and to understand whether the overall situation has improved or deteriorated. <br><br>  There are drawbacks to the method, and the most important of them is the lack of dependence on the input data.  Thus, for the function of determining the prime number ‚Äúis_prime‚Äù, the execution time will strongly depend on the magnitude of this number, and if this function is called in the project very often, the schedule will be completely meaningless.  It is important to clearly understand where what approach can be used and what we have at the output. <br><br>  <i>Of course, you can call the method of profiling through the collection of metrics in graphite "statistical", because we collect the statistics of the program.</i>  <i>But I propose to adhere to the terminology adopted by us in the first part and by ‚Äústatistical‚Äù profiling to understand precisely the collection of information (sampling) at certain intervals of time.</i> <br><br><h3>  Django statsd </h3><br>  In the case of using graphite and an aggregating server ( <a href="https://github.com/andymckay/django-statsd">StatsD</a> ) for it, for one metric we get several graphs at once: the minimum and maximum code execution time, as well as the median and the number of recorded readings (function calls) per unit of time, which is very convenient.  Let's see how easy it is to connect StatsD to Django. <br><br>  We put the module: <br><blockquote>  <font color="#444444">‚ûú</font> pip install django-statsd-mozilla </blockquote><br>  Add settings in settings.py: application and middleware: <br><pre> <code class="python hljs">INSTALLED_APPS += (<span class="hljs-string"><span class="hljs-string">'django_statsd'</span></span>,) MIDDLEWARE_CLASSES += ( <span class="hljs-string"><span class="hljs-string">'django_statsd.middleware.GraphiteRequestTimingMiddleware'</span></span>, <span class="hljs-string"><span class="hljs-string">'django_statsd.middleware.GraphiteMiddleware'</span></span>, ) <span class="hljs-comment"><span class="hljs-comment"># send DB timings STATSD_PATCHES = ['django_statsd.patches.db']</span></span></code> </pre> <br>  And that's it!  At the output, we get the following graphics: <br><img src="http://habrastorage.org/storage3/955/244/faa/955244faa9f37cc5762eea8f18d6df2b.png"><br><br>  Pros and cons of StatsD: <br>  + easy to install and use <br>  + suitable for production (must-have, in general) <br>  - little information (number / time) <br>  - I need graphite and statsd (must-have too) <br><br><h2>  Statistical profilers </h2><br>  Unlike event profilers, there are few tools for statistical profiling.  I will tell about three: <br><ul><li>  <a href="https://github.com/bos/statprof.py">StatProf</a> and <a href="https://github.com/InviteBox/django-live-profiler">django-live-profiler</a> </li><li>  <a href="https://github.com/bdarnell/plop">Plop</a> and <a href="https://github.com/BrianHicks/django-plop">django-plop</a> </li><li>  <a href="http://newrelic.com/">New relic</a> </li></ul><br><br><h3>  StatProf </h3><br>  Perhaps the most famous statistical profiler under the python is <a href="https://github.com/bos/statprof.py">statprof</a> .  We put: <br><blockquote>  <font color="#444444">‚ûú</font> pip install statprof </blockquote><br>  We use, for example.  So: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> statprof ... statprof.start() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: do_some_action() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: statprof.stop() statprof.display()</code> </pre> <br>  Or as a context manager (not in version 0.1.2 of pypi, only in the version from the <a href="https://github.com/bos/statprof.py">repository</a> ): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> statprof ... <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> statprof.profile(): do_some_action()</code> </pre> <br>  Let's try to profile our code: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 600851475143 <br>  % cumulative self <br>  time seconds seconds name <br>  44.42 8.63 8.63 euler_3.py:12:is_prime <br>  37.12 7.21 7.21 euler_3.py:11:is_prime <br>  16.90 19.40 3.28 euler_3.py:21:find_prime_factors <br>  0.95 0.18 0.18 euler_3.py:9:is_prime <br>  0.48 0.09 0.09 euler_3.py:13:is_prime <br>  0.06 0.01 0.01 euler_3.py:14:is_prime <br>  0.06 0.01 0.01 euler_3.py:20:find_prime_factors <br>  0.03 0.01 0.01 euler_3.py:23:find_prime_factors <br>  0.00 19.42 0.00 euler_3.py:37: &lt;module&gt; <br>  - Sample count: 3575 <br>  Total time: 19.420000 seconds <br>  Answer: 6857 </blockquote><br>  We see two "hotspot" in our program.  The first: lines 12 and 11 of the ‚Äúis_prime‚Äù function (which is logical), their execution takes about 82% of the program‚Äôs time, and the second: line 21 of the ‚Äúfind_prime_factors‚Äù functions (about 17% of the time): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_prime(i) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i:</code> </pre> <br>  It is from this line that the ‚Äúhottest‚Äù function of the ‚Äúis_prime‚Äù program is called.  Simply swapping the operands in the condition, we will significantly speed up the program, since  the operation of obtaining the remainder of division (num% i) is performed faster than the ‚Äúis_prime‚Äù function, and at the same time, quite often the remainder of dividing one number by another is not zero, and ‚Äúnot num% i‚Äù returns False.  Thus, we will drastically reduce the number of calls to the is_prime function: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> num % i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_prime(i):</code> </pre> <br>  We start profiling: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python euler_3.py 600851475143 <br>  % cumulative self <br>  time seconds seconds name <br>  87.50 0.22 0.22 euler_3.py:21:find_prime_factors <br>  5.00 0.01 0.01 euler_3.py:20:find_prime_factors <br>  5.00 0.01 0.01 euler_3.py:11:is_prime <br>  2.50 0.01 0.01 euler_3.py:23:find_prime_factors <br>  0.00 0.25 0.00 euler_3.py:37: &lt;module&gt; <br>  - Sample count: 40 <br>  Total time: 0.250000 seconds <br>  Answer: 6857 </blockquote><br>  The hottest place in our program is now line 21 of the ‚Äúfind_prime_factors‚Äù function, that is, the operation of obtaining the remainder of division (‚Äúnum% i‚Äù).  The ‚Äúis_prime‚Äù function is now called much less frequently and runs only 5% of the time the program is running.  The time of the program has decreased significantly and the largest prime divisor of the number 600851475143 is now just 0.25 seconds (accelerated the program almost 80 times). <br><br>  Note how much the accuracy of the profiler operation fell: instead of 3575 samples (in the example before optimization) only 40 measurements were made and information was obtained about only five lines.  Of course, this is not enough.  Actually, this is a feature of statistical profilers: the more time we collect data, the more accurate the analysis.  If we, for example, started the program ten or a hundred times, we would get much more accurate results. <br><br><div class="spoiler">  <b class="spoiler_title">Here I must make a small lyrical digression.</b> <div class="spoiler_text">  99% of all auxiliary utilities, such as profilers or code <a href="https://bitbucket.org/ned/coveragepy">coverage</a> analysis tools, work with strings as the minimum unit of information.  Thus, if we try to write the code as compactly as possible, like this: <br><pre> <code class="python hljs">result = foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> baz()</code> </pre> <br>  we cannot see in the profiler which function was called and which one was not.  And in the coverage report, we will not see if a particular scenario is covered with tests.  Despite the more familiar and seemingly convenient code, in some cases it is still better to write this: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar: result = foo() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = baz()</code> </pre> <br>  and then we will immediately see which lines are not executed, and which lines are executed (and how often).  One-liners and compactness are, of course, nice and fun, but sometimes it is better to spend more time and get code that is easier to profile, test and maintain. <br></div></div><br><br>  The pros and cons of statprof: <br>  + minimal overhead projector <br>  + simple use <br>  - implementation is quite raw and experimental <br>  - Adequate analysis is needed for an adequate result. <br>  - little output data <br><br><h3>  Django-live-profiler </h3><br>  A separate point is worth noting <a href="https://github.com/InviteBox/django-live-profiler">django-live-profiler</a> - profiler application Django, using statprof.  For it to work, you must first install <a href="http://zeromq.org/">zeromq</a> : <br><blockquote>  <font color="#444444">‚ûú</font> brew install zmq </blockquote><br>  We put the module itself: <br><blockquote>  <font color="#444444">‚ûú</font> pip install django-live-profiler </blockquote><br>  And run the aggregator: <br><blockquote>  <font color="#444444">‚ûú</font> aggregated --host 127.0.0.1 --port 5556 </blockquote><br>  Next, add the profiler in settings.py: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  application INSTALLED_APPS += ('profiler',) #  middleware MIDDLEWARE_CLASSES += ( 'profiler.middleware.ProfilerMiddleware', 'profiler.middleware.StatProfMiddleware', )</span></span></code> </pre> <br>  And in urls.py: <br><pre> <code class="python hljs">url(<span class="hljs-string"><span class="hljs-string">r'^profiler/'</span></span>, include(<span class="hljs-string"><span class="hljs-string">'profiler.urls'</span></span>))</code> </pre> <br>  We start the server: <br><blockquote>  <font color="#444444">‚ûú</font> python manage.py runserver --noreload --nothreading </blockquote><br>  Open the profiler in the browser: <u><a href="http://127.0.0.1/">127.0.0.1</a> : 8000 / profiler /</u> and enjoy life, watching the results of profiling a live project in real time: <br><img src="http://habrastorage.org/storage3/a17/06a/549/a1706a5496f065765656c3d971747c99.png"><br><br>  And django-live-profiler can show SQL queries: <br><img src="http://habrastorage.org/storage3/992/fd2/8bf/992fd28bfca5285d91063ad8b64de09c.png"><br><br>  Advantages and disadvantages of django-live-profiler: <br>  + small overhead <br>  + you can start in production (very carefully) <br>  + SQL query profiling <br>  - complex installation, dependencies <br>  - little output data <br><br><h3>  Plop </h3><br>  Another statistical profiler is called <a href="https://github.com/bdarnell/plop">plop</a> (Python Low-Overhead Profiler).  The author immediately warns that the implementation of the raw and the project is under active development.  Installation is trivial: <br><blockquote>  <font color="#444444">‚ûú</font> pip install plop tornado </blockquote><br>  We start profiling: <br><blockquote>  <font color="#4e7a27">rudnyh</font> <font color="#444444">@</font> <font color="#C4BC36">work</font> <font color="#444444">: ~ / work / python-profiling (venv:</font> <font color="#2D6E8F">python-profiling</font> <font color="#444444">)</font> <br>  <font color="#444444">‚ûú</font> python -m plop.collector euler_3.py 600851475143 <br>  Answer: 6857 <br>  profile output saved to /tmp/plop.out <br>  overhead was 5.89810884916e-05 per sample (0.00589810884916%) </blockquote><br>  Start the server to view the results: <br><blockquote>  <font color="#444444">‚ûú</font> python -m plop.viewer --datadir = / tmp / </blockquote><br>  Open the page <a href="http://localhost:8888/">http: // localhost: 8888 / in the</a> browser and admire the results: <br><img src="http://habrastorage.org/storage3/096/d1e/a52/096d1ea528d25ff539db1123108d42c7.png"><br>  Plop can be used to profile Django applications.  To do this, install the django-plop package: <br><blockquote>  <font color="#444444">‚ûú</font> pip install django-plop </blockquote><br>  Add a settings.py middleware and a parameter that tells the profiler where to put the results: <br><pre> <code class="python hljs">MIDDLEWARE_CLASSES += ( <span class="hljs-string"><span class="hljs-string">'django-plop.middleware.PlopMiddleware'</span></span>, ) PLOP_DIR = os.path.join(PROJECT_ROOT, <span class="hljs-string"><span class="hljs-string">'plop'</span></span>)</code> </pre> <br>  In a large project, the graph will look more impressive: <br><img src="http://habrastorage.org/storage3/beb/36e/543/beb36e54397fa98c12a2c08586ad868a.jpg"><br>  The picture is quite psychedelic, it is difficult to call it a serious profiling tool, but nevertheless we have a call graph, the hottest parts of the code can be seen, the overhead is minimal (according to the authors only 2%), and in some cases this tool is enough to detect areas code needing profiling.  <a href="https://www.dropbox.com/">Dropbox</a> uses plop right in production, and that says a lot. <br><br>  Advantages and disadvantages of plop: <br>  + minimal overhead projector <br>  + can be started in production <br>  - complex installation, dependencies <br>  - very little output data <br><br><h3>  New relic </h3><br>  Speaking of statistical profilers, it is impossible not to say about the <a href="http://newrelic.com/">New Relic</a> service, which is intended not only for profiling, but also for monitoring servers and web applications (as well as mobile versions).  Those interested can see all the information on the company's website, as well as try the service for free.  I will not talk about him because I personally have not tried working with New Relic, and I used to talk only about those things that I tried myself.  You can see screenshots on the <a href="http://newrelic.com/thread-profiler">page</a> dedicated to the profiler. <br><br>  Advantages and disadvantages: <br>  + intended for production <br>  + many different functional (not only profiling) <br>  - paid (there is a free version) <br>  - data is sent to other servers <br><br>  In the <a href="http://habrahabr.ru/company/mailru/blog/202832/">next article,</a> we turn to the study of event profilers - the main tools for profiling Python.  Stay in touch! </div><p>Source: <a href="https://habr.com/ru/post/201778/">https://habr.com/ru/post/201778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201762/index.html">Why is the future behind remote work (part 1)</a></li>
<li><a href="../201768/index.html">ASLR bypass methods in the newest Zero-Day exploits</a></li>
<li><a href="../201772/index.html">Whiteboarding (write code on the board for interviews)</a></li>
<li><a href="../201774/index.html">Papa Carlo and incremental compilers</a></li>
<li><a href="../201776/index.html">Overflow effect in CorelDRAW</a></li>
<li><a href="../201782/index.html">Ways to combat bookmarks in compilers</a></li>
<li><a href="../201784/index.html">An example of using WxPython to create a node interface. Part 4: Implementing Drag & Drop</a></li>
<li><a href="../201788/index.html">Parado Monty Hall and Excel</a></li>
<li><a href="../201790/index.html">Galaxy Map on Three.js / WebGL</a></li>
<li><a href="../201792/index.html">Hyper-V 2012 Failover Cluster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>