<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the computer itself improved its code, or we program the programming process.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On the nose was inventing a topic for a diploma, the department was popular with various versions of ideas related to genetic algorithms, but I myself...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the computer itself improved its code, or we program the programming process.</h1><div class="post__text post__text-html js-mediator-article"> On the nose was inventing a topic for a diploma, the department was popular with various versions of ideas related to genetic algorithms, but I myself wanted to do something like that.  And so the idea was born that gave rise to this project, namely the genetic optimizer of the program code. <br><br><img src="https://habrastorage.org/files/644/992/0ba/6449920ba4474c458b1b1525baf26c32.GIF"><br><br>  The goal was quite ambitious - ideally, to make such a thing, which the program receives at the entrance, and then it turns it this way and that and tries to speed up its individual fragments in every possible way without human intervention, simultaneously gathering the basis for subsequent optimizations.  I‚Äôll say right away that although on the whole the task was solved, I couldn‚Äôt extract any practical benefits from it.  However, some of the results obtained in the process seemed to me interesting enough to share. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, there is such a funny optimization of a set of arithmetic instructions (taken from some mathematical library that has come to hand) corresponding to the formulas: <img src="https://habrastorage.org/files/ace/19a/a3b/ace19aa3b2154f44958046c370a8bac6.gif">  which gave me about 10% of acceleration on java with JIT turned off, at the same time, at first glance it‚Äôs not even obvious that these formulas are equivalent (WHERE IS HERE OR? THIS IS ALWAYS LEGAL!), although it is.  Under the cut, I'll tell you exactly how such results were obtained and how the computer came up with a better code than the one that I myself could write. <br><a name="habracut"></a><br>  I decided not to do anyhow what optimization, but the so-called ‚Äúlocal‚Äù or peephole optimization.  As a rule, this is the last stage through which modern optimizing compilers run programs, and in fact it is very simple - they search for given small linear sequences of instructions and change them to others that are optimal from their point of view.  That is, here is some notorious replacement <i>mov eax, 0</i> to <i>xor eax eax</i> - this is precisely the local optimization.  The most interesting thing here is exactly how these replacement rules are constructed.  They can be made by hand by specially trained and verbose assembler people, or searched by enumeration of instruction sets.  Obviously, the first option is quite expensive (specially trained people will certainly want a lot of money) and ineffective (well, how many such sets can a person come up with and think of?), And the second is long, especially if you try to sort out long sequences. <br><br>  This is where genetic algorithms come on the scene, which significantly reduces the search process. <br><br>  About the genetic algorithms themselves, I will not tell here, I hope everyone at least in general terms represents what it is, and who does not represent - there are enough articles on this topic on Habr√©, for example, <a href="http://habrahabr.ru/post/200454/">here</a> .  I‚Äôll dwell only on how I applied them. <br><br>  It is quite obvious that individuals in our case are code fragments, crossover operators and mutations must somehow modify the instructions included in them, and the fitness function selects the fastest options (since we‚Äôll optimize the speed of execution).  But how exactly this crossing should work? <br><br>  <b>Crossing and mutation of code fragments</b> <br><br>  From the idea to change arbitrary fragments, I refused very quickly.  In this case, the probability of receiving an invalid code is very high, one that simply cannot be run.  I chose JVM as my target architecture (because of the simplicity of both the bytecode itself and the means of manipulating it, although later I realized that it was not the most successful solution), but it has a fairly strict validator that simply will not allow the curve code to load. (eg causing stack emptying).  Accordingly, the value of the fitness function for him to count will not work. <br><br>  Therefore it was necessary to build a rather complicated system, almost a sort of mini-emulator JVM.  For each instruction and each sequence, the initial and final states were determined.  Specific values ‚Äã‚Äãwere not calculated, only the types of operands were determined.  That is, it was always possible to tell how many values ‚Äã‚Äãand which types were removed and put on the stack as a result of executing an arbitrary code fragment.  Then, on the basis of this information, there was another set that could be replaced with this (in the case of mutation, it was created randomly, in the case of crossing, it was searched for in the second specimen), in order to preserve the correctness of the code, it had to be equivalent in terms of handling the state of the JVM ‚Äî that is, removing from the stack and put back exactly the same number and types of values. <br>  This does not apply to intermediate computations, that is, a fragment inside itself can do anything with the stack, but it should leave exactly the same state behind it. <br><br>  Example: <br><br><img src="https://habrastorage.org/files/f58/f4b/9d7/f58f4b9d79ac40e18a20710b1334ecfa.png"><br><br>  The initial generation was created according to the same rules - it had to change the state of the JVM in the same way as the original sequence of instructions.  Thus, the correctness of individuals and their comparability were always maintained: since all individuals after their work always left the same state (values ‚Äã‚Äãof the same types on the stack in the same order), it was easy to compare the similarity of the obtained results with the reference ones: it was enough just to count the difference of two multidimensional vectors in which each value is a single register or a stack element (I occasionally use both Javas and non-Javas terminology here since, in principle, the algorithm is applicable to any  bomu mind of the computer, and I myself checked it for several purposes). <br><br>  <b>Fitness function</b> <br><br>  What do we need from our individuals?  And we need them to firstly consider the same results, and secondly - to do it faster than the original.  And to check this - we need to run them. <br>  We already have counted VM states at every step of the execution of our individuals.  In particular, this gives us the necessary set of input data - that is, what registers must be filled and how many and what elements should be put on the stack so that everything works as it should.  Well, we add the same code to the beginning of each individual, which will create this data, and by the end - which will record the results where we need it.  The final value of the fitness function is made up of the distance between the result vectors and the acceleration factor compared to the original. <br><br>  In the course of the research, it turned out that the ‚Äúfrontal‚Äù implementation leads to a rapid degeneration of the population, which is clogged with very short (and very fast) individuals that do not do anything useful (that is, instead of computing, for example, they simply empty the stack to the desired depth). gain due to length and speed.  Therefore, we had to make it so that the speed starts to be taken into account only after the calculated results become sufficiently close to the reference ones. <br><br>  In addition to the speed of work and equivalence of results, it was necessary to additionally control the length of individuals.  Without such control in the population, the growth of the average length of an individual, up to 10‚Äì20 lengths of the initial code fragment, begins fairly quickly (approximately 50 generations).  The appearance of such long individuals greatly slows down the genetic process, because, firstly, the code analysis time required for validation checks increases (the time of each iteration increases), and secondly, to obtain a solution, it is necessary to get rid of a large number of unnecessary instructions in the individual, which can take a significant number of generations (the total number of iterations is growing). <br>  Since this work examines the optimization of execution speed, and not the size of the instruction set, the length ratio is used only for screening out too long candidates and applies to the formula only if the individual for which the fitness function is calculated is longer than the original one. <br><br>  The final form of the fitness function: <br><img src="https://habrastorage.org/files/104/dc2/ec0/104dc2ec0e694bd5a25278fd1f633042.gif"><br><br>  Here <i>Xc</i> is the tested individual, <i>Xo</i> is the original fragment, <i>diff</i> is the difference of the results vectors, <i>len</i> is the ratio is long, <i>speedup</i> is the ratio of the runtime. <br><br>  <i>A speedup is</i> equal to one if <i>diff is</i> greater than a certain constant, that is, the speed starts to be taken into account only for an individual that considers almost correct values. <br><br>  It is easy to verify that this function has the following properties: <br><ul><li>  It is close to zero for initial random code fragments (the difference is large) </li><li>  It approaches unity as the calculated results converge with the reference ones. </li><li>  It is equal to one for the original fragment. </li><li>  All options with a fitness function of a larger unit are the potential results of the work of our algorithm, these are individuals who believe that it is necessary and at the same time faster / shorter </li></ul><br><br>  <b>Verification</b> <br><br>  In the course of the algorithm, each individual was tested for compliance with the results by giving the original fragment in several dozen test examples.  This is a quick and fairly effective test, but it is clearly insufficient for rigorous proof of the equivalence of the resulting optimized sequence and the original one.  To obtain such evidence, formal verification was used. <br><br><img src="https://habrastorage.org/files/211/fa1/f7f/211fa1f7f88141d8adf6930b378f1223.png"><br><br>  For this, for the verified and initial individuals, all their operations were represented in symbolic form, that is, after running through a special emulator, in each register / cell of the stack lay a symbolic representation of the formula calculated and written into it.  Then all these formulas were compared using the Z3 SMT expression solver.  Such a solver is able to prove that there is no set of input parameters on which the two formulas to be tested will give different results.  If such a set exists, it will be built and presented. <br><br>  Since this verification is quite a long process (it could take tens of minutes for one individual and a couple of simple mathematical expressions) only candidates for the final decision, that is, individuals with a fitness function greater than 1, were subjected to it. <br><br>  However, it should be noted that in the course of the research, not a single candidate met, who would calculate everything correctly on test datasets but would be eliminated at the verification stage. <br><br>  <b>Examples</b> <br><br>  Genetic algorithms, like any other branch of machine learning, is an amazing thing, periodically forcing the programmer to clutch his head and shout ‚Äúhow, how did he do it?‚Äù.  The piquancy here was added by the fact that in my case, with my help, the computer actually improves its programs itself in some unknown way, by inventing such things that I myself would not have thought of at once. <br><br>  In general, I sometimes felt like a hero of this and similar comics: <br><br><img src="https://habrastorage.org/files/98e/e5b/aef/98ee5baef83c4aa9b9125b1d4075cea0.jpg"><br><br>  Well, we drove our individuals through crosses and emulations, verified the equivalence of the results and what did we get?  I will give a couple of examples of the optimizations I found. <br><br>  <u>Minimizing constants and other standard things.</u> <br><br>  First, the algorithm quite well finds all sorts of standard things on synthetic tests, such as removing unused calculations or folding constants, although I didn‚Äôt sharpen it specifically for this.  For example, he quickly realized that <i>x + 1 - 2</i> can be reduced to <i>x - 1</i> : <br>  It was: <br><pre><code class="java hljs">ILOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ICONST_1 IADD ICONST_2 ICONST_M1 IMUL IADD</code> </pre> <br>  It became: <br><pre> <code class="java hljs">ILOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ICONST_1 ISUB</code> </pre><br><br>  All other examples are taken from real code, a special tool was written that parsed the compiled classes and looked for suitable sequences for optimization (that is, not containing branches and unsupported instructions). <br><br>  <u>Simplify Mathematical Expressions and Brackets</u> <br><br>  The example from the beginning of the article was reduced from 11 to 9 instructions: <img src="https://habrastorage.org/files/ace/19a/a3b/ace19aa3b2154f44958046c370a8bac6.gif">  .  At first glance, the expression is generally wrong, and having received it, I rushed to look for an error in the emulator code.  But no, that's right, because the expression <i>(x + 1) x is</i> always even and non-negative, that is, the low-order bit is always zero, and in this case addition with the unit is equivalent to xor with it, and apparently works for some faster.  The truth is only in the absence of JIT, if you turn it on then the quite expected <i>((x + 1) x + 1) x</i> comes out on top.  I don‚Äôt know why the OR (or XOR) version worked faster, but this result was regularly reproduced, including on different versions of Java and on different computers <br><br>  In general, JIT in the case of Java brought a lot of headaches, and I even regretted that I chose this platform.  It was never possible to be sure for one hundred percent, is it your optimization that has increased the speed, or is it a damn java-machine inside of you that turned something there?  Of course, I studied all kinds of useful articles like <a href="http://www.ibm.com/developerworks/ru/library/j-jtp02225/">Anatomy of incorrect micro-tests for performance evaluation</a> , but I still had a lot of trouble with it.  Very annoying is the sequential improvement in the code, depending on the number of launches.  I started the fragment a hundred times - it works in the interpreter mode and gives one result, launched a thousand - turned on the JIT, translated it into a native code but didn‚Äôt optimize it much, launched ten thousand - JIT started picking something in this native code, as a result, the execution speeds change on orders and all this has to be taken into account. <br><br>  <u>Logical operators</u> <br><br>  However, in some places I even managed to jump.  For example, the expression <i>(x XOR -1) AND y The</i> obvious enough optimization for it will be <i>! X and y</i> , and this is exactly what the C ++ compiler will generate for you.  But in Java's bytecode there is no bitwise single-operand operation, so the best option here would be <i>(x XOR y) AND y</i> .  At the same time, the JIT is not thought out to this (it was checked by including the debug output on the JVM 1.6 server), which allows us to gain a little in speed. <br><br>  <u>Sly left shift feature</u> <br><br>  There was another fun result with the shift operator.  Somewhere in the depths of BigInteger, the expression <i>1 &lt;&lt; (x &amp; 31) was found</i> , the optimized version of which gave the algorithm <i>1 &lt;&lt; x</i> . <br>  Again, grabbing the head, again looking for a bug - obviously, the algorithm took and threw out a whole significant piece of code.  Until I thought of rereading the specification of operators more closely, in particular, it turned out that the &lt;&lt; operator uses only 5 low bits of its second operand.  Therefore, an explicit <i>&amp; 31</i> is not needed in general, the operator will do it for you (I understand that the library classes in the baytkod are forced &amp; left for compatibility with older versions, since this feature did not appear in the very first java). <br><br>  <b>Problems and conclusion</b> <br><br>  Having received my results, I began to think what to do with them further.  And it was here that nothing was invented.  In the case of Java, my optimizations are too small and unnoticeable to have a significant impact on the speed of the program as a whole, at least for those programs on which I could test all this (maybe some deep scientific calculations and will benefit significantly from replacing a couple of instructions and cuts the time of one cycle for a couple of nanoseconds).  In addition, the effect is significantly eaten by the structure of the java machine itself, virtuality and JIT. <br><br>  I tried to switch to other architectures.  At first on x86, I got the first working version, but the assembler is too complicated there and I couldn‚Äôt write the code required for its verification.  Then I tried to stick in the direction of the shaders, since then I worked in game dev, and added support for the pixel shader assembler.  But there I just could not find a single suitable shader containing a good example of a sequence of instructions. <br><br>  In general, I did not think of where to screw this thing.  Although the feeling of when the computer turns out to be smarter than you and finds such optimization that you don‚Äôt even immediately understand how it works, I remembered for a long time. </div><p>Source: <a href="https://habr.com/ru/post/265195/">https://habr.com/ru/post/265195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265183/index.html">Billions of requests per day meet Go 1.5</a></li>
<li><a href="../265185/index.html">Rakes that you wouldn‚Äôt want to step on in your project</a></li>
<li><a href="../265187/index.html">Career in Information Security</a></li>
<li><a href="../265189/index.html">Dell and TLC 3D NAND: Something New</a></li>
<li><a href="../265191/index.html">An update is available for ReSharper Ultimate</a></li>
<li><a href="../265197/index.html">Editor or IDE? Another analysis attempt</a></li>
<li><a href="../265199/index.html">Meta-Object Protocol in Perl6</a></li>
<li><a href="../265201/index.html">C # - Modeling "reasonable" life based on neural networks</a></li>
<li><a href="../265203/index.html">Development of trading robots: the history of the project StockSharp</a></li>
<li><a href="../265207/index.html">TMS Star</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>