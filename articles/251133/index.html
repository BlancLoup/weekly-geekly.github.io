<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CxxMock - principle of operation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes it is interesting to study the architecture of any product, and see how it works. That happened to disassemble the clock, and you can not co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CxxMock - principle of operation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/570/e79/e73/570e79e73ed38f63467392e937ed9e13.jpg" align="right"><br>  Sometimes it is interesting to study the architecture of any product, and see how it works.  That happened to disassemble the clock, and you can not collect back ... But in contrast to the clock software when accessing the source can be disassembled and assembled.  And the solutions found are already used in their practice. <br><br>  When I needed to create <a href="http://cxxmock.com/">CxxMock</a> , about which I wrote in the article <a href="http://habrahabr.ru/post/250979/">CxxMock - Mock-objects in C ++</a> , I understood the principle of the similar <a href="http://code.google.com/p/googlemock/">GoogleMock</a> .  Or even earlier, I analyzed the main idea of ‚Äã‚Äãmathopd's c10k server, which in subsequent projects allowed me to better maneuver in architecture design. <br><br>  Therefore, I will talk about the basic concepts and due to which CxxMock works.  And that was interesting to invent.  Some tricks may seem simple to you, while others may be able to help you in your practice. <br><a name="habracut"></a><br><h2>  CxxMock inside view </h2><br>  Interesting decisions that will be discussed: <br><ol><li>  Imitation of behavior as if we have a <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">reflection</a> </li><li>  Ensuring registration of factories without an overhead. </li><li>  Creating the desired interface implementation. </li><li>  Programming method behavior. </li><li>  Control method </li><li>  Comparison of arguments. </li><li>  Execute custom method. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Imitation of behavior as if we have a reflection <br></h2><br>  In C # there is reflection, in C ++ there is no, but there is RTTI which can help identify types but can neither call methods nor build classes dynamically during program execution.  That is, in order to create something, it is necessary that it already existed at compile time, and that the CxxMock kernel knows what to create and how to create it.  To achieve this, you can use a code parser as well, as CxxTest does to build a test table of contents and Qt to create a <a href="http://qt-project.org/doc/qt-4.8/qmetaobject.html">QMetaOBject</a> containing references to all signals and slots.  In the case of CxxMock, I had to comply with the concept of <a href="http://cxxtest.com/">CxxTest</a> and write a generator in python with all sorts of scary regex and algorithm for parsing brackets to take into account such cases: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NS4 { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NS5 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Type* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type&amp; a)</span></span></span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface(){}; }; }}</code> </pre> <br>  on output, the generator creates a header file with a class (s) that implements the interface <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NS4 { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NS5 { <span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CXXMOCK_DECL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Interface )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ CXXMOCK( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, a ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Type* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type&amp; a)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CXXMOCK( Type*, a ) } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface(){}; }; CXXMOCK_IMPL( Interface ) }}</code> </pre><br>  that is, quite readable code that can be written manually and which can parse almost any syntax parser in the IDE.  The first version was done by writing such classes manually. <br><br><h2>  Ensuring registration of factories without an overhead </h2><br>  If we approach the forehead, then for each class it would be necessary to have a special implementation of the interface at some point setUp () or immediately write code like this: <br><br><pre> <code class="cpp hljs">cxxmock::Repository::instance().registerFactory&lt;Interface&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockFactory&lt;Interface, InterfaceImpl&gt;() ); cxxmock::Repository::instance().registerFactory&lt;Interface2&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockFactory&lt;Interface2, Interface2Impl&gt;() ); ...</code> </pre><br><br>  It agree, it is not so convenient, to repeat the name of our interface ten times.  Even if this piece of code is automatically created, where should it be inserted? <br><br>  We have limitations: <br><ol><li>  In most cases, when using CxxTest, you do not need to manually rewrite the main () function.  That is, we cannot insert our code into it. </li><li>  However, it is also not convenient to do the registration in each setUp () method of each test suite, even connecting the table of contents through the #include directive </li><li>  And to execute some code in the same place where our class is declared is also seemingly impossible </li></ol><br><br>  But when it is impossible but really want - you can.  The macro call is used for this purpose. <br><pre> <code class="cpp hljs">CXXMOCK_IMPL( Interface )</code> </pre><br>  The macro is responsible for creating a static variable - a container typed by the interface and our created class - stub. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CXXMOCK_IMPL( interface ) CxxMock::Container</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;interface, cxxmocks_impl_##interface&gt; cxxmocks_instance_##interface;</span></span></span></span></code> </pre><br>  Due to the fact that in C ++, just as in ANSI C, when loading a library into memory, even before running main () and _init (), all static and global variables are initialized first.  Since the variables declared in CXXMOCK_IMPL are an instance of a class, a constructor will be called for them, in which we can tell the registry that we have a container that can create objects implementing a certain interface. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span><span class="hljs-class">&lt;Interface, Impl&gt;:</span></span>:Container() { Repository::instance().registerFactory( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); }</code> </pre><br>  The main purpose of the Container is to store information about the interface's compliance with its class stub, but it has a factory method for creating an instance of the class and is inherited from Factory. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span><span class="hljs-class">&lt;Interface, Impl&gt;:</span></span>:create(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Impl(); }</code> </pre><br>  therefore, it is further referred to as the Factory. <br><br>  Of course, the order of initialization of global variables is not defined, but due to the use of lazy initialization of the repository of containers (factories), the order of creating global variables is not important to us.  In this way, by the beginning of the execution of a set of unit tests, CxxMock knows about all the classes implementing the interfaces that will be required in the unit tests. <br><br><h2>  Creating the desired interface implementation </h2><br>  In order to create something, you need to know WHAT to create and find someone who knows HOW to create what we need. <br>  In .NET we can simply write: <br><pre> <code class="cpp hljs">_registry[ typeof( factory ) ] = factory;</code> </pre><br>  for C ++ you need to use magic with RTTI: <br><img src="https://habrastorage.org/getpro/habr/post_images/395/d86/4db/395d864dba2ddd1a9b8ce92de5d7f427.jpg" align="right" width="150"><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Repository</span></span></span><span class="hljs-class">:</span></span>:registerFactory(Factory&lt;T&gt;* factory) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tname = <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Factory&lt;T&gt;::TargetType ).name(); _registry[ tname ] = factory; }</code> </pre><br>  _registry is a regular std :: map &lt;string, Handle *&gt;, using a pointer to Handle (the base class for the factories) makes the <b>dynamic_cast</b> work. <br><br>  after the factory is in the registry, we can ask the repository to create for us the implementation of the stub object for our interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Repository</span></span></span><span class="hljs-class">:</span></span>:create() { RepositoryTypeMap::iterator it = _registry.find( <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).name() ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt; Factory&lt;T&gt;* &gt;(&amp;(*it-&gt;second))-&gt;create(); }</code> </pre><br><br>  Here we apply a trick with casting the type from Handle back to Factory *, as we have in the collection are factories of completely different types with only the general class Handle. <br><br><br><h2>  Programming method behavior </h2><br>  Programming the behavior of the method is the most important part of CxxMock, because it is necessary to explicitly call the interface method so that the IDE highlights all the necessary arguments, but at the same time you need to tell CxxMock any parameters related to this particular call. <br><br>  Ideally it should look like this (Rhino.Mocks, C #): <br><pre> <code class="hljs pgsql">Expect.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>( mock-&gt;<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>( <span class="hljs-number"><span class="hljs-number">5</span></span> ) ).<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>( <span class="hljs-number"><span class="hljs-number">10</span></span> ); Expect.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>( ()=&gt; { mock-&gt;voidMethod( <span class="hljs-number"><span class="hljs-number">5</span></span> ); } ).repeat.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>;</code> </pre><br><br>  In fact, two calls take place here: <br><ul><li>  First, we honestly call our interface method mock-&gt; method (), then </li><li>  The result, no matter what, is passed to the Expect.Call () call which returns a CalllInfo structure containing the call information. </li></ul><br>  Also in Rhino.Mocks, the Expect class is used which knows the current context and the active MockRepository. <br><br>  For the C ++ version, I applied a similar trick: <br><pre> <code class="cpp hljs"> TS_EXPECT_CALL( mock-&gt;method(<span class="hljs-number"><span class="hljs-number">10</span></span>) ).returns(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br><br>  but using the TS_EXPECT_CALL macro with the CxxTest compatible signature that hid the call: <br><pre> <code class="cpp hljs"> CxxMock::Repository::instance().expectCall( mock-&gt;method(<span class="hljs-number"><span class="hljs-number">10</span></span>) )</code> </pre><br>  The difference from Rhino.Mocks here is that, firstly, there is no additional class used for hiding calls to the repository instance (MocksRepository), and secondly, it is possible to disguise the method of calling the method () method. <br><br>  After the CallInfo structure is returned by a link from expectCall (), the usual work of setting up the object occurs. <br><br><h2>  Passing arguments </h2><br>  An interesting question about writing down the arguments with which the method was invoked and ensuring that the return value is memorized and returned.  Arguments should be stored and compared with them. <br><br>  Mixed solution is applied in CxxMock: <br><br>  1. The auto-generator creates a class using the CXXMOCK macro, which makes it easy to use in manual mode. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CXXMOCK(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, a); }</code> </pre><br><br>  2. The macro CXXMOCK, in turn, calls the overloaded method cxxmock_object.mock (MOCK_FUNCID, args);  which has an arbitrary typing similar to Action &lt;&gt; in C # (up to 10 arguments) and tells the CxxMock kernel a string representation of the method name.  Since it is important for us to know exactly which method was called and what signature it has, and in C ++ it is possible to overload including pure virtual methods, then registration by calling on the full signature of the method is used using the macro MOCK_FUNCID implementing __PRETTY_FUNC____ or __FUNCDNAME__ depending about the compiler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A2&gt; R MockObject::mock( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; funcname, A1 a1, A2 a2) { <span class="hljs-comment"><span class="hljs-comment">// processCall()  :     . return this-&gt;processCall&lt;R&gt;( method(funcname).arg( a1 ).arg( a2 ) ); } CallInfo&amp; MockObject::method( std::string funcname ) { CallInfoPtr ptr = new CallInfo(funcname); Repository::instance().setLastCall( ptr ); return *ptr; }</span></span></code> </pre><br>  Inside the overloaded method, the actual registration of all arguments takes place and a CallInfo structure is formed for further customization. <br><br>  Unlike the googlemock solution, here the MockObject :: mock () method for each call forms the same CallInfo structure into which all the information about the call is recorded.  The method arguments are saved in the same way as is done for the Class Factory .: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A&gt; CallInfo&amp; CallInfo::arg(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A value ) { inValues[ inValues.size() ] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Argument&lt;A&gt;(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  After that, in playback mode, a simple comparison of the collections of arguments is performed using a unified IArgument interface for all implementations of Argument. <br><br><h2>  Argument comparison </h2><br>  Comparing arguments is very simple.  To do this, take the expected value and compare it with the value that came in the call to the user interface.  And since there are a lot of comparison options, here I simply use the CxxTest capabilities for comparing all types.  He has good opportunities for this. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Argument&lt;T&gt;::compare( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IArgument&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Argument&lt;T&gt; *arg = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Argument&lt;T&gt;* &gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CxxTest::equals( Value, arg-&gt;Value); }</code> </pre><br><br>  A more serious problem was getting a string representation of the value in order to generate a good error message like this: <br><br>  Call Waiting: Interface :: method (5) <br>  Actually called: Interace :: method2 (6) <br><br>  Since the developer can use his own data types, and if he uses some kind of framework for testing, he should not write anything extra.  Therefore, CxxTest is also used here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TVal&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TVal arg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CxxTest::ValueTraits&lt;T&gt;( Value ).asString(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> convertToString( Value ); }</code> </pre><br>  Doing these two things is the only place where integration with CxxTest is actually used. <br><br><h2>  Run custom method </h2><br>  In order to execute a custom method, several conditions are necessary: <br><ol><li>  It is necessary to save information about the method to be called and its type in order to correctly call it. </li><li>  We must equally initiate a call to the user method, regardless of how many arguments it has. </li><li>  Given the strong typing, you need to construct a method call as if we have a variable number of arguments. </li></ol><br>  To save information about the method, simply make a template class that stores a pointer to the function that we received on the input: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Sender, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">CallInfo&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Sender* sender, T method )</span></span></span><span class="hljs-function"> </span></span>{ _action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action&lt;Sender, T&gt;(sender, method ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  In order to call ‚ÄúI don‚Äôt know what‚Äù, we can use a proxy method that implements the interface (IAction) but within itself calls a template method that implements a specific strategy for calling a custom method: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Sender, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IAction { Sender* _sender; T _method; ... <span class="hljs-comment"><span class="hljs-comment">//  template&lt;typename R, typename A&gt; void callMethod(IArgumentPtr result, const ArgList&amp; args, R (Sender::*method)(A)){ result-&gt;setValue(Argument&lt;R&gt;((_sender-&gt;*_method)( args.val&lt;A&gt;(0) )) ); } ... void call(IArgumentPtr result, const ArgList&amp; args) { callMethod(result, args, _method ); } }</span></span></code> </pre><br>  Due to the fact that we explicitly indicate the signature of the user method in each template implementation, at the point of callMethod () our type T will be decomposed into type R (Sender :: * method) (A).  allowing you to handle a specific version of a call separately.  And build a custom method call in the same way that the registration of the method call was performed. <br><br>  Due to the use of the solution ‚Äútemplate inherited from the interface‚Äù, it is not required to create many service classes, it is enough just to make many versions of the methods with the implementation of the calling strategy.  That will provide a simulation of calling a method with a variable number of arguments. <br><br><h2>  Conclusion </h2><br>  The main theses of the applied tricks: <br><ul><li>  Even a simple text can make an imitation of "reflection" when you really want </li><li>  You can execute any code before transferring control to main () using the object's constructor. </li><li>  To bind template classes to a common point, you need to inherit the interface, dynamic_cast will do the rest as it should. </li><li>  You can build chains of sequences by implicitly using the global context (Expect.Call (...)). </li><li>  A dozen overloaded methods and a collection of argument containers can simplify the creation of your version of RPC or the task of comparing the list of arguments. </li><li>  You do not need to do everything yourself, sometimes the platform already provides opportunities for this. </li><li>  A complex type in a template can be decomposed into simpler types, which will allow a more precise choice of the implementing method. </li></ul><br><br>  That's probably all the basic tricks applied in this simple library CxxMock, the main code of which takes only 15kb, but allows you to greatly simplify the life of the developer and IDE. <br><br>  Everything lies on <a href="http://sourceforge.net/projects/cxxmock/">SourceForge</a> and <a href="https://github.com/comm644/cxxmock">GitHub</a> . <br><br><br>  Thanks for attention. <br><br><h2>  Links </h2><br><ol><li>  <a href="http://cxxmock.com/">CxxMock main site</a> </li><li>  <a href="http://sourceforge.net/projects/cxxmock/">SourceForge Mirror</a> </li><li>  <a href="https://github.com/comm644/cxxmock">Mirror on github</a> </li><li>  <a href="http://cxxtest.com/">CxxTest</a> </li><li>  <a href="http://www.hibernatingrhinos.com/oss/rhino-mocks">Rhino.Mocks</a> </li><li>  <a href="http://code.google.com/p/googlemock/">GoogleMock</a> </li></ol><br><br><h2>  What to read </h2><br>  To understand DAO programming, I also recommend: <br><ol><li>  Myers Scott  Effective use of C ++.  55 sure ways to improve the structure and code of your programs </li><li>  John Bentley  Programming gems </li></ol></div><p>Source: <a href="https://habr.com/ru/post/251133/">https://habr.com/ru/post/251133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251117/index.html">Overview of glands for practicing robotics with children</a></li>
<li><a href="../251121/index.html">Save electricity or time timer for night tariffs in power grids</a></li>
<li><a href="../251123/index.html">NAS + SoftetherVPN = Universal VPN Server</a></li>
<li><a href="../251127/index.html">International exhibition "EuroCIS-2015". Live twitter feed</a></li>
<li><a href="../251131/index.html">Java EE, JCA and jNode 2.X announce</a></li>
<li><a href="../251137/index.html">We write a bot for MMORPG with assembler and draenei. Part 0</a></li>
<li><a href="../251141/index.html">Another software UART on ATtiny13</a></li>
<li><a href="../251143/index.html">Own implementation of https using crypto ++ for I2P bootstrapping</a></li>
<li><a href="../251149/index.html">We write a bot for MMORPG with assembler and draenei. Part 1</a></li>
<li><a href="../251155/index.html">Creating MMC Management Console</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>