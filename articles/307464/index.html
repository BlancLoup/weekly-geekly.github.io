<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple system of demons for Yii2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will try to reveal the main nuances of the implementation of the system of demons for PHP and teach the console commands Yii2 to be ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple system of demons for Yii2</h1><div class="post__text post__text-html js-mediator-article">  In this article I will try to reveal the main nuances of the implementation of the system of demons for PHP and teach the console commands Yii2 to be demonized. <br><br>  For the last 3 years I have been developing and developing a fairly large corporate portal for one group of companies.  I, like many, have encountered a problem when the solution of the task that a business requires does not fit into any timeouts.  Make a report in excel on 300 thousand lines, send a newsletter to 1500 letters and so on.  Naturally, such tasks should be solved by background tasks, demons and crontab-s.  Within the framework of this article I will not give a comparison of crowns and demons, we have chosen demons for solving such problems.  At the same time, an important requirement for us was the opportunity to have access to everything that is already written for the backend, respectively, the demons should be a continuation of the Yii2 framework.  For the same reason, ready-made solutions like phpDaemon did not suit us. <br><br>  Under the cut a ready-made solution for the implementation of demons on Yii2, which I got. <br><a name="habracut"></a><br>  The theme of demons in PHP is raised with enviable regularity ( <a href="https://habrahabr.ru/post/40432/">one</a> , <a href="https://habrahabr.ru/post/134620/">two</a> , <a href="https://habrahabr.ru/post/276709/">three</a> , <a href="https://habrahabr.ru/company/badoo/blog/252809/">and the guys from badoo even restart them without losing connections</a> ).  Maybe my <s>bike is a</s> quick way to run demons on a popular framework. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Some basics </h4><br>  In order for a process to become a demon, you need: <br><ol><li>  Unlink script from console and standard input / output streams; </li><li>  Wrap the execution of the main code in an infinite loop; </li><li>  Implement process control mechanisms. </li></ol><br><h5>  Unbound from the console </h5><br>  To begin, close the standard streams STDIN, STOUT, STDERR.  But PHP cannot do without them, so it will make the first open stream standard, so open them in / dev / null. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_resource(STDIN)) { fclose(STDIN); $stdIn = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_resource(STDOUT)) { fclose(STDOUT); $stdOut = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'ab'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_resource(STDERR)) { fclose(STDERR); $stdErr = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, <span class="hljs-string"><span class="hljs-string">'ab'</span></span>); }</code> </pre> <br>  Next, we fork the process and fork the main process.  The donor process is complete. <br><pre> <code class="php hljs">$pid = pcntl_fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;halt(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::EXIT_CODE_ERROR, <span class="hljs-string"><span class="hljs-string">'pcntl_fork() rise error'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> ($pid) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;halt(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::EXIT_CODE_NORMAL); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { posix_setsid(); }</code> </pre><br><h5>  Endless cycle and control </h5><br>  I think with the cycle everything is understood.  But the necessary control mechanisms should be considered in more detail. <br><br><h6>  Fixing processes already running </h6><br>  Everything is simple - after the launch, the daemon puts its PID in a file with its name, and at the completion of its work, this file is demolished. <br><br><h6>  POSIX signal processing </h6><br>  The daemon must correctly process signals from the operating system, i.e.  upon receipt of a signal, SIGTERM should smoothly complete its work.  This is achieved by several things: first, we define the function that will process the received signals: <br><br><pre> <code class="php hljs">pcntl_signal(SIGTERM, [<span class="hljs-string"><span class="hljs-string">'MyClassName'</span></span>, <span class="hljs-string"><span class="hljs-string">'mySignalHandlerFunction'</span></span>]);</code> </pre><br>  Second, in the signal processing function, we set the assignment of a certain static class property to true. <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signalHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($signo, $pid = null, $status = null)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$stopFlag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  And third, our infinite loop should now be not so infinite: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$stopFlag) { pcntl_signal_dispatch(); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Signal processing features in different versions of PHP</b> <div class="spoiler_text">  In PHP &lt;5.3.0, a special <a href="http://php.net/manual/ru/control-structures.declare.php">declare</a> directive <a href="http://php.net/manual/ru/control-structures.declare.php">(ticks = N) was</a> used to distribute signals.  Where tick is an event that happens every N low-level operations performed by the parser inside the declare block.  The distribution of signals was carried out in accordance with the setting.  Too small a value resulted in a failure in performance, and too large a result in untimely signal processing. <br><br>  In PHP&gt; = 5.3.0, the <a href="http://php.net/manual/ru/function.pcntl-signal-dispatch.php">pcntl_signal_dispatch ()</a> function appeared, which can be called for the manual distribution of signals, which we do after each iteration. <br>  Finally, in PHP 7.1, the <a href="https://wiki.php.net/rfc/async_signals">asynchronous distribution of signals</a> will become available, which will make it possible to receive signals almost instantly without overhead and manual function calls. <br></div></div><br>  Now when receiving a command from the operating system, the script will quietly complete the current iteration and exit the loop. <br><br><h6>  Memory Leak Control </h6><br>  Unfortunately, if the demon works for a long time without restarting, memory starts flowing from it.  The intensity of the leak depends on what features you use.  From our practice, the most heavily flowed are the demons that work with remote SOAP services through the standard SoapClient class.  So you need to monitor this and periodically restart them.  Let‚Äôs complement our cycle with leak control: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$stopFlag) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_get_usage() &gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;memoryLimit) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } pcntl_signal_dispatch(); }</code> </pre><br><h4>  Where is the code for Yii? </h4><br>  Sources are laid out on Github - <a href="https://github.com/vyants/yii2-daemon">yii2-daemon</a> , the package is also available for installation via composer. <br><br>  The package consists of only 2 abstract classes - the base class DaemonController and the class WatcherDaemonController. <br><br><div class="spoiler">  <b class="spoiler_title">DaemonController</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">vyants</span></span>\<span class="hljs-title"><span class="hljs-title">daemon</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">base</span></span>\<span class="hljs-title"><span class="hljs-title">NotSupportedException</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">console</span></span>\<span class="hljs-title"><span class="hljs-title">Controller</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">helpers</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Class DaemonController * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Vladimir Yants &lt;vladimir.yants</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@gmail</span></span></span><span class="hljs-comment">.com&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DaemonController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EVENT_BEFORE_JOB = <span class="hljs-string"><span class="hljs-string">"beforeJob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EVENT_AFTER_JOB = <span class="hljs-string"><span class="hljs-string">"afterJob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EVENT_BEFORE_ITERATION = <span class="hljs-string"><span class="hljs-string">"beforeIteration"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EVENT_AFTER_ITERATION = <span class="hljs-string"><span class="hljs-string">"afterIteration"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> $demonize boolean Run controller as Daemon * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@default</span></span></span><span class="hljs-comment"> false */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $demonize = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> $isMultiInstance boolean allow daemon create a few instances * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> $maxChildProcesses * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@default</span></span></span><span class="hljs-comment"> false */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $isMultiInstance = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> $parentPID int main procces pid */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $parentPID; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> $maxChildProcesses int max daemon instances * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@default</span></span></span><span class="hljs-comment"> 10 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $maxChildProcesses = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> $currentJobs [] array of running instances */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $currentJobs = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> int Memory limit for daemon, must bee less than php memory_limit * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@default</span></span></span><span class="hljs-comment"> 32M */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $memoryLimit = <span class="hljs-number"><span class="hljs-number">268435456</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> boolean used for soft daemon stop, set 1 to stop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $stopFlag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> int Delay between task list checking * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@default</span></span></span><span class="hljs-comment"> 5sec */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $sleep = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $pidDir = <span class="hljs-string"><span class="hljs-string">"@runtime/daemons/pids"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $logDir = <span class="hljs-string"><span class="hljs-string">"@runtime/daemons/logs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $stdIn; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $stdOut; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $stdErr; <span class="hljs-comment"><span class="hljs-comment">/** * Init function */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::init(); <span class="hljs-comment"><span class="hljs-comment">//set PCNTL signal handlers pcntl_signal(SIGTERM, ['vyants\daemon\DaemonController', 'signalHandler']); pcntl_signal(SIGINT, ['vyants\daemon\DaemonController', 'signalHandler']); pcntl_signal(SIGHUP, ['vyants\daemon\DaemonController', 'signalHandler']); pcntl_signal(SIGUSR1, ['vyants\daemon\DaemonController', 'signalHandler']); pcntl_signal(SIGCHLD, ['vyants\daemon\DaemonController', 'signalHandler']); } function __destruct() { $this-&gt;deletePid(); } /** * Adjusting logger. You can override it. */ protected function initLogger() { $targets = \Yii::$app-&gt;getLog()-&gt;targets; foreach ($targets as $name =&gt; $target) { $target-&gt;enabled = false; } $config = [ 'levels' =&gt; ['error', 'warning', 'trace', 'info'], 'logFile' =&gt; \Yii::getAlias($this-&gt;logDir) . DIRECTORY_SEPARATOR . $this-&gt;getProcessName() . '.log', 'logVars' =&gt; [], 'except' =&gt; [ 'yii\db\*', // Don't include messages from db ], ]; $targets['daemon'] = new \yii\log\FileTarget($config); \Yii::$app-&gt;getLog()-&gt;targets = $targets; \Yii::$app-&gt;getLog()-&gt;init(); } /** * Daemon worker body * * @param $job * * @return boolean */ abstract protected function doJob($job); /** * Base action, you can\t override or create another actions * @return bool * @throws NotSupportedException */ final public function actionIndex() { if ($this-&gt;demonize) { $pid = pcntl_fork(); if ($pid == -1) { $this-&gt;halt(self::EXIT_CODE_ERROR, 'pcntl_fork() rise error'); } elseif ($pid) { $this-&gt;cleanLog(); $this-&gt;halt(self::EXIT_CODE_NORMAL); } else { posix_setsid(); $this-&gt;closeStdStreams(); } } $this-&gt;changeProcessName(); //run loop return $this-&gt;loop(); } /** * Set new process name */ protected function changeProcessName() { //rename process if (version_compare(PHP_VERSION, '5.5.0') &gt;= 0) { cli_set_process_title($this-&gt;getProcessName()); } else { if (function_exists('setproctitle')) { setproctitle($this-&gt;getProcessName()); } else { \Yii::error('Can\'t find cli_set_process_title or setproctitle function'); } } } /** * Close std streams and open to /dev/null * need some class properties */ protected function closeStdStreams() { if (is_resource(STDIN)) { fclose(STDIN); $this-&gt;stdIn = fopen('/dev/null', 'r'); } if (is_resource(STDOUT)) { fclose(STDOUT); $this-&gt;stdOut = fopen('/dev/null', 'ab'); } if (is_resource(STDERR)) { fclose(STDERR); $this-&gt;stdErr = fopen('/dev/null', 'ab'); } } /** * Prevent non index action running * * @param \yii\base\Action $action * * @return bool * @throws NotSupportedException */ public function beforeAction($action) { if (parent::beforeAction($action)) { $this-&gt;initLogger(); if ($action-&gt;id != "index") { throw new NotSupportedException( "Only index action allowed in daemons. So, don't create and call another" ); } return true; } else { return false; } } /** *    * * @param string $actionID * * @return array */ public function options($actionID) { return [ 'demonize', 'taskLimit', 'isMultiInstance', 'maxChildProcesses', ]; } /** * Extract current unprocessed jobs * You can extract jobs from DB (DataProvider will be great), queue managers (ZMQ, RabbiMQ etc), redis and so on * * @return array with jobs */ abstract protected function defineJobs(); /** * Fetch one task from array of tasks * * @param Array * * @return mixed one task */ protected function defineJobExtractor(&amp;$jobs) { return array_shift($jobs); } /** * Main Loop * * * @return boolean 0|1 */ final private function loop() { if (file_put_contents($this-&gt;getPidPath(), getmypid())) { $this-&gt;parentPID = getmypid(); \Yii::trace('Daemon ' . $this-&gt;getProcessName() . ' pid ' . getmypid() . ' started.'); while (!self::$stopFlag) { if (memory_get_usage() &gt; $this-&gt;memoryLimit) { \Yii::trace('Daemon ' . $this-&gt;getProcessName() . ' pid ' . getmypid() . ' used ' . memory_get_usage() . ' bytes on ' . $this-&gt;memoryLimit . ' bytes allowed by memory limit'); break; } $this-&gt;trigger(self::EVENT_BEFORE_ITERATION); $this-&gt;renewConnections(); $jobs = $this-&gt;defineJobs(); if ($jobs &amp;&amp; !empty($jobs)) { while (($job = $this-&gt;defineJobExtractor($jobs)) !== null) { //if no free workers, wait if ($this-&gt;isMultiInstance &amp;&amp; (count(static::$currentJobs) &gt;= $this-&gt;maxChildProcesses)) { \Yii::trace('Reached maximum number of child processes. Waiting...'); while (count(static::$currentJobs) &gt;= $this-&gt;maxChildProcesses) { sleep(1); pcntl_signal_dispatch(); } \Yii::trace( 'Free workers found: ' . ($this-&gt;maxChildProcesses - count(static::$currentJobs)) . ' worker(s). Delegate tasks.' ); } pcntl_signal_dispatch(); $this-&gt;runDaemon($job); } } else { sleep($this-&gt;sleep); } pcntl_signal_dispatch(); $this-&gt;trigger(self::EVENT_AFTER_ITERATION); } \Yii::info('Daemon ' . $this-&gt;getProcessName() . ' pid ' . getmypid() . ' is stopped.'); return self::EXIT_CODE_NORMAL; } $this-&gt;halt(self::EXIT_CODE_ERROR, 'Can\'t create pid file ' . $this-&gt;getPidPath()); } /** * Delete pid file */ protected function deletePid() { $pid = $this-&gt;getPidPath(); if (file_exists($pid)) { if (file_get_contents($pid) == getmypid()) { unlink($this-&gt;getPidPath()); } } else { \Yii::error('Can\'t unlink pid file ' . $this-&gt;getPidPath()); } } /** * PCNTL signals handler * * @param $signo * @param null $pid * @param null $status */ final static function signalHandler($signo, $pid = null, $status = null) { switch ($signo) { case SIGINT: case SIGTERM: //shutdown self::$stopFlag = true; break; case SIGHUP: //restart, not implemented break; case SIGUSR1: //user signal, not implemented break; case SIGCHLD: if (!$pid) { $pid = pcntl_waitpid(-1, $status, WNOHANG); } while ($pid &gt; 0) { if ($pid &amp;&amp; isset(static::$currentJobs[$pid])) { unset(static::$currentJobs[$pid]); } $pid = pcntl_waitpid(-1, $status, WNOHANG); } break; } } /** * Tasks runner * * @param string $job * * @return boolean */ final public function runDaemon($job) { if ($this-&gt;isMultiInstance) { $this-&gt;flushLog(); $pid = pcntl_fork(); if ($pid == -1) { return false; } elseif ($pid !== 0) { static::$currentJobs[$pid] = true; return true; } else { $this-&gt;cleanLog(); $this-&gt;renewConnections(); //child process must die $this-&gt;trigger(self::EVENT_BEFORE_JOB); $status = $this-&gt;doJob($job); $this-&gt;trigger(self::EVENT_AFTER_JOB); if ($status) { $this-&gt;halt(self::EXIT_CODE_NORMAL); } else { $this-&gt;halt(self::EXIT_CODE_ERROR, 'Child process #' . $pid . ' return error.'); } } } else { $this-&gt;trigger(self::EVENT_BEFORE_JOB); $status = $this-&gt;doJob($job); $this-&gt;trigger(self::EVENT_AFTER_JOB); return $status; } } /** * Stop process and show or write message * * @param $code int -1|0|1 * @param $message string */ protected function halt($code, $message = null) { if ($message !== null) { if ($code == self::EXIT_CODE_ERROR) { \Yii::error($message); if (!$this-&gt;demonize) { $message = Console::ansiFormat($message, [Console::FG_RED]); } } else { \Yii::trace($message); } if (!$this-&gt;demonize) { $this-&gt;writeConsole($message); } } if ($code !== -1) { \Yii::$app-&gt;end($code); } } /** * Renew connections * @throws \yii\base\InvalidConfigException * @throws \yii\db\Exception */ protected function renewConnections() { if (isset(\Yii::$app-&gt;db)) { \Yii::$app-&gt;db-&gt;close(); \Yii::$app-&gt;db-&gt;open(); } } /** * Show message in console * * @param $message */ private function writeConsole($message) { $out = Console::ansiFormat('[' . date('dmY H:i:s') . '] ', [Console::BOLD]); $this-&gt;stdout($out . $message . "\n"); } /** * @param string $daemon * * @return string */ public function getPidPath($daemon = null) { $dir = \Yii::getAlias($this-&gt;pidDir); if (!file_exists($dir)) { mkdir($dir, 0744, true); } $daemon = $this-&gt;getProcessName($daemon); return $dir . DIRECTORY_SEPARATOR . $daemon; } /** * @return string */ public function getProcessName($route = null) { if (is_null($route)) { $route = \Yii::$app-&gt;requestedRoute; } return str_replace(['/index', '/'], ['', '.'], $route); } /** * If in daemon mode - no write to console * * @param string $string * * @return bool|int */ public function stdout($string) { if (!$this-&gt;demonize &amp;&amp; is_resource(STDOUT)) { return parent::stdout($string); } else { return false; } } /** * If in daemon mode - no write to console * * @param string $string * * @return int */ public function stderr($string) { if (!$this-&gt;demonize &amp;&amp; is_resource(\STDERR)) { return parent::stderr($string); } else { return false; } } /** * Empty log queue */ protected function cleanLog() { \Yii::$app-&gt;log-&gt;logger-&gt;messages = []; } /** * Empty log queue */ protected function flushLog($final = false) { \Yii::$app-&gt;log-&gt;logger-&gt;flush($final); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">WatcherDaemonController</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">vyants</span></span>\<span class="hljs-title"><span class="hljs-title">daemon</span></span>\<span class="hljs-title"><span class="hljs-title">controllers</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">vyants</span></span>\<span class="hljs-title"><span class="hljs-title">daemon</span></span>\<span class="hljs-title"><span class="hljs-title">DaemonController</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * watcher-daemon - check another daemons and run it if need * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Vladimir Yants &lt;vladimir.yants</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@gmail</span></span></span><span class="hljs-comment">.com&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WatcherDaemonController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DaemonController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string subfolder in console/controllers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $daemonFolder = <span class="hljs-string"><span class="hljs-string">'daemons'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> boolean flag for first iteration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $firstIteration = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Prevent double start */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $pid_file = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getPidPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_exists($pid_file) &amp;&amp; ($pid = file_get_contents($pid_file)) &amp;&amp; file_exists(<span class="hljs-string"><span class="hljs-string">"/proc/$pid"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;halt(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::EXIT_CODE_ERROR, <span class="hljs-string"><span class="hljs-string">'Another Watcher is already running.'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::init(); } <span class="hljs-comment"><span class="hljs-comment">/** * Job processing body * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> $job array * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($job)</span></span></span><span class="hljs-function"> </span></span>{ $pid_file = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getPidPath($job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>]); \Yii::trace(<span class="hljs-string"><span class="hljs-string">'Check daemon '</span></span> . $job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_exists($pid_file)) { $pid = file_get_contents($pid_file); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isProcessRunning($pid)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($job[<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>]) { \Yii::trace(<span class="hljs-string"><span class="hljs-string">'Daemon '</span></span> . $job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>] . <span class="hljs-string"><span class="hljs-string">' running and working fine'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { \Yii::warning(<span class="hljs-string"><span class="hljs-string">'Daemon '</span></span> . $job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>] . <span class="hljs-string"><span class="hljs-string">' running, but disabled in config. Send SIGTERM signal.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($job[<span class="hljs-string"><span class="hljs-string">'hardKill'</span></span>]) &amp;&amp; $job[<span class="hljs-string"><span class="hljs-string">'hardKill'</span></span>]) { posix_kill($pid, SIGKILL); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { posix_kill($pid, SIGTERM); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } } \Yii::error(<span class="hljs-string"><span class="hljs-string">'Daemon pid not found.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($job[<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>]) { \Yii::trace(<span class="hljs-string"><span class="hljs-string">'Try to run daemon '</span></span> . $job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>] . <span class="hljs-string"><span class="hljs-string">'.'</span></span>); $command_name = $job[<span class="hljs-string"><span class="hljs-string">'daemon'</span></span>] . DIRECTORY_SEPARATOR . <span class="hljs-string"><span class="hljs-string">'index'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//flush log before fork $this-&gt;flushLog(true); //run daemon $pid = pcntl_fork(); if ($pid === -1) { $this-&gt;halt(self::EXIT_CODE_ERROR, 'pcntl_fork() returned error'); } elseif ($pid === 0) { $this-&gt;cleanLog(); \Yii::$app-&gt;requestedRoute = $command_name; \Yii::$app-&gt;runAction("$command_name", ['demonize' =&gt; 1]); $this-&gt;halt(0); } else { $this-&gt;initLogger(); \Yii::trace('Daemon ' . $job['daemon'] . ' is running with pid ' . $pid); } } \Yii::trace('Daemon ' . $job['daemon'] . ' is checked.'); return true; } /** * @return array */ protected function defineJobs() { if ($this-&gt;firstIteration) { $this-&gt;firstIteration = false; } else { sleep($this-&gt;sleep); } return $this-&gt;getDaemonsList(); } /** * Daemons for check. Better way - get it from database * [ * ['daemon' =&gt; 'one-daemon', 'enabled' =&gt; true] * ... * ['daemon' =&gt; 'another-daemon', 'enabled' =&gt; false] * ] * @return array */ abstract protected function getDaemonsList(); /** * @param $pid * * @return bool */ public function isProcessRunning($pid) { return file_exists("/proc/$pid"); } }</span></span></code> </pre><br></div></div><br><h5>  DaemonController </h5><br>  This is the parent class for all demons.  Here is a minimal daemon example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">console</span></span>\<span class="hljs-title"><span class="hljs-title">controllers</span></span>\<span class="hljs-title"><span class="hljs-title">daemons</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">vyants</span></span>\<span class="hljs-title"><span class="hljs-title">daemon</span></span>\<span class="hljs-title"><span class="hljs-title">DaemonController</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DaemonController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> $job * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do some job return true; } /** * @return array */ protected function defineJobs() { return []; } }</span></span></code> </pre><br>  The defineJobs () function must return a set of tasks to perform.  By default, it is expected that it will return an array.  If you want to return, say MongoCursor, you will need to override the defineJobExtractor ().  The doJob () function should receive one task for its input, perform the necessary operations with it, and mark this task at the source as completed so that it does not fall a second time. <br><br>  Possible parameters and settings: <br><ul><li>  <b>demonize</b> - this parameter determines whether the script will be demonized or work as a console application.  The parameter is available for setting from the console: --demonize = 1 </li><li>  <b>isMultiInstance and maxChildProcesses</b> - determines whether the daemon can create its own copies and how many of them can work simultaneously.  This function allows you to perform several tasks in parallel.  doJob will be executed in child processes, and the parent process will only delegate tasks to its descendants and ensure that their number does not exceed the maximum allowed.  It is very useful if the server has enough resources to perform several tasks that are quite long in time.  By default, this behavior is disabled.  Parameters are also available from the console: --isMultiInstance = 1 --maxChildProcesses = 2 </li><li>  <b>memoryLimit</b> - the threshold of consumption by the daemon of memory, if the daemon in the standby mode exceeds this threshold, then it will nobly make a sippok.  As already indicated earlier, to reduce the size of memory consumed by daemons as a result of leaks. </li><li>  <b>sleep</b> - the time in seconds that the demon will fall asleep between checks for the presence of tasks.  The daemon will go to sleep only if defineJob returns empty and while the daemon has any tasks it will not sleep.  Therefore, defineJobs should not return a static task list, otherwise the daemon will thresh them endlessly and rest. </li><li>  <b>pidDir and logDir</b> - paths for storing logs and pid-s, support aliias Yii.  The default is "@ runtime / daemons / pids" and "@ runtime / daemons / logs" </li></ul><br><br><h6>  Connection loss problem </h6><br>  When performing a fork () operation, the connections established in the parent process cease to work in child processes.  In order to avoid this problem, after all the forks, the call to the renewConnections () function is placed.  By default, this function only reconnects Yii :: $ app-&gt; db, but you can redefine it, and add other sources that you need to maintain connection to in child processes. <br><br><h6>  Logging </h6><br>  Demons reconfigure the standard Yii logger for themselves.  If you are not comfortable with the default behavior, override the initLogger () function. <br><br><h5>  WatcherDaemonController </h5><br>  This is almost a ready-watch demon.  The task of this daemon to monitor other demons, start and stop them if necessary.  It cannot start twice, so you can safely put its launch in the crontab.  To start using it, you need to create a folder daemons in console / controllers and put a class like: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">console</span></span>\<span class="hljs-title"><span class="hljs-title">controllers</span></span>\<span class="hljs-title"><span class="hljs-title">daemons</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">vyants</span></span>\<span class="hljs-title"><span class="hljs-title">daemon</span></span>\<span class="hljs-title"><span class="hljs-title">controllers</span></span>\<span class="hljs-title"><span class="hljs-title">WatcherDaemonController</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Class WatcherController */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WatcherController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WatcherDaemonController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $sleep = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDaemonsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ [<span class="hljs-string"><span class="hljs-string">'daemon'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'daemons/test'</span></span>, <span class="hljs-string"><span class="hljs-string">'enabled'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>] ]; } }</code> </pre><br>  It is required to define only one function - getDaemonsList (), which will return a list of demons that need to be monitored.  In its simplest form, this is an array embedded in the code, but in this case you will not be able to change the list on the fly.  Put a list of demons in the database or a separate file and get it every time from there.  In this case, the watcher will be able to turn the daemon on or off without its own restart. <br><br><h4>  Conclusion </h4><br>  At the moment, we have more than 50 demons performing various tasks, ranging from sending e-mails and ending with generating reports and updating data between different systems. <br><br>  Demons work with different sources of tasks - MySQL, RabbitMQ, and even remote web services.  The flight is normal. <br>  Of course, demons on php will not compare with the same demons on Go.  But the high speed of development, the ability to reuse the already written code and the lack of the need to teach the team another language outweigh the disadvantages. </div><p>Source: <a href="https://habr.com/ru/post/307464/">https://habr.com/ru/post/307464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307454/index.html">We create a mobile game on Monogame, solving typical problems of a novice developer.</a></li>
<li><a href="../307456/index.html">IXIA ThreatARMOR: fewer attacks, fewer SIEM alarms, better ROI</a></li>
<li><a href="../307458/index.html">Chatbots vs. apps: who wins?</a></li>
<li><a href="../307460/index.html">5 ways to get a customer to talk</a></li>
<li><a href="../307462/index.html">What is the monitoring of site availability? Service Overview HostTracker</a></li>
<li><a href="../307466/index.html">Open Data Programming Contest: Budget Sprint</a></li>
<li><a href="../307468/index.html">Why I love working with the web. Remy Sharp</a></li>
<li><a href="../307470/index.html">Mirantis Unlocked validation program. Part 2: Hard and Soft</a></li>
<li><a href="../307474/index.html">Minimally viable UX: SaaS (service application) design</a></li>
<li><a href="../307478/index.html">Identifying a region by phone number in Asterisk without using a database</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>