<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Boat for the arcade. Part number 2: connect OpenCV</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction  We continue to manage the world to develop a bot for the game. The previous conversation stopped on the fact that the contact is establi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Boat for the arcade. Part number 2: connect OpenCV</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><img align="right" src="https://habrastorage.org/getpro/habr/post_images/3eb/189/42d/3eb18942ddc34126657bfa2a7b770485.png">  We continue <s>to manage the world to</s> develop a bot for the game.  The previous conversation stopped on the fact that the contact is established: the mouse runs, the image is obtained.  It's time to select objects; this requires the use of many different image processing functions.  You can, of course, invent a bicycle and write these functions yourself, but it is better to use ready-made practices. <br><br>  For image processing, take the widespread <a href="http://opencv.org/">OpenCV library</a> .  It is non-native (unmanaged) for .net, so we connect it via the <a href="https://github.com/shimat/opencvsharp">OpenCvSharp</a> wrapper. <br><br>  We need OpenCV in order to apply various transformations to images, choosing such a transformation that will separate the background and the shadows from the objects, and the objects from each other.  To this goal and we will move today. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr>  <b>Topics covered</b> : the <i>choice of library for image processing, the choice of wrapper for working with OpenCV, the basic functions of OpenCV, the selection of moving objects, the color model of HSV.</i> <i><br></i> <hr><br><a name="habracut"></a><br><h4>  Why OpenCV? </h4>  There are other good libraries for image processing, the light on <a href="http://opencv.org/">OpenCV has</a> not come together. <br><br>  When programming under .net, you should also pay attention to the <a href="http://code.google.com/p/accord/">Accord.Net</a> library (and its earlier version <a href="http://code.google.com/p/aforge/">AForge.Net</a> ).  These two libraries are also free, but native (managed) for the .net platform, unlike OpenCV. <br><br>  When developing a product for sale, not ‚Äúfor fun‚Äù - I would rather focus on managed libraries.  The choice of good managed libraries does not degrade performance, but it greatly simplifies deployment, portability, and subsequent maintenance.  But in startups and in the development of ‚Äúfor fun‚Äù, a large community is more important than the future simplification of maintenance.  And that brings us back to the OpenCV library, which is much more widely known. <br><br><h5>  Big community </h5>  When self-selecting libraries, it makes sense to focus on those that have a large active community.  A large number of followers makes the library highly tested, a small percentage of inconveniences of use, a variety of documentation, and makes it easy to google questions that arise during the course of work. <br><br>  OpenCV fully supports this thesis.  There is a book on it: <a href="http://shop.oreilly.com/product/0636920022497.do">Learning OpenCV</a> ( <i>frankly, I have not read it yet, but I am going to fix it in the near future</i> ), there is its translation into Russian <a href="http://locv.ru/">locv.ru</a> ( <i>I‚Äôm not opening now</i> ), there is <a href="http://docs.opencv.org/">online documentation</a> , there are a lot of questions with answers on <a href="http://stackoverflow.com/questions/tagged/opencv%3Fsort%3Dfrequent">stackoverflow</a> . <br><br>  All of this hiring gives a quick start, providing an approach ‚ÄúPl!  Get ready!  Aim ‚Äù(when the library is being studied as work progresses) instead of the classic‚Äú Get ready!  Aim!  Pl! ‚Äù(When at first a considerable time is spent on preliminary familiarization with the library device). <br><br><h5>  Google questions </h5>  Most of the tasks were solved with the help of fast googling: the keywords in the topic of the question are hammered into Google, and the first links immediately contain the answer.  When self-searching for answers, be sure to pay attention to what keywords are used to describe the desired perspective.  Google is not important beauty and grammatical correctness of the question, for it is only important the presence of keywords, for which he will choose the answer. <br><br>  Examples of issues to be solved: <br>  - select the R-component from the image - request in google: <a href="https://www.google.ru/webhp%3Fq%3Dopencv%2Bget%2Bsingle%2Bcomponent">google: opencv get single channel</a> , and the first link says that this is done using the Split function <br>  - find differences between images: <a href="https://www.google.ru/webhp%3Fq%3Dopencv%2Bdifference%2Bimages">google: opencv difference images</a> , and the example from the first answer says that the absdiff function does this.  If, when searching, to use the word compare instead of difference, then Google will start to show completely different pages, and this will give more general answers with a recommendation to use histogram comparison, etc.  This shows the importance of choosing keywords when searching for the answer to your question. <br><br><h4>  Choosing .net-wrapper for OpenCV </h4>  The library was chosen, it remains to befriend her with C #.  This problem has already been solved before us, and again we just have to make a choice between the available options.  There are two <a href="http://www.emgu.com/">common wrappers</a> : <a href="http://www.emgu.com/">Emgu Cv</a> and <a href="https://github.com/shimat/opencvsharp">OpenCvSharp</a> .  Emgu Cv is older and more cool, OpenCvSharp is more modern.  The choice focused on OpenCvSharp, bribed the words of the author that IDisposable is supported.  This means that the author not only transferred 1 to 1 structures and functions from C / C ++ to C #, but also doped them with a file in order to make them more convenient to use in the C # style of writing code. <br><br><h5>  We connect OpenCvSharp to the project </h5>  Connecting OpenCvSharp to the project is done in a standard way, without any special quotation.  There is a small <a href="https://github.com/shimat/opencvsharp/wiki/Tutorial-for-Windows">tutorial</a> from the author, it is also possible to connect <a href="https://www.nuget.org/packages/OpenCvSharp-x64/">OpenCvSharp via nuget</a> . <br><br><h4>  Basic basic functions </h4> OpenCV has many features for working with images.  Let us dwell only on the basic basic functions that are used in solving the problem of selecting objects from an image.  OpenCV has two uses: C-style and C ++ - style.  To simplify the code, we will use the C ++ style (or rather, its counterpart via OpenCvSharp). <br><br>  There are two main classes: Mat and Cv2.  Both are in the namespace-e OpenCvSharp.CPlusPlus.  Mat is the image itself, and Cv2 is a set of actions on images. <br>  Functions: <br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  var mat = new Mat("test.bmp"); //  mat.ImWrite("out.bmp"); //  bitmap var bmp = mat.ToBitmap(); //  bitmap (  OpenCvSharp.Extensions) var mat2 = new Mat(bmp.ToIplImage(), true); //  using (new Window("", mat)) { Cv2.WaitKey(); } //   (,     ) Cv2.CvtColor(mat, dstMat, ColorConversion.RgbToGray); //      Cv2.Split(mat, out mat_channels) //      Cv2.Merge(mat_channels, mat) //    Cv2.Absdiff(mat1, mat2, dstMat); // ,  /  (50)  (0)   (255) Cv2.Threshold(mat, dstMat, 50, 255, OpenCvSharp.ThresholdType.Binary); //  mat.Circle(x, y, radius, new Scalar(b, g, r)); mat.Line(x1, y1, x2, y2, new CvScalar(b, g, r)); mat.Rectangle(new Rect(x, y, width, height), new Scalar(b, g, r)); mat.Rectangle(new Rect(x, y, width, height), new Scalar(b, g, r), -1); //  mat.PutText("test", new OpenCvSharp.CPlusPlus.Point(x, y), FontFace.HersheySimplex, 2, new Scalar(b, g, r))</span></span></code> </pre> <br>  Also in OpenCV, there are special functions for selecting objects ( <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html">Structural Analysis and Shape Descriptors</a> , <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html">Motion Analysis and Object Tracking</a> , <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html">Feature Detection</a> , <a href="http://docs.opencv.org/modules/imgproc/doc/object_detection.html">Object Detection</a> ), but squeezing the useful result out of them did not work out ( <i>you probably need to read the book after all</i> ) so leave them for later. <br><br><h4>  Selection of objects </h4>  A simple method of selecting objects is to invent a filter that cuts off the background from objects and objects from each other.  Unfortunately, the image of Zuma's field is very colorful, and a simple brightness cut-off does not work.  Below are the original image, its black and white version, and a ladder of various cutoffs.  The last image shows that in all cases the background merges with the balls, or either the one and the other is present, or at the same time is absent. <br><img src="https://habrastorage.org/getpro/habr/post_images/124/936/092/124936092568d12786c488dee611708a.png"><img src="https://habrastorage.org/getpro/habr/post_images/16e/62c/1fa/16e62c1fa6b2647b9b5f70f5adfbe7b6.png"><img src="https://habrastorage.org/getpro/habr/post_images/777/efd/68a/777efd68a129a75b1144593433cc1dd9.png"><br><br>  The selection of objects greatly complicates their ‚Äúbanding‚Äù.  Here, for example, how the Canny function reacts, highlighting the outlines of objects. <br><img src="https://habrastorage.org/getpro/habr/post_images/029/cb9/fee/029cb9fee3eef443ea06a9c58df962f3.png"><br><br>  Using separate color components life does not do better. <br><img src="https://habrastorage.org/getpro/habr/post_images/134/40e/2ca/13440e2ca46c14757a3865069762af56.png"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/57c/c79/0c857cc79c64fc3e4633e9f389f43677.png"><img src="https://habrastorage.org/getpro/habr/post_images/8f1/a04/07b/8f1a0407bcd5fa7496e7c0fd6e3fc6c5.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/759/9f6/3bb/7599f63bb90700e86e0e6fce8bac05ab.png"><img src="https://habrastorage.org/getpro/habr/post_images/568/df2/304/568df2304e2621d3d7dce2935c4ce188.png"><img src="https://habrastorage.org/getpro/habr/post_images/df2/874/42d/df287442dc8bfc9592fe7732e6d11b5c.png"><br><br><h4>  Selection of moving objects </h4>  The basis for selecting moving objects is simple: two files are compared - the points that have changed and are the desired objects.  In practice, everything is more complicated, and the devil, as always, lies in the details ... <br><br><h5>  Formation of a series of image </h5>  To form a series of images, add a small code to our bot.  The bot will keep a history of the last frames, and by pressing the space bar will drop them to disk. <br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> history = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Bitmap&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tick = <span class="hljs-number"><span class="hljs-number">0</span></span>; ;tick++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bmp = GetScreenImage(gameScreenRect); history.Insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, bmp); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxHistoryLength = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (history.Count &gt; maxHistoryLength) history.RemoveRange(maxHistoryLength, history.Count - maxHistoryLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Console.KeyAvailable) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyInfo = Console.ReadKey(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyInfo.Key == ConsoleKey.Spacebar) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; history.Count; ++i) history[i].Save(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"{0}.png"</span></span>, i)); } [..] } [..] }</code> </pre><br><br>  We launch, click and voila - we have two frames on hand. <br><img src="http://habrastorage.org/getpro/habr/post_images/b21/ad2/45c/b21ad245cdd967fe323b65844d9cc531.png"><img src="http://habrastorage.org/getpro/habr/post_images/ca9/023/14c/ca902314cd084f23c052c340c2d049ee.png"><br><br><h5>  Neighbor Comparison </h5>  Subtract one image from another ... and what is called "mixed in a bunch of horses, people."  The balls turned into something ‚Äústrange‚Äù (it can be clearly seen on the full-sized fragment), but it's okay, the main thing is that the balls turned out to be separated from the background. <br><img src="http://habrastorage.org/getpro/habr/post_images/ac2/863/853/ac2863853e0389309888144bc6a33d63.png"><img src="http://habrastorage.org/getpro/habr/post_images/425/a1c/3eb/425a1c3ebad1249228d6164255d08cc8.png"><img src="http://habrastorage.org/getpro/habr/post_images/bb3/878/1fd/bb38781fdb802ea8c7551654eed9d2ed.png"><br><br><h5>  Comparison with specially prepared background </h5>  Comparison of adjacent frames is well suited for "detached" moving objects.  If it is necessary to isolate densely moving objects, then a comparison with a specially prepared static background works better. <br>  Prepare this background: <br><img src="http://habrastorage.org/getpro/habr/post_images/754/dcd/7be/754dcd7bea0b4b9a9b09899eebb56d46.png"><br>  Compare: <br><img src="http://habrastorage.org/getpro/habr/post_images/940/1f1/a02/9401f1a023f82a6ee65bb048b496c4ce.png"><br><img src="http://habrastorage.org/getpro/habr/post_images/186/f8c/ecc/186f8cecc602d51ba8f306f76beac931.png"><img src="http://habrastorage.org/getpro/habr/post_images/88a/ede/2c0/88aede2c0a29a82c1c7007642baacfd3.png"><br>  Much better, but everything spoils the shadows.  I tried to get rid of the shadows in many ways, but the best effect was given by the idea that the shadow, in fact, is a change in brightness, and this has already led me to the idea of ‚Äã‚Äãthe HSV color model. <br><br><h4>  HSV </h4><img align="right" src="http://habrastorage.org/getpro/habr/post_images/ddb/179/8d8/ddb1798d838dc08a919f934719d9124b.png">  The HSV color model, as well as RGB, consists of three channels.  But unlike him (and the same CMYK) - this is not just a mixture of colors. <br>  - First channel, H (Hue) - color tone.  In the first approximation, this is the number of colors from the rainbow. <br>  - The second channel, S (Saturation) - saturation.  The smaller the value of this channel, the closer the color is to gray, the more - the more pronounced the color.  High saturation colors are known under the colloquial name ‚Äúacidic‚Äù. <br>  - The third channel, V (Value) - brightness.  This is the easiest to understand channel, the greater the illumination, the higher the value of this channel. <br>  The picture on the right shows the relationship of channels and colors among themselves.  There is a rainbow in a circle - this is the H channel. The triangle for a particular color (now it is red) shows the change in the S channel - saturation (direction to the top-right) and the change in the V channel - brightness (to the top-left).  Classically, the values ‚Äã‚Äãof the channel H are in the range of 0-360, S - 0-100, V - 0-100.  In OpenCV, the values ‚Äã‚Äãof all channels are brought to the range of 0-255 in order to maximally use the dimension of one byte. <br><br>  The RGB color model is close to the human eye, to how it works.  The HSV color model is close to how the color is perceived by the brain.  Below, I specifically cited a series of images of what will happen if each channel is changed to plus / minus 50 parrots.  They show that even after changing channels S and V by 100 units (and this is half of the range), the image is perceived almost as much, but even a small change in channel H greatly changes the perception, making the image ‚Äúaddicted‚Äù.  This is due to the fact that the brain for many years of evolution has learned to separate more stable data from less stable. <br><br>  What does "stable" mean?  This is the part of the information that is least affected by some external conditions.  Take a real object, for example, a solid ball.  It has some kind of its own color, but the perception of this color will vary depending on external conditions: light, air transparency, reflection of neighboring objects, etc.  Accordingly, if there is a task to allocate a ball from the surrounding world, regardless of external conditions, then it is necessary to focus more on that part of information that changes little from external conditions, and ignore the part that changes most strongly.  The least stable is the brightness (channel V): moved into the shadows and the brightness of the surrounding world has changed, the sky has covered with clouds - and the brightness has changed again.  Saturation (channel S) also changes during the day, the color perception changes more precisely - the lower the illumination, the more the <a href="http://ru.wikipedia.org/wiki/%25CA%25EE%25EB%25E1%25EE%25F7%25EA%25E8">cone</a> contribute (black and white vision) and the less information comes from the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B8_(%25D1%2581%25D0%25B5%25D1%2582%25D1%2587%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B0)">sticks</a> (color vision).  The color tone (channel H) changes the least and most consistently reflects the color of an object. <br><br><img src="http://habrastorage.org/getpro/habr/post_images/f01/c8e/c5f/f01c8ec5f7984a3bdd62ae89ae9439f9.png"><img src="http://habrastorage.org/getpro/habr/post_images/766/a8f/135/766a8f13549db900dc3eedc88e244cf9.png"><img src="http://habrastorage.org/getpro/habr/post_images/1b1/22e/f76/1b122ef7608938da9a065d30c41c4581.png"><br><img src="http://habrastorage.org/getpro/habr/post_images/4aa/c38/bac/4aac38bac2b418aee4df48e3ec6c156c.png"><img src="http://habrastorage.org/getpro/habr/post_images/ba8/3d9/c73/ba83d9c73facde311a278a7537b78d50.png"><img src="http://habrastorage.org/getpro/habr/post_images/a59/375/7eb/a593757eb6a45379514cb42c6241b871.png"><br><img src="http://habrastorage.org/getpro/habr/post_images/df9/097/170/df90971707caa537261e6f987da3ea12.png"><img src="http://habrastorage.org/getpro/habr/post_images/8d0/70b/322/8d070b32219e75596dfbb33db018950f.png"><img src="http://habrastorage.org/getpro/habr/post_images/da1/528/e6c/da1528e6c9843d17d9906a202495493f.png"><br><img src="http://habrastorage.org/getpro/habr/post_images/72d/558/0ee/72d5580eed43bce5eb65a16d32942bfe.png"><img src="http://habrastorage.org/getpro/habr/post_images/6ef/c07/418/6efc07418f8ff66a2ce8e2e348af3044.png"><img src="http://habrastorage.org/getpro/habr/post_images/c0a/2aa/a03/c0a2aaa037707d4098b4398ca6a05943.png"><br><img src="http://habrastorage.org/getpro/habr/post_images/747/263/d0b/747263d0b5c3cb2d2a946d3f23615ccc.png"><img src="http://habrastorage.org/getpro/habr/post_images/113/047/26a/11304726ae16bd95a774e662d94ae347.png"><img src="http://habrastorage.org/getpro/habr/post_images/175/137/f76/175137f76ef37812fd3dea71fb25f08d.png"><br><br><h5>  Comparison with background in hsv space </h5>  We repeat the subtraction from the static background, but now after the conversion to the hsv space, and Oh!  Miracle!  In the H and S channels, the balls are clearly separated from the shadows, all the shadows almost completely went into channel V. In the H-channel, the ‚Äúbroken‚Äù balls even disappear, but, unfortunately, the yellow balls begin to merge with the background.  In the S-channel, the irregularity remains, but all the balls are clearly visible, and translating into a two-color image (with ‚Äúgarbage‚Äù cut off less than 25) gives clear circles and removes all unnecessary. <br><br><img src="http://habrastorage.org/getpro/habr/post_images/1c8/c16/42f/1c8c1642f7c7224f35a1c366a44eed5e.png"><img src="http://habrastorage.org/getpro/habr/post_images/f0a/b0b/b15/f0ab0bb15ba171a57c9bf3a274a52cb0.png"><br><br><img src="http://habrastorage.org/getpro/habr/post_images/1e2/1e9/862/1e21e98629a8569054e7c6d4586a4aa0.png"><img src="http://habrastorage.org/getpro/habr/post_images/c14/921/a47/c14921a4777f4880159dde433fa15dd5.png"><br><br><img src="http://habrastorage.org/getpro/habr/post_images/f65/619/4eb/f656194eb95b07c0f98f84e10073e621.png"><img src="http://habrastorage.org/getpro/habr/post_images/12f/46a/59a/12f46a59a628a7491fef757842eaaef8.png"><br><br><h5>  Summary </h5>  The goal set for today has been achieved (the balls are separated from the background and from their shadows), and with peace of mind you can go to sleep. <br><br><h5>  PS </h5>  All images are generated using OpenCV (code under the cut). <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resizeK = <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = <span class="hljs-string"><span class="hljs-string">"Example/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"0.bmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src_g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"0.bmp"</span></span>, LoadMode.GrayScale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src_1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"1.bmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src_1_g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"1.bmp"</span></span>, LoadMode.GrayScale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"background.bmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> background_g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(<span class="hljs-string"><span class="hljs-string">"background.bmp"</span></span>, LoadMode.GrayScale); src.Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0.png"</span></span>); src_g.Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0 g.png"</span></span>); src_g.ThresholdStairs().Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0 g th.png"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canny = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Canny(src_g, canny, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); canny.Resize(<span class="hljs-number"><span class="hljs-number">0.5</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0 canny.png"</span></span>); Mat[] src_channels; Cv2.Split(src, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> src_channels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; src_channels.Length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channels = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, src_channels.Length).Select(j =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(src_channels[<span class="hljs-number"><span class="hljs-number">0</span></span>].Rows, src_channels[<span class="hljs-number"><span class="hljs-number">0</span></span>].Cols, src_channels[<span class="hljs-number"><span class="hljs-number">0</span></span>].Type())).ToArray(); channels[i] = src_channels[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Merge(channels, dst); dst.Resize(resizeK).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0 ch{0}.png"</span></span>, i)); src_channels[i].ThresholdStairs().Resize(resizeK).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0 ch{0} th.png"</span></span>, i)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { src.Resize(<span class="hljs-number"><span class="hljs-number">0.4</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0.png"</span></span>); src_1.Resize(<span class="hljs-number"><span class="hljs-number">0.4</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"1.png"</span></span>); background.Resize(<span class="hljs-number"><span class="hljs-number">0.4</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"bg.png"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst_01 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(src, src_1, dst_01); dst_01.Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"01.png"</span></span>); dst_01.Cut(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">50</span></span>, src.Height * <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">5</span></span> - <span class="hljs-number"><span class="hljs-number">50</span></span>, src.Width / <span class="hljs-number"><span class="hljs-number">5</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">5</span></span>)).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"01 part.png"</span></span>); dst_01.Cut(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">50</span></span>, src.Height * <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">5</span></span> - <span class="hljs-number"><span class="hljs-number">50</span></span>, src.Width / <span class="hljs-number"><span class="hljs-number">5</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">5</span></span>)).CvtColor(ColorConversion.RgbToGray).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"01 g.png"</span></span>); dst_01.CvtColor(ColorConversion.RgbToGray).ThresholdStairs().Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"01 g th.png"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst_01_g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(src_g, src_1_g, dst_01_g); dst_01_g.Cut(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">50</span></span>, src.Height * <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">5</span></span> - <span class="hljs-number"><span class="hljs-number">50</span></span>, src.Width / <span class="hljs-number"><span class="hljs-number">5</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">5</span></span>)).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0g1g.png"</span></span>); dst_01_g.ThresholdStairs().Resize(resizeK).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0g1g th.png"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst_0b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(src, background, dst_0b); dst_0b.Resize(<span class="hljs-number"><span class="hljs-number">0.6</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0b.png"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst_0b_g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(src_g, background_g, dst_0b_g); dst_0b_g.Resize(<span class="hljs-number"><span class="hljs-number">0.3</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0b g.png"</span></span>); dst_0b_g.ThresholdStairs().Resize(<span class="hljs-number"><span class="hljs-number">0.3</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"0b g th.png"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hsv_src = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.CvtColor(src, hsv_src, ColorConversion.RgbToHsv); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hsv_background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.CvtColor(background, hsv_background, ColorConversion.RgbToHsv); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hsv_background_channels = hsv_background.Split(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hsv_src_channels = hsv_src.Split(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(src.ToIplImage(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hsv_src_channels.Length; ++i) { hsv_src_channels[i].CvtColor(ColorConversion.GrayToRgb).CopyTo(all, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(i * src.Width / <span class="hljs-number"><span class="hljs-number">3</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>, src.Width / <span class="hljs-number"><span class="hljs-number">3</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>)); } src_g.CvtColor(ColorConversion.GrayToRgb).CopyTo(all, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(src.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, src.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, src.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>)); all.Resize(<span class="hljs-number"><span class="hljs-number">0.3</span></span>).ImWrite(dir + <span class="hljs-string"><span class="hljs-string">"all.png"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"h"</span></span>, <span class="hljs-string"><span class="hljs-string">"s"</span></span>, <span class="hljs-string"><span class="hljs-string">"v"</span></span> }.Select((channel, index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { channel, index })) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diff = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(hsv_src_channels[pair.index], hsv_background_channels[pair.index], diff); diff.Resize(<span class="hljs-number"><span class="hljs-number">0.3</span></span>).With_Title(pair.channel).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0b {0}.png"</span></span>, pair.channel)); diff.ThresholdStairs().Resize(<span class="hljs-number"><span class="hljs-number">0.3</span></span>).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0b {0} th.png"</span></span>, pair.channel)); hsv_src_channels[pair.index].Resize(resizeK).With_Title(pair.channel).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0 {0}.png"</span></span>, pair.channel)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">-50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span> }) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(hsv_src_channels[pair.index].ToIplImage(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); delta.Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, delta.Width, delta.Height), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(Math.Abs(d)), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> new_channel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) Cv2.Add(hsv_src_channels[pair.index], delta, new_channel); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Cv2.Subtract(hsv_src_channels[pair.index], delta, new_channel); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> new_hsv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Merge(hsv_src_channels.Select((channel, index) =&gt; index == pair.index ? new_channel : channel).ToArray(), new_hsv); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.CvtColor(new_hsv, res, ColorConversion.HsvToRgb); res.Resize(resizeK).With_Title(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"{0} {1:+#;-#}"</span></span>, pair.channel, d)).ImWrite(dir + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"0 {0}{1}.png"</span></span>, pair.channel, d)); } } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCvHlp</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scalar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToScalar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Color color</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(color.B, color.G, color.R); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, Mat dst, Rect rect</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(src.Rows, src.Cols, MatType.CV_8UC1); mask.Rectangle(rect, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(<span class="hljs-number"><span class="hljs-number">255</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>); src.CopyTo(dst, mask); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Absdiff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, Mat src2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Absdiff(src, src2, dst); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CvtColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, ColorConversion code</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.CvtColor(src, dst, code); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Threshold</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thresh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxval, ThresholdType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Threshold(src, dst, thresh, maxval, type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThresholdStairs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(src.Rows, src.Cols, src.Type()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> partCount = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> partWidth = src.Width / partCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; partCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> th_mat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Threshold(src, th_mat, <span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">10</span></span> * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">255</span></span>, ThresholdType.Binary); th_mat.Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, partWidth * i, src.Height), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>); th_mat.Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(partWidth * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, src.Width - partWidth * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), src.Height), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>); Cv2.Add(dst, th_mat, dst); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color_dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.CvtColor(dst, color_dst, ColorConversion.GrayToRgb); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; partCount; ++i) { color_dst.Line(partWidth * i, <span class="hljs-number"><span class="hljs-number">0</span></span>, partWidth * i, src.Height, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CvScalar(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), thickness: <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color_dst; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">With_Title</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat mat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(mat.ToIplImage(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); res.Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(res.Width / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> + text.Length * <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>); res.PutText(text, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCvSharp.CPlusPlus.Point(res.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), FontFace.HersheyComplex, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scalar(<span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(); Cv2.Resize(src, dst, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCvSharp.CPlusPlus.Size((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(src.Width * k), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(src.Height * k))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cut</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat src, Rect rect</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mat(src, rect); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mat[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Split</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Mat hsv_background</span></span></span><span class="hljs-function">)</span></span> { Mat[] hsv_background_channels; Cv2.Split(hsv_background, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hsv_background_channels); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hsv_background_channels; } }</code> </pre></div></div><br><br><hr>  <a href="http://habrahabr.ru/post/214955/">Boat for DirectX-arcade.</a>  <a href="http://habrahabr.ru/post/214955/">Part number 1: make contact</a> <br>  <a href="http://habrahabr.ru/post/216757/">Boat for the arcade.</a>  <a href="http://habrahabr.ru/post/216757/">Part number 2: connect OpenCV</a> <hr></div><p>Source: <a href="https://habr.com/ru/post/216757/">https://habr.com/ru/post/216757/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216743/index.html">Build-traffic light: the story of another introduction</a></li>
<li><a href="../216747/index.html">In a major anti-piracy campaign, the BSA used "pirated" photo</a></li>
<li><a href="../216751/index.html">HTTP Strict-Transport-Security or how to protect yourself from man-in-the-middle attacks and force the browser to always use HTTPS</a></li>
<li><a href="../216753/index.html">Transformation of backup storage technologies: software products and data deduplication devices</a></li>
<li><a href="../216755/index.html">Useful materials for mobile developer # 45 (March 17-23)</a></li>
<li><a href="../216759/index.html">Building FreeType2 for iOS</a></li>
<li><a href="../216765/index.html">LinkMeUp. Issue 13. Project management. Guest from Ericsson</a></li>
<li><a href="../216767/index.html">Training / gaming program for calculating the payload of the rocket based on several stages and gravitational losses</a></li>
<li><a href="../216771/index.html">New York Times: NSA has had access to Huawei server hardware for several years</a></li>
<li><a href="../216773/index.html">How your tweets reveal your location</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>