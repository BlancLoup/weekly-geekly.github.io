<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Error handling in Go: Defer, Panic and Recover</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Go language uses the usual methods of controlling the flow of execution: if, for, switch, goto. There is also a go statement to run the code in a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Error handling in Go: Defer, Panic and Recover</h1><div class="post__text post__text-html js-mediator-article">  The Go language uses the usual methods of controlling the flow of execution: if, for, switch, goto.  There is also a go statement to run the code in a separate go-procedure.  And now I would like to discuss less common ways: defer, panic and recover. <br><br>  The <b>defer</b> command places a function call on the list.  This list of deferred calls is executed after the enclosing function completes execution.  Defer is usually used to simplify the functions that deal with the release of a resource. <br><br>  For example, look at a function that opens two files and copies the contents from one file to another: <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <font><font color="#804040"><b>func</b></font> CopyFile (dstName, srcName <font color="#2e8b57"><b>string</b></font> ) (written <font color="#2e8b57"><b>int64</b></font> , err <font color="#2e8b57"><b>os.Error</b></font> ) {</font> <font><br></font>  <font>src, err: = os.Open (srcName, os.O_RDONLY, <font color="#ff00ff">0</font> )</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> err! = <font color="#804040"><b>nil</b></font> {</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br><br></font>  <font>dst, err: = os.Open (dstName, os.O_WRONLY | os.O_CREATE, <font color="#ff00ff">0644</font> )</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> err! = <font color="#804040"><b>nil</b></font> {</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br><br></font>  <font>written, err = io.Copy (dst, src)</font> <font><br></font>  <font>dst.Close ()</font> <font><br></font>  <font>src.Close ()</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  The code is working, but there is an error.  If the second os.Open call fails, the function will terminate, leaving the first file open.  This is easily fixed by adding the src.Close () call before the second return, but if the function is more complicated, then this problem can be missed.  Entering defer commands, you can make the files close under any conditions: <br><br>  <font><font color="#804040"><b>func</b></font> CopyFile (dstName, srcName <font color="#2e8b57"><b>string</b></font> ) (written <font color="#2e8b57"><b>int64</b></font> , err <font color="#2e8b57"><b>os.Error</b></font> ) {</font> <font><br></font>  <font>src, err: = os.Open (srcName, os.O_RDONLY, <font color="#ff00ff">0</font> )</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> err! = <font color="#804040"><b>nil</b></font> {</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> src.Close ()</font> <font><br><br></font>  <font>dst, err: = os.Open (dstName, os.O_WRONLY | os.O_CREATE, <font color="#ff00ff">0644</font> )</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> err! = <font color="#804040"><b>nil</b></font> {</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> dst.Close ()</font> <font><br><br></font>  <font><font color="#804040"><b>return</b></font> io.Copy (dst, src)</font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  The defer command allows you to think about closing the file immediately after opening it, ensuring that the file <i>is</i> closed, regardless of the number of exit points from the function. <br><br>  The behavior of defer commands is simple and predictable.  There are three easy rules: <br><br>  1. <i>The deferred function call arguments are evaluated when the defer command is evaluated.</i> <br><br>  In this example, the expression "i" is evaluated when the Println call is deferred.  A delayed call will print ‚Äú0‚Äù after returning from the function. <br><br>  <font><font color="#804040"><b>func</b></font> a () {</font> <font><br></font>  <font>i: = <font color="#ff00ff">0</font></font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> fmt.Println (i)</font> <font><br></font>  <font>i ++</font> <font><br></font>  <font><font color="#804040"><b>return</b></font></font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  2. <i>Deferred function calls are made in the LIFO order: the last deferred call will be called first - after the enclosing function completes execution.</i> <br><br>  This function will print "3210": <br><br>  <font><font color="#804040"><b>func</b></font> b () {</font> <font><br></font>  <font><font color="#804040"><b>for</b></font> i: = <font color="#ff00ff">0</font> ;</font>  <font>i &lt; <font color="#ff00ff">4</font> ;</font>  <font>i ++ {</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> fmt.Print (i)</font> <font><br></font>  <font>}</font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  3. <i>Deferred functions can read and set the named return values ‚Äã‚Äãof the enclosing function.</i> <br><br>  In this example, the deferred function increases the return value i after the enclosing function completes execution.  So, this function returns 2: <br><br>  <font><font color="#804040"><b>func</b></font> c () (i <font color="#2e8b57"><b>int</b></font> ) {</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> <font color="#2e8b57"><b>func</b></font> () {i ++} ()</font> <font><br></font>  <font><font color="#804040"><b>return</b></font> <font color="#ff00ff">1</font></font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  This is a convenient way to change the error code returned by a function.  Soon we will see an example of this. <br><br>  <b>Panic</b> is a built-in function that stops the normal flow of control and starts panicking.  When the function F calls panic, the execution of F stops, all pending calls to F are executed normally, then F returns control to the calling function.  For the calling function, calling F behaves like calling panic.  The process continues up the stack until all functions in the current go procedure complete the execution, after which the program crashes.  Panic can be caused by a direct call to panic, as well as due to runtime errors, such as access outside the array. <br><br>  <b>Recover</b> is a built-in function that regains control over a panicked go procedure.  Recover is only useful inside a deferred function call.  During normal execution, recover returns nil and has no other effects.  If the current go procedure panics, then the call to recover returns the value that was passed to panic and restores normal execution. <br><br>  Here is an example program that demonstrates the panic and defer mechanics: <br><br>  <font><font color="#804040"><b>package</b></font> main</font> <font><br><br></font>  <font><font color="#804040"><b>import</b></font> <font color="#ff00ff">"fmt"</font></font> <font><br><br></font>  <font><font color="#804040"><b>func</b></font> main () {</font> <font><br></font>  <font>f ()</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Returned normally from f."</font> )</font> <font><br></font>  <font>}</font> <font><br><br></font>  <font><font color="#804040"><b>func</b></font> f () {</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> <font color="#2e8b57"><b>func</b></font> () {</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> r: = <font color="#804040"><b>recover</b></font> ();</font>  <font>r! = <font color="#804040"><b>nil</b></font> {</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Recovered in f"</font> , r)</font> <font><br></font>  <font>}</font> <font><br></font>  <font>} ()</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Calling g."</font> )</font> <font><br></font>  <font>g ( <font color="#ff00ff">0</font> )</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Returned normally from g."</font> )</font> <font><br></font>  <font>}</font> <font><br><br></font>  <font><font color="#804040"><b>func</b></font> g (i <font color="#2e8b57"><b>int</b></font> ) {</font> <font><br></font>  <font><font color="#804040"><b>if</b></font> i&gt; <font color="#ff00ff">3</font> {</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Panicking!"</font> )</font> <font><br></font>  <font><font color="#804040"><b>panic</b></font> (fmt.Sprintf ( <font color="#ff00ff">"% v"</font> , i))</font> <font><br></font>  <font>}</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> fmt.Println ( <font color="#ff00ff">"Defer in g"</font> , i)</font> <font><br></font>  <font>fmt.Println ( <font color="#ff00ff">"Printing in g"</font> , i)</font> <font><br></font>  <font>g (i + <font color="#ff00ff">1</font> )</font> <font><br></font>  <font>}</font> <font><br></font> <br><br>  The function g takes the integer i as an input and panics if i is greater than 3, or it will wind itself with the argument i + 1.  The f function defers the function that calls recover and prints the restored value (if it is not empty).  Try to imagine what this program will display before reading further. <br><br>  The program will output: <br><pre> Calling g.
 Printing in g 0
 Printing in g 1
 Printing in g 2
 Printing in g 3
 Panicking!
 Defer in g 3
 Defer in g 2
 Defer in g 1
 Defer in g 0
 Recovered in f 4
 Returned normally from f. </pre><br><br>  If we remove the deferred function call from f, then the panic does not stop and reaches the top of the call stack of the go procedure, stopping the program.  So the modified program will output: <br><br><pre> Calling g.
 Printing in g 0
 Printing in g 1
 Printing in g 2
 Printing in g 3
 Panicking!
 Defer in g 3
 Defer in g 2
 Defer in g 1
 Defer in g 0
 panic: 4
 
 panic PC = 0x2a9cd8
 [Call stack omitted]
</pre><br><br>  For a real example of using <b>panic</b> and <b>recover,</b> see <a href="http://golang.org/pkg/json/">the json package</a> from the standard Go library.  It decodes JSON encoded data using a set of recursive functions.  When an incorrectly generated JSON arrives at the input, the parser calls panic to expand the stack to the top call, which recovers from the panic and returns the appropriate error code (see the ‚Äúerror‚Äù and ‚Äúunmarshal‚Äù <a href="">functions</a> in <a href="">decode.go</a> ).  A similar example of such a technique is in the <a href="http://golang.org/pkg/regexp/">Compile</a> procedure of the <a href="http://golang.org/pkg/regexp/">regexp</a> package.  There is an agreement that in Go libraries, even if the package uses panic inside, its external API returns explicit error codes. <br><br>  Other uses of <b>defer</b> (besides the above file.Close () example) include releasing the mutex: <br><br>  <font>mu.Lock ()</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> mu.Unlock ()</font> <font><br></font> <br>  print footer: <br><br>  <font>printHeader ()</font> <font><br></font>  <font><font color="#804040"><b>defer</b></font> printFooter ()</font> <font><br></font> <br><br>  And much more. <br><br>  In summary, the defer command (with or without panic and recover) provides an unusual and powerful mechanism for controlling the flow of execution.  It can be used to simulate various possibilities, which are responsible for special structures in other programming languages.  Try it. <br><br>  PS Comments on typos and other inaccuracies, please communicate by personal messages, as for various reasons I can only correct them in the evening. </div><p>Source: <a href="https://habr.com/ru/post/118898/">https://habr.com/ru/post/118898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118889/index.html">Google added Flash support in Instant Preview</a></li>
<li><a href="../118892/index.html">News 2.0.1-beta</a></li>
<li><a href="../118893/index.html">Clouds for a regular user</a></li>
<li><a href="../118894/index.html">FreeBSD versus GRUB</a></li>
<li><a href="../118897/index.html">Writing a simple web browser plugin using FireBreath</a></li>
<li><a href="../118901/index.html">The need for a long rest: another trap when planning time</a></li>
<li><a href="../118902/index.html">Standard_Test_Treating_Long_Title</a></li>
<li><a href="../118903/index.html">How to study correctly?</a></li>
<li><a href="../118905/index.html">Facebook's main mobile developer left the company</a></li>
<li><a href="../118906/index.html">From Ubuntu to Fedora - we land on foreign land (good, bad and ugly)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>